var y0 = Object.defineProperty
var mH = Object.getOwnPropertyDescriptor
var I0 = (o) => {
	throw TypeError(o)
}
var fH = (o, e) => {
	for (var t in e) y0(o, t, { get: e[t], enumerable: !0 })
}
var R = (o, e, t, n) => {
		for (var r = n > 1 ? void 0 : n ? mH(e, t) : e, i = o.length - 1, s; i >= 0; i--)
			(s = o[i]) && (r = (n ? s(e, t, r) : s(r)) || r)
		return n && r && y0(e, t, r), r
	},
	S = (o, e) => (t, n) => e(t, n, o)
var FT = (o, e, t) => e.has(o) || I0("Cannot " + t)
var sn = (o, e, t) => (FT(o, e, "read from private field"), t ? t.call(o) : e.get(o)),
	qm = (o, e, t) =>
		e.has(o)
			? I0("Cannot add the same private member more than once")
			: e instanceof WeakSet
				? e.add(o)
				: e.set(o, t),
	Kh = (o, e, t, n) => (FT(o, e, "write to private field"), n ? n.call(o, t) : e.set(o, t), t),
	Km = (o, e, t) => (FT(o, e, "access private method"), t)
import GU from "net"
import v6 from "minimist"
import * as qU from "net"
function sc(o, e) {
	let t = Object.create(null)
	for (let n of o) {
		let r = e(n),
			i = t[r]
		i || (i = t[r] = []), i.push(n)
	}
	return t
}
function NT(o, e) {
	let t = [],
		n = []
	for (let r of o) e.has(r) || t.push(r)
	for (let r of e) o.has(r) || n.push(r)
	return { removed: t, added: n }
}
var C0,
	S0,
	x0 = class {
		constructor(e, t) {
			this.toKey = t
			this._map = new Map()
			this[C0] = "SetWithKey"
			for (let n of e) this.add(n)
		}
		get size() {
			return this._map.size
		}
		add(e) {
			let t = this.toKey(e)
			return this._map.set(t, e), this
		}
		delete(e) {
			return this._map.delete(this.toKey(e))
		}
		has(e) {
			return this._map.has(this.toKey(e))
		}
		*entries() {
			for (let e of this._map.values()) yield [e, e]
		}
		keys() {
			return this.values()
		}
		*values() {
			for (let e of this._map.values()) yield e
		}
		clear() {
			this._map.clear()
		}
		forEach(e, t) {
			this._map.forEach((n) => e.call(t, n, n, this))
		}
		[((S0 = Symbol.iterator), (C0 = Symbol.toStringTag), S0)]() {
			return this.values()
		}
	}
var UT = class {
		constructor() {
			;(this.listeners = []),
				(this.unexpectedErrorHandler = function (e) {
					setTimeout(() => {
						throw e.stack
							? Kn.isErrorNoTelemetry(e)
								? new Kn(
										e.message +
											`

` +
											e.stack,
									)
								: new Error(
										e.message +
											`

` +
											e.stack,
									)
							: e
					}, 0)
				})
		}
		addListener(e) {
			return (
				this.listeners.push(e),
				() => {
					this._removeListener(e)
				}
			)
		}
		emit(e) {
			this.listeners.forEach((t) => {
				t(e)
			})
		}
		_removeListener(e) {
			this.listeners.splice(this.listeners.indexOf(e), 1)
		}
		setUnexpectedErrorHandler(e) {
			this.unexpectedErrorHandler = e
		}
		getUnexpectedErrorHandler() {
			return this.unexpectedErrorHandler
		}
		onUnexpectedError(e) {
			this.unexpectedErrorHandler(e), this.emit(e)
		}
		onUnexpectedExternalError(e) {
			this.unexpectedErrorHandler(e)
		}
	},
	ac = new UT()
function jm(o) {
	ac.setUnexpectedErrorHandler(o)
}
function T0(o) {
	if (!o || typeof o != "object") return !1
	let e = o
	return e.code === "EPIPE" && e.syscall?.toUpperCase() === "WRITE"
}
function Tl(o) {
	ac.onUnexpectedError(o)
}
function Be(o) {
	bn(o) || ac.onUnexpectedError(o)
}
function Qh(o) {
	bn(o) || ac.onUnexpectedExternalError(o)
}
function Po(o) {
	if (o instanceof Error) {
		let { name: e, message: t, cause: n } = o,
			r = o.stacktrace || o.stack
		return {
			$isError: !0,
			name: e,
			message: t,
			stack: r,
			noTelemetry: Kn.isErrorNoTelemetry(o),
			cause: n ? Po(n) : void 0,
			code: o.code,
		}
	}
	return o
}
function HT(o) {
	let e
	return (
		o.noTelemetry ? (e = new Kn()) : ((e = new Error()), (e.name = o.name)),
		(e.message = o.message),
		(e.stack = o.stack),
		o.code && (e.code = o.code),
		o.cause && (e.cause = HT(o.cause)),
		e
	)
}
var jh = "Canceled"
function bn(o) {
	return o instanceof xt ? !0 : o instanceof Error && o.name === jh && o.message === jh
}
var xt = class extends Error {
	constructor() {
		super(jh), (this.name = this.message)
	}
}
function $i() {
	let o = new Error(jh)
	return (o.name = o.message), o
}
function We(o) {
	return o ? new Error(`Illegal argument: ${o}`) : new Error("Illegal argument")
}
function lc(o) {
	return o ? new Error(`Illegal state: ${o}`) : new Error("Illegal state")
}
var wo = class extends TypeError {
	constructor(e) {
		super(e ? `${e} is read-only and cannot be changed` : "Cannot change read-only property")
	}
}
function Gm(o) {
	return o
		? o.message
			? o.message
			: o.stack
				? o.stack.split(`
`)[0]
				: String(o)
		: "Error"
}
var Gh = class extends Error {
		constructor(e) {
			super("NotImplemented"), e && (this.message = e)
		}
	},
	Sl = class extends Error {
		constructor(e) {
			super("NotSupported"), e && (this.message = e)
		}
	}
var Kn = class o extends Error {
		constructor(e) {
			super(e), (this.name = "CodeExpectedError")
		}
		static fromError(e) {
			if (e instanceof o) return e
			let t = new o()
			return (t.message = e.message), (t.stack = e.stack), t
		}
		static isErrorNoTelemetry(e) {
			return e.name === "CodeExpectedError"
		}
	},
	Gt = class o extends Error {
		constructor(e) {
			super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, o.prototype)
		}
	}
function zi(o, e) {
	let t = this,
		n = !1,
		r
	return function () {
		if (n) return r
		if (((n = !0), e))
			try {
				r = o.apply(t, arguments)
			} finally {
				e()
			}
		else r = o.apply(t, arguments)
		return r
	}
}
function w0(o, e, t = o.length - 1) {
	let n = hH(o, e, t)
	if (n !== -1) return o[n]
}
function hH(o, e, t = o.length - 1) {
	for (let n = t; n >= 0; n--) {
		let r = o[n]
		if (e(r)) return n
	}
	return -1
}
function vH(o, e, t = 0, n = o.length) {
	let r = t,
		i = n
	for (; r < i; ) {
		let s = Math.floor((r + i) / 2)
		e(o[s]) ? (r = s + 1) : (i = s)
	}
	return r - 1
}
function P0(o, e, t = 0, n = o.length) {
	let r = t,
		i = n
	for (; r < i; ) {
		let s = Math.floor((r + i) / 2)
		e(o[s]) ? (i = s) : (r = s + 1)
	}
	return r
}
var E0 = class o {
	constructor(e) {
		this._array = e
		this._findLastMonotonousLastIdx = 0
	}
	static {
		this.assertInvariants = !1
	}
	findLastMonotonous(e) {
		if (o.assertInvariants) {
			if (this._prevFindLastPredicate) {
				for (let n of this._array)
					if (this._prevFindLastPredicate(n) && !e(n))
						throw new Error(
							"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.",
						)
			}
			this._prevFindLastPredicate = e
		}
		let t = vH(this._array, e, this._findLastMonotonousLastIdx)
		return (this._findLastMonotonousLastIdx = t + 1), t === -1 ? void 0 : this._array[t]
	}
}
function mn(o, e, t = (n, r) => n === r) {
	if (o === e) return !0
	if (!o || !e || o.length !== e.length) return !1
	for (let n = 0, r = o.length; n < r; n++) if (!t(o[n], e[n])) return !1
	return !0
}
function D0(o, e) {
	let t = [],
		n
	for (let r of o.slice(0).sort(e)) !n || e(n[0], r) !== 0 ? ((n = [r]), t.push(n)) : n.push(r)
	return t
}
function WT(o, e, t) {
	let n = []
	function r(a, l, d) {
		if (l === 0 && d.length === 0) return
		let c = n[n.length - 1]
		c && c.start + c.deleteCount === a
			? ((c.deleteCount += l), c.toInsert.push(...d))
			: n.push({ start: a, deleteCount: l, toInsert: d })
	}
	let i = 0,
		s = 0
	for (;;) {
		if (i === o.length) {
			r(i, 0, e.slice(s))
			break
		}
		if (s === e.length) {
			r(i, o.length - i, [])
			break
		}
		let a = o[i],
			l = e[s],
			d = t(a, l)
		d === 0 ? ((i += 1), (s += 1)) : d < 0 ? (r(i, 1, []), (i += 1)) : d > 0 && (r(i, 0, [l]), (s += 1))
	}
	return n
}
function k0(o, e, t) {
	let n = WT(o, e, t),
		r = [],
		i = []
	for (let s of n) r.push(...o.slice(s.start, s.start + s.deleteCount)), i.push(...s.toInsert)
	return { removed: r, added: i }
}
function R0(o, e, t, n, r) {
	return t === 0
		? Promise.resolve([])
		: new Promise((i, s) => {
				;(async () => {
					let a = o.length,
						l = o.slice(0, t).sort(e)
					for (let d = t, c = Math.min(t + n, a); d < a; d = c, c = Math.min(c + n, a)) {
						if ((d > t && (await new Promise((u) => setTimeout(u))), r && r.isCancellationRequested))
							throw new xt()
						bH(o, e, l, d, c)
					}
					return l
				})().then(i, s)
			})
}
function bH(o, e, t, n, r) {
	for (let i = t.length; n < r; n++) {
		let s = o[n]
		if (e(s, t[i - 1]) < 0) {
			t.pop()
			let a = P0(t, (l) => e(s, l) < 0)
			t.splice(a, 0, s)
		}
	}
}
function Ye(o) {
	return o.filter((e) => !!e)
}
function A0(o) {
	let e = 0
	for (let t = 0; t < o.length; t++) o[t] && ((o[e] = o[t]), (e += 1))
	o.length = e
}
function Qm(o) {
	return !Array.isArray(o) || o.length === 0
}
function ri(o) {
	return Array.isArray(o) && o.length > 0
}
function oi(o, e = (t) => t) {
	let t = new Set()
	return o.filter((n) => {
		let r = e(n)
		return t.has(r) ? !1 : (t.add(r), !0)
	})
}
function VT(o, e) {
	return o.push(e), () => yH(o, e)
}
function yH(o, e) {
	let t = o.indexOf(e)
	if (t > -1) return o.splice(t, 1), e
}
function BT(o, e) {
	let t
	if (typeof e == "number") {
		let n = e
		t = () => {
			let r = Math.sin(n++) * 179426549
			return r - Math.floor(r)
		}
	} else t = Math.random
	for (let n = o.length - 1; n > 0; n -= 1) {
		let r = Math.floor(t() * (n + 1)),
			i = o[n]
		;(o[n] = o[r]), (o[r] = i)
	}
}
function El(o, e) {
	return Array.isArray(o) ? o.map(e) : e(o)
}
function an(o) {
	return Array.isArray(o) ? o : [o]
}
var O0
;((a) => {
	function o(l) {
		return l < 0
	}
	a.isLessThan = o
	function e(l) {
		return l <= 0
	}
	a.isLessThanOrEqual = e
	function t(l) {
		return l > 0
	}
	a.isGreaterThan = t
	function n(l) {
		return l === 0
	}
	;(a.isNeitherLessOrGreaterThan = n), (a.greaterThan = 1), (a.lessThan = -1), (a.neitherLessOrGreaterThan = 0)
})((O0 ||= {}))
function L0(o, e) {
	return (t, n) => e(o(t), o(n))
}
var M0 = (o, e) => o - e
var _0 = class o {
	constructor(e) {
		this.iterate = e
	}
	static {
		this.empty = new o((e) => {})
	}
	forEach(e) {
		this.iterate((t) => (e(t), !0))
	}
	toArray() {
		let e = []
		return this.iterate((t) => (e.push(t), !0)), e
	}
	filter(e) {
		return new o((t) => this.iterate((n) => (e(n) ? t(n) : !0)))
	}
	map(e) {
		return new o((t) => this.iterate((n) => t(e(n))))
	}
	some(e) {
		let t = !1
		return this.iterate((n) => ((t = e(n)), !t)), t
	}
	findFirst(e) {
		let t
		return this.iterate((n) => (e(n) ? ((t = n), !1) : !0)), t
	}
	findLast(e) {
		let t
		return this.iterate((n) => (e(n) && (t = n), !0)), t
	}
	findLastMaxBy(e) {
		let t,
			n = !0
		return this.iterate((r) => ((n || O0.isGreaterThan(e(r, t))) && ((n = !1), (t = r)), !0)), t
	}
}
function KT(o, e, t) {
	let n = o.get(e)
	return n === void 0 && ((n = t), o.set(e, n)), n
}
var $T = class {
	constructor(e, t) {
		this.uri = e
		this.value = t
	}
}
function IH(o) {
	return Array.isArray(o)
}
var F0,
	ft = class o {
		constructor(e, t) {
			this[F0] = "ResourceMap"
			if (e instanceof o) (this.map = new Map(e.map)), (this.toKey = t ?? o.defaultToKey)
			else if (IH(e)) {
				;(this.map = new Map()), (this.toKey = t ?? o.defaultToKey)
				for (let [n, r] of e) this.set(n, r)
			} else (this.map = new Map()), (this.toKey = e ?? o.defaultToKey)
		}
		static {
			this.defaultToKey = (e) => e.toString()
		}
		set(e, t) {
			return this.map.set(this.toKey(e), new $T(e, t)), this
		}
		get(e) {
			return this.map.get(this.toKey(e))?.value
		}
		has(e) {
			return this.map.has(this.toKey(e))
		}
		get size() {
			return this.map.size
		}
		clear() {
			this.map.clear()
		}
		delete(e) {
			return this.map.delete(this.toKey(e))
		}
		forEach(e, t) {
			typeof t < "u" && (e = e.bind(t))
			for (let [n, r] of this.map) e(r.value, r.uri, this)
		}
		*values() {
			for (let e of this.map.values()) yield e.value
		}
		*keys() {
			for (let e of this.map.values()) yield e.uri
		}
		*entries() {
			for (let e of this.map.values()) yield [e.uri, e.value]
		}
		*[((F0 = Symbol.toStringTag), Symbol.iterator)]() {
			for (let [, e] of this.map) yield [e.uri, e.value]
		}
	},
	N0,
	dc = class {
		constructor(e, t) {
			this[N0] = "ResourceSet"
			!e || typeof e == "function"
				? (this._map = new ft(e))
				: ((this._map = new ft(t)), e.forEach(this.add, this))
		}
		get size() {
			return this._map.size
		}
		add(e) {
			return this._map.set(e, e), this
		}
		clear() {
			this._map.clear()
		}
		delete(e) {
			return this._map.delete(e)
		}
		forEach(e, t) {
			this._map.forEach((n, r) => e.call(t, r, r, this))
		}
		has(e) {
			return this._map.has(e)
		}
		entries() {
			return this._map.entries()
		}
		keys() {
			return this._map.keys()
		}
		values() {
			return this._map.keys()
		}
		[((N0 = Symbol.toStringTag), Symbol.iterator)]() {
			return this.keys()
		}
	}
var U0,
	zT = class {
		constructor() {
			this[U0] = "LinkedMap"
			;(this._map = new Map()), (this._head = void 0), (this._tail = void 0), (this._size = 0), (this._state = 0)
		}
		clear() {
			this._map.clear(), (this._head = void 0), (this._tail = void 0), (this._size = 0), this._state++
		}
		isEmpty() {
			return !this._head && !this._tail
		}
		get size() {
			return this._size
		}
		get first() {
			return this._head?.value
		}
		get last() {
			return this._tail?.value
		}
		has(e) {
			return this._map.has(e)
		}
		get(e, t = 0) {
			let n = this._map.get(e)
			if (n) return t !== 0 && this.touch(n, t), n.value
		}
		set(e, t, n = 0) {
			let r = this._map.get(e)
			if (r) (r.value = t), n !== 0 && this.touch(r, n)
			else {
				switch (((r = { key: e, value: t, next: void 0, previous: void 0 }), n)) {
					case 0:
						this.addItemLast(r)
						break
					case 1:
						this.addItemFirst(r)
						break
					case 2:
						this.addItemLast(r)
						break
					default:
						this.addItemLast(r)
						break
				}
				this._map.set(e, r), this._size++
			}
			return this
		}
		delete(e) {
			return !!this.remove(e)
		}
		remove(e) {
			let t = this._map.get(e)
			if (t) return this._map.delete(e), this.removeItem(t), this._size--, t.value
		}
		shift() {
			if (!this._head && !this._tail) return
			if (!this._head || !this._tail) throw new Error("Invalid list")
			let e = this._head
			return this._map.delete(e.key), this.removeItem(e), this._size--, e.value
		}
		forEach(e, t) {
			let n = this._state,
				r = this._head
			for (; r; ) {
				if ((t ? e.bind(t)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== n))
					throw new Error("LinkedMap got modified during iteration.")
				r = r.next
			}
		}
		keys() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: n.key, done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		values() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: n.value, done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		entries() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: [n.key, n.value], done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		[((U0 = Symbol.toStringTag), Symbol.iterator)]() {
			return this.entries()
		}
		trimOld(e) {
			if (e >= this.size) return
			if (e === 0) {
				this.clear()
				return
			}
			let t = this._head,
				n = this.size
			for (; t && n > e; ) this._map.delete(t.key), (t = t.next), n--
			;(this._head = t), (this._size = n), t && (t.previous = void 0), this._state++
		}
		trimNew(e) {
			if (e >= this.size) return
			if (e === 0) {
				this.clear()
				return
			}
			let t = this._tail,
				n = this.size
			for (; t && n > e; ) this._map.delete(t.key), (t = t.previous), n--
			;(this._tail = t), (this._size = n), t && (t.next = void 0), this._state++
		}
		addItemFirst(e) {
			if (!this._head && !this._tail) this._tail = e
			else if (this._head) (e.next = this._head), (this._head.previous = e)
			else throw new Error("Invalid list")
			;(this._head = e), this._state++
		}
		addItemLast(e) {
			if (!this._head && !this._tail) this._head = e
			else if (this._tail) (e.previous = this._tail), (this._tail.next = e)
			else throw new Error("Invalid list")
			;(this._tail = e), this._state++
		}
		removeItem(e) {
			if (e === this._head && e === this._tail) (this._head = void 0), (this._tail = void 0)
			else if (e === this._head) {
				if (!e.next) throw new Error("Invalid list")
				;(e.next.previous = void 0), (this._head = e.next)
			} else if (e === this._tail) {
				if (!e.previous) throw new Error("Invalid list")
				;(e.previous.next = void 0), (this._tail = e.previous)
			} else {
				let t = e.next,
					n = e.previous
				if (!t || !n) throw new Error("Invalid list")
				;(t.previous = n), (n.next = t)
			}
			;(e.next = void 0), (e.previous = void 0), this._state++
		}
		touch(e, t) {
			if (!this._head || !this._tail) throw new Error("Invalid list")
			if (!(t !== 1 && t !== 2)) {
				if (t === 1) {
					if (e === this._head) return
					let n = e.next,
						r = e.previous
					e === this._tail ? ((r.next = void 0), (this._tail = r)) : ((n.previous = r), (r.next = n)),
						(e.previous = void 0),
						(e.next = this._head),
						(this._head.previous = e),
						(this._head = e),
						this._state++
				} else if (t === 2) {
					if (e === this._tail) return
					let n = e.next,
						r = e.previous
					e === this._head ? ((n.previous = void 0), (this._head = n)) : ((n.previous = r), (r.next = n)),
						(e.next = void 0),
						(e.previous = this._tail),
						(this._tail.next = e),
						(this._tail = e),
						this._state++
				}
			}
		}
		toJSON() {
			let e = []
			return (
				this.forEach((t, n) => {
					e.push([n, t])
				}),
				e
			)
		}
		fromJSON(e) {
			this.clear()
			for (let [t, n] of e) this.set(t, n)
		}
	},
	qT = class extends zT {
		constructor(e, t = 1) {
			super(), (this._limit = e), (this._ratio = Math.min(Math.max(0, t), 1))
		}
		get limit() {
			return this._limit
		}
		set limit(e) {
			;(this._limit = e), this.checkTrim()
		}
		get ratio() {
			return this._ratio
		}
		set ratio(e) {
			;(this._ratio = Math.min(Math.max(0, e), 1)), this.checkTrim()
		}
		get(e, t = 2) {
			return super.get(e, t)
		}
		peek(e) {
			return super.get(e, 0)
		}
		set(e, t) {
			return super.set(e, t, 2), this
		}
		checkTrim() {
			this.size > this._limit && this.trim(Math.round(this._limit * this._ratio))
		}
	},
	_o = class extends qT {
		constructor(e, t = 1) {
			super(e, t)
		}
		trim(e) {
			this.trimOld(e)
		}
		set(e, t) {
			return super.set(e, t), this.checkTrim(), this
		}
	}
var Jh = class {
		constructor(e) {
			this._m1 = new Map()
			this._m2 = new Map()
			if (e) for (let [t, n] of e) this.set(t, n)
		}
		clear() {
			this._m1.clear(), this._m2.clear()
		}
		set(e, t) {
			this._m1.set(e, t), this._m2.set(t, e)
		}
		get(e) {
			return this._m1.get(e)
		}
		getKey(e) {
			return this._m2.get(e)
		}
		delete(e) {
			let t = this._m1.get(e)
			return t === void 0 ? !1 : (this._m1.delete(e), this._m2.delete(t), !0)
		}
		forEach(e, t) {
			this._m1.forEach((n, r) => {
				e.call(t, n, r, this)
			})
		}
		keys() {
			return this._m1.keys()
		}
		values() {
			return this._m1.values()
		}
	},
	cc = class {
		constructor() {
			this.map = new Map()
		}
		add(e, t) {
			let n = this.map.get(e)
			n || ((n = new Set()), this.map.set(e, n)), n.add(t)
		}
		delete(e, t) {
			let n = this.map.get(e)
			n && (n.delete(t), n.size === 0 && this.map.delete(e))
		}
		forEach(e, t) {
			let n = this.map.get(e)
			n && n.forEach(t)
		}
		get(e) {
			let t = this.map.get(e)
			return t || new Set()
		}
	}
function yn(o, e) {
	if (!o) throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed")
}
function uc(o, e = "Unreachable") {
	throw new Error(e)
}
function pc(o, e = "unexpected state") {
	if (!o) throw typeof e == "string" ? new Gt(`Assertion Failed: ${e}`) : e
}
function Jm(o) {
	if (!o()) {
		debugger
		o(), Be(new Gt("Assertion Failed"))
	}
}
function Ee(o) {
	return typeof o == "string"
}
function W0(o) {
	return Array.isArray(o) && o.every((e) => Ee(e))
}
function dt(o) {
	return typeof o == "object" && o !== null && !Array.isArray(o) && !(o instanceof RegExp) && !(o instanceof Date)
}
function V0(o) {
	let e = Object.getPrototypeOf(Uint8Array)
	return typeof o == "object" && o instanceof e
}
function fn(o) {
	return typeof o == "number" && !isNaN(o)
}
function B0(o) {
	return !!o && typeof o[Symbol.iterator] == "function"
}
function Xh(o) {
	return o === !0 || o === !1
}
function mc(o) {
	return typeof o > "u"
}
function rr(o) {
	return !bt(o)
}
function bt(o) {
	return mc(o) || o === null
}
function fc(o, e) {
	if (!o) throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type")
}
function Do(o) {
	return pc(o != null, "Argument is `undefined` or `null`."), o
}
var xH = Object.prototype.hasOwnProperty
function Yh(o) {
	if (!dt(o)) return !1
	for (let e in o) if (xH.call(o, e)) return !1
	return !0
}
function $0(o) {
	return typeof o == "function"
}
function z0(o, e) {
	if (Ee(e)) {
		if (typeof o !== e) throw new Error(`argument does not match constraint: typeof ${e}`)
	} else if ($0(e)) {
		try {
			if (o instanceof e) return
		} catch {}
		if ((!bt(o) && o.constructor === e) || (e.length === 1 && e.call(void 0, o) === !0)) return
		throw new Error(
			"argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true",
		)
	}
}
var kt
;((L) => {
	function o(A) {
		return A && typeof A == "object" && typeof A[Symbol.iterator] == "function"
	}
	L.is = o
	let e = Object.freeze([])
	function t() {
		return e
	}
	L.empty = t
	function* n(A) {
		yield A
	}
	L.single = n
	function r(A) {
		return o(A) ? A : n(A)
	}
	L.wrap = r
	function i(A) {
		return A || e
	}
	L.from = i
	function* s(A) {
		for (let J = A.length - 1; J >= 0; J--) yield A[J]
	}
	L.reverse = s
	function a(A) {
		return !A || A[Symbol.iterator]().next().done === !0
	}
	L.isEmpty = a
	function l(A) {
		return A[Symbol.iterator]().next().value
	}
	L.first = l
	function d(A, J) {
		let ne = 0
		for (let oe of A) if (J(oe, ne++)) return !0
		return !1
	}
	L.some = d
	function c(A, J) {
		for (let ne of A) if (J(ne)) return ne
	}
	L.find = c
	function* u(A, J) {
		for (let ne of A) J(ne) && (yield ne)
	}
	L.filter = u
	function* m(A, J) {
		let ne = 0
		for (let oe of A) yield J(oe, ne++)
	}
	L.map = m
	function* f(A, J) {
		let ne = 0
		for (let oe of A) yield* J(oe, ne++)
	}
	L.flatMap = f
	function* h(...A) {
		for (let J of A) B0(J) ? yield* J : yield J
	}
	L.concat = h
	function g(A, J, ne) {
		let oe = ne
		for (let Y of A) oe = J(oe, Y)
		return oe
	}
	L.reduce = g
	function I(A) {
		let J = 0
		for (let ne of A) J++
		return J
	}
	L.length = I
	function* C(A, J, ne = A.length) {
		for (
			J < -A.length && (J = 0),
				J < 0 && (J += A.length),
				ne < 0 ? (ne += A.length) : ne > A.length && (ne = A.length);
			J < ne;
			J++
		)
			yield A[J]
	}
	L.slice = C
	function T(A, J = Number.POSITIVE_INFINITY) {
		let ne = []
		if (J === 0) return [ne, A]
		let oe = A[Symbol.iterator]()
		for (let Y = 0; Y < J; Y++) {
			let j = oe.next()
			if (j.done) return [ne, L.empty()]
			ne.push(j.value)
		}
		return [
			ne,
			{
				[Symbol.iterator]() {
					return oe
				},
			},
		]
	}
	L.consume = T
	async function w(A) {
		let J = []
		for await (let ne of A) J.push(ne)
		return Promise.resolve(J)
	}
	L.asyncToArray = w
})((kt ||= {}))
var CH = !1,
	gc = null
var q0 = class o {
	constructor() {
		this.livingDisposables = new Map()
	}
	static {
		this.idx = 0
	}
	getDisposableData(e) {
		let t = this.livingDisposables.get(e)
		return (
			t ||
				((t = { parent: null, source: null, isSingleton: !1, value: e, idx: o.idx++ }),
				this.livingDisposables.set(e, t)),
			t
		)
	}
	trackDisposable(e) {
		let t = this.getDisposableData(e)
		t.source || (t.source = new Error().stack)
	}
	setParent(e, t) {
		let n = this.getDisposableData(e)
		n.parent = t
	}
	markAsDisposed(e) {
		this.livingDisposables.delete(e)
	}
	markAsSingleton(e) {
		this.getDisposableData(e).isSingleton = !0
	}
	getRootParent(e, t) {
		let n = t.get(e)
		if (n) return n
		let r = e.parent ? this.getRootParent(this.getDisposableData(e.parent), t) : e
		return t.set(e, r), r
	}
	getTrackedDisposables() {
		let e = new Map()
		return [...this.livingDisposables.entries()]
			.filter(([, n]) => n.source !== null && !this.getRootParent(n, e).isSingleton)
			.flatMap(([n]) => n)
	}
	computeLeakingDisposables(e = 10, t) {
		let n
		if (t) n = t
		else {
			let l = new Map(),
				d = [...this.livingDisposables.values()].filter(
					(u) => u.source !== null && !this.getRootParent(u, l).isSingleton,
				)
			if (d.length === 0) return
			let c = new Set(d.map((u) => u.value))
			if (((n = d.filter((u) => !(u.parent && c.has(u.parent)))), n.length === 0))
				throw new Error("There are cyclic diposable chains!")
		}
		if (!n) return
		function r(l) {
			function d(u, m) {
				for (; u.length > 0 && m.some((f) => (typeof f == "string" ? f === u[0] : u[0].match(f))); ) u.shift()
			}
			let c = l.source
				.split(
					`
`,
				)
				.map((u) => u.trim().replace("at ", ""))
				.filter((u) => u !== "")
			return (
				d(c, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]), c.reverse()
			)
		}
		let i = new cc()
		for (let l of n) {
			let d = r(l)
			for (let c = 0; c <= d.length; c++)
				i.add(
					d.slice(0, c).join(`
`),
					l,
				)
		}
		n.sort(L0((l) => l.idx, M0))
		let s = "",
			a = 0
		for (let l of n.slice(0, e)) {
			a++
			let d = r(l),
				c = []
			for (let u = 0; u < d.length; u++) {
				let m = d[u]
				m = `(shared with ${
					i.get(
						d.slice(0, u + 1).join(`
`),
					).size
				}/${n.length} leaks) at ${m}`
				let h = i.get(
						d.slice(0, u).join(`
`),
					),
					g = sc(
						[...h].map((I) => r(I)[u]),
						(I) => I,
					)
				delete g[d[u]]
				for (let [I, C] of Object.entries(g))
					c.unshift(`    - stacktraces of ${C.length} other leaks continue with ${I}`)
				c.unshift(m)
			}
			s += `


==================== Leaking disposable ${a}/${n.length}: ${l.value.constructor.name} ====================
${c.join(`
`)}
============================================================

`
		}
		return (
			n.length > e &&
				(s += `


... and ${n.length - e} more leaking disposables

`),
			{ leaks: n, details: s }
		)
	}
}
function SH(o) {
	gc = o
}
if (CH) {
	let o = "__is_disposable_tracked__"
	SH(
		new (class {
			trackDisposable(e) {
				let t = new Error("Potentially leaked disposable").stack
				setTimeout(() => {
					e[o] || console.log(t)
				}, 3e3)
			}
			setParent(e, t) {
				if (e && e !== $.None)
					try {
						e[o] = !0
					} catch {}
			}
			markAsDisposed(e) {
				if (e && e !== $.None)
					try {
						e[o] = !0
					} catch {}
			}
			markAsSingleton(e) {}
		})(),
	)
}
function Zs(o) {
	return gc?.trackDisposable(o), o
}
function ea(o) {
	gc?.markAsDisposed(o)
}
function Xm(o, e) {
	gc?.setParent(o, e)
}
function TH(o, e) {
	if (gc) for (let t of o) gc.setParent(t, e)
}
function Zh(o) {
	return typeof o == "object" && o !== null && typeof o.dispose == "function" && o.dispose.length === 0
}
function Fn(o) {
	if (kt.is(o)) {
		let e = []
		for (let t of o)
			if (t)
				try {
					t.dispose()
				} catch (n) {
					e.push(n)
				}
		if (e.length === 1) throw e[0]
		if (e.length > 1) throw new AggregateError(e, "Encountered errors while disposing of store")
		return Array.isArray(o) ? [] : o
	} else if (o) return o.dispose(), o
}
function ev(...o) {
	let e = q(() => Fn(o))
	return TH(o, e), e
}
function q(o) {
	let e = Zs({
		dispose: zi(() => {
			ea(e), o()
		}),
	})
	return e
}
var Q = class o {
		constructor() {
			this._toDispose = new Set()
			this._isDisposed = !1
			Zs(this)
		}
		static {
			this.DISABLE_DISPOSED_WARNING = !1
		}
		dispose() {
			this._isDisposed || (ea(this), (this._isDisposed = !0), this.clear())
		}
		get isDisposed() {
			return this._isDisposed
		}
		clear() {
			if (this._toDispose.size !== 0)
				try {
					Fn(this._toDispose)
				} finally {
					this._toDispose.clear()
				}
		}
		add(e) {
			if (!e) return e
			if (e === this) throw new Error("Cannot register a disposable on itself!")
			return (
				Xm(e, this),
				this._isDisposed
					? o.DISABLE_DISPOSED_WARNING ||
						console.warn(
							new Error(
								"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!",
							).stack,
						)
					: this._toDispose.add(e),
				e
			)
		}
		delete(e) {
			if (e) {
				if (e === this) throw new Error("Cannot dispose a disposable on itself!")
				this._toDispose.delete(e), e.dispose()
			}
		}
		deleteAndLeak(e) {
			e && this._toDispose.has(e) && (this._toDispose.delete(e), Xm(e, null))
		}
	},
	$ = class {
		constructor() {
			this._store = new Q()
			Zs(this), Xm(this._store, this)
		}
		static {
			this.None = Object.freeze({ dispose() {} })
		}
		dispose() {
			ea(this), this._store.dispose()
		}
		_register(e) {
			if (e === this) throw new Error("Cannot register a disposable on itself!")
			return this._store.add(e)
		}
	},
	Dn = class {
		constructor() {
			this._isDisposed = !1
			Zs(this)
		}
		get value() {
			return this._isDisposed ? void 0 : this._value
		}
		set value(e) {
			this._isDisposed || e === this._value || (this._value?.dispose(), e && Xm(e, this), (this._value = e))
		}
		clear() {
			this.value = void 0
		}
		dispose() {
			;(this._isDisposed = !0), ea(this), this._value?.dispose(), (this._value = void 0)
		}
		clearAndLeak() {
			let e = this._value
			return (this._value = void 0), e && Xm(e, null), e
		}
	}
var Wr = class {
	constructor() {
		this._store = new Map()
		this._isDisposed = !1
		Zs(this)
	}
	dispose() {
		ea(this), (this._isDisposed = !0), this.clearAndDisposeAll()
	}
	clearAndDisposeAll() {
		if (this._store.size)
			try {
				Fn(this._store.values())
			} finally {
				this._store.clear()
			}
	}
	has(e) {
		return this._store.has(e)
	}
	get size() {
		return this._store.size
	}
	get(e) {
		return this._store.get(e)
	}
	set(e, t, n = !1) {
		this._isDisposed &&
			console.warn(
				new Error(
					"Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!",
				).stack,
			),
			n || this._store.get(e)?.dispose(),
			this._store.set(e, t)
	}
	deleteAndDispose(e) {
		this._store.get(e)?.dispose(), this._store.delete(e)
	}
	deleteAndLeak(e) {
		let t = this._store.get(e)
		return this._store.delete(e), t
	}
	keys() {
		return this._store.keys()
	}
	values() {
		return this._store.values()
	}
	[Symbol.iterator]() {
		return this._store[Symbol.iterator]()
	}
}
var $t = class o {
		static {
			this.Undefined = new o(void 0)
		}
		constructor(e) {
			;(this.element = e), (this.next = o.Undefined), (this.prev = o.Undefined)
		}
	},
	ko = class {
		constructor() {
			this._first = $t.Undefined
			this._last = $t.Undefined
			this._size = 0
		}
		get size() {
			return this._size
		}
		isEmpty() {
			return this._first === $t.Undefined
		}
		clear() {
			let e = this._first
			for (; e !== $t.Undefined; ) {
				let t = e.next
				;(e.prev = $t.Undefined), (e.next = $t.Undefined), (e = t)
			}
			;(this._first = $t.Undefined), (this._last = $t.Undefined), (this._size = 0)
		}
		unshift(e) {
			return this._insert(e, !1)
		}
		push(e) {
			return this._insert(e, !0)
		}
		_insert(e, t) {
			let n = new $t(e)
			if (this._first === $t.Undefined) (this._first = n), (this._last = n)
			else if (t) {
				let i = this._last
				;(this._last = n), (n.prev = i), (i.next = n)
			} else {
				let i = this._first
				;(this._first = n), (n.next = i), (i.prev = n)
			}
			this._size += 1
			let r = !1
			return () => {
				r || ((r = !0), this._remove(n))
			}
		}
		shift() {
			if (this._first !== $t.Undefined) {
				let e = this._first.element
				return this._remove(this._first), e
			}
		}
		pop() {
			if (this._last !== $t.Undefined) {
				let e = this._last.element
				return this._remove(this._last), e
			}
		}
		_remove(e) {
			if (e.prev !== $t.Undefined && e.next !== $t.Undefined) {
				let t = e.prev
				;(t.next = e.next), (e.next.prev = t)
			} else
				e.prev === $t.Undefined && e.next === $t.Undefined
					? ((this._first = $t.Undefined), (this._last = $t.Undefined))
					: e.next === $t.Undefined
						? ((this._last = this._last.prev), (this._last.next = $t.Undefined))
						: e.prev === $t.Undefined &&
							((this._first = this._first.next), (this._first.prev = $t.Undefined))
			this._size -= 1
		}
		*[Symbol.iterator]() {
			let e = this._first
			for (; e !== $t.Undefined; ) yield e.element, (e = e.next)
		}
	}
var EH = globalThis.performance.now.bind(globalThis.performance),
	zt = class o {
		static create(e) {
			return new o(e)
		}
		constructor(e) {
			;(this._now = e === !1 ? Date.now : EH), (this._startTime = this._now()), (this._stopTime = -1)
		}
		stop() {
			this._stopTime = this._now()
		}
		reset() {
			;(this._startTime = this._now()), (this._stopTime = -1)
		}
		elapsed() {
			return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime
		}
	}
var K0 = !1,
	wH = !1,
	Te
;((vt) => {
	vt.None = () => $.None
	function e(ae) {
		if (wH) {
			let { onDidAddListener: Z } = ae,
				se = Ym.create(),
				ee = 0
			ae.onDidAddListener = () => {
				++ee === 2 &&
					(console.warn(
						"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here",
					),
					se.print()),
					Z?.()
			}
		}
	}
	function t(ae, Z) {
		return f(ae, () => {}, 0, void 0, !0, void 0, Z)
	}
	vt.defer = t
	function n(ae) {
		return (Z, se = null, ee) => {
			let fe = !1,
				Ae
			return (
				(Ae = ae(
					(he) => {
						if (!fe) return Ae ? Ae.dispose() : (fe = !0), Z.call(se, he)
					},
					null,
					ee,
				)),
				fe && Ae.dispose(),
				Ae
			)
		}
	}
	vt.once = n
	function r(ae, Z) {
		return vt.once(vt.filter(ae, Z))
	}
	vt.onceIf = r
	function i(ae, Z, se) {
		return u((ee, fe = null, Ae) => ae((he) => ee.call(fe, Z(he)), null, Ae), se)
	}
	vt.map = i
	function s(ae, Z, se) {
		return u(
			(ee, fe = null, Ae) =>
				ae(
					(he) => {
						Z(he), ee.call(fe, he)
					},
					null,
					Ae,
				),
			se,
		)
	}
	vt.forEach = s
	function a(ae, Z, se) {
		return u((ee, fe = null, Ae) => ae((he) => Z(he) && ee.call(fe, he), null, Ae), se)
	}
	vt.filter = a
	function l(ae) {
		return ae
	}
	vt.signal = l
	function d(...ae) {
		return (Z, se = null, ee) => {
			let fe = ev(...ae.map((Ae) => Ae((he) => Z.call(se, he))))
			return m(fe, ee)
		}
	}
	vt.any = d
	function c(ae, Z, se, ee) {
		let fe = se
		return i(ae, (Ae) => ((fe = Z(fe, Ae)), fe), ee)
	}
	vt.reduce = c
	function u(ae, Z) {
		let se,
			ee = {
				onWillAddFirstListener() {
					se = ae(fe.fire, fe)
				},
				onDidRemoveLastListener() {
					se?.dispose()
				},
			}
		Z || e(ee)
		let fe = new E(ee)
		return Z?.add(fe), fe.event
	}
	function m(ae, Z) {
		return Z instanceof Array ? Z.push(ae) : Z && Z.add(ae), ae
	}
	function f(ae, Z, se = 100, ee = !1, fe = !1, Ae, he) {
		let le,
			Et,
			_t,
			Se = 0,
			En,
			Ft = {
				leakWarningThreshold: Ae,
				onWillAddFirstListener() {
					le = ae((nc) => {
						Se++,
							(Et = Z(Et, nc)),
							ee && !_t && (to.fire(Et), (Et = void 0)),
							(En = () => {
								let ti = Et
								;(Et = void 0), (_t = void 0), (!ee || Se > 1) && to.fire(ti), (Se = 0)
							}),
							typeof se == "number"
								? (clearTimeout(_t), (_t = setTimeout(En, se)))
								: _t === void 0 && ((_t = 0), queueMicrotask(En))
					})
				},
				onWillRemoveListener() {
					fe && Se > 0 && En?.()
				},
				onDidRemoveLastListener() {
					;(En = void 0), le.dispose()
				},
			}
		he || e(Ft)
		let to = new E(Ft)
		return he?.add(to), to.event
	}
	vt.debounce = f
	function h(ae, Z = 0, se) {
		return vt.debounce(ae, (ee, fe) => (ee ? (ee.push(fe), ee) : [fe]), Z, void 0, !0, void 0, se)
	}
	vt.accumulate = h
	function g(ae, Z = (ee, fe) => ee === fe, se) {
		let ee = !0,
			fe
		return a(
			ae,
			(Ae) => {
				let he = ee || !Z(Ae, fe)
				return (ee = !1), (fe = Ae), he
			},
			se,
		)
	}
	vt.latch = g
	function I(ae, Z, se) {
		return [vt.filter(ae, Z, se), vt.filter(ae, (ee) => !Z(ee), se)]
	}
	vt.split = I
	function C(ae, Z = !1, se = [], ee) {
		let fe = se.slice(),
			Ae = ae((Et) => {
				fe ? fe.push(Et) : le.fire(Et)
			})
		ee && ee.add(Ae)
		let he = () => {
				fe?.forEach((Et) => le.fire(Et)), (fe = null)
			},
			le = new E({
				onWillAddFirstListener() {
					Ae || ((Ae = ae((Et) => le.fire(Et))), ee && ee.add(Ae))
				},
				onDidAddFirstListener() {
					fe && (Z ? setTimeout(he) : he())
				},
				onDidRemoveLastListener() {
					Ae && Ae.dispose(), (Ae = null)
				},
			})
		return ee && ee.add(le), le.event
	}
	vt.buffer = C
	function T(ae, Z) {
		return (ee, fe, Ae) => {
			let he = Z(new L())
			return ae(
				function (le) {
					let Et = he.evaluate(le)
					Et !== w && ee.call(fe, Et)
				},
				void 0,
				Ae,
			)
		}
	}
	vt.chain = T
	let w = Symbol("HaltChainable")
	class L {
		constructor() {
			this.steps = []
		}
		map(Z) {
			return this.steps.push(Z), this
		}
		forEach(Z) {
			return this.steps.push((se) => (Z(se), se)), this
		}
		filter(Z) {
			return this.steps.push((se) => (Z(se) ? se : w)), this
		}
		reduce(Z, se) {
			let ee = se
			return this.steps.push((fe) => ((ee = Z(ee, fe)), ee)), this
		}
		latch(Z = (se, ee) => se === ee) {
			let se = !0,
				ee
			return (
				this.steps.push((fe) => {
					let Ae = se || !Z(fe, ee)
					return (se = !1), (ee = fe), Ae ? fe : w
				}),
				this
			)
		}
		evaluate(Z) {
			for (let se of this.steps) if (((Z = se(Z)), Z === w)) break
			return Z
		}
	}
	function A(ae, Z, se = (ee) => ee) {
		let ee = (...le) => he.fire(se(...le)),
			fe = () => ae.on(Z, ee),
			Ae = () => ae.removeListener(Z, ee),
			he = new E({ onWillAddFirstListener: fe, onDidRemoveLastListener: Ae })
		return he.event
	}
	vt.fromNodeEventEmitter = A
	function J(ae, Z, se = (ee) => ee) {
		let ee = (...le) => he.fire(se(...le)),
			fe = () => ae.addEventListener(Z, ee),
			Ae = () => ae.removeEventListener(Z, ee),
			he = new E({ onWillAddFirstListener: fe, onDidRemoveLastListener: Ae })
		return he.event
	}
	vt.fromDOMEventEmitter = J
	function ne(ae, Z) {
		return new Promise((se) => n(ae)(se, null, Z))
	}
	vt.toPromise = ne
	function oe(ae) {
		let Z = new E()
		return (
			ae
				.then(
					(se) => {
						Z.fire(se)
					},
					() => {
						Z.fire(void 0)
					},
				)
				.finally(() => {
					Z.dispose()
				}),
			Z.event
		)
	}
	vt.fromPromise = oe
	function Y(ae, Z) {
		return ae((se) => Z.fire(se))
	}
	vt.forward = Y
	function j(ae, Z, se) {
		return Z(se), ae((ee) => Z(ee))
	}
	vt.runAndSubscribe = j
	class K {
		constructor(Z, se) {
			this._observable = Z
			this._counter = 0
			this._hasChanged = !1
			let ee = {
				onWillAddFirstListener: () => {
					Z.addObserver(this), this._observable.reportChanges()
				},
				onDidRemoveLastListener: () => {
					Z.removeObserver(this)
				},
			}
			se || e(ee), (this.emitter = new E(ee)), se && se.add(this.emitter)
		}
		beginUpdate(Z) {
			this._counter++
		}
		handlePossibleChange(Z) {}
		handleChange(Z, se) {
			this._hasChanged = !0
		}
		endUpdate(Z) {
			this._counter--,
				this._counter === 0 &&
					(this._observable.reportChanges(),
					this._hasChanged && ((this._hasChanged = !1), this.emitter.fire(this._observable.get())))
		}
	}
	function qe(ae, Z) {
		return new K(ae, Z).emitter.event
	}
	vt.fromObservable = qe
	function Bt(ae) {
		return (Z, se, ee) => {
			let fe = 0,
				Ae = !1,
				he = {
					beginUpdate() {
						fe++
					},
					endUpdate() {
						fe--, fe === 0 && (ae.reportChanges(), Ae && ((Ae = !1), Z.call(se)))
					},
					handlePossibleChange() {},
					handleChange() {
						Ae = !0
					},
				}
			ae.addObserver(he), ae.reportChanges()
			let le = {
				dispose() {
					ae.removeObserver(he)
				},
			}
			return ee instanceof Q ? ee.add(le) : Array.isArray(ee) && ee.push(le), le
		}
	}
	vt.fromObservableLight = Bt
})((Te ||= {}))
var jT = class o {
		constructor(e) {
			this.listenerCount = 0
			this.invocationCount = 0
			this.elapsedOverall = 0
			this.durations = []
			;(this.name = `${e}_${o._idPool++}`), o.all.add(this)
		}
		static {
			this.all = new Set()
		}
		static {
			this._idPool = 0
		}
		start(e) {
			;(this._stopWatch = new zt()), (this.listenerCount = e)
		}
		stop() {
			if (this._stopWatch) {
				let e = this._stopWatch.elapsed()
				this.durations.push(e),
					(this.elapsedOverall += e),
					(this.invocationCount += 1),
					(this._stopWatch = void 0)
			}
		}
	},
	j0 = -1
var GT = class o {
		constructor(e, t, n = (o._idPool++).toString(16).padStart(3, "0")) {
			this._errorHandler = e
			this.threshold = t
			this.name = n
			this._warnCountdown = 0
		}
		static {
			this._idPool = 1
		}
		dispose() {
			this._stacks?.clear()
		}
		check(e, t) {
			let n = this.threshold
			if (n <= 0 || t < n) return
			this._stacks || (this._stacks = new Map())
			let r = this._stacks.get(e.value) || 0
			if ((this._stacks.set(e.value, r + 1), (this._warnCountdown -= 1), this._warnCountdown <= 0)) {
				this._warnCountdown = n * 0.5
				let [i, s] = this.getMostFrequentStack(),
					a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${s}):`
				console.warn(a), console.warn(i)
				let l = new QT(a, i)
				this._errorHandler(l)
			}
			return () => {
				let i = this._stacks.get(e.value) || 0
				this._stacks.set(e.value, i - 1)
			}
		}
		getMostFrequentStack() {
			if (!this._stacks) return
			let e,
				t = 0
			for (let [n, r] of this._stacks) (!e || t < r) && ((e = [n, r]), (t = r))
			return e
		}
	},
	Ym = class o {
		constructor(e) {
			this.value = e
		}
		static create() {
			let e = new Error()
			return new o(e.stack ?? "")
		}
		print() {
			console.warn(
				this.value
					.split(
						`
`,
					)
					.slice(2).join(`
`),
			)
		}
	},
	QT = class extends Error {
		constructor(e, t) {
			super(e), (this.name = "ListenerLeakError"), (this.stack = t)
		}
	},
	JT = class extends Error {
		constructor(e, t) {
			super(e), (this.name = "ListenerRefusalError"), (this.stack = t)
		}
	},
	PH = 0,
	hc = class {
		constructor(e) {
			this.value = e
			this.id = PH++
		}
	},
	_H = 2,
	G0 = (o, e) => {
		if (o instanceof hc) e(o)
		else
			for (let t = 0; t < o.length; t++) {
				let n = o[t]
				n && e(n)
			}
	},
	E = class {
		constructor(e) {
			this._size = 0
			;(this._options = e),
				(this._leakageMon =
					j0 > 0 || this._options?.leakWarningThreshold
						? new GT(e?.onListenerError ?? Be, this._options?.leakWarningThreshold ?? j0)
						: void 0),
				(this._perfMon = this._options?._profName ? new jT(this._options._profName) : void 0),
				(this._deliveryQueue = this._options?.deliveryQueue)
		}
		dispose() {
			if (!this._disposed) {
				if (
					((this._disposed = !0),
					this._deliveryQueue?.current === this && this._deliveryQueue.reset(),
					this._listeners)
				) {
					if (K0) {
						let e = this._listeners
						queueMicrotask(() => {
							G0(e, (t) => t.stack?.print())
						})
					}
					;(this._listeners = void 0), (this._size = 0)
				}
				this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose()
			}
		}
		get event() {
			return (
				(this._event ??= (e, t, n) => {
					if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
						let l = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`
						console.warn(l)
						let d = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1],
							c = new JT(`${l}. HINT: Stack shows most frequent listener (${d[1]}-times)`, d[0])
						return (this._options?.onListenerError || Be)(c), $.None
					}
					if (this._disposed) return $.None
					t && (e = e.bind(t))
					let r = new hc(e),
						i,
						s
					this._leakageMon &&
						this._size >= Math.ceil(this._leakageMon.threshold * 0.2) &&
						((r.stack = Ym.create()), (i = this._leakageMon.check(r.stack, this._size + 1))),
						K0 && (r.stack = s ?? Ym.create()),
						this._listeners
							? this._listeners instanceof hc
								? ((this._deliveryQueue ??= new XT()), (this._listeners = [this._listeners, r]))
								: this._listeners.push(r)
							: (this._options?.onWillAddFirstListener?.(this),
								(this._listeners = r),
								this._options?.onDidAddFirstListener?.(this)),
						this._options?.onDidAddListener?.(this),
						this._size++
					let a = q(() => {
						i?.(), this._removeListener(r)
					})
					return n instanceof Q ? n.add(a) : Array.isArray(n) && n.push(a), a
				}),
				this._event
			)
		}
		_removeListener(e) {
			if ((this._options?.onWillRemoveListener?.(this), !this._listeners)) return
			if (this._size === 1) {
				;(this._listeners = void 0), this._options?.onDidRemoveLastListener?.(this), (this._size = 0)
				return
			}
			let t = this._listeners,
				n = t.indexOf(e)
			if (n === -1)
				throw (
					(console.log("disposed?", this._disposed),
					console.log("size?", this._size),
					console.log("arr?", JSON.stringify(this._listeners)),
					new Error("Attempted to dispose unknown listener"))
				)
			this._size--, (t[n] = void 0)
			let r = this._deliveryQueue.current === this
			if (this._size * _H <= t.length) {
				let i = 0
				for (let s = 0; s < t.length; s++)
					t[s]
						? (t[i++] = t[s])
						: r &&
							i < this._deliveryQueue.end &&
							(this._deliveryQueue.end--, i < this._deliveryQueue.i && this._deliveryQueue.i--)
				t.length = i
			}
		}
		_deliver(e, t) {
			if (!e) return
			let n = this._options?.onListenerError || Be
			if (!n) {
				e.value(t)
				return
			}
			try {
				e.value(t)
			} catch (r) {
				n(r)
			}
		}
		_deliverQueue(e) {
			let t = e.current._listeners
			for (; e.i < e.end; ) this._deliver(t[e.i++], e.value)
			e.reset()
		}
		fire(e) {
			if (
				(this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()),
				this._perfMon?.start(this._size),
				this._listeners)
			)
				if (this._listeners instanceof hc) this._deliver(this._listeners, e)
				else {
					let t = this._deliveryQueue
					t.enqueue(this, e, this._listeners.length), this._deliverQueue(t)
				}
			this._perfMon?.stop()
		}
		hasListeners() {
			return this._size > 0
		}
	}
var XT = class {
		constructor() {
			this.i = -1
			this.end = 0
		}
		enqueue(e, t, n) {
			;(this.i = 0), (this.end = n), (this.current = e), (this.value = t)
		}
		reset() {
			;(this.i = this.end), (this.current = void 0), (this.value = void 0)
		}
	},
	si = class extends E {
		async fireAsync(e, t, n) {
			if (this._listeners)
				for (
					this._asyncDeliveryQueue || (this._asyncDeliveryQueue = new ko()),
						G0(this._listeners, (r) => this._asyncDeliveryQueue.push([r.value, e]));
					this._asyncDeliveryQueue.size > 0 && !t.isCancellationRequested;

				) {
					let [r, i] = this._asyncDeliveryQueue.shift(),
						s = [],
						a = {
							...i,
							token: t,
							waitUntil: (l) => {
								if (Object.isFrozen(s)) throw new Error("waitUntil can NOT be called asynchronous")
								n && (l = n(l, r)), s.push(l)
							},
						}
					try {
						r(a)
					} catch (l) {
						Be(l)
						continue
					}
					Object.freeze(s),
						await Promise.allSettled(s).then((l) => {
							for (let d of l) d.status === "rejected" && Be(d.reason)
						})
				}
		}
	},
	ai = class extends E {
		constructor(t) {
			super(t)
			this._isPaused = 0
			this._eventQueue = new ko()
			this._mergeFn = t?.merge
		}
		get isPaused() {
			return this._isPaused !== 0
		}
		pause() {
			this._isPaused++
		}
		resume() {
			if (this._isPaused !== 0 && --this._isPaused === 0)
				if (this._mergeFn) {
					if (this._eventQueue.size > 0) {
						let t = Array.from(this._eventQueue)
						this._eventQueue.clear(), super.fire(this._mergeFn(t))
					}
				} else for (; !this._isPaused && this._eventQueue.size !== 0; ) super.fire(this._eventQueue.shift())
		}
		fire(t) {
			this._size && (this._isPaused !== 0 ? this._eventQueue.push(t) : super.fire(t))
		}
	},
	tv = class extends ai {
		constructor(e) {
			super(e), (this._delay = e.delay ?? 100)
		}
		fire(e) {
			this._handle ||
				(this.pause(),
				(this._handle = setTimeout(() => {
					;(this._handle = void 0), this.resume()
				}, this._delay))),
				super.fire(e)
		}
	}
var nv = class {
	constructor() {
		this.listening = !1
		this.inputEvent = Te.None
		this.inputEventListener = $.None
		this.emitter = new E({
			onDidAddFirstListener: () => {
				;(this.listening = !0), (this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter))
			},
			onDidRemoveLastListener: () => {
				;(this.listening = !1), this.inputEventListener.dispose()
			},
		})
		this.event = this.emitter.event
	}
	set input(e) {
		;(this.inputEvent = e),
			this.listening &&
				(this.inputEventListener.dispose(), (this.inputEventListener = e(this.emitter.fire, this.emitter)))
	}
	dispose() {
		this.inputEventListener.dispose(), this.emitter.dispose()
	}
}
var Q0 = Object.freeze(function (o, e) {
		let t = setTimeout(o.bind(e), 0)
		return {
			dispose() {
				clearTimeout(t)
			},
		}
	}),
	De
;((n) => {
	function o(r) {
		return r === n.None || r === n.Cancelled || r instanceof vc
			? !0
			: !r || typeof r != "object"
				? !1
				: typeof r.isCancellationRequested == "boolean" && typeof r.onCancellationRequested == "function"
	}
	;(n.isCancellationToken = o),
		(n.None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: Te.None })),
		(n.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: Q0 }))
})((De ||= {}))
var vc = class {
		constructor() {
			this._isCancelled = !1
			this._emitter = null
		}
		cancel() {
			this._isCancelled ||
				((this._isCancelled = !0), this._emitter && (this._emitter.fire(void 0), this.dispose()))
		}
		get isCancellationRequested() {
			return this._isCancelled
		}
		get onCancellationRequested() {
			return this._isCancelled ? Q0 : (this._emitter || (this._emitter = new E()), this._emitter.event)
		}
		dispose() {
			this._emitter && (this._emitter.dispose(), (this._emitter = null))
		}
	},
	_e = class {
		constructor(e) {
			this._token = void 0
			this._parentListener = void 0
			this._parentListener = e && e.onCancellationRequested(this.cancel, this)
		}
		get token() {
			return this._token || (this._token = new vc()), this._token
		}
		cancel() {
			this._token ? this._token instanceof vc && this._token.cancel() : (this._token = De.Cancelled)
		}
		dispose(e = !1) {
			e && this.cancel(),
				this._parentListener?.dispose(),
				this._token ? this._token instanceof vc && this._token.dispose() : (this._token = De.None)
		}
	}
function YT() {
	return globalThis._VSCODE_NLS_MESSAGES
}
function Zm() {
	return globalThis._VSCODE_NLS_LANGUAGE
}
var DH =
	Zm() === "pseudo" ||
	(typeof document < "u" &&
		document.location &&
		typeof document.location.hash == "string" &&
		document.location.hash.indexOf("pseudo=true") >= 0)
function rv(o, e) {
	let t
	return (
		e.length === 0
			? (t = o)
			: (t = o.replace(/\{(\d+)\}/g, (n, r) => {
					let i = r[0],
						s = e[i],
						a = n
					return (
						typeof s == "string"
							? (a = s)
							: (typeof s == "number" || typeof s == "boolean" || s === void 0 || s === null) &&
								(a = String(s)),
						a
					)
				})),
		DH && (t = "\uFF3B" + t.replace(/[aouei]/g, "$&$&") + "\uFF3D"),
		t
	)
}
function p(o, e, ...t) {
	return rv(typeof o == "number" ? J0(o, e) : e, t)
}
function J0(o, e) {
	let t = YT()?.[o]
	if (typeof t != "string") {
		if (typeof e == "string") return e
		throw new Error(`!!! NLS MISSING: ${o} !!!`)
	}
	return t
}
function ef(o, e, ...t) {
	let n
	typeof o == "number" ? (n = J0(o, e)) : (n = e)
	let r = rv(n, t)
	return { value: r, original: e === n ? r : rv(e, t) }
}
var li = "en",
	nf = !1,
	rf = !1,
	tf = !1,
	kH = !1,
	eA = !1,
	ZT = !1,
	RH = !1,
	eE = !1,
	tA = !1,
	nA = !1,
	ov,
	iv = li,
	X0 = li,
	AH,
	qi,
	Ki = globalThis,
	Vr
typeof Ki.vscode < "u" && typeof Ki.vscode.process < "u"
	? (Vr = Ki.vscode.process)
	: typeof process < "u" && typeof process?.versions?.node == "string" && (Vr = process)
var rA = typeof Vr?.versions?.electron == "string",
	OH = rA && Vr?.type === "renderer"
if (typeof Vr == "object") {
	;(nf = Vr.platform === "win32"),
		(rf = Vr.platform === "darwin"),
		(tf = Vr.platform === "linux"),
		(kH = tf && !!Vr.env.SNAP && !!Vr.env.SNAP_REVISION),
		(RH = rA),
		(tA = !!Vr.env.CI || !!Vr.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
		(ov = li),
		(iv = li)
	let o = Vr.env.VSCODE_NLS_CONFIG
	if (o)
		try {
			let e = JSON.parse(o)
			;(ov = e.userLocale),
				(X0 = e.osLocale),
				(iv = e.resolvedLanguage || li),
				(AH = e.languagePack?.translationsConfigFile)
		} catch {}
	eA = !0
} else
	typeof navigator == "object" && !OH
		? ((qi = navigator.userAgent),
			(nf = qi.indexOf("Windows") >= 0),
			(rf = qi.indexOf("Macintosh") >= 0),
			(eE =
				(qi.indexOf("Macintosh") >= 0 || qi.indexOf("iPad") >= 0 || qi.indexOf("iPhone") >= 0) &&
				!!navigator.maxTouchPoints &&
				navigator.maxTouchPoints > 0),
			(tf = qi.indexOf("Linux") >= 0),
			(nA = qi?.indexOf("Mobi") >= 0),
			(ZT = !0),
			(iv = Zm() || li),
			(ov = navigator.language.toLowerCase()),
			(X0 = ov))
		: console.error("Unable to resolve platform.")
function tE(o) {
	switch (o) {
		case 0:
			return "Web"
		case 1:
			return "Mac"
		case 2:
			return "Linux"
		case 3:
			return "Windows"
	}
}
var sv = 0
rf ? (sv = 1) : nf ? (sv = 3) : tf && (sv = 2)
var Ie = nf,
	st = rf,
	Ve = tf
var av = eA
var Ro = ZT,
	LH = ZT && typeof Ki.importScripts == "function",
	oA = LH ? Ki.origin : void 0,
	iA = eE,
	sA = nA,
	na = tA,
	lv = sv,
	di = qi,
	ta = iv,
	MH
;((n) => {
	function o() {
		return ta
	}
	n.value = o
	function e() {
		return ta.length === 2 ? ta === "en" : ta.length >= 3 ? ta[0] === "e" && ta[1] === "n" && ta[2] === "-" : !1
	}
	n.isDefaultVariant = e
	function t() {
		return ta === "en"
	}
	n.isDefault = t
})((MH ||= {}))
var FH = typeof Ki.postMessage == "function" && !Ki.importScripts,
	dv = (() => {
		if (FH) {
			let o = []
			Ki.addEventListener("message", (t) => {
				if (t.data && t.data.vscodeScheduleAsyncWork)
					for (let n = 0, r = o.length; n < r; n++) {
						let i = o[n]
						if (i.id === t.data.vscodeScheduleAsyncWork) {
							o.splice(n, 1), i.callback()
							return
						}
					}
			})
			let e = 0
			return (t) => {
				let n = ++e
				o.push({ id: n, callback: t }), Ki.postMessage({ vscodeScheduleAsyncWork: n }, "*")
			}
		}
		return (o) => setTimeout(o)
	})()
var wl = rf || eE ? 2 : nf ? 1 : 3,
	Y0 = !0,
	Z0 = !1
function cv() {
	if (!Z0) {
		Z0 = !0
		let o = new Uint8Array(2)
		;(o[0] = 1), (o[1] = 2), (Y0 = new Uint16Array(o.buffer)[0] === 513)
	}
	return Y0
}
var of = !!(di && di.indexOf("Chrome") >= 0),
	aA = !!(di && di.indexOf("Firefox") >= 0),
	lA = !!(!of && di && di.indexOf("Safari") >= 0),
	uv = !!(di && di.indexOf("Edg/") >= 0),
	i3 = !!(di && di.indexOf("Android") >= 0)
var Pl,
	nE = globalThis.vscode
if (typeof nE < "u" && typeof nE.process < "u") {
	let o = nE.process
	Pl = {
		get platform() {
			return o.platform
		},
		get arch() {
			return o.arch
		},
		get env() {
			return o.env
		},
		cwd() {
			return o.cwd()
		},
	}
} else
	typeof process < "u" && typeof process?.versions?.node == "string"
		? (Pl = {
				get platform() {
					return process.platform
				},
				get arch() {
					return process.arch
				},
				get env() {
					return process.env
				},
				cwd() {
					return process.env.VSCODE_CWD || process.cwd()
				},
			})
		: (Pl = {
				get platform() {
					return Ie ? "win32" : st ? "darwin" : "linux"
				},
				get arch() {},
				get env() {
					return {}
				},
				cwd() {
					return "/"
				},
			})
var Ao = Pl.cwd,
	Er = Pl.env,
	rE = Pl.platform,
	NH = Pl.arch
var UH = 65,
	HH = 97,
	WH = 90,
	VH = 122,
	_l = 46,
	Un = 47,
	wr = 92,
	ji = 58,
	BH = 63,
	mv = class extends Error {
		constructor(e, t, n) {
			let r
			typeof t == "string" && t.indexOf("not ") === 0
				? ((r = "must not be"), (t = t.replace(/^not /, "")))
				: (r = "must be")
			let i = e.indexOf(".") !== -1 ? "property" : "argument",
				s = `The "${e}" ${i} ${r} of type ${t}`
			;(s += `. Received type ${typeof n}`), super(s), (this.code = "ERR_INVALID_ARG_TYPE")
		}
	}
function $H(o, e) {
	if (o === null || typeof o != "object") throw new mv(e, "Object", o)
}
function ln(o, e) {
	if (typeof o != "string") throw new mv(e, "string", o)
}
var Pr = rE === "win32"
function Ge(o) {
	return o === Un || o === wr
}
function oE(o) {
	return o === Un
}
function Gi(o) {
	return (o >= UH && o <= WH) || (o >= HH && o <= VH)
}
function fv(o, e, t, n) {
	let r = "",
		i = 0,
		s = -1,
		a = 0,
		l = 0
	for (let d = 0; d <= o.length; ++d) {
		if (d < o.length) l = o.charCodeAt(d)
		else {
			if (n(l)) break
			l = Un
		}
		if (n(l)) {
			if (!(s === d - 1 || a === 1))
				if (a === 2) {
					if (
						r.length < 2 ||
						i !== 2 ||
						r.charCodeAt(r.length - 1) !== _l ||
						r.charCodeAt(r.length - 2) !== _l
					) {
						if (r.length > 2) {
							let c = r.lastIndexOf(t)
							c === -1
								? ((r = ""), (i = 0))
								: ((r = r.slice(0, c)), (i = r.length - 1 - r.lastIndexOf(t))),
								(s = d),
								(a = 0)
							continue
						} else if (r.length !== 0) {
							;(r = ""), (i = 0), (s = d), (a = 0)
							continue
						}
					}
					e && ((r += r.length > 0 ? `${t}..` : ".."), (i = 2))
				} else r.length > 0 ? (r += `${t}${o.slice(s + 1, d)}`) : (r = o.slice(s + 1, d)), (i = d - s - 1)
			;(s = d), (a = 0)
		} else l === _l && a !== -1 ? ++a : (a = -1)
	}
	return r
}
function zH(o) {
	return o ? `${o[0] === "." ? "" : "."}${o}` : ""
}
function dA(o, e) {
	$H(e, "pathObject")
	let t = e.dir || e.root,
		n = e.base || `${e.name || ""}${zH(e.ext)}`
	return t ? (t === e.root ? `${t}${n}` : `${t}${o}${n}`) : n
}
var qt = {
		resolve(...o) {
			let e = "",
				t = "",
				n = !1
			for (let r = o.length - 1; r >= -1; r--) {
				let i
				if (r >= 0) {
					if (((i = o[r]), ln(i, `paths[${r}]`), i.length === 0)) continue
				} else
					e.length === 0
						? (i = Ao())
						: ((i = Er[`=${e}`] || Ao()),
							(i === void 0 ||
								(i.slice(0, 2).toLowerCase() !== e.toLowerCase() && i.charCodeAt(2) === wr)) &&
								(i = `${e}\\`))
				let s = i.length,
					a = 0,
					l = "",
					d = !1,
					c = i.charCodeAt(0)
				if (s === 1) Ge(c) && ((a = 1), (d = !0))
				else if (Ge(c))
					if (((d = !0), Ge(i.charCodeAt(1)))) {
						let u = 2,
							m = u
						for (; u < s && !Ge(i.charCodeAt(u)); ) u++
						if (u < s && u !== m) {
							let f = i.slice(m, u)
							for (m = u; u < s && Ge(i.charCodeAt(u)); ) u++
							if (u < s && u !== m) {
								for (m = u; u < s && !Ge(i.charCodeAt(u)); ) u++
								;(u === s || u !== m) && ((l = `\\\\${f}\\${i.slice(m, u)}`), (a = u))
							}
						}
					} else a = 1
				else
					Gi(c) &&
						i.charCodeAt(1) === ji &&
						((l = i.slice(0, 2)), (a = 2), s > 2 && Ge(i.charCodeAt(2)) && ((d = !0), (a = 3)))
				if (l.length > 0)
					if (e.length > 0) {
						if (l.toLowerCase() !== e.toLowerCase()) continue
					} else e = l
				if (n) {
					if (e.length > 0) break
				} else if (((t = `${i.slice(a)}\\${t}`), (n = d), d && e.length > 0)) break
			}
			return (t = fv(t, !n, "\\", Ge)), n ? `${e}\\${t}` : `${e}${t}` || "."
		},
		normalize(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return "."
			let t = 0,
				n,
				r = !1,
				i = o.charCodeAt(0)
			if (e === 1) return oE(i) ? "\\" : o
			if (Ge(i))
				if (((r = !0), Ge(o.charCodeAt(1)))) {
					let a = 2,
						l = a
					for (; a < e && !Ge(o.charCodeAt(a)); ) a++
					if (a < e && a !== l) {
						let d = o.slice(l, a)
						for (l = a; a < e && Ge(o.charCodeAt(a)); ) a++
						if (a < e && a !== l) {
							for (l = a; a < e && !Ge(o.charCodeAt(a)); ) a++
							if (a === e) return `\\\\${d}\\${o.slice(l)}\\`
							a !== l && ((n = `\\\\${d}\\${o.slice(l, a)}`), (t = a))
						}
					}
				} else t = 1
			else
				Gi(i) &&
					o.charCodeAt(1) === ji &&
					((n = o.slice(0, 2)), (t = 2), e > 2 && Ge(o.charCodeAt(2)) && ((r = !0), (t = 3)))
			let s = t < e ? fv(o.slice(t), !r, "\\", Ge) : ""
			if (
				(s.length === 0 && !r && (s = "."),
				s.length > 0 && Ge(o.charCodeAt(e - 1)) && (s += "\\"),
				!r && n === void 0 && o.includes(":"))
			) {
				if (s.length >= 2 && Gi(s.charCodeAt(0)) && s.charCodeAt(1) === ji) return `.\\${s}`
				let a = o.indexOf(":")
				do if (a === e - 1 || Ge(o.charCodeAt(a + 1))) return `.\\${s}`
				while ((a = o.indexOf(":", a + 1)) !== -1)
			}
			return n === void 0 ? (r ? `\\${s}` : s) : r ? `${n}\\${s}` : `${n}${s}`
		},
		isAbsolute(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return !1
			let t = o.charCodeAt(0)
			return Ge(t) || (e > 2 && Gi(t) && o.charCodeAt(1) === ji && Ge(o.charCodeAt(2)))
		},
		join(...o) {
			if (o.length === 0) return "."
			let e, t
			for (let i = 0; i < o.length; ++i) {
				let s = o[i]
				ln(s, "path"), s.length > 0 && (e === void 0 ? (e = t = s) : (e += `\\${s}`))
			}
			if (e === void 0) return "."
			let n = !0,
				r = 0
			if (typeof t == "string" && Ge(t.charCodeAt(0))) {
				++r
				let i = t.length
				i > 1 && Ge(t.charCodeAt(1)) && (++r, i > 2 && (Ge(t.charCodeAt(2)) ? ++r : (n = !1)))
			}
			if (n) {
				for (; r < e.length && Ge(e.charCodeAt(r)); ) r++
				r >= 2 && (e = `\\${e.slice(r)}`)
			}
			return qt.normalize(e)
		},
		relative(o, e) {
			if ((ln(o, "from"), ln(e, "to"), o === e)) return ""
			let t = qt.resolve(o),
				n = qt.resolve(e)
			if (t === n || ((o = t.toLowerCase()), (e = n.toLowerCase()), o === e)) return ""
			if (t.length !== o.length || n.length !== e.length) {
				let h = t.split("\\"),
					g = n.split("\\")
				h[h.length - 1] === "" && h.pop(), g[g.length - 1] === "" && g.pop()
				let I = h.length,
					C = g.length,
					T = I < C ? I : C,
					w
				for (w = 0; w < T && h[w].toLowerCase() === g[w].toLowerCase(); w++);
				return w === 0
					? n
					: w === T
						? C > T
							? g.slice(w).join("\\")
							: I > T
								? "..\\".repeat(I - 1 - w) + ".."
								: ""
						: "..\\".repeat(I - w) + g.slice(w).join("\\")
			}
			let r = 0
			for (; r < o.length && o.charCodeAt(r) === wr; ) r++
			let i = o.length
			for (; i - 1 > r && o.charCodeAt(i - 1) === wr; ) i--
			let s = i - r,
				a = 0
			for (; a < e.length && e.charCodeAt(a) === wr; ) a++
			let l = e.length
			for (; l - 1 > a && e.charCodeAt(l - 1) === wr; ) l--
			let d = l - a,
				c = s < d ? s : d,
				u = -1,
				m = 0
			for (; m < c; m++) {
				let h = o.charCodeAt(r + m)
				if (h !== e.charCodeAt(a + m)) break
				h === wr && (u = m)
			}
			if (m !== c) {
				if (u === -1) return n
			} else {
				if (d > c) {
					if (e.charCodeAt(a + m) === wr) return n.slice(a + m + 1)
					if (m === 2) return n.slice(a + m)
				}
				s > c && (o.charCodeAt(r + m) === wr ? (u = m) : m === 2 && (u = 3)), u === -1 && (u = 0)
			}
			let f = ""
			for (m = r + u + 1; m <= i; ++m)
				(m === i || o.charCodeAt(m) === wr) && (f += f.length === 0 ? ".." : "\\..")
			return (a += u), f.length > 0 ? `${f}${n.slice(a, l)}` : (n.charCodeAt(a) === wr && ++a, n.slice(a, l))
		},
		toNamespacedPath(o) {
			if (typeof o != "string" || o.length === 0) return o
			let e = qt.resolve(o)
			if (e.length <= 2) return o
			if (e.charCodeAt(0) === wr) {
				if (e.charCodeAt(1) === wr) {
					let t = e.charCodeAt(2)
					if (t !== BH && t !== _l) return `\\\\?\\UNC\\${e.slice(2)}`
				}
			} else if (Gi(e.charCodeAt(0)) && e.charCodeAt(1) === ji && e.charCodeAt(2) === wr) return `\\\\?\\${e}`
			return e
		},
		dirname(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return "."
			let t = -1,
				n = 0,
				r = o.charCodeAt(0)
			if (e === 1) return Ge(r) ? o : "."
			if (Ge(r)) {
				if (((t = n = 1), Ge(o.charCodeAt(1)))) {
					let a = 2,
						l = a
					for (; a < e && !Ge(o.charCodeAt(a)); ) a++
					if (a < e && a !== l) {
						for (l = a; a < e && Ge(o.charCodeAt(a)); ) a++
						if (a < e && a !== l) {
							for (l = a; a < e && !Ge(o.charCodeAt(a)); ) a++
							if (a === e) return o
							a !== l && (t = n = a + 1)
						}
					}
				}
			} else Gi(r) && o.charCodeAt(1) === ji && ((t = e > 2 && Ge(o.charCodeAt(2)) ? 3 : 2), (n = t))
			let i = -1,
				s = !0
			for (let a = e - 1; a >= n; --a)
				if (Ge(o.charCodeAt(a))) {
					if (!s) {
						i = a
						break
					}
				} else s = !1
			if (i === -1) {
				if (t === -1) return "."
				i = t
			}
			return o.slice(0, i)
		},
		basename(o, e) {
			e !== void 0 && ln(e, "suffix"), ln(o, "path")
			let t = 0,
				n = -1,
				r = !0,
				i
			if (
				(o.length >= 2 && Gi(o.charCodeAt(0)) && o.charCodeAt(1) === ji && (t = 2),
				e !== void 0 && e.length > 0 && e.length <= o.length)
			) {
				if (e === o) return ""
				let s = e.length - 1,
					a = -1
				for (i = o.length - 1; i >= t; --i) {
					let l = o.charCodeAt(i)
					if (Ge(l)) {
						if (!r) {
							t = i + 1
							break
						}
					} else
						a === -1 && ((r = !1), (a = i + 1)),
							s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (n = i) : ((s = -1), (n = a)))
				}
				return t === n ? (n = a) : n === -1 && (n = o.length), o.slice(t, n)
			}
			for (i = o.length - 1; i >= t; --i)
				if (Ge(o.charCodeAt(i))) {
					if (!r) {
						t = i + 1
						break
					}
				} else n === -1 && ((r = !1), (n = i + 1))
			return n === -1 ? "" : o.slice(t, n)
		},
		extname(o) {
			ln(o, "path")
			let e = 0,
				t = -1,
				n = 0,
				r = -1,
				i = !0,
				s = 0
			o.length >= 2 && o.charCodeAt(1) === ji && Gi(o.charCodeAt(0)) && (e = n = 2)
			for (let a = o.length - 1; a >= e; --a) {
				let l = o.charCodeAt(a)
				if (Ge(l)) {
					if (!i) {
						n = a + 1
						break
					}
					continue
				}
				r === -1 && ((i = !1), (r = a + 1)),
					l === _l ? (t === -1 ? (t = a) : s !== 1 && (s = 1)) : t !== -1 && (s = -1)
			}
			return t === -1 || r === -1 || s === 0 || (s === 1 && t === r - 1 && t === n + 1) ? "" : o.slice(t, r)
		},
		format: dA.bind(null, "\\"),
		parse(o) {
			ln(o, "path")
			let e = { root: "", dir: "", base: "", ext: "", name: "" }
			if (o.length === 0) return e
			let t = o.length,
				n = 0,
				r = o.charCodeAt(0)
			if (t === 1) return Ge(r) ? ((e.root = e.dir = o), e) : ((e.base = e.name = o), e)
			if (Ge(r)) {
				if (((n = 1), Ge(o.charCodeAt(1)))) {
					let u = 2,
						m = u
					for (; u < t && !Ge(o.charCodeAt(u)); ) u++
					if (u < t && u !== m) {
						for (m = u; u < t && Ge(o.charCodeAt(u)); ) u++
						if (u < t && u !== m) {
							for (m = u; u < t && !Ge(o.charCodeAt(u)); ) u++
							u === t ? (n = u) : u !== m && (n = u + 1)
						}
					}
				}
			} else if (Gi(r) && o.charCodeAt(1) === ji) {
				if (t <= 2) return (e.root = e.dir = o), e
				if (((n = 2), Ge(o.charCodeAt(2)))) {
					if (t === 3) return (e.root = e.dir = o), e
					n = 3
				}
			}
			n > 0 && (e.root = o.slice(0, n))
			let i = -1,
				s = n,
				a = -1,
				l = !0,
				d = o.length - 1,
				c = 0
			for (; d >= n; --d) {
				if (((r = o.charCodeAt(d)), Ge(r))) {
					if (!l) {
						s = d + 1
						break
					}
					continue
				}
				a === -1 && ((l = !1), (a = d + 1)),
					r === _l ? (i === -1 ? (i = d) : c !== 1 && (c = 1)) : i !== -1 && (c = -1)
			}
			return (
				a !== -1 &&
					(i === -1 || c === 0 || (c === 1 && i === a - 1 && i === s + 1)
						? (e.base = e.name = o.slice(s, a))
						: ((e.name = o.slice(s, i)), (e.base = o.slice(s, a)), (e.ext = o.slice(i, a)))),
				s > 0 && s !== n ? (e.dir = o.slice(0, s - 1)) : (e.dir = e.root),
				e
			)
		},
		sep: "\\",
		delimiter: ";",
		win32: null,
		posix: null,
	},
	qH = (() => {
		if (Pr) {
			let o = /\\/g
			return () => {
				let e = Ao().replace(o, "/")
				return e.slice(e.indexOf("/"))
			}
		}
		return () => Ao()
	})(),
	Ue = {
		resolve(...o) {
			let e = "",
				t = !1
			for (let n = o.length - 1; n >= 0 && !t; n--) {
				let r = o[n]
				ln(r, `paths[${n}]`), r.length !== 0 && ((e = `${r}/${e}`), (t = r.charCodeAt(0) === Un))
			}
			if (!t) {
				let n = qH()
				;(e = `${n}/${e}`), (t = n.charCodeAt(0) === Un)
			}
			return (e = fv(e, !t, "/", oE)), t ? `/${e}` : e.length > 0 ? e : "."
		},
		normalize(o) {
			if ((ln(o, "path"), o.length === 0)) return "."
			let e = o.charCodeAt(0) === Un,
				t = o.charCodeAt(o.length - 1) === Un
			return (
				(o = fv(o, !e, "/", oE)),
				o.length === 0 ? (e ? "/" : t ? "./" : ".") : (t && (o += "/"), e ? `/${o}` : o)
			)
		},
		isAbsolute(o) {
			return ln(o, "path"), o.length > 0 && o.charCodeAt(0) === Un
		},
		join(...o) {
			if (o.length === 0) return "."
			let e = []
			for (let t = 0; t < o.length; ++t) {
				let n = o[t]
				ln(n, "path"), n.length > 0 && e.push(n)
			}
			return e.length === 0 ? "." : Ue.normalize(e.join("/"))
		},
		relative(o, e) {
			if ((ln(o, "from"), ln(e, "to"), o === e || ((o = Ue.resolve(o)), (e = Ue.resolve(e)), o === e))) return ""
			let t = 1,
				n = o.length,
				r = n - t,
				i = 1,
				s = e.length - i,
				a = r < s ? r : s,
				l = -1,
				d = 0
			for (; d < a; d++) {
				let u = o.charCodeAt(t + d)
				if (u !== e.charCodeAt(i + d)) break
				u === Un && (l = d)
			}
			if (d === a)
				if (s > a) {
					if (e.charCodeAt(i + d) === Un) return e.slice(i + d + 1)
					if (d === 0) return e.slice(i + d)
				} else r > a && (o.charCodeAt(t + d) === Un ? (l = d) : d === 0 && (l = 0))
			let c = ""
			for (d = t + l + 1; d <= n; ++d) (d === n || o.charCodeAt(d) === Un) && (c += c.length === 0 ? ".." : "/..")
			return `${c}${e.slice(i + l)}`
		},
		toNamespacedPath(o) {
			return o
		},
		dirname(o) {
			if ((ln(o, "path"), o.length === 0)) return "."
			let e = o.charCodeAt(0) === Un,
				t = -1,
				n = !0
			for (let r = o.length - 1; r >= 1; --r)
				if (o.charCodeAt(r) === Un) {
					if (!n) {
						t = r
						break
					}
				} else n = !1
			return t === -1 ? (e ? "/" : ".") : e && t === 1 ? "//" : o.slice(0, t)
		},
		basename(o, e) {
			e !== void 0 && ln(e, "suffix"), ln(o, "path")
			let t = 0,
				n = -1,
				r = !0,
				i
			if (e !== void 0 && e.length > 0 && e.length <= o.length) {
				if (e === o) return ""
				let s = e.length - 1,
					a = -1
				for (i = o.length - 1; i >= 0; --i) {
					let l = o.charCodeAt(i)
					if (l === Un) {
						if (!r) {
							t = i + 1
							break
						}
					} else
						a === -1 && ((r = !1), (a = i + 1)),
							s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (n = i) : ((s = -1), (n = a)))
				}
				return t === n ? (n = a) : n === -1 && (n = o.length), o.slice(t, n)
			}
			for (i = o.length - 1; i >= 0; --i)
				if (o.charCodeAt(i) === Un) {
					if (!r) {
						t = i + 1
						break
					}
				} else n === -1 && ((r = !1), (n = i + 1))
			return n === -1 ? "" : o.slice(t, n)
		},
		extname(o) {
			ln(o, "path")
			let e = -1,
				t = 0,
				n = -1,
				r = !0,
				i = 0
			for (let s = o.length - 1; s >= 0; --s) {
				let a = o[s]
				if (a === "/") {
					if (!r) {
						t = s + 1
						break
					}
					continue
				}
				n === -1 && ((r = !1), (n = s + 1)),
					a === "." ? (e === -1 ? (e = s) : i !== 1 && (i = 1)) : e !== -1 && (i = -1)
			}
			return e === -1 || n === -1 || i === 0 || (i === 1 && e === n - 1 && e === t + 1) ? "" : o.slice(e, n)
		},
		format: dA.bind(null, "/"),
		parse(o) {
			ln(o, "path")
			let e = { root: "", dir: "", base: "", ext: "", name: "" }
			if (o.length === 0) return e
			let t = o.charCodeAt(0) === Un,
				n
			t ? ((e.root = "/"), (n = 1)) : (n = 0)
			let r = -1,
				i = 0,
				s = -1,
				a = !0,
				l = o.length - 1,
				d = 0
			for (; l >= n; --l) {
				let c = o.charCodeAt(l)
				if (c === Un) {
					if (!a) {
						i = l + 1
						break
					}
					continue
				}
				s === -1 && ((a = !1), (s = l + 1)),
					c === _l ? (r === -1 ? (r = l) : d !== 1 && (d = 1)) : r !== -1 && (d = -1)
			}
			if (s !== -1) {
				let c = i === 0 && t ? 1 : i
				r === -1 || d === 0 || (d === 1 && r === s - 1 && r === i + 1)
					? (e.base = e.name = o.slice(c, s))
					: ((e.name = o.slice(c, r)), (e.base = o.slice(c, s)), (e.ext = o.slice(r, s)))
			}
			return i > 0 ? (e.dir = o.slice(0, i - 1)) : t && (e.dir = "/"), e
		},
		sep: "/",
		delimiter: ":",
		win32: null,
		posix: null,
	}
Ue.win32 = qt.win32 = qt
Ue.posix = qt.posix = Ue
var jn = Pr ? qt.normalize : Ue.normalize,
	In = Pr ? qt.isAbsolute : Ue.isAbsolute,
	Fe = Pr ? qt.join : Ue.join,
	cA = Pr ? qt.resolve : Ue.resolve,
	Oo = Pr ? qt.relative : Ue.relative,
	Qt = Pr ? qt.dirname : Ue.dirname,
	Ze = Pr ? qt.basename : Ue.basename,
	ra = Pr ? qt.extname : Ue.extname,
	l3 = Pr ? qt.format : Ue.format,
	d3 = Pr ? qt.parse : Ue.parse,
	c3 = Pr ? qt.toNamespacedPath : Ue.toNamespacedPath,
	at = Pr ? qt.sep : Ue.sep,
	gv = Pr ? qt.delimiter : Ue.delimiter
function KH(o) {
	return o
}
var hv = class {
	constructor(e, t) {
		this.lastCache = void 0
		this.lastArgKey = void 0
		typeof e == "function"
			? ((this._fn = e), (this._computeKey = KH))
			: ((this._fn = t), (this._computeKey = e.getCacheKey))
	}
	get(e) {
		let t = this._computeKey(e)
		return this.lastArgKey !== t && ((this.lastArgKey = t), (this.lastCache = this._fn(e))), this.lastCache
	}
}
var Rt = class {
	constructor(e) {
		this.executor = e
		this._didRun = !1
	}
	get hasValue() {
		return this._didRun
	}
	get value() {
		if (!this._didRun)
			try {
				this._value = this.executor()
			} catch (e) {
				this._error = e
			} finally {
				this._didRun = !0
			}
		if (this._error) throw this._error
		return this._value
	}
	get rawValue() {
		return this._value
	}
}
function iE(o) {
	return o < 0 ? 0 : o > 255 ? 255 : o | 0
}
function Dl(o) {
	return o < 0 ? 0 : o > 4294967295 ? 4294967295 : o | 0
}
function Qi(o) {
	return !o || typeof o != "string" ? !0 : o.trim().length === 0
}
var GH = /{([^}]+)}/g
function dE(o, e) {
	return Object.keys(e).length === 0 ? o : o.replace(GH, (t, n) => e[n] ?? t)
}
function _r(o) {
	return o.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&")
}
function gA(o, e) {
	let t = 0,
		n = o.indexOf(e)
	for (; n !== -1; ) t++, (n = o.indexOf(e, n + e.length))
	return t
}
function cE(o, e) {
	if (!o || !e) return o
	let t = e.length
	if (t === 0 || o.length === 0) return o
	let n = 0
	for (; o.indexOf(e, n) === n; ) n = n + t
	return o.substring(n)
}
function Dr(o, e) {
	if (!o || !e) return o
	let t = e.length,
		n = o.length
	if (t === 0 || n === 0) return o
	let r = n,
		i = -1
	for (; (i = o.lastIndexOf(e, r - 1)), !(i === -1 || i + t !== r); ) {
		if (i === 0) return ""
		r = i
	}
	return o.substring(0, r)
}
function hA(o) {
	return o.replace(/\*/g, "")
}
function bv(o, e, t = {}) {
	if (!o) throw new Error("Cannot create regex from empty string")
	e || (o = _r(o)),
		t.wholeWord && (/\B/.test(o.charAt(0)) || (o = "\\b" + o), /\B/.test(o.charAt(o.length - 1)) || (o = o + "\\b"))
	let n = ""
	return (
		t.global && (n += "g"),
		t.matchCase || (n += "i"),
		t.multiline && (n += "m"),
		t.unicode && (n += "u"),
		new RegExp(o, n)
	)
}
function yv(o) {
	return o.source === "^" || o.source === "^$" || o.source === "$" || o.source === "^\\s*$"
		? !1
		: !!(o.exec("") && o.lastIndex === 0)
}
function Iv(o) {
	return o.split(/\r\n|\r|\n/)
}
function xv(o) {
	for (let e = 0, t = o.length; e < t; e++) {
		let n = o.charCodeAt(e)
		if (n !== 32 && n !== 9) return e
	}
	return -1
}
function vA(o, e = o.length - 1) {
	for (let t = e; t >= 0; t--) {
		let n = o.charCodeAt(t)
		if (n !== 32 && n !== 9) return t
	}
	return -1
}
function Lo(o, e) {
	return o < e ? -1 : o > e ? 1 : 0
}
function Cv(o, e, t = 0, n = o.length, r = 0, i = e.length) {
	for (; t < n && r < i; t++, r++) {
		let l = o.charCodeAt(t),
			d = e.charCodeAt(r)
		if (l < d) return -1
		if (l > d) return 1
	}
	let s = n - t,
		a = i - r
	return s < a ? -1 : s > a ? 1 : 0
}
function Sv(o, e) {
	return bc(o, e, 0, o.length, 0, e.length)
}
function bc(o, e, t = 0, n = o.length, r = 0, i = e.length) {
	for (; t < n && r < i; t++, r++) {
		let l = o.charCodeAt(t),
			d = e.charCodeAt(r)
		if (l === d) continue
		if (l >= 128 || d >= 128) return Cv(o.toLowerCase(), e.toLowerCase(), t, n, r, i)
		uA(l) && (l -= 32), uA(d) && (d -= 32)
		let c = l - d
		if (c !== 0) return c
	}
	let s = n - t,
		a = i - r
	return s < a ? -1 : s > a ? 1 : 0
}
function uA(o) {
	return o >= 97 && o <= 122
}
function uE(o) {
	return o >= 65 && o <= 90
}
function xn(o, e) {
	return o.length === e.length && bc(o, e) === 0
}
function Ji(o, e) {
	let t = e.length
	return e.length > o.length ? !1 : bc(o, e, 0, t) === 0
}
function bA(o, e) {
	let t = Math.min(o.length, e.length),
		n
	for (n = 0; n < t; n++) if (o.charCodeAt(n) !== e.charCodeAt(n)) return n
	return t
}
function kl(o) {
	return 55296 <= o && o <= 56319
}
function sf(o) {
	return 56320 <= o && o <= 57343
}
function Tv(o, e) {
	return ((o - 55296) << 10) + (e - 56320) + 65536
}
function pE(o, e, t) {
	let n = o.charCodeAt(t)
	if (kl(n) && t + 1 < e) {
		let r = o.charCodeAt(t + 1)
		if (sf(r)) return Tv(n, r)
	}
	return n
}
function QH(o, e) {
	let t = o.charCodeAt(e - 1)
	if (sf(t) && e > 1) {
		let n = o.charCodeAt(e - 2)
		if (kl(n)) return Tv(n, t)
	}
	return t
}
var aE = class {
		get offset() {
			return this._offset
		}
		constructor(e, t = 0) {
			;(this._str = e), (this._len = e.length), (this._offset = t)
		}
		setOffset(e) {
			this._offset = e
		}
		prevCodePoint() {
			let e = QH(this._str, this._offset)
			return (this._offset -= e >= 65536 ? 2 : 1), e
		}
		nextCodePoint() {
			let e = pE(this._str, this._len, this._offset)
			return (this._offset += e >= 65536 ? 2 : 1), e
		}
		eol() {
			return this._offset >= this._len
		}
	},
	lE = class {
		get offset() {
			return this._iterator.offset
		}
		constructor(e, t = 0) {
			this._iterator = new aE(e, t)
		}
		nextGraphemeLength() {
			let e = vv.getInstance(),
				t = this._iterator,
				n = t.offset,
				r = e.getGraphemeBreakType(t.nextCodePoint())
			for (; !t.eol(); ) {
				let i = t.offset,
					s = e.getGraphemeBreakType(t.nextCodePoint())
				if (pA(r, s)) {
					t.setOffset(i)
					break
				}
				r = s
			}
			return t.offset - n
		}
		prevGraphemeLength() {
			let e = vv.getInstance(),
				t = this._iterator,
				n = t.offset,
				r = e.getGraphemeBreakType(t.prevCodePoint())
			for (; t.offset > 0; ) {
				let i = t.offset,
					s = e.getGraphemeBreakType(t.prevCodePoint())
				if (pA(s, r)) {
					t.setOffset(i)
					break
				}
				r = s
			}
			return n - t.offset
		}
		eol() {
			return this._iterator.eol()
		}
	}
function mE(o, e) {
	return new lE(o, e).nextGraphemeLength()
}
var sE
function JH() {
	return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/
}
function Ev(o) {
	return sE || (sE = JH()), sE.test(o)
}
var XH = /^[\t\n\r\x20-\x7E]*$/
function yA(o) {
	return XH.test(o)
}
var YH = /[\u2028\u2029]/
function wv(o) {
	return YH.test(o)
}
var ZH = /(?:\x1b\[|\x9b)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/,
	e4 = /(?:\x1b\]|\x9d).*?(?:\x1b\\|\x07|\x9c)/,
	t4 = /\x1b(?:[ #%\(\)\*\+\-\.\/]?[a-zA-Z0-9\|}~@])/,
	I3 = new RegExp("(?:" + [ZH.source, e4.source, t4.source].join("|") + ")", "g")
var IA = String.fromCharCode(65279)
function xA(o) {
	return !!(o && o.length > 0 && o.charCodeAt(0) === 65279)
}
function CA(o, e) {
	if (!o || !e || o.length < e.length) return !1
	let t = e.length,
		n = o.toLowerCase(),
		r = 0,
		i = -1
	for (; r < t; ) {
		let s = n.indexOf(e[r], i + 1)
		if (s < 0) return !1
		;(i = s), r++
	}
	return !0
}
function fE(o, e = !1) {
	return o ? (e && (o = o.replace(/\\./g, "")), o.toLowerCase() !== o) : !1
}
function SA(o) {
	return o.charAt(0).toUpperCase() + o.slice(1)
}
function TA(o, e = 1) {
	if (e === 0) return ""
	let t = -1
	do
		(t = o.indexOf(
			`
`,
			t + 1,
		)),
			e--
	while (e > 0 && t >= 0)
	return t === -1 ? o : (o[t - 1] === "\r" && t--, o.substr(0, t))
}
function pA(o, e) {
	return o === 0
		? e !== 5 && e !== 7
		: o === 2 && e === 3
			? !1
			: o === 4 || o === 2 || o === 3 || e === 4 || e === 2 || e === 3
				? !0
				: !(
						(o === 8 && (e === 8 || e === 9 || e === 11 || e === 12)) ||
						((o === 11 || o === 9) && (e === 9 || e === 10)) ||
						((o === 12 || o === 10) && e === 10) ||
						e === 5 ||
						e === 13 ||
						e === 7 ||
						o === 1 ||
						(o === 13 && e === 14) ||
						(o === 6 && e === 6)
					)
}
var vv = class o {
	static {
		this._INSTANCE = null
	}
	static getInstance() {
		return o._INSTANCE || (o._INSTANCE = new o()), o._INSTANCE
	}
	constructor() {
		this._data = n4()
	}
	getGraphemeBreakType(e) {
		if (e < 32) return e === 10 ? 3 : e === 13 ? 2 : 4
		if (e < 127) return 0
		let t = this._data,
			n = t.length / 3,
			r = 1
		for (; r <= n; )
			if (e < t[3 * r]) r = 2 * r
			else if (e > t[3 * r + 1]) r = 2 * r + 1
			else return t[3 * r + 2]
		return 0
	}
}
function n4() {
	return JSON.parse(
		"[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]",
	)
}
var mA = class o {
		constructor(e) {
			this.confusableDictionary = e
		}
		static {
			this.ambiguousCharacterData = new Rt(() =>
				JSON.parse(
					'{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}',
				),
			)
		}
		static {
			this.cache = new hv({ getCacheKey: JSON.stringify }, (e) => {
				function t(c) {
					let u = new Map()
					for (let m = 0; m < c.length; m += 2) u.set(c[m], c[m + 1])
					return u
				}
				function n(c, u) {
					let m = new Map(c)
					for (let [f, h] of u) m.set(f, h)
					return m
				}
				function r(c, u) {
					if (!c) return u
					let m = new Map()
					for (let [f, h] of c) u.has(f) && m.set(f, h)
					return m
				}
				let i = this.ambiguousCharacterData.value,
					s = e.filter((c) => !c.startsWith("_") && c in i)
				s.length === 0 && (s = ["_default"])
				let a
				for (let c of s) {
					let u = t(i[c])
					a = r(a, u)
				}
				let l = t(i._common),
					d = n(l, a)
				return new o(d)
			})
		}
		static getInstance(e) {
			return o.cache.get(Array.from(e))
		}
		static {
			this._locales = new Rt(() => Object.keys(o.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")))
		}
		static getLocales() {
			return o._locales.value
		}
		isAmbiguous(e) {
			return this.confusableDictionary.has(e)
		}
		containsAmbiguousCharacter(e) {
			for (let t = 0; t < e.length; t++) {
				let n = e.codePointAt(t)
				if (typeof n == "number" && this.isAmbiguous(n)) return !0
			}
			return !1
		}
		getPrimaryConfusable(e) {
			return this.confusableDictionary.get(e)
		}
		getConfusableCodePoints() {
			return new Set(this.confusableDictionary.keys())
		}
	},
	fA = class o {
		static getRawData() {
			return JSON.parse(
				'{"_common":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],"cs":[173,8203,12288],"de":[173,8203,12288],"es":[8203,12288],"fr":[173,8203,12288],"it":[160,173,12288],"ja":[173],"ko":[173,12288],"pl":[173,8203,12288],"pt-BR":[173,8203,12288],"qps-ploc":[160,173,8203,12288],"ru":[173,12288],"tr":[160,173,8203,12288],"zh-hans":[160,173,8203,12288],"zh-hant":[173,12288]}',
			)
		}
		static {
			this._data = void 0
		}
		static getData() {
			return this._data || (this._data = new Set([...Object.values(o.getRawData())].flat())), this._data
		}
		static isInvisibleCharacter(e) {
			return o.getData().has(e)
		}
		static containsInvisibleCharacter(e) {
			for (let t = 0; t < e.length; t++) {
				let n = e.codePointAt(t)
				if (typeof n == "number" && (o.isInvisibleCharacter(n) || n === 32)) return !0
			}
			return !1
		}
		static get codePoints() {
			return o.getData()
		}
	}
function oa(o) {
	return o === 47 || o === 92
}
function Pv(o) {
	return o.replace(/[\\/]/g, Ue.sep)
}
function EA(o) {
	return o.indexOf("/") === -1 && (o = Pv(o)), /^[a-zA-Z]:(\/|$)/.test(o) && (o = "/" + o), o
}
function af(o, e = Ue.sep) {
	if (!o) return ""
	let t = o.length,
		n = o.charCodeAt(0)
	if (oa(n)) {
		if (oa(o.charCodeAt(1)) && !oa(o.charCodeAt(2))) {
			let i = 3,
				s = i
			for (; i < t && !oa(o.charCodeAt(i)); i++);
			if (s !== i && !oa(o.charCodeAt(i + 1))) {
				for (i += 1; i < t; i++) if (oa(o.charCodeAt(i))) return o.slice(0, i + 1).replace(/[\\/]/g, e)
			}
		}
		return e
	} else if (PA(n) && o.charCodeAt(1) === 58) return oa(o.charCodeAt(2)) ? o.slice(0, 2) + e : o.slice(0, 2)
	let r = o.indexOf("://")
	if (r !== -1) {
		for (r += 3; r < t; r++) if (oa(o.charCodeAt(r))) return o.slice(0, r + 1)
	}
	return ""
}
var r4 = /[\\/:\*\?"<>\|]/g,
	o4 = /[/]/g,
	i4 = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i
function wA(o, e = Ie) {
	let t = e ? r4 : o4
	return !(
		!o ||
		o.length === 0 ||
		/^\s+$/.test(o) ||
		((t.lastIndex = 0), t.test(o)) ||
		(e && i4.test(o)) ||
		o === "." ||
		o === ".." ||
		(e && o[o.length - 1] === ".") ||
		(e && o.length !== o.trim().length) ||
		o.length > 255
	)
}
function yc(o, e, t) {
	let n = o === e
	return !t || n ? n : !o || !e ? !1 : xn(o, e)
}
function zr(o, e, t, n = at) {
	if (o === e) return !0
	if (!o || !e || e.length > o.length) return !1
	if (t) {
		if (!Ji(o, e)) return !1
		if (e.length === o.length) return !0
		let i = e.length
		return e.charAt(e.length - 1) === n && i--, o.charAt(i) === n
	}
	return e.charAt(e.length - 1) !== n && (e += n), o.indexOf(e) === 0
}
function PA(o) {
	return (o >= 65 && o <= 90) || (o >= 97 && o <= 122)
}
function _A(o) {
	return Ie ? ((o = Dr(o, at)), o.endsWith(":") && (o += at)) : ((o = Dr(o, at)), o || (o = at)), o
}
function gE(o) {
	let e = jn(o)
	return Ie ? (o.length > 3 ? !1 : _v(e) && (o.length === 2 || e.charCodeAt(2) === 92)) : e === Ue.sep
}
function _v(o, e = Ie) {
	return e ? PA(o.charCodeAt(0)) && o.charCodeAt(1) === 58 : !1
}
function hE(o, e = Ie) {
	return _v(o, e) ? o[0] : void 0
}
var s4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
	a4 = "BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789"
function DA(o, e, t = 8) {
	let n = ""
	for (let i = 0; i < t; i++) {
		let s
		i === 0 && Ie && !e && (t === 3 || t === 4) ? (s = a4) : (s = s4),
			(n += s.charAt(Math.floor(Math.random() * s.length)))
	}
	let r
	return e ? (r = `${e}-${n}`) : (r = n), o ? Fe(o, r) : r
}
var l4 = /^\w[\w\d+.-]*$/,
	d4 = /^\//,
	c4 = /^\/\//
function u4(o, e) {
	if (!o.scheme && e)
		throw new Error(
			`[UriError]: Scheme is missing: {scheme: "", authority: "${o.authority}", path: "${o.path}", query: "${o.query}", fragment: "${o.fragment}"}`,
		)
	if (o.scheme && !l4.test(o.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.")
	if (o.path) {
		if (o.authority) {
			if (!d4.test(o.path))
				throw new Error(
					'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
				)
		} else if (c4.test(o.path))
			throw new Error(
				'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
			)
	}
}
function p4(o, e) {
	return !o && !e ? "file" : o
}
function m4(o, e) {
	switch (o) {
		case "https":
		case "http":
		case "file":
			e ? e[0] !== Mo && (e = Mo + e) : (e = Mo)
			break
	}
	return e
}
var Ot = "",
	Mo = "/",
	f4 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
	y = class o {
		static isUri(e) {
			return e instanceof o
				? !0
				: e
					? typeof e.authority == "string" &&
						typeof e.fragment == "string" &&
						typeof e.path == "string" &&
						typeof e.query == "string" &&
						typeof e.scheme == "string" &&
						typeof e.fsPath == "string" &&
						typeof e.with == "function" &&
						typeof e.toString == "function"
					: !1
		}
		constructor(e, t, n, r, i, s = !1) {
			typeof e == "object"
				? ((this.scheme = e.scheme || Ot),
					(this.authority = e.authority || Ot),
					(this.path = e.path || Ot),
					(this.query = e.query || Ot),
					(this.fragment = e.fragment || Ot))
				: ((this.scheme = p4(e, s)),
					(this.authority = t || Ot),
					(this.path = m4(this.scheme, n || Ot)),
					(this.query = r || Ot),
					(this.fragment = i || Ot),
					u4(this, s))
		}
		get fsPath() {
			return lf(this, !1)
		}
		with(e) {
			if (!e) return this
			let { scheme: t, authority: n, path: r, query: i, fragment: s } = e
			return (
				t === void 0 ? (t = this.scheme) : t === null && (t = Ot),
				n === void 0 ? (n = this.authority) : n === null && (n = Ot),
				r === void 0 ? (r = this.path) : r === null && (r = Ot),
				i === void 0 ? (i = this.query) : i === null && (i = Ot),
				s === void 0 ? (s = this.fragment) : s === null && (s = Ot),
				t === this.scheme && n === this.authority && r === this.path && i === this.query && s === this.fragment
					? this
					: new ia(t, n, r, i, s)
			)
		}
		static parse(e, t = !1) {
			let n = f4.exec(e)
			return n
				? new ia(n[2] || Ot, Dv(n[4] || Ot), Dv(n[5] || Ot), Dv(n[7] || Ot), Dv(n[9] || Ot), t)
				: new ia(Ot, Ot, Ot, Ot, Ot)
		}
		static file(e) {
			let t = Ot
			if ((Ie && (e = e.replace(/\\/g, Mo)), e[0] === Mo && e[1] === Mo)) {
				let n = e.indexOf(Mo, 2)
				n === -1 ? ((t = e.substring(2)), (e = Mo)) : ((t = e.substring(2, n)), (e = e.substring(n) || Mo))
			}
			return new ia("file", t, e, Ot, Ot)
		}
		static from(e, t) {
			return new ia(e.scheme, e.authority, e.path, e.query, e.fragment, t)
		}
		static joinPath(e, ...t) {
			if (!e.path) throw new Error("[UriError]: cannot call joinPath on URI without path")
			let n
			return (
				Ie && e.scheme === "file" ? (n = o.file(qt.join(lf(e, !0), ...t)).path) : (n = Ue.join(e.path, ...t)),
				e.with({ path: n })
			)
		}
		toString(e = !1) {
			return bE(this, e)
		}
		toJSON() {
			return this
		}
		static revive(e) {
			if (e) {
				if (e instanceof o) return e
				{
					let t = new ia(e)
					return (
						(t._formatted = e.external ?? null), (t._fsPath = e._sep === AA ? (e.fsPath ?? null) : null), t
					)
				}
			} else return e
		}
		[Symbol.for("debug.description")]() {
			return `URI(${this.toString()})`
		}
	}
function df(o) {
	return !o || typeof o != "object"
		? !1
		: typeof o.scheme == "string" &&
				(typeof o.authority == "string" || typeof o.authority > "u") &&
				(typeof o.path == "string" || typeof o.path > "u") &&
				(typeof o.query == "string" || typeof o.query > "u") &&
				(typeof o.fragment == "string" || typeof o.fragment > "u")
}
var AA = Ie ? 1 : void 0,
	ia = class extends y {
		constructor() {
			super(...arguments)
			this._formatted = null
			this._fsPath = null
		}
		get fsPath() {
			return this._fsPath || (this._fsPath = lf(this, !1)), this._fsPath
		}
		toString(t = !1) {
			return t ? bE(this, !0) : (this._formatted || (this._formatted = bE(this, !1)), this._formatted)
		}
		toJSON() {
			let t = { $mid: 1 }
			return (
				this._fsPath && ((t.fsPath = this._fsPath), (t._sep = AA)),
				this._formatted && (t.external = this._formatted),
				this.path && (t.path = this.path),
				this.scheme && (t.scheme = this.scheme),
				this.authority && (t.authority = this.authority),
				this.query && (t.query = this.query),
				this.fragment && (t.fragment = this.fragment),
				t
			)
		}
	},
	OA = {
		58: "%3A",
		47: "%2F",
		63: "%3F",
		35: "%23",
		91: "%5B",
		93: "%5D",
		64: "%40",
		33: "%21",
		36: "%24",
		38: "%26",
		39: "%27",
		40: "%28",
		41: "%29",
		42: "%2A",
		43: "%2B",
		44: "%2C",
		59: "%3B",
		61: "%3D",
		32: "%20",
	}
function kA(o, e, t) {
	let n,
		r = -1
	for (let i = 0; i < o.length; i++) {
		let s = o.charCodeAt(i)
		if (
			(s >= 97 && s <= 122) ||
			(s >= 65 && s <= 90) ||
			(s >= 48 && s <= 57) ||
			s === 45 ||
			s === 46 ||
			s === 95 ||
			s === 126 ||
			(e && s === 47) ||
			(t && s === 91) ||
			(t && s === 93) ||
			(t && s === 58)
		)
			r !== -1 && ((n += encodeURIComponent(o.substring(r, i))), (r = -1)), n !== void 0 && (n += o.charAt(i))
		else {
			n === void 0 && (n = o.substr(0, i))
			let a = OA[s]
			a !== void 0
				? (r !== -1 && ((n += encodeURIComponent(o.substring(r, i))), (r = -1)), (n += a))
				: r === -1 && (r = i)
		}
	}
	return r !== -1 && (n += encodeURIComponent(o.substring(r))), n !== void 0 ? n : o
}
function g4(o) {
	let e
	for (let t = 0; t < o.length; t++) {
		let n = o.charCodeAt(t)
		n === 35 || n === 63 ? (e === void 0 && (e = o.substr(0, t)), (e += OA[n])) : e !== void 0 && (e += o[t])
	}
	return e !== void 0 ? e : o
}
function lf(o, e) {
	let t
	return (
		o.authority && o.path.length > 1 && o.scheme === "file"
			? (t = `//${o.authority}${o.path}`)
			: o.path.charCodeAt(0) === 47 &&
				  ((o.path.charCodeAt(1) >= 65 && o.path.charCodeAt(1) <= 90) ||
						(o.path.charCodeAt(1) >= 97 && o.path.charCodeAt(1) <= 122)) &&
				  o.path.charCodeAt(2) === 58
				? e
					? (t = o.path.substr(1))
					: (t = o.path[1].toLowerCase() + o.path.substr(2))
				: (t = o.path),
		Ie && (t = t.replace(/\//g, "\\")),
		t
	)
}
function bE(o, e) {
	let t = e ? g4 : kA,
		n = "",
		{ scheme: r, authority: i, path: s, query: a, fragment: l } = o
	if ((r && ((n += r), (n += ":")), (i || r === "file") && ((n += Mo), (n += Mo)), i)) {
		let d = i.indexOf("@")
		if (d !== -1) {
			let c = i.substr(0, d)
			;(i = i.substr(d + 1)),
				(d = c.lastIndexOf(":")),
				d === -1
					? (n += t(c, !1, !1))
					: ((n += t(c.substr(0, d), !1, !1)), (n += ":"), (n += t(c.substr(d + 1), !1, !0))),
				(n += "@")
		}
		;(i = i.toLowerCase()),
			(d = i.lastIndexOf(":")),
			d === -1 ? (n += t(i, !1, !0)) : ((n += t(i.substr(0, d), !1, !0)), (n += i.substr(d)))
	}
	if (s) {
		if (s.length >= 3 && s.charCodeAt(0) === 47 && s.charCodeAt(2) === 58) {
			let d = s.charCodeAt(1)
			d >= 65 && d <= 90 && (s = `/${String.fromCharCode(d + 32)}:${s.substr(3)}`)
		} else if (s.length >= 2 && s.charCodeAt(1) === 58) {
			let d = s.charCodeAt(0)
			d >= 65 && d <= 90 && (s = `${String.fromCharCode(d + 32)}:${s.substr(2)}`)
		}
		n += t(s, !0, !1)
	}
	return a && ((n += "?"), (n += t(a, !1, !1))), l && ((n += "#"), (n += e ? l : kA(l, !1, !1))), n
}
function LA(o) {
	try {
		return decodeURIComponent(o)
	} catch {
		return o.length > 3 ? o.substr(0, 3) + LA(o.substr(3)) : o
	}
}
var RA = /(%[0-9A-Za-z][0-9A-Za-z])+/g
function Dv(o) {
	return o.match(RA) ? o.replace(RA, (e) => LA(e)) : o
}
var W
;((Se) => (
	(Se.inMemory = "inmemory"),
	(Se.vscode = "vscode"),
	(Se.internal = "private"),
	(Se.walkThrough = "walkThrough"),
	(Se.walkThroughSnippet = "walkThroughSnippet"),
	(Se.http = "http"),
	(Se.https = "https"),
	(Se.file = "file"),
	(Se.mailto = "mailto"),
	(Se.untitled = "untitled"),
	(Se.data = "data"),
	(Se.command = "command"),
	(Se.vscodeRemote = "vscode-remote"),
	(Se.vscodeRemoteResource = "vscode-remote-resource"),
	(Se.vscodeManagedRemoteResource = "vscode-managed-remote-resource"),
	(Se.vscodeUserData = "vscode-userdata"),
	(Se.vscodeCustomEditor = "vscode-custom-editor"),
	(Se.vscodeNotebookCell = "vscode-notebook-cell"),
	(Se.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata"),
	(Se.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff"),
	(Se.vscodeNotebookCellOutput = "vscode-notebook-cell-output"),
	(Se.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff"),
	(Se.vscodeNotebookMetadata = "vscode-notebook-metadata"),
	(Se.vscodeInteractiveInput = "vscode-interactive-input"),
	(Se.vscodeSettings = "vscode-settings"),
	(Se.vscodeWorkspaceTrust = "vscode-workspace-trust"),
	(Se.vscodeTerminal = "vscode-terminal"),
	(Se.vscodeChatCodeBlock = "vscode-chat-code-block"),
	(Se.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block"),
	(Se.vscodeChatSesssion = "vscode-chat-editor"),
	(Se.webviewPanel = "webview-panel"),
	(Se.vscodeWebview = "vscode-webview"),
	(Se.extension = "extension"),
	(Se.vscodeFileResource = "vscode-file"),
	(Se.tmp = "tmp"),
	(Se.vsls = "vsls"),
	(Se.vscodeSourceControl = "vscode-scm"),
	(Se.commentsInput = "comment"),
	(Se.codeSetting = "code-setting"),
	(Se.outputChannel = "output"),
	(Se.accessibleView = "accessible-view")
))((W ||= {}))
function kv(o, e) {
	return y.isUri(o) ? xn(o.scheme, e) : Ji(o, e + ":")
}
function MA(o, ...e) {
	return e.some((t) => kv(o, t))
}
var h4 = "tkn",
	yE = class {
		constructor() {
			this._hosts = Object.create(null)
			this._ports = Object.create(null)
			this._connectionTokens = Object.create(null)
			this._preferredWebSchema = "http"
			this._delegate = null
			this._serverRootPath = "/"
		}
		setPreferredWebSchema(e) {
			this._preferredWebSchema = e
		}
		setDelegate(e) {
			this._delegate = e
		}
		setServerRootPath(e, t) {
			this._serverRootPath = Ue.join(t ?? "/", v4(e))
		}
		getServerRootPath() {
			return this._serverRootPath
		}
		get _remoteResourcesPath() {
			return Ue.join(this._serverRootPath, W.vscodeRemoteResource)
		}
		set(e, t, n) {
			;(this._hosts[e] = t), (this._ports[e] = n)
		}
		setConnectionToken(e, t) {
			this._connectionTokens[e] = t
		}
		getPreferredWebSchema() {
			return this._preferredWebSchema
		}
		rewrite(e) {
			if (this._delegate)
				try {
					return this._delegate(e)
				} catch (a) {
					return Be(a), e
				}
			let t = e.authority,
				n = this._hosts[t]
			n && n.indexOf(":") !== -1 && n.indexOf("[") === -1 && (n = `[${n}]`)
			let r = this._ports[t],
				i = this._connectionTokens[t],
				s = `path=${encodeURIComponent(e.path)}`
			return (
				typeof i == "string" && (s += `&${h4}=${encodeURIComponent(i)}`),
				y.from({
					scheme: Ro ? this._preferredWebSchema : W.vscodeRemoteResource,
					authority: `${n}:${r}`,
					path: this._remoteResourcesPath,
					query: s,
				})
			)
		}
	},
	xE = new yE()
function v4(o) {
	return `${o.quality ?? "oss"}-${o.commit ?? "dev"}`
}
var FA = "vs/../../node_modules",
	NA = "vs/../../node_modules.asar"
var CE = "vscode-app",
	IE = class o {
		static {
			this.FALLBACK_AUTHORITY = CE
		}
		asBrowserUri(e) {
			let t = this.toUri(e)
			return this.uriToBrowserUri(t)
		}
		uriToBrowserUri(e) {
			return e.scheme === W.vscodeRemote
				? xE.rewrite(e)
				: e.scheme === W.file && (av || oA === `${W.vscodeFileResource}://${o.FALLBACK_AUTHORITY}`)
					? e.with({
							scheme: W.vscodeFileResource,
							authority: e.authority || o.FALLBACK_AUTHORITY,
							query: null,
							fragment: null,
						})
					: e
		}
		asFileUri(e) {
			let t = this.toUri(e)
			return this.uriToFileUri(t)
		}
		uriToFileUri(e) {
			return e.scheme === W.vscodeFileResource
				? e.with({
						scheme: W.file,
						authority: e.authority !== o.FALLBACK_AUTHORITY ? e.authority : null,
						query: null,
						fragment: null,
					})
				: e
		}
		toUri(e) {
			if (y.isUri(e)) return e
			if (globalThis._VSCODE_FILE_ROOT) {
				let t = globalThis._VSCODE_FILE_ROOT
				if (/^\w[\w\d+.-]*:\/\//.test(t)) return y.joinPath(y.parse(t, !0), e)
				let n = Fe(t, e)
				return y.file(n)
			}
			throw new Error("Cannot determine URI for module id!")
		}
	},
	Ic = new IE(),
	O3 = Object.freeze({ "Cache-Control": "no-cache, no-store" }),
	L3 = Object.freeze({ "Document-Policy": "include-js-call-stacks-in-crash-reports" }),
	b4
;((i) => {
	let o = new Map([
		["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
		["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
		["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }],
	])
	i.CoopAndCoep = Object.freeze(o.get("3"))
	let t = "vscode-coi"
	function n(s) {
		let a
		typeof s == "string"
			? (a = new URL(s).searchParams)
			: s instanceof URL
				? (a = s.searchParams)
				: y.isUri(s) && (a = new URL(s.toString(!0)).searchParams)
		let l = a?.get(t)
		if (l) return o.get(l)
	}
	i.getHeadersFromQuery = n
	function r(s, a, l) {
		if (!globalThis.crossOriginIsolated) return
		let d = a && l ? "3" : l ? "2" : "1"
		s instanceof URLSearchParams ? s.set(t, d) : (s[t] = d)
	}
	i.addSearchParam = r
})((b4 ||= {}))
function oo(o) {
	return lf(o, !0)
}
var Xi = class {
		constructor(e) {
			this._ignorePathCasing = e
		}
		compare(e, t, n = !1) {
			return e === t ? 0 : Lo(this.getComparisonKey(e, n), this.getComparisonKey(t, n))
		}
		isEqual(e, t, n = !1) {
			return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, n) === this.getComparisonKey(t, n)
		}
		getComparisonKey(e, t = !1) {
			return e
				.with({ path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0, fragment: t ? null : void 0 })
				.toString()
		}
		ignorePathCasing(e) {
			return this._ignorePathCasing(e)
		}
		isEqualOrParent(e, t, n = !1) {
			if (e.scheme === t.scheme) {
				if (e.scheme === W.file)
					return (
						zr(oo(e), oo(t), this._ignorePathCasing(e)) &&
						e.query === t.query &&
						(n || e.fragment === t.fragment)
					)
				if (UA(e.authority, t.authority))
					return (
						zr(e.path, t.path, this._ignorePathCasing(e), "/") &&
						e.query === t.query &&
						(n || e.fragment === t.fragment)
					)
			}
			return !1
		}
		joinPath(e, ...t) {
			return y.joinPath(e, ...t)
		}
		basenameOrAuthority(e) {
			return Ht(e) || e.authority
		}
		basename(e) {
			return Ue.basename(e.path)
		}
		extname(e) {
			return Ue.extname(e.path)
		}
		dirname(e) {
			if (e.path.length === 0) return e
			let t
			return (
				e.scheme === W.file
					? (t = y.file(Qt(oo(e))).path)
					: ((t = Ue.dirname(e.path)),
						e.authority &&
							t.length &&
							t.charCodeAt(0) !== 47 &&
							(console.error(`dirname("${e.toString})) resulted in a relative path`), (t = "/"))),
				e.with({ path: t })
			)
		}
		normalizePath(e) {
			if (!e.path.length) return e
			let t
			return e.scheme === W.file ? (t = y.file(jn(oo(e))).path) : (t = Ue.normalize(e.path)), e.with({ path: t })
		}
		relativePath(e, t) {
			if (e.scheme !== t.scheme || !UA(e.authority, t.authority)) return
			if (e.scheme === W.file) {
				let i = Oo(oo(e), oo(t))
				return Ie ? Pv(i) : i
			}
			let n = e.path || "/",
				r = t.path || "/"
			if (this._ignorePathCasing(e)) {
				let i = 0
				for (
					let s = Math.min(n.length, r.length);
					i < s &&
					!(n.charCodeAt(i) !== r.charCodeAt(i) && n.charAt(i).toLowerCase() !== r.charAt(i).toLowerCase());
					i++
				);
				n = r.substr(0, i) + n.substr(i)
			}
			return Ue.relative(n, r)
		}
		resolvePath(e, t) {
			if (e.scheme === W.file) {
				let n = y.file(cA(oo(e), t))
				return e.with({ authority: n.authority, path: n.path })
			}
			return (t = EA(t)), e.with({ path: Ue.resolve(e.path, t) })
		}
		isAbsolutePath(e) {
			return !!e.path && e.path[0] === "/"
		}
		isEqualAuthority(e, t) {
			return e === t || (e !== void 0 && t !== void 0 && xn(e, t))
		}
		hasTrailingPathSeparator(e, t = at) {
			if (e.scheme === W.file) {
				let n = oo(e)
				return n.length > af(n).length && n[n.length - 1] === t
			} else {
				let n = e.path
				return n.length > 1 && n.charCodeAt(n.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath)
			}
		}
		removeTrailingPathSeparator(e, t = at) {
			return HA(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e
		}
		addTrailingPathSeparator(e, t = at) {
			let n = !1
			if (e.scheme === W.file) {
				let r = oo(e)
				n = r !== void 0 && r.length === af(r).length && r[r.length - 1] === t
			} else {
				t = "/"
				let r = e.path
				n = r.length === 1 && r.charCodeAt(r.length - 1) === 47
			}
			return !n && !HA(e, t) ? e.with({ path: e.path + "/" }) : e
		}
	},
	et = new Xi(() => !1),
	Rl = new Xi((o) => (o.scheme === W.file ? !Ve : !0)),
	SE = new Xi((o) => !0),
	qr = et.isEqual.bind(et),
	y4 = et.isEqualOrParent.bind(et),
	V3 = et.getComparisonKey.bind(et),
	cf = et.basenameOrAuthority.bind(et),
	Ht = et.basename.bind(et),
	Rv = et.extname.bind(et),
	Yi = et.dirname.bind(et),
	ct = et.joinPath.bind(et),
	B3 = et.normalizePath.bind(et),
	uf = et.relativePath.bind(et),
	$3 = et.resolvePath.bind(et),
	WA = et.isAbsolutePath.bind(et),
	UA = et.isEqualAuthority.bind(et),
	HA = et.hasTrailingPathSeparator.bind(et),
	z3 = et.removeTrailingPathSeparator.bind(et),
	q3 = et.addTrailingPathSeparator.bind(et)
var I4
;((i) => {
	;(i.META_DATA_LABEL = "label"),
		(i.META_DATA_DESCRIPTION = "description"),
		(i.META_DATA_SIZE = "size"),
		(i.META_DATA_MIME = "mime")
	function r(s) {
		let a = new Map()
		s.path
			.substring(s.path.indexOf(";") + 1, s.path.lastIndexOf(";"))
			.split(";")
			.forEach((c) => {
				let [u, m] = c.split(":")
				u && m && a.set(u, m)
			})
		let d = s.path.substring(0, s.path.indexOf(";"))
		return d && a.set(i.META_DATA_MIME, d), a
	}
	i.parseMetaData = r
})((I4 ||= {}))
var VA = Symbol("MicrotaskDelay")
function io(o) {
	return !!o && typeof o.then == "function"
}
function kr(o) {
	let e = new _e(),
		t = o(e.token),
		n = !1,
		r = new Promise((i, s) => {
			let a = e.token.onCancellationRequested(() => {
				;(n = !0), a.dispose(), s(new xt())
			})
			Promise.resolve(t).then(
				(l) => {
					a.dispose(), e.dispose(), n ? Zh(l) && l.dispose() : i(l)
				},
				(l) => {
					a.dispose(), e.dispose(), s(l)
				},
			)
		})
	return new (class {
		cancel() {
			e.cancel(), e.dispose()
		}
		then(i, s) {
			return r.then(i, s)
		}
		catch(i) {
			return this.then(void 0, i)
		}
		finally(i) {
			return r.finally(i)
		}
	})()
}
function Fv(o, e, t) {
	return new Promise((n, r) => {
		let i = e.onCancellationRequested(() => {
			i.dispose(), n(t)
		})
		o.then(n, r).finally(() => i.dispose())
	})
}
function BA(o, e) {
	return new Promise((t, n) => {
		let r = e.onCancellationRequested(() => {
			r.dispose(), n(new xt())
		})
		o.then(t, n).finally(() => r.dispose())
	})
}
function Jt(o) {
	return new Promise((e, t) => {
		let n = o()
		io(n) ? n.then(e, t) : e(n)
	})
}
function ff() {
	let o, e
	return {
		promise: new Promise((n, r) => {
			;(o = n), (e = r)
		}),
		resolve: o,
		reject: e,
	}
}
var TE = class {
		constructor() {
			this.isDisposed = !1
			;(this.activePromise = null), (this.queuedPromise = null), (this.queuedPromiseFactory = null)
		}
		queue(e) {
			if (this.isDisposed) return Promise.reject(new Error("Throttler is disposed"))
			if (this.activePromise) {
				if (((this.queuedPromiseFactory = e), !this.queuedPromise)) {
					let t = () => {
						if (((this.queuedPromise = null), this.isDisposed)) return
						let n = this.queue(this.queuedPromiseFactory)
						return (this.queuedPromiseFactory = null), n
					}
					this.queuedPromise = new Promise((n) => {
						this.activePromise.then(t, t).then(n)
					})
				}
				return new Promise((t, n) => {
					this.queuedPromise.then(t, n)
				})
			}
			return (
				(this.activePromise = e()),
				new Promise((t, n) => {
					this.activePromise.then(
						(r) => {
							;(this.activePromise = null), t(r)
						},
						(r) => {
							;(this.activePromise = null), n(r)
						},
					)
				})
			)
		}
		dispose() {
			this.isDisposed = !0
		}
	},
	Ov = class {
		constructor() {
			this.current = Promise.resolve(null)
		}
		queue(e) {
			return (this.current = this.current.then(
				() => e(),
				() => e(),
			))
		}
	}
var x4 = (o, e) => {
		let t = !0,
			n = setTimeout(() => {
				;(t = !1), e()
			}, o)
		return {
			isTriggered: () => t,
			dispose: () => {
				clearTimeout(n), (t = !1)
			},
		}
	},
	C4 = (o) => {
		let e = !0
		return (
			queueMicrotask(() => {
				e && ((e = !1), o())
			}),
			{
				isTriggered: () => e,
				dispose: () => {
					e = !1
				},
			}
		)
	},
	pf = class {
		constructor(e) {
			this.defaultDelay = e
			;(this.deferred = null),
				(this.completionPromise = null),
				(this.doResolve = null),
				(this.doReject = null),
				(this.task = null)
		}
		trigger(e, t = this.defaultDelay) {
			;(this.task = e),
				this.cancelTimeout(),
				this.completionPromise ||
					(this.completionPromise = new Promise((r, i) => {
						;(this.doResolve = r), (this.doReject = i)
					}).then(() => {
						if (((this.completionPromise = null), (this.doResolve = null), this.task)) {
							let r = this.task
							return (this.task = null), r()
						}
					}))
			let n = () => {
				;(this.deferred = null), this.doResolve?.(null)
			}
			return (this.deferred = t === VA ? C4(n) : x4(t, n)), this.completionPromise
		}
		isTriggered() {
			return !!this.deferred?.isTriggered()
		}
		cancel() {
			this.cancelTimeout(), this.completionPromise && (this.doReject?.(new xt()), (this.completionPromise = null))
		}
		cancelTimeout() {
			this.deferred?.dispose(), (this.deferred = null)
		}
		dispose() {
			this.cancel()
		}
	},
	Zi = class {
		constructor(e) {
			;(this.delayer = new pf(e)), (this.throttler = new TE())
		}
		trigger(e, t) {
			return this.delayer.trigger(() => this.throttler.queue(e), t)
		}
		isTriggered() {
			return this.delayer.isTriggered()
		}
		cancel() {
			this.delayer.cancel()
		}
		dispose() {
			this.delayer.dispose(), this.throttler.dispose()
		}
	},
	dn = class {
		constructor() {
			;(this._isOpen = !1),
				(this._promise = new Promise((e, t) => {
					this._completePromise = e
				}))
		}
		isOpen() {
			return this._isOpen
		}
		open() {
			;(this._isOpen = !0), this._completePromise(!0)
		}
		wait() {
			return this._promise
		}
	}
function Wt(o, e) {
	return e
		? new Promise((t, n) => {
				let r = setTimeout(() => {
						i.dispose(), t()
					}, o),
					i = e.onCancellationRequested(() => {
						clearTimeout(r), i.dispose(), n(new xt())
					})
			})
		: kr((t) => Wt(o, t))
}
function gf(o, e = 0, t) {
	let n = setTimeout(() => {
			o(), t && r.dispose()
		}, e),
		r = q(() => {
			clearTimeout(n), t?.delete(r)
		})
	return t?.add(r), r
}
function $A(o, e = (n) => !!n, t = null) {
	if (o.length === 0) return Promise.resolve(t)
	let n = o.length,
		r = () => {
			n = -1
			for (let i of o) i.cancel?.()
		}
	return new Promise((i, s) => {
		for (let a of o)
			a.then((l) => {
				--n >= 0 && e(l) ? (r(), i(l)) : n === 0 && i(t)
			}).catch((l) => {
				--n >= 0 && (r(), s(l))
			})
	})
}
var EE = class {
		constructor(e) {
			this._size = 0
			this._isDisposed = !1
			;(this.maxDegreeOfParalellism = e),
				(this.outstandingPromises = []),
				(this.runningPromises = 0),
				(this._onDrained = new E())
		}
		whenIdle() {
			return this.size > 0 ? Te.toPromise(this.onDrained) : Promise.resolve()
		}
		get onDrained() {
			return this._onDrained.event
		}
		get size() {
			return this._size
		}
		queue(e) {
			if (this._isDisposed) throw new Error("Object has been disposed")
			return (
				this._size++,
				new Promise((t, n) => {
					this.outstandingPromises.push({ factory: e, c: t, e: n }), this.consume()
				})
			)
		}
		consume() {
			for (; this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism; ) {
				let e = this.outstandingPromises.shift()
				this.runningPromises++
				let t = e.factory()
				t.then(e.c, e.e),
					t.then(
						() => this.consumed(),
						() => this.consumed(),
					)
			}
		}
		consumed() {
			this._isDisposed ||
				(this.runningPromises--,
				--this._size === 0 && this._onDrained.fire(),
				this.outstandingPromises.length > 0 && this.consume())
		}
		clear() {
			if (this._isDisposed) throw new Error("Object has been disposed")
			;(this.outstandingPromises.length = 0), (this._size = this.runningPromises)
		}
		dispose() {
			;(this._isDisposed = !0), (this.outstandingPromises.length = 0), (this._size = 0), this._onDrained.dispose()
		}
	},
	wE = class extends EE {
		constructor() {
			super(1)
		}
	}
var Cc = class {
	constructor() {
		this.queues = new Map()
		this.drainers = new Set()
		this.drainListeners = void 0
		this.drainListenerCount = 0
	}
	async whenDrained() {
		if (this.isDrained()) return
		let e = new Cn()
		return this.drainers.add(e), e.p
	}
	isDrained() {
		for (let [, e] of this.queues) if (e.size > 0) return !1
		return !0
	}
	queueSize(e, t = et) {
		let n = t.getComparisonKey(e)
		return this.queues.get(n)?.size ?? 0
	}
	queueFor(e, t, n = et) {
		let r = n.getComparisonKey(e),
			i = this.queues.get(r)
		if (!i) {
			i = new wE()
			let s = this.drainListenerCount++,
				a = Te.once(i.onDrained)(() => {
					i?.dispose(),
						this.queues.delete(r),
						this.onDidQueueDrain(),
						this.drainListeners?.deleteAndDispose(s),
						this.drainListeners?.size === 0 &&
							(this.drainListeners.dispose(), (this.drainListeners = void 0))
				})
			this.drainListeners || (this.drainListeners = new Wr()),
				this.drainListeners.set(s, a),
				this.queues.set(r, i)
		}
		return i.queue(t)
	}
	onDidQueueDrain() {
		this.isDrained() && this.releaseDrainers()
	}
	releaseDrainers() {
		for (let e of this.drainers) e.complete()
		this.drainers.clear()
	}
	dispose() {
		for (let [, e] of this.queues) e.dispose()
		this.queues.clear(), this.releaseDrainers(), this.drainListeners?.dispose()
	}
}
var Sc = class {
		constructor() {
			this.disposable = void 0
			this.isDisposed = !1
		}
		cancel() {
			this.disposable?.dispose(), (this.disposable = void 0)
		}
		cancelAndSet(e, t, n = globalThis) {
			if (this.isDisposed) throw new Gt("Calling 'cancelAndSet' on a disposed IntervalTimer")
			this.cancel()
			let r = n.setInterval(() => {
				e()
			}, t)
			this.disposable = q(() => {
				n.clearInterval(r), (this.disposable = void 0)
			})
		}
		dispose() {
			this.cancel(), (this.isDisposed = !0)
		}
	},
	Hn = class {
		constructor(e, t) {
			;(this.timeoutToken = -1),
				(this.runner = e),
				(this.timeout = t),
				(this.timeoutHandler = this.onTimeout.bind(this))
		}
		dispose() {
			this.cancel(), (this.runner = null)
		}
		cancel() {
			this.isScheduled() && (clearTimeout(this.timeoutToken), (this.timeoutToken = -1))
		}
		schedule(e = this.timeout) {
			this.cancel(), (this.timeoutToken = setTimeout(this.timeoutHandler, e))
		}
		get delay() {
			return this.timeout
		}
		set delay(e) {
			this.timeout = e
		}
		isScheduled() {
			return this.timeoutToken !== -1
		}
		flush() {
			this.isScheduled() && (this.cancel(), this.doRun())
		}
		onTimeout() {
			;(this.timeoutToken = -1), this.runner && this.doRun()
		}
		doRun() {
			this.runner?.()
		}
	},
	mf = class {
		constructor(e, t) {
			t % 1e3 !== 0 &&
				console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${t}ms is not a multiple of 1000ms.`),
				(this.runner = e),
				(this.timeout = t),
				(this.counter = 0),
				(this.intervalToken = -1),
				(this.intervalHandler = this.onInterval.bind(this))
		}
		dispose() {
			this.cancel(), (this.runner = null)
		}
		cancel() {
			this.isScheduled() && (clearInterval(this.intervalToken), (this.intervalToken = -1))
		}
		schedule(e = this.timeout) {
			e % 1e3 !== 0 &&
				console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${e}ms is not a multiple of 1000ms.`),
				this.cancel(),
				(this.counter = Math.ceil(e / 1e3)),
				(this.intervalToken = setInterval(this.intervalHandler, 1e3))
		}
		isScheduled() {
			return this.intervalToken !== -1
		}
		onInterval() {
			this.counter--,
				!(this.counter > 0) && (clearInterval(this.intervalToken), (this.intervalToken = -1), this.runner?.())
		}
	},
	Lv = class extends Hn {
		constructor(t, n) {
			super(t, n)
			this.units = []
		}
		work(t) {
			this.units.push(t), this.isScheduled() || this.schedule()
		}
		doRun() {
			let t = this.units
			;(this.units = []), this.runner?.(t)
		}
		dispose() {
			;(this.units = []), super.dispose()
		}
	},
	Tc = class extends $ {
		constructor(t, n) {
			super()
			this.options = t
			this.handler = n
			this.pendingWork = []
			this.throttler = this._register(new Dn())
			this.disposed = !1
			this.lastExecutionTime = 0
		}
		get pending() {
			return this.pendingWork.length
		}
		work(t) {
			if (this.disposed) return !1
			if (typeof this.options.maxBufferedWork == "number") {
				if (this.throttler.value) {
					if (this.pending + t.length > this.options.maxBufferedWork) return !1
				} else if (this.pending + t.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork)
					return !1
			}
			for (let r of t) this.pendingWork.push(r)
			let n = Date.now() - this.lastExecutionTime
			return (
				!this.throttler.value &&
				(!this.options.waitThrottleDelayBetweenWorkUnits || n >= this.options.throttleDelay)
					? this.doWork()
					: !this.throttler.value &&
						this.options.waitThrottleDelayBetweenWorkUnits &&
						this.scheduleThrottler(Math.max(this.options.throttleDelay - n, 0)),
				!0
			)
		}
		doWork() {
			;(this.lastExecutionTime = Date.now()),
				this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize)),
				this.pendingWork.length > 0 && this.scheduleThrottler()
		}
		scheduleThrottler(t = this.options.throttleDelay) {
			;(this.throttler.value = new Hn(() => {
				this.throttler.clear(), this.doWork()
			}, t)),
				this.throttler.value.schedule()
		}
		dispose() {
			super.dispose(), (this.pendingWork.length = 0), (this.disposed = !0)
		}
	},
	_E,
	Av
;(function () {
	typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function"
		? (Av = (o, e, t) => {
				dv(() => {
					if (n) return
					let r = Date.now() + 15
					e(
						Object.freeze({
							didTimeout: !0,
							timeRemaining() {
								return Math.max(0, r - Date.now())
							},
						}),
					)
				})
				let n = !1
				return {
					dispose() {
						n || (n = !0)
					},
				}
			})
		: (Av = (o, e, t) => {
				let n = o.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0),
					r = !1
				return {
					dispose() {
						r || ((r = !0), o.cancelIdleCallback(n))
					},
				}
			}),
		(_E = (o, e) => Av(globalThis, o, e))
})()
var PE = class {
		constructor(e, t) {
			this._didRun = !1
			;(this._executor = () => {
				try {
					this._value = t()
				} catch (n) {
					this._error = n
				} finally {
					this._didRun = !0
				}
			}),
				(this._handle = Av(e, () => this._executor()))
		}
		dispose() {
			this._handle.dispose()
		}
		get value() {
			if ((this._didRun || (this._handle.dispose(), this._executor()), this._error)) throw this._error
			return this._value
		}
		get isInitialized() {
			return this._didRun
		}
	},
	Mv = class extends PE {
		constructor(e) {
			super(globalThis, e)
		}
	}
async function zA(o, e, t) {
	let n
	for (let r = 0; r < t; r++)
		try {
			return await o()
		} catch (i) {
			;(n = i), await Wt(e)
		}
	throw n
}
var Cn = class {
		get isRejected() {
			return this.outcome?.outcome === 1
		}
		get isResolved() {
			return this.outcome?.outcome === 0
		}
		get isSettled() {
			return !!this.outcome
		}
		get value() {
			return this.outcome?.outcome === 0 ? this.outcome?.value : void 0
		}
		constructor() {
			this.p = new Promise((e, t) => {
				;(this.completeCallback = e), (this.errorCallback = t)
			})
		}
		complete(e) {
			return new Promise((t) => {
				this.completeCallback(e), (this.outcome = { outcome: 0, value: e }), t()
			})
		}
		error(e) {
			return new Promise((t) => {
				this.errorCallback(e), (this.outcome = { outcome: 1, value: e }), t()
			})
		}
		cancel() {
			return this.error(new xt())
		}
	},
	so
;((t) => {
	async function o(n) {
		let r,
			i = await Promise.all(
				n.map((s) =>
					s.then(
						(a) => a,
						(a) => {
							r || (r = a)
						},
					),
				),
			)
		if (typeof r < "u") throw r
		return i
	}
	t.settled = o
	function e(n) {
		return new Promise(async (r, i) => {
			try {
				await n(r, i)
			} catch (s) {
				i(s)
			}
		})
	}
	t.withAsyncBody = e
})((so ||= {}))
var ci = class o {
	static fromArray(e) {
		return new o((t) => {
			t.emitMany(e)
		})
	}
	static fromPromise(e) {
		return new o(async (t) => {
			t.emitMany(await e)
		})
	}
	static fromPromisesResolveOrder(e) {
		return new o(async (t) => {
			await Promise.all(e.map(async (n) => t.emitOne(await n)))
		})
	}
	static merge(e) {
		return new o(async (t) => {
			await Promise.all(
				e.map(async (n) => {
					for await (let r of n) t.emitOne(r)
				}),
			)
		})
	}
	static {
		this.EMPTY = o.fromArray([])
	}
	constructor(e, t) {
		;(this._state = 0),
			(this._results = []),
			(this._error = null),
			(this._onReturn = t),
			(this._onStateChanged = new E()),
			queueMicrotask(async () => {
				let n = {
					emitOne: (r) => this.emitOne(r),
					emitMany: (r) => this.emitMany(r),
					reject: (r) => this.reject(r),
				}
				try {
					await Promise.resolve(e(n)), this.resolve()
				} catch (r) {
					this.reject(r)
				} finally {
					;(n.emitOne = void 0), (n.emitMany = void 0), (n.reject = void 0)
				}
			})
	}
	[Symbol.asyncIterator]() {
		let e = 0
		return {
			next: async () => {
				do {
					if (this._state === 2) throw this._error
					if (e < this._results.length) return { done: !1, value: this._results[e++] }
					if (this._state === 1) return { done: !0, value: void 0 }
					await Te.toPromise(this._onStateChanged.event)
				} while (!0)
			},
			return: async () => (this._onReturn?.(), { done: !0, value: void 0 }),
		}
	}
	static map(e, t) {
		return new o(async (n) => {
			for await (let r of e) n.emitOne(t(r))
		})
	}
	map(e) {
		return o.map(this, e)
	}
	static filter(e, t) {
		return new o(async (n) => {
			for await (let r of e) t(r) && n.emitOne(r)
		})
	}
	filter(e) {
		return o.filter(this, e)
	}
	static coalesce(e) {
		return o.filter(e, (t) => !!t)
	}
	coalesce() {
		return o.coalesce(this)
	}
	static async toPromise(e) {
		let t = []
		for await (let n of e) t.push(n)
		return t
	}
	toPromise() {
		return o.toPromise(this)
	}
	emitOne(e) {
		this._state === 0 && (this._results.push(e), this._onStateChanged.fire())
	}
	emitMany(e) {
		this._state === 0 && ((this._results = this._results.concat(e)), this._onStateChanged.fire())
	}
	resolve() {
		this._state === 0 && ((this._state = 1), this._onStateChanged.fire())
	}
	reject(e) {
		this._state === 0 && ((this._state = 2), (this._error = e), this._onStateChanged.fire())
	}
}
var Ec = class {
	constructor(e) {
		this._deferred = new Cn()
		this._asyncIterable = new ci((r) => {
			if (t) {
				r.reject(t)
				return
			}
			return (
				n && r.emitMany(n),
				(this._errorFn = (i) => r.reject(i)),
				(this._emitFn = (i) => r.emitOne(i)),
				this._deferred.p
			)
		}, e)
		let t, n
		;(this._emitFn = (r) => {
			n || (n = []), n.push(r)
		}),
			(this._errorFn = (r) => {
				t || (t = r)
			})
	}
	get asyncIterable() {
		return this._asyncIterable
	}
	resolve() {
		this._deferred.complete()
	}
	reject(e) {
		this._errorFn(e), this._deferred.complete()
	}
	emitOne(e) {
		this._emitFn(e)
	}
}
function Al(o, e) {
	return new DE(o, e)
}
var DE = class {
	constructor(e, t) {
		this.reducer = e
		this.options = t
		this.state = { flowing: !1, ended: !1, destroyed: !1 }
		this.buffer = { data: [], error: [] }
		this.listeners = { data: [], error: [], end: [] }
		this.pendingWritePromises = []
	}
	pause() {
		this.state.destroyed || (this.state.flowing = !1)
	}
	resume() {
		this.state.destroyed ||
			this.state.flowing ||
			((this.state.flowing = !0), this.flowData(), this.flowErrors(), this.flowEnd())
	}
	write(e) {
		if (!this.state.destroyed) {
			if (this.state.flowing) this.emitData(e)
			else if (
				(this.buffer.data.push(e),
				typeof this.options?.highWaterMark == "number" && this.buffer.data.length > this.options.highWaterMark)
			)
				return new Promise((t) => this.pendingWritePromises.push(t))
		}
	}
	error(e) {
		this.state.destroyed || (this.state.flowing ? this.emitError(e) : this.buffer.error.push(e))
	}
	end(e) {
		this.state.destroyed ||
			(typeof e < "u" && this.write(e),
			this.state.flowing ? (this.emitEnd(), this.destroy()) : (this.state.ended = !0))
	}
	emitData(e) {
		this.listeners.data.slice(0).forEach((t) => t(e))
	}
	emitError(e) {
		this.listeners.error.length === 0 ? Be(e) : this.listeners.error.slice(0).forEach((t) => t(e))
	}
	emitEnd() {
		this.listeners.end.slice(0).forEach((e) => e())
	}
	on(e, t) {
		if (!this.state.destroyed)
			switch (e) {
				case "data":
					this.listeners.data.push(t), this.resume()
					break
				case "end":
					this.listeners.end.push(t), this.state.flowing && this.flowEnd() && this.destroy()
					break
				case "error":
					this.listeners.error.push(t), this.state.flowing && this.flowErrors()
					break
			}
	}
	removeListener(e, t) {
		if (this.state.destroyed) return
		let n
		switch (e) {
			case "data":
				n = this.listeners.data
				break
			case "end":
				n = this.listeners.end
				break
			case "error":
				n = this.listeners.error
				break
		}
		if (n) {
			let r = n.indexOf(t)
			r >= 0 && n.splice(r, 1)
		}
	}
	flowData() {
		if (this.buffer.data.length === 0) return
		if (typeof this.reducer == "function") {
			let t = this.reducer(this.buffer.data)
			this.emitData(t)
		} else for (let t of this.buffer.data) this.emitData(t)
		this.buffer.data.length = 0
		let e = [...this.pendingWritePromises]
		;(this.pendingWritePromises.length = 0), e.forEach((t) => t())
	}
	flowErrors() {
		if (this.listeners.error.length > 0) {
			for (let e of this.buffer.error) this.emitError(e)
			this.buffer.error.length = 0
		}
	}
	flowEnd() {
		return this.state.ended ? (this.emitEnd(), this.listeners.end.length > 0) : !1
	}
	destroy() {
		this.state.destroyed ||
			((this.state.destroyed = !0),
			(this.state.ended = !0),
			(this.buffer.data.length = 0),
			(this.buffer.error.length = 0),
			(this.listeners.data.length = 0),
			(this.listeners.error.length = 0),
			(this.listeners.end.length = 0),
			(this.pendingWritePromises.length = 0))
	}
}
function qA(o, e) {
	let t = [],
		n
	for (; (n = o.read()) !== null; ) t.push(n)
	return e(t)
}
function Nv(o, e) {
	return new Promise((t, n) => {
		let r = []
		Uv(o, {
			onData: (i) => {
				e && r.push(i)
			},
			onError: (i) => {
				e ? n(i) : t(void 0)
			},
			onEnd: () => {
				t(e ? e(r) : void 0)
			},
		})
	})
}
function Uv(o, e, t) {
	o.on("error", (n) => {
		t?.isCancellationRequested || e.onError(n)
	}),
		o.on("end", () => {
			t?.isCancellationRequested || e.onEnd()
		}),
		o.on("data", (n) => {
			t?.isCancellationRequested || e.onData(n)
		})
}
function KA(o, e) {
	let t = Al(e)
	return t.end(o), t
}
function jA(o, e, t) {
	let n = Al(t)
	return (
		Uv(o, {
			onData: (r) => n.write(e.data(r)),
			onError: (r) => n.error(e.error ? e.error(r) : r),
			onEnd: () => n.end(),
		}),
		n
	)
}
var Hv = typeof Buffer < "u",
	T4 = new Rt(() => new Uint8Array(256)),
	kE,
	RE,
	z = class o {
		static alloc(e) {
			return Hv ? new o(Buffer.allocUnsafe(e)) : new o(new Uint8Array(e))
		}
		static wrap(e) {
			return Hv && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new o(e)
		}
		static fromString(e, t) {
			return !(t?.dontUseNodeBuffer || !1) && Hv
				? new o(Buffer.from(e))
				: (kE || (kE = new TextEncoder()), new o(kE.encode(e)))
		}
		static fromByteArray(e) {
			let t = o.alloc(e.length)
			for (let n = 0, r = e.length; n < r; n++) t.buffer[n] = e[n]
			return t
		}
		static concat(e, t) {
			if (typeof t > "u") {
				t = 0
				for (let i = 0, s = e.length; i < s; i++) t += e[i].byteLength
			}
			let n = o.alloc(t),
				r = 0
			for (let i = 0, s = e.length; i < s; i++) {
				let a = e[i]
				n.set(a, r), (r += a.byteLength)
			}
			return n
		}
		constructor(e) {
			;(this.buffer = e), (this.byteLength = this.buffer.byteLength)
		}
		clone() {
			let e = o.alloc(this.byteLength)
			return e.set(this), e
		}
		toString() {
			return Hv ? this.buffer.toString() : (RE || (RE = new TextDecoder()), RE.decode(this.buffer))
		}
		slice(e, t) {
			return new o(this.buffer.subarray(e, t))
		}
		set(e, t) {
			if (e instanceof o) this.buffer.set(e.buffer, t)
			else if (e instanceof Uint8Array) this.buffer.set(e, t)
			else if (e instanceof ArrayBuffer) this.buffer.set(new Uint8Array(e), t)
			else if (ArrayBuffer.isView(e)) this.buffer.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t)
			else throw new Error("Unknown argument 'array'")
		}
		readUInt32BE(e) {
			return hf(this.buffer, e)
		}
		writeUInt32BE(e, t) {
			vf(this.buffer, e, t)
		}
		readUInt32LE(e) {
			return E4(this.buffer, e)
		}
		writeUInt32LE(e, t) {
			w4(this.buffer, e, t)
		}
		readUInt8(e) {
			return P4(this.buffer, e)
		}
		writeUInt8(e, t) {
			_4(this.buffer, e, t)
		}
		indexOf(e, t = 0) {
			return AE(this.buffer, e instanceof o ? e.buffer : e, t)
		}
		equals(e) {
			return this === e
				? !0
				: this.byteLength !== e.byteLength
					? !1
					: this.buffer.every((t, n) => t === e.buffer[n])
		}
	}
function AE(o, e, t = 0) {
	let n = e.byteLength,
		r = o.byteLength
	if (n === 0) return 0
	if (n === 1) return o.indexOf(e[0])
	if (n > r - t) return -1
	let i = T4.value
	i.fill(e.length)
	for (let d = 0; d < e.length; d++) i[e[d]] = e.length - d - 1
	let s = t + e.length - 1,
		a = s,
		l = -1
	for (; s < r; )
		if (o[s] === e[a]) {
			if (a === 0) {
				l = s
				break
			}
			s--, a--
		} else (s += Math.max(e.length - a, i[o[s]])), (a = e.length - 1)
	return l
}
function GA(o, e) {
	return ((o[e + 0] << 0) >>> 0) | ((o[e + 1] << 8) >>> 0)
}
function QA(o, e, t) {
	;(o[t + 0] = e & 255), (e = e >>> 8), (o[t + 1] = e & 255)
}
function hf(o, e) {
	return o[e] * 2 ** 24 + o[e + 1] * 2 ** 16 + o[e + 2] * 2 ** 8 + o[e + 3]
}
function vf(o, e, t) {
	;(o[t + 3] = e), (e = e >>> 8), (o[t + 2] = e), (e = e >>> 8), (o[t + 1] = e), (e = e >>> 8), (o[t] = e)
}
function E4(o, e) {
	return ((o[e + 0] << 0) >>> 0) | ((o[e + 1] << 8) >>> 0) | ((o[e + 2] << 16) >>> 0) | ((o[e + 3] << 24) >>> 0)
}
function w4(o, e, t) {
	;(o[t + 0] = e & 255),
		(e = e >>> 8),
		(o[t + 1] = e & 255),
		(e = e >>> 8),
		(o[t + 2] = e & 255),
		(e = e >>> 8),
		(o[t + 3] = e & 255)
}
function P4(o, e) {
	return o[e]
}
function _4(o, e, t) {
	o[t] = e
}
function JA(o) {
	return qA(o, (e) => z.concat(e))
}
function XA(o) {
	return Nv(o, (e) => z.concat(e))
}
function YA(o) {
	return KA(o, (e) => z.concat(e))
}
function ZA(o) {
	return jA(o, { data: (e) => (typeof e == "string" ? z.fromString(e) : z.wrap(e)) }, (e) => z.concat(e))
}
function wc(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = new Uint8Array(Math.floor((o.length / 4) * 3)),
		i = (a) => {
			switch (t) {
				case 3:
					;(r[n++] = e | a), (t = 0)
					break
				case 2:
					;(r[n++] = e | (a >>> 2)), (e = a << 6), (t = 3)
					break
				case 1:
					;(r[n++] = e | (a >>> 4)), (e = a << 4), (t = 2)
					break
				default:
					;(e = a << 2), (t = 1)
			}
		}
	for (let a = 0; a < o.length; a++) {
		let l = o.charCodeAt(a)
		if (l >= 65 && l <= 90) i(l - 65)
		else if (l >= 97 && l <= 122) i(l - 97 + 26)
		else if (l >= 48 && l <= 57) i(l - 48 + 52)
		else if (l === 43 || l === 45) i(62)
		else if (l === 47 || l === 95) i(63)
		else {
			if (l === 61) break
			throw new SyntaxError(`Unexpected base64 character ${o[a]}`)
		}
	}
	let s = n
	for (; t > 0; ) i(0)
	return z.wrap(r).slice(0, s)
}
var D4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	k4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
function Ol({ buffer: o }, e = !0, t = !1) {
	let n = t ? k4 : D4,
		r = "",
		i = o.byteLength % 3,
		s = 0
	for (; s < o.byteLength - i; s += 3) {
		let a = o[s + 0],
			l = o[s + 1],
			d = o[s + 2]
		;(r += n[a >>> 2]),
			(r += n[((a << 4) | (l >>> 4)) & 63]),
			(r += n[((l << 2) | (d >>> 6)) & 63]),
			(r += n[d & 63])
	}
	if (i === 1) {
		let a = o[s + 0]
		;(r += n[a >>> 2]), (r += n[(a << 4) & 63]), e && (r += "==")
	} else if (i === 2) {
		let a = o[s + 0],
			l = o[s + 1]
		;(r += n[a >>> 2]), (r += n[((a << 4) | (l >>> 4)) & 63]), (r += n[(l << 2) & 63]), e && (r += "=")
	}
	return r
}
function OE(o) {
	let e = []
	typeof o == "number" && e.push("code/timeOrigin", o)
	function t(r, i) {
		e.push(r, i?.startTime ?? Date.now())
	}
	function n() {
		let r = []
		for (let i = 0; i < e.length; i += 2) r.push({ name: e[i], startTime: e[i + 1] })
		return r
	}
	return { mark: t, getMarks: n }
}
function R4() {
	if (typeof performance == "object" && typeof performance.mark == "function" && !performance.nodeTiming)
		return typeof performance.timeOrigin != "number" && !performance.timing
			? OE()
			: {
					mark(o, e) {
						performance.mark(o, e)
					},
					getMarks() {
						let o = performance.timeOrigin
						typeof o != "number" &&
							(o =
								performance.timing.navigationStart ||
								performance.timing.redirectStart ||
								performance.timing.fetchStart)
						let e = [{ name: "code/timeOrigin", startTime: Math.round(o) }]
						for (let t of performance.getEntriesByType("mark"))
							e.push({ name: t.name, startTime: Math.round(o + t.startTime) })
						return e
					},
				}
	if (typeof process == "object") {
		let o = performance?.timeOrigin
		return OE(o)
	} else return console.trace("perf-util loaded in UNKNOWN environment"), OE()
}
function A4(o) {
	return o.MonacoPerformanceMarks || (o.MonacoPerformanceMarks = R4()), o.MonacoPerformanceMarks
}
var tO = A4(globalThis),
	Ct = tO.mark,
	nO = tO.getMarks
import * as es from "fs"
var Fo = {}
fH(Fo, {
	Promises: () => Qe,
	RimRafMode: () => FE,
	SymlinkSupport: () => or,
	configureFlushOnWrite: () => UE,
	readdirSync: () => V4,
	rimrafSync: () => H4,
	whenDeleted: () => $4,
	writeFileSync: () => j4,
})
import * as ke from "fs"
import { tmpdir as N4 } from "os"
import { promisify as bf } from "util"
var O4 = new _o(1e4)
function Ll(o) {
	return rO(o, "NFC", O4)
}
var L4 = new _o(1e4)
function LE(o) {
	return rO(o, "NFD", L4)
}
var M4 = /[^\u0000-\u0080]/
function rO(o, e, t) {
	if (!o) return o
	let n = t.get(o)
	if (n) return n
	let r
	return M4.test(o) ? (r = o.normalize(e)) : (r = o), t.set(o, r), r
}
var FE = ((t) => ((t[(t.UNLINK = 0)] = "UNLINK"), (t[(t.MOVE = 1)] = "MOVE"), t))(FE || {})
async function iO(o, e = 0, t) {
	if (gE(o)) throw new Error("rimraf - will refuse to recursively delete root")
	return e === 0 ? ME(o) : U4(o, t)
}
async function U4(o, e = DA(N4())) {
	try {
		try {
			await ke.promises.rename(o, e)
		} catch (t) {
			return t.code === "ENOENT" ? void 0 : ME(o)
		}
		ME(e).catch((t) => {})
	} catch (t) {
		if (t.code !== "ENOENT") throw t
	}
}
async function ME(o) {
	return ke.promises.rm(o, { recursive: !0, force: !0, maxRetries: 3 })
}
function H4(o) {
	if (gE(o)) throw new Error("rimraf - will refuse to recursively delete root")
	ke.rmSync(o, { recursive: !0, force: !0, maxRetries: 3 })
}
async function Wv(o, e) {
	return sO(await (e ? W4(o) : ke.promises.readdir(o)))
}
async function W4(o) {
	try {
		return await ke.promises.readdir(o, { withFileTypes: !0 })
	} catch (n) {
		console.warn("[node.js fs] readdir with filetypes failed with error: ", n)
	}
	let e = [],
		t = await Wv(o)
	for (let n of t) {
		let r = !1,
			i = !1,
			s = !1
		try {
			let a = await ke.promises.lstat(Fe(o, n))
			;(r = a.isFile()), (i = a.isDirectory()), (s = a.isSymbolicLink())
		} catch (a) {
			console.warn("[node.js fs] unexpected error from lstat after readdir: ", a)
		}
		e.push({ name: n, isFile: () => r, isDirectory: () => i, isSymbolicLink: () => s })
	}
	return e
}
function V4(o) {
	return sO(ke.readdirSync(o))
}
function sO(o) {
	return o.map((e) => (typeof e == "string" ? (st ? Ll(e) : e) : ((e.name = st ? Ll(e.name) : e.name), e)))
}
async function B4(o) {
	let e = await Wv(o),
		t = []
	for (let n of e) (await or.existsDirectory(Fe(o, n))) && t.push(n)
	return t
}
function $4(o, e = 1e3) {
	return new Promise((t) => {
		let n = !1,
			r = setInterval(() => {
				n ||
					((n = !0),
					ke.access(o, (i) => {
						;(n = !1), i && (clearInterval(r), t(void 0))
					}))
			}, e)
	})
}
var or
;((n) => {
	async function o(r) {
		let i
		try {
			if (((i = await ke.promises.lstat(r)), !i.isSymbolicLink())) return { stat: i }
		} catch {}
		try {
			return { stat: await ke.promises.stat(r), symbolicLink: i?.isSymbolicLink() ? { dangling: !1 } : void 0 }
		} catch (s) {
			if (s.code === "ENOENT" && i) return { stat: i, symbolicLink: { dangling: !0 } }
			if (Ie && s.code === "EACCES")
				try {
					return {
						stat: await ke.promises.stat(await ke.promises.readlink(r)),
						symbolicLink: { dangling: !1 },
					}
				} catch (a) {
					if (a.code === "ENOENT" && i) return { stat: i, symbolicLink: { dangling: !0 } }
					throw a
				}
			throw s
		}
	}
	n.stat = o
	async function e(r) {
		try {
			let { stat: i, symbolicLink: s } = await n.stat(r)
			return i.isFile() && s?.dangling !== !0
		} catch {}
		return !1
	}
	n.existsFile = e
	async function t(r) {
		try {
			let { stat: i, symbolicLink: s } = await n.stat(r)
			return i.isDirectory() && s?.dangling !== !0
		} catch {}
		return !1
	}
	n.existsDirectory = t
})((or ||= {}))
var z4 = new Cc()
function q4(o, e, t) {
	return z4.queueFor(
		y.file(o),
		() => {
			let n = aO(t)
			return new Promise((r, i) => K4(o, e, n, (s) => (s ? i(s) : r())))
		},
		Rl,
	)
}
var NE = !0
function UE(o) {
	NE = o
}
function K4(o, e, t, n) {
	if (!NE) return ke.writeFile(o, e, { mode: t.mode, flag: t.flag }, n)
	ke.open(o, t.flag, t.mode, (r, i) => {
		if (r) return n(r)
		ke.writeFile(i, e, (s) => {
			if (s) return ke.close(i, () => n(s))
			ke.fdatasync(
				i,
				(a) => (
					a &&
						(console.warn("[node.js fs] fdatasync is now disabled for this session because it failed: ", a),
						UE(!1)),
					ke.close(i, (l) => n(l))
				),
			)
		})
	})
}
function j4(o, e, t) {
	let n = aO(t)
	if (!NE) return ke.writeFileSync(o, e, { mode: n.mode, flag: n.flag })
	let r = ke.openSync(o, n.flag, n.mode)
	try {
		ke.writeFileSync(r, e)
		try {
			ke.fdatasyncSync(r)
		} catch (i) {
			console.warn("[node.js fs] fdatasyncSync is now disabled for this session because it failed: ", i), UE(!1)
		}
	} finally {
		ke.closeSync(r)
	}
}
function aO(o) {
	return o
		? { mode: typeof o.mode == "number" ? o.mode : 438, flag: typeof o.flag == "string" ? o.flag : "w" }
		: { mode: 438, flag: "w" }
}
async function G4(o, e, t = 6e4) {
	if (o !== e)
		try {
			Ie && typeof t == "number" ? await lO(o, e, Date.now(), t) : await ke.promises.rename(o, e)
		} catch (n) {
			if ((o.toLowerCase() !== e.toLowerCase() && n.code === "EXDEV") || o.endsWith("."))
				await dO(o, e, { preserveSymlinks: !1 }), await iO(o, 1)
			else throw n
		}
}
async function lO(o, e, t, n, r = 0) {
	try {
		return await ke.promises.rename(o, e)
	} catch (i) {
		if (i.code !== "EACCES" && i.code !== "EPERM" && i.code !== "EBUSY") throw i
		if (Date.now() - t >= n)
			throw (console.error(`[node.js fs] rename failed after ${r} retries with error: ${i}`), i)
		if (r === 0) {
			let s = !1
			try {
				let { stat: a } = await or.stat(e)
				a.isFile() || (s = !0)
			} catch {}
			if (s) throw i
		}
		return await Wt(Math.min(100, r * 10)), lO(o, e, t, n, r + 1)
	}
}
async function dO(o, e, t) {
	return cO(o, e, { root: { source: o, target: e }, options: t, handledSourcePaths: new Set() })
}
var oO = 511
async function cO(o, e, t) {
	if (t.handledSourcePaths.has(o)) return
	t.handledSourcePaths.add(o)
	let { stat: n, symbolicLink: r } = await or.stat(o)
	if (r) {
		if (t.options.preserveSymlinks)
			try {
				return await X4(o, e, t)
			} catch {}
		if (r.dangling) return
	}
	return n.isDirectory() ? Q4(o, e, n.mode & oO, t) : J4(o, e, n.mode & oO)
}
async function Q4(o, e, t, n) {
	await ke.promises.mkdir(e, { recursive: !0, mode: t })
	let r = await Wv(o)
	for (let i of r) await cO(Fe(o, i), Fe(e, i), n)
}
async function J4(o, e, t) {
	await ke.promises.copyFile(o, e), await ke.promises.chmod(e, t)
}
async function X4(o, e, t) {
	let n = await ke.promises.readlink(o)
	zr(n, t.root.source, !Ve) && (n = Fe(t.root.target, n.substr(t.root.source.length + 1))),
		await ke.promises.symlink(n, e)
}
var Qe = new (class {
	get read() {
		return (o, e, t, n, r) =>
			new Promise((i, s) => {
				ke.read(o, e, t, n, r, (a, l, d) => (a ? s(a) : i({ bytesRead: l, buffer: d })))
			})
	}
	get write() {
		return (o, e, t, n, r) =>
			new Promise((i, s) => {
				ke.write(o, e, t, n, r, (a, l, d) => (a ? s(a) : i({ bytesWritten: l, buffer: d })))
			})
	}
	get fdatasync() {
		return bf(ke.fdatasync)
	}
	get open() {
		return bf(ke.open)
	}
	get close() {
		return bf(ke.close)
	}
	get realpath() {
		return bf(ke.realpath)
	}
	get ftruncate() {
		return bf(ke.ftruncate)
	}
	async exists(o) {
		try {
			return await ke.promises.access(o), !0
		} catch {
			return !1
		}
	}
	get readdir() {
		return Wv
	}
	get readDirsInDir() {
		return B4
	}
	get writeFile() {
		return q4
	}
	get rm() {
		return iO
	}
	get rename() {
		return G4
	}
	get copy() {
		return dO
	}
})()
async function Vv(o) {
	try {
		return await Qe.realpath(o)
	} catch {
		let t = pO(o)
		return await es.promises.access(t, es.constants.R_OK), t
	}
}
function uO(o) {
	try {
		return es.realpathSync(o)
	} catch {
		let t = pO(o)
		return es.accessSync(t, es.constants.R_OK), t
	}
}
function pO(o) {
	return Dr(jn(o), at)
}
import * as kc from "fs"
import * as BE from "path"
import * as xO from "os"
function mO(o) {
	return o.toJSON()
}
var Bv = class {
		constructor(e) {
			this._uriTransformer = e
		}
		transformIncoming(e) {
			let t = this._uriTransformer.transformIncoming(e)
			return t === e ? e : mO(y.from(t))
		}
		transformOutgoing(e) {
			let t = this._uriTransformer.transformOutgoing(e)
			return t === e ? e : mO(y.from(t))
		}
		transformOutgoingURI(e) {
			let t = this._uriTransformer.transformOutgoing(e)
			return t === e ? e : y.from(t)
		}
		transformOutgoingScheme(e) {
			return this._uriTransformer.transformOutgoingScheme(e)
		}
	},
	Oz = new (class {
		transformIncoming(o) {
			return o
		}
		transformOutgoing(o) {
			return o
		}
		transformOutgoingURI(o) {
			return o
		}
		transformOutgoingScheme(o) {
			return o
		}
	})()
function fO(o, e, t, n) {
	if (!o || n > 200) return null
	if (typeof o == "object") {
		if (o.$mid === 1) return t ? y.revive(e.transformIncoming(o)) : e.transformIncoming(o)
		if (o instanceof z) return null
		for (let r in o)
			if (Object.hasOwnProperty.call(o, r)) {
				let i = fO(o[r], e, t, n + 1)
				i !== null && (o[r] = i)
			}
	}
	return null
}
function _c(o, e) {
	let t = fO(o, e, !1, 0)
	return t === null ? o : t
}
var yf = class {
		constructor() {
			;(this._actual = null),
				(this._actualOk = null),
				(this._actualErr = null),
				(this._hasValue = !1),
				(this._value = null),
				(this._hasErr = !1),
				(this._err = null)
		}
		get [Symbol.toStringTag]() {
			return this.toString()
		}
		_ensureActual() {
			return (
				this._actual ||
					(this._actual = new Promise((e, t) => {
						;(this._actualOk = e),
							(this._actualErr = t),
							this._hasValue && this._actualOk(this._value),
							this._hasErr && this._actualErr(this._err)
					})),
				this._actual
			)
		}
		resolveOk(e) {
			this._hasValue ||
				this._hasErr ||
				((this._hasValue = !0), (this._value = e), this._actual && this._actualOk(e))
		}
		resolveErr(e) {
			this._hasValue ||
				this._hasErr ||
				((this._hasErr = !0), (this._err = e), this._actual ? this._actualErr(e) : Be(e))
		}
		then(e, t) {
			return this._ensureActual().then(e, t)
		}
		catch(e) {
			return this._ensureActual().then(void 0, e)
		}
		finally(e) {
			return this._ensureActual().finally(e)
		}
	},
	$v = class extends yf {
		constructor() {
			super(), (this._hasErr = !0), (this._err = new xt())
		}
	}
var If = class o {
		constructor(e) {
			this._proxyIdentifierBrand = void 0
			;(this.sid = e), (this.nid = ++o.count)
		}
		static {
			this.count = 0
		}
	},
	gO = []
function V(o) {
	let e = new If(o)
	return (gO[e.nid] = e), e
}
function xf(o) {
	return gO[o].sid
}
var Xt = class {
	constructor(e) {
		this.value = e
	}
}
function HE(o, e) {
	try {
		return JSON.stringify(o, e)
	} catch {
		return "null"
	}
}
var VE = "$$ref$$",
	Y4 = { [VE]: -1 }
function hO(o, e = null, t = !1) {
	let n = []
	return {
		jsonString: (t ? HE : JSON.stringify)(o, (i, s) => {
			if (typeof s > "u") return Y4
			if (typeof s == "object") {
				if (s instanceof z) {
					let a = n.push(s) - 1
					return { [VE]: a }
				}
				if (e) return e(i, s)
			}
			return s
		}),
		referencedBuffers: n,
	}
}
function IO(o, e, t) {
	return JSON.parse(o, (n, r) => {
		if (r) {
			let i = r[VE]
			if (typeof i == "number") return e[i]
			if (t && r.$mid === 1) return t.transformIncoming(r)
		}
		return r
	})
}
function vO(o, e) {
	return JSON.stringify(o, e)
}
function Z4(o) {
	return o ? (e, t) => (t && t.$mid === 1 ? o.transformOutgoing(t) : t) : null
}
var e5 = () => {},
	t5 = Symbol.for("rpcProtocol"),
	n5 = Symbol.for("rpcProxy"),
	bO,
	yO,
	zv = class o extends ((yO = $), (bO = t5), yO) {
		constructor(t, n = null, r = null) {
			super()
			this[bO] = !0
			this._onDidChangeResponsiveState = this._register(new E())
			this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event
			;(this._protocol = t),
				(this._logger = n),
				(this._uriTransformer = r),
				(this._uriReplacer = Z4(this._uriTransformer)),
				(this._isDisposed = !1),
				(this._locals = []),
				(this._proxies = [])
			for (let i = 0, s = If.count; i < s; i++) (this._locals[i] = null), (this._proxies[i] = null)
			;(this._lastMessageId = 0),
				(this._cancelInvokedHandlers = Object.create(null)),
				(this._pendingRPCReplies = {}),
				(this._responsiveState = 0),
				(this._unacknowledgedCount = 0),
				(this._unresponsiveTime = 0),
				(this._asyncCheckUresponsive = this._register(new Hn(() => this._checkUnresponsive(), 1e3))),
				this._register(this._protocol.onMessage((i) => this._receiveOneMessage(i)))
		}
		static {
			this.UNRESPONSIVE_TIME = 3 * 1e3
		}
		dispose() {
			;(this._isDisposed = !0),
				Object.keys(this._pendingRPCReplies).forEach((t) => {
					let n = this._pendingRPCReplies[t]
					delete this._pendingRPCReplies[t], n.resolveErr($i())
				}),
				super.dispose()
		}
		drain() {
			return typeof this._protocol.drain == "function" ? this._protocol.drain() : Promise.resolve()
		}
		_onWillSendRequest(t) {
			this._unacknowledgedCount === 0 && (this._unresponsiveTime = Date.now() + o.UNRESPONSIVE_TIME),
				this._unacknowledgedCount++,
				this._asyncCheckUresponsive.isScheduled() || this._asyncCheckUresponsive.schedule()
		}
		_onDidReceiveAcknowledge(t) {
			;(this._unresponsiveTime = Date.now() + o.UNRESPONSIVE_TIME),
				this._unacknowledgedCount--,
				this._unacknowledgedCount === 0 && this._asyncCheckUresponsive.cancel(),
				this._setResponsiveState(0)
		}
		_checkUnresponsive() {
			this._unacknowledgedCount !== 0 &&
				(Date.now() > this._unresponsiveTime
					? this._setResponsiveState(1)
					: this._asyncCheckUresponsive.schedule())
		}
		_setResponsiveState(t) {
			this._responsiveState !== t &&
				((this._responsiveState = t), this._onDidChangeResponsiveState.fire(this._responsiveState))
		}
		get responsiveState() {
			return this._responsiveState
		}
		transformIncomingURIs(t) {
			return this._uriTransformer ? _c(t, this._uriTransformer) : t
		}
		getProxy(t) {
			let { nid: n, sid: r } = t
			return this._proxies[n] || (this._proxies[n] = this._createProxy(n, r)), this._proxies[n]
		}
		_createProxy(t, n) {
			let r = {
				get: (i, s) => (
					typeof s == "string" &&
						!i[s] &&
						s.charCodeAt(0) === 36 &&
						(i[s] = (...a) => this._remoteCall(t, s, a)),
					s === n5 ? n : i[s]
				),
			}
			return new Proxy(Object.create(null), r)
		}
		set(t, n) {
			return (this._locals[t.nid] = n), n
		}
		assertRegistered(t) {
			for (let n = 0, r = t.length; n < r; n++) {
				let i = t[n]
				if (!this._locals[i.nid]) throw new Error(`Missing proxy instance ${i.sid}`)
			}
		}
		_receiveOneMessage(t) {
			if (this._isDisposed) return
			let n = t.byteLength,
				r = Kt.read(t, 0),
				i = r.readUInt8(),
				s = r.readUInt32()
			switch ((this._logger?.logIncoming(n, s, 1, `receiveMessage: ${i}, req: ${s}, msgType: ${i}`), i)) {
				case 1:
				case 2: {
					let { rpcId: a, method: l, args: d } = Rr.deserializeRequestJSONArgs(r)
					this._uriTransformer && (d = _c(d, this._uriTransformer)),
						this._receiveRequest(n, s, a, l, d, i === 2)
					break
				}
				case 3:
				case 4: {
					let { rpcId: a, method: l, args: d } = Rr.deserializeRequestMixedArgs(r)
					this._uriTransformer && (d = _c(d, this._uriTransformer)),
						this._receiveRequest(n, s, a, l, d, i === 4)
					break
				}
				case 5: {
					this._onDidReceiveAcknowledge(s)
					break
				}
				case 6: {
					this._receiveCancel(n, s)
					break
				}
				case 7: {
					this._receiveReply(n, s, void 0)
					break
				}
				case 9: {
					let a = Rr.deserializeReplyOKJSON(r)
					this._uriTransformer && (a = _c(a, this._uriTransformer)), this._receiveReply(n, s, a)
					break
				}
				case 10: {
					let a = Rr.deserializeReplyOKJSONWithBuffers(r, this._uriTransformer)
					this._receiveReply(n, s, a)
					break
				}
				case 8: {
					let a = Rr.deserializeReplyOKVSBuffer(r)
					this._receiveReply(n, s, a)
					break
				}
				case 11: {
					let a = Rr.deserializeReplyErrError(r)
					this._uriTransformer && (a = _c(a, this._uriTransformer)), this._receiveReplyErr(n, s, a)
					break
				}
				case 12: {
					this._receiveReplyErr(n, s, void 0)
					break
				}
				default:
					console.error("received unexpected message"), console.error(t)
			}
		}
		_receiveRequest(t, n, r, i, s, a) {
			this._logger?.logIncoming(t, n, 1, `receiveRequest ${xf(r)}.${i}(`, s)
			let l = String(n),
				d,
				c
			if (a) {
				let m = new _e()
				s.push(m.token), (d = this._invokeHandler(r, i, s)), (c = () => m.cancel())
			} else (d = this._invokeHandler(r, i, s)), (c = e5)
			this._cancelInvokedHandlers[l] = c
			let u = Rr.serializeAcknowledged(n)
			this._logger?.logOutgoing(u.byteLength, n, 1, "ack"),
				this._protocol.send(u),
				d.then(
					(m) => {
						delete this._cancelInvokedHandlers[l]
						let f = Rr.serializeReplyOK(n, m, this._uriReplacer)
						this._logger?.logOutgoing(f.byteLength, n, 1, "reply:", m), this._protocol.send(f)
					},
					(m) => {
						delete this._cancelInvokedHandlers[l]
						let f = Rr.serializeReplyErr(n, m)
						this._logger?.logOutgoing(f.byteLength, n, 1, "replyErr:", m), this._protocol.send(f)
					},
				)
		}
		_receiveCancel(t, n) {
			this._logger?.logIncoming(t, n, 1, "receiveCancel")
			let r = String(n)
			this._cancelInvokedHandlers[r]?.()
		}
		_receiveReply(t, n, r) {
			this._logger?.logIncoming(t, n, 0, "receiveReply:", r)
			let i = String(n)
			if (!this._pendingRPCReplies.hasOwnProperty(i)) return
			let s = this._pendingRPCReplies[i]
			delete this._pendingRPCReplies[i], s.resolveOk(r)
		}
		_receiveReplyErr(t, n, r) {
			this._logger?.logIncoming(t, n, 0, "receiveReplyErr:", r)
			let i = String(n)
			if (!this._pendingRPCReplies.hasOwnProperty(i)) return
			let s = this._pendingRPCReplies[i]
			delete this._pendingRPCReplies[i]
			let a
			r &&
				(r.$isError
					? ((a = new Error()), (a.name = r.name), (a.message = r.message), (a.stack = r.stack))
					: (a = r)),
				s.resolveErr(a)
		}
		_invokeHandler(t, n, r) {
			try {
				return Promise.resolve(this._doInvokeHandler(t, n, r))
			} catch (i) {
				return console.error("invokeHandler error:", i), Promise.reject(i)
			}
		}
		_doInvokeHandler(t, n, r) {
			let i = this._locals[t]
			if (!i) throw new Error("Unknown actor " + xf(t))
			let s = i[n]
			if (typeof s != "function") throw new Error("Unknown method " + n + " on actor " + xf(t))
			return s.apply(i, r)
		}
		_remoteCall(t, n, r) {
			if (this._isDisposed) return new $v()
			let i = null
			if (
				(r.length > 0 && De.isCancellationToken(r[r.length - 1]) && (i = r.pop()),
				i && i.isCancellationRequested)
			)
				return Promise.reject($i())
			let s = Rr.serializeRequestArguments(r, this._uriReplacer),
				a = ++this._lastMessageId,
				l = String(a),
				d = new yf(),
				c = new Q()
			i &&
				c.add(
					i.onCancellationRequested(() => {
						let m = Rr.serializeCancel(a)
						this._logger?.logOutgoing(m.byteLength, a, 0, "cancel"), this._protocol.send(m)
					}),
				),
				(this._pendingRPCReplies[l] = new WE(d, c)),
				this._onWillSendRequest(a)
			let u = Rr.serializeRequest(a, t, n, s, !!i)
			return (
				this._logger?.logOutgoing(u.byteLength, a, 0, `request: ${xf(t)}.${n}(`, r), this._protocol.send(u), d
			)
		}
	},
	WE = class {
		constructor(e, t) {
			this._promise = e
			this._disposable = t
		}
		resolveOk(e) {
			this._promise.resolveOk(e), this._disposable.dispose()
		}
		resolveErr(e) {
			this._promise.resolveErr(e), this._disposable.dispose()
		}
	},
	Kt = class o {
		static alloc(e, t, n) {
			let r = new o(z.alloc(n + 1 + 4), 0)
			return r.writeUInt8(e), r.writeUInt32(t), r
		}
		static read(e, t) {
			return new o(e, t)
		}
		get buffer() {
			return this._buff
		}
		constructor(e, t) {
			;(this._buff = e), (this._offset = t)
		}
		static sizeUInt8() {
			return 1
		}
		static {
			this.sizeUInt32 = 4
		}
		writeUInt8(e) {
			this._buff.writeUInt8(e, this._offset), (this._offset += 1)
		}
		readUInt8() {
			let e = this._buff.readUInt8(this._offset)
			return (this._offset += 1), e
		}
		writeUInt32(e) {
			this._buff.writeUInt32BE(e, this._offset), (this._offset += 4)
		}
		readUInt32() {
			let e = this._buff.readUInt32BE(this._offset)
			return (this._offset += 4), e
		}
		static sizeShortString(e) {
			return 1 + e.byteLength
		}
		writeShortString(e) {
			this._buff.writeUInt8(e.byteLength, this._offset),
				(this._offset += 1),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readShortString() {
			let e = this._buff.readUInt8(this._offset)
			this._offset += 1
			let n = this._buff.slice(this._offset, this._offset + e).toString()
			return (this._offset += e), n
		}
		static sizeLongString(e) {
			return 4 + e.byteLength
		}
		writeLongString(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readLongString() {
			let e = this._buff.readUInt32BE(this._offset)
			this._offset += 4
			let n = this._buff.slice(this._offset, this._offset + e).toString()
			return (this._offset += e), n
		}
		writeBuffer(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		static sizeVSBuffer(e) {
			return 4 + e.byteLength
		}
		writeVSBuffer(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readVSBuffer() {
			let e = this._buff.readUInt32BE(this._offset)
			this._offset += 4
			let t = this._buff.slice(this._offset, this._offset + e)
			return (this._offset += e), t
		}
		static sizeMixedArray(e) {
			let t = 0
			t += 1
			for (let n = 0, r = e.length; n < r; n++) {
				let i = e[n]
				switch (((t += 1), i.type)) {
					case 1:
						t += this.sizeLongString(i.value)
						break
					case 2:
						t += this.sizeVSBuffer(i.value)
						break
					case 3:
						;(t += this.sizeUInt32), (t += this.sizeLongString(i.value))
						for (let s = 0; s < i.buffers.length; ++s) t += this.sizeVSBuffer(i.buffers[s])
						break
					case 4:
						break
				}
			}
			return t
		}
		writeMixedArray(e) {
			this._buff.writeUInt8(e.length, this._offset), (this._offset += 1)
			for (let t = 0, n = e.length; t < n; t++) {
				let r = e[t]
				switch (r.type) {
					case 1:
						this.writeUInt8(1), this.writeLongString(r.value)
						break
					case 2:
						this.writeUInt8(2), this.writeVSBuffer(r.value)
						break
					case 3:
						this.writeUInt8(3), this.writeUInt32(r.buffers.length), this.writeLongString(r.value)
						for (let i = 0; i < r.buffers.length; ++i) this.writeBuffer(r.buffers[i])
						break
					case 4:
						this.writeUInt8(4)
						break
				}
			}
		}
		readMixedArray() {
			let e = this._buff.readUInt8(this._offset)
			this._offset += 1
			let t = new Array(e)
			for (let n = 0; n < e; n++)
				switch (this.readUInt8()) {
					case 1:
						t[n] = this.readLongString()
						break
					case 2:
						t[n] = this.readVSBuffer()
						break
					case 3: {
						let i = this.readUInt32(),
							s = this.readLongString(),
							a = []
						for (let l = 0; l < i; ++l) a.push(this.readVSBuffer())
						t[n] = new Xt(IO(s, a, null))
						break
					}
					case 4:
						t[n] = void 0
						break
				}
			return t
		}
	}
var Rr = class {
	static _useMixedArgSerialization(e) {
		for (let t = 0, n = e.length; t < n; t++)
			if (e[t] instanceof z || e[t] instanceof Xt || typeof e[t] > "u") return !0
		return !1
	}
	static serializeRequestArguments(e, t) {
		if (this._useMixedArgSerialization(e)) {
			let n = []
			for (let r = 0, i = e.length; r < i; r++) {
				let s = e[r]
				if (s instanceof z) n[r] = { type: 2, value: s }
				else if (typeof s > "u") n[r] = { type: 4 }
				else if (s instanceof Xt) {
					let { jsonString: a, referencedBuffers: l } = hO(s.value, t)
					n[r] = { type: 3, value: z.fromString(a), buffers: l }
				} else n[r] = { type: 1, value: z.fromString(vO(s, t)) }
			}
			return { type: 1, args: n }
		}
		return { type: 0, args: vO(e, t) }
	}
	static serializeRequest(e, t, n, r, i) {
		switch (r.type) {
			case 0:
				return this._requestJSONArgs(e, t, n, r.args, i)
			case 1:
				return this._requestMixedArgs(e, t, n, r.args, i)
		}
	}
	static _requestJSONArgs(e, t, n, r, i) {
		let s = z.fromString(n),
			a = z.fromString(r),
			l = 0
		;(l += Kt.sizeUInt8()), (l += Kt.sizeShortString(s)), (l += Kt.sizeLongString(a))
		let d = Kt.alloc(i ? 2 : 1, e, l)
		return d.writeUInt8(t), d.writeShortString(s), d.writeLongString(a), d.buffer
	}
	static deserializeRequestJSONArgs(e) {
		let t = e.readUInt8(),
			n = e.readShortString(),
			r = e.readLongString()
		return { rpcId: t, method: n, args: JSON.parse(r) }
	}
	static _requestMixedArgs(e, t, n, r, i) {
		let s = z.fromString(n),
			a = 0
		;(a += Kt.sizeUInt8()), (a += Kt.sizeShortString(s)), (a += Kt.sizeMixedArray(r))
		let l = Kt.alloc(i ? 4 : 3, e, a)
		return l.writeUInt8(t), l.writeShortString(s), l.writeMixedArray(r), l.buffer
	}
	static deserializeRequestMixedArgs(e) {
		let t = e.readUInt8(),
			n = e.readShortString(),
			r = e.readMixedArray(),
			i = new Array(r.length)
		for (let s = 0, a = r.length; s < a; s++) {
			let l = r[s]
			typeof l == "string" ? (i[s] = JSON.parse(l)) : (i[s] = l)
		}
		return { rpcId: t, method: n, args: i }
	}
	static serializeAcknowledged(e) {
		return Kt.alloc(5, e, 0).buffer
	}
	static serializeCancel(e) {
		return Kt.alloc(6, e, 0).buffer
	}
	static serializeReplyOK(e, t, n) {
		if (typeof t > "u") return this._serializeReplyOKEmpty(e)
		if (t instanceof z) return this._serializeReplyOKVSBuffer(e, t)
		if (t instanceof Xt) {
			let { jsonString: r, referencedBuffers: i } = hO(t.value, n, !0)
			return this._serializeReplyOKJSONWithBuffers(e, r, i)
		} else return this._serializeReplyOKJSON(e, HE(t, n))
	}
	static _serializeReplyOKEmpty(e) {
		return Kt.alloc(7, e, 0).buffer
	}
	static _serializeReplyOKVSBuffer(e, t) {
		let n = 0
		n += Kt.sizeVSBuffer(t)
		let r = Kt.alloc(8, e, n)
		return r.writeVSBuffer(t), r.buffer
	}
	static deserializeReplyOKVSBuffer(e) {
		return e.readVSBuffer()
	}
	static _serializeReplyOKJSON(e, t) {
		let n = z.fromString(t),
			r = 0
		r += Kt.sizeLongString(n)
		let i = Kt.alloc(9, e, r)
		return i.writeLongString(n), i.buffer
	}
	static _serializeReplyOKJSONWithBuffers(e, t, n) {
		let r = z.fromString(t),
			i = 0
		;(i += Kt.sizeUInt32), (i += Kt.sizeLongString(r))
		for (let a of n) i += Kt.sizeVSBuffer(a)
		let s = Kt.alloc(10, e, i)
		s.writeUInt32(n.length), s.writeLongString(r)
		for (let a of n) s.writeBuffer(a)
		return s.buffer
	}
	static deserializeReplyOKJSON(e) {
		let t = e.readLongString()
		return JSON.parse(t)
	}
	static deserializeReplyOKJSONWithBuffers(e, t) {
		let n = e.readUInt32(),
			r = e.readLongString(),
			i = []
		for (let s = 0; s < n; ++s) i.push(e.readVSBuffer())
		return new Xt(IO(r, i, t))
	}
	static serializeReplyErr(e, t) {
		let n = t ? HE(Po(t), null) : void 0
		if (typeof n != "string") return this._serializeReplyErrEmpty(e)
		let r = z.fromString(n),
			i = 0
		i += Kt.sizeLongString(r)
		let s = Kt.alloc(11, e, i)
		return s.writeLongString(r), s.buffer
	}
	static deserializeReplyErrError(e) {
		let t = e.readLongString()
		return JSON.parse(t)
	}
	static _serializeReplyErrEmpty(e) {
		return Kt.alloc(12, e, 0).buffer
	}
}
var sa = class {
	constructor(e) {
		this._totalIncoming = 0
		this._totalOutgoing = 0
		this._writeStream = null
		this._logQueue = []
		this._isInitialized = !1
		this._isDisposed = !1
		this._processInterval = null
		this._isEnabled = !1
		if (!this._isEnabled) return
		;(this._logDir = BE.join(xO.homedir(), ".ext_host", "log")), this._ensureLogDirectoryExists()
		let t = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").slice(0, 19),
			n = e ? `_${e}` : ""
		this._logFile = BE.join(this._logDir, `rpc${n}_${t}.log`)
		try {
			this._writeStream = kc.createWriteStream(this._logFile, { flags: "a" })
			let r = new Date(),
				s = [
					"-------------------------------------------------------------",
					"Extension Host RPC Protocol Logger",
					`Started at: ${this._formatTimestampWithMilliseconds(r)}`,
					`Log file: ${this._logFile}`,
					"-------------------------------------------------------------",
					"",
				].join(`
`)
			this._logQueue.push(s),
				this._startProcessingQueue(),
				(this._isInitialized = !0),
				console.log(`FileRPCProtocolLogger initialized, log file: ${this._logFile}`)
		} catch (r) {
			console.error("Failed to initialize FileRPCProtocolLogger", r)
		}
	}
	_ensureLogDirectoryExists() {
		if (this._logDir)
			try {
				kc.existsSync(this._logDir) || kc.mkdirSync(this._logDir, { recursive: !0 })
			} catch (e) {
				console.error("Failed to create log directory", e)
			}
	}
	_startProcessingQueue() {
		this._processInterval = setInterval(() => {
			this._processQueue()
		}, 100)
	}
	_processQueue() {
		if (!(this._isDisposed || !this._writeStream || this._logQueue.length === 0))
			try {
				let e = this._logQueue.splice(0, Math.min(50, this._logQueue.length))
				for (let t of e)
					this._writeStream.write(
						t +
							`
`,
					)
			} catch (e) {
				console.error("Failed to write log entries", e)
			}
	}
	logIncoming(e, t, n, r, i) {
		this._isInitialized &&
			((this._totalIncoming += e), this._logMessage("IDEA \u2192 Ext", this._totalIncoming, e, t, n, r, i))
	}
	logOutgoing(e, t, n, r, i) {
		this._isInitialized &&
			((this._totalOutgoing += e), this._logMessage("Ext \u2192 IDEA", this._totalOutgoing, e, t, n, r, i))
	}
	_logMessage(e, t, n, r, i, s, a) {
		try {
			let l = new Date(),
				d = this._formatTimestampWithMilliseconds(l),
				c = i === 0 ? "Local" : "Other",
				u = `[${d}] `
			if (
				((u += `[${e}] `),
				(u += `[Total: ${String(t).padStart(7)}] `),
				(u += `[Len: ${String(n).padStart(5)}] `),
				(u += `[${String(r).padStart(5)}] `),
				(u += `[${c}] `),
				(u += s),
				a !== void 0)
			) {
				let m = /\($/.test(s) ? `${this._stringify(a)})` : this._stringify(a)
				u += ` ${m}`
			}
			this._logQueue.push(u)
		} catch (l) {
			console.error("Failed to format log message", l)
		}
	}
	_stringify(e) {
		try {
			return JSON.stringify(e, null, 0)
		} catch {
			return String(e)
		}
	}
	dispose() {
		if (!this._isDisposed) {
			this._isDisposed = !0
			try {
				this._processInterval && (clearInterval(this._processInterval), (this._processInterval = null)),
					this._processQueue()
				let e = new Date(),
					n = [
						"-------------------------------------------------------------",
						"Extension Host RPC Protocol Logger",
						`Ended at: ${this._formatTimestampWithMilliseconds(e)}`,
						`Total incoming: ${this._totalIncoming} bytes`,
						`Total outgoing: ${this._totalOutgoing} bytes`,
						"-------------------------------------------------------------",
					].join(`
`)
				this._writeStream &&
					(this._writeStream.write(
						n +
							`
`,
					),
					this._writeStream.end(),
					(this._writeStream = null)),
					console.log("FileRPCProtocolLogger disposed")
			} catch (e) {
				console.error("Failed to dispose FileRPCProtocolLogger", e)
			}
		}
	}
	_formatTimestampWithMilliseconds(e) {
		let t = e.getFullYear(),
			n = String(e.getMonth() + 1).padStart(2, "0"),
			r = String(e.getDate()).padStart(2, "0"),
			i = String(e.getHours()).padStart(2, "0"),
			s = String(e.getMinutes()).padStart(2, "0"),
			a = String(e.getSeconds()).padStart(2, "0"),
			l = String(e.getMilliseconds()).padStart(3, "0")
		return `${t}-${n}-${r} ${i}:${s}:${a}.${l}`
	}
}
function CO(o) {
	return (e, t, n) => {
		let r = null,
			i = null
		if (
			(typeof n.value == "function"
				? ((r = "value"), (i = n.value))
				: typeof n.get == "function" && ((r = "get"), (i = n.get)),
			!i || typeof t == "symbol")
		)
			throw new Error("not supported")
		n[r] = o(i, t)
	}
}
function qv(o, e, t) {
	let n = null,
		r = null
	if (
		(typeof t.value == "function"
			? ((n = "value"),
				(r = t.value),
				r.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters"))
			: typeof t.get == "function" && ((n = "get"), (r = t.get)),
		!r)
	)
		throw new Error("not supported")
	let i = `$memoize$${e}`
	t[n] = function (...s) {
		return (
			this.hasOwnProperty(i) ||
				Object.defineProperty(this, i, {
					configurable: !1,
					enumerable: !1,
					writable: !1,
					value: r.apply(this, s),
				}),
			this[i]
		)
	}
}
function Ml(o, e, t) {
	return CO((n, r) => {
		let i = `$debounce$${r}`,
			s = `$debounce$result$${r}`
		return function (...a) {
			this[s] || (this[s] = t ? t() : void 0),
				clearTimeout(this[i]),
				e && ((this[s] = e(this[s], ...a)), (a = [this[s]])),
				(this[i] = setTimeout(() => {
					n.apply(this, a), (this[s] = t ? t() : void 0)
				}, o))
		}
	})
}
function SO(o, e, t) {
	return CO((n, r) => {
		let i = `$throttle$timer$${r}`,
			s = `$throttle$result$${r}`,
			a = `$throttle$lastRun$${r}`,
			l = `$throttle$pending$${r}`
		return function (...d) {
			if (
				(this[s] || (this[s] = t ? t() : void 0),
				(this[a] === null || this[a] === void 0) && (this[a] = -Number.MAX_VALUE),
				e && (this[s] = e(this[s], ...d)),
				this[l])
			)
				return
			let c = this[a] + o
			c <= Date.now()
				? ((this[a] = Date.now()), n.apply(this, [this[s]]), (this[s] = t ? t() : void 0))
				: ((this[l] = !0),
					(this[i] = setTimeout(() => {
						;(this[l] = !1), (this[a] = Date.now()), n.apply(this, [this[s]]), (this[s] = t ? t() : void 0)
					}, c - Date.now())))
		}
	})
}
function TO(o) {
	return JSON.stringify(o, r5)
}
function Kv(o) {
	let e = JSON.parse(o)
	return (e = ut(e)), e
}
function r5(o, e) {
	return e instanceof RegExp ? { $mid: 2, source: e.source, flags: e.flags } : e
}
function ut(o, e = 0) {
	if (!o || e > 200) return o
	if (typeof o == "object") {
		switch (o.$mid) {
			case 1:
				return y.revive(o)
			case 2:
				return new RegExp(o.source, o.flags)
			case 17:
				return new Date(o.source)
		}
		if (o instanceof z || o instanceof Uint8Array) return o
		if (Array.isArray(o)) for (let t = 0; t < o.length; ++t) o[t] = ut(o[t], e + 1)
		else for (let t in o) Object.hasOwnProperty.call(o, t) && (o[t] = ut(o[t], e + 1))
	}
	return o
}
function EO(o) {
	switch (o) {
		case 100:
			return "req"
		case 101:
			return "cancel"
		case 102:
			return "subscribe"
		case 103:
			return "unsubscribe"
	}
}
function wO(o) {
	switch (o) {
		case 200:
			return "init"
		case 201:
			return "reply:"
		case 202:
		case 203:
			return "replyErr:"
		case 204:
			return "event:"
	}
}
function Rc(o) {
	let e = 0
	for (let t = 0; ; t += 7) {
		let n = o.read(1)
		if (((e |= (n.buffer[0] & 127) << t), !(n.buffer[0] & 128))) return e
	}
}
var o5 = aa(0)
function Ac(o, e) {
	if (e === 0) {
		o.write(o5)
		return
	}
	let t = 0
	for (let r = e; r !== 0; r = r >>> 7) t++
	let n = z.alloc(t)
	for (let r = 0; e !== 0; r++) (n.buffer[r] = e & 127), (e = e >>> 7), e > 0 && (n.buffer[r] |= 128)
	o.write(n)
}
var $E = class {
		constructor(e) {
			this.buffer = e
			this.pos = 0
		}
		read(e) {
			let t = this.buffer.slice(this.pos, this.pos + e)
			return (this.pos += t.byteLength), t
		}
	},
	zE = class {
		constructor() {
			this.buffers = []
		}
		get buffer() {
			return z.concat(this.buffers)
		}
		write(e) {
			this.buffers.push(e)
		}
	}
function aa(o) {
	let e = z.alloc(1)
	return e.writeUInt8(o, 0), e
}
var Fl = { Undefined: aa(0), String: aa(1), Buffer: aa(2), VSBuffer: aa(3), Array: aa(4), Object: aa(5), Uint: aa(6) },
	i5 = typeof Buffer < "u"
function qE(o, e) {
	if (typeof e > "u") o.write(Fl.Undefined)
	else if (typeof e == "string") {
		let t = z.fromString(e)
		o.write(Fl.String), Ac(o, t.byteLength), o.write(t)
	} else if (i5 && Buffer.isBuffer(e)) {
		let t = z.wrap(e)
		o.write(Fl.Buffer), Ac(o, t.byteLength), o.write(t)
	} else if (e instanceof z) o.write(Fl.VSBuffer), Ac(o, e.byteLength), o.write(e)
	else if (Array.isArray(e)) {
		o.write(Fl.Array), Ac(o, e.length)
		for (let t of e) qE(o, t)
	} else if (typeof e == "number" && (e | 0) === e) o.write(Fl.Uint), Ac(o, e)
	else {
		let t = z.fromString(JSON.stringify(e))
		o.write(Fl.Object), Ac(o, t.byteLength), o.write(t)
	}
}
function KE(o) {
	switch (o.read(1).readUInt8(0)) {
		case 0:
			return
		case 1:
			return o.read(Rc(o)).toString()
		case 2:
			return o.read(Rc(o)).buffer
		case 3:
			return o.read(Rc(o))
		case 4: {
			let t = Rc(o),
				n = []
			for (let r = 0; r < t; r++) n.push(KE(o))
			return n
		}
		case 5:
			return JSON.parse(o.read(Rc(o)).toString())
		case 6:
			return Rc(o)
	}
}
var Cf = class {
	constructor(e, t = null) {
		this.protocol = e
		this.isDisposed = !1
		this.state = 0
		this.activeRequests = new Set()
		this.handlers = new Map()
		this.lastRequestId = 0
		this._onDidInitialize = new E()
		this.onDidInitialize = this._onDidInitialize.event
		;(this.protocolListener = this.protocol.onMessage((n) => this.onBuffer(n))), (this.logger = t)
	}
	getChannel(e) {
		let t = this
		return {
			call(n, r, i) {
				return t.isDisposed ? Promise.reject(new xt()) : t.requestPromise(e, n, r, i)
			},
			listen(n, r) {
				return t.isDisposed ? Te.None : t.requestEvent(e, n, r)
			},
		}
	}
	requestPromise(e, t, n, r = De.None) {
		let i = this.lastRequestId++,
			a = { id: i, type: 100, channelName: e, name: t, arg: n }
		if (r.isCancellationRequested) return Promise.reject(new xt())
		let l, d
		return new Promise((u, m) => {
			if (r.isCancellationRequested) return m(new xt())
			let f = () => {
					let I = (C) => {
						switch (C.type) {
							case 201:
								this.handlers.delete(i), u(C.data)
								break
							case 202: {
								this.handlers.delete(i)
								let T = new Error(C.data.message)
								;(T.stack = Array.isArray(C.data.stack)
									? C.data.stack.join(`
`)
									: C.data.stack),
									(T.name = C.data.name),
									m(T)
								break
							}
							case 203:
								this.handlers.delete(i), m(C.data)
								break
						}
					}
					this.handlers.set(i, I), this.sendRequest(a)
				},
				h = null
			this.state === 1
				? f()
				: ((h = kr((I) => this.whenInitialized())),
					h.then(() => {
						;(h = null), f()
					}))
			let g = () => {
				h ? (h.cancel(), (h = null)) : this.sendRequest({ id: i, type: 101 }), m(new xt())
			}
			;(l = r.onCancellationRequested(g)),
				(d = {
					dispose: zi(() => {
						g(), l.dispose()
					}),
				}),
				this.activeRequests.add(d)
		}).finally(() => {
			l?.dispose(), this.activeRequests.delete(d)
		})
	}
	requestEvent(e, t, n) {
		let r = this.lastRequestId++,
			s = { id: r, type: 102, channelName: e, name: t, arg: n },
			a = null,
			l = new E({
				onWillAddFirstListener: () => {
					let c = () => {
						this.activeRequests.add(l), this.sendRequest(s)
					}
					this.state === 1
						? c()
						: ((a = kr((u) => this.whenInitialized())),
							a.then(() => {
								;(a = null), c()
							}))
				},
				onDidRemoveLastListener: () => {
					a
						? (a.cancel(), (a = null))
						: (this.activeRequests.delete(l), this.sendRequest({ id: r, type: 103 }))
				},
			}),
			d = (c) => l.fire(c.data)
		return this.handlers.set(r, d), l.event
	}
	sendRequest(e) {
		switch (e.type) {
			case 100:
			case 102: {
				let t = this.send([e.type, e.id, e.channelName, e.name], e.arg)
				this.logger?.logOutgoing(t, e.id, 0, `${EO(e.type)}: ${e.channelName}.${e.name}`, e.arg)
				return
			}
			case 101:
			case 103: {
				let t = this.send([e.type, e.id])
				this.logger?.logOutgoing(t, e.id, 0, EO(e.type))
				return
			}
		}
	}
	send(e, t = void 0) {
		let n = new zE()
		return qE(n, e), qE(n, t), this.sendBuffer(n.buffer)
	}
	sendBuffer(e) {
		try {
			return this.protocol.send(e), e.byteLength
		} catch {
			return 0
		}
	}
	onBuffer(e) {
		let t = new $E(e),
			n = KE(t),
			r = KE(t),
			i = n[0]
		switch (i) {
			case 200:
				return this.logger?.logIncoming(e.byteLength, 0, 0, wO(i)), this.onResponse({ type: n[0] })
			case 201:
			case 202:
			case 204:
			case 203:
				return (
					this.logger?.logIncoming(e.byteLength, n[1], 0, wO(i), r),
					this.onResponse({ type: n[0], id: n[1], data: r })
				)
		}
	}
	onResponse(e) {
		if (e.type === 200) {
			;(this.state = 1), this._onDidInitialize.fire()
			return
		}
		this.handlers.get(e.id)?.(e)
	}
	get onDidInitializePromise() {
		return Te.toPromise(this.onDidInitialize)
	}
	whenInitialized() {
		return this.state === 1 ? Promise.resolve() : this.onDidInitializePromise
	}
	dispose() {
		;(this.isDisposed = !0),
			this.protocolListener && (this.protocolListener.dispose(), (this.protocolListener = null)),
			Fn(this.activeRequests.values()),
			this.activeRequests.clear()
	}
}
R([qv], Cf.prototype, "onDidInitializePromise", 1)
function PO(o) {
	let e = !1
	return {
		call(t, n, r) {
			return e
				? o.call(t, n, r)
				: Wt(0)
						.then(() => (e = !0))
						.then(() => o.call(t, n, r))
		},
		listen(t, n) {
			if (e) return o.listen(t, n)
			let r = new nv()
			return (
				Wt(0)
					.then(() => (e = !0))
					.then(() => (r.input = o.listen(t, n))),
				r.event
			)
		},
	}
}
var jE
;((r) => {
	function o(i, s, a) {
		let l = i,
			d = a && a.disableMarshalling,
			c = new Map()
		for (let u in l) t(u) && c.set(u, Te.buffer(l[u], !0, void 0, s))
		return new (class {
			listen(u, m, f) {
				let h = c.get(m)
				if (h) return h
				let g = l[m]
				if (typeof g == "function") {
					if (n(m)) return g.call(l, f)
					if (t(m)) return c.set(m, Te.buffer(l[m], !0, void 0, s)), c.get(m)
				}
				throw new Kn(`Event not found: ${m}`)
			}
			call(u, m, f) {
				let h = l[m]
				if (typeof h == "function") {
					if (!d && Array.isArray(f)) for (let I = 0; I < f.length; I++) f[I] = ut(f[I])
					let g = h.apply(l, f)
					return g instanceof Promise || (g = Promise.resolve(g)), g
				}
				throw new Kn(`Method not found: ${m}`)
			}
		})()
	}
	r.fromService = o
	function e(i, s) {
		let a = s && s.disableMarshalling
		return new Proxy(
			{},
			{
				get(l, d) {
					if (typeof d == "string")
						return s?.properties?.has(d)
							? s.properties.get(d)
							: n(d)
								? function (c) {
										return i.listen(d, c)
									}
								: t(d)
									? i.listen(d)
									: async function (...c) {
											let u
											s && !bt(s.context) ? (u = [s.context, ...c]) : (u = c)
											let m = await i.call(d, u)
											return a ? m : ut(m)
										}
					throw new Kn(`Property not found: ${String(d)}`)
				},
			},
		)
	}
	r.toService = e
	function t(i) {
		return i[0] === "o" && i[1] === "n" && uE(i.charCodeAt(2))
	}
	function n(i) {
		return /^onDynamic/.test(i) && uE(i.charCodeAt(9))
	}
})((jE ||= {}))
var Tf
;((s) => {
	;(s.enableDiagnostics = !1), (s.records = [])
	let t = new WeakMap(),
		n = 0
	function r(a, l) {
		if (!t.has(a)) {
			let d = String(++n)
			t.set(a, d)
		}
		return t.get(a)
	}
	function i(a, l, d, c) {}
	s.traceSocketEvent = i
})((Tf ||= {}))
var GE = null
function la() {
	return GE || (GE = z.alloc(0)), GE
}
var Sf = class {
	get byteLength() {
		return this._totalLength
	}
	constructor() {
		;(this._chunks = []), (this._totalLength = 0)
	}
	acceptChunk(e) {
		this._chunks.push(e), (this._totalLength += e.byteLength)
	}
	read(e) {
		return this._read(e, !0)
	}
	peek(e) {
		return this._read(e, !1)
	}
	_read(e, t) {
		if (e === 0) return la()
		if (e > this._totalLength) throw new Error("Cannot read so many bytes!")
		if (this._chunks[0].byteLength === e) {
			let s = this._chunks[0]
			return t && (this._chunks.shift(), (this._totalLength -= e)), s
		}
		if (this._chunks[0].byteLength > e) {
			let s = this._chunks[0].slice(0, e)
			return t && ((this._chunks[0] = this._chunks[0].slice(e)), (this._totalLength -= e)), s
		}
		let n = z.alloc(e),
			r = 0,
			i = 0
		for (; e > 0; ) {
			let s = this._chunks[i]
			if (s.byteLength > e) {
				let a = s.slice(0, e)
				n.set(a, r), (r += e), t && ((this._chunks[i] = s.slice(e)), (this._totalLength -= e)), (e -= e)
			} else
				n.set(s, r),
					(r += s.byteLength),
					t ? (this._chunks.shift(), (this._totalLength -= s.byteLength)) : i++,
					(e -= s.byteLength)
		}
		return n
	}
}
function _O(o) {
	switch (o) {
		case 0:
			return "None"
		case 1:
			return "Regular"
		case 2:
			return "Control"
		case 3:
			return "Ack"
		case 5:
			return "Disconnect"
		case 6:
			return "ReplayRequest"
		case 7:
			return "PauseWriting"
		case 8:
			return "ResumeWriting"
		case 9:
			return "KeepAlive"
	}
}
var ao = class {
		constructor(e, t, n, r) {
			this.type = e
			this.id = t
			this.ack = n
			this.data = r
			this.writtenTime = 0
		}
		get size() {
			return this.data.byteLength
		}
	},
	jv = class extends $ {
		constructor(t) {
			super()
			this._onMessage = this._register(new E())
			this.onMessage = this._onMessage.event
			this._state = { readHead: !0, readLen: 13, messageType: 0, id: 0, ack: 0 }
			;(this._socket = t),
				(this._isDisposed = !1),
				(this._incomingData = new Sf()),
				this._register(this._socket.onData((n) => this.acceptChunk(n))),
				(this.lastReadTime = Date.now())
		}
		acceptChunk(t) {
			if (!t || t.byteLength === 0) {
				gt.logIncoming(0, 0, 0, "Accept chunk: empty buffer")
				return
			}
			for (
				gt.logIncoming(
					0,
					0,
					0,
					"Accept chunk: " +
						t.byteLength +
						", read head: " +
						this._state.readHead +
						", read len: " +
						this._state.readLen,
				),
					this.lastReadTime = Date.now(),
					this._incomingData.acceptChunk(t);
				this._incomingData.byteLength >= this._state.readLen;

			) {
				let n = this._incomingData.read(this._state.readLen)
				if (this._state.readHead)
					(this._state.readHead = !1),
						(this._state.readLen = n.readUInt32BE(9)),
						(this._state.messageType = n.readUInt8(0)),
						(this._state.id = n.readUInt32BE(1)),
						(this._state.ack = n.readUInt32BE(5)),
						gt.logIncoming(0, 0, 0, "Protocol header read: " + this._state.id),
						this._socket.traceSocketEvent("protocolHeaderRead", {
							messageType: _O(this._state.messageType),
							id: this._state.id,
							ack: this._state.ack,
							messageSize: this._state.readLen,
						})
				else {
					let r = this._state.messageType,
						i = this._state.id,
						s = this._state.ack
					if (
						((this._state.readHead = !0),
						(this._state.readLen = 13),
						(this._state.messageType = 0),
						(this._state.id = 0),
						(this._state.ack = 0),
						gt.logIncoming(0, 0, 0, "Protocol message read: " + i + ", type: " + r + ", ack: " + s),
						this._socket.traceSocketEvent("protocolMessageRead", n),
						this._onMessage.fire(new ao(r, i, s, n)),
						this._isDisposed)
					)
						break
				}
			}
		}
		readEntireBuffer() {
			return this._incomingData.read(this._incomingData.byteLength)
		}
		dispose() {
			;(this._isDisposed = !0), super.dispose()
		}
	},
	Gv = class {
		constructor(e) {
			this._writeNowTimeout = null
			;(this._isDisposed = !1),
				(this._isPaused = !1),
				(this._socket = e),
				(this._data = []),
				(this._totalLength = 0),
				(this.lastWriteTime = 0)
		}
		dispose() {
			try {
				this.flush()
			} catch {}
			this._isDisposed = !0
		}
		drain() {
			return this.flush(), this._socket.drain()
		}
		flush() {
			this._writeNow()
		}
		pause() {
			this._isPaused = !0
		}
		resume() {
			;(this._isPaused = !1), this._scheduleWriting()
		}
		write(e) {
			if (this._isDisposed) return
			;(e.writtenTime = Date.now()), (this.lastWriteTime = Date.now())
			let t = z.alloc(13)
			t.writeUInt8(e.type, 0),
				t.writeUInt32BE(e.id, 1),
				t.writeUInt32BE(e.ack, 5),
				t.writeUInt32BE(e.data.byteLength, 9),
				this._socket.traceSocketEvent("protocolHeaderWrite", {
					messageType: _O(e.type),
					id: e.id,
					ack: e.ack,
					messageSize: e.data.byteLength,
				}),
				this._socket.traceSocketEvent("protocolMessageWrite", e.data),
				this._writeSoon(t, e.data)
		}
		_bufferAdd(e, t) {
			let n = this._totalLength === 0
			return this._data.push(e, t), (this._totalLength += e.byteLength + t.byteLength), n
		}
		_bufferTake() {
			let e = z.concat(this._data, this._totalLength)
			return (this._data.length = 0), (this._totalLength = 0), e
		}
		_writeSoon(e, t) {
			this._bufferAdd(e, t) && this._scheduleWriting()
		}
		_scheduleWriting() {
			this._writeNowTimeout ||
				(this._writeNowTimeout = setTimeout(() => {
					;(this._writeNowTimeout = null), this._writeNow()
				}))
		}
		_writeNow() {
			if (this._totalLength === 0 || this._isPaused) return
			let e = this._bufferTake()
			this._socket.traceSocketEvent("protocolWrite", { byteLength: e.byteLength }), this._socket.write(e)
		}
	}
var ui = class {
		constructor() {
			this._hasListeners = !1
			this._isDeliveringMessages = !1
			this._bufferedMessages = []
			;(this._emitter = new E({
				onWillAddFirstListener: () => {
					;(this._hasListeners = !0), queueMicrotask(() => this._deliverMessages())
				},
				onDidRemoveLastListener: () => {
					this._hasListeners = !1
				},
			})),
				(this.event = this._emitter.event)
		}
		_deliverMessages() {
			if (!this._isDeliveringMessages) {
				for (this._isDeliveringMessages = !0; this._hasListeners && this._bufferedMessages.length > 0; )
					this._emitter.fire(this._bufferedMessages.shift())
				this._isDeliveringMessages = !1
			}
		}
		fire(e) {
			this._hasListeners
				? this._bufferedMessages.length > 0
					? this._bufferedMessages.push(e)
					: this._emitter.fire(e)
				: this._bufferedMessages.push(e)
		}
		flushBuffer() {
			this._bufferedMessages = []
		}
	},
	QE = class {
		constructor(e) {
			;(this.data = e), (this.next = null)
		}
	},
	JE = class {
		constructor() {
			;(this._first = null), (this._last = null)
		}
		length() {
			let e = 0,
				t = this._first
			for (; t; ) (t = t.next), e++
			return e
		}
		peek() {
			return this._first ? this._first.data : null
		}
		toArray() {
			let e = [],
				t = 0,
				n = this._first
			for (; n; ) (e[t++] = n.data), (n = n.next)
			return e
		}
		pop() {
			if (this._first) {
				if (this._first === this._last) {
					;(this._first = null), (this._last = null)
					return
				}
				this._first = this._first.next
			}
		}
		push(e) {
			let t = new QE(e)
			if (!this._first) {
				;(this._first = t), (this._last = t)
				return
			}
			;(this._last.next = t), (this._last = t)
		}
	},
	XE = class o {
		static {
			this._HISTORY_LENGTH = 10
		}
		static {
			this._INSTANCE = null
		}
		static getInstance() {
			return o._INSTANCE || (o._INSTANCE = new o()), o._INSTANCE
		}
		constructor() {
			this.lastRuns = []
			let e = Date.now()
			for (let t = 0; t < o._HISTORY_LENGTH; t++) this.lastRuns[t] = e - 1e3 * t
			setInterval(() => {
				for (let t = o._HISTORY_LENGTH; t >= 1; t--) this.lastRuns[t] = this.lastRuns[t - 1]
				this.lastRuns[0] = Date.now()
			}, 1e3)
		}
		load() {
			let e = Date.now(),
				t = (1 + o._HISTORY_LENGTH) * 1e3,
				n = 0
			for (let r = 0; r < o._HISTORY_LENGTH; r++) e - this.lastRuns[r] <= t && n++
			return 1 - n / o._HISTORY_LENGTH
		}
		hasHighLoad() {
			return this.load() >= 0.5
		}
	},
	Nl = class {
		constructor(e) {
			this._onControlMessage = new ui()
			this.onControlMessage = this._onControlMessage.event
			this._onMessage = new ui()
			this.onMessage = this._onMessage.event
			this._onDidDispose = new ui()
			this.onDidDispose = this._onDidDispose.event
			this._onSocketClose = new ui()
			this.onSocketClose = this._onSocketClose.event
			this._onSocketTimeout = new ui()
			this.onSocketTimeout = this._onSocketTimeout.event
			;(this._loadEstimator = e.loadEstimator ?? XE.getInstance()),
				(this._shouldSendKeepAlive = e.sendKeepAlive ?? !0),
				(this._isReconnecting = !1),
				(this._outgoingUnackMsg = new JE()),
				(this._outgoingMsgId = 0),
				(this._outgoingAckId = 0),
				(this._outgoingAckTimeout = null),
				(this._incomingMsgId = 0),
				(this._incomingAckId = 0),
				(this._incomingMsgLastTime = 0),
				(this._incomingAckTimeout = null),
				(this._lastReplayRequestTime = 0),
				(this._lastSocketTimeoutTime = Date.now()),
				(this._socketDisposables = new Q()),
				(this._socket = e.socket),
				(this._socketWriter = this._socketDisposables.add(new Gv(this._socket))),
				(this._socketReader = this._socketDisposables.add(new jv(this._socket))),
				this._socketDisposables.add(this._socketReader.onMessage((t) => this._receiveMessage(t))),
				this._socketDisposables.add(this._socket.onClose((t) => this._onSocketClose.fire(t))),
				(this._fileLogger = new sa("PersistentProtocol")),
				e.initialChunk && this._socketReader.acceptChunk(e.initialChunk),
				this._shouldSendKeepAlive
					? (this._keepAliveInterval = setInterval(() => {
							this._sendKeepAlive()
						}, 5e3))
					: (this._keepAliveInterval = null)
		}
		get unacknowledgedCount() {
			return this._outgoingMsgId - this._outgoingAckId
		}
		dispose() {
			this._outgoingAckTimeout && (clearTimeout(this._outgoingAckTimeout), (this._outgoingAckTimeout = null)),
				this._incomingAckTimeout && (clearTimeout(this._incomingAckTimeout), (this._incomingAckTimeout = null)),
				this._keepAliveInterval && (clearInterval(this._keepAliveInterval), (this._keepAliveInterval = null)),
				this._socketDisposables.dispose()
		}
		drain() {
			return this._socketWriter.drain()
		}
		sendDisconnect() {
			if (!this._didSendDisconnect) {
				this._didSendDisconnect = !0
				let e = new ao(5, 0, 0, la())
				this._socketWriter.write(e), this._socketWriter.flush()
			}
		}
		sendPause() {
			let e = new ao(7, 0, 0, la())
			this._socketWriter.write(e)
		}
		sendResume() {
			let e = new ao(8, 0, 0, la())
			this._socketWriter.write(e)
		}
		pauseSocketWriting() {
			this._socketWriter.pause()
		}
		getSocket() {
			return this._socket
		}
		getMillisSinceLastIncomingData() {
			return Date.now() - this._socketReader.lastReadTime
		}
		beginAcceptReconnection(e, t) {
			this._fileLogger.logIncoming(0, 0, 0, "Begin accept reconnection"),
				(this._isReconnecting = !0),
				this._socketDisposables.dispose(),
				(this._socketDisposables = new Q()),
				this._onControlMessage.flushBuffer(),
				this._onSocketClose.flushBuffer(),
				this._onSocketTimeout.flushBuffer(),
				this._socket.dispose(),
				(this._lastReplayRequestTime = 0),
				(this._lastSocketTimeoutTime = Date.now()),
				(this._socket = e),
				(this._socketWriter = this._socketDisposables.add(new Gv(this._socket))),
				(this._socketReader = this._socketDisposables.add(new jv(this._socket))),
				this._socketDisposables.add(this._socketReader.onMessage((n) => this._receiveMessage(n))),
				this._socketDisposables.add(this._socket.onClose((n) => this._onSocketClose.fire(n))),
				this._socketReader.acceptChunk(t)
		}
		endAcceptReconnection() {
			this._fileLogger.logIncoming(0, 0, 0, "End accept reconnection"),
				(this._isReconnecting = !1),
				(this._incomingAckId = this._incomingMsgId)
			let e = new ao(3, 0, this._incomingAckId, la())
			this._socketWriter.write(e)
			let t = this._outgoingUnackMsg.toArray()
			for (let n = 0, r = t.length; n < r; n++) this._socketWriter.write(t[n])
			this._recvAckCheck()
		}
		acceptDisconnect() {
			this._onDidDispose.fire()
		}
		_receiveMessage(e) {
			if (
				(this._fileLogger.logIncoming(
					0,
					0,
					0,
					"Receive message: " +
						e.type +
						", id: " +
						e.id +
						", ack: " +
						e.ack +
						", data: " +
						e.data.byteLength +
						", _incomingMsgId: " +
						this._incomingMsgId,
				),
				e.ack > this._outgoingAckId)
			) {
				this._outgoingAckId = e.ack
				do {
					let t = this._outgoingUnackMsg.peek()
					if (t && t.id <= e.ack) this._outgoingUnackMsg.pop()
					else break
				} while (!0)
			}
			switch (e.type) {
				case 0:
					break
				case 1: {
					if (e.id > this._incomingMsgId)
						if (e.id !== this._incomingMsgId + 1) {
							let t = Date.now()
							t - this._lastReplayRequestTime > 1e4 &&
								((this._lastReplayRequestTime = t), this._socketWriter.write(new ao(6, 0, 0, la())))
						} else
							(this._incomingMsgId = e.id),
								(this._incomingMsgLastTime = Date.now()),
								this._sendAckCheck(),
								this._onMessage.fire(e.data)
					break
				}
				case 2: {
					this._onControlMessage.fire(e.data)
					break
				}
				case 3:
					break
				case 5: {
					this._onDidDispose.fire()
					break
				}
				case 6: {
					let t = this._outgoingUnackMsg.toArray()
					for (let n = 0, r = t.length; n < r; n++) this._socketWriter.write(t[n])
					this._recvAckCheck()
					break
				}
				case 7: {
					this._socketWriter.pause()
					break
				}
				case 8: {
					this._socketWriter.resume()
					break
				}
				case 9:
					break
			}
		}
		readEntireBuffer() {
			return this._socketReader.readEntireBuffer()
		}
		flush() {
			this._socketWriter.flush()
		}
		send(e) {
			let t = ++this._outgoingMsgId
			this._incomingAckId = this._incomingMsgId
			let n = new ao(1, t, this._incomingAckId, e)
			this._outgoingUnackMsg.push(n), this._isReconnecting || (this._socketWriter.write(n), this._recvAckCheck())
		}
		sendControl(e) {
			let t = new ao(2, 0, 0, e)
			this._socketWriter.write(t)
		}
		_sendAckCheck() {
			if (this._incomingMsgId <= this._incomingAckId || this._incomingAckTimeout) return
			let e = Date.now() - this._incomingMsgLastTime
			if (e >= 2e3) {
				this._sendAck()
				return
			}
			this._incomingAckTimeout = setTimeout(
				() => {
					;(this._incomingAckTimeout = null), this._sendAckCheck()
				},
				2e3 - e + 5,
			)
		}
		_recvAckCheck() {
			if (this._outgoingMsgId <= this._outgoingAckId || this._outgoingAckTimeout || this._isReconnecting) return
			let e = this._outgoingUnackMsg.peek(),
				t = Date.now() - e.writtenTime,
				n = Date.now() - this._socketReader.lastReadTime,
				r = Date.now() - this._lastSocketTimeoutTime
			if (t >= 2e4 && n >= 2e4 && r >= 2e4 && !this._loadEstimator.hasHighLoad()) {
				;(this._lastSocketTimeoutTime = Date.now()),
					this._onSocketTimeout.fire({
						unacknowledgedMsgCount: this._outgoingUnackMsg.length(),
						timeSinceOldestUnacknowledgedMsg: t,
						timeSinceLastReceivedSomeData: n,
					})
				return
			}
			let i = Math.max(2e4 - t, 2e4 - n, 2e4 - r, 500)
			this._outgoingAckTimeout = setTimeout(() => {
				;(this._outgoingAckTimeout = null), this._recvAckCheck()
			}, i)
		}
		_sendAck() {
			if (this._incomingMsgId <= this._incomingAckId) return
			this._incomingAckId = this._incomingMsgId
			let e = new ao(3, 0, this._incomingAckId, la())
			this._socketWriter.write(e)
		}
		_sendKeepAlive() {
			this._incomingAckId = this._incomingMsgId
			let e = new ao(9, 0, this._incomingAckId, la())
			this._socketWriter.write(e)
		}
	}
import { tmpdir as a5 } from "os"
import { createDeflateRaw as l5, createInflateRaw as d5 } from "zlib"
var He = (function () {
	if (typeof crypto.randomUUID == "function") return crypto.randomUUID.bind(crypto)
	let o = new Uint8Array(16),
		e = []
	for (let t = 0; t < 256; t++) e.push(t.toString(16).padStart(2, "0"))
	return function () {
		crypto.getRandomValues(o), (o[6] = (o[6] & 15) | 64), (o[8] = (o[8] & 63) | 128)
		let n = 0,
			r = ""
		return (
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			r
		)
	}
})()
var c5 = 3e4,
	ts = class {
		constructor(e, t = "") {
			this._canWrite = !0
			;(this.debugLabel = t),
				(this.socket = e),
				this.traceSocketEvent("created", { type: "NodeSocket" }),
				(this._errorListener = (r) => {
					if ((this.traceSocketEvent("error", { code: r?.code, message: r?.message }), r)) {
						if (r.code === "EPIPE") return
						Be(r)
					}
				}),
				this.socket.on("error", this._errorListener)
			let n
			;(this._closeListener = (r) => {
				this.traceSocketEvent("close", { hadError: r }), (this._canWrite = !1), n && clearTimeout(n)
			}),
				this.socket.on("close", this._closeListener),
				(this._endListener = () => {
					this.traceSocketEvent("nodeEndReceived"),
						(this._canWrite = !1),
						(n = setTimeout(() => e.destroy(), c5))
				}),
				this.socket.on("end", this._endListener)
		}
		traceSocketEvent(e, t) {
			Tf.traceSocketEvent(this.socket, this.debugLabel, e, t)
		}
		dispose() {
			this.socket.off("error", this._errorListener),
				this.socket.off("close", this._closeListener),
				this.socket.off("end", this._endListener),
				this.socket.destroy()
		}
		onData(e) {
			let t = (n) => {
				this.traceSocketEvent("read", n), e(z.wrap(n))
			}
			return this.socket.on("data", t), { dispose: () => this.socket.off("data", t) }
		}
		onClose(e) {
			let t = (n) => {
				e({ type: 0, hadError: n, error: void 0 })
			}
			return this.socket.on("close", t), { dispose: () => this.socket.off("close", t) }
		}
		onEnd(e) {
			let t = () => {
				e()
			}
			return this.socket.on("end", t), { dispose: () => this.socket.off("end", t) }
		}
		write(e) {
			if (!(this.socket.destroyed || !this._canWrite))
				try {
					this.traceSocketEvent("write", e),
						this.socket.write(e.buffer, (t) => {
							if (t) {
								if (t.code === "EPIPE") return
								Be(t)
							}
						})
				} catch (t) {
					if (t.code === "EPIPE") return
					Be(t)
				}
		}
		end() {
			this.traceSocketEvent("nodeEndSent"), this.socket.end()
		}
		drain() {
			return (
				this.traceSocketEvent("nodeDrainBegin"),
				new Promise((e, t) => {
					if (this.socket.bufferSize === 0) {
						this.traceSocketEvent("nodeDrainEnd"), e()
						return
					}
					let n = () => {
						this.socket.off("close", n),
							this.socket.off("end", n),
							this.socket.off("error", n),
							this.socket.off("timeout", n),
							this.socket.off("drain", n),
							this.traceSocketEvent("nodeDrainEnd"),
							e()
					}
					this.socket.on("close", n),
						this.socket.on("end", n),
						this.socket.on("error", n),
						this.socket.on("timeout", n),
						this.socket.on("drain", n)
				})
			)
		}
	}
var Qv = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._onData = this._register(new E())
			this._onClose = this._register(new E())
			this._isEnded = !1
			this._state = { state: 1, readLen: 2, fin: 0, compressed: !1, firstFrameOfMessage: !0, mask: 0, opcode: 0 }
			;(this.socket = t),
				this.traceSocketEvent("created", {
					type: "WebSocketNodeSocket",
					permessageDeflate: n,
					inflateBytesLength: r?.byteLength || 0,
					recordInflateBytes: i,
				}),
				(this._flowManager = this._register(new YE(this, n, r, i, this._onData, (s, a) => this._write(s, a)))),
				this._register(
					this._flowManager.onError((s) => {
						console.error(s), Be(s), this._onClose.fire({ type: 0, hadError: !0, error: s })
					}),
				),
				(this._incomingData = new Sf()),
				this._register(this.socket.onData((s) => this._acceptChunk(s))),
				this._register(
					this.socket.onClose(async (s) => {
						this._flowManager.isProcessingReadQueue() &&
							(await Te.toPromise(this._flowManager.onDidFinishProcessingReadQueue)),
							this._onClose.fire(s)
					}),
				)
		}
		get permessageDeflate() {
			return this._flowManager.permessageDeflate
		}
		get recordedInflateBytes() {
			return this._flowManager.recordedInflateBytes
		}
		traceSocketEvent(t, n) {
			this.socket.traceSocketEvent(t, n)
		}
		dispose() {
			this._flowManager.isProcessingWriteQueue()
				? this._register(
						this._flowManager.onDidFinishProcessingWriteQueue(() => {
							this.dispose()
						}),
					)
				: (this.socket.dispose(), super.dispose())
		}
		onData(t) {
			return this._onData.event(t)
		}
		onClose(t) {
			return this._onClose.event(t)
		}
		onEnd(t) {
			return this.socket.onEnd(t)
		}
		write(t) {
			let n = 0
			for (; n < t.byteLength; )
				this._flowManager.writeMessage(t.slice(n, Math.min(n + 262144, t.byteLength)), {
					compressed: !0,
					opcode: 2,
				}),
					(n += 262144)
		}
		_write(t, { compressed: n, opcode: r }) {
			if (this._isEnded) return
			this.traceSocketEvent("webSocketNodeSocketWrite", t)
			let i = 2
			t.byteLength < 126 ? (i += 0) : t.byteLength < 2 ** 16 ? (i += 2) : (i += 8)
			let s = z.alloc(i),
				a = n ? 64 : 0,
				l = r & 15
			if ((s.writeUInt8(128 | a | l, 0), t.byteLength < 126)) s.writeUInt8(t.byteLength, 1)
			else if (t.byteLength < 2 ** 16) {
				s.writeUInt8(126, 1)
				let d = 1
				s.writeUInt8((t.byteLength >>> 8) & 255, ++d), s.writeUInt8((t.byteLength >>> 0) & 255, ++d)
			} else {
				s.writeUInt8(127, 1)
				let d = 1
				s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8((t.byteLength >>> 24) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 16) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 8) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 0) & 255, ++d)
			}
			this.socket.write(z.concat([s, t]))
		}
		end() {
			;(this._isEnded = !0), this.socket.end()
		}
		_acceptChunk(t) {
			if (t.byteLength !== 0) {
				for (this._incomingData.acceptChunk(t); this._incomingData.byteLength >= this._state.readLen; )
					if (this._state.state === 1) {
						let n = this._incomingData.peek(this._state.readLen),
							r = n.readUInt8(0),
							i = (r & 128) >>> 7,
							s = (r & 64) >>> 6,
							a = r & 15,
							l = n.readUInt8(1),
							d = (l & 128) >>> 7,
							c = l & 127
						;(this._state.state = 2),
							(this._state.readLen = 2 + (d ? 4 : 0) + (c === 126 ? 2 : 0) + (c === 127 ? 8 : 0)),
							(this._state.fin = i),
							this._state.firstFrameOfMessage && (this._state.compressed = !!s),
							(this._state.firstFrameOfMessage = !!i),
							(this._state.mask = 0),
							(this._state.opcode = a),
							this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
								headerSize: this._state.readLen,
								compressed: this._state.compressed,
								fin: this._state.fin,
								opcode: this._state.opcode,
							})
					} else if (this._state.state === 2) {
						let n = this._incomingData.read(this._state.readLen),
							r = n.readUInt8(1),
							i = (r & 128) >>> 7,
							s = r & 127,
							a = 1
						s === 126
							? (s = n.readUInt8(++a) * 2 ** 8 + n.readUInt8(++a))
							: s === 127 &&
								(s =
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 2 ** 24 +
									n.readUInt8(++a) * 2 ** 16 +
									n.readUInt8(++a) * 2 ** 8 +
									n.readUInt8(++a))
						let l = 0
						i &&
							(l =
								n.readUInt8(++a) * 2 ** 24 +
								n.readUInt8(++a) * 2 ** 16 +
								n.readUInt8(++a) * 2 ** 8 +
								n.readUInt8(++a)),
							(this._state.state = 3),
							(this._state.readLen = s),
							(this._state.mask = l),
							this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
								bodySize: this._state.readLen,
								compressed: this._state.compressed,
								fin: this._state.fin,
								mask: this._state.mask,
								opcode: this._state.opcode,
							})
					} else if (this._state.state === 3) {
						let n = this._incomingData.read(this._state.readLen)
						this.traceSocketEvent("webSocketNodeSocketReadData", n),
							u5(n, this._state.mask),
							this.traceSocketEvent("webSocketNodeSocketUnmaskedData", n),
							(this._state.state = 1),
							(this._state.readLen = 2),
							(this._state.mask = 0),
							this._state.opcode <= 2
								? this._flowManager.acceptFrame(n, this._state.compressed, !!this._state.fin)
								: this._state.opcode === 9 &&
									this._flowManager.writeMessage(n, { compressed: !1, opcode: 10 })
					}
			}
		}
		async drain() {
			this.traceSocketEvent("webSocketNodeSocketDrainBegin"),
				this._flowManager.isProcessingWriteQueue() &&
					(await Te.toPromise(this._flowManager.onDidFinishProcessingWriteQueue)),
				await this.socket.drain(),
				this.traceSocketEvent("webSocketNodeSocketDrainEnd")
		}
	},
	YE = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this._tracer = t
			this._onData = s
			this._writeFn = a
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._writeQueue = []
			this._readQueue = []
			this._onDidFinishProcessingReadQueue = this._register(new E())
			this.onDidFinishProcessingReadQueue = this._onDidFinishProcessingReadQueue.event
			this._onDidFinishProcessingWriteQueue = this._register(new E())
			this.onDidFinishProcessingWriteQueue = this._onDidFinishProcessingWriteQueue.event
			this._isProcessingWriteQueue = !1
			this._isProcessingReadQueue = !1
			n
				? ((this._zlibInflateStream = this._register(new ZE(this._tracer, i, r, { windowBits: 15 }))),
					(this._zlibDeflateStream = this._register(new ew(this._tracer, { windowBits: 15 }))),
					this._register(this._zlibInflateStream.onError((l) => this._onError.fire(l))),
					this._register(this._zlibDeflateStream.onError((l) => this._onError.fire(l))))
				: ((this._zlibInflateStream = null), (this._zlibDeflateStream = null))
		}
		get permessageDeflate() {
			return !!(this._zlibInflateStream && this._zlibDeflateStream)
		}
		get recordedInflateBytes() {
			return this._zlibInflateStream ? this._zlibInflateStream.recordedInflateBytes : z.alloc(0)
		}
		writeMessage(t, n) {
			this._writeQueue.push({ data: t, options: n }), this._processWriteQueue()
		}
		async _processWriteQueue() {
			if (!this._isProcessingWriteQueue) {
				for (this._isProcessingWriteQueue = !0; this._writeQueue.length > 0; ) {
					let { data: t, options: n } = this._writeQueue.shift()
					if (this._zlibDeflateStream && n.compressed) {
						let r = await this._deflateMessage(this._zlibDeflateStream, t)
						this._writeFn(r, n)
					} else this._writeFn(t, { ...n, compressed: !1 })
				}
				;(this._isProcessingWriteQueue = !1), this._onDidFinishProcessingWriteQueue.fire()
			}
		}
		isProcessingWriteQueue() {
			return this._isProcessingWriteQueue
		}
		_deflateMessage(t, n) {
			return new Promise((r, i) => {
				t.write(n), t.flush((s) => r(s))
			})
		}
		acceptFrame(t, n, r) {
			this._readQueue.push({ data: t, isCompressed: n, isLastFrameOfMessage: r }), this._processReadQueue()
		}
		async _processReadQueue() {
			if (!this._isProcessingReadQueue) {
				for (this._isProcessingReadQueue = !0; this._readQueue.length > 0; ) {
					let t = this._readQueue.shift()
					if (this._zlibInflateStream && t.isCompressed) {
						let n = await this._inflateFrame(this._zlibInflateStream, t.data, t.isLastFrameOfMessage)
						this._onData.fire(n)
					} else this._onData.fire(t.data)
				}
				;(this._isProcessingReadQueue = !1), this._onDidFinishProcessingReadQueue.fire()
			}
		}
		isProcessingReadQueue() {
			return this._isProcessingReadQueue
		}
		_inflateFrame(t, n, r) {
			return new Promise((i, s) => {
				t.write(n), r && t.write(z.fromByteArray([0, 0, 255, 255])), t.flush((a) => i(a))
			})
		}
	},
	ZE = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._tracer = t
			this._recordInflateBytes = n
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._recordedInflateBytes = []
			this._pendingInflateData = []
			;(this._zlibInflate = d5(i)),
				this._zlibInflate.on("error", (s) => {
					this._tracer.traceSocketEvent("zlibInflateError", { message: s?.message, code: s?.code }),
						this._onError.fire(s)
				}),
				this._zlibInflate.on("data", (s) => {
					this._tracer.traceSocketEvent("zlibInflateData", s), this._pendingInflateData.push(z.wrap(s))
				}),
				r &&
					(this._tracer.traceSocketEvent("zlibInflateInitialWrite", r.buffer),
					this._zlibInflate.write(r.buffer),
					this._zlibInflate.flush(() => {
						this._tracer.traceSocketEvent("zlibInflateInitialFlushFired"),
							(this._pendingInflateData.length = 0)
					}))
		}
		get recordedInflateBytes() {
			return this._recordInflateBytes ? z.concat(this._recordedInflateBytes) : z.alloc(0)
		}
		write(t) {
			this._recordInflateBytes && this._recordedInflateBytes.push(t.clone()),
				this._tracer.traceSocketEvent("zlibInflateWrite", t),
				this._zlibInflate.write(t.buffer)
		}
		flush(t) {
			this._zlibInflate.flush(() => {
				this._tracer.traceSocketEvent("zlibInflateFlushFired")
				let n = z.concat(this._pendingInflateData)
				;(this._pendingInflateData.length = 0), t(n)
			})
		}
	},
	ew = class extends $ {
		constructor(t, n) {
			super()
			this._tracer = t
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._pendingDeflateData = []
			;(this._zlibDeflate = l5({ windowBits: 15 })),
				this._zlibDeflate.on("error", (r) => {
					this._tracer.traceSocketEvent("zlibDeflateError", { message: r?.message, code: r?.code }),
						this._onError.fire(r)
				}),
				this._zlibDeflate.on("data", (r) => {
					this._tracer.traceSocketEvent("zlibDeflateData", r), this._pendingDeflateData.push(z.wrap(r))
				})
		}
		write(t) {
			this._tracer.traceSocketEvent("zlibDeflateWrite", t.buffer), this._zlibDeflate.write(t.buffer)
		}
		flush(t) {
			this._zlibDeflate.flush(2, () => {
				this._tracer.traceSocketEvent("zlibDeflateFlushFired")
				let n = z.concat(this._pendingDeflateData)
				;(this._pendingDeflateData.length = 0), (n = n.slice(0, n.byteLength - 4)), t(n)
			})
		}
	}
function u5(o, e) {
	if (e === 0) return
	let t = o.byteLength >>> 2
	for (let l = 0; l < t; l++) {
		let d = o.readUInt32BE(l * 4)
		o.writeUInt32BE(d ^ e, l * 4)
	}
	let n = t * 4,
		r = o.byteLength - n,
		i = (e >>> 24) & 255,
		s = (e >>> 16) & 255,
		a = (e >>> 8) & 255
	r >= 1 && o.writeUInt8(o.readUInt8(n) ^ i, n),
		r >= 2 && o.writeUInt8(o.readUInt8(n + 1) ^ s, n + 1),
		r >= 3 && o.writeUInt8(o.readUInt8(n + 2) ^ a, n + 2)
}
var DO = process.env.XDG_RUNTIME_DIR,
	p5 = { 2: 107, 1: 103 }
function RO() {
	let o = He()
	if (process.platform === "win32") return `\\\\.\\pipe\\vscode-ipc-${o}-sock`
	let e = process.platform !== "darwin" && DO ? DO : a5(),
		t = Fe(e, `vscode-ipc-${o}.sock`)
	return m5(t), t
}
function m5(o) {
	let e = p5[lv]
	typeof e == "number" &&
		o.length >= e &&
		console.warn(`WARNING: IPC handle "${o}" is longer than ${e} chars, try a shorter --user-data-dir`)
}
function je(o) {
	if (!o || typeof o != "object" || o instanceof RegExp) return o
	let e = Array.isArray(o) ? [] : {}
	return (
		Object.entries(o).forEach(([t, n]) => {
			e[t] = n && typeof n == "object" ? je(n) : n
		}),
		e
	)
}
function Jv(o) {
	if (!o || typeof o != "object") return o
	let e = [o]
	for (; e.length > 0; ) {
		let t = e.shift()
		Object.freeze(t)
		for (let n in t)
			if (AO.call(t, n)) {
				let r = t[n]
				typeof r == "object" && !Object.isFrozen(r) && !V0(r) && e.push(r)
			}
	}
	return o
}
var AO = Object.prototype.hasOwnProperty
function ns(o, e) {
	return nw(o, e, new Set())
}
function nw(o, e, t) {
	if (bt(o)) return o
	let n = e(o)
	if (typeof n < "u") return n
	if (Array.isArray(o)) {
		let r = []
		for (let i of o) r.push(nw(i, e, t))
		return r
	}
	if (dt(o)) {
		if (t.has(o)) throw new Error("Cannot clone recursive data-structure")
		t.add(o)
		let r = {}
		for (let i in o) AO.call(o, i) && (r[i] = nw(o[i], e, t))
		return t.delete(o), r
	}
	return o
}
function fr(o, e, t = !0) {
	return dt(o)
		? (dt(e) &&
				Object.keys(e).forEach((n) => {
					n in o ? t && (dt(o[n]) && dt(e[n]) ? fr(o[n], e[n], t) : (o[n] = e[n])) : (o[n] = e[n])
				}),
			o)
		: e
}
function nn(o, e) {
	if (o === e) return !0
	if (
		o == null ||
		e === null ||
		e === void 0 ||
		typeof o != typeof e ||
		typeof o != "object" ||
		Array.isArray(o) !== Array.isArray(e)
	)
		return !1
	let t, n
	if (Array.isArray(o)) {
		if (o.length !== e.length) return !1
		for (t = 0; t < o.length; t++) if (!nn(o[t], e[t])) return !1
	} else {
		let r = []
		for (n in o) r.push(n)
		r.sort()
		let i = []
		for (n in e) i.push(n)
		if ((i.sort(), !nn(r, i))) return !1
		for (t = 0; t < r.length; t++) if (!nn(o[r[t]], e[r[t]])) return !1
	}
	return !0
}
function rw(o) {
	let e = new Set()
	return JSON.stringify(o, (t, n) => {
		if (dt(n) || Array.isArray(n)) {
			if (e.has(n)) return "[Circular]"
			e.add(n)
		}
		return typeof n == "bigint" ? `[BigInt ${n.toString()}]` : n
	})
}
function ow(o, e) {
	let t = e.toLowerCase(),
		n = Object.keys(o).find((r) => r.toLowerCase() === t)
	return n ? o[n] : o[e]
}
function iw(o, e) {
	let t = Object.create(null)
	for (let [n, r] of Object.entries(o)) e(n, r) && (t[n] = r)
	return t
}
var sw = {
	tabSize: 4,
	indentSize: 4,
	insertSpaces: !0,
	detectIndentation: !0,
	trimAutoWhitespace: !0,
	largeFileOptimizations: !0,
	bracketPairColorizationOptions: { enabled: !0, independentColorPoolPerBracketType: !1 },
}
var aw = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?"
function f5(o = "") {
	let e = "(-?\\d*\\.\\d\\w*)|([^"
	for (let t of aw) o.indexOf(t) >= 0 || (e += "\\" + t)
	return (e += "\\s]+)"), new RegExp(e, "g")
}
var g5 = f5()
function lw(o) {
	let e = g5
	if (o && o instanceof RegExp)
		if (o.global) e = o
		else {
			let t = "g"
			o.ignoreCase && (t += "i"),
				o.multiline && (t += "m"),
				o.unicode && (t += "u"),
				(e = new RegExp(o.source, t))
		}
	return (e.lastIndex = 0), e
}
var OO = new ko()
OO.unshift({ maxLen: 1e3, windowSize: 15, timeBudget: 150 })
function dw(o, e, t, n, r) {
	if (((e = lw(e)), r || (r = kt.first(OO)), t.length > r.maxLen)) {
		let d = o - r.maxLen / 2
		return d < 0 ? (d = 0) : (n += d), (t = t.substring(d, o + r.maxLen / 2)), dw(o, e, t, n, r)
	}
	let i = Date.now(),
		s = o - 1 - n,
		a = -1,
		l = null
	for (let d = 1; !(Date.now() - i >= r.timeBudget); d++) {
		let c = s - r.windowSize * d
		e.lastIndex = Math.max(0, c)
		let u = h5(e, t, s, a)
		if ((!u && l) || ((l = u), c <= 0)) break
		a = c
	}
	if (l) {
		let d = { word: l[0], startColumn: n + 1 + l.index, endColumn: n + 1 + l.index + l[0].length }
		return (e.lastIndex = 0), d
	}
	return null
}
function h5(o, e, t, n) {
	let r
	for (; (r = o.exec(e)); ) {
		let i = r.index || 0
		if (i <= t && o.lastIndex >= t) return r
		if (n > 0 && i > n) return null
	}
	return null
}
function cw(...o) {
	switch (o.length) {
		case 1:
			return p("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", o[0])
		case 2:
			return p("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", o[0], o[1])
		case 3:
			return p("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", o[0], o[1], o[2])
		default:
			return
	}
}
var v5 = p("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"),
	b5 = p(
		"contextkey.scanner.hint.didYouForgetToEscapeSlash",
		"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.",
	),
	da = class o {
		constructor() {
			this._input = ""
			this._start = 0
			this._current = 0
			this._tokens = []
			this._errors = []
			this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy
		}
		static getLexeme(e) {
			switch (e.type) {
				case 0:
					return "("
				case 1:
					return ")"
				case 2:
					return "!"
				case 3:
					return e.isTripleEq ? "===" : "=="
				case 4:
					return e.isTripleEq ? "!==" : "!="
				case 5:
					return "<"
				case 6:
					return "<="
				case 7:
					return ">="
				case 8:
					return ">="
				case 9:
					return "=~"
				case 10:
					return e.lexeme
				case 11:
					return "true"
				case 12:
					return "false"
				case 13:
					return "in"
				case 14:
					return "not"
				case 15:
					return "&&"
				case 16:
					return "||"
				case 17:
					return e.lexeme
				case 18:
					return e.lexeme
				case 19:
					return e.lexeme
				case 20:
					return "EOF"
				default:
					throw lc(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`)
			}
		}
		static {
			this._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0)))
		}
		static {
			this._keywords = new Map([
				["not", 14],
				["in", 13],
				["false", 12],
				["true", 11],
			])
		}
		get errors() {
			return this._errors
		}
		reset(e) {
			return (
				(this._input = e),
				(this._start = 0),
				(this._current = 0),
				(this._tokens = []),
				(this._errors = []),
				this
			)
		}
		scan() {
			for (; !this._isAtEnd(); )
				switch (((this._start = this._current), this._advance())) {
					case 40:
						this._addToken(0)
						break
					case 41:
						this._addToken(1)
						break
					case 33:
						if (this._match(61)) {
							let t = this._match(61)
							this._tokens.push({ type: 4, offset: this._start, isTripleEq: t })
						} else this._addToken(2)
						break
					case 39:
						this._quotedString()
						break
					case 47:
						this._regex()
						break
					case 61:
						if (this._match(61)) {
							let t = this._match(61)
							this._tokens.push({ type: 3, offset: this._start, isTripleEq: t })
						} else this._match(126) ? this._addToken(9) : this._error(cw("==", "=~"))
						break
					case 60:
						this._addToken(this._match(61) ? 6 : 5)
						break
					case 62:
						this._addToken(this._match(61) ? 8 : 7)
						break
					case 38:
						this._match(38) ? this._addToken(15) : this._error(cw("&&"))
						break
					case 124:
						this._match(124) ? this._addToken(16) : this._error(cw("||"))
						break
					case 32:
					case 13:
					case 9:
					case 10:
					case 160:
						break
					default:
						this._string()
				}
			return (this._start = this._current), this._addToken(20), Array.from(this._tokens)
		}
		_match(e) {
			return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0)
		}
		_advance() {
			return this._input.charCodeAt(this._current++)
		}
		_peek() {
			return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current)
		}
		_addToken(e) {
			this._tokens.push({ type: e, offset: this._start })
		}
		_error(e) {
			let t = this._start,
				n = this._input.substring(this._start, this._current),
				r = { type: 19, offset: this._start, lexeme: n }
			this._errors.push({ offset: t, lexeme: n, additionalInfo: e }), this._tokens.push(r)
		}
		_string() {
			this.stringRe.lastIndex = this._start
			let e = this.stringRe.exec(this._input)
			if (e) {
				this._current = this._start + e[0].length
				let t = this._input.substring(this._start, this._current),
					n = o._keywords.get(t)
				n ? this._addToken(n) : this._tokens.push({ type: 17, lexeme: t, offset: this._start })
			}
		}
		_quotedString() {
			for (; this._peek() !== 39 && !this._isAtEnd(); ) this._advance()
			if (this._isAtEnd()) {
				this._error(v5)
				return
			}
			this._advance(),
				this._tokens.push({
					type: 18,
					lexeme: this._input.substring(this._start + 1, this._current - 1),
					offset: this._start + 1,
				})
		}
		_regex() {
			let e = this._current,
				t = !1,
				n = !1
			for (;;) {
				if (e >= this._input.length) {
					;(this._current = e), this._error(b5)
					return
				}
				let i = this._input.charCodeAt(e)
				if (t) t = !1
				else if (i === 47 && !n) {
					e++
					break
				} else i === 91 ? (n = !0) : i === 92 ? (t = !0) : i === 93 && (n = !1)
				e++
			}
			for (; e < this._input.length && o._regexFlags.has(this._input.charCodeAt(e)); ) e++
			this._current = e
			let r = this._input.substring(this._start, this._current)
			this._tokens.push({ type: 10, lexeme: r, offset: this._start })
		}
		_isAtEnd() {
			return this._current >= this._input.length
		}
	}
var No
;((r) => {
	;(r.serviceIds = new Map()), (r.DI_TARGET = "$di$target"), (r.DI_DEPENDENCIES = "$di$dependencies")
	function n(i) {
		return i[r.DI_DEPENDENCIES] || []
	}
	r.getServiceDependencies = n
})((No ||= {}))
var Uo = O("instantiationService")
function y5(o, e, t) {
	e[No.DI_TARGET] === e
		? e[No.DI_DEPENDENCIES].push({ id: o, index: t })
		: ((e[No.DI_DEPENDENCIES] = [{ id: o, index: t }]), (e[No.DI_TARGET] = e))
}
function O(o) {
	if (No.serviceIds.has(o)) return No.serviceIds.get(o)
	let e = function (t, n, r) {
		if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter")
		y5(e, t, r)
	}
	return (e.toString = () => o), No.serviceIds.set(o, e), e
}
var An = new Map()
An.set("false", !1)
An.set("true", !0)
An.set("isMac", st)
An.set("isLinux", Ve)
An.set("isWindows", Ie)
An.set("isWeb", Ro)
An.set("isMacNative", st && !Ro)
An.set("isEdge", uv)
An.set("isFirefox", aA)
An.set("isChrome", of)
An.set("isSafari", lA)
var I5 = Object.prototype.hasOwnProperty
var x5 = { regexParsingWithErrorRecovery: !0 },
	C5 = p("contextkey.parser.error.emptyString", "Empty context key expression"),
	S5 = p(
		"contextkey.parser.error.emptyString.hint",
		"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.",
	),
	T5 = p("contextkey.parser.error.noInAfterNot", "'in' after 'not'."),
	LO = p("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"),
	E5 = p("contextkey.parser.error.unexpectedToken", "Unexpected token"),
	w5 = p("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"),
	P5 = p("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"),
	_5 = p("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?"),
	Xv = class o {
		constructor(e = x5) {
			this._config = e
			this._scanner = new da()
			this._tokens = []
			this._current = 0
			this._parsingErrors = []
			this._flagsGYRe = /g|y/g
		}
		static {
			this._parseError = new Error()
		}
		get lexingErrors() {
			return this._scanner.errors
		}
		get parsingErrors() {
			return this._parsingErrors
		}
		parse(e) {
			if (e === "") {
				this._parsingErrors.push({ message: C5, offset: 0, lexeme: "", additionalInfo: S5 })
				return
			}
			;(this._tokens = this._scanner.reset(e).scan()), (this._current = 0), (this._parsingErrors = [])
			try {
				let t = this._expr()
				if (!this._isAtEnd()) {
					let n = this._peek(),
						r = n.type === 17 ? w5 : void 0
					throw (
						(this._parsingErrors.push({
							message: E5,
							offset: n.offset,
							lexeme: da.getLexeme(n),
							additionalInfo: r,
						}),
						o._parseError)
					)
				}
				return t
			} catch (t) {
				if (t !== o._parseError) throw t
				return
			}
		}
		_expr() {
			return this._or()
		}
		_or() {
			let e = [this._and()]
			for (; this._matchOne(16); ) {
				let t = this._and()
				e.push(t)
			}
			return e.length === 1 ? e[0] : Lt.or(...e)
		}
		_and() {
			let e = [this._term()]
			for (; this._matchOne(15); ) {
				let t = this._term()
				e.push(t)
			}
			return e.length === 1 ? e[0] : Lt.and(...e)
		}
		_term() {
			if (this._matchOne(2)) {
				let e = this._peek()
				switch (e.type) {
					case 11:
						return this._advance(), Gn.INSTANCE
					case 12:
						return this._advance(), ir.INSTANCE
					case 0: {
						this._advance()
						let t = this._expr()
						return this._consume(1, LO), t?.negate()
					}
					case 17:
						return this._advance(), Wl.create(e.lexeme)
					default:
						throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e)
				}
			}
			return this._primary()
		}
		_primary() {
			let e = this._peek()
			switch (e.type) {
				case 11:
					return this._advance(), Lt.true()
				case 12:
					return this._advance(), Lt.false()
				case 0: {
					this._advance()
					let t = this._expr()
					return this._consume(1, LO), t
				}
				case 17: {
					let t = e.lexeme
					if ((this._advance(), this._matchOne(9))) {
						let r = this._peek()
						if (!this._config.regexParsingWithErrorRecovery) {
							if ((this._advance(), r.type !== 10)) throw this._errExpectedButGot("REGEX", r)
							let i = r.lexeme,
								s = i.lastIndexOf("/"),
								a = s === i.length - 1 ? void 0 : this._removeFlagsGY(i.substring(s + 1)),
								l
							try {
								l = new RegExp(i.substring(1, s), a)
							} catch {
								throw this._errExpectedButGot("REGEX", r)
							}
							return Rf.create(t, l)
						}
						switch (r.type) {
							case 10:
							case 19: {
								let i = [r.lexeme]
								this._advance()
								let s = this._peek(),
									a = 0
								for (let m = 0; m < r.lexeme.length; m++)
									r.lexeme.charCodeAt(m) === 40 ? a++ : r.lexeme.charCodeAt(m) === 41 && a--
								for (; !this._isAtEnd() && s.type !== 15 && s.type !== 16; ) {
									switch (s.type) {
										case 0:
											a++
											break
										case 1:
											a--
											break
										case 10:
										case 18:
											for (let m = 0; m < s.lexeme.length; m++)
												s.lexeme.charCodeAt(m) === 40
													? a++
													: r.lexeme.charCodeAt(m) === 41 && a--
									}
									if (a < 0) break
									i.push(da.getLexeme(s)), this._advance(), (s = this._peek())
								}
								let l = i.join(""),
									d = l.lastIndexOf("/"),
									c = d === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(d + 1)),
									u
								try {
									u = new RegExp(l.substring(1, d), c)
								} catch {
									throw this._errExpectedButGot("REGEX", r)
								}
								return Lt.regex(t, u)
							}
							case 18: {
								let i = r.lexeme
								this._advance()
								let s = null
								if (!Qi(i)) {
									let a = i.indexOf("/"),
										l = i.lastIndexOf("/")
									if (a !== l && a >= 0) {
										let d = i.slice(a + 1, l),
											c = i[l + 1] === "i" ? "i" : ""
										try {
											s = new RegExp(d, c)
										} catch {
											throw this._errExpectedButGot("REGEX", r)
										}
									}
								}
								if (s === null) throw this._errExpectedButGot("REGEX", r)
								return Rf.create(t, s)
							}
							default:
								throw this._errExpectedButGot("REGEX", this._peek())
						}
					}
					if (this._matchOne(14)) {
						this._consume(13, T5)
						let r = this._value()
						return Lt.notIn(t, r)
					}
					switch (this._peek().type) {
						case 3: {
							this._advance()
							let r = this._value()
							if (this._previous().type === 18) return Lt.equals(t, r)
							switch (r) {
								case "true":
									return Lt.has(t)
								case "false":
									return Lt.not(t)
								default:
									return Lt.equals(t, r)
							}
						}
						case 4: {
							this._advance()
							let r = this._value()
							if (this._previous().type === 18) return Lt.notEquals(t, r)
							switch (r) {
								case "true":
									return Lt.not(t)
								case "false":
									return Lt.has(t)
								default:
									return Lt.notEquals(t, r)
							}
						}
						case 5:
							return this._advance(), Df.create(t, this._value())
						case 6:
							return this._advance(), kf.create(t, this._value())
						case 7:
							return this._advance(), Oc.create(t, this._value())
						case 8:
							return this._advance(), _f.create(t, this._value())
						case 13:
							return this._advance(), Lt.in(t, this._value())
						default:
							return Lt.has(t)
					}
				}
				case 20:
					throw (
						(this._parsingErrors.push({ message: P5, offset: e.offset, lexeme: "", additionalInfo: _5 }),
						o._parseError)
					)
				default:
					throw this._errExpectedButGot(
						`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,
						this._peek(),
					)
			}
		}
		_value() {
			let e = this._peek()
			switch (e.type) {
				case 17:
				case 18:
					return this._advance(), e.lexeme
				case 11:
					return this._advance(), "true"
				case 12:
					return this._advance(), "false"
				case 13:
					return this._advance(), "in"
				default:
					return ""
			}
		}
		_removeFlagsGY(e) {
			return e.replaceAll(this._flagsGYRe, "")
		}
		_previous() {
			return this._tokens[this._current - 1]
		}
		_matchOne(e) {
			return this._check(e) ? (this._advance(), !0) : !1
		}
		_advance() {
			return this._isAtEnd() || this._current++, this._previous()
		}
		_consume(e, t) {
			if (this._check(e)) return this._advance()
			throw this._errExpectedButGot(t, this._peek())
		}
		_errExpectedButGot(e, t, n) {
			let r = p(
					"contextkey.parser.error.expectedButGot",
					`Expected: {0}
Received: '{1}'.`,
					e,
					da.getLexeme(t),
				),
				i = t.offset,
				s = da.getLexeme(t)
			return this._parsingErrors.push({ message: r, offset: i, lexeme: s, additionalInfo: n }), o._parseError
		}
		_check(e) {
			return this._peek().type === e
		}
		_peek() {
			return this._tokens[this._current]
		}
		_isAtEnd() {
			return this._peek().type === 20
		}
	},
	Lt = class {
		static false() {
			return Gn.INSTANCE
		}
		static true() {
			return ir.INSTANCE
		}
		static has(e) {
			return Hl.create(e)
		}
		static equals(e, t) {
			return wf.create(e, t)
		}
		static notEquals(e, t) {
			return Pf.create(e, t)
		}
		static regex(e, t) {
			return Rf.create(e, t)
		}
		static in(e, t) {
			return Yv.create(e, t)
		}
		static notIn(e, t) {
			return Zv.create(e, t)
		}
		static not(e) {
			return Wl.create(e)
		}
		static and(...e) {
			return eb.create(e, null, !0)
		}
		static or(...e) {
			return Af.create(e, null, !0)
		}
		static greater(e, t) {
			return Oc.create(e, t)
		}
		static greaterEquals(e, t) {
			return _f.create(e, t)
		}
		static smaller(e, t) {
			return Df.create(e, t)
		}
		static smallerEquals(e, t) {
			return kf.create(e, t)
		}
		static {
			this._parser = new Xv({ regexParsingWithErrorRecovery: !1 })
		}
		static deserialize(e) {
			return e == null ? void 0 : this._parser.parse(e)
		}
	}
function FO(o) {
	let e = new Xv({ regexParsingWithErrorRecovery: !1 })
	return o.map(
		(t) => (
			e.parse(t),
			e.lexingErrors.length > 0
				? e.lexingErrors.map((n) => ({
						errorMessage: n.additionalInfo
							? p(
									"contextkey.scanner.errorForLinterWithHint",
									"Unexpected token. Hint: {0}",
									n.additionalInfo,
								)
							: p("contextkey.scanner.errorForLinter", "Unexpected token."),
						offset: n.offset,
						length: n.lexeme.length,
					}))
				: e.parsingErrors.length > 0
					? e.parsingErrors.map((n) => ({
							errorMessage: n.additionalInfo ? `${n.message}. ${n.additionalInfo}` : n.message,
							offset: n.offset,
							length: n.lexeme.length,
						}))
					: []
		),
	)
}
function Ef(o, e) {
	return o.cmp(e)
}
var Gn = class o {
		constructor() {
			this.type = 0
		}
		static {
			this.INSTANCE = new o()
		}
		cmp(e) {
			return this.type - e.type
		}
		equals(e) {
			return e.type === this.type
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !1
		}
		serialize() {
			return "false"
		}
		keys() {
			return []
		}
		map(e) {
			return this
		}
		negate() {
			return ir.INSTANCE
		}
	},
	ir = class o {
		constructor() {
			this.type = 1
		}
		static {
			this.INSTANCE = new o()
		}
		cmp(e) {
			return this.type - e.type
		}
		equals(e) {
			return e.type === this.type
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !0
		}
		serialize() {
			return "true"
		}
		keys() {
			return []
		}
		map(e) {
			return this
		}
		negate() {
			return Gn.INSTANCE
		}
	},
	Hl = class o {
		constructor(e, t) {
			this.key = e
			this.negated = t
			this.type = 2
		}
		static create(e, t = null) {
			let n = An.get(e)
			return typeof n == "boolean" ? (n ? ir.INSTANCE : Gn.INSTANCE) : new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : UO(this.key, e.key)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key : !1
		}
		substituteConstants() {
			let e = An.get(this.key)
			return typeof e == "boolean" ? (e ? ir.INSTANCE : Gn.INSTANCE) : this
		}
		evaluate(e) {
			return !!e.getValue(this.key)
		}
		serialize() {
			return this.key
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapDefined(this.key)
		}
		negate() {
			return this.negated || (this.negated = Wl.create(this.key, this)), this.negated
		}
	},
	wf = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 4
		}
		static create(e, t, n = null) {
			if (typeof t == "boolean") return t ? Hl.create(e, n) : Wl.create(e, n)
			let r = An.get(e)
			return typeof r == "boolean" ? (t === (r ? "true" : "false") ? ir.INSTANCE : Gn.INSTANCE) : new o(e, t, n)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			let e = An.get(this.key)
			if (typeof e == "boolean") {
				let t = e ? "true" : "false"
				return this.value === t ? ir.INSTANCE : Gn.INSTANCE
			}
			return this
		}
		evaluate(e) {
			return e.getValue(this.key) == this.value
		}
		serialize() {
			return `${this.key} == '${this.value}'`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Pf.create(this.key, this.value, this)), this.negated
		}
	},
	Yv = class o {
		constructor(e, t) {
			this.key = e
			this.valueKey = t
			this.type = 10
			this.negated = null
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.valueKey, e.key, e.valueKey)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			let t = e.getValue(this.valueKey),
				n = e.getValue(this.key)
			return Array.isArray(t)
				? t.includes(n)
				: typeof n == "string" && typeof t == "object" && t !== null
					? I5.call(t, n)
					: !1
		}
		serialize() {
			return `${this.key} in '${this.valueKey}'`
		}
		keys() {
			return [this.key, this.valueKey]
		}
		map(e) {
			return e.mapIn(this.key, this.valueKey)
		}
		negate() {
			return this.negated || (this.negated = Zv.create(this.key, this.valueKey)), this.negated
		}
	},
	Zv = class o {
		constructor(e, t) {
			this.key = e
			this.valueKey = t
			this.type = 11
			this._negated = Yv.create(e, t)
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated)
		}
		equals(e) {
			return e.type === this.type ? this._negated.equals(e._negated) : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !this._negated.evaluate(e)
		}
		serialize() {
			return `${this.key} not in '${this.valueKey}'`
		}
		keys() {
			return this._negated.keys()
		}
		map(e) {
			return e.mapNotIn(this.key, this.valueKey)
		}
		negate() {
			return this._negated
		}
	},
	Pf = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 5
		}
		static create(e, t, n = null) {
			if (typeof t == "boolean") return t ? Wl.create(e, n) : Hl.create(e, n)
			let r = An.get(e)
			return typeof r == "boolean" ? (t === (r ? "true" : "false") ? Gn.INSTANCE : ir.INSTANCE) : new o(e, t, n)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			let e = An.get(this.key)
			if (typeof e == "boolean") {
				let t = e ? "true" : "false"
				return this.value === t ? Gn.INSTANCE : ir.INSTANCE
			}
			return this
		}
		evaluate(e) {
			return e.getValue(this.key) != this.value
		}
		serialize() {
			return `${this.key} != '${this.value}'`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapNotEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = wf.create(this.key, this.value, this)), this.negated
		}
	},
	Wl = class o {
		constructor(e, t) {
			this.key = e
			this.negated = t
			this.type = 3
		}
		static create(e, t = null) {
			let n = An.get(e)
			return typeof n == "boolean" ? (n ? Gn.INSTANCE : ir.INSTANCE) : new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : UO(this.key, e.key)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key : !1
		}
		substituteConstants() {
			let e = An.get(this.key)
			return typeof e == "boolean" ? (e ? Gn.INSTANCE : ir.INSTANCE) : this
		}
		evaluate(e) {
			return !e.getValue(this.key)
		}
		serialize() {
			return `!${this.key}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapNot(this.key)
		}
		negate() {
			return this.negated || (this.negated = Hl.create(this.key, this)), this.negated
		}
	}
function tb(o, e) {
	if (typeof o == "string") {
		let t = parseFloat(o)
		isNaN(t) || (o = t)
	}
	return typeof o == "string" || typeof o == "number" ? e(o) : Gn.INSTANCE
}
var Oc = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 12
		}
		static create(e, t, n = null) {
			return tb(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value
		}
		serialize() {
			return `${this.key} > ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapGreater(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = kf.create(this.key, this.value, this)), this.negated
		}
	},
	_f = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 13
		}
		static create(e, t, n = null) {
			return tb(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value
		}
		serialize() {
			return `${this.key} >= ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapGreaterEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Df.create(this.key, this.value, this)), this.negated
		}
	},
	Df = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 14
		}
		static create(e, t, n = null) {
			return tb(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value
		}
		serialize() {
			return `${this.key} < ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapSmaller(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = _f.create(this.key, this.value, this)), this.negated
		}
	},
	kf = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 15
		}
		static create(e, t, n = null) {
			return tb(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Vl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value
		}
		serialize() {
			return `${this.key} <= ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapSmallerEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Oc.create(this.key, this.value, this)), this.negated
		}
	},
	Rf = class o {
		constructor(e, t) {
			this.key = e
			this.regexp = t
			this.type = 7
			this.negated = null
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.key < e.key) return -1
			if (this.key > e.key) return 1
			let t = this.regexp ? this.regexp.source : "",
				n = e.regexp ? e.regexp.source : ""
			return t < n ? -1 : t > n ? 1 : 0
		}
		equals(e) {
			if (e.type === this.type) {
				let t = this.regexp ? this.regexp.source : "",
					n = e.regexp ? e.regexp.source : ""
				return this.key === e.key && t === n
			}
			return !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			let t = e.getValue(this.key)
			return this.regexp ? this.regexp.test(t) : !1
		}
		serialize() {
			let e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/"
			return `${this.key} =~ ${e}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapRegex(this.key, this.regexp)
		}
		negate() {
			return this.negated || (this.negated = uw.create(this)), this.negated
		}
	},
	uw = class o {
		constructor(e) {
			this._actual = e
			this.type = 8
		}
		static create(e) {
			return new o(e)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual)
		}
		equals(e) {
			return e.type === this.type ? this._actual.equals(e._actual) : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !this._actual.evaluate(e)
		}
		serialize() {
			return `!(${this._actual.serialize()})`
		}
		keys() {
			return this._actual.keys()
		}
		map(e) {
			return new o(this._actual.map(e))
		}
		negate() {
			return this._actual
		}
	}
function NO(o) {
	let e = null
	for (let t = 0, n = o.length; t < n; t++) {
		let r = o[t].substituteConstants()
		if (o[t] !== r && e === null) {
			e = []
			for (let i = 0; i < t; i++) e[i] = o[i]
		}
		e !== null && (e[t] = r)
	}
	return e === null ? o : e
}
var eb = class o {
		constructor(e, t) {
			this.expr = e
			this.negated = t
			this.type = 6
		}
		static create(e, t, n) {
			return o._normalizeArr(e, t, n)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.expr.length < e.expr.length) return -1
			if (this.expr.length > e.expr.length) return 1
			for (let t = 0, n = this.expr.length; t < n; t++) {
				let r = Ef(this.expr[t], e.expr[t])
				if (r !== 0) return r
			}
			return 0
		}
		equals(e) {
			if (e.type === this.type) {
				if (this.expr.length !== e.expr.length) return !1
				for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].equals(e.expr[t])) return !1
				return !0
			}
			return !1
		}
		substituteConstants() {
			let e = NO(this.expr)
			return e === this.expr ? this : o.create(e, this.negated, !1)
		}
		evaluate(e) {
			for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].evaluate(e)) return !1
			return !0
		}
		static _normalizeArr(e, t, n) {
			let r = [],
				i = !1
			for (let s of e)
				if (s) {
					if (s.type === 1) {
						i = !0
						continue
					}
					if (s.type === 0) return Gn.INSTANCE
					if (s.type === 6) {
						r.push(...s.expr)
						continue
					}
					r.push(s)
				}
			if (r.length === 0 && i) return ir.INSTANCE
			if (r.length !== 0) {
				if (r.length === 1) return r[0]
				r.sort(Ef)
				for (let s = 1; s < r.length; s++) r[s - 1].equals(r[s]) && (r.splice(s, 1), s--)
				if (r.length === 1) return r[0]
				for (; r.length > 1; ) {
					let s = r[r.length - 1]
					if (s.type !== 9) break
					r.pop()
					let a = r.pop(),
						l = r.length === 0,
						d = Af.create(
							s.expr.map((c) => o.create([c, a], null, n)),
							null,
							l,
						)
					d && (r.push(d), r.sort(Ef))
				}
				if (r.length === 1) return r[0]
				if (n) {
					for (let s = 0; s < r.length; s++)
						for (let a = s + 1; a < r.length; a++) if (r[s].negate().equals(r[a])) return Gn.INSTANCE
					if (r.length === 1) return r[0]
				}
				return new o(r, t)
			}
		}
		serialize() {
			return this.expr.map((e) => e.serialize()).join(" && ")
		}
		keys() {
			let e = []
			for (let t of this.expr) e.push(...t.keys())
			return e
		}
		map(e) {
			return new o(
				this.expr.map((t) => t.map(e)),
				null,
			)
		}
		negate() {
			if (!this.negated) {
				let e = []
				for (let t of this.expr) e.push(t.negate())
				this.negated = Af.create(e, this, !0)
			}
			return this.negated
		}
	},
	Af = class o {
		constructor(e, t) {
			this.expr = e
			this.negated = t
			this.type = 9
		}
		static create(e, t, n) {
			return o._normalizeArr(e, t, n)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.expr.length < e.expr.length) return -1
			if (this.expr.length > e.expr.length) return 1
			for (let t = 0, n = this.expr.length; t < n; t++) {
				let r = Ef(this.expr[t], e.expr[t])
				if (r !== 0) return r
			}
			return 0
		}
		equals(e) {
			if (e.type === this.type) {
				if (this.expr.length !== e.expr.length) return !1
				for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].equals(e.expr[t])) return !1
				return !0
			}
			return !1
		}
		substituteConstants() {
			let e = NO(this.expr)
			return e === this.expr ? this : o.create(e, this.negated, !1)
		}
		evaluate(e) {
			for (let t = 0, n = this.expr.length; t < n; t++) if (this.expr[t].evaluate(e)) return !0
			return !1
		}
		static _normalizeArr(e, t, n) {
			let r = [],
				i = !1
			if (e) {
				for (let s = 0, a = e.length; s < a; s++) {
					let l = e[s]
					if (l) {
						if (l.type === 0) {
							i = !0
							continue
						}
						if (l.type === 1) return ir.INSTANCE
						if (l.type === 9) {
							r = r.concat(l.expr)
							continue
						}
						r.push(l)
					}
				}
				if (r.length === 0 && i) return Gn.INSTANCE
				r.sort(Ef)
			}
			if (r.length !== 0) {
				if (r.length === 1) return r[0]
				for (let s = 1; s < r.length; s++) r[s - 1].equals(r[s]) && (r.splice(s, 1), s--)
				if (r.length === 1) return r[0]
				if (n) {
					for (let s = 0; s < r.length; s++)
						for (let a = s + 1; a < r.length; a++) if (r[s].negate().equals(r[a])) return ir.INSTANCE
					if (r.length === 1) return r[0]
				}
				return new o(r, t)
			}
		}
		serialize() {
			return this.expr.map((e) => e.serialize()).join(" || ")
		}
		keys() {
			let e = []
			for (let t of this.expr) e.push(...t.keys())
			return e
		}
		map(e) {
			return new o(
				this.expr.map((t) => t.map(e)),
				null,
			)
		}
		negate() {
			if (!this.negated) {
				let e = []
				for (let t of this.expr) e.push(t.negate())
				for (; e.length > 1; ) {
					let t = e.shift(),
						n = e.shift(),
						r = []
					for (let i of MO(t)) for (let s of MO(n)) r.push(eb.create([i, s], null, !1))
					e.unshift(o.create(r, null, !1))
				}
				this.negated = o.create(e, this, !0)
			}
			return this.negated
		}
	},
	D = class o extends Hl {
		static {
			this._info = []
		}
		static all() {
			return o._info.values()
		}
		constructor(e, t, n) {
			super(e, null),
				(this._defaultValue = t),
				typeof n == "object"
					? o._info.push({ ...n, key: e })
					: n !== !0 && o._info.push({ key: e, description: n, type: t != null ? typeof t : void 0 })
		}
		bindTo(e) {
			return e.createKey(this.key, this._defaultValue)
		}
		getValue(e) {
			return e.getContextKeyValue(this.key)
		}
		toNegated() {
			return this.negate()
		}
		isEqualTo(e) {
			return wf.create(this.key, e)
		}
		notEqualsTo(e) {
			return Pf.create(this.key, e)
		}
		greater(e) {
			return Oc.create(this.key, e)
		}
	},
	ca = O("contextKeyService")
function UO(o, e) {
	return o < e ? -1 : o > e ? 1 : 0
}
function Vl(o, e, t, n) {
	return o < t ? -1 : o > t ? 1 : e < n ? -1 : e > n ? 1 : 0
}
function MO(o) {
	return o.type === 9 ? o.expr : [o]
}
var jK = O("accessibilityService")
var GK = new D("accessibilityModeEnabled", !1)
var Ar,
	pw = globalThis.vscode
if (typeof pw < "u" && typeof pw.context < "u") {
	let o = pw.context.configuration()
	if (o) Ar = o.product
	else throw new Error("Sandbox: unable to resolve product configuration from preload script.")
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
	if (
		((Ar = globalThis._VSCODE_PRODUCT_JSON),
		Er.VSCODE_DEV &&
			Object.assign(Ar, {
				nameShort: `${Ar.nameShort} Dev`,
				nameLong: `${Ar.nameLong} Dev`,
				dataFolderName: `${Ar.dataFolderName}-dev`,
				serverDataFolderName: Ar.serverDataFolderName ? `${Ar.serverDataFolderName}-dev` : void 0,
			}),
		!Ar.version)
	) {
		let o = globalThis._VSCODE_PACKAGE_JSON
		Object.assign(Ar, { version: o.version })
	}
} else
	(Ar = {}),
		Object.keys(Ar).length === 0 &&
			Object.assign(Ar, {
				version: "1.95.0-dev",
				nameShort: "Code - OSS Dev",
				nameLong: "Code - OSS Dev",
				applicationName: "code-oss",
				dataFolderName: ".vscode-oss",
				urlProtocol: "code-oss",
				reportIssueUrl: "https://github.com/microsoft/vscode/issues/new",
				licenseName: "MIT",
				licenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
				serverLicenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
			})
var nb = Ar
var D5 = 8
var mw = class {
		constructor() {
			;(this.stableMinimapLayoutInput = null),
				(this.stableFitMaxMinimapScale = 0),
				(this.stableFitRemainingWidth = 0)
		}
	},
	pt = class {
		constructor(e, t, n, r) {
			;(this.id = e), (this.name = t), (this.defaultValue = n), (this.schema = r)
		}
		applyUpdate(e, t) {
			return rb(e, t)
		}
		compute(e, t, n) {
			return n
		}
	},
	Lc = class {
		constructor(e, t) {
			this.newValue = e
			this.didChange = t
		}
	}
function rb(o, e) {
	if (typeof o != "object" || typeof e != "object" || !o || !e) return new Lc(e, o !== e)
	if (Array.isArray(o) || Array.isArray(e)) {
		let n = Array.isArray(o) && Array.isArray(e) && mn(o, e)
		return new Lc(e, !n)
	}
	let t = !1
	for (let n in e)
		if (e.hasOwnProperty(n)) {
			let r = rb(o[n], e[n])
			r.didChange && ((o[n] = r.newValue), (t = !0))
		}
	return new Lc(o, t)
}
var os = class {
		constructor(e) {
			this.schema = void 0
			;(this.id = e), (this.name = "_never_"), (this.defaultValue = void 0)
		}
		applyUpdate(e, t) {
			return rb(e, t)
		}
		validate(e) {
			return this.defaultValue
		}
	},
	ua = class {
		constructor(e, t, n, r) {
			;(this.id = e), (this.name = t), (this.defaultValue = n), (this.schema = r)
		}
		applyUpdate(e, t) {
			return rb(e, t)
		}
		validate(e) {
			return typeof e > "u" ? this.defaultValue : e
		}
		compute(e, t, n) {
			return n
		}
	}
function re(o, e) {
	return typeof o > "u" ? e : o === "false" ? !1 : !!o
}
var Le = class extends ua {
	constructor(e, t, n, r = void 0) {
		typeof r < "u" && ((r.type = "boolean"), (r.default = n)), super(e, t, n, r)
	}
	validate(e) {
		return re(e, this.defaultValue)
	}
}
function k5(o, e, t, n) {
	if (typeof o > "u") return e
	let r = parseInt(o, 10)
	return isNaN(r) ? e : ((r = Math.max(t, r)), (r = Math.min(n, r)), r | 0)
}
var tt = class o extends ua {
	static clampedInt(e, t, n, r) {
		return k5(e, t, n, r)
	}
	constructor(e, t, n, r, i, s = void 0) {
		typeof s < "u" && ((s.type = "integer"), (s.default = n), (s.minimum = r), (s.maximum = i)),
			super(e, t, n, s),
			(this.minimum = r),
			(this.maximum = i)
	}
	validate(e) {
		return o.clampedInt(e, this.defaultValue, this.minimum, this.maximum)
	}
}
var lo = class o extends ua {
		static clamp(e, t, n) {
			return e < t ? t : e > n ? n : e
		}
		static float(e, t) {
			if (typeof e == "number") return e
			if (typeof e > "u") return t
			let n = parseFloat(e)
			return isNaN(n) ? t : n
		}
		constructor(e, t, n, r, i) {
			typeof i < "u" && ((i.type = "number"), (i.default = n)), super(e, t, n, i), (this.validationFn = r)
		}
		validate(e) {
			return this.validationFn(o.float(e, this.defaultValue))
		}
	},
	Qn = class o extends ua {
		static string(e, t) {
			return typeof e != "string" ? t : e
		}
		constructor(e, t, n, r = void 0) {
			typeof r < "u" && ((r.type = "string"), (r.default = n)), super(e, t, n, r)
		}
		validate(e) {
			return o.string(e, this.defaultValue)
		}
	}
function St(o, e, t, n) {
	return typeof o != "string" ? e : n && o in n ? n[o] : t.indexOf(o) === -1 ? e : o
}
var ht = class extends ua {
		constructor(e, t, n, r, i = void 0) {
			typeof i < "u" && ((i.type = "string"), (i.enum = r), (i.default = n)),
				super(e, t, n, i),
				(this._allowedValues = r)
		}
		validate(e) {
			return St(e, this.defaultValue, this._allowedValues)
		}
	},
	$l = class extends pt {
		constructor(e, t, n, r, i, s, a = void 0) {
			typeof a < "u" && ((a.type = "string"), (a.enum = i), (a.default = r)),
				super(e, t, n, a),
				(this._allowedValues = i),
				(this._convert = s)
		}
		validate(e) {
			return typeof e != "string"
				? this.defaultValue
				: this._allowedValues.indexOf(e) === -1
					? this.defaultValue
					: this._convert(e)
		}
	}
function R5(o) {
	switch (o) {
		case "none":
			return 0
		case "keep":
			return 1
		case "brackets":
			return 2
		case "advanced":
			return 3
		case "full":
			return 4
	}
}
var fw = class extends pt {
		constructor() {
			super(2, "accessibilitySupport", 0, {
				type: "string",
				enum: ["auto", "on", "off"],
				enumDescriptions: [
					p("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
					p("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
					p("accessibilitySupport.off", "Assume a screen reader is not attached."),
				],
				default: "auto",
				tags: ["accessibility"],
				description: p(
					"accessibilitySupport",
					"Controls if the UI should run in a mode where it is optimized for screen readers.",
				),
			})
		}
		validate(e) {
			switch (e) {
				case "auto":
					return 0
				case "off":
					return 1
				case "on":
					return 2
			}
			return this.defaultValue
		}
		compute(e, t, n) {
			return n === 0 ? e.accessibilitySupport : n
		}
	},
	gw = class extends pt {
		constructor() {
			let e = { insertSpace: !0, ignoreEmptyLines: !0 }
			super(23, "comments", e, {
				"editor.comments.insertSpace": {
					type: "boolean",
					default: e.insertSpace,
					description: p(
						"comments.insertSpace",
						"Controls whether a space character is inserted when commenting.",
					),
				},
				"editor.comments.ignoreEmptyLines": {
					type: "boolean",
					default: e.ignoreEmptyLines,
					description: p(
						"comments.ignoreEmptyLines",
						"Controls if empty lines should be ignored with toggle, add or remove actions for line comments.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				insertSpace: re(t.insertSpace, this.defaultValue.insertSpace),
				ignoreEmptyLines: re(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),
			}
		}
	}
function A5(o) {
	switch (o) {
		case "blink":
			return 1
		case "smooth":
			return 2
		case "phase":
			return 3
		case "expand":
			return 4
		case "solid":
			return 5
	}
}
var nP = ((s) => (
	(s[(s.Line = 1)] = "Line"),
	(s[(s.Block = 2)] = "Block"),
	(s[(s.Underline = 3)] = "Underline"),
	(s[(s.LineThin = 4)] = "LineThin"),
	(s[(s.BlockOutline = 5)] = "BlockOutline"),
	(s[(s.UnderlineThin = 6)] = "UnderlineThin"),
	s
))(nP || {})
function HO(o) {
	switch (o) {
		case "line":
			return 1
		case "block":
			return 2
		case "underline":
			return 3
		case "line-thin":
			return 4
		case "block-outline":
			return 5
		case "underline-thin":
			return 6
	}
}
var hw = class extends os {
		constructor() {
			super(148)
		}
		compute(e, t, n) {
			let r = ["monaco-editor"]
			return (
				t.get(41) && r.push(t.get(41)),
				e.extraEditorClassName && r.push(e.extraEditorClassName),
				t.get(75) === "default" ? r.push("mouse-default") : t.get(75) === "copy" && r.push("mouse-copy"),
				t.get(116) && r.push("showUnused"),
				t.get(145) && r.push("showDeprecated"),
				r.join(" ")
			)
		}
	},
	vw = class extends Le {
		constructor() {
			super(38, "emptySelectionClipboard", !0, {
				description: p(
					"emptySelectionClipboard",
					"Controls whether copying without a selection copies the current line.",
				),
			})
		}
		compute(e, t, n) {
			return n && e.emptySelectionClipboard
		}
	},
	bw = class extends pt {
		constructor() {
			let e = {
				cursorMoveOnType: !0,
				seedSearchStringFromSelection: "always",
				autoFindInSelection: "never",
				globalFindClipboard: !1,
				addExtraSpaceOnTop: !0,
				loop: !0,
				history: "workspace",
				replaceHistory: "workspace",
			}
			super(43, "find", e, {
				"editor.find.cursorMoveOnType": {
					type: "boolean",
					default: e.cursorMoveOnType,
					description: p(
						"find.cursorMoveOnType",
						"Controls whether the cursor should jump to find matches while typing.",
					),
				},
				"editor.find.seedSearchStringFromSelection": {
					type: "string",
					enum: ["never", "always", "selection"],
					default: e.seedSearchStringFromSelection,
					enumDescriptions: [
						p(
							"editor.find.seedSearchStringFromSelection.never",
							"Never seed search string from the editor selection.",
						),
						p(
							"editor.find.seedSearchStringFromSelection.always",
							"Always seed search string from the editor selection, including word at cursor position.",
						),
						p(
							"editor.find.seedSearchStringFromSelection.selection",
							"Only seed search string from the editor selection.",
						),
					],
					description: p(
						"find.seedSearchStringFromSelection",
						"Controls whether the search string in the Find Widget is seeded from the editor selection.",
					),
				},
				"editor.find.autoFindInSelection": {
					type: "string",
					enum: ["never", "always", "multiline"],
					default: e.autoFindInSelection,
					enumDescriptions: [
						p(
							"editor.find.autoFindInSelection.never",
							"Never turn on Find in Selection automatically (default).",
						),
						p("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
						p(
							"editor.find.autoFindInSelection.multiline",
							"Turn on Find in Selection automatically when multiple lines of content are selected.",
						),
					],
					description: p(
						"find.autoFindInSelection",
						"Controls the condition for turning on Find in Selection automatically.",
					),
				},
				"editor.find.globalFindClipboard": {
					type: "boolean",
					default: e.globalFindClipboard,
					description: p(
						"find.globalFindClipboard",
						"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.",
					),
					included: st,
				},
				"editor.find.addExtraSpaceOnTop": {
					type: "boolean",
					default: e.addExtraSpaceOnTop,
					description: p(
						"find.addExtraSpaceOnTop",
						"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.",
					),
				},
				"editor.find.loop": {
					type: "boolean",
					default: e.loop,
					description: p(
						"find.loop",
						"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.",
					),
				},
				"editor.find.history": {
					type: "string",
					enum: ["never", "workspace"],
					default: "workspace",
					enumDescriptions: [
						p("editor.find.history.never", "Do not store search history from the find widget."),
						p("editor.find.history.workspace", "Store search history across the active workspace"),
					],
					description: p("find.history", "Controls how the find widget history should be stored"),
				},
				"editor.find.replaceHistory": {
					type: "string",
					enum: ["never", "workspace"],
					default: "workspace",
					enumDescriptions: [
						p("editor.find.replaceHistory.never", "Do not store history from the replace widget."),
						p("editor.find.replaceHistory.workspace", "Store replace history across the active workspace"),
					],
					description: p("find.replaceHistory", "Controls how the replace widget history should be stored"),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				cursorMoveOnType: re(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
				seedSearchStringFromSelection:
					typeof e.seedSearchStringFromSelection == "boolean"
						? e.seedSearchStringFromSelection
							? "always"
							: "never"
						: St(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, [
								"never",
								"always",
								"selection",
							]),
				autoFindInSelection:
					typeof e.autoFindInSelection == "boolean"
						? e.autoFindInSelection
							? "always"
							: "never"
						: St(t.autoFindInSelection, this.defaultValue.autoFindInSelection, [
								"never",
								"always",
								"multiline",
							]),
				globalFindClipboard: re(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
				addExtraSpaceOnTop: re(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
				loop: re(t.loop, this.defaultValue.loop),
				history: St(t.history, this.defaultValue.history, ["never", "workspace"]),
				replaceHistory: St(t.replaceHistory, this.defaultValue.replaceHistory, ["never", "workspace"]),
			}
		}
	},
	yw = class o extends pt {
		static {
			this.OFF = '"liga" off, "calt" off'
		}
		static {
			this.ON = '"liga" on, "calt" on'
		}
		constructor() {
			super(53, "fontLigatures", o.OFF, {
				anyOf: [
					{
						type: "boolean",
						description: p(
							"fontLigatures",
							"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.",
						),
					},
					{
						type: "string",
						description: p(
							"fontFeatureSettings",
							"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.",
						),
					},
				],
				description: p(
					"fontLigaturesGeneral",
					"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.",
				),
				default: !1,
			})
		}
		validate(e) {
			return typeof e > "u"
				? this.defaultValue
				: typeof e == "string"
					? e === "false" || e.length === 0
						? o.OFF
						: e === "true"
							? o.ON
							: e
					: e
						? o.ON
						: o.OFF
		}
	},
	Iw = class o extends pt {
		static {
			this.OFF = "normal"
		}
		static {
			this.TRANSLATE = "translate"
		}
		constructor() {
			super(56, "fontVariations", o.OFF, {
				anyOf: [
					{
						type: "boolean",
						description: p(
							"fontVariations",
							"Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.",
						),
					},
					{
						type: "string",
						description: p(
							"fontVariationSettings",
							"Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.",
						),
					},
				],
				description: p(
					"fontVariationsGeneral",
					"Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property.",
				),
				default: !1,
			})
		}
		validate(e) {
			return typeof e > "u"
				? this.defaultValue
				: typeof e == "string"
					? e === "false"
						? o.OFF
						: e === "true"
							? o.TRANSLATE
							: e
					: e
						? o.TRANSLATE
						: o.OFF
		}
		compute(e, t, n) {
			return e.fontInfo.fontVariationSettings
		}
	},
	xw = class extends os {
		constructor() {
			super(52)
		}
		compute(e, t, n) {
			return e.fontInfo
		}
	},
	Cw = class extends os {
		constructor() {
			super(147)
		}
		compute(e, t, n) {
			return e.inputMode === "overtype" ? t.get(84) : t.get(28)
		}
	},
	Sw = class extends os {
		constructor() {
			super(156)
		}
		compute(e, t) {
			return e.editContextSupported && t.get(37)
		}
	},
	Tw = class extends ua {
		constructor() {
			super(54, "fontSize", rs.fontSize, {
				type: "number",
				minimum: 6,
				maximum: 100,
				default: rs.fontSize,
				description: p("fontSize", "Controls the font size in pixels."),
			})
		}
		validate(e) {
			let t = lo.float(e, this.defaultValue)
			return t === 0 ? rs.fontSize : lo.clamp(t, 6, 100)
		}
		compute(e, t, n) {
			return e.fontInfo.fontSize
		}
	},
	Ew = class o extends pt {
		static {
			this.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
		}
		static {
			this.MINIMUM_VALUE = 1
		}
		static {
			this.MAXIMUM_VALUE = 1e3
		}
		constructor() {
			super(55, "fontWeight", rs.fontWeight, {
				anyOf: [
					{
						type: "number",
						minimum: o.MINIMUM_VALUE,
						maximum: o.MAXIMUM_VALUE,
						errorMessage: p(
							"fontWeightErrorMessage",
							'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.',
						),
					},
					{ type: "string", pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$" },
					{ enum: o.SUGGESTION_VALUES },
				],
				default: rs.fontWeight,
				description: p(
					"fontWeight",
					'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.',
				),
			})
		}
		validate(e) {
			return e === "normal" || e === "bold"
				? e
				: String(tt.clampedInt(e, rs.fontWeight, o.MINIMUM_VALUE, o.MAXIMUM_VALUE))
		}
	},
	ww = class extends pt {
		constructor() {
			let e = {
					multiple: "peek",
					multipleDefinitions: "peek",
					multipleTypeDefinitions: "peek",
					multipleDeclarations: "peek",
					multipleImplementations: "peek",
					multipleReferences: "peek",
					multipleTests: "peek",
					alternativeDefinitionCommand: "editor.action.goToReferences",
					alternativeTypeDefinitionCommand: "editor.action.goToReferences",
					alternativeDeclarationCommand: "editor.action.goToReferences",
					alternativeImplementationCommand: "",
					alternativeReferenceCommand: "",
					alternativeTestsCommand: "",
				},
				t = {
					type: "string",
					enum: ["peek", "gotoAndPeek", "goto"],
					default: e.multiple,
					enumDescriptions: [
						p("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
						p("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
						p(
							"editor.gotoLocation.multiple.goto",
							"Go to the primary result and enable Peek-less navigation to others",
						),
					],
				},
				n = [
					"",
					"editor.action.referenceSearch.trigger",
					"editor.action.goToReferences",
					"editor.action.peekImplementation",
					"editor.action.goToImplementation",
					"editor.action.peekTypeDefinition",
					"editor.action.goToTypeDefinition",
					"editor.action.peekDeclaration",
					"editor.action.revealDeclaration",
					"editor.action.peekDefinition",
					"editor.action.revealDefinitionAside",
					"editor.action.revealDefinition",
				]
			super(60, "gotoLocation", e, {
				"editor.gotoLocation.multiple": {
					deprecationMessage: p(
						"editor.gotoLocation.multiple.deprecated",
						"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.",
					),
				},
				"editor.gotoLocation.multipleDefinitions": {
					description: p(
						"editor.editor.gotoLocation.multipleDefinitions",
						"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleTypeDefinitions": {
					description: p(
						"editor.editor.gotoLocation.multipleTypeDefinitions",
						"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleDeclarations": {
					description: p(
						"editor.editor.gotoLocation.multipleDeclarations",
						"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleImplementations": {
					description: p(
						"editor.editor.gotoLocation.multipleImplemenattions",
						"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleReferences": {
					description: p(
						"editor.editor.gotoLocation.multipleReferences",
						"Controls the behavior the 'Go to References'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.alternativeDefinitionCommand": {
					type: "string",
					default: e.alternativeDefinitionCommand,
					enum: n,
					description: p(
						"alternativeDefinitionCommand",
						"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeTypeDefinitionCommand": {
					type: "string",
					default: e.alternativeTypeDefinitionCommand,
					enum: n,
					description: p(
						"alternativeTypeDefinitionCommand",
						"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeDeclarationCommand": {
					type: "string",
					default: e.alternativeDeclarationCommand,
					enum: n,
					description: p(
						"alternativeDeclarationCommand",
						"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeImplementationCommand": {
					type: "string",
					default: e.alternativeImplementationCommand,
					enum: n,
					description: p(
						"alternativeImplementationCommand",
						"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeReferenceCommand": {
					type: "string",
					default: e.alternativeReferenceCommand,
					enum: n,
					description: p(
						"alternativeReferenceCommand",
						"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				multiple: St(t.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
				multipleDefinitions:
					t.multipleDefinitions ?? St(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleTypeDefinitions:
					t.multipleTypeDefinitions ?? St(t.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleDeclarations:
					t.multipleDeclarations ?? St(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleImplementations:
					t.multipleImplementations ?? St(t.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleReferences:
					t.multipleReferences ?? St(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleTests: t.multipleTests ?? St(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
				alternativeDefinitionCommand: Qn.string(
					t.alternativeDefinitionCommand,
					this.defaultValue.alternativeDefinitionCommand,
				),
				alternativeTypeDefinitionCommand: Qn.string(
					t.alternativeTypeDefinitionCommand,
					this.defaultValue.alternativeTypeDefinitionCommand,
				),
				alternativeDeclarationCommand: Qn.string(
					t.alternativeDeclarationCommand,
					this.defaultValue.alternativeDeclarationCommand,
				),
				alternativeImplementationCommand: Qn.string(
					t.alternativeImplementationCommand,
					this.defaultValue.alternativeImplementationCommand,
				),
				alternativeReferenceCommand: Qn.string(
					t.alternativeReferenceCommand,
					this.defaultValue.alternativeReferenceCommand,
				),
				alternativeTestsCommand: Qn.string(
					t.alternativeTestsCommand,
					this.defaultValue.alternativeTestsCommand,
				),
			}
		}
	},
	Pw = class extends pt {
		constructor() {
			let e = { enabled: !0, delay: 300, hidingDelay: 300, sticky: !0, above: !0 }
			super(62, "hover", e, {
				"editor.hover.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p("hover.enabled", "Controls whether the hover is shown."),
				},
				"editor.hover.delay": {
					type: "number",
					default: e.delay,
					minimum: 0,
					maximum: 1e4,
					description: p("hover.delay", "Controls the delay in milliseconds after which the hover is shown."),
				},
				"editor.hover.sticky": {
					type: "boolean",
					default: e.sticky,
					description: p(
						"hover.sticky",
						"Controls whether the hover should remain visible when mouse is moved over it.",
					),
				},
				"editor.hover.hidingDelay": {
					type: "integer",
					minimum: 0,
					default: e.hidingDelay,
					description: p(
						"hover.hidingDelay",
						"Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.",
					),
				},
				"editor.hover.above": {
					type: "boolean",
					default: e.above,
					description: p("hover.above", "Prefer showing hovers above the line, if there's space."),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				delay: tt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
				sticky: re(t.sticky, this.defaultValue.sticky),
				hidingDelay: tt.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
				above: re(t.above, this.defaultValue.above),
			}
		}
	}
var _w = class o extends os {
		constructor() {
			super(151)
		}
		compute(e, t, n) {
			return o.computeLayout(t, {
				memory: e.memory,
				outerWidth: e.outerWidth,
				outerHeight: e.outerHeight,
				isDominatedByLongLines: e.isDominatedByLongLines,
				lineHeight: e.fontInfo.lineHeight,
				viewLineCount: e.viewLineCount,
				lineNumbersDigitCount: e.lineNumbersDigitCount,
				typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
				maxDigitWidth: e.fontInfo.maxDigitWidth,
				pixelRatio: e.pixelRatio,
				glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount,
			})
		}
		static computeContainedMinimapLineCount(e) {
			let t = e.height / e.lineHeight,
				n = Math.floor(e.paddingTop / e.lineHeight),
				r = Math.floor(e.paddingBottom / e.lineHeight)
			e.scrollBeyondLastLine && (r = Math.max(r, t - 1))
			let i = (n + e.viewLineCount + r) / (e.pixelRatio * e.height),
				s = Math.floor(e.viewLineCount / i)
			return {
				typicalViewportLineCount: t,
				extraLinesBeforeFirstLine: n,
				extraLinesBeyondLastLine: r,
				desiredRatio: i,
				minimapLineCount: s,
			}
		}
		static _computeMinimapLayout(e, t) {
			let n = e.outerWidth,
				r = e.outerHeight,
				i = e.pixelRatio
			if (!e.minimap.enabled)
				return {
					renderMinimap: 0,
					minimapLeft: 0,
					minimapWidth: 0,
					minimapHeightIsEditorHeight: !1,
					minimapIsSampling: !1,
					minimapScale: 1,
					minimapLineHeight: 1,
					minimapCanvasInnerWidth: 0,
					minimapCanvasInnerHeight: Math.floor(i * r),
					minimapCanvasOuterWidth: 0,
					minimapCanvasOuterHeight: r,
				}
			let s = t.stableMinimapLayoutInput,
				a =
					s &&
					e.outerHeight === s.outerHeight &&
					e.lineHeight === s.lineHeight &&
					e.typicalHalfwidthCharacterWidth === s.typicalHalfwidthCharacterWidth &&
					e.pixelRatio === s.pixelRatio &&
					e.scrollBeyondLastLine === s.scrollBeyondLastLine &&
					e.paddingTop === s.paddingTop &&
					e.paddingBottom === s.paddingBottom &&
					e.minimap.enabled === s.minimap.enabled &&
					e.minimap.side === s.minimap.side &&
					e.minimap.size === s.minimap.size &&
					e.minimap.showSlider === s.minimap.showSlider &&
					e.minimap.renderCharacters === s.minimap.renderCharacters &&
					e.minimap.maxColumn === s.minimap.maxColumn &&
					e.minimap.scale === s.minimap.scale &&
					e.verticalScrollbarWidth === s.verticalScrollbarWidth &&
					e.isViewportWrapping === s.isViewportWrapping,
				l = e.lineHeight,
				d = e.typicalHalfwidthCharacterWidth,
				c = e.scrollBeyondLastLine,
				u = e.minimap.renderCharacters,
				m = i >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale,
				f = e.minimap.maxColumn,
				h = e.minimap.size,
				g = e.minimap.side,
				I = e.verticalScrollbarWidth,
				C = e.viewLineCount,
				T = e.remainingWidth,
				w = e.isViewportWrapping,
				L = u ? 2 : 3,
				A = Math.floor(i * r),
				J = A / i,
				ne = !1,
				oe = !1,
				Y = L * m,
				j = m / i,
				K = 1
			if (h === "fill" || h === "fit") {
				let {
					typicalViewportLineCount: ee,
					extraLinesBeforeFirstLine: fe,
					extraLinesBeyondLastLine: Ae,
					desiredRatio: he,
					minimapLineCount: le,
				} = o.computeContainedMinimapLineCount({
					viewLineCount: C,
					scrollBeyondLastLine: c,
					paddingTop: e.paddingTop,
					paddingBottom: e.paddingBottom,
					height: r,
					lineHeight: l,
					pixelRatio: i,
				})
				if (C / le > 1) (ne = !0), (oe = !0), (m = 1), (Y = 1), (j = m / i)
				else {
					let _t = !1,
						Se = m + 1
					if (h === "fit") {
						let En = Math.ceil((fe + C + Ae) * Y)
						w && a && T <= t.stableFitRemainingWidth
							? ((_t = !0), (Se = t.stableFitMaxMinimapScale))
							: (_t = En > A)
					}
					if (h === "fill" || _t) {
						ne = !0
						let En = m
						;(Y = Math.min(l * i, Math.max(1, Math.floor(1 / he)))),
							w && a && T <= t.stableFitRemainingWidth && (Se = t.stableFitMaxMinimapScale),
							(m = Math.min(Se, Math.max(1, Math.floor(Y / L)))),
							m > En && (K = Math.min(2, m / En)),
							(j = m / i / K),
							(A = Math.ceil(Math.max(ee, fe + C + Ae) * Y)),
							w
								? ((t.stableMinimapLayoutInput = e),
									(t.stableFitRemainingWidth = T),
									(t.stableFitMaxMinimapScale = m))
								: ((t.stableMinimapLayoutInput = null), (t.stableFitRemainingWidth = 0))
					}
				}
			}
			let qe = Math.floor(f * j),
				Bt = Math.min(qe, Math.max(0, Math.floor(((T - I - 2) * j) / (d + j))) + D5),
				vt = Math.floor(i * Bt),
				ae = vt / i
			vt = Math.floor(vt * K)
			let Z = u ? 1 : 2,
				se = g === "left" ? 0 : n - Bt - I
			return {
				renderMinimap: Z,
				minimapLeft: se,
				minimapWidth: Bt,
				minimapHeightIsEditorHeight: ne,
				minimapIsSampling: oe,
				minimapScale: m,
				minimapLineHeight: Y,
				minimapCanvasInnerWidth: vt,
				minimapCanvasInnerHeight: A,
				minimapCanvasOuterWidth: ae,
				minimapCanvasOuterHeight: J,
			}
		}
		static computeLayout(e, t) {
			let n = t.outerWidth | 0,
				r = t.outerHeight | 0,
				i = t.lineHeight | 0,
				s = t.lineNumbersDigitCount | 0,
				a = t.typicalHalfwidthCharacterWidth,
				l = t.maxDigitWidth,
				d = t.pixelRatio,
				c = t.viewLineCount,
				u = e.get(142),
				m = u === "inherit" ? e.get(141) : u,
				f = m === "inherit" ? e.get(137) : m,
				h = e.get(140),
				g = t.isDominatedByLongLines,
				I = e.get(59),
				C = e.get(69).renderType !== 0,
				T = e.get(70),
				w = e.get(110),
				L = e.get(88),
				A = e.get(74),
				J = e.get(108),
				ne = J.verticalScrollbarSize,
				oe = J.verticalHasArrows,
				Y = J.arrowSize,
				j = J.horizontalScrollbarSize,
				K = e.get(45),
				qe = e.get(115) !== "never",
				Bt = e.get(67)
			K && qe && (Bt += 16)
			let vt = 0
			if (C) {
				let to = Math.max(s, T)
				vt = Math.round(to * l)
			}
			let ae = 0
			I && (ae = i * t.glyphMarginDecorationLaneCount)
			let Z = 0,
				se = Z + ae,
				ee = se + vt,
				fe = ee + Bt,
				Ae = n - ae - vt - Bt,
				he = !1,
				le = !1,
				Et = -1
			m === "inherit" && g
				? ((he = !0), (le = !0))
				: f === "on" || f === "bounded"
					? (le = !0)
					: f === "wordWrapColumn" && (Et = h)
			let _t = o._computeMinimapLayout(
				{
					outerWidth: n,
					outerHeight: r,
					lineHeight: i,
					typicalHalfwidthCharacterWidth: a,
					pixelRatio: d,
					scrollBeyondLastLine: w,
					paddingTop: L.top,
					paddingBottom: L.bottom,
					minimap: A,
					verticalScrollbarWidth: ne,
					viewLineCount: c,
					remainingWidth: Ae,
					isViewportWrapping: le,
				},
				t.memory || new mw(),
			)
			_t.renderMinimap !== 0 &&
				_t.minimapLeft === 0 &&
				((Z += _t.minimapWidth), (se += _t.minimapWidth), (ee += _t.minimapWidth), (fe += _t.minimapWidth))
			let Se = Ae - _t.minimapWidth,
				En = Math.max(1, Math.floor((Se - ne - 2) / a)),
				Ft = oe ? Y : 0
			return (
				le && ((Et = Math.max(1, En)), f === "bounded" && (Et = Math.min(Et, h))),
				{
					width: n,
					height: r,
					glyphMarginLeft: Z,
					glyphMarginWidth: ae,
					glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
					lineNumbersLeft: se,
					lineNumbersWidth: vt,
					decorationsLeft: ee,
					decorationsWidth: Bt,
					contentLeft: fe,
					contentWidth: Se,
					minimap: _t,
					viewportColumn: En,
					isWordWrapMinified: he,
					isViewportWrapping: le,
					wrappingColumn: Et,
					verticalScrollbarWidth: ne,
					horizontalScrollbarHeight: j,
					overviewRuler: { top: Ft, width: ne, height: r - 2 * Ft, right: 0 },
				}
			)
		}
	},
	Dw = class extends pt {
		constructor() {
			super(144, "wrappingStrategy", "simple", {
				"editor.wrappingStrategy": {
					enumDescriptions: [
						p(
							"wrappingStrategy.simple",
							"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.",
						),
						p(
							"wrappingStrategy.advanced",
							"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.",
						),
					],
					type: "string",
					enum: ["simple", "advanced"],
					default: "simple",
					description: p(
						"wrappingStrategy",
						"Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.",
					),
				},
			})
		}
		validate(e) {
			return St(e, "simple", ["simple", "advanced"])
		}
		compute(e, t, n) {
			return t.get(2) === 2 ? "advanced" : n
		}
	}
var kw = class extends pt {
		constructor() {
			let e = { enabled: "onCode" }
			super(66, "lightbulb", e, {
				"editor.lightbulb.enabled": {
					type: "string",
					enum: ["off", "onCode", "on"],
					default: e.enabled,
					enumDescriptions: [
						p("editor.lightbulb.enabled.off", "Disable the code action menu."),
						p(
							"editor.lightbulb.enabled.onCode",
							"Show the code action menu when the cursor is on lines with code.",
						),
						p(
							"editor.lightbulb.enabled.on",
							"Show the code action menu when the cursor is on lines with code or on empty lines.",
						),
					],
					description: p("enabled", "Enables the Code Action lightbulb in the editor."),
				},
			})
		}
		validate(e) {
			return !e || typeof e != "object"
				? this.defaultValue
				: { enabled: St(e.enabled, this.defaultValue.enabled, ["off", "onCode", "on"]) }
		}
	},
	Rw = class extends pt {
		constructor() {
			let e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 }
			super(120, "stickyScroll", e, {
				"editor.stickyScroll.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"editor.stickyScroll.enabled",
						"Shows the nested current scopes during the scroll at the top of the editor.",
					),
				},
				"editor.stickyScroll.maxLineCount": {
					type: "number",
					default: e.maxLineCount,
					minimum: 1,
					maximum: 20,
					description: p(
						"editor.stickyScroll.maxLineCount",
						"Defines the maximum number of sticky lines to show.",
					),
				},
				"editor.stickyScroll.defaultModel": {
					type: "string",
					enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
					default: e.defaultModel,
					description: p(
						"editor.stickyScroll.defaultModel",
						"Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.",
					),
				},
				"editor.stickyScroll.scrollWithEditor": {
					type: "boolean",
					default: e.scrollWithEditor,
					description: p(
						"editor.stickyScroll.scrollWithEditor",
						"Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				maxLineCount: tt.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
				defaultModel: St(t.defaultModel, this.defaultValue.defaultModel, [
					"outlineModel",
					"foldingProviderModel",
					"indentationModel",
				]),
				scrollWithEditor: re(t.scrollWithEditor, this.defaultValue.scrollWithEditor),
			}
		}
	},
	Aw = class extends pt {
		constructor() {
			let e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1, maximumLength: 43 }
			super(146, "inlayHints", e, {
				"editor.inlayHints.enabled": {
					type: "string",
					default: e.enabled,
					description: p("inlayHints.enable", "Enables the inlay hints in the editor."),
					enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
					markdownEnumDescriptions: [
						p("editor.inlayHints.on", "Inlay hints are enabled"),
						p(
							"editor.inlayHints.onUnlessPressed",
							"Inlay hints are showing by default and hide when holding {0}",
							st ? "Ctrl+Option" : "Ctrl+Alt",
						),
						p(
							"editor.inlayHints.offUnlessPressed",
							"Inlay hints are hidden by default and show when holding {0}",
							st ? "Ctrl+Option" : "Ctrl+Alt",
						),
						p("editor.inlayHints.off", "Inlay hints are disabled"),
					],
				},
				"editor.inlayHints.fontSize": {
					type: "number",
					default: e.fontSize,
					markdownDescription: p(
						"inlayHints.fontSize",
						"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.",
						"`#editor.fontSize#`",
						"`5`",
					),
				},
				"editor.inlayHints.fontFamily": {
					type: "string",
					default: e.fontFamily,
					markdownDescription: p(
						"inlayHints.fontFamily",
						"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.",
						"`#editor.fontFamily#`",
					),
				},
				"editor.inlayHints.padding": {
					type: "boolean",
					default: e.padding,
					description: p("inlayHints.padding", "Enables the padding around the inlay hints in the editor."),
				},
				"editor.inlayHints.maximumLength": {
					type: "number",
					default: e.maximumLength,
					markdownDescription: p(
						"inlayHints.maximumLength",
						"Maximum overall length of inlay hints, for a single line, before they get truncated by the editor. Set to `0` to never truncate",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return (
				typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"),
				{
					enabled: St(t.enabled, this.defaultValue.enabled, [
						"on",
						"off",
						"offUnlessPressed",
						"onUnlessPressed",
					]),
					fontSize: tt.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
					fontFamily: Qn.string(t.fontFamily, this.defaultValue.fontFamily),
					padding: re(t.padding, this.defaultValue.padding),
					maximumLength: tt.clampedInt(
						t.maximumLength,
						this.defaultValue.maximumLength,
						0,
						Number.MAX_SAFE_INTEGER,
					),
				}
			)
		}
	},
	Ow = class extends pt {
		constructor() {
			super(67, "lineDecorationsWidth", 10)
		}
		validate(e) {
			return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e)
				? -parseFloat(e.substring(0, e.length - 2))
				: tt.clampedInt(e, this.defaultValue, 0, 1e3)
		}
		compute(e, t, n) {
			return n < 0 ? tt.clampedInt(-n * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : n
		}
	},
	Lw = class extends lo {
		constructor() {
			super(68, "lineHeight", rs.lineHeight, (e) => lo.clamp(e, 0, 150), {
				markdownDescription: p(
					"lineHeight",
					`Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`,
				),
			})
		}
		compute(e, t, n) {
			return e.fontInfo.lineHeight
		}
	},
	Mw = class extends pt {
		constructor() {
			let e = {
				enabled: !0,
				size: "proportional",
				side: "right",
				showSlider: "mouseover",
				autohide: !1,
				renderCharacters: !0,
				maxColumn: 120,
				scale: 1,
				showRegionSectionHeaders: !0,
				showMarkSectionHeaders: !0,
				markSectionHeaderRegex: "\\bMARK:\\s*(?<separator>-?)\\s*(?<label>.*)$",
				sectionHeaderFontSize: 9,
				sectionHeaderLetterSpacing: 1,
			}
			super(74, "minimap", e, {
				"editor.minimap.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p("minimap.enabled", "Controls whether the minimap is shown."),
				},
				"editor.minimap.autohide": {
					type: "boolean",
					default: e.autohide,
					description: p("minimap.autohide", "Controls whether the minimap is hidden automatically."),
				},
				"editor.minimap.size": {
					type: "string",
					enum: ["proportional", "fill", "fit"],
					enumDescriptions: [
						p(
							"minimap.size.proportional",
							"The minimap has the same size as the editor contents (and might scroll).",
						),
						p(
							"minimap.size.fill",
							"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).",
						),
						p(
							"minimap.size.fit",
							"The minimap will shrink as necessary to never be larger than the editor (no scrolling).",
						),
					],
					default: e.size,
					description: p("minimap.size", "Controls the size of the minimap."),
				},
				"editor.minimap.side": {
					type: "string",
					enum: ["left", "right"],
					default: e.side,
					description: p("minimap.side", "Controls the side where to render the minimap."),
				},
				"editor.minimap.showSlider": {
					type: "string",
					enum: ["always", "mouseover"],
					default: e.showSlider,
					description: p("minimap.showSlider", "Controls when the minimap slider is shown."),
				},
				"editor.minimap.scale": {
					type: "number",
					default: e.scale,
					minimum: 1,
					maximum: 3,
					enum: [1, 2, 3],
					description: p("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3."),
				},
				"editor.minimap.renderCharacters": {
					type: "boolean",
					default: e.renderCharacters,
					description: p(
						"minimap.renderCharacters",
						"Render the actual characters on a line as opposed to color blocks.",
					),
				},
				"editor.minimap.maxColumn": {
					type: "number",
					default: e.maxColumn,
					description: p(
						"minimap.maxColumn",
						"Limit the width of the minimap to render at most a certain number of columns.",
					),
				},
				"editor.minimap.showRegionSectionHeaders": {
					type: "boolean",
					default: e.showRegionSectionHeaders,
					description: p(
						"minimap.showRegionSectionHeaders",
						"Controls whether named regions are shown as section headers in the minimap.",
					),
				},
				"editor.minimap.showMarkSectionHeaders": {
					type: "boolean",
					default: e.showMarkSectionHeaders,
					description: p(
						"minimap.showMarkSectionHeaders",
						"Controls whether MARK: comments are shown as section headers in the minimap.",
					),
				},
				"editor.minimap.markSectionHeaderRegex": {
					type: "string",
					default: e.markSectionHeaderRegex,
					description: p(
						"minimap.markSectionHeaderRegex",
						"Defines the regular expression used to find section headers in comments. The regex must contain a named match group `label` (written as `(?<label>.+)`) that encapsulates the section header, otherwise it will not work. Optionally you can include another match group named `separator`. Use \\n in the pattern to match multi-line headers.",
					),
				},
				"editor.minimap.sectionHeaderFontSize": {
					type: "number",
					default: e.sectionHeaderFontSize,
					description: p(
						"minimap.sectionHeaderFontSize",
						"Controls the font size of section headers in the minimap.",
					),
				},
				"editor.minimap.sectionHeaderLetterSpacing": {
					type: "number",
					default: e.sectionHeaderLetterSpacing,
					description: p(
						"minimap.sectionHeaderLetterSpacing",
						"Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e,
				n = this.defaultValue.markSectionHeaderRegex,
				r = e.markSectionHeaderRegex
			if (typeof r == "string")
				try {
					new RegExp(r, "d"), (n = r)
				} catch {}
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				autohide: re(t.autohide, this.defaultValue.autohide),
				size: St(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
				side: St(t.side, this.defaultValue.side, ["right", "left"]),
				showSlider: St(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
				renderCharacters: re(t.renderCharacters, this.defaultValue.renderCharacters),
				scale: tt.clampedInt(t.scale, 1, 1, 3),
				maxColumn: tt.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
				showRegionSectionHeaders: re(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
				showMarkSectionHeaders: re(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
				markSectionHeaderRegex: n,
				sectionHeaderFontSize: lo.clamp(
					t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize,
					4,
					32,
				),
				sectionHeaderLetterSpacing: lo.clamp(
					t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing,
					0,
					5,
				),
			}
		}
	}
function O5(o) {
	return o === "ctrlCmd" ? (st ? "metaKey" : "ctrlKey") : "altKey"
}
var Fw = class extends pt {
		constructor() {
			super(
				88,
				"padding",
				{ top: 0, bottom: 0 },
				{
					"editor.padding.top": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1e3,
						description: p(
							"padding.top",
							"Controls the amount of space between the top edge of the editor and the first line.",
						),
					},
					"editor.padding.bottom": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1e3,
						description: p(
							"padding.bottom",
							"Controls the amount of space between the bottom edge of the editor and the last line.",
						),
					},
				},
			)
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return { top: tt.clampedInt(t.top, 0, 0, 1e3), bottom: tt.clampedInt(t.bottom, 0, 0, 1e3) }
		}
	},
	Nw = class extends pt {
		constructor() {
			let e = { enabled: !0, cycle: !0 }
			super(90, "parameterHints", e, {
				"editor.parameterHints.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"parameterHints.enabled",
						"Enables a pop-up that shows parameter documentation and type information as you type.",
					),
				},
				"editor.parameterHints.cycle": {
					type: "boolean",
					default: e.cycle,
					description: p(
						"parameterHints.cycle",
						"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return { enabled: re(t.enabled, this.defaultValue.enabled), cycle: re(t.cycle, this.defaultValue.cycle) }
		}
	},
	Uw = class extends os {
		constructor() {
			super(149)
		}
		compute(e, t, n) {
			return e.pixelRatio
		}
	},
	Hw = class extends pt {
		constructor() {
			super(92, "placeholder", void 0)
		}
		validate(e) {
			return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue
		}
	},
	Ww = class extends pt {
		constructor() {
			let e = { other: "on", comments: "off", strings: "off" },
				t = [
					{ type: "boolean" },
					{
						type: "string",
						enum: ["on", "inline", "off"],
						enumDescriptions: [
							p("on", "Quick suggestions show inside the suggest widget"),
							p("inline", "Quick suggestions show as ghost text"),
							p("off", "Quick suggestions are disabled"),
						],
					},
				]
			super(94, "quickSuggestions", e, {
				type: "object",
				additionalProperties: !1,
				properties: {
					strings: {
						anyOf: t,
						default: e.strings,
						description: p("quickSuggestions.strings", "Enable quick suggestions inside strings."),
					},
					comments: {
						anyOf: t,
						default: e.comments,
						description: p("quickSuggestions.comments", "Enable quick suggestions inside comments."),
					},
					other: {
						anyOf: t,
						default: e.other,
						description: p(
							"quickSuggestions.other",
							"Enable quick suggestions outside of strings and comments.",
						),
					},
				},
				default: e,
				markdownDescription: p(
					"quickSuggestions",
					"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.",
					"`#editor.suggestOnTriggerCharacters#`",
				),
			}),
				(this.defaultValue = e)
		}
		validate(e) {
			if (typeof e == "boolean") {
				let d = e ? "on" : "off"
				return { comments: d, strings: d, other: d }
			}
			if (!e || typeof e != "object") return this.defaultValue
			let { other: t, comments: n, strings: r } = e,
				i = ["on", "inline", "off"],
				s,
				a,
				l
			return (
				typeof t == "boolean" ? (s = t ? "on" : "off") : (s = St(t, this.defaultValue.other, i)),
				typeof n == "boolean" ? (a = n ? "on" : "off") : (a = St(n, this.defaultValue.comments, i)),
				typeof r == "boolean" ? (l = r ? "on" : "off") : (l = St(r, this.defaultValue.strings, i)),
				{ other: s, comments: a, strings: l }
			)
		}
	}
var Vw = class extends pt {
	constructor() {
		super(
			69,
			"lineNumbers",
			{ renderType: 1, renderFn: null },
			{
				type: "string",
				enum: ["off", "on", "relative", "interval"],
				enumDescriptions: [
					p("lineNumbers.off", "Line numbers are not rendered."),
					p("lineNumbers.on", "Line numbers are rendered as absolute number."),
					p("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
					p("lineNumbers.interval", "Line numbers are rendered every 10 lines."),
				],
				default: "on",
				description: p("lineNumbers", "Controls the display of line numbers."),
			},
		)
	}
	validate(e) {
		let t = this.defaultValue.renderType,
			n = this.defaultValue.renderFn
		return (
			typeof e < "u" &&
				(typeof e == "function"
					? ((t = 4), (n = e))
					: e === "interval"
						? (t = 3)
						: e === "relative"
							? (t = 2)
							: e === "on"
								? (t = 1)
								: (t = 0)),
			{ renderType: t, renderFn: n }
		)
	}
}
var Bw = class extends pt {
		constructor() {
			let e = [],
				t = {
					type: "number",
					description: p(
						"rulers.size",
						"Number of monospace characters at which this editor ruler will render.",
					),
				}
			super(107, "rulers", e, {
				type: "array",
				items: {
					anyOf: [
						t,
						{
							type: ["object"],
							properties: {
								column: t,
								color: {
									type: "string",
									description: p("rulers.color", "Color of this editor ruler."),
									format: "color-hex",
								},
							},
						},
					],
				},
				default: e,
				description: p(
					"rulers",
					"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.",
				),
			})
		}
		validate(e) {
			if (Array.isArray(e)) {
				let t = []
				for (let n of e)
					if (typeof n == "number") t.push({ column: tt.clampedInt(n, 0, 0, 1e4), color: null })
					else if (n && typeof n == "object") {
						let r = n
						t.push({ column: tt.clampedInt(r.column, 0, 0, 1e4), color: r.color })
					}
				return t.sort((n, r) => n.column - r.column), t
			}
			return this.defaultValue
		}
	},
	$w = class extends pt {
		constructor() {
			super(97, "readOnlyMessage", void 0)
		}
		validate(e) {
			return !e || typeof e != "object" ? this.defaultValue : e
		}
	}
function WO(o, e) {
	if (typeof o != "string") return e
	switch (o) {
		case "hidden":
			return 2
		case "visible":
			return 3
		default:
			return 1
	}
}
var zw = class extends pt {
		constructor() {
			let e = {
				vertical: 1,
				horizontal: 1,
				arrowSize: 11,
				useShadows: !0,
				verticalHasArrows: !1,
				horizontalHasArrows: !1,
				horizontalScrollbarSize: 12,
				horizontalSliderSize: 12,
				verticalScrollbarSize: 14,
				verticalSliderSize: 14,
				handleMouseWheel: !0,
				alwaysConsumeMouseWheel: !0,
				scrollByPage: !1,
				ignoreHorizontalScrollbarInContentHeight: !1,
			}
			super(108, "scrollbar", e, {
				"editor.scrollbar.vertical": {
					type: "string",
					enum: ["auto", "visible", "hidden"],
					enumDescriptions: [
						p("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
						p("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
						p("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden."),
					],
					default: "auto",
					description: p("scrollbar.vertical", "Controls the visibility of the vertical scrollbar."),
				},
				"editor.scrollbar.horizontal": {
					type: "string",
					enum: ["auto", "visible", "hidden"],
					enumDescriptions: [
						p("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
						p("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
						p("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden."),
					],
					default: "auto",
					description: p("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar."),
				},
				"editor.scrollbar.verticalScrollbarSize": {
					type: "number",
					default: e.verticalScrollbarSize,
					description: p("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar."),
				},
				"editor.scrollbar.horizontalScrollbarSize": {
					type: "number",
					default: e.horizontalScrollbarSize,
					description: p("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar."),
				},
				"editor.scrollbar.scrollByPage": {
					type: "boolean",
					default: e.scrollByPage,
					description: p(
						"scrollbar.scrollByPage",
						"Controls whether clicks scroll by page or jump to click position.",
					),
				},
				"editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
					type: "boolean",
					default: e.ignoreHorizontalScrollbarInContentHeight,
					description: p(
						"scrollbar.ignoreHorizontalScrollbarInContentHeight",
						"When set, the horizontal scrollbar will not increase the size of the editor's content.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e,
				n = tt.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3),
				r = tt.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3)
			return {
				arrowSize: tt.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
				vertical: WO(t.vertical, this.defaultValue.vertical),
				horizontal: WO(t.horizontal, this.defaultValue.horizontal),
				useShadows: re(t.useShadows, this.defaultValue.useShadows),
				verticalHasArrows: re(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
				horizontalHasArrows: re(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
				handleMouseWheel: re(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
				alwaysConsumeMouseWheel: re(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
				horizontalScrollbarSize: n,
				horizontalSliderSize: tt.clampedInt(t.horizontalSliderSize, n, 0, 1e3),
				verticalScrollbarSize: r,
				verticalSliderSize: tt.clampedInt(t.verticalSliderSize, r, 0, 1e3),
				scrollByPage: re(t.scrollByPage, this.defaultValue.scrollByPage),
				ignoreHorizontalScrollbarInContentHeight: re(
					t.ignoreHorizontalScrollbarInContentHeight,
					this.defaultValue.ignoreHorizontalScrollbarInContentHeight,
				),
			}
		}
	},
	Ho = "inUntrustedWorkspace",
	Bl = {
		allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
		invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
		nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
		ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
		includeComments: "editor.unicodeHighlight.includeComments",
		includeStrings: "editor.unicodeHighlight.includeStrings",
		allowedLocales: "editor.unicodeHighlight.allowedLocales",
	},
	qw = class extends pt {
		constructor() {
			let e = {
				nonBasicASCII: Ho,
				invisibleCharacters: !0,
				ambiguousCharacters: !0,
				includeComments: Ho,
				includeStrings: !0,
				allowedCharacters: {},
				allowedLocales: { _os: !0, _vscode: !0 },
			}
			super(130, "unicodeHighlight", e, {
				[Bl.nonBasicASCII]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Ho],
					default: e.nonBasicASCII,
					description: p(
						"unicodeHighlight.nonBasicASCII",
						"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.",
					),
				},
				[Bl.invisibleCharacters]: {
					restricted: !0,
					type: "boolean",
					default: e.invisibleCharacters,
					description: p(
						"unicodeHighlight.invisibleCharacters",
						"Controls whether characters that just reserve space or have no width at all are highlighted.",
					),
				},
				[Bl.ambiguousCharacters]: {
					restricted: !0,
					type: "boolean",
					default: e.ambiguousCharacters,
					description: p(
						"unicodeHighlight.ambiguousCharacters",
						"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.",
					),
				},
				[Bl.includeComments]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Ho],
					default: e.includeComments,
					description: p(
						"unicodeHighlight.includeComments",
						"Controls whether characters in comments should also be subject to Unicode highlighting.",
					),
				},
				[Bl.includeStrings]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Ho],
					default: e.includeStrings,
					description: p(
						"unicodeHighlight.includeStrings",
						"Controls whether characters in strings should also be subject to Unicode highlighting.",
					),
				},
				[Bl.allowedCharacters]: {
					restricted: !0,
					type: "object",
					default: e.allowedCharacters,
					description: p(
						"unicodeHighlight.allowedCharacters",
						"Defines allowed characters that are not being highlighted.",
					),
					additionalProperties: { type: "boolean" },
				},
				[Bl.allowedLocales]: {
					restricted: !0,
					type: "object",
					additionalProperties: { type: "boolean" },
					default: e.allowedLocales,
					description: p(
						"unicodeHighlight.allowedLocales",
						"Unicode characters that are common in allowed locales are not being highlighted.",
					),
				},
			})
		}
		applyUpdate(e, t) {
			let n = !1
			t.allowedCharacters &&
				e &&
				(nn(e.allowedCharacters, t.allowedCharacters) ||
					((e = { ...e, allowedCharacters: t.allowedCharacters }), (n = !0))),
				t.allowedLocales &&
					e &&
					(nn(e.allowedLocales, t.allowedLocales) ||
						((e = { ...e, allowedLocales: t.allowedLocales }), (n = !0)))
			let r = super.applyUpdate(e, t)
			return n ? new Lc(r.newValue, !0) : r
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				nonBasicASCII: Mc(t.nonBasicASCII, Ho, [!0, !1, Ho]),
				invisibleCharacters: re(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
				ambiguousCharacters: re(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
				includeComments: Mc(t.includeComments, Ho, [!0, !1, Ho]),
				includeStrings: Mc(t.includeStrings, Ho, [!0, !1, Ho]),
				allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
				allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales),
			}
		}
		validateBooleanMap(e, t) {
			if (typeof e != "object" || !e) return t
			let n = {}
			for (let [r, i] of Object.entries(e)) i === !0 && (n[r] = !0)
			return n
		}
	},
	Kw = class extends pt {
		constructor() {
			let e = {
				enabled: !0,
				mode: "subwordSmart",
				showToolbar: "onHover",
				suppressSuggestions: !1,
				keepOnBlur: !1,
				fontFamily: "default",
				syntaxHighlightingEnabled: !0,
				edits: {
					enabled: !0,
					showCollapsed: !1,
					renderSideBySide: "auto",
					allowCodeShifting: "always",
					useMultiLineGhostText: !0,
				},
			}
			super(64, "inlineSuggest", e, {
				"editor.inlineSuggest.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"inlineSuggest.enabled",
						"Controls whether to automatically show inline suggestions in the editor.",
					),
				},
				"editor.inlineSuggest.showToolbar": {
					type: "string",
					default: e.showToolbar,
					enum: ["always", "onHover", "never"],
					enumDescriptions: [
						p(
							"inlineSuggest.showToolbar.always",
							"Show the inline suggestion toolbar whenever an inline suggestion is shown.",
						),
						p(
							"inlineSuggest.showToolbar.onHover",
							"Show the inline suggestion toolbar when hovering over an inline suggestion.",
						),
						p("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar."),
					],
					description: p("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar."),
				},
				"editor.inlineSuggest.syntaxHighlightingEnabled": {
					type: "boolean",
					default: e.syntaxHighlightingEnabled,
					description: p(
						"inlineSuggest.syntaxHighlightingEnabled",
						"Controls whether to show syntax highlighting for inline suggestions in the editor.",
					),
				},
				"editor.inlineSuggest.suppressSuggestions": {
					type: "boolean",
					default: e.suppressSuggestions,
					description: p(
						"inlineSuggest.suppressSuggestions",
						"Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.",
					),
				},
				"editor.inlineSuggest.fontFamily": {
					type: "string",
					default: e.fontFamily,
					description: p("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions."),
				},
				"editor.inlineSuggest.edits.allowCodeShifting": {
					type: "string",
					default: e.edits.allowCodeShifting,
					description: p(
						"inlineSuggest.edits.allowCodeShifting",
						"Controls whether showing a suggestion will shift the code to make space for the suggestion inline.",
					),
					enum: ["always", "horizontal", "never"],
					tags: ["nextEditSuggestions"],
				},
				"editor.inlineSuggest.edits.renderSideBySide": {
					type: "string",
					default: e.edits.renderSideBySide,
					description: p(
						"inlineSuggest.edits.renderSideBySide",
						"Controls whether larger suggestions can be shown side by side.",
					),
					enum: ["auto", "never"],
					enumDescriptions: [
						p(
							"editor.inlineSuggest.edits.renderSideBySide.auto",
							"Larger suggestions will show side by side if there is enough space, otherwise they will be shown below.",
						),
						p(
							"editor.inlineSuggest.edits.renderSideBySide.never",
							"Larger suggestions are never shown side by side and will always be shown below.",
						),
					],
					tags: ["nextEditSuggestions"],
				},
				"editor.inlineSuggest.edits.showCollapsed": {
					type: "boolean",
					default: e.edits.showCollapsed,
					description: p(
						"inlineSuggest.edits.showCollapsed",
						"Controls whether the suggestion will show as collapsed until jumping to it.",
					),
					tags: ["nextEditSuggestions"],
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				mode: St(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
				showToolbar: St(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
				suppressSuggestions: re(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
				keepOnBlur: re(t.keepOnBlur, this.defaultValue.keepOnBlur),
				fontFamily: Qn.string(t.fontFamily, this.defaultValue.fontFamily),
				syntaxHighlightingEnabled: re(t.syntaxHighlightingEnabled, this.defaultValue.syntaxHighlightingEnabled),
				edits: {
					enabled: re(t.edits?.enabled, this.defaultValue.edits.enabled),
					showCollapsed: re(t.edits?.showCollapsed, this.defaultValue.edits.showCollapsed),
					allowCodeShifting: St(t.edits?.allowCodeShifting, this.defaultValue.edits.allowCodeShifting, [
						"always",
						"horizontal",
						"never",
					]),
					renderSideBySide: St(t.edits?.renderSideBySide, this.defaultValue.edits.renderSideBySide, [
						"never",
						"auto",
					]),
					useMultiLineGhostText: re(
						t.edits?.useMultiLineGhostText,
						this.defaultValue.edits.useMultiLineGhostText,
					),
				},
			}
		}
	},
	jw = class extends pt {
		constructor() {
			let e = {
				enabled: sw.bracketPairColorizationOptions.enabled,
				independentColorPoolPerBracketType:
					sw.bracketPairColorizationOptions.independentColorPoolPerBracketType,
			}
			super(15, "bracketPairColorization", e, {
				"editor.bracketPairColorization.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"bracketPairColorization.enabled",
						"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.",
						"`#workbench.colorCustomizations#`",
					),
				},
				"editor.bracketPairColorization.independentColorPoolPerBracketType": {
					type: "boolean",
					default: e.independentColorPoolPerBracketType,
					description: p(
						"bracketPairColorization.independentColorPoolPerBracketType",
						"Controls whether each bracket type has its own independent color pool.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				independentColorPoolPerBracketType: re(
					t.independentColorPoolPerBracketType,
					this.defaultValue.independentColorPoolPerBracketType,
				),
			}
		}
	},
	Gw = class extends pt {
		constructor() {
			let e = {
				bracketPairs: !1,
				bracketPairsHorizontal: "active",
				highlightActiveBracketPair: !0,
				indentation: !0,
				highlightActiveIndentation: !0,
			}
			super(16, "guides", e, {
				"editor.guides.bracketPairs": {
					type: ["boolean", "string"],
					enum: [!0, "active", !1],
					enumDescriptions: [
						p("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
						p(
							"editor.guides.bracketPairs.active",
							"Enables bracket pair guides only for the active bracket pair.",
						),
						p("editor.guides.bracketPairs.false", "Disables bracket pair guides."),
					],
					default: e.bracketPairs,
					description: p(
						"editor.guides.bracketPairs",
						"Controls whether bracket pair guides are enabled or not.",
					),
				},
				"editor.guides.bracketPairsHorizontal": {
					type: ["boolean", "string"],
					enum: [!0, "active", !1],
					enumDescriptions: [
						p(
							"editor.guides.bracketPairsHorizontal.true",
							"Enables horizontal guides as addition to vertical bracket pair guides.",
						),
						p(
							"editor.guides.bracketPairsHorizontal.active",
							"Enables horizontal guides only for the active bracket pair.",
						),
						p("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides."),
					],
					default: e.bracketPairsHorizontal,
					description: p(
						"editor.guides.bracketPairsHorizontal",
						"Controls whether horizontal bracket pair guides are enabled or not.",
					),
				},
				"editor.guides.highlightActiveBracketPair": {
					type: "boolean",
					default: e.highlightActiveBracketPair,
					description: p(
						"editor.guides.highlightActiveBracketPair",
						"Controls whether the editor should highlight the active bracket pair.",
					),
				},
				"editor.guides.indentation": {
					type: "boolean",
					default: e.indentation,
					description: p(
						"editor.guides.indentation",
						"Controls whether the editor should render indent guides.",
					),
				},
				"editor.guides.highlightActiveIndentation": {
					type: ["boolean", "string"],
					enum: [!0, "always", !1],
					enumDescriptions: [
						p("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
						p(
							"editor.guides.highlightActiveIndentation.always",
							"Highlights the active indent guide even if bracket guides are highlighted.",
						),
						p(
							"editor.guides.highlightActiveIndentation.false",
							"Do not highlight the active indent guide.",
						),
					],
					default: e.highlightActiveIndentation,
					description: p(
						"editor.guides.highlightActiveIndentation",
						"Controls whether the editor should highlight the active indent guide.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				bracketPairs: Mc(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
				bracketPairsHorizontal: Mc(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [
					!0,
					!1,
					"active",
				]),
				highlightActiveBracketPair: re(
					t.highlightActiveBracketPair,
					this.defaultValue.highlightActiveBracketPair,
				),
				indentation: re(t.indentation, this.defaultValue.indentation),
				highlightActiveIndentation: Mc(
					t.highlightActiveIndentation,
					this.defaultValue.highlightActiveIndentation,
					[!0, !1, "always"],
				),
			}
		}
	}
function Mc(o, e, t) {
	let n = t.indexOf(o)
	return n === -1 ? e : t[n]
}
var Qw = class extends pt {
		constructor() {
			let e = {
				insertMode: "insert",
				filterGraceful: !0,
				snippetsPreventQuickSuggestions: !1,
				localityBonus: !1,
				shareSuggestSelections: !1,
				selectionMode: "always",
				showIcons: !0,
				showStatusBar: !1,
				preview: !1,
				previewMode: "subwordSmart",
				showInlineDetails: !0,
				showMethods: !0,
				showFunctions: !0,
				showConstructors: !0,
				showDeprecated: !0,
				matchOnWordStartOnly: !0,
				showFields: !0,
				showVariables: !0,
				showClasses: !0,
				showStructs: !0,
				showInterfaces: !0,
				showModules: !0,
				showProperties: !0,
				showEvents: !0,
				showOperators: !0,
				showUnits: !0,
				showValues: !0,
				showConstants: !0,
				showEnums: !0,
				showEnumMembers: !0,
				showKeywords: !0,
				showWords: !0,
				showColors: !0,
				showFiles: !0,
				showReferences: !0,
				showFolders: !0,
				showTypeParameters: !0,
				showSnippets: !0,
				showUsers: !0,
				showIssues: !0,
			}
			super(123, "suggest", e, {
				"editor.suggest.insertMode": {
					type: "string",
					enum: ["insert", "replace"],
					enumDescriptions: [
						p(
							"suggest.insertMode.insert",
							"Insert suggestion without overwriting text right of the cursor.",
						),
						p("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor."),
					],
					default: e.insertMode,
					description: p(
						"suggest.insertMode",
						"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.",
					),
				},
				"editor.suggest.filterGraceful": {
					type: "boolean",
					default: e.filterGraceful,
					description: p(
						"suggest.filterGraceful",
						"Controls whether filtering and sorting suggestions accounts for small typos.",
					),
				},
				"editor.suggest.localityBonus": {
					type: "boolean",
					default: e.localityBonus,
					description: p(
						"suggest.localityBonus",
						"Controls whether sorting favors words that appear close to the cursor.",
					),
				},
				"editor.suggest.shareSuggestSelections": {
					type: "boolean",
					default: e.shareSuggestSelections,
					markdownDescription: p(
						"suggest.shareSuggestSelections",
						"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).",
					),
				},
				"editor.suggest.selectionMode": {
					type: "string",
					enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
					enumDescriptions: [
						p(
							"suggest.insertMode.always",
							"Always select a suggestion when automatically triggering IntelliSense.",
						),
						p(
							"suggest.insertMode.never",
							"Never select a suggestion when automatically triggering IntelliSense.",
						),
						p(
							"suggest.insertMode.whenTriggerCharacter",
							"Select a suggestion only when triggering IntelliSense from a trigger character.",
						),
						p(
							"suggest.insertMode.whenQuickSuggestion",
							"Select a suggestion only when triggering IntelliSense as you type.",
						),
					],
					default: e.selectionMode,
					markdownDescription: p(
						"suggest.selectionMode",
						"Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.",
						"`#editor.quickSuggestions#`",
						"`#editor.suggestOnTriggerCharacters#`",
					),
				},
				"editor.suggest.snippetsPreventQuickSuggestions": {
					type: "boolean",
					default: e.snippetsPreventQuickSuggestions,
					description: p(
						"suggest.snippetsPreventQuickSuggestions",
						"Controls whether an active snippet prevents quick suggestions.",
					),
				},
				"editor.suggest.showIcons": {
					type: "boolean",
					default: e.showIcons,
					description: p("suggest.showIcons", "Controls whether to show or hide icons in suggestions."),
				},
				"editor.suggest.showStatusBar": {
					type: "boolean",
					default: e.showStatusBar,
					description: p(
						"suggest.showStatusBar",
						"Controls the visibility of the status bar at the bottom of the suggest widget.",
					),
				},
				"editor.suggest.preview": {
					type: "boolean",
					default: e.preview,
					description: p(
						"suggest.preview",
						"Controls whether to preview the suggestion outcome in the editor.",
					),
				},
				"editor.suggest.showInlineDetails": {
					type: "boolean",
					default: e.showInlineDetails,
					description: p(
						"suggest.showInlineDetails",
						"Controls whether suggest details show inline with the label or only in the details widget.",
					),
				},
				"editor.suggest.maxVisibleSuggestions": {
					type: "number",
					deprecationMessage: p(
						"suggest.maxVisibleSuggestions.dep",
						"This setting is deprecated. The suggest widget can now be resized.",
					),
				},
				"editor.suggest.filteredTypes": {
					type: "object",
					deprecationMessage: p(
						"deprecated",
						"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.",
					),
				},
				"editor.suggest.showMethods": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showMethods",
						"When enabled IntelliSense shows `method`-suggestions.",
					),
				},
				"editor.suggest.showFunctions": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFunctions",
						"When enabled IntelliSense shows `function`-suggestions.",
					),
				},
				"editor.suggest.showConstructors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showConstructors",
						"When enabled IntelliSense shows `constructor`-suggestions.",
					),
				},
				"editor.suggest.showDeprecated": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showDeprecated",
						"When enabled IntelliSense shows `deprecated`-suggestions.",
					),
				},
				"editor.suggest.matchOnWordStartOnly": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.matchOnWordStartOnly",
						"When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.",
					),
				},
				"editor.suggest.showFields": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFields",
						"When enabled IntelliSense shows `field`-suggestions.",
					),
				},
				"editor.suggest.showVariables": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showVariables",
						"When enabled IntelliSense shows `variable`-suggestions.",
					),
				},
				"editor.suggest.showClasses": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showClasss",
						"When enabled IntelliSense shows `class`-suggestions.",
					),
				},
				"editor.suggest.showStructs": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showStructs",
						"When enabled IntelliSense shows `struct`-suggestions.",
					),
				},
				"editor.suggest.showInterfaces": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showInterfaces",
						"When enabled IntelliSense shows `interface`-suggestions.",
					),
				},
				"editor.suggest.showModules": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showModules",
						"When enabled IntelliSense shows `module`-suggestions.",
					),
				},
				"editor.suggest.showProperties": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showPropertys",
						"When enabled IntelliSense shows `property`-suggestions.",
					),
				},
				"editor.suggest.showEvents": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEvents",
						"When enabled IntelliSense shows `event`-suggestions.",
					),
				},
				"editor.suggest.showOperators": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showOperators",
						"When enabled IntelliSense shows `operator`-suggestions.",
					),
				},
				"editor.suggest.showUnits": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showUnits",
						"When enabled IntelliSense shows `unit`-suggestions.",
					),
				},
				"editor.suggest.showValues": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showValues",
						"When enabled IntelliSense shows `value`-suggestions.",
					),
				},
				"editor.suggest.showConstants": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showConstants",
						"When enabled IntelliSense shows `constant`-suggestions.",
					),
				},
				"editor.suggest.showEnums": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEnums",
						"When enabled IntelliSense shows `enum`-suggestions.",
					),
				},
				"editor.suggest.showEnumMembers": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEnumMembers",
						"When enabled IntelliSense shows `enumMember`-suggestions.",
					),
				},
				"editor.suggest.showKeywords": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showKeywords",
						"When enabled IntelliSense shows `keyword`-suggestions.",
					),
				},
				"editor.suggest.showWords": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showTexts",
						"When enabled IntelliSense shows `text`-suggestions.",
					),
				},
				"editor.suggest.showColors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showColors",
						"When enabled IntelliSense shows `color`-suggestions.",
					),
				},
				"editor.suggest.showFiles": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFiles",
						"When enabled IntelliSense shows `file`-suggestions.",
					),
				},
				"editor.suggest.showReferences": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showReferences",
						"When enabled IntelliSense shows `reference`-suggestions.",
					),
				},
				"editor.suggest.showCustomcolors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showCustomcolors",
						"When enabled IntelliSense shows `customcolor`-suggestions.",
					),
				},
				"editor.suggest.showFolders": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFolders",
						"When enabled IntelliSense shows `folder`-suggestions.",
					),
				},
				"editor.suggest.showTypeParameters": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showTypeParameters",
						"When enabled IntelliSense shows `typeParameter`-suggestions.",
					),
				},
				"editor.suggest.showSnippets": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showSnippets",
						"When enabled IntelliSense shows `snippet`-suggestions.",
					),
				},
				"editor.suggest.showUsers": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showUsers",
						"When enabled IntelliSense shows `user`-suggestions.",
					),
				},
				"editor.suggest.showIssues": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showIssues",
						"When enabled IntelliSense shows `issues`-suggestions.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				insertMode: St(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
				filterGraceful: re(t.filterGraceful, this.defaultValue.filterGraceful),
				snippetsPreventQuickSuggestions: re(
					t.snippetsPreventQuickSuggestions,
					this.defaultValue.filterGraceful,
				),
				localityBonus: re(t.localityBonus, this.defaultValue.localityBonus),
				shareSuggestSelections: re(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
				selectionMode: St(t.selectionMode, this.defaultValue.selectionMode, [
					"always",
					"never",
					"whenQuickSuggestion",
					"whenTriggerCharacter",
				]),
				showIcons: re(t.showIcons, this.defaultValue.showIcons),
				showStatusBar: re(t.showStatusBar, this.defaultValue.showStatusBar),
				preview: re(t.preview, this.defaultValue.preview),
				previewMode: St(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
				showInlineDetails: re(t.showInlineDetails, this.defaultValue.showInlineDetails),
				showMethods: re(t.showMethods, this.defaultValue.showMethods),
				showFunctions: re(t.showFunctions, this.defaultValue.showFunctions),
				showConstructors: re(t.showConstructors, this.defaultValue.showConstructors),
				showDeprecated: re(t.showDeprecated, this.defaultValue.showDeprecated),
				matchOnWordStartOnly: re(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
				showFields: re(t.showFields, this.defaultValue.showFields),
				showVariables: re(t.showVariables, this.defaultValue.showVariables),
				showClasses: re(t.showClasses, this.defaultValue.showClasses),
				showStructs: re(t.showStructs, this.defaultValue.showStructs),
				showInterfaces: re(t.showInterfaces, this.defaultValue.showInterfaces),
				showModules: re(t.showModules, this.defaultValue.showModules),
				showProperties: re(t.showProperties, this.defaultValue.showProperties),
				showEvents: re(t.showEvents, this.defaultValue.showEvents),
				showOperators: re(t.showOperators, this.defaultValue.showOperators),
				showUnits: re(t.showUnits, this.defaultValue.showUnits),
				showValues: re(t.showValues, this.defaultValue.showValues),
				showConstants: re(t.showConstants, this.defaultValue.showConstants),
				showEnums: re(t.showEnums, this.defaultValue.showEnums),
				showEnumMembers: re(t.showEnumMembers, this.defaultValue.showEnumMembers),
				showKeywords: re(t.showKeywords, this.defaultValue.showKeywords),
				showWords: re(t.showWords, this.defaultValue.showWords),
				showColors: re(t.showColors, this.defaultValue.showColors),
				showFiles: re(t.showFiles, this.defaultValue.showFiles),
				showReferences: re(t.showReferences, this.defaultValue.showReferences),
				showFolders: re(t.showFolders, this.defaultValue.showFolders),
				showTypeParameters: re(t.showTypeParameters, this.defaultValue.showTypeParameters),
				showSnippets: re(t.showSnippets, this.defaultValue.showSnippets),
				showUsers: re(t.showUsers, this.defaultValue.showUsers),
				showIssues: re(t.showIssues, this.defaultValue.showIssues),
			}
		}
	},
	Jw = class extends pt {
		constructor() {
			super(
				118,
				"smartSelect",
				{ selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 },
				{
					"editor.smartSelect.selectLeadingAndTrailingWhitespace": {
						description: p(
							"selectLeadingAndTrailingWhitespace",
							"Whether leading and trailing whitespace should always be selected.",
						),
						default: !0,
						type: "boolean",
					},
					"editor.smartSelect.selectSubwords": {
						description: p(
							"selectSubwords",
							"Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected.",
						),
						default: !0,
						type: "boolean",
					},
				},
			)
		}
		validate(e) {
			return !e || typeof e != "object"
				? this.defaultValue
				: {
						selectLeadingAndTrailingWhitespace: re(
							e.selectLeadingAndTrailingWhitespace,
							this.defaultValue.selectLeadingAndTrailingWhitespace,
						),
						selectSubwords: re(e.selectSubwords, this.defaultValue.selectSubwords),
					}
		}
	},
	Xw = class extends pt {
		constructor() {
			let e = []
			super(135, "wordSegmenterLocales", e, {
				anyOf: [
					{
						description: p(
							"wordSegmenterLocales",
							"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).",
						),
						type: "string",
					},
					{
						description: p(
							"wordSegmenterLocales",
							"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).",
						),
						type: "array",
						items: { type: "string" },
					},
				],
			})
		}
		validate(e) {
			if ((typeof e == "string" && (e = [e]), Array.isArray(e))) {
				let t = []
				for (let n of e)
					if (typeof n == "string")
						try {
							Intl.Segmenter.supportedLocalesOf(n).length > 0 && t.push(n)
						} catch {}
				return t
			}
			return this.defaultValue
		}
	}
var Yw = class extends pt {
		constructor() {
			super(143, "wrappingIndent", 1, {
				"editor.wrappingIndent": {
					type: "string",
					enum: ["none", "same", "indent", "deepIndent"],
					enumDescriptions: [
						p("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
						p("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
						p("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
						p("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent."),
					],
					description: p("wrappingIndent", "Controls the indentation of wrapped lines."),
					default: "same",
				},
			})
		}
		validate(e) {
			switch (e) {
				case "none":
					return 0
				case "same":
					return 1
				case "indent":
					return 2
				case "deepIndent":
					return 3
			}
			return 1
		}
		compute(e, t, n) {
			return t.get(2) === 2 ? 0 : n
		}
	},
	Zw = class extends os {
		constructor() {
			super(152)
		}
		compute(e, t, n) {
			let r = t.get(151)
			return {
				isDominatedByLongLines: e.isDominatedByLongLines,
				isWordWrapMinified: r.isWordWrapMinified,
				isViewportWrapping: r.isViewportWrapping,
				wrappingColumn: r.wrappingColumn,
			}
		}
	},
	eP = class extends pt {
		constructor() {
			let e = { enabled: !0, showDropSelector: "afterDrop" }
			super(36, "dropIntoEditor", e, {
				"editor.dropIntoEditor.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"dropIntoEditor.enabled",
						"Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).",
					),
				},
				"editor.dropIntoEditor.showDropSelector": {
					type: "string",
					markdownDescription: p(
						"dropIntoEditor.showDropSelector",
						"Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped.",
					),
					enum: ["afterDrop", "never"],
					enumDescriptions: [
						p(
							"dropIntoEditor.showDropSelector.afterDrop",
							"Show the drop selector widget after a file is dropped into the editor.",
						),
						p(
							"dropIntoEditor.showDropSelector.never",
							"Never show the drop selector widget. Instead the default drop provider is always used.",
						),
					],
					default: "afterDrop",
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				showDropSelector: St(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"]),
			}
		}
	},
	tP = class extends pt {
		constructor() {
			let e = { enabled: !0, showPasteSelector: "afterPaste" }
			super(89, "pasteAs", e, {
				"editor.pasteAs.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"pasteAs.enabled",
						"Controls whether you can paste content in different ways.",
					),
				},
				"editor.pasteAs.showPasteSelector": {
					type: "string",
					markdownDescription: p(
						"pasteAs.showPasteSelector",
						"Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted.",
					),
					enum: ["afterPaste", "never"],
					enumDescriptions: [
						p(
							"pasteAs.showPasteSelector.afterPaste",
							"Show the paste selector widget after content is pasted into the editor.",
						),
						p(
							"pasteAs.showPasteSelector.never",
							"Never show the paste selector widget. Instead the default pasting behavior is always used.",
						),
					],
					default: "afterPaste",
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				showPasteSelector: St(t.showPasteSelector, this.defaultValue.showPasteSelector, [
					"afterPaste",
					"never",
				]),
			}
		}
	},
	L5 = "Consolas, 'Courier New', monospace",
	M5 = "Menlo, Monaco, 'Courier New', monospace",
	F5 = "'Droid Sans Mono', 'monospace', monospace",
	rs = {
		fontFamily: st ? M5 : Ve ? F5 : L5,
		fontWeight: "normal",
		fontSize: st ? 12 : 14,
		lineHeight: 0,
		letterSpacing: 0,
	},
	N5 = []
function F(o) {
	return (N5[o.id] = o), o
}
var sj = {
	acceptSuggestionOnCommitCharacter: F(
		new Le(0, "acceptSuggestionOnCommitCharacter", !0, {
			markdownDescription: p(
				"acceptSuggestionOnCommitCharacter",
				"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.",
			),
		}),
	),
	acceptSuggestionOnEnter: F(
		new ht(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
			markdownEnumDescriptions: [
				"",
				p(
					"acceptSuggestionOnEnterSmart",
					"Only accept a suggestion with `Enter` when it makes a textual change.",
				),
				"",
			],
			markdownDescription: p(
				"acceptSuggestionOnEnter",
				"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.",
			),
		}),
	),
	accessibilitySupport: F(new fw()),
	accessibilityPageSize: F(
		new tt(3, "accessibilityPageSize", 500, 1, 1073741824, {
			description: p(
				"accessibilityPageSize",
				"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.",
			),
			tags: ["accessibility"],
		}),
	),
	ariaLabel: F(new Qn(4, "ariaLabel", p("editorViewAccessibleLabel", "Editor content"))),
	ariaRequired: F(new Le(5, "ariaRequired", !1, void 0)),
	screenReaderAnnounceInlineSuggestion: F(
		new Le(8, "screenReaderAnnounceInlineSuggestion", !0, {
			description: p(
				"screenReaderAnnounceInlineSuggestion",
				"Control whether inline suggestions are announced by a screen reader.",
			),
			tags: ["accessibility"],
		}),
	),
	autoClosingBrackets: F(
		new ht(
			6,
			"autoClosingBrackets",
			"languageDefined",
			["always", "languageDefined", "beforeWhitespace", "never"],
			{
				enumDescriptions: [
					"",
					p(
						"editor.autoClosingBrackets.languageDefined",
						"Use language configurations to determine when to autoclose brackets.",
					),
					p(
						"editor.autoClosingBrackets.beforeWhitespace",
						"Autoclose brackets only when the cursor is to the left of whitespace.",
					),
					"",
				],
				description: p(
					"autoClosingBrackets",
					"Controls whether the editor should automatically close brackets after the user adds an opening bracket.",
				),
			},
		),
	),
	autoClosingComments: F(
		new ht(
			7,
			"autoClosingComments",
			"languageDefined",
			["always", "languageDefined", "beforeWhitespace", "never"],
			{
				enumDescriptions: [
					"",
					p(
						"editor.autoClosingComments.languageDefined",
						"Use language configurations to determine when to autoclose comments.",
					),
					p(
						"editor.autoClosingComments.beforeWhitespace",
						"Autoclose comments only when the cursor is to the left of whitespace.",
					),
					"",
				],
				description: p(
					"autoClosingComments",
					"Controls whether the editor should automatically close comments after the user adds an opening comment.",
				),
			},
		),
	),
	autoClosingDelete: F(
		new ht(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingDelete.auto",
					"Remove adjacent closing quotes or brackets only if they were automatically inserted.",
				),
				"",
			],
			description: p(
				"autoClosingDelete",
				"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.",
			),
		}),
	),
	autoClosingOvertype: F(
		new ht(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingOvertype.auto",
					"Type over closing quotes or brackets only if they were automatically inserted.",
				),
				"",
			],
			description: p(
				"autoClosingOvertype",
				"Controls whether the editor should type over closing quotes or brackets.",
			),
		}),
	),
	autoClosingQuotes: F(
		new ht(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingQuotes.languageDefined",
					"Use language configurations to determine when to autoclose quotes.",
				),
				p(
					"editor.autoClosingQuotes.beforeWhitespace",
					"Autoclose quotes only when the cursor is to the left of whitespace.",
				),
				"",
			],
			description: p(
				"autoClosingQuotes",
				"Controls whether the editor should automatically close quotes after the user adds an opening quote.",
			),
		}),
	),
	autoIndent: F(
		new $l(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], R5, {
			enumDescriptions: [
				p("editor.autoIndent.none", "The editor will not insert indentation automatically."),
				p("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
				p(
					"editor.autoIndent.brackets",
					"The editor will keep the current line's indentation and honor language defined brackets.",
				),
				p(
					"editor.autoIndent.advanced",
					"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.",
				),
				p(
					"editor.autoIndent.full",
					"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.",
				),
			],
			description: p(
				"autoIndent",
				"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.",
			),
		}),
	),
	automaticLayout: F(new Le(13, "automaticLayout", !1)),
	autoSurround: F(
		new ht(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
			enumDescriptions: [
				p(
					"editor.autoSurround.languageDefined",
					"Use language configurations to determine when to automatically surround selections.",
				),
				p("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
				p("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
				"",
			],
			description: p(
				"autoSurround",
				"Controls whether the editor should automatically surround selections when typing quotes or brackets.",
			),
		}),
	),
	bracketPairColorization: F(new jw()),
	bracketPairGuides: F(new Gw()),
	stickyTabStops: F(
		new Le(121, "stickyTabStops", !1, {
			description: p(
				"stickyTabStops",
				"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.",
			),
		}),
	),
	codeLens: F(
		new Le(17, "codeLens", !0, { description: p("codeLens", "Controls whether the editor shows CodeLens.") }),
	),
	codeLensFontFamily: F(
		new Qn(18, "codeLensFontFamily", "", {
			description: p("codeLensFontFamily", "Controls the font family for CodeLens."),
		}),
	),
	codeLensFontSize: F(
		new tt(19, "codeLensFontSize", 0, 0, 100, {
			type: "number",
			default: 0,
			minimum: 0,
			maximum: 100,
			markdownDescription: p(
				"codeLensFontSize",
				"Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.",
			),
		}),
	),
	colorDecorators: F(
		new Le(20, "colorDecorators", !0, {
			description: p(
				"colorDecorators",
				"Controls whether the editor should render the inline color decorators and color picker.",
			),
		}),
	),
	colorDecoratorActivatedOn: F(
		new ht(154, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
			enumDescriptions: [
				p(
					"editor.colorDecoratorActivatedOn.clickAndHover",
					"Make the color picker appear both on click and hover of the color decorator",
				),
				p(
					"editor.colorDecoratorActivatedOn.hover",
					"Make the color picker appear on hover of the color decorator",
				),
				p(
					"editor.colorDecoratorActivatedOn.click",
					"Make the color picker appear on click of the color decorator",
				),
			],
			description: p(
				"colorDecoratorActivatedOn",
				"Controls the condition to make a color picker appear from a color decorator.",
			),
		}),
	),
	colorDecoratorsLimit: F(
		new tt(21, "colorDecoratorsLimit", 500, 1, 1e6, {
			markdownDescription: p(
				"colorDecoratorsLimit",
				"Controls the max number of color decorators that can be rendered in an editor at once.",
			),
		}),
	),
	columnSelection: F(
		new Le(22, "columnSelection", !1, {
			description: p(
				"columnSelection",
				"Enable that the selection with the mouse and keys is doing column selection.",
			),
		}),
	),
	comments: F(new gw()),
	contextmenu: F(new Le(24, "contextmenu", !0)),
	copyWithSyntaxHighlighting: F(
		new Le(25, "copyWithSyntaxHighlighting", !0, {
			description: p(
				"copyWithSyntaxHighlighting",
				"Controls whether syntax highlighting should be copied into the clipboard.",
			),
		}),
	),
	cursorBlinking: F(
		new $l(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], A5, {
			description: p("cursorBlinking", "Control the cursor animation style."),
		}),
	),
	cursorSmoothCaretAnimation: F(
		new ht(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
			enumDescriptions: [
				p("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
				p(
					"cursorSmoothCaretAnimation.explicit",
					"Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture.",
				),
				p("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled."),
			],
			description: p(
				"cursorSmoothCaretAnimation",
				"Controls whether the smooth caret animation should be enabled.",
			),
		}),
	),
	cursorStyle: F(
		new $l(
			28,
			"cursorStyle",
			1,
			"line",
			["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
			HO,
			{ description: p("cursorStyle", "Controls the cursor style in insert input mode.") },
		),
	),
	overtypeCursorStyle: F(
		new $l(
			84,
			"overtypeCursorStyle",
			2,
			"block",
			["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
			HO,
			{ description: p("overtypeCursorStyle", "Controls the cursor style in overtype input mode.") },
		),
	),
	cursorSurroundingLines: F(
		new tt(29, "cursorSurroundingLines", 0, 0, 1073741824, {
			description: p(
				"cursorSurroundingLines",
				"Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.",
			),
		}),
	),
	cursorSurroundingLinesStyle: F(
		new ht(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
			enumDescriptions: [
				p(
					"cursorSurroundingLinesStyle.default",
					"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.",
				),
				p("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always."),
			],
			markdownDescription: p(
				"cursorSurroundingLinesStyle",
				"Controls when `#editor.cursorSurroundingLines#` should be enforced.",
			),
		}),
	),
	cursorWidth: F(
		new tt(31, "cursorWidth", 0, 0, 1073741824, {
			markdownDescription: p(
				"cursorWidth",
				"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.",
			),
		}),
	),
	disableLayerHinting: F(new Le(32, "disableLayerHinting", !1)),
	disableMonospaceOptimizations: F(new Le(33, "disableMonospaceOptimizations", !1)),
	domReadOnly: F(new Le(34, "domReadOnly", !1)),
	dragAndDrop: F(
		new Le(35, "dragAndDrop", !0, {
			description: p(
				"dragAndDrop",
				"Controls whether the editor should allow moving selections via drag and drop.",
			),
		}),
	),
	emptySelectionClipboard: F(new vw()),
	dropIntoEditor: F(new eP()),
	experimentalEditContextEnabled: F(
		new Le(37, "experimentalEditContextEnabled", nb.quality !== "stable", {
			description: p(
				"experimentalEditContextEnabled",
				"Sets whether the new experimental edit context should be used instead of the text area.",
			),
			included: of || uv || av,
		}),
	),
	stickyScroll: F(new Rw()),
	experimentalGpuAcceleration: F(
		new ht(39, "experimentalGpuAcceleration", "off", ["off", "on"], {
			tags: ["experimental"],
			enumDescriptions: [
				p("experimentalGpuAcceleration.off", "Use regular DOM-based rendering."),
				p("experimentalGpuAcceleration.on", "Use GPU acceleration."),
			],
			description: p(
				"experimentalGpuAcceleration",
				"Controls whether to use the experimental GPU acceleration to render the editor.",
			),
		}),
	),
	experimentalWhitespaceRendering: F(
		new ht(40, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
			enumDescriptions: [
				p("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
				p("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
				p("experimentalWhitespaceRendering.off", "Use the stable rendering method."),
			],
			description: p(
				"experimentalWhitespaceRendering",
				"Controls whether whitespace is rendered with a new, experimental method.",
			),
		}),
	),
	extraEditorClassName: F(new Qn(41, "extraEditorClassName", "")),
	fastScrollSensitivity: F(
		new lo(42, "fastScrollSensitivity", 5, (o) => (o <= 0 ? 5 : o), {
			markdownDescription: p("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`."),
		}),
	),
	find: F(new bw()),
	fixedOverflowWidgets: F(new Le(44, "fixedOverflowWidgets", !1)),
	folding: F(
		new Le(45, "folding", !0, {
			description: p("folding", "Controls whether the editor has code folding enabled."),
		}),
	),
	foldingStrategy: F(
		new ht(46, "foldingStrategy", "auto", ["auto", "indentation"], {
			enumDescriptions: [
				p(
					"foldingStrategy.auto",
					"Use a language-specific folding strategy if available, else the indentation-based one.",
				),
				p("foldingStrategy.indentation", "Use the indentation-based folding strategy."),
			],
			description: p("foldingStrategy", "Controls the strategy for computing folding ranges."),
		}),
	),
	foldingHighlight: F(
		new Le(47, "foldingHighlight", !0, {
			description: p("foldingHighlight", "Controls whether the editor should highlight folded ranges."),
		}),
	),
	foldingImportsByDefault: F(
		new Le(48, "foldingImportsByDefault", !1, {
			description: p(
				"foldingImportsByDefault",
				"Controls whether the editor automatically collapses import ranges.",
			),
		}),
	),
	foldingMaximumRegions: F(
		new tt(49, "foldingMaximumRegions", 5e3, 10, 65e3, {
			description: p(
				"foldingMaximumRegions",
				"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.",
			),
		}),
	),
	unfoldOnClickAfterEndOfLine: F(
		new Le(50, "unfoldOnClickAfterEndOfLine", !1, {
			description: p(
				"unfoldOnClickAfterEndOfLine",
				"Controls whether clicking on the empty content after a folded line will unfold the line.",
			),
		}),
	),
	fontFamily: F(
		new Qn(51, "fontFamily", rs.fontFamily, { description: p("fontFamily", "Controls the font family.") }),
	),
	fontInfo: F(new xw()),
	fontLigatures2: F(new yw()),
	fontSize: F(new Tw()),
	fontWeight: F(new Ew()),
	fontVariations: F(new Iw()),
	formatOnPaste: F(
		new Le(57, "formatOnPaste", !1, {
			description: p(
				"formatOnPaste",
				"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.",
			),
		}),
	),
	formatOnType: F(
		new Le(58, "formatOnType", !1, {
			description: p(
				"formatOnType",
				"Controls whether the editor should automatically format the line after typing.",
			),
		}),
	),
	glyphMargin: F(
		new Le(59, "glyphMargin", !0, {
			description: p(
				"glyphMargin",
				"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.",
			),
		}),
	),
	gotoLocation: F(new ww()),
	hideCursorInOverviewRuler: F(
		new Le(61, "hideCursorInOverviewRuler", !1, {
			description: p(
				"hideCursorInOverviewRuler",
				"Controls whether the cursor should be hidden in the overview ruler.",
			),
		}),
	),
	hover: F(new Pw()),
	inDiffEditor: F(new Le(63, "inDiffEditor", !1)),
	letterSpacing: F(
		new lo(65, "letterSpacing", rs.letterSpacing, (o) => lo.clamp(o, -5, 20), {
			description: p("letterSpacing", "Controls the letter spacing in pixels."),
		}),
	),
	lightbulb: F(new kw()),
	lineDecorationsWidth: F(new Ow()),
	lineHeight: F(new Lw()),
	lineNumbers: F(new Vw()),
	lineNumbersMinChars: F(new tt(70, "lineNumbersMinChars", 5, 1, 300)),
	linkedEditing: F(
		new Le(71, "linkedEditing", !1, {
			description: p(
				"linkedEditing",
				"Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.",
			),
		}),
	),
	links: F(
		new Le(72, "links", !0, {
			description: p("links", "Controls whether the editor should detect links and make them clickable."),
		}),
	),
	matchBrackets: F(
		new ht(73, "matchBrackets", "always", ["always", "near", "never"], {
			description: p("matchBrackets", "Highlight matching brackets."),
		}),
	),
	minimap: F(new Mw()),
	mouseStyle: F(new ht(75, "mouseStyle", "text", ["text", "default", "copy"])),
	mouseWheelScrollSensitivity: F(
		new lo(76, "mouseWheelScrollSensitivity", 1, (o) => (o === 0 ? 1 : o), {
			markdownDescription: p(
				"mouseWheelScrollSensitivity",
				"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.",
			),
		}),
	),
	mouseWheelZoom: F(
		new Le(77, "mouseWheelZoom", !1, {
			markdownDescription: st
				? p("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.")
				: p("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`."),
		}),
	),
	multiCursorMergeOverlapping: F(
		new Le(78, "multiCursorMergeOverlapping", !0, {
			description: p("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping."),
		}),
	),
	multiCursorModifier: F(
		new $l(79, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], O5, {
			markdownEnumDescriptions: [
				p("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
				p("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS."),
			],
			markdownDescription: p(
				{
					key: "multiCursorModifier",
					comment: [
						"- `ctrlCmd` refers to a value the setting can take and should not be localized.",
						"- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.",
					],
				},
				"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).",
			),
		}),
	),
	multiCursorPaste: F(
		new ht(80, "multiCursorPaste", "spread", ["spread", "full"], {
			markdownEnumDescriptions: [
				p("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
				p("multiCursorPaste.full", "Each cursor pastes the full text."),
			],
			markdownDescription: p(
				"multiCursorPaste",
				"Controls pasting when the line count of the pasted text matches the cursor count.",
			),
		}),
	),
	multiCursorLimit: F(
		new tt(81, "multiCursorLimit", 1e4, 1, 1e5, {
			markdownDescription: p(
				"multiCursorLimit",
				"Controls the max number of cursors that can be in an active editor at once.",
			),
		}),
	),
	occurrencesHighlight: F(
		new ht(82, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
			markdownEnumDescriptions: [
				p("occurrencesHighlight.off", "Does not highlight occurrences."),
				p("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
				p(
					"occurrencesHighlight.multiFile",
					"Experimental: Highlights occurrences across all valid open files.",
				),
			],
			markdownDescription: p(
				"occurrencesHighlight",
				"Controls whether occurrences should be highlighted across open files.",
			),
		}),
	),
	occurrencesHighlightDelay: F(
		new tt(83, "occurrencesHighlightDelay", 0, 0, 2e3, {
			description: p(
				"occurrencesHighlightDelay",
				"Controls the delay in milliseconds after which occurrences are highlighted.",
			),
			tags: ["preview"],
		}),
	),
	overtypeOnPaste: F(
		new Le(85, "overtypeOnPaste", !0, {
			description: p("overtypeOnPaste", "Controls whether pasting should overtype."),
		}),
	),
	overviewRulerBorder: F(
		new Le(86, "overviewRulerBorder", !0, {
			description: p(
				"overviewRulerBorder",
				"Controls whether a border should be drawn around the overview ruler.",
			),
		}),
	),
	overviewRulerLanes: F(new tt(87, "overviewRulerLanes", 3, 0, 3)),
	padding: F(new Fw()),
	pasteAs: F(new tP()),
	parameterHints: F(new Nw()),
	peekWidgetDefaultFocus: F(
		new ht(91, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
			enumDescriptions: [
				p("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
				p("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek"),
			],
			description: p(
				"peekWidgetDefaultFocus",
				"Controls whether to focus the inline editor or the tree in the peek widget.",
			),
		}),
	),
	placeholder: F(new Hw()),
	definitionLinkOpensInPeek: F(
		new Le(93, "definitionLinkOpensInPeek", !1, {
			description: p(
				"definitionLinkOpensInPeek",
				"Controls whether the Go to Definition mouse gesture always opens the peek widget.",
			),
		}),
	),
	quickSuggestions: F(new Ww()),
	quickSuggestionsDelay: F(
		new tt(95, "quickSuggestionsDelay", 10, 0, 1073741824, {
			description: p(
				"quickSuggestionsDelay",
				"Controls the delay in milliseconds after which quick suggestions will show up.",
			),
		}),
	),
	readOnly: F(new Le(96, "readOnly", !1)),
	readOnlyMessage: F(new $w()),
	renameOnType: F(
		new Le(98, "renameOnType", !1, {
			description: p("renameOnType", "Controls whether the editor auto renames on type."),
			markdownDeprecationMessage: p("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead."),
		}),
	),
	renderControlCharacters: F(
		new Le(99, "renderControlCharacters", !0, {
			description: p("renderControlCharacters", "Controls whether the editor should render control characters."),
			restricted: !0,
		}),
	),
	renderFinalNewline: F(
		new ht(100, "renderFinalNewline", Ve ? "dimmed" : "on", ["off", "on", "dimmed"], {
			description: p("renderFinalNewline", "Render last line number when the file ends with a newline."),
		}),
	),
	renderLineHighlight: F(
		new ht(101, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
			enumDescriptions: [
				"",
				"",
				"",
				p("renderLineHighlight.all", "Highlights both the gutter and the current line."),
			],
			description: p("renderLineHighlight", "Controls how the editor should render the current line highlight."),
		}),
	),
	renderLineHighlightOnlyWhenFocus: F(
		new Le(102, "renderLineHighlightOnlyWhenFocus", !1, {
			description: p(
				"renderLineHighlightOnlyWhenFocus",
				"Controls if the editor should render the current line highlight only when the editor is focused.",
			),
		}),
	),
	renderValidationDecorations: F(new ht(103, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
	renderWhitespace: F(
		new ht(104, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
			enumDescriptions: [
				"",
				p("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
				p("renderWhitespace.selection", "Render whitespace characters only on selected text."),
				p("renderWhitespace.trailing", "Render only trailing whitespace characters."),
				"",
			],
			description: p("renderWhitespace", "Controls how the editor should render whitespace characters."),
		}),
	),
	revealHorizontalRightPadding: F(new tt(105, "revealHorizontalRightPadding", 15, 0, 1e3)),
	roundedSelection: F(
		new Le(106, "roundedSelection", !0, {
			description: p("roundedSelection", "Controls whether selections should have rounded corners."),
		}),
	),
	rulers: F(new Bw()),
	scrollbar: F(new zw()),
	scrollBeyondLastColumn: F(
		new tt(109, "scrollBeyondLastColumn", 4, 0, 1073741824, {
			description: p(
				"scrollBeyondLastColumn",
				"Controls the number of extra characters beyond which the editor will scroll horizontally.",
			),
		}),
	),
	scrollBeyondLastLine: F(
		new Le(110, "scrollBeyondLastLine", !0, {
			description: p("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line."),
		}),
	),
	scrollPredominantAxis: F(
		new Le(111, "scrollPredominantAxis", !0, {
			description: p(
				"scrollPredominantAxis",
				"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.",
			),
		}),
	),
	selectionClipboard: F(
		new Le(112, "selectionClipboard", !0, {
			description: p("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
			included: Ve,
		}),
	),
	selectionHighlight: F(
		new Le(113, "selectionHighlight", !0, {
			description: p(
				"selectionHighlight",
				"Controls whether the editor should highlight matches similar to the selection.",
			),
		}),
	),
	selectOnLineNumbers: F(new Le(114, "selectOnLineNumbers", !0)),
	showFoldingControls: F(
		new ht(115, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
			enumDescriptions: [
				p("showFoldingControls.always", "Always show the folding controls."),
				p("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
				p("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter."),
			],
			description: p("showFoldingControls", "Controls when the folding controls on the gutter are shown."),
		}),
	),
	showUnused: F(
		new Le(116, "showUnused", !0, { description: p("showUnused", "Controls fading out of unused code.") }),
	),
	showDeprecated: F(
		new Le(145, "showDeprecated", !0, {
			description: p("showDeprecated", "Controls strikethrough deprecated variables."),
		}),
	),
	inlayHints: F(new Aw()),
	snippetSuggestions: F(
		new ht(117, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
			enumDescriptions: [
				p("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
				p("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
				p("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
				p("snippetSuggestions.none", "Do not show snippet suggestions."),
			],
			description: p(
				"snippetSuggestions",
				"Controls whether snippets are shown with other suggestions and how they are sorted.",
			),
		}),
	),
	smartSelect: F(new Jw()),
	smoothScrolling: F(
		new Le(119, "smoothScrolling", !1, {
			description: p("smoothScrolling", "Controls whether the editor will scroll using an animation."),
		}),
	),
	stopRenderingLineAfter: F(new tt(122, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
	suggest: F(new Qw()),
	inlineSuggest: F(new Kw()),
	inlineCompletionsAccessibilityVerbose: F(
		new Le(155, "inlineCompletionsAccessibilityVerbose", !1, {
			description: p(
				"inlineCompletionsAccessibilityVerbose",
				"Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.",
			),
		}),
	),
	suggestFontSize: F(
		new tt(124, "suggestFontSize", 0, 0, 1e3, {
			markdownDescription: p(
				"suggestFontSize",
				"Font size for the suggest widget. When set to {0}, the value of {1} is used.",
				"`0`",
				"`#editor.fontSize#`",
			),
		}),
	),
	suggestLineHeight: F(
		new tt(125, "suggestLineHeight", 0, 0, 1e3, {
			markdownDescription: p(
				"suggestLineHeight",
				"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.",
				"`0`",
				"`#editor.lineHeight#`",
			),
		}),
	),
	suggestOnTriggerCharacters: F(
		new Le(126, "suggestOnTriggerCharacters", !0, {
			description: p(
				"suggestOnTriggerCharacters",
				"Controls whether suggestions should automatically show up when typing trigger characters.",
			),
		}),
	),
	suggestSelection: F(
		new ht(127, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
			markdownEnumDescriptions: [
				p("suggestSelection.first", "Always select the first suggestion."),
				p(
					"suggestSelection.recentlyUsed",
					"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.",
				),
				p(
					"suggestSelection.recentlyUsedByPrefix",
					"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.",
				),
			],
			description: p(
				"suggestSelection",
				"Controls how suggestions are pre-selected when showing the suggest list.",
			),
		}),
	),
	tabCompletion: F(
		new ht(128, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
			enumDescriptions: [
				p("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
				p("tabCompletion.off", "Disable tab completions."),
				p(
					"tabCompletion.onlySnippets",
					"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.",
				),
			],
			description: p("tabCompletion", "Enables tab completions."),
		}),
	),
	tabIndex: F(new tt(129, "tabIndex", 0, -1, 1073741824)),
	unicodeHighlight: F(new qw()),
	unusualLineTerminators: F(
		new ht(131, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
			enumDescriptions: [
				p("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
				p("unusualLineTerminators.off", "Unusual line terminators are ignored."),
				p("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed."),
			],
			description: p("unusualLineTerminators", "Remove unusual line terminators that might cause problems."),
		}),
	),
	useShadowDOM: F(new Le(132, "useShadowDOM", !0)),
	useTabStops: F(
		new Le(133, "useTabStops", !0, {
			description: p("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops."),
		}),
	),
	wordBreak: F(
		new ht(134, "wordBreak", "normal", ["normal", "keepAll"], {
			markdownEnumDescriptions: [
				p("wordBreak.normal", "Use the default line break rule."),
				p(
					"wordBreak.keepAll",
					"Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.",
				),
			],
			description: p("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text."),
		}),
	),
	wordSegmenterLocales: F(new Xw()),
	wordSeparators: F(
		new Qn(136, "wordSeparators", aw, {
			description: p(
				"wordSeparators",
				"Characters that will be used as word separators when doing word related navigations or operations.",
			),
		}),
	),
	wordWrap: F(
		new ht(137, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
			markdownEnumDescriptions: [
				p("wordWrap.off", "Lines will never wrap."),
				p("wordWrap.on", "Lines will wrap at the viewport width."),
				p(
					{
						key: "wordWrap.wordWrapColumn",
						comment: [
							"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
						],
					},
					"Lines will wrap at `#editor.wordWrapColumn#`.",
				),
				p(
					{
						key: "wordWrap.bounded",
						comment: [
							"- viewport means the edge of the visible window size.",
							"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
						],
					},
					"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.",
				),
			],
			description: p(
				{
					key: "wordWrap",
					comment: [
						"- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
						"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
					],
				},
				"Controls how lines should wrap.",
			),
		}),
	),
	wordWrapBreakAfterCharacters: F(
		new Qn(
			138,
			"wordWrapBreakAfterCharacters",
			" 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63",
		),
	),
	wordWrapBreakBeforeCharacters: F(
		new Qn(
			139,
			"wordWrapBreakBeforeCharacters",
			"([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B",
		),
	),
	wordWrapColumn: F(
		new tt(140, "wordWrapColumn", 80, 1, 1073741824, {
			markdownDescription: p(
				{
					key: "wordWrapColumn",
					comment: [
						"- `editor.wordWrap` refers to a different setting and should not be localized.",
						"- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized.",
					],
				},
				"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.",
			),
		}),
	),
	wordWrapOverride1: F(new ht(141, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
	wordWrapOverride2: F(new ht(142, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
	effectiveCursorStyle: F(new Cw()),
	editorClassName: F(new hw()),
	defaultColorDecorators: F(
		new ht(153, "defaultColorDecorators", "auto", ["auto", "always", "never"], {
			enumDescriptions: [
				p(
					"editor.defaultColorDecorators.auto",
					"Show default color decorators only when no extension provides colors decorators.",
				),
				p("editor.defaultColorDecorators.always", "Always show default color decorators."),
				p("editor.defaultColorDecorators.never", "Never show default color decorators."),
			],
			description: p(
				"defaultColorDecorators",
				"Controls whether inline color decorations should be shown using the default document color provider.",
			),
		}),
	),
	pixelRatio: F(new Uw()),
	tabFocusMode: F(
		new Le(150, "tabFocusMode", !1, {
			markdownDescription: p(
				"tabFocusMode",
				"Controls whether the editor receives tabs or defers them to the workbench for navigation.",
			),
		}),
	),
	layoutInfo: F(new _w()),
	wrappingInfo: F(new Zw()),
	wrappingIndent: F(new Yw()),
	wrappingStrategy: F(new Dw()),
	effectiveExperimentalEditContextEnabled: F(new Sw()),
}
var rP = ((r) => (
		(r[(r.None = 0)] = "None"),
		(r[(r.Process = 1)] = "Process"),
		(r[(r.Output = 2)] = "Output"),
		(r[(r.Hybrid = 3)] = "Hybrid"),
		r
	))(rP || {}),
	VO = class o {
		static {
			this._n = 0
		}
		static mixin(e) {
			return (e._id = o._n++), e
		}
	}
var N = {
		MainThreadAuthentication: V("MainThreadAuthentication"),
		MainThreadBulkEdits: V("MainThreadBulkEdits"),
		MainThreadLanguageModels: V("MainThreadLanguageModels"),
		MainThreadEmbeddings: V("MainThreadEmbeddings"),
		MainThreadChatAgents2: V("MainThreadChatAgents2"),
		MainThreadCodeMapper: V("MainThreadCodeMapper"),
		MainThreadLanguageModelTools: V("MainThreadChatSkills"),
		MainThreadClipboard: V("MainThreadClipboard"),
		MainThreadCommands: V("MainThreadCommands"),
		MainThreadComments: V("MainThreadComments"),
		MainThreadConfiguration: V("MainThreadConfiguration"),
		MainThreadConsole: V("MainThreadConsole"),
		MainThreadDebugService: V("MainThreadDebugService"),
		MainThreadDecorations: V("MainThreadDecorations"),
		MainThreadDiagnostics: V("MainThreadDiagnostics"),
		MainThreadDialogs: V("MainThreadDiaglogs"),
		MainThreadDocuments: V("MainThreadDocuments"),
		MainThreadDocumentContentProviders: V("MainThreadDocumentContentProviders"),
		MainThreadTextEditors: V("MainThreadTextEditors"),
		MainThreadEditorInsets: V("MainThreadEditorInsets"),
		MainThreadEditorTabs: V("MainThreadEditorTabs"),
		MainThreadErrors: V("MainThreadErrors"),
		MainThreadTreeViews: V("MainThreadTreeViews"),
		MainThreadDownloadService: V("MainThreadDownloadService"),
		MainThreadLanguageFeatures: V("MainThreadLanguageFeatures"),
		MainThreadLanguages: V("MainThreadLanguages"),
		MainThreadLogger: V("MainThreadLogger"),
		MainThreadMessageService: V("MainThreadMessageService"),
		MainThreadOutputService: V("MainThreadOutputService"),
		MainThreadProgress: V("MainThreadProgress"),
		MainThreadQuickDiff: V("MainThreadQuickDiff"),
		MainThreadQuickOpen: V("MainThreadQuickOpen"),
		MainThreadStatusBar: V("MainThreadStatusBar"),
		MainThreadSecretState: V("MainThreadSecretState"),
		MainThreadStorage: V("MainThreadStorage"),
		MainThreadSpeech: V("MainThreadSpeechProvider"),
		MainThreadTelemetry: V("MainThreadTelemetry"),
		MainThreadTerminalService: V("MainThreadTerminalService"),
		MainThreadTerminalShellIntegration: V("MainThreadTerminalShellIntegration"),
		MainThreadWebviews: V("MainThreadWebviews"),
		MainThreadWebviewPanels: V("MainThreadWebviewPanels"),
		MainThreadWebviewViews: V("MainThreadWebviewViews"),
		MainThreadCustomEditors: V("MainThreadCustomEditors"),
		MainThreadUrls: V("MainThreadUrls"),
		MainThreadUriOpeners: V("MainThreadUriOpeners"),
		MainThreadProfileContentHandlers: V("MainThreadProfileContentHandlers"),
		MainThreadWorkspace: V("MainThreadWorkspace"),
		MainThreadFileSystem: V("MainThreadFileSystem"),
		MainThreadFileSystemEventService: V("MainThreadFileSystemEventService"),
		MainThreadExtensionService: V("MainThreadExtensionService"),
		MainThreadSCM: V("MainThreadSCM"),
		MainThreadSearch: V("MainThreadSearch"),
		MainThreadShare: V("MainThreadShare"),
		MainThreadTask: V("MainThreadTask"),
		MainThreadWindow: V("MainThreadWindow"),
		MainThreadLabelService: V("MainThreadLabelService"),
		MainThreadNotebook: V("MainThreadNotebook"),
		MainThreadNotebookDocuments: V("MainThreadNotebookDocumentsShape"),
		MainThreadNotebookEditors: V("MainThreadNotebookEditorsShape"),
		MainThreadNotebookKernels: V("MainThreadNotebookKernels"),
		MainThreadNotebookRenderers: V("MainThreadNotebookRenderers"),
		MainThreadInteractive: V("MainThreadInteractive"),
		MainThreadTheming: V("MainThreadTheming"),
		MainThreadTunnelService: V("MainThreadTunnelService"),
		MainThreadManagedSockets: V("MainThreadManagedSockets"),
		MainThreadTimeline: V("MainThreadTimeline"),
		MainThreadTesting: V("MainThreadTesting"),
		MainThreadLocalization: V("MainThreadLocalizationShape"),
		MainThreadMcp: V("MainThreadMcpShape"),
		MainThreadAiRelatedInformation: V("MainThreadAiRelatedInformation"),
		MainThreadAiEmbeddingVector: V("MainThreadAiEmbeddingVector"),
		MainThreadChatStatus: V("MainThreadChatStatus"),
	},
	de = {
		ExtHostCodeMapper: V("ExtHostCodeMapper"),
		ExtHostCommands: V("ExtHostCommands"),
		ExtHostConfiguration: V("ExtHostConfiguration"),
		ExtHostDiagnostics: V("ExtHostDiagnostics"),
		ExtHostDebugService: V("ExtHostDebugService"),
		ExtHostDecorations: V("ExtHostDecorations"),
		ExtHostDocumentsAndEditors: V("ExtHostDocumentsAndEditors"),
		ExtHostDocuments: V("ExtHostDocuments"),
		ExtHostDocumentContentProviders: V("ExtHostDocumentContentProviders"),
		ExtHostDocumentSaveParticipant: V("ExtHostDocumentSaveParticipant"),
		ExtHostEditors: V("ExtHostEditors"),
		ExtHostTreeViews: V("ExtHostTreeViews"),
		ExtHostFileSystem: V("ExtHostFileSystem"),
		ExtHostFileSystemInfo: V("ExtHostFileSystemInfo"),
		ExtHostFileSystemEventService: V("ExtHostFileSystemEventService"),
		ExtHostLanguages: V("ExtHostLanguages"),
		ExtHostLanguageFeatures: V("ExtHostLanguageFeatures"),
		ExtHostQuickOpen: V("ExtHostQuickOpen"),
		ExtHostQuickDiff: V("ExtHostQuickDiff"),
		ExtHostStatusBar: V("ExtHostStatusBar"),
		ExtHostShare: V("ExtHostShare"),
		ExtHostExtensionService: V("ExtHostExtensionService"),
		ExtHostLogLevelServiceShape: V("ExtHostLogLevelServiceShape"),
		ExtHostTerminalService: V("ExtHostTerminalService"),
		ExtHostTerminalShellIntegration: V("ExtHostTerminalShellIntegration"),
		ExtHostSCM: V("ExtHostSCM"),
		ExtHostSearch: V("ExtHostSearch"),
		ExtHostTask: V("ExtHostTask"),
		ExtHostWorkspace: V("ExtHostWorkspace"),
		ExtHostWindow: V("ExtHostWindow"),
		ExtHostWebviews: V("ExtHostWebviews"),
		ExtHostWebviewPanels: V("ExtHostWebviewPanels"),
		ExtHostCustomEditors: V("ExtHostCustomEditors"),
		ExtHostWebviewViews: V("ExtHostWebviewViews"),
		ExtHostEditorInsets: V("ExtHostEditorInsets"),
		ExtHostEditorTabs: V("ExtHostEditorTabs"),
		ExtHostProgress: V("ExtHostProgress"),
		ExtHostComments: V("ExtHostComments"),
		ExtHostSecretState: V("ExtHostSecretState"),
		ExtHostStorage: V("ExtHostStorage"),
		ExtHostUrls: V("ExtHostUrls"),
		ExtHostUriOpeners: V("ExtHostUriOpeners"),
		ExtHostProfileContentHandlers: V("ExtHostProfileContentHandlers"),
		ExtHostOutputService: V("ExtHostOutputService"),
		ExtHostLabelService: V("ExtHostLabelService"),
		ExtHostNotebook: V("ExtHostNotebook"),
		ExtHostNotebookDocuments: V("ExtHostNotebookDocuments"),
		ExtHostNotebookEditors: V("ExtHostNotebookEditors"),
		ExtHostNotebookKernels: V("ExtHostNotebookKernels"),
		ExtHostNotebookRenderers: V("ExtHostNotebookRenderers"),
		ExtHostNotebookDocumentSaveParticipant: V("ExtHostNotebookDocumentSaveParticipant"),
		ExtHostInteractive: V("ExtHostInteractive"),
		ExtHostChatAgents2: V("ExtHostChatAgents"),
		ExtHostLanguageModelTools: V("ExtHostChatSkills"),
		ExtHostChatProvider: V("ExtHostChatProvider"),
		ExtHostSpeech: V("ExtHostSpeech"),
		ExtHostEmbeddings: V("ExtHostEmbeddings"),
		ExtHostAiRelatedInformation: V("ExtHostAiRelatedInformation"),
		ExtHostAiEmbeddingVector: V("ExtHostAiEmbeddingVector"),
		ExtHostTheming: V("ExtHostTheming"),
		ExtHostTunnelService: V("ExtHostTunnelService"),
		ExtHostManagedSockets: V("ExtHostManagedSockets"),
		ExtHostAuthentication: V("ExtHostAuthentication"),
		ExtHostTimeline: V("ExtHostTimeline"),
		ExtHostTesting: V("ExtHostTesting"),
		ExtHostTelemetry: V("ExtHostTelemetry"),
		ExtHostLocalization: V("ExtHostLocalization"),
		ExtHostMcp: V("ExtHostMcp"),
	}
function zl(o) {
	if (!o) return
	let e = o.indexOf("+")
	return e < 0 ? o : o.substr(0, e)
}
var BO = [
	"AI",
	"Azure",
	"Chat",
	"Data Science",
	"Debuggers",
	"Extension Packs",
	"Education",
	"Formatters",
	"Keymaps",
	"Language Packs",
	"Linters",
	"Machine Learning",
	"Notebooks",
	"Programming Languages",
	"SCM Providers",
	"Snippets",
	"Testing",
	"Themes",
	"Visualization",
	"Other",
]
var we = class {
		constructor(e) {
			;(this.value = e), (this._lower = e.toLowerCase())
		}
		static equals(e, t) {
			if (typeof e > "u" || e === null) return typeof t > "u" || t === null
			if (typeof t > "u" || t === null) return !1
			if (typeof e == "string" || typeof t == "string") {
				let n = typeof e == "string" ? e : e.value,
					r = typeof t == "string" ? t : t.value
				return xn(n, r)
			}
			return e._lower === t._lower
		}
		static toKey(e) {
			return typeof e == "string" ? e.toLowerCase() : e._lower
		}
	},
	sr = class {
		constructor(e) {
			this._set = new Set()
			if (e) for (let t of e) this.add(t)
		}
		get size() {
			return this._set.size
		}
		add(e) {
			this._set.add(we.toKey(e))
		}
		delete(e) {
			return this._set.delete(we.toKey(e))
		}
		has(e) {
			return this._set.has(we.toKey(e))
		}
	},
	On = class {
		constructor() {
			this._map = new Map()
		}
		clear() {
			this._map.clear()
		}
		delete(e) {
			this._map.delete(we.toKey(e))
		}
		get(e) {
			return this._map.get(we.toKey(e))
		}
		has(e) {
			return this._map.has(we.toKey(e))
		}
		set(e, t) {
			this._map.set(we.toKey(e), t)
		}
		values() {
			return this._map.values()
		}
		forEach(e) {
			this._map.forEach(e)
		}
		[Symbol.iterator]() {
			return this._map[Symbol.iterator]()
		}
	},
	Fc = class extends Error {
		constructor(e, t, n) {
			super(`Error in extension ${we.toKey(e)}: ${n ?? t.message}`, { cause: t }),
				(this.name = "ExtensionError"),
				(this.extension = e)
		}
	}
var hj = O("IBuiltinExtensionsScannerService")
function oP(o, e) {
	return e && (o.stack || o.stacktrace)
		? p("stackTrace.format", "{0}: {1}", zO(o), $O(o.stack) || $O(o.stacktrace))
		: zO(o)
}
function $O(o) {
	return Array.isArray(o)
		? o.join(`
`)
		: o
}
function zO(o) {
	return o.code === "ERR_UNC_HOST_NOT_ALLOWED"
		? `${o.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`
		: typeof o.code == "string" && typeof o.errno == "number" && typeof o.syscall == "string"
			? p("nodeExceptionMessage", "A system error occurred ({0})", o.message)
			: o.message ||
				p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
}
function Jn(o = null, e = !1) {
	if (!o) return p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
	if (Array.isArray(o)) {
		let t = Ye(o),
			n = Jn(t[0], e)
		return t.length > 1 ? p("error.moreErrors", "{0} ({1} errors in total)", n, t.length) : n
	}
	if (Ee(o)) return o
	if (o.detail) {
		let t = o.detail
		if (t.error) return oP(t.error, e)
		if (t.exception) return oP(t.exception, e)
	}
	return o.stack
		? oP(o, e)
		: o.message
			? o.message
			: p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
}
function ar(o) {
	return sP(o, 0)
}
function sP(o, e) {
	switch (typeof o) {
		case "object":
			return o === null ? ss(349, e) : Array.isArray(o) ? H5(o, e) : W5(o, e)
		case "string":
			return KO(o, e)
		case "boolean":
			return U5(o, e)
		case "number":
			return ss(o, e)
		case "undefined":
			return ss(937, e)
		default:
			return ss(617, e)
	}
}
function ss(o, e) {
	return ((e << 5) - e + o) | 0
}
function U5(o, e) {
	return ss(o ? 433 : 863, e)
}
function KO(o, e) {
	e = ss(149417, e)
	for (let t = 0, n = o.length; t < n; t++) e = ss(o.charCodeAt(t), e)
	return e
}
function H5(o, e) {
	return (e = ss(104579, e)), o.reduce((t, n) => sP(n, t), e)
}
function W5(o, e) {
	return (
		(e = ss(181387, e)),
		Object.keys(o)
			.sort()
			.reduce((t, n) => ((t = KO(n, t)), sP(o[n], t)), e)
	)
}
function iP(o, e, t = 32) {
	let n = t - e,
		r = ~((1 << n) - 1)
	return ((o << e) | ((r & o) >>> n)) >>> 0
}
function Of(o, e = 32) {
	return o instanceof ArrayBuffer
		? Array.from(new Uint8Array(o))
				.map((t) => t.toString(16).padStart(2, "0"))
				.join("")
		: (o >>> 0).toString(16).padStart(e / 4, "0")
}
var qO = class o {
	constructor() {
		this._h0 = 1732584193
		this._h1 = 4023233417
		this._h2 = 2562383102
		this._h3 = 271733878
		this._h4 = 3285377520
		;(this._buff = new Uint8Array(67)),
			(this._buffDV = new DataView(this._buff.buffer)),
			(this._buffLen = 0),
			(this._totalLen = 0),
			(this._leftoverHighSurrogate = 0),
			(this._finished = !1)
	}
	static {
		this._bigBlock32 = new DataView(new ArrayBuffer(320))
	}
	update(e) {
		let t = e.length
		if (t === 0) return
		let n = this._buff,
			r = this._buffLen,
			i = this._leftoverHighSurrogate,
			s,
			a
		for (i !== 0 ? ((s = i), (a = -1), (i = 0)) : ((s = e.charCodeAt(0)), (a = 0)); ; ) {
			let l = s
			if (kl(s))
				if (a + 1 < t) {
					let d = e.charCodeAt(a + 1)
					sf(d) ? (a++, (l = Tv(s, d))) : (l = 65533)
				} else {
					i = s
					break
				}
			else sf(s) && (l = 65533)
			if (((r = this._push(n, r, l)), a++, a < t)) s = e.charCodeAt(a)
			else break
		}
		;(this._buffLen = r), (this._leftoverHighSurrogate = i)
	}
	_push(e, t, n) {
		return (
			n < 128
				? (e[t++] = n)
				: n < 2048
					? ((e[t++] = 192 | ((n & 1984) >>> 6)), (e[t++] = 128 | ((n & 63) >>> 0)))
					: n < 65536
						? ((e[t++] = 224 | ((n & 61440) >>> 12)),
							(e[t++] = 128 | ((n & 4032) >>> 6)),
							(e[t++] = 128 | ((n & 63) >>> 0)))
						: ((e[t++] = 240 | ((n & 1835008) >>> 18)),
							(e[t++] = 128 | ((n & 258048) >>> 12)),
							(e[t++] = 128 | ((n & 4032) >>> 6)),
							(e[t++] = 128 | ((n & 63) >>> 0))),
			t >= 64 &&
				(this._step(), (t -= 64), (this._totalLen += 64), (e[0] = e[64]), (e[1] = e[65]), (e[2] = e[66])),
			t
		)
	}
	digest() {
		return (
			this._finished ||
				((this._finished = !0),
				this._leftoverHighSurrogate &&
					((this._leftoverHighSurrogate = 0), (this._buffLen = this._push(this._buff, this._buffLen, 65533))),
				(this._totalLen += this._buffLen),
				this._wrapUp()),
			Of(this._h0) + Of(this._h1) + Of(this._h2) + Of(this._h3) + Of(this._h4)
		)
	}
	_wrapUp() {
		;(this._buff[this._buffLen++] = 128),
			this._buff.subarray(this._buffLen).fill(0),
			this._buffLen > 56 && (this._step(), this._buff.fill(0))
		let e = 8 * this._totalLen
		this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1),
			this._buffDV.setUint32(60, e % 4294967296, !1),
			this._step()
	}
	_step() {
		let e = o._bigBlock32,
			t = this._buffDV
		for (let u = 0; u < 64; u += 4) e.setUint32(u, t.getUint32(u, !1), !1)
		for (let u = 64; u < 320; u += 4)
			e.setUint32(
				u,
				iP(
					e.getUint32(u - 12, !1) ^
						e.getUint32(u - 32, !1) ^
						e.getUint32(u - 56, !1) ^
						e.getUint32(u - 64, !1),
					1,
				),
				!1,
			)
		let n = this._h0,
			r = this._h1,
			i = this._h2,
			s = this._h3,
			a = this._h4,
			l,
			d,
			c
		for (let u = 0; u < 80; u++)
			u < 20
				? ((l = (r & i) | (~r & s)), (d = 1518500249))
				: u < 40
					? ((l = r ^ i ^ s), (d = 1859775393))
					: u < 60
						? ((l = (r & i) | (r & s) | (i & s)), (d = 2400959708))
						: ((l = r ^ i ^ s), (d = 3395469782)),
				(c = (iP(n, 5) + l + a + d + e.getUint32(u * 4, !1)) & 4294967295),
				(a = s),
				(s = i),
				(i = iP(r, 30)),
				(r = n),
				(n = c)
		;(this._h0 = (this._h0 + n) & 4294967295),
			(this._h1 = (this._h1 + r) & 4294967295),
			(this._h2 = (this._h2 + i) & 4294967295),
			(this._h3 = (this._h3 + s) & 4294967295),
			(this._h4 = (this._h4 + a) & 4294967295)
	}
}
var te = O("logService"),
	co = O("loggerService")
var ma = ((s) => (
		(s[(s.Off = 0)] = "Off"),
		(s[(s.Trace = 1)] = "Trace"),
		(s[(s.Debug = 2)] = "Debug"),
		(s[(s.Info = 3)] = "Info"),
		(s[(s.Warning = 4)] = "Warning"),
		(s[(s.Error = 5)] = "Error"),
		s
	))(ma || {}),
	V5 = 3
function B5(o, e) {
	return o !== 0 && o <= e
}
function jO(o, e, t) {
	switch (e) {
		case 1:
			o.trace(t)
			break
		case 2:
			o.debug(t)
			break
		case 3:
			o.info(t)
			break
		case 4:
			o.warn(t)
			break
		case 5:
			o.error(t)
			break
		case 0:
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
function Nc(o, e = !1) {
	let t = ""
	for (let n = 0; n < o.length; n++) {
		let r = o[n]
		if ((r instanceof Error && (r = Jn(r, e)), typeof r == "object"))
			try {
				r = JSON.stringify(r)
			} catch {}
		t += (n > 0 ? " " : "") + r
	}
	return t
}
var ob = class extends $ {
		constructor() {
			super(...arguments)
			this.level = V5
			this._onDidChangeLogLevel = this._register(new E())
			this.onDidChangeLogLevel = this._onDidChangeLogLevel.event
		}
		setLevel(t) {
			this.level !== t && ((this.level = t), this._onDidChangeLogLevel.fire(this.level))
		}
		getLevel() {
			return this.level
		}
		checkLogLevel(t) {
			return B5(this.level, t)
		}
		canLog(t) {
			return this._store.isDisposed ? !1 : this.checkLogLevel(t)
		}
	},
	pa = class extends ob {
		constructor(t) {
			super()
			this.logAlways = t
		}
		checkLogLevel(t) {
			return this.logAlways || super.checkLogLevel(t)
		}
		trace(t, ...n) {
			this.canLog(1) && this.log(1, Nc([t, ...n], !0))
		}
		debug(t, ...n) {
			this.canLog(2) && this.log(2, Nc([t, ...n]))
		}
		info(t, ...n) {
			this.canLog(3) && this.log(3, Nc([t, ...n]))
		}
		warn(t, ...n) {
			this.canLog(4) && this.log(4, Nc([t, ...n]))
		}
		error(t, ...n) {
			if (this.canLog(5))
				if (t instanceof Error) {
					let r = Array.prototype.slice.call(arguments)
					;(r[0] = t.stack), this.log(5, Nc(r))
				} else this.log(5, Nc([t, ...n]))
		}
		flush() {}
	}
var ib = class extends ob {
		constructor(t) {
			super()
			this.loggers = t
			t.length && this.setLevel(t[0].getLevel())
		}
		setLevel(t) {
			for (let n of this.loggers) n.setLevel(t)
			super.setLevel(t)
		}
		trace(t, ...n) {
			for (let r of this.loggers) r.trace(t, ...n)
		}
		debug(t, ...n) {
			for (let r of this.loggers) r.debug(t, ...n)
		}
		info(t, ...n) {
			for (let r of this.loggers) r.info(t, ...n)
		}
		warn(t, ...n) {
			for (let r of this.loggers) r.warn(t, ...n)
		}
		error(t, ...n) {
			for (let r of this.loggers) r.error(t, ...n)
		}
		flush() {
			for (let t of this.loggers) t.flush()
		}
		dispose() {
			for (let t of this.loggers) t.dispose()
			super.dispose()
		}
	},
	sb = class extends $ {
		constructor(t, n, r) {
			super()
			this.logLevel = t
			this.logsHome = n
			this._loggers = new ft()
			this._onDidChangeLoggers = this._register(new E())
			this.onDidChangeLoggers = this._onDidChangeLoggers.event
			this._onDidChangeLogLevel = this._register(new E())
			this.onDidChangeLogLevel = this._onDidChangeLogLevel.event
			this._onDidChangeVisibility = this._register(new E())
			this.onDidChangeVisibility = this._onDidChangeVisibility.event
			if (r) for (let i of r) this._loggers.set(i.resource, { logger: void 0, info: i })
		}
		getLoggerEntry(t) {
			return Ee(t) ? [...this._loggers.values()].find((n) => n.info.id === t) : this._loggers.get(t)
		}
		getLogger(t) {
			return this.getLoggerEntry(t)?.logger
		}
		createLogger(t, n) {
			let r = this.toResource(t),
				i = Ee(t) ? t : (n?.id ?? ar(r.toString()).toString(16)),
				s = this._loggers.get(r)?.logger,
				a = n?.logLevel === "always" ? 1 : n?.logLevel
			s || (s = this.doCreateLogger(r, a ?? this.getLogLevel(r) ?? this.logLevel, { ...n, id: i }))
			let l = {
				logger: s,
				info: {
					resource: r,
					id: i,
					logLevel: a,
					name: n?.name,
					hidden: n?.hidden,
					group: n?.group,
					extensionId: n?.extensionId,
					when: n?.when,
				},
			}
			return this.registerLogger(l.info), this._loggers.set(r, l), s
		}
		toResource(t) {
			return Ee(t) ? ct(this.logsHome, `${t}.log`) : t
		}
		setLogLevel(t, n) {
			if (y.isUri(t)) {
				let r = t,
					i = n,
					s = this._loggers.get(r)
				s &&
					i !== s.info.logLevel &&
					((s.info.logLevel = i === this.logLevel ? void 0 : i),
					s.logger?.setLevel(i),
					this._loggers.set(s.info.resource, s),
					this._onDidChangeLogLevel.fire([r, i]))
			} else {
				this.logLevel = t
				for (let [r, i] of this._loggers.entries())
					this._loggers.get(r)?.info.logLevel === void 0 && i.logger?.setLevel(this.logLevel)
				this._onDidChangeLogLevel.fire(this.logLevel)
			}
		}
		setVisibility(t, n) {
			let r = this.getLoggerEntry(t)
			r &&
				n !== !r.info.hidden &&
				((r.info.hidden = !n),
				this._loggers.set(r.info.resource, r),
				this._onDidChangeVisibility.fire([r.info.resource, n]))
		}
		getLogLevel(t) {
			let n
			return t && (n = this._loggers.get(t)?.info.logLevel), n ?? this.logLevel
		}
		registerLogger(t) {
			let n = this._loggers.get(t.resource)
			n
				? n.info.hidden !== t.hidden && this.setVisibility(t.resource, !t.hidden)
				: (this._loggers.set(t.resource, { info: t, logger: void 0 }),
					this._onDidChangeLoggers.fire({ added: [t], removed: [] }))
		}
		deregisterLogger(t) {
			let n = this.toResource(t),
				r = this._loggers.get(n)
			r &&
				(r.logger && r.logger.dispose(),
				this._loggers.delete(n),
				this._onDidChangeLoggers.fire({ added: [], removed: [r.info] }))
		}
		*getRegisteredLoggers() {
			for (let t of this._loggers.values()) yield t.info
		}
		getRegisteredLogger(t) {
			return this._loggers.get(t)?.info
		}
		dispose() {
			this._loggers.forEach((t) => t.logger?.dispose()), this._loggers.clear(), super.dispose()
		}
	}
function $5(o) {
	switch (o) {
		case 1:
			return "trace"
		case 2:
			return "debug"
		case 3:
			return "info"
		case 4:
			return "warn"
		case 5:
			return "error"
		case 0:
			return "off"
	}
}
function GO(o) {
	switch (o) {
		case "trace":
			return 1
		case "debug":
			return 2
		case "info":
			return 3
		case "warn":
			return 4
		case "error":
			return 5
		case "critical":
			return 5
		case "off":
			return 0
	}
}
var Mj = new D("logLevel", $5(3))
var gr = class {
	constructor(e, t = [], n = !1) {
		;(this.ctor = e), (this.staticArguments = t), (this.supportsDelayedInstantiation = n)
	}
}
var QO = []
function Ke(o, e, t) {
	e instanceof gr || (e = new gr(e, [], !!t)), QO.push([o, e])
}
function JO() {
	return QO
}
var fa = class {
	constructor(...e) {
		this._entries = new Map()
		for (let [t, n] of e) this.set(t, n)
	}
	set(e, t) {
		let n = this._entries.get(e)
		return this._entries.set(e, t), n
	}
	has(e) {
		return this._entries.has(e)
	}
	get(e) {
		return this._entries.get(e)
	}
}
var Xe = O("IExtHostInitDataService")
var aP = class {
		constructor(e, t) {
			this.key = e
			this.data = t
			this.incoming = new Map()
			this.outgoing = new Map()
		}
	},
	Lf = class {
		constructor(e) {
			this._hashFn = e
			this._nodes = new Map()
		}
		roots() {
			let e = []
			for (let t of this._nodes.values()) t.outgoing.size === 0 && e.push(t)
			return e
		}
		insertEdge(e, t) {
			let n = this.lookupOrInsertNode(e),
				r = this.lookupOrInsertNode(t)
			n.outgoing.set(r.key, r), r.incoming.set(n.key, n)
		}
		removeNode(e) {
			let t = this._hashFn(e)
			this._nodes.delete(t)
			for (let n of this._nodes.values()) n.outgoing.delete(t), n.incoming.delete(t)
		}
		lookupOrInsertNode(e) {
			let t = this._hashFn(e),
				n = this._nodes.get(t)
			return n || ((n = new aP(t, e)), this._nodes.set(t, n)), n
		}
		lookup(e) {
			return this._nodes.get(this._hashFn(e))
		}
		isEmpty() {
			return this._nodes.size === 0
		}
		toString() {
			let e = []
			for (let [t, n] of this._nodes)
				e.push(`${t}
	(-> incoming)[${[...n.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...n.outgoing.keys()].join(",")}]
`)
			return e.join(`
`)
		}
		findCycleSlow() {
			for (let [e, t] of this._nodes) {
				let n = new Set([e]),
					r = this._findCycle(t, n)
				if (r) return r
			}
		}
		_findCycle(e, t) {
			for (let [n, r] of e.outgoing) {
				if (t.has(n)) return [...t, n].join(" -> ")
				t.add(n)
				let i = this._findCycle(r, t)
				if (i) return i
				t.delete(n)
			}
		}
	}
var z5 = !1,
	ab = class extends Error {
		constructor(e) {
			super("cyclic dependency between services"),
				(this.message =
					e.findCycleSlow() ??
					`UNABLE to detect cycle, dumping graph: 
${e.toString()}`)
		}
	},
	lb = class o {
		constructor(e = new fa(), t = !1, n, r = z5) {
			this._services = e
			this._strict = t
			this._parent = n
			this._enableTracing = r
			this._isDisposed = !1
			this._servicesToMaybeDispose = new Set()
			this._children = new Set()
			this._activeInstantiations = new Set()
			this._services.set(Uo, this), (this._globalGraph = r ? (n?._globalGraph ?? new Lf((i) => i)) : void 0)
		}
		dispose() {
			if (!this._isDisposed) {
				;(this._isDisposed = !0), Fn(this._children), this._children.clear()
				for (let e of this._servicesToMaybeDispose) Zh(e) && e.dispose()
				this._servicesToMaybeDispose.clear()
			}
		}
		_throwIfDisposed() {
			if (this._isDisposed) throw new Error("InstantiationService has been disposed")
		}
		createChild(e, t) {
			this._throwIfDisposed()
			let n = this,
				r = new (class extends o {
					dispose() {
						n._children.delete(r), super.dispose()
					}
				})(e, this._strict, this, this._enableTracing)
			return this._children.add(r), t?.add(r), r
		}
		invokeFunction(e, ...t) {
			this._throwIfDisposed()
			let n = Mf.traceInvocation(this._enableTracing, e),
				r = !1
			try {
				return e(
					{
						get: (s) => {
							if (r) throw lc("service accessor is only valid during the invocation of its target method")
							let a = this._getOrCreateServiceInstance(s, n)
							if (!a) throw new Error(`[invokeFunction] unknown service '${s}'`)
							return a
						},
					},
					...t,
				)
			} finally {
				;(r = !0), n.stop()
			}
		}
		createInstance(e, ...t) {
			this._throwIfDisposed()
			let n, r
			return (
				e instanceof gr
					? ((n = Mf.traceCreation(this._enableTracing, e.ctor)),
						(r = this._createInstance(e.ctor, e.staticArguments.concat(t), n)))
					: ((n = Mf.traceCreation(this._enableTracing, e)), (r = this._createInstance(e, t, n))),
				n.stop(),
				r
			)
		}
		_createInstance(e, t = [], n) {
			let r = No.getServiceDependencies(e).sort((a, l) => a.index - l.index),
				i = []
			for (let a of r) {
				let l = this._getOrCreateServiceInstance(a.id, n)
				l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1),
					i.push(l)
			}
			let s = r.length > 0 ? r[0].index : t.length
			if (t.length !== s) {
				console.trace(
					`[createInstance] First service dependency of ${e.name} at position ${s + 1} conflicts with ${t.length} static arguments`,
				)
				let a = s - t.length
				a > 0 ? (t = t.concat(new Array(a))) : (t = t.slice(0, s))
			}
			return Reflect.construct(e, t.concat(i))
		}
		_setCreatedServiceInstance(e, t) {
			if (this._services.get(e) instanceof gr) this._services.set(e, t)
			else if (this._parent) this._parent._setCreatedServiceInstance(e, t)
			else throw new Error("illegalState - setting UNKNOWN service instance")
		}
		_getServiceInstanceOrDescriptor(e) {
			let t = this._services.get(e)
			return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t
		}
		_getOrCreateServiceInstance(e, t) {
			this._globalGraph &&
				this._globalGraphImplicitDependency &&
				this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e))
			let n = this._getServiceInstanceOrDescriptor(e)
			return n instanceof gr
				? this._safeCreateAndCacheServiceInstance(e, n, t.branch(e, !0))
				: (t.branch(e, !1), n)
		}
		_safeCreateAndCacheServiceInstance(e, t, n) {
			if (this._activeInstantiations.has(e))
				throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`)
			this._activeInstantiations.add(e)
			try {
				return this._createAndCacheServiceInstance(e, t, n)
			} finally {
				this._activeInstantiations.delete(e)
			}
		}
		_createAndCacheServiceInstance(e, t, n) {
			let r = new Lf((l) => l.id.toString()),
				i = 0,
				s = [{ id: e, desc: t, _trace: n }],
				a = new Set()
			for (; s.length; ) {
				let l = s.pop()
				if (!a.has(String(l.id))) {
					if ((a.add(String(l.id)), r.lookupOrInsertNode(l), i++ > 1e3)) throw new ab(r)
					for (let d of No.getServiceDependencies(l.desc.ctor)) {
						let c = this._getServiceInstanceOrDescriptor(d.id)
						if (
							(c ||
								this._throwIfStrict(
									`[createInstance] ${e} depends on ${d.id} which is NOT registered.`,
									!0,
								),
							this._globalGraph?.insertEdge(String(l.id), String(d.id)),
							c instanceof gr)
						) {
							let u = { id: d.id, desc: c, _trace: l._trace.branch(d.id, !0) }
							r.insertEdge(l, u), s.push(u)
						}
					}
				}
			}
			for (;;) {
				let l = r.roots()
				if (l.length === 0) {
					if (!r.isEmpty()) throw new ab(r)
					break
				}
				for (let { data: d } of l) {
					if (this._getServiceInstanceOrDescriptor(d.id) instanceof gr) {
						let u = this._createServiceInstanceWithOwner(
							d.id,
							d.desc.ctor,
							d.desc.staticArguments,
							d.desc.supportsDelayedInstantiation,
							d._trace,
						)
						this._setCreatedServiceInstance(d.id, u)
					}
					r.removeNode(d)
				}
			}
			return this._getServiceInstanceOrDescriptor(e)
		}
		_createServiceInstanceWithOwner(e, t, n = [], r, i) {
			if (this._services.get(e) instanceof gr)
				return this._createServiceInstance(e, t, n, r, i, this._servicesToMaybeDispose)
			if (this._parent) return this._parent._createServiceInstanceWithOwner(e, t, n, r, i)
			throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)
		}
		_createServiceInstance(e, t, n = [], r, i, s) {
			if (r) {
				let a = new o(void 0, this._strict, this, this._enableTracing)
				a._globalGraphImplicitDependency = String(e)
				let l = new Map(),
					d = new Mv(() => {
						let c = a._createInstance(t, n, i)
						for (let [u, m] of l) {
							let f = c[u]
							if (typeof f == "function") for (let h of m) h.disposable = f.apply(c, h.listener)
						}
						return l.clear(), s.add(c), c
					})
				return new Proxy(Object.create(null), {
					get(c, u) {
						if (
							!d.isInitialized &&
							typeof u == "string" &&
							(u.startsWith("onDid") || u.startsWith("onWill"))
						) {
							let h = l.get(u)
							return (
								h || ((h = new ko()), l.set(u, h)),
								(I, C, T) => {
									if (d.isInitialized) return d.value[u](I, C, T)
									{
										let w = { listener: [I, C, T], disposable: void 0 },
											L = h.push(w)
										return q(() => {
											L(), w.disposable?.dispose()
										})
									}
								}
							)
						}
						if (u in c) return c[u]
						let m = d.value,
							f = m[u]
						return typeof f != "function" || ((f = f.bind(m)), (c[u] = f)), f
					},
					set(c, u, m) {
						return (d.value[u] = m), !0
					},
					getPrototypeOf(c) {
						return t.prototype
					},
				})
			} else {
				let a = this._createInstance(t, n, i)
				return s.add(a), a
			}
		}
		_throwIfStrict(e, t) {
			if ((t && console.warn(e), this._strict)) throw new Error(e)
		}
	}
var Mf = class o {
	constructor(e, t) {
		this.type = e
		this.name = t
		this._start = Date.now()
		this._dep = []
	}
	static {
		this.all = new Set()
	}
	static {
		this._None = new (class extends o {
			constructor() {
				super(0, null)
			}
			stop() {}
			branch() {
				return this
			}
		})()
	}
	static traceInvocation(e, t) {
		return e
			? new o(
					2,
					t.name ||
						new Error().stack
							.split(
								`
`,
							)
							.slice(3, 4).join(`
`),
				)
			: o._None
	}
	static traceCreation(e, t) {
		return e ? new o(1, t.name) : o._None
	}
	static {
		this._totals = 0
	}
	branch(e, t) {
		let n = new o(3, e.toString())
		return this._dep.push([e, t, n]), n
	}
	stop() {
		let e = Date.now() - this._start
		o._totals += e
		let t = !1
		function n(i, s) {
			let a = [],
				l = new Array(i + 1).join("	")
			for (let [d, c, u] of s._dep)
				if (c && u) {
					;(t = !0), a.push(`${l}CREATES -> ${d}`)
					let m = n(i + 1, u)
					m && a.push(m)
				} else a.push(`${l}uses -> ${d}`)
			return a.join(`
`)
		}
		let r = [
			`${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
			`${n(1, this)}`,
			`DONE, took ${e.toFixed(2)}ms (grand total ${o._totals.toFixed(2)}ms)`,
		]
		;(e > 2 || t) &&
			o.all.add(
				r.join(`
`),
			)
	}
}
var ie = O("IExtHostRpcService"),
	db = class {
		constructor(e) {
			;(this.getProxy = e.getProxy.bind(e)),
				(this.set = e.set.bind(e)),
				(this.dispose = e.dispose.bind(e)),
				(this.assertRegistered = e.assertRegistered.bind(e)),
				(this.drain = e.drain.bind(e))
		}
	}
var pi = O("IURITransformerService"),
	cb = class {
		constructor(e) {
			e
				? ((this.transformIncoming = e.transformIncoming.bind(e)),
					(this.transformOutgoing = e.transformOutgoing.bind(e)),
					(this.transformOutgoingURI = e.transformOutgoingURI.bind(e)),
					(this.transformOutgoingScheme = e.transformOutgoingScheme.bind(e)))
				: ((this.transformIncoming = (t) => t),
					(this.transformOutgoing = (t) => t),
					(this.transformOutgoingURI = (t) => t),
					(this.transformOutgoingScheme = (t) => t))
		}
	}
var lP = class {
		constructor() {
			this._value = ""
			this._pos = 0
		}
		reset(e) {
			return (this._value = e), (this._pos = 0), this
		}
		next() {
			return (this._pos += 1), this
		}
		hasNext() {
			return this._pos < this._value.length - 1
		}
		cmp(e) {
			let t = e.charCodeAt(0),
				n = this._value.charCodeAt(this._pos)
			return t - n
		}
		value() {
			return this._value[this._pos]
		}
	},
	dP = class {
		constructor(e = !0) {
			this._caseSensitive = e
		}
		reset(e) {
			return (this._value = e), (this._from = 0), (this._to = 0), this.next()
		}
		hasNext() {
			return this._to < this._value.length
		}
		next() {
			this._from = this._to
			let e = !0
			for (; this._to < this._value.length; this._to++)
				if (this._value.charCodeAt(this._to) === 46)
					if (e) this._from++
					else break
				else e = !1
			return this
		}
		cmp(e) {
			return this._caseSensitive
				? Cv(e, this._value, 0, e.length, this._from, this._to)
				: bc(e, this._value, 0, e.length, this._from, this._to)
		}
		value() {
			return this._value.substring(this._from, this._to)
		}
	},
	ub = class {
		constructor(e = !0, t = !0) {
			this._splitOnBackslash = e
			this._caseSensitive = t
		}
		reset(e) {
			;(this._from = 0), (this._to = 0), (this._value = e), (this._valueLen = e.length)
			for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
				let n = this._value.charCodeAt(t)
				if (!(n === 47 || (this._splitOnBackslash && n === 92))) break
			}
			return this.next()
		}
		hasNext() {
			return this._to < this._valueLen
		}
		next() {
			this._from = this._to
			let e = !0
			for (; this._to < this._valueLen; this._to++) {
				let t = this._value.charCodeAt(this._to)
				if (t === 47 || (this._splitOnBackslash && t === 92))
					if (e) this._from++
					else break
				else e = !1
			}
			return this
		}
		cmp(e) {
			return this._caseSensitive
				? Cv(e, this._value, 0, e.length, this._from, this._to)
				: bc(e, this._value, 0, e.length, this._from, this._to)
		}
		value() {
			return this._value.substring(this._from, this._to)
		}
	}
var Ff = class {
		constructor(e, t) {
			this._ignorePathCasing = e
			this._ignoreQueryAndFragment = t
			this._states = []
			this._stateIdx = 0
		}
		reset(e) {
			return (
				(this._value = e),
				(this._states = []),
				this._value.scheme && this._states.push(1),
				this._value.authority && this._states.push(2),
				this._value.path &&
					((this._pathIterator = new ub(!1, !this._ignorePathCasing(e))),
					this._pathIterator.reset(e.path),
					this._pathIterator.value() && this._states.push(3)),
				this._ignoreQueryAndFragment(e) ||
					(this._value.query && this._states.push(4), this._value.fragment && this._states.push(5)),
				(this._stateIdx = 0),
				this
			)
		}
		next() {
			return (
				this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()
					? this._pathIterator.next()
					: (this._stateIdx += 1),
				this
			)
		}
		hasNext() {
			return (
				(this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) ||
				this._stateIdx < this._states.length - 1
			)
		}
		cmp(e) {
			if (this._states[this._stateIdx] === 1) return Sv(e, this._value.scheme)
			if (this._states[this._stateIdx] === 2) return Sv(e, this._value.authority)
			if (this._states[this._stateIdx] === 3) return this._pathIterator.cmp(e)
			if (this._states[this._stateIdx] === 4) return Lo(e, this._value.query)
			if (this._states[this._stateIdx] === 5) return Lo(e, this._value.fragment)
			throw new Error()
		}
		value() {
			if (this._states[this._stateIdx] === 1) return this._value.scheme
			if (this._states[this._stateIdx] === 2) return this._value.authority
			if (this._states[this._stateIdx] === 3) return this._pathIterator.value()
			if (this._states[this._stateIdx] === 4) return this._value.query
			if (this._states[this._stateIdx] === 5) return this._value.fragment
			throw new Error()
		}
	},
	as = class o {
		static {
			this.Val = Symbol("undefined_placeholder")
		}
		static wrap(e) {
			return e === void 0 ? o.Val : e
		}
		static unwrap(e) {
			return e === o.Val ? void 0 : e
		}
	},
	Uc = class {
		constructor() {
			this.height = 1
			this.value = void 0
			this.key = void 0
			this.left = void 0
			this.mid = void 0
			this.right = void 0
		}
		isEmpty() {
			return !this.left && !this.mid && !this.right && this.value === void 0
		}
		rotateLeft() {
			let e = this.right
			return (this.right = e.left), (e.left = this), this.updateHeight(), e.updateHeight(), e
		}
		rotateRight() {
			let e = this.left
			return (this.left = e.right), (e.right = this), this.updateHeight(), e.updateHeight(), e
		}
		updateHeight() {
			this.height = 1 + Math.max(this.heightLeft, this.heightRight)
		}
		balanceFactor() {
			return this.heightRight - this.heightLeft
		}
		get heightLeft() {
			return this.left?.height ?? 0
		}
		get heightRight() {
			return this.right?.height ?? 0
		}
	}
var hr = class o {
	static forUris(e = () => !1, t = () => !1) {
		return new o(new Ff(e, t))
	}
	static forPaths(e = !1) {
		return new o(new ub(void 0, !e))
	}
	static forStrings() {
		return new o(new lP())
	}
	static forConfigKeys() {
		return new o(new dP())
	}
	constructor(e) {
		this._iter = e
	}
	clear() {
		this._root = void 0
	}
	fill(e, t) {
		if (t) {
			let n = t.slice(0)
			BT(n)
			for (let r of n) this.set(r, e)
		} else {
			let n = e.slice(0)
			BT(n)
			for (let r of n) this.set(r[0], r[1])
		}
	}
	set(e, t) {
		let n = this._iter.reset(e),
			r
		this._root || ((this._root = new Uc()), (this._root.segment = n.value()))
		let i = []
		for (r = this._root; ; ) {
			let a = n.cmp(r.segment)
			if (a > 0) r.left || ((r.left = new Uc()), (r.left.segment = n.value())), i.push([-1, r]), (r = r.left)
			else if (a < 0)
				r.right || ((r.right = new Uc()), (r.right.segment = n.value())), i.push([1, r]), (r = r.right)
			else if (n.hasNext())
				n.next(), r.mid || ((r.mid = new Uc()), (r.mid.segment = n.value())), i.push([0, r]), (r = r.mid)
			else break
		}
		let s = as.unwrap(r.value)
		;(r.value = as.wrap(t)), (r.key = e)
		for (let a = i.length - 1; a >= 0; a--) {
			let l = i[a][1]
			l.updateHeight()
			let d = l.balanceFactor()
			if (d < -1 || d > 1) {
				let c = i[a][0],
					u = i[a + 1][0]
				if (c === 1 && u === 1) i[a][1] = l.rotateLeft()
				else if (c === -1 && u === -1) i[a][1] = l.rotateRight()
				else if (c === 1 && u === -1)
					(l.right = i[a + 1][1] = i[a + 1][1].rotateRight()), (i[a][1] = l.rotateLeft())
				else if (c === -1 && u === 1)
					(l.left = i[a + 1][1] = i[a + 1][1].rotateLeft()), (i[a][1] = l.rotateRight())
				else throw new Error()
				if (a > 0)
					switch (i[a - 1][0]) {
						case -1:
							i[a - 1][1].left = i[a][1]
							break
						case 1:
							i[a - 1][1].right = i[a][1]
							break
						case 0:
							i[a - 1][1].mid = i[a][1]
							break
					}
				else this._root = i[0][1]
			}
		}
		return s
	}
	get(e) {
		return as.unwrap(this._getNode(e)?.value)
	}
	_getNode(e) {
		let t = this._iter.reset(e),
			n = this._root
		for (; n; ) {
			let r = t.cmp(n.segment)
			if (r > 0) n = n.left
			else if (r < 0) n = n.right
			else if (t.hasNext()) t.next(), (n = n.mid)
			else break
		}
		return n
	}
	has(e) {
		let t = this._getNode(e)
		return !(t?.value === void 0 && t?.mid === void 0)
	}
	delete(e) {
		return this._delete(e, !1)
	}
	deleteSuperstr(e) {
		return this._delete(e, !0)
	}
	_delete(e, t) {
		let n = this._iter.reset(e),
			r = [],
			i = this._root
		for (; i; ) {
			let s = n.cmp(i.segment)
			if (s > 0) r.push([-1, i]), (i = i.left)
			else if (s < 0) r.push([1, i]), (i = i.right)
			else if (n.hasNext()) n.next(), r.push([0, i]), (i = i.mid)
			else break
		}
		if (i) {
			if (
				(t
					? ((i.left = void 0), (i.mid = void 0), (i.right = void 0), (i.height = 1))
					: ((i.key = void 0), (i.value = void 0)),
				!i.mid && !i.value)
			)
				if (i.left && i.right) {
					let s = [[1, i]],
						a = this._min(i.right, s)
					if (a.key) {
						;(i.key = a.key), (i.value = a.value), (i.segment = a.segment)
						let l = a.right
						if (s.length > 1) {
							let [c, u] = s[s.length - 1]
							switch (c) {
								case -1:
									u.left = l
									break
								case 0:
									pc(!1)
								case 1:
									pc(!1)
							}
						} else i.right = l
						let d = this._balanceByStack(s)
						if (r.length > 0) {
							let [c, u] = r[r.length - 1]
							switch (c) {
								case -1:
									u.left = d
									break
								case 0:
									u.mid = d
									break
								case 1:
									u.right = d
									break
							}
						} else this._root = d
					}
				} else {
					let s = i.left ?? i.right
					if (r.length > 0) {
						let [a, l] = r[r.length - 1]
						switch (a) {
							case -1:
								l.left = s
								break
							case 0:
								l.mid = s
								break
							case 1:
								l.right = s
								break
						}
					} else this._root = s
				}
			this._root = this._balanceByStack(r) ?? this._root
		}
	}
	_min(e, t) {
		for (; e.left; ) t.push([-1, e]), (e = e.left)
		return e
	}
	_balanceByStack(e) {
		for (let t = e.length - 1; t >= 0; t--) {
			let n = e[t][1]
			n.updateHeight()
			let r = n.balanceFactor()
			if (
				(r > 1
					? (n.right.balanceFactor() >= 0 || (n.right = n.right.rotateRight()), (e[t][1] = n.rotateLeft()))
					: r < -1 &&
						(n.left.balanceFactor() <= 0 || (n.left = n.left.rotateLeft()), (e[t][1] = n.rotateRight())),
				t > 0)
			)
				switch (e[t - 1][0]) {
					case -1:
						e[t - 1][1].left = e[t][1]
						break
					case 1:
						e[t - 1][1].right = e[t][1]
						break
					case 0:
						e[t - 1][1].mid = e[t][1]
						break
				}
			else return e[0][1]
		}
	}
	findSubstr(e) {
		let t = this._iter.reset(e),
			n = this._root,
			r
		for (; n; ) {
			let i = t.cmp(n.segment)
			if (i > 0) n = n.left
			else if (i < 0) n = n.right
			else if (t.hasNext()) t.next(), (r = as.unwrap(n.value) || r), (n = n.mid)
			else break
		}
		return (n && as.unwrap(n.value)) || r
	}
	findSuperstr(e) {
		return this._findSuperstrOrElement(e, !1)
	}
	_findSuperstrOrElement(e, t) {
		let n = this._iter.reset(e),
			r = this._root
		for (; r; ) {
			let i = n.cmp(r.segment)
			if (i > 0) r = r.left
			else if (i < 0) r = r.right
			else if (n.hasNext()) n.next(), (r = r.mid)
			else return r.mid ? this._entries(r.mid) : t ? as.unwrap(r.value) : void 0
		}
	}
	hasElementOrSubtree(e) {
		return this._findSuperstrOrElement(e, !0) !== void 0
	}
	forEach(e) {
		for (let [t, n] of this) e(n, t)
	}
	*[Symbol.iterator]() {
		yield* this._entries(this._root)
	}
	_entries(e) {
		let t = []
		return this._dfsEntries(e, t), t[Symbol.iterator]()
	}
	_dfsEntries(e, t) {
		e &&
			(e.left && this._dfsEntries(e.left, t),
			e.value !== void 0 && t.push([e.key, as.unwrap(e.value)]),
			e.mid && this._dfsEntries(e.mid, t),
			e.right && this._dfsEntries(e.right, t))
	}
	_isBalanced() {
		let e = (t) => {
			if (!t) return !0
			let n = t.balanceFactor()
			return n < -1 || n > 1 ? !1 : e(t.left) && e(t.right)
		}
		return e(this._root)
	}
}
function XO(o, e, t) {
	return Math.min(Math.max(o, e), t)
}
var pb = class {
		constructor() {
			this._next = 0
		}
		getNext() {
			return this._next++
		}
	},
	mb = class {
		constructor() {
			this._n = 1
			this._val = 0
		}
		update(e) {
			return (this._val = this._val + (e - this._val) / this._n), (this._n += 1), this._val
		}
		get value() {
			return this._val
		}
	}
var fb = O("fileService")
function Kl(o) {
	return o.create === !0
}
var jl = ((r) => (
		(r[(r.Unknown = 0)] = "Unknown"),
		(r[(r.File = 1)] = "File"),
		(r[(r.Directory = 2)] = "Directory"),
		(r[(r.SymbolicLink = 64)] = "SymbolicLink"),
		r
	))(jl || {}),
	Gl = ((t) => ((t[(t.Readonly = 1)] = "Readonly"), (t[(t.Locked = 2)] = "Locked"), t))(Gl || {})
var ga = class o extends Error {
	constructor(t, n) {
		super(t)
		this.code = n
	}
	static create(t, n) {
		let r = new o(t.toString(), n)
		return cP(r, n), r
	}
}
function Wo(o, e) {
	return ga.create(o, e)
}
function ZO(o) {
	return o || Wo(p("unknownError", "Unknown Error"), "Unknown")
}
function cP(o, e) {
	return (o.name = e ? `${e} (FileSystemError)` : "FileSystemError"), o
}
function Wc(o) {
	if (!o) return "Unknown"
	if (o instanceof ga) return o.code
	let e = /^(.+) \(FileSystemError\)$/.exec(o.name)
	if (!e) return "Unknown"
	switch (e[1]) {
		case "EntryExists":
			return "EntryExists"
		case "EntryIsADirectory":
			return "EntryIsADirectory"
		case "EntryNotADirectory":
			return "EntryNotADirectory"
		case "EntryNotFound":
			return "EntryNotFound"
		case "EntryTooLarge":
			return "EntryTooLarge"
		case "EntryWriteLocked":
			return "EntryWriteLocked"
		case "NoPermissions":
			return "NoPermissions"
		case "Unavailable":
			return "Unavailable"
	}
	return "Unknown"
}
function eL(o) {
	if (o instanceof ql) return o.fileOperationResult
	switch (Wc(o)) {
		case "EntryNotFound":
			return 1
		case "EntryIsADirectory":
			return 0
		case "EntryNotADirectory":
			return 9
		case "EntryWriteLocked":
			return 5
		case "NoPermissions":
			return 6
		case "EntryExists":
			return 4
		case "EntryTooLarge":
			return 7
		default:
			return 10
	}
}
var YO = class o {
	constructor(e, t) {
		this.ignorePathCasing = t
		this.correlationId = void 0
		this.added = new Rt(() => {
			let e = hr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawAdded.map((t) => [t, !0])), e
		})
		this.updated = new Rt(() => {
			let e = hr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawUpdated.map((t) => [t, !0])), e
		})
		this.deleted = new Rt(() => {
			let e = hr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawDeleted.map((t) => [t, !0])), e
		})
		this.rawAdded = []
		this.rawUpdated = []
		this.rawDeleted = []
		for (let n of e) {
			switch (n.type) {
				case 1:
					this.rawAdded.push(n.resource)
					break
				case 0:
					this.rawUpdated.push(n.resource)
					break
				case 2:
					this.rawDeleted.push(n.resource)
					break
			}
			this.correlationId !== o.MIXED_CORRELATION &&
				(typeof n.cId == "number"
					? this.correlationId === void 0
						? (this.correlationId = n.cId)
						: this.correlationId !== n.cId && (this.correlationId = o.MIXED_CORRELATION)
					: this.correlationId !== void 0 && (this.correlationId = o.MIXED_CORRELATION))
		}
	}
	static {
		this.MIXED_CORRELATION = null
	}
	contains(e, ...t) {
		return this.doContains(e, { includeChildren: !1 }, ...t)
	}
	affects(e, ...t) {
		return this.doContains(e, { includeChildren: !0 }, ...t)
	}
	doContains(e, t, ...n) {
		if (!e) return !1
		let r = n.length > 0
		return !!(
			((!r || n.includes(1)) &&
				(this.added.value.get(e) || (t.includeChildren && this.added.value.findSuperstr(e)))) ||
			((!r || n.includes(0)) &&
				(this.updated.value.get(e) || (t.includeChildren && this.updated.value.findSuperstr(e)))) ||
			((!r || n.includes(2)) &&
				(this.deleted.value.findSubstr(e) || (t.includeChildren && this.deleted.value.findSuperstr(e))))
		)
	}
	gotAdded() {
		return this.rawAdded.length > 0
	}
	gotDeleted() {
		return this.rawDeleted.length > 0
	}
	gotUpdated() {
		return this.rawUpdated.length > 0
	}
	correlates(e) {
		return this.correlationId === e
	}
	hasCorrelation() {
		return typeof this.correlationId == "number"
	}
}
function tL(o, e, t) {
	return !o || !e || o === e || e.length > o.length
		? !1
		: (e.charAt(e.length - 1) !== at && (e += at), t ? Ji(o, e) : o.indexOf(e) === 0)
}
var ql = class extends Error {
	constructor(t, n, r) {
		super(t)
		this.fileOperationResult = n
		this.options = r
	}
}
var nL = ""
function uP(o) {
	if (!(typeof o.size != "number" || typeof o.mtime != "number")) return o.mtime.toString(29) + o.size.toString(31)
}
var Hc = class o {
	static {
		this.KB = 1024
	}
	static {
		this.MB = o.KB * o.KB
	}
	static {
		this.GB = o.MB * o.KB
	}
	static {
		this.TB = o.GB * o.KB
	}
	static formatSize(e) {
		return (
			fn(e) || (e = 0),
			e < o.KB
				? p("sizeB", "{0}B", e.toFixed(0))
				: e < o.MB
					? p("sizeKB", "{0}KB", (e / o.KB).toFixed(2))
					: e < o.GB
						? p("sizeMB", "{0}MB", (e / o.MB).toFixed(2))
						: e < o.TB
							? p("sizeGB", "{0}GB", (e / o.GB).toFixed(2))
							: p("sizeTB", "{0}TB", (e / o.TB).toFixed(2))
		)
	}
}
var hb = ((r) => (
	(r[(r.Ignore = 0)] = "Ignore"),
	(r[(r.Info = 1)] = "Info"),
	(r[(r.Warning = 2)] = "Warning"),
	(r[(r.Error = 3)] = "Error"),
	r
))(hb || {})
;((a) => {
	let o = "error",
		e = "warning",
		t = "warn",
		n = "info",
		r = "ignore"
	function i(l) {
		return l ? (xn(o, l) ? 3 : xn(e, l) || xn(t, l) ? 2 : xn(n, l) ? 1 : 0) : 0
	}
	a.fromValue = i
	function s(l) {
		switch (l) {
			case 3:
				return o
			case 2:
				return e
			case 1:
				return n
			default:
				return r
		}
	}
	a.toString = s
})((hb ||= {}))
var It = hb
var rL = It,
	AG = O("notificationService")
var mi = O("contextService")
function oL(o) {
	let e = o
	return typeof e?.id == "string" && y.isUri(e.uri)
}
function iL(o) {
	let e = o
	return typeof e?.id == "string" && y.isUri(e.configPath)
}
var vb = class {
		constructor(e, t, n, r, i) {
			this._id = e
			this._transient = n
			this._configuration = r
			this.ignorePathCasing = i
			;(this.foldersMap = hr.forUris(this.ignorePathCasing, () => !0)), (this.folders = t)
		}
		get folders() {
			return this._folders
		}
		set folders(e) {
			;(this._folders = e), this.updateFoldersMap()
		}
		update(e) {
			;(this._id = e.id),
				(this._configuration = e.configuration),
				(this._transient = e.transient),
				(this.ignorePathCasing = e.ignorePathCasing),
				(this.folders = e.folders)
		}
		get id() {
			return this._id
		}
		get transient() {
			return this._transient
		}
		get configuration() {
			return this._configuration
		}
		set configuration(e) {
			this._configuration = e
		}
		getFolder(e) {
			return (e && this.foldersMap.findSubstr(e)) || null
		}
		updateFoldersMap() {
			this.foldersMap = hr.forUris(this.ignorePathCasing, () => !0)
			for (let e of this.folders) this.foldersMap.set(e.uri, e)
		}
		toJSON() {
			return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration }
		}
	},
	Ql = class {
		constructor(e, t) {
			this.raw = t
			;(this.uri = e.uri), (this.index = e.index), (this.name = e.name)
		}
		toResource(e) {
			return ct(this.uri, e)
		}
		toJSON() {
			return { uri: this.uri, name: this.name, index: this.index }
		}
	}
function Nf(o) {
	return new Ql({ uri: o, index: 0, name: cf(o) }, { uri: o.toString() })
}
var sL = "code-workspace",
	q5 = `.${sL}`,
	BG = [{ name: p("codeWorkspace", "Code Workspace"), extensions: [sL] }]
function aL(o) {
	return (typeof o == "string" ? ra(o) : Rv(o)) === q5
}
var bb = class {
		constructor() {
			this._systemSchemes = new Set(Object.keys(W))
			this._providerInfo = new Map()
			this.extUri = new Xi((e) => {
				let t = this._providerInfo.get(e.scheme)
				return !(t === void 0 || t & 1024)
			})
		}
		$acceptProviderInfos(e, t) {
			t === null ? this._providerInfo.delete(e.scheme) : this._providerInfo.set(e.scheme, t)
		}
		isFreeScheme(e) {
			return !this._providerInfo.has(e) && !this._systemSchemes.has(e)
		}
		getCapabilities(e) {
			return this._providerInfo.get(e)
		}
	},
	uo = O("IExtHostFileSystemInfo")
var Ib = Object.freeze({
	create: (o) =>
		oi(o.map((e) => e.toString())).join(`\r
`),
	split: (o) =>
		o.split(`\r
`),
	parse: (o) => Ib.split(o).filter((e) => !e.startsWith("#")),
})
var eQ = new Uint32Array(10)
var tQ = new Uint8Array([114, 82, 115, 101, 69, 102, 97, 113, 81, 116, 84, 100, 119, 87, 99, 122, 120, 118, 103]),
	nQ = new Uint16Array([
		107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520, 27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757,
		108,
	]),
	rQ = new Uint16Array([
		114, 82, 29810, 115, 30579, 26483, 101, 102, 29286, 24934, 29030, 29798, 30822, 30310, 26470, 97, 113, 29809,
		116, 84, 100, 119, 99, 122, 120, 118, 103,
	]),
	oQ = new Uint16Array([
		114, 82, 29810, 115, 30579, 26483, 101, 69, 102, 29286, 24934, 29030, 29798, 30822, 30310, 26470, 97, 113, 81,
		29809, 116, 84, 100, 119, 87, 99, 122, 120, 118, 103, 107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520,
		27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757, 108,
	])
function dL(...o) {
	return function (e, t) {
		for (let n = 0, r = o.length; n < r; n++) {
			let i = o[n](e, t)
			if (i) return i
		}
		return null
	}
}
var pQ = cL.bind(void 0, !1),
	Cb = cL.bind(void 0, !0)
function cL(o, e, t) {
	if (!t || t.length < e.length) return null
	let n
	return o ? (n = Ji(t, e)) : (n = t.indexOf(e) === 0), n ? (e.length > 0 ? [{ start: 0, end: e.length }] : []) : null
}
function K5(o, e) {
	let t = e.toLowerCase().indexOf(o.toLowerCase())
	return t === -1 ? null : [{ start: t, end: t + o.length }]
}
function j5(o, e) {
	return pP(o.toLowerCase(), e.toLowerCase(), 0, 0)
}
function pP(o, e, t, n) {
	if (t === o.length) return []
	if (n === e.length) return null
	if (o[t] === e[n]) {
		let r = null
		return (r = pP(o, e, t + 1, n + 1)) ? pL({ start: n, end: n + 1 }, r) : null
	}
	return pP(o, e, t, n + 1)
}
function fP(o) {
	return 97 <= o && o <= 122
}
function Vc(o) {
	return 65 <= o && o <= 90
}
function gP(o) {
	return 48 <= o && o <= 57
}
function G5(o) {
	return o === 32 || o === 9 || o === 10 || o === 13
}
var Q5 = new Set()
"()[]{}<>`'\"-/;:,.?!".split("").forEach((o) => Q5.add(o.charCodeAt(0)))
function uL(o) {
	return fP(o) || Vc(o) || gP(o)
}
function pL(o, e) {
	return e.length === 0 ? (e = [o]) : o.end === e[0].start ? (e[0].start = o.start) : e.unshift(o), e
}
function mL(o, e) {
	for (let t = e; t < o.length; t++) {
		let n = o.charCodeAt(t)
		if (Vc(n) || gP(n) || (t > 0 && !uL(o.charCodeAt(t - 1)))) return t
	}
	return o.length
}
function mP(o, e, t, n) {
	if (t === o.length) return []
	if (n === e.length) return null
	if (o[t] !== e[n].toLowerCase()) return null
	{
		let r = null,
			i = n + 1
		for (r = mP(o, e, t + 1, n + 1); !r && (i = mL(e, i)) < e.length; ) (r = mP(o, e, t + 1, i)), i++
		return r === null ? null : pL({ start: n, end: n + 1 }, r)
	}
}
function J5(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0,
		i = 0
	for (let c = 0; c < o.length; c++) (i = o.charCodeAt(c)), Vc(i) && e++, fP(i) && t++, uL(i) && n++, gP(i) && r++
	let s = e / o.length,
		a = t / o.length,
		l = n / o.length,
		d = r / o.length
	return { upperPercent: s, lowerPercent: a, alphaPercent: l, numericPercent: d }
}
function X5(o) {
	let { upperPercent: e, lowerPercent: t } = o
	return t === 0 && e > 0.6
}
function Y5(o) {
	let { upperPercent: e, lowerPercent: t, alphaPercent: n, numericPercent: r } = o
	return t > 0.2 && e < 0.8 && n > 0.6 && r < 0.2
}
function Z5(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0
	for (let i = 0; i < o.length; i++) (n = o.charCodeAt(i)), Vc(n) && e++, fP(n) && t++, G5(n) && r++
	return (e === 0 || t === 0) && r === 0 ? o.length <= 30 : e <= 5
}
function fL(o, e) {
	if (!e || ((e = e.trim()), e.length === 0) || !Z5(o)) return null
	e.length > 60 && (e = e.substring(0, 60))
	let t = J5(e)
	if (!Y5(t)) {
		if (!X5(t)) return null
		e = e.toLowerCase()
	}
	let n = null,
		r = 0
	for (o = o.toLowerCase(); r < e.length && (n = mP(o, e, 0, r)) === null; ) r = mL(e, r + 1)
	return n
}
var mQ = dL(Cb, fL, K5),
	fQ = dL(Cb, fL, j5),
	gQ = new _o(1e4)
var xb = 128
function hP() {
	let o = [],
		e = []
	for (let t = 0; t <= xb; t++) e[t] = 0
	for (let t = 0; t <= xb; t++) o.push(e.slice(0))
	return o
}
function gL(o) {
	let e = []
	for (let t = 0; t <= o; t++) e[t] = 0
	return e
}
var hQ = gL(2 * xb),
	vQ = gL(2 * xb),
	bQ = hP(),
	yQ = hP(),
	IQ = hP()
var eW
;((t) => {
	t.Default = [-100, 0]
	function e(n) {
		return !n || (n.length === 2 && n[0] === -100 && n[1] === 0)
	}
	t.isDefault = e
})((eW ||= {}))
var lL = class {
	constructor(e, t) {
		this.firstMatchCanBeWeak = e
		this.boostFullMatch = t
	}
	static {
		this.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 }
	}
}
var vP = Object.create(null)
function v(o, e) {
	if (Ee(e)) {
		let t = vP[e]
		if (t === void 0) throw new Error(`${o} references an unknown codicon: ${e}`)
		e = t
	}
	return (vP[o] = e), { id: o }
}
function hL() {
	return vP
}
var vL = {
	add: v("add", 6e4),
	plus: v("plus", 6e4),
	gistNew: v("gist-new", 6e4),
	repoCreate: v("repo-create", 6e4),
	lightbulb: v("lightbulb", 60001),
	lightBulb: v("light-bulb", 60001),
	repo: v("repo", 60002),
	repoDelete: v("repo-delete", 60002),
	gistFork: v("gist-fork", 60003),
	repoForked: v("repo-forked", 60003),
	gitPullRequest: v("git-pull-request", 60004),
	gitPullRequestAbandoned: v("git-pull-request-abandoned", 60004),
	recordKeys: v("record-keys", 60005),
	keyboard: v("keyboard", 60005),
	tag: v("tag", 60006),
	gitPullRequestLabel: v("git-pull-request-label", 60006),
	tagAdd: v("tag-add", 60006),
	tagRemove: v("tag-remove", 60006),
	person: v("person", 60007),
	personFollow: v("person-follow", 60007),
	personOutline: v("person-outline", 60007),
	personFilled: v("person-filled", 60007),
	gitBranch: v("git-branch", 60008),
	gitBranchCreate: v("git-branch-create", 60008),
	gitBranchDelete: v("git-branch-delete", 60008),
	sourceControl: v("source-control", 60008),
	mirror: v("mirror", 60009),
	mirrorPublic: v("mirror-public", 60009),
	star: v("star", 60010),
	starAdd: v("star-add", 60010),
	starDelete: v("star-delete", 60010),
	starEmpty: v("star-empty", 60010),
	comment: v("comment", 60011),
	commentAdd: v("comment-add", 60011),
	alert: v("alert", 60012),
	warning: v("warning", 60012),
	search: v("search", 60013),
	searchSave: v("search-save", 60013),
	logOut: v("log-out", 60014),
	signOut: v("sign-out", 60014),
	logIn: v("log-in", 60015),
	signIn: v("sign-in", 60015),
	eye: v("eye", 60016),
	eyeUnwatch: v("eye-unwatch", 60016),
	eyeWatch: v("eye-watch", 60016),
	circleFilled: v("circle-filled", 60017),
	primitiveDot: v("primitive-dot", 60017),
	closeDirty: v("close-dirty", 60017),
	debugBreakpoint: v("debug-breakpoint", 60017),
	debugBreakpointDisabled: v("debug-breakpoint-disabled", 60017),
	debugHint: v("debug-hint", 60017),
	terminalDecorationSuccess: v("terminal-decoration-success", 60017),
	primitiveSquare: v("primitive-square", 60018),
	edit: v("edit", 60019),
	pencil: v("pencil", 60019),
	info: v("info", 60020),
	issueOpened: v("issue-opened", 60020),
	gistPrivate: v("gist-private", 60021),
	gitForkPrivate: v("git-fork-private", 60021),
	lock: v("lock", 60021),
	mirrorPrivate: v("mirror-private", 60021),
	close: v("close", 60022),
	removeClose: v("remove-close", 60022),
	x: v("x", 60022),
	repoSync: v("repo-sync", 60023),
	sync: v("sync", 60023),
	clone: v("clone", 60024),
	desktopDownload: v("desktop-download", 60024),
	beaker: v("beaker", 60025),
	microscope: v("microscope", 60025),
	vm: v("vm", 60026),
	deviceDesktop: v("device-desktop", 60026),
	file: v("file", 60027),
	fileText: v("file-text", 60027),
	more: v("more", 60028),
	ellipsis: v("ellipsis", 60028),
	kebabHorizontal: v("kebab-horizontal", 60028),
	mailReply: v("mail-reply", 60029),
	reply: v("reply", 60029),
	organization: v("organization", 60030),
	organizationFilled: v("organization-filled", 60030),
	organizationOutline: v("organization-outline", 60030),
	newFile: v("new-file", 60031),
	fileAdd: v("file-add", 60031),
	newFolder: v("new-folder", 60032),
	fileDirectoryCreate: v("file-directory-create", 60032),
	trash: v("trash", 60033),
	trashcan: v("trashcan", 60033),
	history: v("history", 60034),
	clock: v("clock", 60034),
	folder: v("folder", 60035),
	fileDirectory: v("file-directory", 60035),
	symbolFolder: v("symbol-folder", 60035),
	logoGithub: v("logo-github", 60036),
	markGithub: v("mark-github", 60036),
	github: v("github", 60036),
	terminal: v("terminal", 60037),
	console: v("console", 60037),
	repl: v("repl", 60037),
	zap: v("zap", 60038),
	symbolEvent: v("symbol-event", 60038),
	error: v("error", 60039),
	stop: v("stop", 60039),
	variable: v("variable", 60040),
	symbolVariable: v("symbol-variable", 60040),
	array: v("array", 60042),
	symbolArray: v("symbol-array", 60042),
	symbolModule: v("symbol-module", 60043),
	symbolPackage: v("symbol-package", 60043),
	symbolNamespace: v("symbol-namespace", 60043),
	symbolObject: v("symbol-object", 60043),
	symbolMethod: v("symbol-method", 60044),
	symbolFunction: v("symbol-function", 60044),
	symbolConstructor: v("symbol-constructor", 60044),
	symbolBoolean: v("symbol-boolean", 60047),
	symbolNull: v("symbol-null", 60047),
	symbolNumeric: v("symbol-numeric", 60048),
	symbolNumber: v("symbol-number", 60048),
	symbolStructure: v("symbol-structure", 60049),
	symbolStruct: v("symbol-struct", 60049),
	symbolParameter: v("symbol-parameter", 60050),
	symbolTypeParameter: v("symbol-type-parameter", 60050),
	symbolKey: v("symbol-key", 60051),
	symbolText: v("symbol-text", 60051),
	symbolReference: v("symbol-reference", 60052),
	goToFile: v("go-to-file", 60052),
	symbolEnum: v("symbol-enum", 60053),
	symbolValue: v("symbol-value", 60053),
	symbolRuler: v("symbol-ruler", 60054),
	symbolUnit: v("symbol-unit", 60054),
	activateBreakpoints: v("activate-breakpoints", 60055),
	archive: v("archive", 60056),
	arrowBoth: v("arrow-both", 60057),
	arrowDown: v("arrow-down", 60058),
	arrowLeft: v("arrow-left", 60059),
	arrowRight: v("arrow-right", 60060),
	arrowSmallDown: v("arrow-small-down", 60061),
	arrowSmallLeft: v("arrow-small-left", 60062),
	arrowSmallRight: v("arrow-small-right", 60063),
	arrowSmallUp: v("arrow-small-up", 60064),
	arrowUp: v("arrow-up", 60065),
	bell: v("bell", 60066),
	bold: v("bold", 60067),
	book: v("book", 60068),
	bookmark: v("bookmark", 60069),
	debugBreakpointConditionalUnverified: v("debug-breakpoint-conditional-unverified", 60070),
	debugBreakpointConditional: v("debug-breakpoint-conditional", 60071),
	debugBreakpointConditionalDisabled: v("debug-breakpoint-conditional-disabled", 60071),
	debugBreakpointDataUnverified: v("debug-breakpoint-data-unverified", 60072),
	debugBreakpointData: v("debug-breakpoint-data", 60073),
	debugBreakpointDataDisabled: v("debug-breakpoint-data-disabled", 60073),
	debugBreakpointLogUnverified: v("debug-breakpoint-log-unverified", 60074),
	debugBreakpointLog: v("debug-breakpoint-log", 60075),
	debugBreakpointLogDisabled: v("debug-breakpoint-log-disabled", 60075),
	briefcase: v("briefcase", 60076),
	broadcast: v("broadcast", 60077),
	browser: v("browser", 60078),
	bug: v("bug", 60079),
	calendar: v("calendar", 60080),
	caseSensitive: v("case-sensitive", 60081),
	check: v("check", 60082),
	checklist: v("checklist", 60083),
	chevronDown: v("chevron-down", 60084),
	chevronLeft: v("chevron-left", 60085),
	chevronRight: v("chevron-right", 60086),
	chevronUp: v("chevron-up", 60087),
	chromeClose: v("chrome-close", 60088),
	chromeMaximize: v("chrome-maximize", 60089),
	chromeMinimize: v("chrome-minimize", 60090),
	chromeRestore: v("chrome-restore", 60091),
	circleOutline: v("circle-outline", 60092),
	circle: v("circle", 60092),
	debugBreakpointUnverified: v("debug-breakpoint-unverified", 60092),
	terminalDecorationIncomplete: v("terminal-decoration-incomplete", 60092),
	circleSlash: v("circle-slash", 60093),
	circuitBoard: v("circuit-board", 60094),
	clearAll: v("clear-all", 60095),
	clippy: v("clippy", 60096),
	closeAll: v("close-all", 60097),
	cloudDownload: v("cloud-download", 60098),
	cloudUpload: v("cloud-upload", 60099),
	code: v("code", 60100),
	collapseAll: v("collapse-all", 60101),
	colorMode: v("color-mode", 60102),
	commentDiscussion: v("comment-discussion", 60103),
	creditCard: v("credit-card", 60105),
	dash: v("dash", 60108),
	dashboard: v("dashboard", 60109),
	database: v("database", 60110),
	debugContinue: v("debug-continue", 60111),
	debugDisconnect: v("debug-disconnect", 60112),
	debugPause: v("debug-pause", 60113),
	debugRestart: v("debug-restart", 60114),
	debugStart: v("debug-start", 60115),
	debugStepInto: v("debug-step-into", 60116),
	debugStepOut: v("debug-step-out", 60117),
	debugStepOver: v("debug-step-over", 60118),
	debugStop: v("debug-stop", 60119),
	debug: v("debug", 60120),
	deviceCameraVideo: v("device-camera-video", 60121),
	deviceCamera: v("device-camera", 60122),
	deviceMobile: v("device-mobile", 60123),
	diffAdded: v("diff-added", 60124),
	diffIgnored: v("diff-ignored", 60125),
	diffModified: v("diff-modified", 60126),
	diffRemoved: v("diff-removed", 60127),
	diffRenamed: v("diff-renamed", 60128),
	diff: v("diff", 60129),
	diffSidebyside: v("diff-sidebyside", 60129),
	discard: v("discard", 60130),
	editorLayout: v("editor-layout", 60131),
	emptyWindow: v("empty-window", 60132),
	exclude: v("exclude", 60133),
	extensions: v("extensions", 60134),
	eyeClosed: v("eye-closed", 60135),
	fileBinary: v("file-binary", 60136),
	fileCode: v("file-code", 60137),
	fileMedia: v("file-media", 60138),
	filePdf: v("file-pdf", 60139),
	fileSubmodule: v("file-submodule", 60140),
	fileSymlinkDirectory: v("file-symlink-directory", 60141),
	fileSymlinkFile: v("file-symlink-file", 60142),
	fileZip: v("file-zip", 60143),
	files: v("files", 60144),
	filter: v("filter", 60145),
	flame: v("flame", 60146),
	foldDown: v("fold-down", 60147),
	foldUp: v("fold-up", 60148),
	fold: v("fold", 60149),
	folderActive: v("folder-active", 60150),
	folderOpened: v("folder-opened", 60151),
	gear: v("gear", 60152),
	gift: v("gift", 60153),
	gistSecret: v("gist-secret", 60154),
	gist: v("gist", 60155),
	gitCommit: v("git-commit", 60156),
	gitCompare: v("git-compare", 60157),
	compareChanges: v("compare-changes", 60157),
	gitMerge: v("git-merge", 60158),
	githubAction: v("github-action", 60159),
	githubAlt: v("github-alt", 60160),
	globe: v("globe", 60161),
	grabber: v("grabber", 60162),
	graph: v("graph", 60163),
	gripper: v("gripper", 60164),
	heart: v("heart", 60165),
	home: v("home", 60166),
	horizontalRule: v("horizontal-rule", 60167),
	hubot: v("hubot", 60168),
	inbox: v("inbox", 60169),
	issueReopened: v("issue-reopened", 60171),
	issues: v("issues", 60172),
	italic: v("italic", 60173),
	jersey: v("jersey", 60174),
	json: v("json", 60175),
	kebabVertical: v("kebab-vertical", 60176),
	key: v("key", 60177),
	law: v("law", 60178),
	lightbulbAutofix: v("lightbulb-autofix", 60179),
	linkExternal: v("link-external", 60180),
	link: v("link", 60181),
	listOrdered: v("list-ordered", 60182),
	listUnordered: v("list-unordered", 60183),
	liveShare: v("live-share", 60184),
	loading: v("loading", 60185),
	location: v("location", 60186),
	mailRead: v("mail-read", 60187),
	mail: v("mail", 60188),
	markdown: v("markdown", 60189),
	megaphone: v("megaphone", 60190),
	mention: v("mention", 60191),
	milestone: v("milestone", 60192),
	gitPullRequestMilestone: v("git-pull-request-milestone", 60192),
	mortarBoard: v("mortar-board", 60193),
	move: v("move", 60194),
	multipleWindows: v("multiple-windows", 60195),
	mute: v("mute", 60196),
	noNewline: v("no-newline", 60197),
	note: v("note", 60198),
	octoface: v("octoface", 60199),
	openPreview: v("open-preview", 60200),
	package: v("package", 60201),
	paintcan: v("paintcan", 60202),
	pin: v("pin", 60203),
	play: v("play", 60204),
	run: v("run", 60204),
	plug: v("plug", 60205),
	preserveCase: v("preserve-case", 60206),
	preview: v("preview", 60207),
	project: v("project", 60208),
	pulse: v("pulse", 60209),
	question: v("question", 60210),
	quote: v("quote", 60211),
	radioTower: v("radio-tower", 60212),
	reactions: v("reactions", 60213),
	references: v("references", 60214),
	refresh: v("refresh", 60215),
	regex: v("regex", 60216),
	remoteExplorer: v("remote-explorer", 60217),
	remote: v("remote", 60218),
	remove: v("remove", 60219),
	replaceAll: v("replace-all", 60220),
	replace: v("replace", 60221),
	repoClone: v("repo-clone", 60222),
	repoForcePush: v("repo-force-push", 60223),
	repoPull: v("repo-pull", 60224),
	repoPush: v("repo-push", 60225),
	report: v("report", 60226),
	requestChanges: v("request-changes", 60227),
	rocket: v("rocket", 60228),
	rootFolderOpened: v("root-folder-opened", 60229),
	rootFolder: v("root-folder", 60230),
	rss: v("rss", 60231),
	ruby: v("ruby", 60232),
	saveAll: v("save-all", 60233),
	saveAs: v("save-as", 60234),
	save: v("save", 60235),
	screenFull: v("screen-full", 60236),
	screenNormal: v("screen-normal", 60237),
	searchStop: v("search-stop", 60238),
	server: v("server", 60240),
	settingsGear: v("settings-gear", 60241),
	settings: v("settings", 60242),
	shield: v("shield", 60243),
	smiley: v("smiley", 60244),
	sortPrecedence: v("sort-precedence", 60245),
	splitHorizontal: v("split-horizontal", 60246),
	splitVertical: v("split-vertical", 60247),
	squirrel: v("squirrel", 60248),
	starFull: v("star-full", 60249),
	starHalf: v("star-half", 60250),
	symbolClass: v("symbol-class", 60251),
	symbolColor: v("symbol-color", 60252),
	symbolConstant: v("symbol-constant", 60253),
	symbolEnumMember: v("symbol-enum-member", 60254),
	symbolField: v("symbol-field", 60255),
	symbolFile: v("symbol-file", 60256),
	symbolInterface: v("symbol-interface", 60257),
	symbolKeyword: v("symbol-keyword", 60258),
	symbolMisc: v("symbol-misc", 60259),
	symbolOperator: v("symbol-operator", 60260),
	symbolProperty: v("symbol-property", 60261),
	wrench: v("wrench", 60261),
	wrenchSubaction: v("wrench-subaction", 60261),
	symbolSnippet: v("symbol-snippet", 60262),
	tasklist: v("tasklist", 60263),
	telescope: v("telescope", 60264),
	textSize: v("text-size", 60265),
	threeBars: v("three-bars", 60266),
	thumbsdown: v("thumbsdown", 60267),
	thumbsup: v("thumbsup", 60268),
	tools: v("tools", 60269),
	triangleDown: v("triangle-down", 60270),
	triangleLeft: v("triangle-left", 60271),
	triangleRight: v("triangle-right", 60272),
	triangleUp: v("triangle-up", 60273),
	twitter: v("twitter", 60274),
	unfold: v("unfold", 60275),
	unlock: v("unlock", 60276),
	unmute: v("unmute", 60277),
	unverified: v("unverified", 60278),
	verified: v("verified", 60279),
	versions: v("versions", 60280),
	vmActive: v("vm-active", 60281),
	vmOutline: v("vm-outline", 60282),
	vmRunning: v("vm-running", 60283),
	watch: v("watch", 60284),
	whitespace: v("whitespace", 60285),
	wholeWord: v("whole-word", 60286),
	window: v("window", 60287),
	wordWrap: v("word-wrap", 60288),
	zoomIn: v("zoom-in", 60289),
	zoomOut: v("zoom-out", 60290),
	listFilter: v("list-filter", 60291),
	listFlat: v("list-flat", 60292),
	listSelection: v("list-selection", 60293),
	selection: v("selection", 60293),
	listTree: v("list-tree", 60294),
	debugBreakpointFunctionUnverified: v("debug-breakpoint-function-unverified", 60295),
	debugBreakpointFunction: v("debug-breakpoint-function", 60296),
	debugBreakpointFunctionDisabled: v("debug-breakpoint-function-disabled", 60296),
	debugStackframeActive: v("debug-stackframe-active", 60297),
	circleSmallFilled: v("circle-small-filled", 60298),
	debugStackframeDot: v("debug-stackframe-dot", 60298),
	terminalDecorationMark: v("terminal-decoration-mark", 60298),
	debugStackframe: v("debug-stackframe", 60299),
	debugStackframeFocused: v("debug-stackframe-focused", 60299),
	debugBreakpointUnsupported: v("debug-breakpoint-unsupported", 60300),
	symbolString: v("symbol-string", 60301),
	debugReverseContinue: v("debug-reverse-continue", 60302),
	debugStepBack: v("debug-step-back", 60303),
	debugRestartFrame: v("debug-restart-frame", 60304),
	debugAlt: v("debug-alt", 60305),
	callIncoming: v("call-incoming", 60306),
	callOutgoing: v("call-outgoing", 60307),
	menu: v("menu", 60308),
	expandAll: v("expand-all", 60309),
	feedback: v("feedback", 60310),
	gitPullRequestReviewer: v("git-pull-request-reviewer", 60310),
	groupByRefType: v("group-by-ref-type", 60311),
	ungroupByRefType: v("ungroup-by-ref-type", 60312),
	account: v("account", 60313),
	gitPullRequestAssignee: v("git-pull-request-assignee", 60313),
	bellDot: v("bell-dot", 60314),
	debugConsole: v("debug-console", 60315),
	library: v("library", 60316),
	output: v("output", 60317),
	runAll: v("run-all", 60318),
	syncIgnored: v("sync-ignored", 60319),
	pinned: v("pinned", 60320),
	githubInverted: v("github-inverted", 60321),
	serverProcess: v("server-process", 60322),
	serverEnvironment: v("server-environment", 60323),
	pass: v("pass", 60324),
	issueClosed: v("issue-closed", 60324),
	stopCircle: v("stop-circle", 60325),
	playCircle: v("play-circle", 60326),
	record: v("record", 60327),
	debugAltSmall: v("debug-alt-small", 60328),
	vmConnect: v("vm-connect", 60329),
	cloud: v("cloud", 60330),
	merge: v("merge", 60331),
	export: v("export", 60332),
	graphLeft: v("graph-left", 60333),
	magnet: v("magnet", 60334),
	notebook: v("notebook", 60335),
	redo: v("redo", 60336),
	checkAll: v("check-all", 60337),
	pinnedDirty: v("pinned-dirty", 60338),
	passFilled: v("pass-filled", 60339),
	circleLargeFilled: v("circle-large-filled", 60340),
	circleLarge: v("circle-large", 60341),
	circleLargeOutline: v("circle-large-outline", 60341),
	combine: v("combine", 60342),
	gather: v("gather", 60342),
	table: v("table", 60343),
	variableGroup: v("variable-group", 60344),
	typeHierarchy: v("type-hierarchy", 60345),
	typeHierarchySub: v("type-hierarchy-sub", 60346),
	typeHierarchySuper: v("type-hierarchy-super", 60347),
	gitPullRequestCreate: v("git-pull-request-create", 60348),
	runAbove: v("run-above", 60349),
	runBelow: v("run-below", 60350),
	notebookTemplate: v("notebook-template", 60351),
	debugRerun: v("debug-rerun", 60352),
	workspaceTrusted: v("workspace-trusted", 60353),
	workspaceUntrusted: v("workspace-untrusted", 60354),
	workspaceUnknown: v("workspace-unknown", 60355),
	terminalCmd: v("terminal-cmd", 60356),
	terminalDebian: v("terminal-debian", 60357),
	terminalLinux: v("terminal-linux", 60358),
	terminalPowershell: v("terminal-powershell", 60359),
	terminalTmux: v("terminal-tmux", 60360),
	terminalUbuntu: v("terminal-ubuntu", 60361),
	terminalBash: v("terminal-bash", 60362),
	arrowSwap: v("arrow-swap", 60363),
	copy: v("copy", 60364),
	personAdd: v("person-add", 60365),
	filterFilled: v("filter-filled", 60366),
	wand: v("wand", 60367),
	debugLineByLine: v("debug-line-by-line", 60368),
	inspect: v("inspect", 60369),
	layers: v("layers", 60370),
	layersDot: v("layers-dot", 60371),
	layersActive: v("layers-active", 60372),
	compass: v("compass", 60373),
	compassDot: v("compass-dot", 60374),
	compassActive: v("compass-active", 60375),
	azure: v("azure", 60376),
	issueDraft: v("issue-draft", 60377),
	gitPullRequestClosed: v("git-pull-request-closed", 60378),
	gitPullRequestDraft: v("git-pull-request-draft", 60379),
	debugAll: v("debug-all", 60380),
	debugCoverage: v("debug-coverage", 60381),
	runErrors: v("run-errors", 60382),
	folderLibrary: v("folder-library", 60383),
	debugContinueSmall: v("debug-continue-small", 60384),
	beakerStop: v("beaker-stop", 60385),
	graphLine: v("graph-line", 60386),
	graphScatter: v("graph-scatter", 60387),
	pieChart: v("pie-chart", 60388),
	bracket: v("bracket", 60175),
	bracketDot: v("bracket-dot", 60389),
	bracketError: v("bracket-error", 60390),
	lockSmall: v("lock-small", 60391),
	azureDevops: v("azure-devops", 60392),
	verifiedFilled: v("verified-filled", 60393),
	newline: v("newline", 60394),
	layout: v("layout", 60395),
	layoutActivitybarLeft: v("layout-activitybar-left", 60396),
	layoutActivitybarRight: v("layout-activitybar-right", 60397),
	layoutPanelLeft: v("layout-panel-left", 60398),
	layoutPanelCenter: v("layout-panel-center", 60399),
	layoutPanelJustify: v("layout-panel-justify", 60400),
	layoutPanelRight: v("layout-panel-right", 60401),
	layoutPanel: v("layout-panel", 60402),
	layoutSidebarLeft: v("layout-sidebar-left", 60403),
	layoutSidebarRight: v("layout-sidebar-right", 60404),
	layoutStatusbar: v("layout-statusbar", 60405),
	layoutMenubar: v("layout-menubar", 60406),
	layoutCentered: v("layout-centered", 60407),
	target: v("target", 60408),
	indent: v("indent", 60409),
	recordSmall: v("record-small", 60410),
	errorSmall: v("error-small", 60411),
	terminalDecorationError: v("terminal-decoration-error", 60411),
	arrowCircleDown: v("arrow-circle-down", 60412),
	arrowCircleLeft: v("arrow-circle-left", 60413),
	arrowCircleRight: v("arrow-circle-right", 60414),
	arrowCircleUp: v("arrow-circle-up", 60415),
	layoutSidebarRightOff: v("layout-sidebar-right-off", 60416),
	layoutPanelOff: v("layout-panel-off", 60417),
	layoutSidebarLeftOff: v("layout-sidebar-left-off", 60418),
	blank: v("blank", 60419),
	heartFilled: v("heart-filled", 60420),
	map: v("map", 60421),
	mapHorizontal: v("map-horizontal", 60421),
	foldHorizontal: v("fold-horizontal", 60421),
	mapFilled: v("map-filled", 60422),
	mapHorizontalFilled: v("map-horizontal-filled", 60422),
	foldHorizontalFilled: v("fold-horizontal-filled", 60422),
	circleSmall: v("circle-small", 60423),
	bellSlash: v("bell-slash", 60424),
	bellSlashDot: v("bell-slash-dot", 60425),
	commentUnresolved: v("comment-unresolved", 60426),
	gitPullRequestGoToChanges: v("git-pull-request-go-to-changes", 60427),
	gitPullRequestNewChanges: v("git-pull-request-new-changes", 60428),
	searchFuzzy: v("search-fuzzy", 60429),
	commentDraft: v("comment-draft", 60430),
	send: v("send", 60431),
	sparkle: v("sparkle", 60432),
	insert: v("insert", 60433),
	mic: v("mic", 60434),
	thumbsdownFilled: v("thumbsdown-filled", 60435),
	thumbsupFilled: v("thumbsup-filled", 60436),
	coffee: v("coffee", 60437),
	snake: v("snake", 60438),
	game: v("game", 60439),
	vr: v("vr", 60440),
	chip: v("chip", 60441),
	piano: v("piano", 60442),
	music: v("music", 60443),
	micFilled: v("mic-filled", 60444),
	repoFetch: v("repo-fetch", 60445),
	copilot: v("copilot", 60446),
	lightbulbSparkle: v("lightbulb-sparkle", 60447),
	robot: v("robot", 60448),
	sparkleFilled: v("sparkle-filled", 60449),
	diffSingle: v("diff-single", 60450),
	diffMultiple: v("diff-multiple", 60451),
	surroundWith: v("surround-with", 60452),
	share: v("share", 60453),
	gitStash: v("git-stash", 60454),
	gitStashApply: v("git-stash-apply", 60455),
	gitStashPop: v("git-stash-pop", 60456),
	vscode: v("vscode", 60457),
	vscodeInsiders: v("vscode-insiders", 60458),
	codeOss: v("code-oss", 60459),
	runCoverage: v("run-coverage", 60460),
	runAllCoverage: v("run-all-coverage", 60461),
	coverage: v("coverage", 60462),
	githubProject: v("github-project", 60463),
	mapVertical: v("map-vertical", 60464),
	foldVertical: v("fold-vertical", 60464),
	mapVerticalFilled: v("map-vertical-filled", 60465),
	foldVerticalFilled: v("fold-vertical-filled", 60465),
	goToSearch: v("go-to-search", 60466),
	percentage: v("percentage", 60467),
	sortPercentage: v("sort-percentage", 60467),
	attach: v("attach", 60468),
	goToEditingSession: v("go-to-editing-session", 60469),
	editSession: v("edit-session", 60470),
	codeReview: v("code-review", 60471),
	copilotWarning: v("copilot-warning", 60472),
	python: v("python", 60473),
	copilotLarge: v("copilot-large", 60474),
	copilotWarningLarge: v("copilot-warning-large", 60475),
	keyboardTab: v("keyboard-tab", 60476),
	copilotBlocked: v("copilot-blocked", 60477),
	copilotNotConnected: v("copilot-not-connected", 60478),
	flag: v("flag", 60479),
	lightbulbEmpty: v("lightbulb-empty", 60480),
	symbolMethodArrow: v("symbol-method-arrow", 60481),
	copilotUnavailable: v("copilot-unavailable", 60482),
	repoPinned: v("repo-pinned", 60483),
	keyboardTabAbove: v("keyboard-tab-above", 60484),
	keyboardTabBelow: v("keyboard-tab-below", 60485),
}
var tW = {
		dialogError: v("dialog-error", "error"),
		dialogWarning: v("dialog-warning", "warning"),
		dialogInfo: v("dialog-info", "info"),
		dialogClose: v("dialog-close", "close"),
		treeItemExpanded: v("tree-item-expanded", "chevron-down"),
		treeFilterOnTypeOn: v("tree-filter-on-type-on", "list-filter"),
		treeFilterOnTypeOff: v("tree-filter-on-type-off", "list-selection"),
		treeFilterClear: v("tree-filter-clear", "close"),
		treeItemLoading: v("tree-item-loading", "loading"),
		menuSelection: v("menu-selection", "check"),
		menuSubmenu: v("menu-submenu", "chevron-right"),
		menuBarMore: v("menubar-more", "more"),
		scrollbarButtonLeft: v("scrollbar-button-left", "triangle-left"),
		scrollbarButtonRight: v("scrollbar-button-right", "triangle-right"),
		scrollbarButtonUp: v("scrollbar-button-up", "triangle-up"),
		scrollbarButtonDown: v("scrollbar-button-down", "triangle-down"),
		toolBarMore: v("toolbar-more", "more"),
		quickInputBack: v("quick-input-back", "arrow-left"),
		dropDownButton: v("drop-down-button", 60084),
		symbolCustomColor: v("symbol-customcolor", 60252),
		exportIcon: v("export", 60332),
		workspaceUnspecified: v("workspace-unspecified", 60355),
		newLine: v("newline", 60394),
		thumbsDownFilled: v("thumbsdown-filled", 60435),
		thumbsUpFilled: v("thumbsup-filled", 60436),
		gitFetch: v("git-fetch", 60445),
		lightbulbSparkleAutofix: v("lightbulb-sparkle-autofix", 60447),
		debugBreakpointPending: v("debug-breakpoint-pending", 60377),
	},
	ce = { ...vL, ...tW }
var Bc
;((e) => {
	function o(t) {
		return t && typeof t == "object" && typeof t.id == "string"
	}
	e.isThemeColor = o
})((Bc ||= {}))
var Yt
;((g) => {
	;(g.iconNameSegment = "[A-Za-z0-9]+"),
		(g.iconNameExpression = "[A-Za-z0-9-]+"),
		(g.iconModifierExpression = "~[A-Za-z]+"),
		(g.iconNameCharacter = "[A-Za-z0-9~-]")
	let r = new RegExp(`^(${g.iconNameExpression})(${g.iconModifierExpression})?$`)
	function i(I) {
		let C = r.exec(I.id)
		if (!C) return i(ce.error)
		let [, T, w] = C,
			L = ["codicon", "codicon-" + T]
		return w && L.push("codicon-modifier-" + w.substring(1)), L
	}
	g.asClassNameArray = i
	function s(I) {
		return i(I).join(" ")
	}
	g.asClassName = s
	function a(I) {
		return "." + i(I).join(".")
	}
	g.asCSSSelector = a
	function l(I) {
		return (
			I && typeof I == "object" && typeof I.id == "string" && (typeof I.color > "u" || Bc.isThemeColor(I.color))
		)
	}
	g.isThemeIcon = l
	let d = new RegExp(`^\\$\\((${g.iconNameExpression}(?:${g.iconModifierExpression})?)\\)$`)
	function c(I) {
		let C = d.exec(I)
		if (!C) return
		let [, T] = C
		return { id: T }
	}
	g.fromString = c
	function u(I) {
		return { id: I }
	}
	g.fromId = u
	function m(I, C) {
		let T = I.id,
			w = T.lastIndexOf("~")
		return w !== -1 && (T = T.substring(0, w)), C && (T = `${T}~${C}`), { id: T }
	}
	g.modify = m
	function f(I) {
		let C = I.id.lastIndexOf("~")
		if (C !== -1) return I.id.substring(C + 1)
	}
	g.getModifier = f
	function h(I, C) {
		return I.id === C.id && I.color?.id === C.color?.id
	}
	g.isEqual = h
})((Yt ||= {}))
var bP = new RegExp(`\\$\\(${Yt.iconNameExpression}(?:${Yt.iconModifierExpression})?\\)`, "g"),
	nW = new RegExp(`(\\\\)?${bP.source}`, "g")
function bL(o) {
	return o.replace(nW, (e, t) => (t ? e : `\\${e}`))
}
var FQ = new RegExp(`\\\\${bP.source}`, "g")
var NQ = new RegExp(`(\\s)?(\\\\)?${bP.source}(\\s)?`, "g")
var UQ = new RegExp(`\\$\\(${Yt.iconNameCharacter}+\\)`, "g")
var Vo = class o {
	static lift(e) {
		let t = new o(e.value, e)
		return (t.uris = e.uris), (t.baseUri = e.baseUri ? y.revive(e.baseUri) : void 0), t
	}
	constructor(e = "", t = !1) {
		if (((this.value = e), typeof this.value != "string")) throw We("value")
		typeof t == "boolean"
			? ((this.isTrusted = t), (this.supportThemeIcons = !1), (this.supportHtml = !1))
			: ((this.isTrusted = t.isTrusted ?? void 0),
				(this.supportThemeIcons = t.supportThemeIcons ?? !1),
				(this.supportHtml = t.supportHtml ?? !1))
	}
	appendText(e, t = 0) {
		return (
			(this.value += rW(this.supportThemeIcons ? bL(e) : e)
				.replace(/([ \t]+)/g, (n, r) => "&nbsp;".repeat(r.length))
				.replace(/\>/gm, "\\>")
				.replace(
					/\n/g,
					t === 1
						? `\\
`
						: `

`,
				)),
			this
		)
	}
	appendMarkdown(e) {
		return (this.value += e), this
	}
	appendCodeblock(e, t) {
		return (
			(this.value += `
${oW(t, e)}
`),
			this
		)
	}
	appendLink(e, t, n) {
		return (
			(this.value += "["),
			(this.value += this._escape(t, "]")),
			(this.value += "]("),
			(this.value += this._escape(String(e), ")")),
			n && (this.value += ` "${this._escape(this._escape(n, '"'), ")")}"`),
			(this.value += ")"),
			this
		)
	}
	_escape(e, t) {
		let n = new RegExp(_r(t), "g")
		return e.replace(n, (r, i) => (e.charAt(i - 1) !== "\\" ? `\\${r}` : r))
	}
}
function Kr(o) {
	return o instanceof Vo
		? !0
		: o && typeof o == "object"
			? typeof o.value == "string" &&
				(typeof o.isTrusted == "boolean" || typeof o.isTrusted == "object" || o.isTrusted === void 0) &&
				(typeof o.supportThemeIcons == "boolean" || o.supportThemeIcons === void 0)
			: !1
}
function rW(o) {
	return o.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&")
}
function oW(o, e) {
	let t = o.match(/^`+/gm)?.reduce((r, i) => (r.length > i.length ? r : i)).length ?? 0,
		n = t >= 3 ? t + 1 : 3
	return [`${"`".repeat(n)}${e}`, o, `${"`".repeat(n)}`].join(`
`)
}
function yL(o) {
	let e = [],
		t = o.split("|").map((r) => r.trim())
	o = t[0]
	let n = t[1]
	if (n) {
		let r = /height=(\d+)/.exec(n),
			i = /width=(\d+)/.exec(n),
			s = r ? r[1] : "",
			a = i ? i[1] : "",
			l = isFinite(parseInt(a)),
			d = isFinite(parseInt(s))
		l && e.push(`width="${a}"`), d && e.push(`height="${s}"`)
	}
	return { href: o, dimensions: e }
}
function xP() {
	return {
		async: !1,
		breaks: !1,
		extensions: null,
		gfm: !0,
		hooks: null,
		pedantic: !1,
		renderer: null,
		silent: !1,
		tokenizer: null,
		walkTokens: null,
	}
}
var Xl = xP()
function EL(o) {
	Xl = o
}
var wL = /[&<>"']/,
	sW = new RegExp(wL.source, "g"),
	PL = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
	aW = new RegExp(PL.source, "g"),
	lW = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
	IL = (o) => lW[o]
function jr(o, e) {
	if (e) {
		if (wL.test(o)) return o.replace(sW, IL)
	} else if (PL.test(o)) return o.replace(aW, IL)
	return o
}
var dW = /(^|[^\[])\^/g
function At(o, e) {
	let t = typeof o == "string" ? o : o.source
	e = e || ""
	let n = {
		replace: (r, i) => {
			let s = typeof i == "string" ? i : i.source
			return (s = s.replace(dW, "$1")), (t = t.replace(r, s)), n
		},
		getRegex: () => new RegExp(t, e),
	}
	return n
}
function xL(o) {
	try {
		o = encodeURI(o).replace(/%25/g, "%")
	} catch {
		return null
	}
	return o
}
var Wf = { exec: () => null }
function CL(o, e) {
	let t = o.replace(/\|/g, (i, s, a) => {
			let l = !1,
				d = s
			for (; --d >= 0 && a[d] === "\\"; ) l = !l
			return l ? "|" : " |"
		}),
		n = t.split(/ \|/),
		r = 0
	if ((n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e))
		if (n.length > e) n.splice(e)
		else for (; n.length < e; ) n.push("")
	for (; r < n.length; r++) n[r] = n[r].trim().replace(/\\\|/g, "|")
	return n
}
function Uf(o, e, t) {
	let n = o.length
	if (n === 0) return ""
	let r = 0
	for (; r < n; ) {
		let i = o.charAt(n - r - 1)
		if (i === e && !t) r++
		else if (i !== e && t) r++
		else break
	}
	return o.slice(0, n - r)
}
function cW(o, e) {
	if (o.indexOf(e[1]) === -1) return -1
	let t = 0
	for (let n = 0; n < o.length; n++)
		if (o[n] === "\\") n++
		else if (o[n] === e[0]) t++
		else if (o[n] === e[1] && (t--, t < 0)) return n
	return -1
}
function SL(o, e, t, n) {
	let r = e.href,
		i = e.title ? jr(e.title) : null,
		s = o[1].replace(/\\([\[\]])/g, "$1")
	if (o[0].charAt(0) !== "!") {
		n.state.inLink = !0
		let a = { type: "link", raw: t, href: r, title: i, text: s, tokens: n.inlineTokens(s) }
		return (n.state.inLink = !1), a
	}
	return { type: "image", raw: t, href: r, title: i, text: jr(s) }
}
function uW(o, e) {
	let t = o.match(/^(\s+)(?:```)/)
	if (t === null) return e
	let n = t[1]
	return e
		.split(
			`
`,
		)
		.map((r) => {
			let i = r.match(/^\s+/)
			if (i === null) return r
			let [s] = i
			return s.length >= n.length ? r.slice(n.length) : r
		}).join(`
`)
}
var zc = class {
		options
		rules
		lexer
		constructor(e) {
			this.options = e || Xl
		}
		space(e) {
			let t = this.rules.block.newline.exec(e)
			if (t && t[0].length > 0) return { type: "space", raw: t[0] }
		}
		code(e) {
			let t = this.rules.block.code.exec(e)
			if (t) {
				let n = t[0].replace(/^ {1,4}/gm, "")
				return {
					type: "code",
					raw: t[0],
					codeBlockStyle: "indented",
					text: this.options.pedantic
						? n
						: Uf(
								n,
								`
`,
							),
				}
			}
		}
		fences(e) {
			let t = this.rules.block.fences.exec(e)
			if (t) {
				let n = t[0],
					r = uW(n, t[3] || "")
				return {
					type: "code",
					raw: n,
					lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
					text: r,
				}
			}
		}
		heading(e) {
			let t = this.rules.block.heading.exec(e)
			if (t) {
				let n = t[2].trim()
				if (/#$/.test(n)) {
					let r = Uf(n, "#")
					;(this.options.pedantic || !r || / $/.test(r)) && (n = r.trim())
				}
				return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) }
			}
		}
		hr(e) {
			let t = this.rules.block.hr.exec(e)
			if (t)
				return {
					type: "hr",
					raw: Uf(
						t[0],
						`
`,
					),
				}
		}
		blockquote(e) {
			let t = this.rules.block.blockquote.exec(e)
			if (t) {
				let n = Uf(
						t[0],
						`
`,
					).split(`
`),
					r = "",
					i = "",
					s = []
				for (; n.length > 0; ) {
					let a = !1,
						l = [],
						d
					for (d = 0; d < n.length; d++)
						if (/^ {0,3}>/.test(n[d])) l.push(n[d]), (a = !0)
						else if (!a) l.push(n[d])
						else break
					n = n.slice(d)
					let c = l.join(`
`),
						u = c
							.replace(
								/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
								`
    $1`,
							)
							.replace(/^ {0,3}>[ \t]?/gm, "")
					;(r = r
						? `${r}
${c}`
						: c),
						(i = i
							? `${i}
${u}`
							: u)
					let m = this.lexer.state.top
					if (
						((this.lexer.state.top = !0),
						this.lexer.blockTokens(u, s, !0),
						(this.lexer.state.top = m),
						n.length === 0)
					)
						break
					let f = s[s.length - 1]
					if (f?.type === "code") break
					if (f?.type === "blockquote") {
						let h = f,
							g =
								h.raw +
								`
` +
								n.join(`
`),
							I = this.blockquote(g)
						;(s[s.length - 1] = I),
							(r = r.substring(0, r.length - h.raw.length) + I.raw),
							(i = i.substring(0, i.length - h.text.length) + I.text)
						break
					} else if (f?.type === "list") {
						let h = f,
							g =
								h.raw +
								`
` +
								n.join(`
`),
							I = this.list(g)
						;(s[s.length - 1] = I),
							(r = r.substring(0, r.length - f.raw.length) + I.raw),
							(i = i.substring(0, i.length - h.raw.length) + I.raw),
							(n = g.substring(s[s.length - 1].raw.length).split(`
`))
						continue
					}
				}
				return { type: "blockquote", raw: r, tokens: s, text: i }
			}
		}
		list(e) {
			let t = this.rules.block.list.exec(e)
			if (t) {
				let n = t[1].trim(),
					r = n.length > 1,
					i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: !1, items: [] }
				;(n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`), this.options.pedantic && (n = r ? n : "[*+-]")
				let s = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`),
					a = !1
				for (; e; ) {
					let l = !1,
						d = "",
						c = ""
					if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break
					;(d = t[0]), (e = e.substring(d.length))
					let u = t[2]
							.split(
								`
`,
								1,
							)[0]
							.replace(/^\t+/, (C) => " ".repeat(3 * C.length)),
						m = e.split(
							`
`,
							1,
						)[0],
						f = !u.trim(),
						h = 0
					if (
						(this.options.pedantic
							? ((h = 2), (c = u.trimStart()))
							: f
								? (h = t[1].length + 1)
								: ((h = t[2].search(/[^ ]/)),
									(h = h > 4 ? 1 : h),
									(c = u.slice(h)),
									(h += t[1].length)),
						f &&
							/^ *$/.test(m) &&
							((d +=
								m +
								`
`),
							(e = e.substring(m.length + 1)),
							(l = !0)),
						!l)
					) {
						let C = new RegExp(
								`^ {0,${Math.min(3, h - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`,
							),
							T = new RegExp(
								`^ {0,${Math.min(3, h - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`,
							),
							w = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:\`\`\`|~~~)`),
							L = new RegExp(`^ {0,${Math.min(3, h - 1)}}#`)
						for (; e; ) {
							let A = e.split(
								`
`,
								1,
							)[0]
							if (
								((m = A),
								this.options.pedantic && (m = m.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
								w.test(m) || L.test(m) || C.test(m) || T.test(e))
							)
								break
							if (m.search(/[^ ]/) >= h || !m.trim())
								c +=
									`
` + m.slice(h)
							else {
								if (f || u.search(/[^ ]/) >= 4 || w.test(u) || L.test(u) || T.test(u)) break
								c +=
									`
` + m
							}
							!f && !m.trim() && (f = !0),
								(d +=
									A +
									`
`),
								(e = e.substring(A.length + 1)),
								(u = m.slice(h))
						}
					}
					i.loose || (a ? (i.loose = !0) : /\n *\n *$/.test(d) && (a = !0))
					let g = null,
						I
					this.options.gfm &&
						((g = /^\[[ xX]\] /.exec(c)),
						g && ((I = g[0] !== "[ ] "), (c = c.replace(/^\[[ xX]\] +/, "")))),
						i.items.push({
							type: "list_item",
							raw: d,
							task: !!g,
							checked: I,
							loose: !1,
							text: c,
							tokens: [],
						}),
						(i.raw += d)
				}
				;(i.items[i.items.length - 1].raw = i.items[i.items.length - 1].raw.trimEnd()),
					(i.items[i.items.length - 1].text = i.items[i.items.length - 1].text.trimEnd()),
					(i.raw = i.raw.trimEnd())
				for (let l = 0; l < i.items.length; l++)
					if (
						((this.lexer.state.top = !1),
						(i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, [])),
						!i.loose)
					) {
						let d = i.items[l].tokens.filter((u) => u.type === "space"),
							c = d.length > 0 && d.some((u) => /\n.*\n/.test(u.raw))
						i.loose = c
					}
				if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = !0
				return i
			}
		}
		html(e) {
			let t = this.rules.block.html.exec(e)
			if (t)
				return {
					type: "html",
					block: !0,
					raw: t[0],
					pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
					text: t[0],
				}
		}
		def(e) {
			let t = this.rules.block.def.exec(e)
			if (t) {
				let n = t[1].toLowerCase().replace(/\s+/g, " "),
					r = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "",
					i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3]
				return { type: "def", tag: n, raw: t[0], href: r, title: i }
			}
		}
		table(e) {
			let t = this.rules.block.table.exec(e)
			if (!t || !/[:|]/.test(t[2])) return
			let n = CL(t[1]),
				r = t[2].replace(/^\||\| *$/g, "").split("|"),
				i =
					t[3] && t[3].trim()
						? t[3].replace(/\n[ \t]*$/, "").split(`
`)
						: [],
				s = { type: "table", raw: t[0], header: [], align: [], rows: [] }
			if (n.length === r.length) {
				for (let a of r)
					/^ *-+: *$/.test(a)
						? s.align.push("right")
						: /^ *:-+: *$/.test(a)
							? s.align.push("center")
							: /^ *:-+ *$/.test(a)
								? s.align.push("left")
								: s.align.push(null)
				for (let a = 0; a < n.length; a++)
					s.header.push({ text: n[a], tokens: this.lexer.inline(n[a]), header: !0, align: s.align[a] })
				for (let a of i)
					s.rows.push(
						CL(a, s.header.length).map((l, d) => ({
							text: l,
							tokens: this.lexer.inline(l),
							header: !1,
							align: s.align[d],
						})),
					)
				return s
			}
		}
		lheading(e) {
			let t = this.rules.block.lheading.exec(e)
			if (t)
				return {
					type: "heading",
					raw: t[0],
					depth: t[2].charAt(0) === "=" ? 1 : 2,
					text: t[1],
					tokens: this.lexer.inline(t[1]),
				}
		}
		paragraph(e) {
			let t = this.rules.block.paragraph.exec(e)
			if (t) {
				let n =
					t[1].charAt(t[1].length - 1) ===
					`
`
						? t[1].slice(0, -1)
						: t[1]
				return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) }
			}
		}
		text(e) {
			let t = this.rules.block.text.exec(e)
			if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) }
		}
		escape(e) {
			let t = this.rules.inline.escape.exec(e)
			if (t) return { type: "escape", raw: t[0], text: jr(t[1]) }
		}
		tag(e) {
			let t = this.rules.inline.tag.exec(e)
			if (t)
				return (
					!this.lexer.state.inLink && /^<a /i.test(t[0])
						? (this.lexer.state.inLink = !0)
						: this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1),
					!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0])
						? (this.lexer.state.inRawBlock = !0)
						: this.lexer.state.inRawBlock &&
							/^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) &&
							(this.lexer.state.inRawBlock = !1),
					{
						type: "html",
						raw: t[0],
						inLink: this.lexer.state.inLink,
						inRawBlock: this.lexer.state.inRawBlock,
						block: !1,
						text: t[0],
					}
				)
		}
		link(e) {
			let t = this.rules.inline.link.exec(e)
			if (t) {
				let n = t[2].trim()
				if (!this.options.pedantic && /^</.test(n)) {
					if (!/>$/.test(n)) return
					let s = Uf(n.slice(0, -1), "\\")
					if ((n.length - s.length) % 2 === 0) return
				} else {
					let s = cW(t[2], "()")
					if (s > -1) {
						let l = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s
						;(t[2] = t[2].substring(0, s)), (t[0] = t[0].substring(0, l).trim()), (t[3] = "")
					}
				}
				let r = t[2],
					i = ""
				if (this.options.pedantic) {
					let s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r)
					s && ((r = s[1]), (i = s[3]))
				} else i = t[3] ? t[3].slice(1, -1) : ""
				return (
					(r = r.trim()),
					/^</.test(r) && (this.options.pedantic && !/>$/.test(n) ? (r = r.slice(1)) : (r = r.slice(1, -1))),
					SL(
						t,
						{
							href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
							title: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
						},
						t[0],
						this.lexer,
					)
				)
			}
		}
		reflink(e, t) {
			let n
			if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
				let r = (n[2] || n[1]).replace(/\s+/g, " "),
					i = t[r.toLowerCase()]
				if (!i) {
					let s = n[0].charAt(0)
					return { type: "text", raw: s, text: s }
				}
				return SL(n, i, n[0], this.lexer)
			}
		}
		emStrong(e, t, n = "") {
			let r = this.rules.inline.emStrongLDelim.exec(e)
			if (!r || (r[3] && n.match(/[\p{L}\p{N}]/u))) return
			if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
				let s = [...r[0]].length - 1,
					a,
					l,
					d = s,
					c = 0,
					u = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd
				for (u.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = u.exec(t)) != null; ) {
					if (((a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6]), !a)) continue
					if (((l = [...a].length), r[3] || r[4])) {
						d += l
						continue
					} else if ((r[5] || r[6]) && s % 3 && !((s + l) % 3)) {
						c += l
						continue
					}
					if (((d -= l), d > 0)) continue
					l = Math.min(l, l + d + c)
					let m = [...r[0]][0].length,
						f = e.slice(0, s + r.index + m + l)
					if (Math.min(s, l) % 2) {
						let g = f.slice(1, -1)
						return { type: "em", raw: f, text: g, tokens: this.lexer.inlineTokens(g) }
					}
					let h = f.slice(2, -2)
					return { type: "strong", raw: f, text: h, tokens: this.lexer.inlineTokens(h) }
				}
			}
		}
		codespan(e) {
			let t = this.rules.inline.code.exec(e)
			if (t) {
				let n = t[2].replace(/\n/g, " "),
					r = /[^ ]/.test(n),
					i = /^ /.test(n) && / $/.test(n)
				return (
					r && i && (n = n.substring(1, n.length - 1)),
					(n = jr(n, !0)),
					{ type: "codespan", raw: t[0], text: n }
				)
			}
		}
		br(e) {
			let t = this.rules.inline.br.exec(e)
			if (t) return { type: "br", raw: t[0] }
		}
		del(e) {
			let t = this.rules.inline.del.exec(e)
			if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) }
		}
		autolink(e) {
			let t = this.rules.inline.autolink.exec(e)
			if (t) {
				let n, r
				return (
					t[2] === "@" ? ((n = jr(t[1])), (r = "mailto:" + n)) : ((n = jr(t[1])), (r = n)),
					{ type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] }
				)
			}
		}
		url(e) {
			let t
			if ((t = this.rules.inline.url.exec(e))) {
				let n, r
				if (t[2] === "@") (n = jr(t[0])), (r = "mailto:" + n)
				else {
					let i
					do (i = t[0]), (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "")
					while (i !== t[0])
					;(n = jr(t[0])), t[1] === "www." ? (r = "http://" + t[0]) : (r = t[0])
				}
				return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] }
			}
		}
		inlineText(e) {
			let t = this.rules.inline.text.exec(e)
			if (t) {
				let n
				return this.lexer.state.inRawBlock ? (n = t[0]) : (n = jr(t[0])), { type: "text", raw: t[0], text: n }
			}
		}
	},
	pW = /^(?: *(?:\n|$))+/,
	mW = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
	fW = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
	Bf = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
	gW = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
	_L = /(?:[*+-]|\d{1,9}[.)])/,
	DL = At(
		/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
	)
		.replace(/bull/g, _L)
		.replace(/blockCode/g, / {4}/)
		.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
		.replace(/blockquote/g, / {0,3}>/)
		.replace(/heading/g, / {0,3}#{1,6}/)
		.replace(/html/g, / {0,3}<[^\n>]+>\n/)
		.getRegex(),
	CP = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
	hW = /^[^\n]+/,
	SP = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
	vW = At(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
		.replace("label", SP)
		.replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
		.getRegex(),
	bW = At(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
		.replace(/bull/g, _L)
		.getRegex(),
	Eb =
		"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
	TP = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
	yW = At(
		"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
		"i",
	)
		.replace("comment", TP)
		.replace("tag", Eb)
		.replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
		.getRegex(),
	kL = At(CP)
		.replace("hr", Bf)
		.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
		.replace("|lheading", "")
		.replace("|table", "")
		.replace("blockquote", " {0,3}>")
		.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
		.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
		.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
		.replace("tag", Eb)
		.getRegex(),
	IW = At(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
		.replace("paragraph", kL)
		.getRegex(),
	EP = {
		blockquote: IW,
		code: mW,
		def: vW,
		fences: fW,
		heading: gW,
		hr: Bf,
		html: yW,
		lheading: DL,
		list: bW,
		newline: pW,
		paragraph: kL,
		table: Wf,
		text: hW,
	},
	TL = At(
		"^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
	)
		.replace("hr", Bf)
		.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
		.replace("blockquote", " {0,3}>")
		.replace("code", " {4}[^\\n]")
		.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
		.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
		.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
		.replace("tag", Eb)
		.getRegex(),
	xW = {
		...EP,
		table: TL,
		paragraph: At(CP)
			.replace("hr", Bf)
			.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
			.replace("|lheading", "")
			.replace("table", TL)
			.replace("blockquote", " {0,3}>")
			.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
			.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
			.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
			.replace("tag", Eb)
			.getRegex(),
	},
	CW = {
		...EP,
		html: At(
			`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
		)
			.replace("comment", TP)
			.replace(
				/tag/g,
				"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
			)
			.getRegex(),
		def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
		heading: /^(#{1,6})(.*)(?:\n+|$)/,
		fences: Wf,
		lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
		paragraph: At(CP)
			.replace("hr", Bf)
			.replace(
				"heading",
				` *#{1,6} *[^
]`,
			)
			.replace("lheading", DL)
			.replace("|table", "")
			.replace("blockquote", " {0,3}>")
			.replace("|fences", "")
			.replace("|list", "")
			.replace("|html", "")
			.replace("|tag", "")
			.getRegex(),
	},
	RL = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
	SW = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
	AL = /^( {2,}|\\)\n(?!\s*$)/,
	TW = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
	$f = "\\p{P}\\p{S}",
	EW = At(/^((?![*_])[\spunctuation])/, "u")
		.replace(/punctuation/g, $f)
		.getRegex(),
	wW = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
	PW = At(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u")
		.replace(/punct/g, $f)
		.getRegex(),
	_W = At(
		"^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])",
		"gu",
	)
		.replace(/punct/g, $f)
		.getRegex(),
	DW = At(
		"^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
		"gu",
	)
		.replace(/punct/g, $f)
		.getRegex(),
	kW = At(/\\([punct])/, "gu")
		.replace(/punct/g, $f)
		.getRegex(),
	RW = At(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
		.replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
		.replace(
			"email",
			/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
		)
		.getRegex(),
	AW = At(TP).replace("(?:-->|$)", "-->").getRegex(),
	OW = At(
		"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
	)
		.replace("comment", AW)
		.replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
		.getRegex(),
	Tb = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
	LW = At(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
		.replace("label", Tb)
		.replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
		.replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
		.getRegex(),
	OL = At(/^!?\[(label)\]\[(ref)\]/)
		.replace("label", Tb)
		.replace("ref", SP)
		.getRegex(),
	LL = At(/^!?\[(ref)\](?:\[\])?/)
		.replace("ref", SP)
		.getRegex(),
	MW = At("reflink|nolink(?!\\()", "g").replace("reflink", OL).replace("nolink", LL).getRegex(),
	wP = {
		_backpedal: Wf,
		anyPunctuation: kW,
		autolink: RW,
		blockSkip: wW,
		br: AL,
		code: SW,
		del: Wf,
		emStrongLDelim: PW,
		emStrongRDelimAst: _W,
		emStrongRDelimUnd: DW,
		escape: RL,
		link: LW,
		nolink: LL,
		punctuation: EW,
		reflink: OL,
		reflinkSearch: MW,
		tag: OW,
		text: TW,
		url: Wf,
	},
	FW = {
		...wP,
		link: At(/^!?\[(label)\]\((.*?)\)/)
			.replace("label", Tb)
			.getRegex(),
		reflink: At(/^!?\[(label)\]\s*\[([^\]]*)\]/)
			.replace("label", Tb)
			.getRegex(),
	},
	yP = {
		...wP,
		escape: At(RL).replace("])", "~|])").getRegex(),
		url: At(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i")
			.replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
			.getRegex(),
		_backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
		del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
		text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
	},
	NW = {
		...yP,
		br: At(AL).replace("{2,}", "*").getRegex(),
		text: At(yP.text)
			.replace("\\b_", "\\b_| {2,}\\n")
			.replace(/\{2,\}/g, "*")
			.getRegex(),
	},
	Sb = { normal: EP, gfm: xW, pedantic: CW },
	Hf = { normal: wP, gfm: yP, breaks: NW, pedantic: FW },
	ls = class o {
		tokens
		options
		state
		tokenizer
		inlineQueue
		constructor(e) {
			;(this.tokens = []),
				(this.tokens.links = Object.create(null)),
				(this.options = e || Xl),
				(this.options.tokenizer = this.options.tokenizer || new zc()),
				(this.tokenizer = this.options.tokenizer),
				(this.tokenizer.options = this.options),
				(this.tokenizer.lexer = this),
				(this.inlineQueue = []),
				(this.state = { inLink: !1, inRawBlock: !1, top: !0 })
			let t = { block: Sb.normal, inline: Hf.normal }
			this.options.pedantic
				? ((t.block = Sb.pedantic), (t.inline = Hf.pedantic))
				: this.options.gfm &&
					((t.block = Sb.gfm), this.options.breaks ? (t.inline = Hf.breaks) : (t.inline = Hf.gfm)),
				(this.tokenizer.rules = t)
		}
		static get rules() {
			return { block: Sb, inline: Hf }
		}
		static lex(e, t) {
			return new o(t).lex(e)
		}
		static lexInline(e, t) {
			return new o(t).inlineTokens(e)
		}
		lex(e) {
			;(e = e.replace(
				/\r\n|\r/g,
				`
`,
			)),
				this.blockTokens(e, this.tokens)
			for (let t = 0; t < this.inlineQueue.length; t++) {
				let n = this.inlineQueue[t]
				this.inlineTokens(n.src, n.tokens)
			}
			return (this.inlineQueue = []), this.tokens
		}
		blockTokens(e, t = [], n = !1) {
			this.options.pedantic
				? (e = e.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
				: (e = e.replace(/^( *)(\t+)/gm, (a, l, d) => l + "    ".repeat(d.length)))
			let r, i, s
			for (; e; )
				if (
					!(
						this.options.extensions &&
						this.options.extensions.block &&
						this.options.extensions.block.some((a) =>
							(r = a.call({ lexer: this }, e, t)) ? ((e = e.substring(r.raw.length)), t.push(r), !0) : !1,
						)
					)
				) {
					if ((r = this.tokenizer.space(e))) {
						;(e = e.substring(r.raw.length)),
							r.raw.length === 1 && t.length > 0
								? (t[t.length - 1].raw += `
`)
								: t.push(r)
						continue
					}
					if ((r = this.tokenizer.code(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && (i.type === "paragraph" || i.type === "text")
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r)
						continue
					}
					if ((r = this.tokenizer.fences(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.heading(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.hr(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.blockquote(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.list(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.html(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.def(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && (i.type === "paragraph" || i.type === "text")
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.raw),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: this.tokens.links[r.tag] ||
									(this.tokens.links[r.tag] = { href: r.href, title: r.title })
						continue
					}
					if ((r = this.tokenizer.table(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.lheading(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if (((s = e), this.options.extensions && this.options.extensions.startBlock)) {
						let a = 1 / 0,
							l = e.slice(1),
							d
						this.options.extensions.startBlock.forEach((c) => {
							;(d = c.call({ lexer: this }, l)), typeof d == "number" && d >= 0 && (a = Math.min(a, d))
						}),
							a < 1 / 0 && a >= 0 && (s = e.substring(0, a + 1))
					}
					if (this.state.top && (r = this.tokenizer.paragraph(s))) {
						;(i = t[t.length - 1]),
							n && i?.type === "paragraph"
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r),
							(n = s.length !== e.length),
							(e = e.substring(r.raw.length))
						continue
					}
					if ((r = this.tokenizer.text(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && i.type === "text"
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r)
						continue
					}
					if (e) {
						let a = "Infinite loop on byte: " + e.charCodeAt(0)
						if (this.options.silent) {
							console.error(a)
							break
						} else throw new Error(a)
					}
				}
			return (this.state.top = !0), t
		}
		inline(e, t = []) {
			return this.inlineQueue.push({ src: e, tokens: t }), t
		}
		inlineTokens(e, t = []) {
			let n,
				r,
				i,
				s = e,
				a,
				l,
				d
			if (this.tokens.links) {
				let c = Object.keys(this.tokens.links)
				if (c.length > 0)
					for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null; )
						c.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) &&
							(s =
								s.slice(0, a.index) +
								"[" +
								"a".repeat(a[0].length - 2) +
								"]" +
								s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
			}
			for (; (a = this.tokenizer.rules.inline.blockSkip.exec(s)) != null; )
				s =
					s.slice(0, a.index) +
					"[" +
					"a".repeat(a[0].length - 2) +
					"]" +
					s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
			for (; (a = this.tokenizer.rules.inline.anyPunctuation.exec(s)) != null; )
				s = s.slice(0, a.index) + "++" + s.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex)
			for (; e; )
				if (
					(l || (d = ""),
					(l = !1),
					!(
						this.options.extensions &&
						this.options.extensions.inline &&
						this.options.extensions.inline.some((c) =>
							(n = c.call({ lexer: this }, e, t)) ? ((e = e.substring(n.raw.length)), t.push(n), !0) : !1,
						)
					))
				) {
					if ((n = this.tokenizer.escape(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.tag(e))) {
						;(e = e.substring(n.raw.length)),
							(r = t[t.length - 1]),
							r && n.type === "text" && r.type === "text"
								? ((r.raw += n.raw), (r.text += n.text))
								: t.push(n)
						continue
					}
					if ((n = this.tokenizer.link(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.reflink(e, this.tokens.links))) {
						;(e = e.substring(n.raw.length)),
							(r = t[t.length - 1]),
							r && n.type === "text" && r.type === "text"
								? ((r.raw += n.raw), (r.text += n.text))
								: t.push(n)
						continue
					}
					if ((n = this.tokenizer.emStrong(e, s, d))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.codespan(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.br(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.del(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.autolink(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if (!this.state.inLink && (n = this.tokenizer.url(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if (((i = e), this.options.extensions && this.options.extensions.startInline)) {
						let c = 1 / 0,
							u = e.slice(1),
							m
						this.options.extensions.startInline.forEach((f) => {
							;(m = f.call({ lexer: this }, u)), typeof m == "number" && m >= 0 && (c = Math.min(c, m))
						}),
							c < 1 / 0 && c >= 0 && (i = e.substring(0, c + 1))
					}
					if ((n = this.tokenizer.inlineText(i))) {
						;(e = e.substring(n.raw.length)),
							n.raw.slice(-1) !== "_" && (d = n.raw.slice(-1)),
							(l = !0),
							(r = t[t.length - 1]),
							r && r.type === "text" ? ((r.raw += n.raw), (r.text += n.text)) : t.push(n)
						continue
					}
					if (e) {
						let c = "Infinite loop on byte: " + e.charCodeAt(0)
						if (this.options.silent) {
							console.error(c)
							break
						} else throw new Error(c)
					}
				}
			return t
		}
	},
	qc = class {
		options
		parser
		constructor(e) {
			this.options = e || Xl
		}
		space(e) {
			return ""
		}
		code({ text: e, lang: t, escaped: n }) {
			let r = (t || "").match(/^\S*/)?.[0],
				i =
					e.replace(/\n$/, "") +
					`
`
			return r
				? '<pre><code class="language-' +
						jr(r) +
						'">' +
						(n ? i : jr(i, !0)) +
						`</code></pre>
`
				: "<pre><code>" +
						(n ? i : jr(i, !0)) +
						`</code></pre>
`
		}
		blockquote({ tokens: e }) {
			return `<blockquote>
${this.parser.parse(e)}</blockquote>
`
		}
		html({ text: e }) {
			return e
		}
		heading({ tokens: e, depth: t }) {
			return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`
		}
		hr(e) {
			return `<hr>
`
		}
		list(e) {
			let t = e.ordered,
				n = e.start,
				r = ""
			for (let a = 0; a < e.items.length; a++) {
				let l = e.items[a]
				r += this.listitem(l)
			}
			let i = t ? "ol" : "ul",
				s = t && n !== 1 ? ' start="' + n + '"' : ""
			return (
				"<" +
				i +
				s +
				`>
` +
				r +
				"</" +
				i +
				`>
`
			)
		}
		listitem(e) {
			let t = ""
			if (e.task) {
				let n = this.checkbox({ checked: !!e.checked })
				e.loose
					? e.tokens.length > 0 && e.tokens[0].type === "paragraph"
						? ((e.tokens[0].text = n + " " + e.tokens[0].text),
							e.tokens[0].tokens &&
								e.tokens[0].tokens.length > 0 &&
								e.tokens[0].tokens[0].type === "text" &&
								(e.tokens[0].tokens[0].text = n + " " + e.tokens[0].tokens[0].text))
						: e.tokens.unshift({ type: "text", raw: n + " ", text: n + " " })
					: (t += n + " ")
			}
			return (
				(t += this.parser.parse(e.tokens, !!e.loose)),
				`<li>${t}</li>
`
			)
		}
		checkbox({ checked: e }) {
			return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
		}
		paragraph({ tokens: e }) {
			return `<p>${this.parser.parseInline(e)}</p>
`
		}
		table(e) {
			let t = "",
				n = ""
			for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i])
			t += this.tablerow({ text: n })
			let r = ""
			for (let i = 0; i < e.rows.length; i++) {
				let s = e.rows[i]
				n = ""
				for (let a = 0; a < s.length; a++) n += this.tablecell(s[a])
				r += this.tablerow({ text: n })
			}
			return (
				r && (r = `<tbody>${r}</tbody>`),
				`<table>
<thead>
` +
					t +
					`</thead>
` +
					r +
					`</table>
`
			)
		}
		tablerow({ text: e }) {
			return `<tr>
${e}</tr>
`
		}
		tablecell(e) {
			let t = this.parser.parseInline(e.tokens),
				n = e.header ? "th" : "td"
			return (
				(e.align ? `<${n} align="${e.align}">` : `<${n}>`) +
				t +
				`</${n}>
`
			)
		}
		strong({ tokens: e }) {
			return `<strong>${this.parser.parseInline(e)}</strong>`
		}
		em({ tokens: e }) {
			return `<em>${this.parser.parseInline(e)}</em>`
		}
		codespan({ text: e }) {
			return `<code>${e}</code>`
		}
		br(e) {
			return "<br>"
		}
		del({ tokens: e }) {
			return `<del>${this.parser.parseInline(e)}</del>`
		}
		link({ href: e, title: t, tokens: n }) {
			let r = this.parser.parseInline(n),
				i = xL(e)
			if (i === null) return r
			e = i
			let s = '<a href="' + e + '"'
			return t && (s += ' title="' + t + '"'), (s += ">" + r + "</a>"), s
		}
		image({ href: e, title: t, text: n }) {
			let r = xL(e)
			if (r === null) return n
			e = r
			let i = `<img src="${e}" alt="${n}"`
			return t && (i += ` title="${t}"`), (i += ">"), i
		}
		text(e) {
			return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : e.text
		}
	},
	Vf = class {
		strong({ text: e }) {
			return e
		}
		em({ text: e }) {
			return e
		}
		codespan({ text: e }) {
			return e
		}
		del({ text: e }) {
			return e
		}
		html({ text: e }) {
			return e
		}
		text({ text: e }) {
			return e
		}
		link({ text: e }) {
			return "" + e
		}
		image({ text: e }) {
			return "" + e
		}
		br() {
			return ""
		}
	},
	ds = class o {
		options
		renderer
		textRenderer
		constructor(e) {
			;(this.options = e || Xl),
				(this.options.renderer = this.options.renderer || new qc()),
				(this.renderer = this.options.renderer),
				(this.renderer.options = this.options),
				(this.renderer.parser = this),
				(this.textRenderer = new Vf())
		}
		static parse(e, t) {
			return new o(t).parse(e)
		}
		static parseInline(e, t) {
			return new o(t).parseInline(e)
		}
		parse(e, t = !0) {
			let n = ""
			for (let r = 0; r < e.length; r++) {
				let i = e[r]
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					let a = i,
						l = this.options.extensions.renderers[a.type].call({ parser: this }, a)
					if (
						l !== !1 ||
						![
							"space",
							"hr",
							"heading",
							"code",
							"table",
							"blockquote",
							"list",
							"html",
							"paragraph",
							"text",
						].includes(a.type)
					) {
						n += l || ""
						continue
					}
				}
				let s = i
				switch (s.type) {
					case "space": {
						n += this.renderer.space(s)
						continue
					}
					case "hr": {
						n += this.renderer.hr(s)
						continue
					}
					case "heading": {
						n += this.renderer.heading(s)
						continue
					}
					case "code": {
						n += this.renderer.code(s)
						continue
					}
					case "table": {
						n += this.renderer.table(s)
						continue
					}
					case "blockquote": {
						n += this.renderer.blockquote(s)
						continue
					}
					case "list": {
						n += this.renderer.list(s)
						continue
					}
					case "html": {
						n += this.renderer.html(s)
						continue
					}
					case "paragraph": {
						n += this.renderer.paragraph(s)
						continue
					}
					case "text": {
						let a = s,
							l = this.renderer.text(a)
						for (; r + 1 < e.length && e[r + 1].type === "text"; )
							(a = e[++r]),
								(l +=
									`
` + this.renderer.text(a))
						t
							? (n += this.renderer.paragraph({
									type: "paragraph",
									raw: l,
									text: l,
									tokens: [{ type: "text", raw: l, text: l }],
								}))
							: (n += l)
						continue
					}
					default: {
						let a = 'Token with "' + s.type + '" type was not found.'
						if (this.options.silent) return console.error(a), ""
						throw new Error(a)
					}
				}
			}
			return n
		}
		parseInline(e, t) {
			t = t || this.renderer
			let n = ""
			for (let r = 0; r < e.length; r++) {
				let i = e[r]
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					let a = this.options.extensions.renderers[i.type].call({ parser: this }, i)
					if (
						a !== !1 ||
						!["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(
							i.type,
						)
					) {
						n += a || ""
						continue
					}
				}
				let s = i
				switch (s.type) {
					case "escape": {
						n += t.text(s)
						break
					}
					case "html": {
						n += t.html(s)
						break
					}
					case "link": {
						n += t.link(s)
						break
					}
					case "image": {
						n += t.image(s)
						break
					}
					case "strong": {
						n += t.strong(s)
						break
					}
					case "em": {
						n += t.em(s)
						break
					}
					case "codespan": {
						n += t.codespan(s)
						break
					}
					case "br": {
						n += t.br(s)
						break
					}
					case "del": {
						n += t.del(s)
						break
					}
					case "text": {
						n += t.text(s)
						break
					}
					default: {
						let a = 'Token with "' + s.type + '" type was not found.'
						if (this.options.silent) return console.error(a), ""
						throw new Error(a)
					}
				}
			}
			return n
		}
	},
	$c = class {
		options
		constructor(e) {
			this.options = e || Xl
		}
		static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens"])
		preprocess(e) {
			return e
		}
		postprocess(e) {
			return e
		}
		processAllTokens(e) {
			return e
		}
	},
	IP = class {
		defaults = xP()
		options = this.setOptions
		parse = this.parseMarkdown(ls.lex, ds.parse)
		parseInline = this.parseMarkdown(ls.lexInline, ds.parseInline)
		Parser = ds
		Renderer = qc
		TextRenderer = Vf
		Lexer = ls
		Tokenizer = zc
		Hooks = $c
		constructor(...e) {
			this.use(...e)
		}
		walkTokens(e, t) {
			let n = []
			for (let r of e)
				switch (((n = n.concat(t.call(this, r))), r.type)) {
					case "table": {
						let i = r
						for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t))
						for (let s of i.rows) for (let a of s) n = n.concat(this.walkTokens(a.tokens, t))
						break
					}
					case "list": {
						let i = r
						n = n.concat(this.walkTokens(i.items, t))
						break
					}
					default: {
						let i = r
						this.defaults.extensions?.childTokens?.[i.type]
							? this.defaults.extensions.childTokens[i.type].forEach((s) => {
									let a = i[s].flat(1 / 0)
									n = n.concat(this.walkTokens(a, t))
								})
							: i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)))
					}
				}
			return n
		}
		use(...e) {
			let t = this.defaults.extensions || { renderers: {}, childTokens: {} }
			return (
				e.forEach((n) => {
					let r = { ...n }
					if (
						((r.async = this.defaults.async || r.async || !1),
						n.extensions &&
							(n.extensions.forEach((i) => {
								if (!i.name) throw new Error("extension name required")
								if ("renderer" in i) {
									let s = t.renderers[i.name]
									s
										? (t.renderers[i.name] = function (...a) {
												let l = i.renderer.apply(this, a)
												return l === !1 && (l = s.apply(this, a)), l
											})
										: (t.renderers[i.name] = i.renderer)
								}
								if ("tokenizer" in i) {
									if (!i.level || (i.level !== "block" && i.level !== "inline"))
										throw new Error("extension level must be 'block' or 'inline'")
									let s = t[i.level]
									s ? s.unshift(i.tokenizer) : (t[i.level] = [i.tokenizer]),
										i.start &&
											(i.level === "block"
												? t.startBlock
													? t.startBlock.push(i.start)
													: (t.startBlock = [i.start])
												: i.level === "inline" &&
													(t.startInline
														? t.startInline.push(i.start)
														: (t.startInline = [i.start])))
								}
								"childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens)
							}),
							(r.extensions = t)),
						n.renderer)
					) {
						let i = this.defaults.renderer || new qc(this.defaults)
						for (let s in n.renderer) {
							if (!(s in i)) throw new Error(`renderer '${s}' does not exist`)
							if (["options", "parser"].includes(s)) continue
							let a = s,
								l = n.renderer[a],
								d = i[a]
							i[a] = (...c) => {
								let u = l.apply(i, c)
								return u === !1 && (u = d.apply(i, c)), u || ""
							}
						}
						r.renderer = i
					}
					if (n.tokenizer) {
						let i = this.defaults.tokenizer || new zc(this.defaults)
						for (let s in n.tokenizer) {
							if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`)
							if (["options", "rules", "lexer"].includes(s)) continue
							let a = s,
								l = n.tokenizer[a],
								d = i[a]
							i[a] = (...c) => {
								let u = l.apply(i, c)
								return u === !1 && (u = d.apply(i, c)), u
							}
						}
						r.tokenizer = i
					}
					if (n.hooks) {
						let i = this.defaults.hooks || new $c()
						for (let s in n.hooks) {
							if (!(s in i)) throw new Error(`hook '${s}' does not exist`)
							if (s === "options") continue
							let a = s,
								l = n.hooks[a],
								d = i[a]
							$c.passThroughHooks.has(s)
								? (i[a] = (c) => {
										if (this.defaults.async)
											return Promise.resolve(l.call(i, c)).then((m) => d.call(i, m))
										let u = l.call(i, c)
										return d.call(i, u)
									})
								: (i[a] = (...c) => {
										let u = l.apply(i, c)
										return u === !1 && (u = d.apply(i, c)), u
									})
						}
						r.hooks = i
					}
					if (n.walkTokens) {
						let i = this.defaults.walkTokens,
							s = n.walkTokens
						r.walkTokens = function (a) {
							let l = []
							return l.push(s.call(this, a)), i && (l = l.concat(i.call(this, a))), l
						}
					}
					this.defaults = { ...this.defaults, ...r }
				}),
				this
			)
		}
		setOptions(e) {
			return (this.defaults = { ...this.defaults, ...e }), this
		}
		lexer(e, t) {
			return ls.lex(e, t ?? this.defaults)
		}
		parser(e, t) {
			return ds.parse(e, t ?? this.defaults)
		}
		parseMarkdown(e, t) {
			return (r, i) => {
				let s = { ...i },
					a = { ...this.defaults, ...s },
					l = this.onError(!!a.silent, !!a.async)
				if (this.defaults.async === !0 && s.async === !1)
					return l(
						new Error(
							"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
						),
					)
				if (typeof r > "u" || r === null) return l(new Error("marked(): input parameter is undefined or null"))
				if (typeof r != "string")
					return l(
						new Error(
							"marked(): input parameter is of type " +
								Object.prototype.toString.call(r) +
								", string expected",
						),
					)
				if ((a.hooks && (a.hooks.options = a), a.async))
					return Promise.resolve(a.hooks ? a.hooks.preprocess(r) : r)
						.then((d) => e(d, a))
						.then((d) => (a.hooks ? a.hooks.processAllTokens(d) : d))
						.then((d) => (a.walkTokens ? Promise.all(this.walkTokens(d, a.walkTokens)).then(() => d) : d))
						.then((d) => t(d, a))
						.then((d) => (a.hooks ? a.hooks.postprocess(d) : d))
						.catch(l)
				try {
					a.hooks && (r = a.hooks.preprocess(r))
					let d = e(r, a)
					a.hooks && (d = a.hooks.processAllTokens(d)), a.walkTokens && this.walkTokens(d, a.walkTokens)
					let c = t(d, a)
					return a.hooks && (c = a.hooks.postprocess(c)), c
				} catch (d) {
					return l(d)
				}
			}
		}
		onError(e, t) {
			return (n) => {
				if (
					((n.message += `
Please report this to https://github.com/markedjs/marked.`),
					e)
				) {
					let r = "<p>An error occurred:</p><pre>" + jr(n.message + "", !0) + "</pre>"
					return t ? Promise.resolve(r) : r
				}
				if (t) return Promise.reject(n)
				throw n
			}
		}
	},
	Jl = new IP()
function Tt(o, e) {
	return Jl.parse(o, e)
}
Tt.options = Tt.setOptions = function (o) {
	return Jl.setOptions(o), (Tt.defaults = Jl.defaults), EL(Tt.defaults), Tt
}
Tt.getDefaults = xP
Tt.defaults = Xl
Tt.use = function (...o) {
	return Jl.use(...o), (Tt.defaults = Jl.defaults), EL(Tt.defaults), Tt
}
Tt.walkTokens = function (o, e) {
	return Jl.walkTokens(o, e)
}
Tt.parseInline = Jl.parseInline
Tt.Parser = ds
Tt.parser = ds.parse
Tt.Renderer = qc
Tt.TextRenderer = Vf
Tt.Lexer = ls
Tt.lexer = ls.lex
Tt.Tokenizer = zc
Tt.Hooks = $c
Tt.parse = Tt
var jQ = Tt.options,
	GQ = Tt.setOptions,
	QQ = Tt.use,
	JQ = Tt.walkTokens,
	XQ = Tt.parseInline
var YQ = ds.parse,
	ZQ = ls.lex
var po = Object.freeze({
	text: "text/plain",
	binary: "application/octet-stream",
	unknown: "application/unknown",
	markdown: "text/markdown",
	latex: "text/latex",
	uriList: "text/uri-list",
	html: "text/html",
})
var HW = /^(.+)\/(.+?)(;.+)?$/
function PP(o, e) {
	let t = HW.exec(o)
	return t ? `${t[1].toLowerCase()}/${t[2].toLowerCase()}${t[3] ?? ""}` : e ? void 0 : o
}
var lr = Symbol("unset"),
	wb = class {
		constructor() {
			this.root = new zf()
			this._size = 0
		}
		get size() {
			return this._size
		}
		get nodes() {
			return this.root.children?.values() || kt.empty()
		}
		get entries() {
			return this.root.children?.entries() || kt.empty()
		}
		insert(e, t, n) {
			this.opNode(e, (r) => (r._value = t), n)
		}
		mutate(e, t) {
			this.opNode(e, (n) => (n._value = t(n._value === lr ? void 0 : n._value)))
		}
		mutatePath(e, t) {
			this.opNode(
				e,
				() => {},
				(n) => t(n),
			)
		}
		delete(e) {
			let t = this.getPathToKey(e)
			if (!t) return
			let n = t.length - 1,
				r = t[n].node._value
			if (r !== lr) {
				for (this._size--, t[n].node._value = lr; n > 0; n--) {
					let { node: i, part: s } = t[n]
					if (i.children?.size || i._value !== lr) break
					t[n - 1].node.children.delete(s)
				}
				return r
			}
		}
		*deleteRecursive(e) {
			let t = this.getPathToKey(e)
			if (!t) return
			let n = t[t.length - 1].node
			for (let r = t.length - 1; r > 0; r--) {
				let i = t[r - 1]
				if ((i.node.children.delete(t[r].part), i.node.children.size > 0 || i.node._value !== lr)) break
			}
			for (let r of ML(n)) r._value !== lr && (this._size--, yield r._value)
			n === this.root && ((this.root._value = lr), (this.root.children = void 0))
		}
		find(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return
				t = r
			}
			return t._value === lr ? void 0 : t._value
		}
		hasKeyOrParent(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				if (r._value !== lr) return !0
				t = r
			}
			return !1
		}
		hasKeyOrChildren(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				t = r
			}
			return !0
		}
		hasKey(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				t = r
			}
			return t._value !== lr
		}
		getPathToKey(e) {
			let t = [{ part: "", node: this.root }],
				n = 0
			for (let r of e) {
				let i = t[n].node.children?.get(r)
				if (!i) return
				t.push({ part: r, node: i }), n++
			}
			return t
		}
		opNode(e, t, n) {
			let r = this.root
			for (let a of e) {
				if (r.children)
					if (r.children.has(a)) r = r.children.get(a)
					else {
						let l = new zf()
						r.children.set(a, l), (r = l)
					}
				else {
					let l = new zf()
					;(r.children = new Map([[a, l]])), (r = l)
				}
				n?.(r)
			}
			let i = r._value === lr ? 0 : 1
			t(r)
			let s = r._value === lr ? 0 : 1
			this._size += s - i
		}
		*values() {
			for (let { _value: e } of ML(this.root)) e !== lr && (yield e)
		}
	}
function* ML(o) {
	let e = [o]
	for (; e.length > 0; ) {
		let t = e.pop()
		if ((yield t, t.children)) for (let n of t.children.values()) e.push(n)
	}
}
var zf = class {
	constructor() {
		this._value = lr
	}
	get value() {
		return this._value === lr ? void 0 : this._value
	}
	set value(e) {
		this._value = e === void 0 ? lr : e
	}
}
var cn = class o {
	constructor(e, t) {
		;(this.lineNumber = e), (this.column = t)
	}
	with(e = this.lineNumber, t = this.column) {
		return e === this.lineNumber && t === this.column ? this : new o(e, t)
	}
	delta(e = 0, t = 0) {
		return this.with(Math.max(1, this.lineNumber + e), Math.max(1, this.column + t))
	}
	equals(e) {
		return o.equals(this, e)
	}
	static equals(e, t) {
		return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column
	}
	isBefore(e) {
		return o.isBefore(this, e)
	}
	static isBefore(e, t) {
		return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column
	}
	isBeforeOrEqual(e) {
		return o.isBeforeOrEqual(this, e)
	}
	static isBeforeOrEqual(e, t) {
		return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column
	}
	static compare(e, t) {
		let n = e.lineNumber | 0,
			r = t.lineNumber | 0
		if (n === r) {
			let i = e.column | 0,
				s = t.column | 0
			return i - s
		}
		return n - r
	}
	clone() {
		return new o(this.lineNumber, this.column)
	}
	toString() {
		return "(" + this.lineNumber + "," + this.column + ")"
	}
	static lift(e) {
		return new o(e.lineNumber, e.column)
	}
	static isIPosition(e) {
		return e && typeof e.lineNumber == "number" && typeof e.column == "number"
	}
	toJSON() {
		return { lineNumber: this.lineNumber, column: this.column }
	}
}
var Re = class o {
	constructor(e, t, n, r) {
		e > n || (e === n && t > r)
			? ((this.startLineNumber = n), (this.startColumn = r), (this.endLineNumber = e), (this.endColumn = t))
			: ((this.startLineNumber = e), (this.startColumn = t), (this.endLineNumber = n), (this.endColumn = r))
	}
	isEmpty() {
		return o.isEmpty(this)
	}
	static isEmpty(e) {
		return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn
	}
	containsPosition(e) {
		return o.containsPosition(this, e)
	}
	static containsPosition(e, t) {
		return !(
			t.lineNumber < e.startLineNumber ||
			t.lineNumber > e.endLineNumber ||
			(t.lineNumber === e.startLineNumber && t.column < e.startColumn) ||
			(t.lineNumber === e.endLineNumber && t.column > e.endColumn)
		)
	}
	static strictContainsPosition(e, t) {
		return !(
			t.lineNumber < e.startLineNumber ||
			t.lineNumber > e.endLineNumber ||
			(t.lineNumber === e.startLineNumber && t.column <= e.startColumn) ||
			(t.lineNumber === e.endLineNumber && t.column >= e.endColumn)
		)
	}
	containsRange(e) {
		return o.containsRange(this, e)
	}
	static containsRange(e, t) {
		return !(
			t.startLineNumber < e.startLineNumber ||
			t.endLineNumber < e.startLineNumber ||
			t.startLineNumber > e.endLineNumber ||
			t.endLineNumber > e.endLineNumber ||
			(t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn) ||
			(t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn)
		)
	}
	strictContainsRange(e) {
		return o.strictContainsRange(this, e)
	}
	static strictContainsRange(e, t) {
		return !(
			t.startLineNumber < e.startLineNumber ||
			t.endLineNumber < e.startLineNumber ||
			t.startLineNumber > e.endLineNumber ||
			t.endLineNumber > e.endLineNumber ||
			(t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn) ||
			(t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn)
		)
	}
	plusRange(e) {
		return o.plusRange(this, e)
	}
	static plusRange(e, t) {
		let n, r, i, s
		return (
			t.startLineNumber < e.startLineNumber
				? ((n = t.startLineNumber), (r = t.startColumn))
				: t.startLineNumber === e.startLineNumber
					? ((n = t.startLineNumber), (r = Math.min(t.startColumn, e.startColumn)))
					: ((n = e.startLineNumber), (r = e.startColumn)),
			t.endLineNumber > e.endLineNumber
				? ((i = t.endLineNumber), (s = t.endColumn))
				: t.endLineNumber === e.endLineNumber
					? ((i = t.endLineNumber), (s = Math.max(t.endColumn, e.endColumn)))
					: ((i = e.endLineNumber), (s = e.endColumn)),
			new o(n, r, i, s)
		)
	}
	intersectRanges(e) {
		return o.intersectRanges(this, e)
	}
	static intersectRanges(e, t) {
		let n = e.startLineNumber,
			r = e.startColumn,
			i = e.endLineNumber,
			s = e.endColumn,
			a = t.startLineNumber,
			l = t.startColumn,
			d = t.endLineNumber,
			c = t.endColumn
		return (
			n < a ? ((n = a), (r = l)) : n === a && (r = Math.max(r, l)),
			i > d ? ((i = d), (s = c)) : i === d && (s = Math.min(s, c)),
			n > i || (n === i && r > s) ? null : new o(n, r, i, s)
		)
	}
	equalsRange(e) {
		return o.equalsRange(this, e)
	}
	static equalsRange(e, t) {
		return !e && !t
			? !0
			: !!e &&
					!!t &&
					e.startLineNumber === t.startLineNumber &&
					e.startColumn === t.startColumn &&
					e.endLineNumber === t.endLineNumber &&
					e.endColumn === t.endColumn
	}
	getEndPosition() {
		return o.getEndPosition(this)
	}
	static getEndPosition(e) {
		return new cn(e.endLineNumber, e.endColumn)
	}
	getStartPosition() {
		return o.getStartPosition(this)
	}
	static getStartPosition(e) {
		return new cn(e.startLineNumber, e.startColumn)
	}
	toString() {
		return (
			"[" +
			this.startLineNumber +
			"," +
			this.startColumn +
			" -> " +
			this.endLineNumber +
			"," +
			this.endColumn +
			"]"
		)
	}
	setEndPosition(e, t) {
		return new o(this.startLineNumber, this.startColumn, e, t)
	}
	setStartPosition(e, t) {
		return new o(e, t, this.endLineNumber, this.endColumn)
	}
	collapseToStart() {
		return o.collapseToStart(this)
	}
	static collapseToStart(e) {
		return new o(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn)
	}
	collapseToEnd() {
		return o.collapseToEnd(this)
	}
	static collapseToEnd(e) {
		return new o(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn)
	}
	delta(e) {
		return new o(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn)
	}
	isSingleLine() {
		return this.startLineNumber === this.endLineNumber
	}
	static fromPositions(e, t = e) {
		return new o(e.lineNumber, e.column, t.lineNumber, t.column)
	}
	static lift(e) {
		return e ? new o(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null
	}
	static isIRange(e) {
		return (
			e &&
			typeof e.startLineNumber == "number" &&
			typeof e.startColumn == "number" &&
			typeof e.endLineNumber == "number" &&
			typeof e.endColumn == "number"
		)
	}
	static areIntersectingOrTouching(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber ||
			(e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn) ||
			t.endLineNumber < e.startLineNumber ||
			(t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn)
		)
	}
	static areIntersecting(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber ||
			(e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn) ||
			t.endLineNumber < e.startLineNumber ||
			(t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn)
		)
	}
	static areOnlyIntersecting(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber - 1 ||
			(e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn - 1) ||
			t.endLineNumber < e.startLineNumber - 1 ||
			(t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn - 1)
		)
	}
	static compareRangesUsingStarts(e, t) {
		if (e && t) {
			let i = e.startLineNumber | 0,
				s = t.startLineNumber | 0
			if (i === s) {
				let a = e.startColumn | 0,
					l = t.startColumn | 0
				if (a === l) {
					let d = e.endLineNumber | 0,
						c = t.endLineNumber | 0
					if (d === c) {
						let u = e.endColumn | 0,
							m = t.endColumn | 0
						return u - m
					}
					return d - c
				}
				return a - l
			}
			return i - s
		}
		return (e ? 1 : 0) - (t ? 1 : 0)
	}
	static compareRangesUsingEnds(e, t) {
		return e.endLineNumber === t.endLineNumber
			? e.endColumn === t.endColumn
				? e.startLineNumber === t.startLineNumber
					? e.startColumn - t.startColumn
					: e.startLineNumber - t.startLineNumber
				: e.endColumn - t.endColumn
			: e.endLineNumber - t.endLineNumber
	}
	static spansMultipleLines(e) {
		return e.endLineNumber > e.startLineNumber
	}
	toJSON() {
		return this
	}
}
var Pb = class {
	static insert(e, t) {
		return { range: new Re(e.lineNumber, e.column, e.lineNumber, e.column), text: t, forceMoveMarkers: !0 }
	}
	static delete(e) {
		return { range: e, text: null }
	}
	static replace(e, t) {
		return { range: e, text: t }
	}
	static replaceMove(e, t) {
		return { range: e, text: t, forceMoveMarkers: !0 }
	}
}
var qf = class {
		constructor() {
			this._tokenizationSupports = new Map()
			this._factories = new Map()
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this._colorMap = null
		}
		handleChange(e) {
			this._onDidChange.fire({ changedLanguages: e, changedColorMap: !1 })
		}
		register(e, t) {
			return (
				this._tokenizationSupports.set(e, t),
				this.handleChange([e]),
				q(() => {
					this._tokenizationSupports.get(e) === t &&
						(this._tokenizationSupports.delete(e), this.handleChange([e]))
				})
			)
		}
		get(e) {
			return this._tokenizationSupports.get(e) || null
		}
		registerFactory(e, t) {
			this._factories.get(e)?.dispose()
			let n = new _P(this, e, t)
			return (
				this._factories.set(e, n),
				q(() => {
					let r = this._factories.get(e)
					!r || r !== n || (this._factories.delete(e), r.dispose())
				})
			)
		}
		async getOrCreate(e) {
			let t = this.get(e)
			if (t) return t
			let n = this._factories.get(e)
			return !n || n.isResolved ? null : (await n.resolve(), this.get(e))
		}
		isResolved(e) {
			if (this.get(e)) return !0
			let n = this._factories.get(e)
			return !!(!n || n.isResolved)
		}
		setColorMap(e) {
			;(this._colorMap = e),
				this._onDidChange.fire({
					changedLanguages: Array.from(this._tokenizationSupports.keys()),
					changedColorMap: !0,
				})
		}
		getColorMap() {
			return this._colorMap
		}
		getDefaultBackground() {
			return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null
		}
	},
	_P = class extends $ {
		constructor(t, n, r) {
			super()
			this._registry = t
			this._languageId = n
			this._factory = r
			this._isDisposed = !1
			this._resolvePromise = null
			this._isResolved = !1
		}
		get isResolved() {
			return this._isResolved
		}
		dispose() {
			;(this._isDisposed = !0), super.dispose()
		}
		async resolve() {
			return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise
		}
		async _create() {
			let t = await this._factory.tokenizationSupport
			;(this._isResolved = !0),
				t && !this._isDisposed && this._register(this._registry.register(this._languageId, t))
		}
	}
var VW
;((i) => {
	let o = new Map()
	o.set(0, ce.symbolMethod),
		o.set(1, ce.symbolFunction),
		o.set(2, ce.symbolConstructor),
		o.set(3, ce.symbolField),
		o.set(4, ce.symbolVariable),
		o.set(5, ce.symbolClass),
		o.set(6, ce.symbolStruct),
		o.set(7, ce.symbolInterface),
		o.set(8, ce.symbolModule),
		o.set(9, ce.symbolProperty),
		o.set(10, ce.symbolEvent),
		o.set(11, ce.symbolOperator),
		o.set(12, ce.symbolUnit),
		o.set(13, ce.symbolValue),
		o.set(15, ce.symbolEnum),
		o.set(14, ce.symbolConstant),
		o.set(15, ce.symbolEnum),
		o.set(16, ce.symbolEnumMember),
		o.set(17, ce.symbolKeyword),
		o.set(27, ce.symbolSnippet),
		o.set(18, ce.symbolText),
		o.set(19, ce.symbolColor),
		o.set(20, ce.symbolFile),
		o.set(21, ce.symbolReference),
		o.set(22, ce.symbolCustomColor),
		o.set(23, ce.symbolFolder),
		o.set(24, ce.symbolTypeParameter),
		o.set(25, ce.account),
		o.set(26, ce.issues)
	function e(s) {
		let a = o.get(s)
		return a || (console.info("No codicon found for CompletionItemKind " + s), (a = ce.symbolProperty)), a
	}
	i.toIcon = e
	function t(s) {
		switch (s) {
			case 0:
				return p("suggestWidget.kind.method", "Method")
			case 1:
				return p("suggestWidget.kind.function", "Function")
			case 2:
				return p("suggestWidget.kind.constructor", "Constructor")
			case 3:
				return p("suggestWidget.kind.field", "Field")
			case 4:
				return p("suggestWidget.kind.variable", "Variable")
			case 5:
				return p("suggestWidget.kind.class", "Class")
			case 6:
				return p("suggestWidget.kind.struct", "Struct")
			case 7:
				return p("suggestWidget.kind.interface", "Interface")
			case 8:
				return p("suggestWidget.kind.module", "Module")
			case 9:
				return p("suggestWidget.kind.property", "Property")
			case 10:
				return p("suggestWidget.kind.event", "Event")
			case 11:
				return p("suggestWidget.kind.operator", "Operator")
			case 12:
				return p("suggestWidget.kind.unit", "Unit")
			case 13:
				return p("suggestWidget.kind.value", "Value")
			case 14:
				return p("suggestWidget.kind.constant", "Constant")
			case 15:
				return p("suggestWidget.kind.enum", "Enum")
			case 16:
				return p("suggestWidget.kind.enumMember", "Enum Member")
			case 17:
				return p("suggestWidget.kind.keyword", "Keyword")
			case 18:
				return p("suggestWidget.kind.text", "Text")
			case 19:
				return p("suggestWidget.kind.color", "Color")
			case 20:
				return p("suggestWidget.kind.file", "File")
			case 21:
				return p("suggestWidget.kind.reference", "Reference")
			case 22:
				return p("suggestWidget.kind.customcolor", "Custom Color")
			case 23:
				return p("suggestWidget.kind.folder", "Folder")
			case 24:
				return p("suggestWidget.kind.typeParameter", "Type Parameter")
			case 25:
				return p("suggestWidget.kind.user", "User")
			case 26:
				return p("suggestWidget.kind.issue", "Issue")
			case 27:
				return p("suggestWidget.kind.snippet", "Snippet")
			default:
				return ""
		}
	}
	i.toLabel = t
	let n = new Map()
	n.set("method", 0),
		n.set("function", 1),
		n.set("constructor", 2),
		n.set("field", 3),
		n.set("variable", 4),
		n.set("class", 5),
		n.set("struct", 6),
		n.set("interface", 7),
		n.set("module", 8),
		n.set("property", 9),
		n.set("event", 10),
		n.set("operator", 11),
		n.set("unit", 12),
		n.set("value", 13),
		n.set("constant", 14),
		n.set("enum", 15),
		n.set("enum-member", 16),
		n.set("enumMember", 16),
		n.set("keyword", 17),
		n.set("snippet", 27),
		n.set("text", 18),
		n.set("color", 19),
		n.set("file", 20),
		n.set("reference", 21),
		n.set("customcolor", 22),
		n.set("folder", 23),
		n.set("type-parameter", 24),
		n.set("typeParameter", 24),
		n.set("account", 25),
		n.set("issue", 26)
	function r(s, a) {
		let l = n.get(s)
		return typeof l > "u" && !a && (l = 9), l
	}
	i.fromString = r
})((VW ||= {}))
function NL(o) {
	return (
		o &&
		y.isUri(o.uri) &&
		Re.isIRange(o.range) &&
		(Re.isIRange(o.originSelectionRange) || Re.isIRange(o.targetSelectionRange))
	)
}
var wJ = {
	17: p("Array", "array"),
	16: p("Boolean", "boolean"),
	4: p("Class", "class"),
	13: p("Constant", "constant"),
	8: p("Constructor", "constructor"),
	9: p("Enum", "enumeration"),
	21: p("EnumMember", "enumeration member"),
	23: p("Event", "event"),
	7: p("Field", "field"),
	0: p("File", "file"),
	11: p("Function", "function"),
	10: p("Interface", "interface"),
	19: p("Key", "key"),
	5: p("Method", "method"),
	1: p("Module", "module"),
	2: p("Namespace", "namespace"),
	20: p("Null", "null"),
	15: p("Number", "number"),
	18: p("Object", "object"),
	24: p("Operator", "operator"),
	3: p("Package", "package"),
	6: p("Property", "property"),
	14: p("String", "string"),
	22: p("Struct", "struct"),
	25: p("TypeParameter", "type parameter"),
	12: p("Variable", "variable"),
}
var BW
;((r) => {
	let o = new Map()
	o.set(0, ce.symbolFile),
		o.set(1, ce.symbolModule),
		o.set(2, ce.symbolNamespace),
		o.set(3, ce.symbolPackage),
		o.set(4, ce.symbolClass),
		o.set(5, ce.symbolMethod),
		o.set(6, ce.symbolProperty),
		o.set(7, ce.symbolField),
		o.set(8, ce.symbolConstructor),
		o.set(9, ce.symbolEnum),
		o.set(10, ce.symbolInterface),
		o.set(11, ce.symbolFunction),
		o.set(12, ce.symbolVariable),
		o.set(13, ce.symbolConstant),
		o.set(14, ce.symbolString),
		o.set(15, ce.symbolNumber),
		o.set(16, ce.symbolBoolean),
		o.set(17, ce.symbolArray),
		o.set(18, ce.symbolObject),
		o.set(19, ce.symbolKey),
		o.set(20, ce.symbolNull),
		o.set(21, ce.symbolEnumMember),
		o.set(22, ce.symbolStruct),
		o.set(23, ce.symbolEvent),
		o.set(24, ce.symbolOperator),
		o.set(25, ce.symbolTypeParameter)
	function e(i) {
		let s = o.get(i)
		return s || (console.info("No codicon found for SymbolKind " + i), (s = ce.symbolProperty)), s
	}
	r.toIcon = e
	let t = new Map()
	t.set(0, 20),
		t.set(1, 8),
		t.set(2, 8),
		t.set(3, 8),
		t.set(4, 5),
		t.set(5, 0),
		t.set(6, 9),
		t.set(7, 3),
		t.set(8, 2),
		t.set(9, 15),
		t.set(10, 7),
		t.set(11, 1),
		t.set(12, 4),
		t.set(13, 14),
		t.set(14, 18),
		t.set(15, 13),
		t.set(16, 13),
		t.set(17, 13),
		t.set(18, 13),
		t.set(19, 17),
		t.set(20, 13),
		t.set(21, 16),
		t.set(22, 6),
		t.set(23, 10),
		t.set(24, 11),
		t.set(25, 24)
	function n(i) {
		let s = t.get(i)
		return s === void 0 && (console.info("No completion kind found for SymbolKind " + i), (s = 20)), s
	}
	r.toCompletionKind = n
})((BW ||= {}))
var _b = class {
		static asEditOperation(e) {
			return Pb.replace(Re.lift(e.range), e.text)
		}
		static isTextEdit(e) {
			let t = e
			return typeof t.text == "string" && Re.isIRange(t.range)
		}
	},
	cs = class o {
		constructor(e) {
			this.value = e
		}
		static {
			this.Comment = new o("comment")
		}
		static {
			this.Imports = new o("imports")
		}
		static {
			this.Region = new o("region")
		}
		static fromValue(e) {
			switch (e) {
				case "comment":
					return o.Comment
				case "imports":
					return o.Imports
				case "region":
					return o.Region
			}
			return new o(e)
		}
	}
var DP
;((e) => {
	function o(t) {
		return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string"
	}
	e.is = o
})((DP ||= {}))
var PJ = new qf(),
	_J = new qf()
var kP = ((r) => (
	(r[(r.Left = 1)] = "Left"),
	(r[(r.Center = 2)] = "Center"),
	(r[(r.Right = 4)] = "Right"),
	(r[(r.Full = 7)] = "Full"),
	r
))(kP || {})
var Yl = class {
	constructor(e, t) {
		this._findMatchBrand = void 0
		;(this.range = e), (this.matches = t)
	}
}
var kb = class {
		constructor(e, t, n) {
			;(this.regex = e), (this.wordSeparators = t), (this.simpleSearch = n)
		}
	},
	Rb = class {
		constructor(e, t, n) {
			this.reverseEdits = e
			this.changes = t
			this.trimAutoWhitespaceLineNumbers = n
		}
	}
var Kc = ((r) => (
	(r[(r.Hint = 1)] = "Hint"),
	(r[(r.Info = 2)] = "Info"),
	(r[(r.Warning = 4)] = "Warning"),
	(r[(r.Error = 8)] = "Error"),
	r
))(Kc || {})
;((a) => {
	function o(l, d) {
		return d - l
	}
	a.compare = o
	let e = Object.create(null)
	;(e[8] = p("sev.error", "Error")), (e[4] = p("sev.warning", "Warning")), (e[2] = p("sev.info", "Info"))
	function t(l) {
		return e[l] || ""
	}
	a.toString = t
	let n = Object.create(null)
	;(n[8] = p("sev.errors", "Errors")), (n[4] = p("sev.warnings", "Warnings")), (n[2] = p("sev.infos", "Infos"))
	function r(l) {
		return n[l] || ""
	}
	a.toStringPlural = r
	function i(l) {
		switch (l) {
			case It.Error:
				return 8
			case It.Warning:
				return 4
			case It.Info:
				return 2
			case It.Ignore:
				return 1
		}
	}
	a.fromSeverity = i
	function s(l) {
		switch (l) {
			case 8:
				return It.Error
			case 4:
				return It.Warning
			case 2:
				return It.Info
			case 1:
				return It.Ignore
		}
	}
	a.toSeverity = s
})((Kc ||= {}))
var $W
;((n) => {
	function e(r) {
		return t(r, !0)
	}
	n.makeKey = e
	function t(r, i) {
		let s = [""]
		return (
			r.source ? s.push(r.source.replace("\xA6", "\\\xA6")) : s.push(""),
			r.code
				? typeof r.code == "string"
					? s.push(r.code.replace("\xA6", "\\\xA6"))
					: s.push(r.code.value.replace("\xA6", "\\\xA6"))
				: s.push(""),
			r.severity !== void 0 && r.severity !== null ? s.push(Kc.toString(r.severity)) : s.push(""),
			r.message && i ? s.push(r.message.replace("\xA6", "\\\xA6")) : s.push(""),
			r.startLineNumber !== void 0 && r.startLineNumber !== null
				? s.push(r.startLineNumber.toString())
				: s.push(""),
			r.startColumn !== void 0 && r.startColumn !== null ? s.push(r.startColumn.toString()) : s.push(""),
			r.endLineNumber !== void 0 && r.endLineNumber !== null ? s.push(r.endLineNumber.toString()) : s.push(""),
			r.endColumn !== void 0 && r.endColumn !== null ? s.push(r.endColumn.toString()) : s.push(""),
			s.push(""),
			s.join("\xA6")
		)
	}
	n.makeKeyOptionalMessage = t
})(($W ||= {}))
var LJ = O("markerService")
var zW = O("progressService")
var VJ = Object.freeze({ total() {}, worked() {}, done() {} }),
	ha = class {
		constructor(e) {
			this.callback = e
		}
		static {
			this.None = Object.freeze({ report() {} })
		}
		get value() {
			return this._value
		}
		report(e) {
			;(this._value = e), this.callback(this._value)
		}
	}
var Ab = class extends $ {
	constructor(t, n) {
		super()
		this.deferred = new Cn()
		n.withProgress(t, (r) => ((this.reporter = r), this.lastStep && r.report(this.lastStep), this.deferred.p)),
			this._register(q(() => this.deferred.complete()))
	}
	report(t) {
		this.reporter ? this.reporter.report(t) : (this.lastStep = t)
	}
}
Ab = R([S(1, zW)], Ab)
var BJ = O("editorProgressService")
var RP = class {
		constructor() {
			this.data = new Map()
		}
		add(e, t) {
			yn(Ee(e)),
				yn(dt(t)),
				yn(!this.data.has(e), "There is already an extension with this id"),
				this.data.set(e, t)
		}
		knows(e) {
			return this.data.has(e)
		}
		as(e) {
			return this.data.get(e) || null
		}
	},
	yt = new RP()
var AP = class extends $ {
	constructor(t, n = "", r = "", i = !0, s) {
		super()
		this._onDidChange = this._register(new E())
		this.onDidChange = this._onDidChange.event
		this._enabled = !0
		;(this._id = t), (this._label = n), (this._cssClass = r), (this._enabled = i), (this._actionCallback = s)
	}
	get id() {
		return this._id
	}
	get label() {
		return this._label
	}
	set label(t) {
		this._setLabel(t)
	}
	_setLabel(t) {
		this._label !== t && ((this._label = t), this._onDidChange.fire({ label: t }))
	}
	get tooltip() {
		return this._tooltip || ""
	}
	set tooltip(t) {
		this._setTooltip(t)
	}
	_setTooltip(t) {
		this._tooltip !== t && ((this._tooltip = t), this._onDidChange.fire({ tooltip: t }))
	}
	get class() {
		return this._cssClass
	}
	set class(t) {
		this._setClass(t)
	}
	_setClass(t) {
		this._cssClass !== t && ((this._cssClass = t), this._onDidChange.fire({ class: t }))
	}
	get enabled() {
		return this._enabled
	}
	set enabled(t) {
		this._setEnabled(t)
	}
	_setEnabled(t) {
		this._enabled !== t && ((this._enabled = t), this._onDidChange.fire({ enabled: t }))
	}
	get checked() {
		return this._checked
	}
	set checked(t) {
		this._setChecked(t)
	}
	_setChecked(t) {
		this._checked !== t && ((this._checked = t), this._onDidChange.fire({ checked: t }))
	}
	async run(t, n) {
		this._actionCallback && (await this._actionCallback(t))
	}
}
var HL = class o {
	constructor() {
		this.id = o.ID
		this.label = ""
		this.tooltip = ""
		this.class = "separator"
		this.enabled = !1
		this.checked = !1
	}
	static join(...e) {
		let t = []
		for (let n of e) n.length && (t.length ? (t = [...t, new o(), ...n]) : (t = n))
		return t
	}
	static {
		this.ID = "vs.actions.separator"
	}
	async run() {}
}
var WL = class o extends AP {
	static {
		this.ID = "vs.actions.empty"
	}
	constructor() {
		super(o.ID, p("submenu.empty", "(empty)"), void 0, !1)
	}
}
var qW = {
		EditorPane: "workbench.contributions.editors",
		EditorFactory: "workbench.contributions.editor.inputFactories",
	},
	UP = {
		id: "default",
		displayName: p("promptOpenWith.defaultEditor.displayName", "Text Editor"),
		providerDisplayName: p("builtinProviderDisplayName", "Built-in"),
	}
function Lb(o) {
	if (us(o)) return !1
	let e = o
	return e?.original !== void 0 && e.modified !== void 0
}
function VL(o) {
	if (us(o)) return !1
	let e = o
	return !e || (e.resources && !Array.isArray(e.resources)) ? !1 : !!e.resources || !!e.multiDiffSource
}
function OP(o) {
	if (us(o) || Lb(o)) return !1
	let e = o
	return e?.primary !== void 0 && e.secondary !== void 0
}
function Ob(o) {
	if (us(o)) return !1
	let e = o
	return (
		y.isUri(e?.base?.resource) &&
		y.isUri(e?.input1?.resource) &&
		y.isUri(e?.input2?.resource) &&
		y.isUri(e?.result?.resource)
	)
}
var LP = class {
		constructor() {
			this.mapIdToSaveSource = new Map()
		}
		registerSource(e, t) {
			let n = this.mapIdToSaveSource.get(e)
			return n || ((n = { source: e, label: t }), this.mapIdToSaveSource.set(e, n)), n.source
		}
		getSourceLabel(e) {
			return this.mapIdToSaveSource.get(e)?.label ?? e
		}
	},
	yX = new LP()
var MP = class extends $ {}
function us(o) {
	return o instanceof MP
}
function KW(o) {
	let e = o
	return y.isUri(e?.preferredResource)
}
function jW(o) {
	let e = o
	return us(e?.primary) && us(e?.secondary)
}
function GW(o) {
	let e = o
	return us(e?.modified) && us(e?.original)
}
var FP = class {
	getOriginalUri(e, t) {
		if (!e) return
		if (Ob(e)) return BL.getOriginalUri(e.result, t)
		if (t?.supportSideBySide) {
			let { primary: r, secondary: i } = this.getSideEditors(e)
			if (r && i) {
				if (t?.supportSideBySide === 3)
					return {
						primary: this.getOriginalUri(r, { filterByScheme: t.filterByScheme }),
						secondary: this.getOriginalUri(i, { filterByScheme: t.filterByScheme }),
					}
				if (t?.supportSideBySide === 4)
					return (
						this.getOriginalUri(r, { filterByScheme: t.filterByScheme }) ??
						this.getOriginalUri(i, { filterByScheme: t.filterByScheme })
					)
				e = t.supportSideBySide === 1 ? r : i
			}
		}
		if (Lb(e) || VL(e) || OP(e) || Ob(e)) return
		let n = KW(e) ? e.preferredResource : e.resource
		return !n || !t || !t.filterByScheme ? n : this.filterUri(n, t.filterByScheme)
	}
	getSideEditors(e) {
		return jW(e) || OP(e)
			? { primary: e.primary, secondary: e.secondary }
			: GW(e) || Lb(e)
				? { primary: e.modified, secondary: e.original }
				: { primary: void 0, secondary: void 0 }
	}
	getCanonicalUri(e, t) {
		if (!e) return
		if (Ob(e)) return BL.getCanonicalUri(e.result, t)
		if (t?.supportSideBySide) {
			let { primary: r, secondary: i } = this.getSideEditors(e)
			if (r && i) {
				if (t?.supportSideBySide === 3)
					return {
						primary: this.getCanonicalUri(r, { filterByScheme: t.filterByScheme }),
						secondary: this.getCanonicalUri(i, { filterByScheme: t.filterByScheme }),
					}
				if (t?.supportSideBySide === 4)
					return (
						this.getCanonicalUri(r, { filterByScheme: t.filterByScheme }) ??
						this.getCanonicalUri(i, { filterByScheme: t.filterByScheme })
					)
				e = t.supportSideBySide === 1 ? r : i
			}
		}
		if (Lb(e) || VL(e) || OP(e) || Ob(e)) return
		let n = e.resource
		return !n || !t || !t.filterByScheme ? n : this.filterUri(n, t.filterByScheme)
	}
	filterUri(e, t) {
		if (Array.isArray(t)) {
			if (t.some((n) => e.scheme === n)) return e
		} else if (t === e.scheme) return e
	}
}
var BL = new FP()
var NP = class {
	constructor() {
		this.editorSerializerConstructors = new Map()
		this.editorSerializerInstances = new Map()
	}
	start(e) {
		let t = (this.instantiationService = e.get(Uo))
		for (let [n, r] of this.editorSerializerConstructors) this.createEditorSerializer(n, r, t)
		this.editorSerializerConstructors.clear()
	}
	createEditorSerializer(e, t, n) {
		let r = n.createInstance(t)
		this.editorSerializerInstances.set(e, r)
	}
	registerFileEditorFactory(e) {
		if (this.fileEditorFactory) throw new Error("Can only register one file editor factory.")
		this.fileEditorFactory = e
	}
	getFileEditorFactory() {
		return Do(this.fileEditorFactory)
	}
	registerEditorSerializer(e, t) {
		if (this.editorSerializerConstructors.has(e) || this.editorSerializerInstances.has(e))
			throw new Error(`A editor serializer with type ID '${e}' was already registered.`)
		return (
			this.instantiationService
				? this.createEditorSerializer(e, t, this.instantiationService)
				: this.editorSerializerConstructors.set(e, t),
			q(() => {
				this.editorSerializerConstructors.delete(e), this.editorSerializerInstances.delete(e)
			})
		)
	}
	getEditorSerializer(e) {
		return this.editorSerializerInstances.get(typeof e == "string" ? e : e.typeId)
	}
}
yt.add(qW.EditorFactory, new NP())
var Gr = class {
		constructor(e, t, n) {
			this.owner = e
			this.debugNameSource = t
			this.referenceFn = n
		}
		getDebugName(e) {
			return KL(e, this)
		}
	},
	$L = new Map(),
	HP = new WeakMap()
function KL(o, e) {
	let t = HP.get(o)
	if (t) return t
	let n = QW(o, e)
	if (n) {
		let r = $L.get(n) ?? 0
		r++, $L.set(n, r)
		let i = r === 1 ? n : `${n}#${r}`
		return HP.set(o, i), i
	}
}
function QW(o, e) {
	let t = HP.get(o)
	if (t) return t
	let n = e.owner ? XW(e.owner) + "." : "",
		r,
		i = e.debugNameSource
	if (i !== void 0)
		if (typeof i == "function") {
			if (((r = i()), r !== void 0)) return n + r
		} else return n + i
	let s = e.referenceFn
	if (s !== void 0 && ((r = Mb(s)), r !== void 0)) return n + r
	if (e.owner !== void 0) {
		let a = JW(e.owner, o)
		if (a !== void 0) return n + a
	}
}
function JW(o, e) {
	for (let t in o) if (o[t] === e) return t
}
var zL = new Map(),
	qL = new WeakMap()
function XW(o) {
	let e = qL.get(o)
	if (e) return e
	let t = WP(o) ?? "Object",
		n = zL.get(t) ?? 0
	n++, zL.set(t, n)
	let r = n === 1 ? t : `${t}#${n}`
	return qL.set(o, r), r
}
function WP(o) {
	let e = o.constructor
	if (e) return e.name === "Object" ? void 0 : e.name
}
function Mb(o) {
	let e = o.toString(),
		n = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e)
	return (n ? n[1] : void 0)?.trim()
}
var ps = (o, e) => o === e
function Fb(o, e) {
	if (o === e) return !0
	if (Array.isArray(o) && Array.isArray(e)) {
		if (o.length !== e.length) return !1
		for (let t = 0; t < o.length; t++) if (!Fb(o[t], e[t])) return !1
		return !0
	}
	if (
		o &&
		typeof o == "object" &&
		e &&
		typeof e == "object" &&
		Object.getPrototypeOf(o) === Object.prototype &&
		Object.getPrototypeOf(e) === Object.prototype
	) {
		let t = o,
			n = e,
			r = Object.keys(t),
			i = Object.keys(n),
			s = new Set(i)
		if (r.length !== i.length) return !1
		for (let a of r) if (!s.has(a) || !Fb(t[a], n[a])) return !1
		return !0
	}
	return !1
}
var Zl
function Kf(o) {
	Zl ? (Zl instanceof Nb ? Zl.loggers.push(o) : (Zl = new Nb([Zl, o]))) : (Zl = o)
}
function Zt() {
	return Zl
}
var VP
function jL(o) {
	VP = o
}
function GL(o) {
	VP && VP(o)
}
var Nb = class {
	constructor(e) {
		this.loggers = e
	}
	handleObservableCreated(e) {
		for (let t of this.loggers) t.handleObservableCreated(e)
	}
	handleOnListenerCountChanged(e, t) {
		for (let n of this.loggers) n.handleOnListenerCountChanged(e, t)
	}
	handleObservableUpdated(e, t) {
		for (let n of this.loggers) n.handleObservableUpdated(e, t)
	}
	handleAutorunCreated(e) {
		for (let t of this.loggers) t.handleAutorunCreated(e)
	}
	handleAutorunDisposed(e) {
		for (let t of this.loggers) t.handleAutorunDisposed(e)
	}
	handleAutorunDependencyChanged(e, t, n) {
		for (let r of this.loggers) r.handleAutorunDependencyChanged(e, t, n)
	}
	handleAutorunStarted(e) {
		for (let t of this.loggers) t.handleAutorunStarted(e)
	}
	handleAutorunFinished(e) {
		for (let t of this.loggers) t.handleAutorunFinished(e)
	}
	handleDerivedDependencyChanged(e, t, n) {
		for (let r of this.loggers) r.handleDerivedDependencyChanged(e, t, n)
	}
	handleDerivedCleared(e) {
		for (let t of this.loggers) t.handleDerivedCleared(e)
	}
	handleBeginTransaction(e) {
		for (let t of this.loggers) t.handleBeginTransaction(e)
	}
	handleEndTransaction(e) {
		for (let t of this.loggers) t.handleEndTransaction(e)
	}
}
var JL
function XL(o) {
	JL = o
}
var YL
function ZL(o) {
	YL = o
}
var BP
function eM(o) {
	BP = o
}
var Ub = class {
		get TChange() {
			return null
		}
		reportChanges() {
			this.get()
		}
		read(e) {
			return e ? e.readObservable(this) : this.get()
		}
		map(e, t) {
			let n = t === void 0 ? void 0 : e,
				r = t === void 0 ? e : t
			return BP(
				{
					owner: n,
					debugName: () => {
						let i = Mb(r)
						if (i !== void 0) return i
						let a =
							/^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(
								r.toString(),
							)
						if (a) return `${this.debugName}.${a[2]}`
						if (!n) return `${this.debugName} (mapped)`
					},
					debugReferenceFn: r,
				},
				(i) => r(this.read(i), i),
			)
		}
		flatten() {
			return BP({ owner: void 0, debugName: () => `${this.debugName} (flattened)` }, (e) => this.read(e).read(e))
		}
		recomputeInitiallyAndOnChange(e, t) {
			return e.add(JL(this, t)), this
		}
		keepObserved(e) {
			return e.add(YL(this)), this
		}
		get debugValue() {
			return this.get()
		}
	},
	va = class extends Ub {
		constructor() {
			super()
			this._observers = new Set()
			Zt()?.handleObservableCreated(this)
		}
		addObserver(t) {
			let n = this._observers.size
			this._observers.add(t),
				n === 0 && this.onFirstObserverAdded(),
				n !== this._observers.size && Zt()?.handleOnListenerCountChanged(this, this._observers.size)
		}
		removeObserver(t) {
			let n = this._observers.delete(t)
			n && this._observers.size === 0 && this.onLastObserverRemoved(),
				n && Zt()?.handleOnListenerCountChanged(this, this._observers.size)
		}
		onFirstObserverAdded() {}
		onLastObserverRemoved() {}
		log() {
			let t = !!Zt()
			return GL(this), t || Zt()?.handleObservableCreated(this), this
		}
		debugGetObservers() {
			return this._observers
		}
	}
function td(o, e) {
	let t = new jc(o, e)
	try {
		o(t)
	} finally {
		t.finish()
	}
}
function $P(o, e, t) {
	o ? e(o) : td(e, t)
}
var jc = class {
	constructor(e, t) {
		this._fn = e
		this._getDebugName = t
		this._updatingObservers = []
		Zt()?.handleBeginTransaction(this)
	}
	getDebugName() {
		return this._getDebugName ? this._getDebugName() : Mb(this._fn)
	}
	updateObserver(e, t) {
		if (!this._updatingObservers) {
			QL("Transaction already finished!"),
				td((n) => {
					n.updateObserver(e, t)
				})
			return
		}
		this._updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t)
	}
	finish() {
		let e = this._updatingObservers
		if (!e) {
			QL("transaction.finish() has already been called!")
			return
		}
		for (let t = 0; t < e.length; t++) {
			let { observer: n, observable: r } = e[t]
			n.endUpdate(r)
		}
		;(this._updatingObservers = null), Zt()?.handleEndTransaction(this)
	}
	debugGetUpdatingObservers() {
		return this._updatingObservers
	}
}
function QL(o) {
	let e = new Error("BugIndicatingErrorRecovery: " + o)
	Be(e), console.error("recovered from an error that indicates a bug", e)
}
function ba(o, e) {
	let t
	return typeof o == "string" ? (t = new Gr(void 0, o, void 0)) : (t = new Gr(o, void 0, void 0)), new ed(t, e, ps)
}
var ed = class extends va {
	constructor(t, n, r) {
		super()
		this._debugNameData = t
		this._equalityComparator = r
		;(this._value = n),
			Zt()?.handleObservableUpdated(this, {
				hadValue: !1,
				newValue: n,
				change: void 0,
				didChange: !0,
				oldValue: void 0,
			})
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "ObservableValue"
	}
	get() {
		return this._value
	}
	set(t, n, r) {
		if (r === void 0 && this._equalityComparator(this._value, t)) return
		let i
		n ||
			(n = i =
				new jc(
					() => {},
					() => `Setting ${this.debugName}`,
				))
		try {
			let s = this._value
			this._setValue(t),
				Zt()?.handleObservableUpdated(this, {
					oldValue: s,
					newValue: t,
					change: r,
					didChange: !0,
					hadValue: !0,
				})
			for (let a of this._observers) n.updateObserver(a, this), a.handleChange(this, r)
		} finally {
			i && i.finish()
		}
	}
	toString() {
		return `${this.debugName}: ${this._value}`
	}
	_setValue(t) {
		this._value = t
	}
	debugGetState() {
		return { value: this._value }
	}
	debugSetValue(t) {
		this._value = t
	}
}
function nd(o) {
	return new Gc(new Gr(void 0, void 0, o), o, void 0)
}
var Gc = class {
	constructor(e, t, n) {
		this._debugNameData = e
		this._runFn = t
		this._changeTracker = n
		this._state = 2
		this._updateCount = 0
		this._disposed = !1
		this._dependencies = new Set()
		this._dependenciesToBeRemoved = new Set()
		this._isRunning = !1
		;(this._changeSummary = this._changeTracker?.createChangeSummary(void 0)),
			Zt()?.handleAutorunCreated(this),
			this._run(),
			Zs(this)
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "(anonymous)"
	}
	dispose() {
		if (!this._disposed) {
			this._disposed = !0
			for (let e of this._dependencies) e.removeObserver(this)
			this._dependencies.clear(), Zt()?.handleAutorunDisposed(this), ea(this)
		}
	}
	_run() {
		let e = this._dependenciesToBeRemoved
		;(this._dependenciesToBeRemoved = this._dependencies), (this._dependencies = e), (this._state = 3)
		try {
			if (!this._disposed) {
				Zt()?.handleAutorunStarted(this)
				let t = this._changeSummary
				try {
					;(this._isRunning = !0),
						this._changeTracker &&
							(this._changeTracker.beforeUpdate?.(this, t),
							(this._changeSummary = this._changeTracker.createChangeSummary(t))),
						this._runFn(this, t)
				} catch (n) {
					Tl(n)
				} finally {
					this._isRunning = !1
				}
			}
		} finally {
			this._disposed || Zt()?.handleAutorunFinished(this)
			for (let t of this._dependenciesToBeRemoved) t.removeObserver(this)
			this._dependenciesToBeRemoved.clear()
		}
	}
	toString() {
		return `Autorun<${this.debugName}>`
	}
	beginUpdate(e) {
		this._state === 3 && (this._state = 1), this._updateCount++
	}
	endUpdate(e) {
		try {
			if (this._updateCount === 1)
				do {
					if (this._state === 1) {
						this._state = 3
						for (let t of this._dependencies) if ((t.reportChanges(), this._state === 2)) break
					}
					this._state !== 3 && this._run()
				} while (this._state !== 3)
		} finally {
			this._updateCount--
		}
		Jm(() => this._updateCount >= 0)
	}
	handlePossibleChange(e) {
		this._state === 3 && this._isDependency(e) && (this._state = 1)
	}
	handleChange(e, t) {
		if (this._isDependency(e)) {
			Zt()?.handleAutorunDependencyChanged(this, e, t)
			try {
				;(this._changeTracker
					? this._changeTracker.handleChange(
							{ changedObservable: e, change: t, didChange: (r) => r === e },
							this._changeSummary,
						)
					: !0) && (this._state = 2)
			} catch (n) {
				Tl(n)
			}
		}
	}
	_isDependency(e) {
		return this._dependencies.has(e) && !this._dependenciesToBeRemoved.has(e)
	}
	readObservable(e) {
		if (!this._isRunning) throw new Gt("The reader object cannot be used outside its compute function!")
		if (this._disposed) return e.get()
		e.addObserver(this)
		let t = e.get()
		return this._dependencies.add(e), this._dependenciesToBeRemoved.delete(e), t
	}
	debugGetState() {
		return {
			isRunning: this._isRunning,
			updateCount: this._updateCount,
			dependencies: this._dependencies,
			state: this._state,
		}
	}
	debugRerun() {
		this._isRunning ? (this._state = 2) : this._run()
	}
}
;((e) => (e.Observer = Gc))((nd ||= {}))
function zP(o, e) {
	return new Or(
		new Gr(o.owner, o.debugName, o.debugReferenceFn),
		e,
		void 0,
		o.onLastObserverRemoved,
		o.equalsFn ?? ps,
	)
}
eM(zP)
var Or = class extends va {
	constructor(t, n, r, i = void 0, s) {
		super()
		this._debugNameData = t
		this._computeFn = n
		this._changeTracker = r
		this._handleLastObserverRemoved = i
		this._equalityComparator = s
		this._state = 0
		this._value = void 0
		this._updateCount = 0
		this._dependencies = new Set()
		this._dependenciesToBeRemoved = new Set()
		this._changeSummary = void 0
		this._isUpdating = !1
		this._isComputing = !1
		this._didReportChange = !1
		this._removedObserverToCallEndUpdateOn = null
		this._isReaderValid = !1
		this._changeSummary = this._changeTracker?.createChangeSummary(void 0)
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "(anonymous)"
	}
	onLastObserverRemoved() {
		;(this._state = 0), (this._value = void 0), Zt()?.handleDerivedCleared(this)
		for (let t of this._dependencies) t.removeObserver(this)
		this._dependencies.clear(), this._handleLastObserverRemoved?.()
	}
	get() {
		if ((this._isComputing, this._observers.size === 0)) {
			let n
			try {
				this._isReaderValid = !0
				let r
				this._changeTracker &&
					((r = this._changeTracker.createChangeSummary(void 0)),
					this._changeTracker.beforeUpdate?.(this, r)),
					(n = this._computeFn(this, r))
			} finally {
				this._isReaderValid = !1
			}
			return this.onLastObserverRemoved(), n
		} else {
			do {
				if (this._state === 1) {
					for (let n of this._dependencies) if ((n.reportChanges(), this._state === 2)) break
				}
				this._state === 1 && (this._state = 3), this._state !== 3 && this._recompute()
			} while (this._state !== 3)
			return this._value
		}
	}
	_recompute() {
		let t = this._dependenciesToBeRemoved
		;(this._dependenciesToBeRemoved = this._dependencies), (this._dependencies = t)
		let n = this._state !== 0,
			r = this._value
		this._state = 3
		let i = !1
		;(this._isComputing = !0), (this._didReportChange = !1)
		try {
			let s = this._changeSummary
			try {
				;(this._isReaderValid = !0),
					this._changeTracker &&
						(this._changeTracker.beforeUpdate?.(this, s),
						(this._changeSummary = this._changeTracker?.createChangeSummary(s))),
					(this._value = this._computeFn(this, s))
			} finally {
				this._isReaderValid = !1
				for (let a of this._dependenciesToBeRemoved) a.removeObserver(this)
				this._dependenciesToBeRemoved.clear()
			}
			;(i = this._didReportChange || (n && !this._equalityComparator(r, this._value))),
				Zt()?.handleObservableUpdated(this, {
					oldValue: r,
					newValue: this._value,
					change: void 0,
					didChange: i,
					hadValue: n,
				})
		} catch (s) {
			Tl(s)
		}
		if (((this._isComputing = !1), !this._didReportChange && i))
			for (let s of this._observers) s.handleChange(this, void 0)
		else this._didReportChange = !1
	}
	toString() {
		return `LazyDerived<${this.debugName}>`
	}
	beginUpdate(t) {
		if (this._isUpdating) throw new Gt("Cyclic deriveds are not supported yet!")
		this._updateCount++, (this._isUpdating = !0)
		try {
			let n = this._updateCount === 1
			if (this._state === 3 && ((this._state = 1), !n))
				for (let r of this._observers) r.handlePossibleChange(this)
			if (n) for (let r of this._observers) r.beginUpdate(this)
		} finally {
			this._isUpdating = !1
		}
	}
	endUpdate(t) {
		if ((this._updateCount--, this._updateCount === 0)) {
			let n = [...this._observers]
			for (let r of n) r.endUpdate(this)
			if (this._removedObserverToCallEndUpdateOn) {
				let r = [...this._removedObserverToCallEndUpdateOn]
				this._removedObserverToCallEndUpdateOn = null
				for (let i of r) i.endUpdate(this)
			}
		}
		Jm(() => this._updateCount >= 0)
	}
	handlePossibleChange(t) {
		if (this._state === 3 && this._dependencies.has(t) && !this._dependenciesToBeRemoved.has(t)) {
			this._state = 1
			for (let n of this._observers) n.handlePossibleChange(this)
		}
	}
	handleChange(t, n) {
		if (this._dependencies.has(t) && !this._dependenciesToBeRemoved.has(t)) {
			Zt()?.handleDerivedDependencyChanged(this, t, n)
			let r = !1
			try {
				r = this._changeTracker
					? this._changeTracker.handleChange(
							{ changedObservable: t, change: n, didChange: (s) => s === t },
							this._changeSummary,
						)
					: !0
			} catch (s) {
				Tl(s)
			}
			let i = this._state === 3
			if (r && (this._state === 1 || i) && ((this._state = 2), i))
				for (let s of this._observers) s.handlePossibleChange(this)
		}
	}
	readObservable(t) {
		if (!this._isReaderValid) throw new Gt("The reader object cannot be used outside its compute function!")
		t.addObserver(this)
		let n = t.get()
		return this._dependencies.add(t), this._dependenciesToBeRemoved.delete(t), n
	}
	reportChange(t) {
		if (!this._isReaderValid) throw new Gt("The reader object cannot be used outside its compute function!")
		this._didReportChange = !0
		for (let n of this._observers) n.handleChange(this, t)
	}
	addObserver(t) {
		let n = !this._observers.has(t) && this._updateCount > 0
		super.addObserver(t),
			n &&
				(this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(t)
					? this._removedObserverToCallEndUpdateOn.delete(t)
					: t.beginUpdate(this))
	}
	removeObserver(t) {
		this._observers.has(t) &&
			this._updateCount > 0 &&
			(this._removedObserverToCallEndUpdateOn || (this._removedObserverToCallEndUpdateOn = new Set()),
			this._removedObserverToCallEndUpdateOn.add(t)),
			super.removeObserver(t)
	}
	debugGetState() {
		return {
			state: this._state,
			updateCount: this._updateCount,
			isComputing: this._isComputing,
			dependencies: this._dependencies,
			value: this._value,
		}
	}
	debugSetValue(t) {
		this._value = t
	}
	setValue(t, n, r) {
		this._value = t
		let i = this._observers
		n.updateObserver(this, this)
		for (let s of i) s.handleChange(this, r)
	}
}
var jf = class o {
		constructor(e) {
			this._value = ba(this, void 0)
			this.promiseResult = this._value
			this.promise = e.then(
				(t) => (
					td((n) => {
						this._value.set(new Gf(t, void 0), n)
					}),
					t
				),
				(t) => {
					throw (
						(td((n) => {
							this._value.set(new Gf(void 0, t), n)
						}),
						t)
					)
				},
			)
		}
		static fromFn(e) {
			return new o(e())
		}
	},
	Gf = class {
		constructor(e, t) {
			this.data = e
			this.error = t
		}
		getDataOrThrow() {
			if (this.error) throw this.error
			return this.data
		}
	}
function qP(...o) {
	let e, t, n
	return (
		o.length === 3 ? ([e, t, n] = o) : ([t, n] = o),
		new fi(new Gr(e, void 0, n), t, n, () => fi.globalTransaction, ps)
	)
}
var fi = class extends va {
	constructor(t, n, r, i, s) {
		super()
		this._debugNameData = t
		this.event = n
		this._getValue = r
		this._getTransaction = i
		this._equalityComparator = s
		this._hasValue = !1
		this.handleEvent = (t) => {
			let n = this._getValue(t),
				r = this._value,
				i = !this._hasValue || !this._equalityComparator(r, n),
				s = !1
			i &&
				((this._value = n),
				this._hasValue &&
					((s = !0),
					$P(
						this._getTransaction(),
						(a) => {
							Zt()?.handleObservableUpdated(this, {
								oldValue: r,
								newValue: n,
								change: void 0,
								didChange: i,
								hadValue: this._hasValue,
							})
							for (let l of this._observers) a.updateObserver(l, this), l.handleChange(this, void 0)
						},
						() => {
							let a = this.getDebugName()
							return "Event fired" + (a ? `: ${a}` : "")
						},
					)),
				(this._hasValue = !0)),
				s ||
					Zt()?.handleObservableUpdated(this, {
						oldValue: r,
						newValue: n,
						change: void 0,
						didChange: i,
						hadValue: this._hasValue,
					})
		}
	}
	getDebugName() {
		return this._debugNameData.getDebugName(this)
	}
	get debugName() {
		let t = this.getDebugName()
		return "From Event" + (t ? `: ${t}` : "")
	}
	onFirstObserverAdded() {
		this._subscription = this.event(this.handleEvent)
	}
	onLastObserverRemoved() {
		this._subscription.dispose(), (this._subscription = void 0), (this._hasValue = !1), (this._value = void 0)
	}
	get() {
		return this._subscription ? (this._hasValue || this.handleEvent(void 0), this._value) : this._getValue(void 0)
	}
	debugSetValue(t) {
		this._value = t
	}
}
;((t) => {
	t.Observer = fi
	function e(n, r) {
		let i = !1
		fi.globalTransaction === void 0 && ((fi.globalTransaction = n), (i = !0))
		try {
			r()
		} finally {
			i && (fi.globalTransaction = void 0)
		}
	}
	t.batchEventsGlobally = e
})((qP ||= {}))
function nM(o) {
	let e = new Hb(!1, void 0)
	return (
		o.addObserver(e),
		q(() => {
			o.removeObserver(e)
		})
	)
}
ZL(nM)
function rM(o, e) {
	let t = new Hb(!0, e)
	o.addObserver(t)
	try {
		t.beginUpdate(o)
	} finally {
		t.endUpdate(o)
	}
	return q(() => {
		o.removeObserver(t)
	})
}
XL(rM)
var Hb = class {
	constructor(e, t) {
		this._forceRecompute = e
		this._handleValue = t
		this._counter = 0
	}
	beginUpdate(e) {
		this._counter++
	}
	endUpdate(e) {
		this._counter === 1 &&
			this._forceRecompute &&
			(this._handleValue ? this._handleValue(e.get()) : e.reportChanges()),
			this._counter--
	}
	handlePossibleChange(e) {}
	handleChange(e, t) {}
}
var Wb
function oM(o) {
	Wb || ((Wb = new Qf()), Kf(Wb)), Wb.addFilteredObj(o)
}
var Qf = class {
	constructor() {
		this.indentation = 0
		this.changedObservablesSets = new WeakMap()
	}
	addFilteredObj(e) {
		this._filteredObjects || (this._filteredObjects = new Set()), this._filteredObjects.add(e)
	}
	_isIncluded(e) {
		return this._filteredObjects?.has(e) ?? !0
	}
	textToConsoleArgs(e) {
		return eV([Qc(rV("|  ", this.indentation)), e])
	}
	formatInfo(e) {
		return e.hadValue
			? e.didChange
				? [
						Qc(" "),
						mo(gi(e.oldValue, 70), { color: "red", strikeThrough: !0 }),
						Qc(" "),
						mo(gi(e.newValue, 60), { color: "green" }),
					]
				: [Qc(" (unchanged)")]
			: [Qc(" "), mo(gi(e.newValue, 60), { color: "green" }), Qc(" (initial)")]
	}
	handleObservableCreated(e) {
		if (e instanceof Or) {
			let t = e
			if ((this.changedObservablesSets.set(t, new Set()), !1)) {
				let r = []
				t.__debugUpdating = r
				let i = t.beginUpdate
				t.beginUpdate = (a) => (r.push(a), i.apply(t, [a]))
				let s = t.endUpdate
				t.endUpdate = (a) => {
					let l = r.indexOf(a)
					return (
						l === -1 && console.error("endUpdate called without beginUpdate", t.debugName, a.debugName),
						r.splice(l, 1),
						s.apply(t, [a])
					)
				}
			}
		}
	}
	handleOnListenerCountChanged(e, t) {}
	handleObservableUpdated(e, t) {
		if (this._isIncluded(e)) {
			if (e instanceof Or) {
				this._handleDerivedRecomputed(e, t)
				return
			}
			console.log(
				...this.textToConsoleArgs([
					Jc("observable value changed"),
					mo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
				]),
			)
		}
	}
	formatChanges(e) {
		if (e.size !== 0)
			return mo(" (changed deps: " + [...e].map((t) => t.debugName).join(", ") + ")", { color: "gray" })
	}
	handleDerivedDependencyChanged(e, t, n) {
		this._isIncluded(e) && this.changedObservablesSets.get(e)?.add(t)
	}
	_handleDerivedRecomputed(e, t) {
		if (!this._isIncluded(e)) return
		let n = this.changedObservablesSets.get(e)
		n &&
			(console.log(
				...this.textToConsoleArgs([
					Jc("derived recomputed"),
					mo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
					this.formatChanges(n),
					{ data: [{ fn: e._debugNameData.referenceFn ?? e._computeFn }] },
				]),
			),
			n.clear())
	}
	handleDerivedCleared(e) {
		this._isIncluded(e) &&
			console.log(...this.textToConsoleArgs([Jc("derived cleared"), mo(e.debugName, { color: "BlueViolet" })]))
	}
	handleFromEventObservableTriggered(e, t) {
		this._isIncluded(e) &&
			console.log(
				...this.textToConsoleArgs([
					Jc("observable from event triggered"),
					mo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
					{ data: [{ fn: e._getValue }] },
				]),
			)
	}
	handleAutorunCreated(e) {
		this._isIncluded(e) && this.changedObservablesSets.set(e, new Set())
	}
	handleAutorunDisposed(e) {}
	handleAutorunDependencyChanged(e, t, n) {
		this._isIncluded(e) && this.changedObservablesSets.get(e).add(t)
	}
	handleAutorunStarted(e) {
		let t = this.changedObservablesSets.get(e)
		t &&
			(this._isIncluded(e) &&
				console.log(
					...this.textToConsoleArgs([
						Jc("autorun"),
						mo(e.debugName, { color: "BlueViolet" }),
						this.formatChanges(t),
						{ data: [{ fn: e._debugNameData.referenceFn ?? e._runFn }] },
					]),
				),
			t.clear(),
			this.indentation++)
	}
	handleAutorunFinished(e) {
		this.indentation--
	}
	handleBeginTransaction(e) {
		let t = e.getDebugName()
		t === void 0 && (t = ""),
			this._isIncluded(e) &&
				console.log(
					...this.textToConsoleArgs([
						Jc("transaction"),
						mo(t, { color: "BlueViolet" }),
						{ data: [{ fn: e._fn }] },
					]),
				),
			this.indentation++
	}
	handleEndTransaction() {
		this.indentation--
	}
}
function eV(o) {
	let e = new Array(),
		t = [],
		n = ""
	function r(s) {
		if ("length" in s) for (let a of s) a && r(a)
		else
			"text" in s
				? ((n += `%c${s.text}`), e.push(s.style), s.data && t.push(...s.data))
				: "data" in s && t.push(...s.data)
	}
	r(o)
	let i = [n, ...e]
	return i.push(...t), i
}
function Qc(o) {
	return mo(o, { color: "black" })
}
function Jc(o) {
	return mo(oV(`${o}: `, 10), { color: "black", bold: !0 })
}
function mo(o, e = { color: "black" }) {
	function t(r) {
		return Object.entries(r).reduce((i, [s, a]) => `${i}${s}:${a};`, "")
	}
	let n = { color: e.color }
	return (
		e.strikeThrough && (n["text-decoration"] = "line-through"),
		e.bold && (n["font-weight"] = "bold"),
		{ text: o, style: t(n) }
	)
}
function gi(o, e) {
	switch (typeof o) {
		case "number":
			return "" + o
		case "string":
			return o.length + 2 <= e ? `"${o}"` : `"${o.substr(0, e - 7)}"+...`
		case "boolean":
			return o ? "true" : "false"
		case "undefined":
			return "undefined"
		case "object":
			return o === null ? "null" : Array.isArray(o) ? tV(o, e) : nV(o, e)
		case "symbol":
			return o.toString()
		case "function":
			return `[[Function${o.name ? " " + o.name : ""}]]`
		default:
			return "" + o
	}
}
function tV(o, e) {
	let t = "[ ",
		n = !0
	for (let r of o) {
		if ((n || (t += ", "), t.length - 5 > e)) {
			t += "..."
			break
		}
		;(n = !1), (t += `${gi(r, e - t.length)}`)
	}
	return (t += " ]"), t
}
function nV(o, e) {
	if (typeof o.toString == "function" && o.toString !== Object.prototype.toString) {
		let i = o.toString()
		return i.length <= e ? i : i.substring(0, e - 3) + "..."
	}
	let t = WP(o),
		n = t ? t + "(" : "{ ",
		r = !0
	for (let [i, s] of Object.entries(o)) {
		if ((r || (n += ", "), n.length - 5 > e)) {
			n += "..."
			break
		}
		;(r = !1), (n += `${i}: ${gi(s, e - n.length)}`)
	}
	return (n += t ? ")" : " }"), n
}
function rV(o, e) {
	let t = ""
	for (let n = 1; n <= e; n++) t += o
	return t
}
function oV(o, e) {
	for (; o.length < e; ) o += " "
	return o
}
var Vb = class o {
	constructor(e, t) {
		this._channelFactory = e
		this._getHandler = t
		this._channel = this._channelFactory({
			handleNotification: (i) => {
				let s = i,
					a = this._getHandler().notifications[s[0]]
				if (!a) throw new Error(`Unknown notification "${s[0]}"!`)
				a(...s[1])
			},
			handleRequest: (i) => {
				let s = i
				try {
					return { type: "result", value: this._getHandler().requests[s[0]](...s[1]) }
				} catch (a) {
					return { type: "error", value: a }
				}
			},
		})
		let n = new Proxy(
				{},
				{
					get:
						(i, s) =>
						async (...a) => {
							let l = await this._channel.sendRequest([s, a])
							if (l.type === "error") throw l.value
							return l.value
						},
				},
			),
			r = new Proxy(
				{},
				{
					get:
						(i, s) =>
						(...a) => {
							this._channel.sendNotification([s, a])
						},
				},
			)
		this.api = { notifications: r, requests: n }
	}
	static createHost(e, t) {
		return new o(e, t)
	}
	static createClient(e, t) {
		return new o(e, t)
	}
}
function iM(o, e) {
	let t = globalThis,
		n = [],
		r,
		{ channel: i, handler: s } = iV({
			sendNotification: (l) => {
				r ? r.sendNotification(l) : n.push(l)
			},
		}),
		a
	return (
		((t.$$debugValueEditor_debugChannels ?? (t.$$debugValueEditor_debugChannels = {}))[o] = (l) => {
			;(a = e()), (r = l)
			for (let d of n) l.sendNotification(d)
			return (n = []), s
		}),
		Vb.createClient(i, () => {
			if (!a) throw new Error("Not supported")
			return a
		})
	)
}
function iV(o) {
	let e
	return {
		channel: (n) => (
			(e = n),
			{
				sendNotification: (r) => {
					o.sendNotification(r)
				},
				sendRequest: (r) => {
					throw new Error("not supported")
				},
			}
		),
		handler: {
			handleRequest: (n) =>
				n.type === "notification" ? e?.handleNotification(n.data) : e?.handleRequest(n.data),
		},
	}
}
function KP(o, e) {
	let t = o.split(`
`),
		n = -1
	for (let r of t.slice(1)) {
		if ((n++, e && e.test(r))) continue
		let i = sV(r)
		if (i) return i
	}
}
function sV(o) {
	let e = o.match(/\((.*):(\d+):(\d+)\)/)
	if (e) return { fileName: e[1], line: parseInt(e[2]), column: parseInt(e[3]), id: o }
	let t = o.match(/at ([^\(\)]*):(\d+):(\d+)/)
	if (t) return { fileName: t[1], line: parseInt(t[2]), column: parseInt(t[3]), id: o }
}
var Bb = class {
	constructor() {
		this._timeout = void 0
	}
	throttle(e, t) {
		this._timeout === void 0 &&
			(this._timeout = setTimeout(() => {
				;(this._timeout = void 0), e()
			}, t))
	}
	dispose() {
		this._timeout !== void 0 && clearTimeout(this._timeout)
	}
}
function jP(o, e) {
	for (let t in e) o[t] && typeof o[t] == "object" && e[t] && typeof e[t] == "object" ? jP(o[t], e[t]) : (o[t] = e[t])
}
function GP(o, e) {
	for (let t in e)
		e[t] === null
			? delete o[t]
			: o[t] && typeof o[t] == "object" && e[t] && typeof e[t] == "object"
				? GP(o[t], e[t])
				: (o[t] = e[t])
}
var $b = class o {
	constructor() {
		this._declarationId = 0
		this._instanceId = 0
		this._declarations = new Map()
		this._instanceInfos = new WeakMap()
		this._aliveInstances = new Map()
		this._activeTransactions = new Set()
		this._channel = iM("observableDevTools", () => ({
			notifications: {
				setDeclarationIdFilter: (e) => {},
				logObservableValue: (e) => {
					console.log("logObservableValue", e)
				},
				flushUpdates: () => {
					this._flushUpdates()
				},
				resetUpdates: () => {
					;(this._pendingChanges = null), this._channel.api.notifications.handleChange(this._fullState, !0)
				},
			},
			requests: {
				getDeclarations: () => {
					let e = {}
					for (let t of this._declarations.values()) e[t.id] = t
					return { decls: e }
				},
				getSummarizedInstances: () => null,
				getObservableValueInfo: (e) => ({
					observers: [...this._aliveInstances.get(e).debugGetObservers()]
						.map((n) => this._formatObserver(n))
						.filter(rr),
				}),
				getDerivedInfo: (e) => {
					let t = this._aliveInstances.get(e)
					return {
						dependencies: [...t.debugGetState().dependencies]
							.map((n) => this._formatObservable(n))
							.filter(rr),
						observers: [...t.debugGetObservers()].map((n) => this._formatObserver(n)).filter(rr),
					}
				},
				getAutorunInfo: (e) => ({
					dependencies: [...this._aliveInstances.get(e).debugGetState().dependencies]
						.map((n) => this._formatObservable(n))
						.filter(rr),
				}),
				getTransactionState: () => this.getTransactionState(),
				setValue: (e, t) => {
					let n = this._aliveInstances.get(e)
					if (n instanceof Or) n.debugSetValue(t)
					else if (n instanceof ed) n.debugSetValue(t)
					else if (n instanceof fi) n.debugSetValue(t)
					else throw new Gt("Observable is not supported")
					let r = [...n.debugGetObservers()]
					for (let i of r) i.beginUpdate(n)
					for (let i of r) i.handleChange(n, void 0)
					for (let i of r) i.endUpdate(n)
				},
				getValue: (e) => {
					let t = this._aliveInstances.get(e)
					if (t instanceof Or) return gi(t.debugGetState().value, 200)
					if (t instanceof ed) return gi(t.debugGetState().value, 200)
				},
			},
		}))
		this._pendingChanges = null
		this._changeThrottler = new Bb()
		this._fullState = {}
		this._flushUpdates = () => {
			this._pendingChanges !== null &&
				(this._channel.api.notifications.handleChange(this._pendingChanges, !1), (this._pendingChanges = null))
		}
	}
	static {
		this._instance = void 0
	}
	static getInstance() {
		return o._instance === void 0 && (o._instance = new o()), o._instance
	}
	getTransactionState() {
		let e = [],
			t = [...this._activeTransactions]
		if (t.length === 0) return
		let n = t.flatMap((i) => i.debugGetUpdatingObservers() ?? []).map((i) => i.observer),
			r = new Set()
		for (; n.length > 0; ) {
			let i = n.shift()
			if (r.has(i)) continue
			r.add(i)
			let s = this._getInfo(i, (a) => {
				r.has(a) || n.push(a)
			})
			s && e.push(s)
		}
		return { names: t.map((i) => i.getDebugName() ?? "tx"), affected: e }
	}
	_getObservableInfo(e) {
		let t = this._instanceInfos.get(e)
		if (!t) {
			Be(new Gt("No info found"))
			return
		}
		return t
	}
	_getAutorunInfo(e) {
		let t = this._instanceInfos.get(e)
		if (!t) {
			Be(new Gt("No info found"))
			return
		}
		return t
	}
	_getInfo(e, t) {
		if (e instanceof Or) {
			let n = [...e.debugGetObservers()]
			for (let l of n) t(l)
			let r = this._getObservableInfo(e)
			if (!r) return
			let i = e.debugGetState(),
				s = { name: e.debugName, instanceId: r.instanceId, updateCount: i.updateCount },
				a = [...r.changedObservables].map((l) => this._instanceInfos.get(l)?.instanceId).filter(rr)
			if (i.isComputing)
				return {
					...s,
					type: "observable/derived",
					state: "updating",
					changedDependencies: a,
					initialComputation: !1,
				}
			switch (i.state) {
				case 0:
					return { ...s, type: "observable/derived", state: "noValue" }
				case 3:
					return { ...s, type: "observable/derived", state: "upToDate" }
				case 2:
					return { ...s, type: "observable/derived", state: "stale", changedDependencies: a }
				case 1:
					return { ...s, type: "observable/derived", state: "possiblyStale" }
			}
		} else if (e instanceof Gc) {
			let n = this._getAutorunInfo(e)
			if (!n) return
			let r = { name: e.debugName, instanceId: n.instanceId, updateCount: n.updateCount },
				i = [...n.changedObservables].map((s) => this._instanceInfos.get(s).instanceId)
			if (e.debugGetState().isRunning) return { ...r, type: "autorun", state: "updating", changedDependencies: i }
			switch (e.debugGetState().state) {
				case 3:
					return { ...r, type: "autorun", state: "upToDate" }
				case 2:
					return { ...r, type: "autorun", state: "stale", changedDependencies: i }
				case 1:
					return { ...r, type: "autorun", state: "possiblyStale" }
			}
		}
	}
	_formatObservable(e) {
		let t = this._getObservableInfo(e)
		if (t) return { name: e.debugName, instanceId: t.instanceId }
	}
	_formatObserver(e) {
		if (e instanceof Or) return { name: e.toString(), instanceId: this._getObservableInfo(e)?.instanceId }
		let t = this._getAutorunInfo(e)
		if (t) return { name: e.toString(), instanceId: t.instanceId }
	}
	_handleChange(e) {
		GP(this._fullState, e),
			this._pendingChanges === null ? (this._pendingChanges = e) : jP(this._pendingChanges, e),
			this._changeThrottler.throttle(this._flushUpdates, 10)
	}
	_getDeclarationId(e) {
		let t = !0,
			n,
			r = Error
		for (;;) {
			let s = r.stackTraceLimit
			r.stackTraceLimit = t ? 6 : 20
			let a = new Error().stack
			r.stackTraceLimit = s
			let l = KP(a, /[/\\]observableInternal[/\\]|\.observe|[/\\]util(s)?\./)
			if ((!t && !l && (l = KP(a, /[/\\]observableInternal[/\\]|\.observe/)), l)) {
				n = l
				break
			}
			if (!t) {
				console.error("Could not find location for declaration", new Error().stack),
					(n = { fileName: "unknown", line: 0, column: 0, id: "unknown" })
				break
			}
			t = !1
		}
		let i = this._declarations.get(n.id)
		return (
			i === void 0 &&
				((i = { id: this._declarationId++, type: e, url: n.fileName, line: n.line, column: n.column }),
				this._declarations.set(n.id, i),
				this._handleChange({ decls: { [i.id]: i } })),
			i.id
		)
	}
	handleObservableCreated(e) {
		let n = {
			declarationId: this._getDeclarationId("observable/value"),
			instanceId: this._instanceId++,
			listenerCount: 0,
			lastValue: void 0,
			updateCount: 0,
			changedObservables: new Set(),
		}
		this._instanceInfos.set(e, n)
	}
	handleOnListenerCountChanged(e, t) {
		let n = this._getObservableInfo(e)
		if (n) {
			if (n.listenerCount === 0 && t > 0) {
				let r = e instanceof Or ? "observable/derived" : "observable/value"
				this._aliveInstances.set(n.instanceId, e),
					this._handleChange({
						instances: {
							[n.instanceId]: {
								instanceId: n.instanceId,
								declarationId: n.declarationId,
								formattedValue: n.lastValue,
								type: r,
								name: e.debugName,
							},
						},
					})
			} else
				n.listenerCount > 0 &&
					t === 0 &&
					(this._handleChange({ instances: { [n.instanceId]: null } }),
					this._aliveInstances.delete(n.instanceId))
			n.listenerCount = t
		}
	}
	handleObservableUpdated(e, t) {
		if (e instanceof Or) {
			this._handleDerivedRecomputed(e, t)
			return
		}
		let n = this._getObservableInfo(e)
		n &&
			t.didChange &&
			((n.lastValue = gi(t.newValue, 30)),
			n.listenerCount > 0 &&
				this._handleChange({ instances: { [n.instanceId]: { formattedValue: n.lastValue } } }))
	}
	handleAutorunCreated(e) {
		let n = {
			declarationId: this._getDeclarationId("autorun"),
			instanceId: this._instanceId++,
			updateCount: 0,
			changedObservables: new Set(),
		}
		this._instanceInfos.set(e, n),
			this._aliveInstances.set(n.instanceId, e),
			n &&
				this._handleChange({
					instances: {
						[n.instanceId]: {
							instanceId: n.instanceId,
							declarationId: n.declarationId,
							runCount: 0,
							type: "autorun",
							name: e.debugName,
						},
					},
				})
	}
	handleAutorunDisposed(e) {
		let t = this._getAutorunInfo(e)
		t &&
			(this._handleChange({ instances: { [t.instanceId]: null } }),
			this._instanceInfos.delete(e),
			this._aliveInstances.delete(t.instanceId))
	}
	handleAutorunDependencyChanged(e, t, n) {
		let r = this._getAutorunInfo(e)
		r && r.changedObservables.add(t)
	}
	handleAutorunStarted(e) {}
	handleAutorunFinished(e) {
		let t = this._getAutorunInfo(e)
		t &&
			(t.changedObservables.clear(),
			t.updateCount++,
			this._handleChange({ instances: { [t.instanceId]: { runCount: t.updateCount } } }))
	}
	handleDerivedDependencyChanged(e, t, n) {
		let r = this._getObservableInfo(e)
		r && r.changedObservables.add(t)
	}
	_handleDerivedRecomputed(e, t) {
		let n = this._getObservableInfo(e)
		if (!n) return
		let r = gi(t.newValue, 30)
		n.updateCount++,
			n.changedObservables.clear(),
			(n.lastValue = r),
			n.listenerCount > 0 &&
				this._handleChange({
					instances: { [n.instanceId]: { formattedValue: r, recomputationCount: n.updateCount } },
				})
	}
	handleDerivedCleared(e) {
		let t = this._getObservableInfo(e)
		t &&
			((t.lastValue = void 0),
			t.changedObservables.clear(),
			t.listenerCount > 0 && this._handleChange({ instances: { [t.instanceId]: { formattedValue: void 0 } } }))
	}
	handleBeginTransaction(e) {
		this._activeTransactions.add(e)
	}
	handleEndTransaction(e) {
		this._activeTransactions.delete(e)
	}
}
jL(oM)
var aV = !1
aV && Kf(new Qf())
Er && Er.VSCODE_DEV_DEBUG && Kf($b.getInstance())
var Qr = class o {
	constructor(e, t) {
		this.start = e
		this.endExclusive = t
		if (e > t) throw new Gt(`Invalid range: ${this.toString()}`)
	}
	static fromTo(e, t) {
		return new o(e, t)
	}
	static addRange(e, t) {
		let n = 0
		for (; n < t.length && t[n].endExclusive < e.start; ) n++
		let r = n
		for (; r < t.length && t[r].start <= e.endExclusive; ) r++
		if (n === r) t.splice(n, 0, e)
		else {
			let i = Math.min(e.start, t[n].start),
				s = Math.max(e.endExclusive, t[r - 1].endExclusive)
			t.splice(n, r - n, new o(i, s))
		}
	}
	static tryCreate(e, t) {
		if (!(e > t)) return new o(e, t)
	}
	static ofLength(e) {
		return new o(0, e)
	}
	static ofStartAndLength(e, t) {
		return new o(e, e + t)
	}
	static emptyAt(e) {
		return new o(e, e)
	}
	get isEmpty() {
		return this.start === this.endExclusive
	}
	delta(e) {
		return new o(this.start + e, this.endExclusive + e)
	}
	deltaStart(e) {
		return new o(this.start + e, this.endExclusive)
	}
	deltaEnd(e) {
		return new o(this.start, this.endExclusive + e)
	}
	get length() {
		return this.endExclusive - this.start
	}
	toString() {
		return `[${this.start}, ${this.endExclusive})`
	}
	equals(e) {
		return this.start === e.start && this.endExclusive === e.endExclusive
	}
	containsRange(e) {
		return this.start <= e.start && e.endExclusive <= this.endExclusive
	}
	contains(e) {
		return this.start <= e && e < this.endExclusive
	}
	join(e) {
		return new o(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive))
	}
	intersect(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		if (t <= n) return new o(t, n)
	}
	intersectionLength(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return Math.max(0, n - t)
	}
	intersects(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return t < n
	}
	intersectsOrTouches(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return t <= n
	}
	isBefore(e) {
		return this.endExclusive <= e.start
	}
	isAfter(e) {
		return this.start >= e.endExclusive
	}
	slice(e) {
		return e.slice(this.start, this.endExclusive)
	}
	substring(e) {
		return e.substring(this.start, this.endExclusive)
	}
	clip(e) {
		if (this.isEmpty) throw new Gt(`Invalid clipping range: ${this.toString()}`)
		return Math.max(this.start, Math.min(this.endExclusive - 1, e))
	}
	clipCyclic(e) {
		if (this.isEmpty) throw new Gt(`Invalid clipping range: ${this.toString()}`)
		return e < this.start
			? this.endExclusive - ((this.start - e) % this.length)
			: e >= this.endExclusive
				? this.start + ((e - this.start) % this.length)
				: e
	}
	map(e) {
		let t = []
		for (let n = this.start; n < this.endExclusive; n++) t.push(e(n))
		return t
	}
	forEach(e) {
		for (let t = this.start; t < this.endExclusive; t++) e(t)
	}
}
function JP() {
	return Object.create(null)
}
var ms = "**",
	Kb = "/",
	zb = "[/\\\\]",
	qb = "[^/\\\\]",
	lV = /\//g
function sM(o, e) {
	switch (o) {
		case 0:
			return ""
		case 1:
			return `${qb}*?`
		default:
			return `(?:${zb}|${qb}+${zb}${e ? `|${zb}${qb}+` : ""})*?`
	}
}
function rd(o, e) {
	if (!o) return []
	let t = [],
		n = !1,
		r = !1,
		i = ""
	for (let s of o) {
		switch (s) {
			case e:
				if (!n && !r) {
					t.push(i), (i = "")
					continue
				}
				break
			case "{":
				n = !0
				break
			case "}":
				n = !1
				break
			case "[":
				r = !0
				break
			case "]":
				r = !1
				break
		}
		i += s
	}
	return i && t.push(i), t
}
function uM(o) {
	if (!o) return ""
	let e = "",
		t = rd(o, Kb)
	if (t.every((n) => n === ms)) e = ".*"
	else {
		let n = !1
		t.forEach((r, i) => {
			if (r === ms) {
				if (n) return
				e += sM(2, i === t.length - 1)
			} else {
				let s = !1,
					a = "",
					l = !1,
					d = ""
				for (let c of r) {
					if (c !== "}" && s) {
						a += c
						continue
					}
					if (l && (c !== "]" || !d)) {
						let u
						c === "-"
							? (u = c)
							: (c === "^" || c === "!") && !d
								? (u = "^")
								: c === Kb
									? (u = "")
									: (u = _r(c)),
							(d += u)
						continue
					}
					switch (c) {
						case "{":
							s = !0
							continue
						case "[":
							l = !0
							continue
						case "}": {
							let m = `(?:${rd(a, ",")
								.map((f) => uM(f))
								.join("|")})`
							;(e += m), (s = !1), (a = "")
							break
						}
						case "]": {
							;(e += "[" + d + "]"), (l = !1), (d = "")
							break
						}
						case "?":
							e += qb
							continue
						case "*":
							e += sM(1)
							continue
						default:
							e += _r(c)
					}
				}
				i < t.length - 1 && (t[i + 1] !== ms || i + 2 < t.length) && (e += zb)
			}
			n = r === ms
		})
	}
	return e
}
var dV = /^\*\*\/\*\.[\w\.-]+$/,
	cV = /^\*\*\/([\w\.-]+)\/?$/,
	uV = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,
	pV = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,
	mV = /^\*\*((\/[\w\.-]+)+)\/?$/,
	fV = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
	aM = new _o(1e4),
	lM = function () {
		return !1
	},
	hi = function () {
		return null
	}
function XP(o, e) {
	if (!o) return hi
	let t
	typeof o != "string" ? (t = o.pattern) : (t = o), (t = t.trim())
	let n = `${t}_${!!e.trimForExclusions}`,
		r = aM.get(n)
	if (r) return dM(r, o)
	let i
	return (
		dV.test(t)
			? (r = gV(t.substr(4), t))
			: (i = cV.exec(QP(t, e)))
				? (r = hV(i[1], t))
				: (e.trimForExclusions ? pV : uV).test(t)
					? (r = vV(t, e))
					: (i = mV.exec(QP(t, e)))
						? (r = cM(i[1].substr(1), t, !0))
						: (i = fV.exec(QP(t, e)))
							? (r = cM(i[1], t, !1))
							: (r = bV(t)),
		aM.set(n, r),
		dM(r, o)
	)
}
function dM(o, e) {
	if (typeof e == "string") return o
	let t = function (n, r) {
		return zr(n, e.base, !Ve) ? o(cE(n.substr(e.base.length), at), r) : null
	}
	return (
		(t.allBasenames = o.allBasenames),
		(t.allPaths = o.allPaths),
		(t.basenames = o.basenames),
		(t.patterns = o.patterns),
		t
	)
}
function QP(o, e) {
	return e.trimForExclusions && o.endsWith("/**") ? o.substr(0, o.length - 2) : o
}
function gV(o, e) {
	return function (t, n) {
		return typeof t == "string" && t.endsWith(o) ? e : null
	}
}
function hV(o, e) {
	let t = `/${o}`,
		n = `\\${o}`,
		r = function (s, a) {
			return typeof s != "string"
				? null
				: a
					? a === o
						? e
						: null
					: s === o || s.endsWith(t) || s.endsWith(n)
						? e
						: null
		},
		i = [o]
	return (r.basenames = i), (r.patterns = [e]), (r.allBasenames = i), r
}
function vV(o, e) {
	let t = mM(
			o
				.slice(1, -1)
				.split(",")
				.map((a) => XP(a, e))
				.filter((a) => a !== hi),
			o,
		),
		n = t.length
	if (!n) return hi
	if (n === 1) return t[0]
	let r = function (a, l) {
			for (let d = 0, c = t.length; d < c; d++) if (t[d](a, l)) return o
			return null
		},
		i = t.find((a) => !!a.allBasenames)
	i && (r.allBasenames = i.allBasenames)
	let s = t.reduce((a, l) => (l.allPaths ? a.concat(l.allPaths) : a), [])
	return s.length && (r.allPaths = s), r
}
function cM(o, e, t) {
	let n = at === Ue.sep,
		r = n ? o : o.replace(lV, at),
		i = at + r,
		s = Ue.sep + o,
		a
	return (
		t
			? (a = function (l, d) {
					return typeof l == "string" && (l === r || l.endsWith(i) || (!n && (l === o || l.endsWith(s))))
						? e
						: null
				})
			: (a = function (l, d) {
					return typeof l == "string" && (l === r || (!n && l === o)) ? e : null
				}),
		(a.allPaths = [(t ? "*/" : "./") + o]),
		a
	)
}
function bV(o) {
	try {
		let e = new RegExp(`^${uM(o)}$`)
		return function (t) {
			return (e.lastIndex = 0), typeof t == "string" && e.test(t) ? o : null
		}
	} catch {
		return hi
	}
}
function vi(o, e, t) {
	return !o || typeof e != "string" ? !1 : Xn(o)(e, void 0, t)
}
function Xn(o, e = {}) {
	if (!o) return lM
	if (typeof o == "string" || pM(o)) {
		let t = XP(o, e)
		if (t === hi) return lM
		let n = function (r, i) {
			return !!t(r, i)
		}
		return t.allBasenames && (n.allBasenames = t.allBasenames), t.allPaths && (n.allPaths = t.allPaths), n
	}
	return yV(o, e)
}
function pM(o) {
	let e = o
	return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1
}
function YP(o) {
	return o.allBasenames || []
}
function ZP(o) {
	return o.allPaths || []
}
function yV(o, e) {
	let t = mM(
			Object.getOwnPropertyNames(o)
				.map((a) => IV(a, o[a], e))
				.filter((a) => a !== hi),
		),
		n = t.length
	if (!n) return hi
	if (!t.some((a) => !!a.requiresSiblings)) {
		if (n === 1) return t[0]
		let a = function (c, u) {
				let m
				for (let f = 0, h = t.length; f < h; f++) {
					let g = t[f](c, u)
					if (typeof g == "string") return g
					io(g) && (m || (m = []), m.push(g))
				}
				return m
					? (async () => {
							for (let f of m) {
								let h = await f
								if (typeof h == "string") return h
							}
							return null
						})()
					: null
			},
			l = t.find((c) => !!c.allBasenames)
		l && (a.allBasenames = l.allBasenames)
		let d = t.reduce((c, u) => (u.allPaths ? c.concat(u.allPaths) : c), [])
		return d.length && (a.allPaths = d), a
	}
	let r = function (a, l, d) {
			let c, u
			for (let m = 0, f = t.length; m < f; m++) {
				let h = t[m]
				h.requiresSiblings && d && (l || (l = Ze(a)), c || (c = l.substr(0, l.length - ra(a).length)))
				let g = h(a, l, c, d)
				if (typeof g == "string") return g
				io(g) && (u || (u = []), u.push(g))
			}
			return u
				? (async () => {
						for (let m of u) {
							let f = await m
							if (typeof f == "string") return f
						}
						return null
					})()
				: null
		},
		i = t.find((a) => !!a.allBasenames)
	i && (r.allBasenames = i.allBasenames)
	let s = t.reduce((a, l) => (l.allPaths ? a.concat(l.allPaths) : a), [])
	return s.length && (r.allPaths = s), r
}
function IV(o, e, t) {
	if (e === !1) return hi
	let n = XP(o, t)
	if (n === hi) return hi
	if (typeof e == "boolean") return n
	if (e) {
		let r = e.when
		if (typeof r == "string") {
			let i = (s, a, l, d) => {
				if (!d || !n(s, a)) return null
				let c = r.replace("$(basename)", () => l),
					u = d(c)
				return io(u) ? u.then((m) => (m ? o : null)) : u ? o : null
			}
			return (i.requiresSiblings = !0), i
		}
	}
	return n
}
function mM(o, e) {
	let t = o.filter((a) => !!a.basenames)
	if (t.length < 2) return o
	let n = t.reduce((a, l) => {
			let d = l.basenames
			return d ? a.concat(d) : a
		}, []),
		r
	if (e) {
		r = []
		for (let a = 0, l = n.length; a < l; a++) r.push(e)
	} else
		r = t.reduce((a, l) => {
			let d = l.patterns
			return d ? a.concat(d) : a
		}, [])
	let i = function (a, l) {
		if (typeof a != "string") return null
		if (!l) {
			let c
			for (c = a.length; c > 0; c--) {
				let u = a.charCodeAt(c - 1)
				if (u === 47 || u === 92) break
			}
			l = a.substr(c)
		}
		let d = n.indexOf(l)
		return d !== -1 ? r[d] : null
	}
	;(i.basenames = n), (i.patterns = r), (i.allBasenames = n)
	let s = o.filter((a) => !a.basenames)
	return s.push(i), s
}
function e_(o, e) {
	return mn(o, e, (t, n) =>
		typeof t == "string" && typeof n == "string"
			? t === n
			: typeof t != "string" && typeof n != "string"
				? t.base === n.base && t.pattern === n.pattern
				: !1,
	)
}
var xV = O("notebookDocumentService"),
	t_ = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"],
	CV = new RegExp(`^[${t_.join("")}]+`),
	gM = 7
function jb(o) {
	if (o.scheme !== W.vscodeNotebookCell) return
	let e = o.fragment.indexOf("s")
	if (e < 0) return
	let t = parseInt(o.fragment.substring(0, e).replace(CV, ""), gM),
		n = wc(o.fragment.substring(e + 1)).toString()
	if (!isNaN(t)) return { handle: t, notebook: o.with({ scheme: n, fragment: null }) }
}
function hM(o, e) {
	let t = e.toString(gM),
		r = `${t.length < t_.length ? t_[t.length - 1] : "z"}${t}s${Ol(z.fromString(o.scheme), !0, !0)}`
	return o.with({ scheme: W.vscodeNotebookCell, fragment: r })
}
function vM(o) {
	if (o.scheme !== W.vscodeNotebookMetadata) return
	let e = wc(o.fragment).toString()
	return o.with({ scheme: e, fragment: null })
}
function bM(o) {
	let e = `${Ol(z.fromString(o.scheme), !0, !0)}`
	return o.with({ scheme: W.vscodeNotebookMetadata, fragment: e })
}
function r_(o) {
	if (o.scheme !== W.vscodeNotebookCellOutput) return
	let e = new URLSearchParams(o.query),
		t = e.get("openIn")
	if (!t) return
	let n = e.get("outputId") ?? void 0,
		r = jb(o.with({ scheme: W.vscodeNotebookCell, query: null })),
		i = e.get("outputIndex") ? parseInt(e.get("outputIndex") || "", 10) : void 0
	return {
		notebook: r ? r.notebook : o.with({ scheme: e.get("notebookScheme") || W.file, fragment: null, query: null }),
		openIn: t,
		outputId: n,
		outputIndex: i,
		cellHandle: r?.handle,
		cellFragment: o.fragment,
	}
}
var n_ = class {
	constructor() {
		this._documents = new ft()
	}
	getNotebook(e) {
		if (e.scheme === W.vscodeNotebookCell) {
			let t = jb(e)
			if (t) {
				let n = this._documents.get(t.notebook)
				if (n) return n
			}
		}
		if (e.scheme === W.vscodeNotebookCellOutput) {
			let t = r_(e)
			if (t) {
				let n = this._documents.get(t.notebook)
				if (n) return n
			}
		}
		return this._documents.get(e)
	}
	addNotebookDocument(e) {
		this._documents.set(e.uri, e)
	}
	removeNotebookDocument(e) {
		this._documents.delete(e.uri)
	}
}
Ke(xV, n_, 1)
var nte = [
		"application/json",
		"application/javascript",
		"text/html",
		"image/svg+xml",
		po.latex,
		po.markdown,
		"image/png",
		"image/jpeg",
		po.text,
	],
	rte = [po.latex, po.markdown, "application/json", "text/html", "image/svg+xml", "image/png", "image/jpeg", po.text]
var SV
;((n) => {
	n.scheme = W.vscodeNotebookMetadata
	function e(r) {
		return bM(r)
	}
	n.generate = e
	function t(r) {
		return vM(r)
	}
	n.parse = t
})((SV ||= {}))
var Jf
;((l) => {
	l.scheme = W.vscodeNotebookCell
	function e(d, c) {
		return hM(d, c)
	}
	l.generate = e
	function t(d) {
		return jb(d)
	}
	l.parse = t
	function n(d, c) {
		return d.with({
			scheme: W.vscodeNotebookCellOutput,
			query: new URLSearchParams({
				openIn: "editor",
				outputId: c ?? "",
				notebookScheme: d.scheme !== W.file ? d.scheme : "",
			}).toString(),
		})
	}
	l.generateCellOutputUriWithId = n
	function r(d, c, u) {
		return d.with({
			scheme: W.vscodeNotebookCellOutput,
			fragment: c.fragment,
			query: new URLSearchParams({ openIn: "notebook", outputIndex: String(u) }).toString(),
		})
	}
	l.generateCellOutputUriWithIndex = r
	function i(d) {
		return r_(d)
	}
	l.parseCellOutputUri = i
	function s(d, c, u) {
		return l.generate(d, c).with({ scheme: u })
	}
	l.generateCellPropertyUri = s
	function a(d, c) {
		if (d.scheme === c) return l.parse(d.with({ scheme: l.scheme }))
	}
	l.parseCellPropertyUri = a
})((Jf ||= {}))
var ote = new D("notebookEditorCursorAtBoundary", "none"),
	ite = new D("notebookEditorCursorAtLineBoundary", "none")
var yM = class o {
	static {
		this._prefix = "notebook/"
	}
	static create(e, t) {
		return `${o._prefix}${e}/${t ?? e}`
	}
	static parse(e) {
		if (e.startsWith(o._prefix)) {
			let t = e.substring(o._prefix.length).split("/")
			if (t.length === 2) return { notebookType: t[0], viewType: t[1] }
		}
	}
}
function Qb(o) {
	return ["application/vnd.code.notebook.stdout", "application/vnd.code.notebook.stderr"].includes(o)
}
var TV = new TextDecoder()
function IM(o) {
	let e = [],
		t = !1
	for (let s of o) (e.length === 0 || t) && (e.push(s), (t = !0))
	let n = wV(e),
		r = z.concat(e.map((s) => z.wrap(s))),
		i = RV(r)
	return (n = n || i.byteLength !== r.byteLength), { data: i, didCompression: n }
}
var Gb = "\x1B[A",
	o_ = Gb.split("").map((o) => o.charCodeAt(0)),
	EV = 10
function wV(o) {
	let e = !1
	return (
		o.forEach((t, n) => {
			if (n === 0 || t.length < Gb.length) return
			let r = o[n - 1],
				i = t.subarray(0, Gb.length)
			if (i[0] === o_[0] && i[1] === o_[1] && i[2] === o_[2]) {
				let s = r.lastIndexOf(EV)
				if (s === -1) return
				;(e = !0), (o[n - 1] = r.subarray(0, s)), (o[n] = t.subarray(Gb.length))
			}
		}),
		e
	)
}
function PV(o) {
	let e = o
	do (o = e), (e = o.replace(/[^\n]\x08/gm, ""))
	while (e.length < o.length)
	return o
}
function _V(o) {
	for (
		o = o.replace(
			/\r+\n/gm,
			`
`,
		);
		o.search(/\r[^$]/g) > -1;

	) {
		let e = o.match(/^(.*)\r+/m)[1],
			t = o.match(/\r+(.*)$/m)[1]
		;(t = t + e.slice(t.length, e.length)), (o = o.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, t))
	}
	return o
}
var DV = 8,
	kV = 13
function RV(o) {
	return !o.buffer.includes(DV) && !o.buffer.includes(kV) ? o : z.fromString(_V(PV(TV.decode(o.buffer))))
}
var Yc = O("productService"),
	CM = "vscode://schemas/vscode-product"
var vr = O("configurationService")
function Jb(o, e) {
	let t = Object.create(null)
	for (let n in o) i_(t, n, o[n], e)
	return t
}
function i_(o, e, t, n) {
	let r = e.split("."),
		i = r.pop(),
		s = o
	for (let a = 0; a < r.length; a++) {
		let l = r[a],
			d = s[l]
		switch (typeof d) {
			case "undefined":
				d = s[l] = Object.create(null)
				break
			case "object":
				if (d === null) {
					n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is null`)
					return
				}
				break
			default:
				n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(d)}`)
				return
		}
		s = d
	}
	if (typeof s == "object" && s !== null)
		try {
			s[i] = t
		} catch {
			n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`)
		}
	else n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`)
}
function SM(o, e) {
	let t = e.split(".")
	TM(o, t)
}
function TM(o, e) {
	if (!o) return
	let t = e.shift()
	if (e.length === 0) {
		delete o[t]
		return
	}
	if (Object.keys(o).indexOf(t) !== -1) {
		let n = o[t]
		typeof n == "object" && !Array.isArray(n) && (TM(n, e), Object.keys(n).length === 0 && delete o[t])
	}
}
function Xf(o, e, t) {
	function n(s, a) {
		let l = s
		for (let d of a) {
			if (typeof l != "object" || l === null) return
			l = l[d]
		}
		return l
	}
	let r = e.split("."),
		i = n(o, r)
	return typeof i > "u" ? t : i
}
function EM(o) {
	return o.replace(/[\[\]]/g, "")
}
function wM(o) {
	let e = !1,
		t = new Map(),
		n = new Map()
	if (
		(AV(o, (c) => {
			if (o === c) return !0
			let u = JSON.stringify(c)
			if (u.length < 30) return !0
			let m = t.get(u)
			if (!m) {
				let f = { schemas: [c] }
				return t.set(u, f), n.set(c, f), !0
			}
			return m.schemas.push(c), n.set(c, m), (e = !0), !1
		}),
		t.clear(),
		!e)
	)
		return JSON.stringify(o)
	let i = "$defs"
	for (; o.hasOwnProperty(i); ) i += "_"
	let s = []
	function a(c) {
		return JSON.stringify(c, (u, m) => {
			if (m !== c) {
				let f = n.get(m)
				if (f && f.schemas.length > 1)
					return f.id || ((f.id = `_${s.length}`), s.push(f.schemas[0])), { $ref: `#/${i}/${f.id}` }
			}
			return m
		})
	}
	let l = a(o),
		d = []
	for (let c = 0; c < s.length; c++) d.push(`"_${c}":${a(s[c])}`)
	return d.length ? `${l.substring(0, l.length - 1)},"${i}":{${d.join(",")}}}` : l
}
function Zc(o) {
	return typeof o == "object" && o !== null
}
function AV(o, e) {
	if (!o || typeof o != "object") return
	let t = (...l) => {
			for (let d of l) Zc(d) && s.push(d)
		},
		n = (...l) => {
			for (let d of l)
				if (Zc(d))
					for (let c in d) {
						let u = d[c]
						Zc(u) && s.push(u)
					}
		},
		r = (...l) => {
			for (let d of l) if (Array.isArray(d)) for (let c of d) Zc(c) && s.push(c)
		},
		i = (l) => {
			if (Array.isArray(l)) for (let d of l) Zc(d) && s.push(d)
			else Zc(l) && s.push(l)
		},
		s = [o],
		a = s.pop()
	for (; a; )
		e(a) &&
			(t(
				a.additionalItems,
				a.additionalProperties,
				a.not,
				a.contains,
				a.propertyNames,
				a.if,
				a.then,
				a.else,
				a.unevaluatedItems,
				a.unevaluatedProperties,
			),
			n(a.definitions, a.$defs, a.properties, a.patternProperties, a.dependencies, a.dependentSchemas),
			r(a.anyOf, a.allOf, a.oneOf, a.prefixItems),
			i(a.items)),
			(a = s.pop())
}
var od = { JSONContribution: "base.contributions.json" }
function PM(o) {
	return o.length > 0 && o.charAt(o.length - 1) === "#" ? o.substring(0, o.length - 1) : o
}
var s_ = class {
		constructor() {
			this.schemasById = {}
			this.schemaAssociations = {}
			this._onDidChangeSchema = new E()
			this.onDidChangeSchema = this._onDidChangeSchema.event
			this._onDidChangeSchemaAssociations = new E()
			this.onDidChangeSchemaAssociations = this._onDidChangeSchemaAssociations.event
		}
		registerSchema(e, t, n) {
			let r = PM(e)
			;(this.schemasById[r] = t),
				this._onDidChangeSchema.fire(e),
				n &&
					n.add(
						q(() => {
							delete this.schemasById[r], this._onDidChangeSchema.fire(e)
						}),
					)
		}
		registerSchemaAssociation(e, t) {
			let n = PM(e)
			return (
				this.schemaAssociations[n] || (this.schemaAssociations[n] = []),
				this.schemaAssociations[n].includes(t) ||
					(this.schemaAssociations[n].push(t), this._onDidChangeSchemaAssociations.fire()),
				q(() => {
					let r = this.schemaAssociations[n]
					if (r) {
						let i = r.indexOf(t)
						i !== -1 &&
							(r.splice(i, 1),
							r.length === 0 && delete this.schemaAssociations[n],
							this._onDidChangeSchemaAssociations.fire())
					}
				})
			)
		}
		notifySchemaChanged(e) {
			this._onDidChangeSchema.fire(e)
		}
		getSchemaContributions() {
			return { schemas: this.schemasById }
		}
		getSchemaContent(e) {
			let t = this.schemasById[e]
			return t ? wM(t) : void 0
		}
		hasSchemaContent(e) {
			return !!this.schemasById[e]
		}
		getSchemaAssociations() {
			return this.schemaAssociations
		}
	},
	OV = new s_()
yt.add(od.JSONContribution, OV)
var go = { Configuration: "base.contributions.configuration" }
var Xb = { properties: {}, patternProperties: {} },
	Yb = { properties: {}, patternProperties: {} },
	Zb = { properties: {}, patternProperties: {} },
	ey = { properties: {}, patternProperties: {} },
	ty = { properties: {}, patternProperties: {} },
	ny = { properties: {}, patternProperties: {} },
	Yf = { properties: {}, patternProperties: {} },
	id = "vscode://schemas/settings/resourceLanguage"
var ry = yt.as(od.JSONContribution),
	a_ = class {
		constructor() {
			this.registeredConfigurationDefaults = []
			this.overrideIdentifiers = new Set()
			this._onDidSchemaChange = new E()
			this.onDidSchemaChange = this._onDidSchemaChange.event
			this._onDidUpdateConfiguration = new E()
			this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event
			;(this.configurationDefaultsOverrides = new Map()),
				(this.defaultLanguageConfigurationOverridesNode = {
					id: "defaultOverrides",
					title: p("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
					properties: {},
				}),
				(this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode]),
				(this.resourceLanguageSettingsSchema = {
					properties: {},
					patternProperties: {},
					additionalProperties: !0,
					allowTrailingCommas: !0,
					allowComments: !0,
				}),
				(this.configurationProperties = {}),
				(this.policyConfigurations = new Map()),
				(this.excludedConfigurationProperties = {}),
				ry.registerSchema(id, this.resourceLanguageSettingsSchema),
				this.registerOverridePropertyPatternKey()
		}
		registerConfiguration(e, t = !0) {
			return this.registerConfigurations([e], t), e
		}
		registerConfigurations(e, t = !0) {
			let n = new Set()
			this.doRegisterConfigurations(e, t, n),
				ry.registerSchema(id, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n })
		}
		deregisterConfigurations(e) {
			let t = new Set()
			this.doDeregisterConfigurations(e, t),
				ry.registerSchema(id, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t })
		}
		updateConfigurations({ add: e, remove: t }) {
			let n = new Set()
			this.doDeregisterConfigurations(t, n),
				this.doRegisterConfigurations(e, !1, n),
				ry.registerSchema(id, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n })
		}
		registerDefaultConfigurations(e) {
			let t = new Set()
			this.doRegisterDefaultConfigurations(e, t),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 })
		}
		doRegisterDefaultConfigurations(e, t) {
			this.registeredConfigurationDefaults.push(...e)
			let n = []
			for (let { overrides: r, source: i } of e)
				for (let s in r) {
					t.add(s)
					let a =
							this.configurationDefaultsOverrides.get(s) ??
							this.configurationDefaultsOverrides.set(s, { configurationDefaultOverrides: [] }).get(s),
						l = r[s]
					if ((a.configurationDefaultOverrides.push({ value: l, source: i }), fo.test(s))) {
						let d = this.mergeDefaultConfigurationsForOverrideIdentifier(
							s,
							l,
							i,
							a.configurationDefaultOverrideValue,
						)
						if (!d) continue
						;(a.configurationDefaultOverrideValue = d),
							this.updateDefaultOverrideProperty(s, d, i),
							n.push(...eu(s))
					} else {
						let d = this.mergeDefaultConfigurationsForConfigurationProperty(
							s,
							l,
							i,
							a.configurationDefaultOverrideValue,
						)
						if (!d) continue
						a.configurationDefaultOverrideValue = d
						let c = this.configurationProperties[s]
						c && (this.updatePropertyDefaultValue(s, c), this.updateSchema(s, c))
					}
				}
			this.doRegisterOverrideIdentifiers(n)
		}
		deregisterDefaultConfigurations(e) {
			let t = new Set()
			this.doDeregisterDefaultConfigurations(e, t),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 })
		}
		doDeregisterDefaultConfigurations(e, t) {
			for (let n of e) {
				let r = this.registeredConfigurationDefaults.indexOf(n)
				r !== -1 && this.registeredConfigurationDefaults.splice(r, 1)
			}
			for (let { overrides: n, source: r } of e)
				for (let i in n) {
					let s = this.configurationDefaultsOverrides.get(i)
					if (!s) continue
					let a = s.configurationDefaultOverrides.findIndex((l) =>
						r ? l.source?.id === r.id : l.value === n[i],
					)
					if (a !== -1) {
						if (
							(s.configurationDefaultOverrides.splice(a, 1),
							s.configurationDefaultOverrides.length === 0 &&
								this.configurationDefaultsOverrides.delete(i),
							fo.test(i))
						) {
							let l
							for (let d of s.configurationDefaultOverrides)
								l = this.mergeDefaultConfigurationsForOverrideIdentifier(i, d.value, d.source, l)
							l && !Yh(l.value)
								? ((s.configurationDefaultOverrideValue = l),
									this.updateDefaultOverrideProperty(i, l, r))
								: (this.configurationDefaultsOverrides.delete(i),
									delete this.configurationProperties[i],
									delete this.defaultLanguageConfigurationOverridesNode.properties[i])
						} else {
							let l
							for (let c of s.configurationDefaultOverrides)
								l = this.mergeDefaultConfigurationsForConfigurationProperty(i, c.value, c.source, l)
							s.configurationDefaultOverrideValue = l
							let d = this.configurationProperties[i]
							d && (this.updatePropertyDefaultValue(i, d), this.updateSchema(i, d))
						}
						t.add(i)
					}
				}
			this.updateOverridePropertyPatternKey()
		}
		updateDefaultOverrideProperty(e, t, n) {
			let r = {
				type: "object",
				default: t.value,
				description: p(
					"defaultLanguageConfiguration.description",
					"Configure settings to be overridden for the {0} language.",
					EM(e),
				),
				$ref: id,
				defaultDefaultValue: t.value,
				source: n,
				defaultValueSource: n,
			}
			;(this.configurationProperties[e] = r), (this.defaultLanguageConfigurationOverridesNode.properties[e] = r)
		}
		mergeDefaultConfigurationsForOverrideIdentifier(e, t, n, r) {
			let i = r?.value || {},
				s = r?.source ?? new Map()
			if (!(s instanceof Map)) {
				console.error("objectConfigurationSources is not a Map")
				return
			}
			for (let a of Object.keys(t)) {
				let l = t[a]
				if (dt(l) && (mc(i[a]) || dt(i[a]))) {
					if (((i[a] = { ...(i[a] ?? {}), ...l }), n)) for (let c in l) s.set(`${a}.${c}`, n)
				} else (i[a] = l), n ? s.set(a, n) : s.delete(a)
			}
			return { value: i, source: s }
		}
		mergeDefaultConfigurationsForConfigurationProperty(e, t, n, r) {
			let i = this.configurationProperties[e],
				s = r?.value ?? i?.defaultDefaultValue,
				a = n
			if (dt(t) && ((i !== void 0 && i.type === "object") || (i === void 0 && (mc(s) || dt(s))))) {
				if (((a = r?.source ?? new Map()), !(a instanceof Map))) {
					console.error("defaultValueSource is not a Map")
					return
				}
				for (let d in t) n && a.set(`${e}.${d}`, n)
				t = { ...(dt(s) ? s : {}), ...t }
			}
			return { value: t, source: a }
		}
		deltaConfiguration(e) {
			let t = !1,
				n = new Set()
			e.removedDefaults && (this.doDeregisterDefaultConfigurations(e.removedDefaults, n), (t = !0)),
				e.addedDefaults && (this.doRegisterDefaultConfigurations(e.addedDefaults, n), (t = !0)),
				e.removedConfigurations && this.doDeregisterConfigurations(e.removedConfigurations, n),
				e.addedConfigurations && this.doRegisterConfigurations(e.addedConfigurations, !1, n),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n, defaultsOverrides: t })
		}
		notifyConfigurationSchemaUpdated(...e) {
			this._onDidSchemaChange.fire()
		}
		registerOverrideIdentifiers(e) {
			this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire()
		}
		doRegisterOverrideIdentifiers(e) {
			for (let t of e) this.overrideIdentifiers.add(t)
			this.updateOverridePropertyPatternKey()
		}
		doRegisterConfigurations(e, t, n) {
			e.forEach((r) => {
				this.validateAndRegisterProperties(r, t, r.extensionInfo, r.restrictedProperties, void 0, n),
					this.configurationContributors.push(r),
					this.registerJSONConfiguration(r)
			})
		}
		doDeregisterConfigurations(e, t) {
			let n = (r) => {
				if (r.properties)
					for (let i in r.properties) {
						t.add(i)
						let s = this.configurationProperties[i]
						s?.policy?.name && this.policyConfigurations.delete(s.policy.name),
							delete this.configurationProperties[i],
							this.removeFromSchema(i, r.properties[i])
					}
				r.allOf?.forEach((i) => n(i))
			}
			for (let r of e) {
				n(r)
				let i = this.configurationContributors.indexOf(r)
				i !== -1 && this.configurationContributors.splice(i, 1)
			}
		}
		validateAndRegisterProperties(e, t = !0, n, r, i = 4, s) {
			i = bt(e.scope) ? i : e.scope
			let a = e.properties
			if (a)
				for (let d in a) {
					let c = a[d]
					if (t && MV(d, c)) {
						delete a[d]
						continue
					}
					;(c.source = n),
						(c.defaultDefaultValue = a[d].default),
						this.updatePropertyDefaultValue(d, c),
						fo.test(d)
							? (c.scope = void 0)
							: ((c.scope = bt(c.scope) ? i : c.scope),
								(c.restricted = bt(c.restricted) ? !!r?.includes(d) : c.restricted))
					let u = a[d].hasOwnProperty("included") && !a[d].included,
						m = a[d].policy?.name
					u
						? ((this.excludedConfigurationProperties[d] = a[d]),
							m && (this.policyConfigurations.set(m, d), s.add(d)),
							delete a[d])
						: (s.add(d),
							m && this.policyConfigurations.set(m, d),
							(this.configurationProperties[d] = a[d]),
							!a[d].deprecationMessage &&
								a[d].markdownDeprecationMessage &&
								(a[d].deprecationMessage = a[d].markdownDeprecationMessage))
				}
			let l = e.allOf
			if (l) for (let d of l) this.validateAndRegisterProperties(d, t, n, r, i, s)
		}
		getConfigurations() {
			return this.configurationContributors
		}
		getConfigurationProperties() {
			return this.configurationProperties
		}
		getPolicyConfigurations() {
			return this.policyConfigurations
		}
		getExcludedConfigurationProperties() {
			return this.excludedConfigurationProperties
		}
		getRegisteredDefaultConfigurations() {
			return [...this.registeredConfigurationDefaults]
		}
		getConfigurationDefaultsOverrides() {
			let e = new Map()
			for (let [t, n] of this.configurationDefaultsOverrides)
				n.configurationDefaultOverrideValue && e.set(t, n.configurationDefaultOverrideValue)
			return e
		}
		registerJSONConfiguration(e) {
			let t = (n) => {
				let r = n.properties
				if (r) for (let s in r) this.updateSchema(s, r[s])
				n.allOf?.forEach(t)
			}
			t(e)
		}
		updateSchema(e, t) {
			switch (((Xb.properties[e] = t), t.scope)) {
				case 1:
					Yb.properties[e] = t
					break
				case 2:
					ey.properties[e] = t
					break
				case 3:
					Zb.properties[e] = t
					break
				case 7:
					ty.properties[e] = t
					break
				case 4:
					ny.properties[e] = t
					break
				case 5:
					Yf.properties[e] = t
					break
				case 6:
					;(Yf.properties[e] = t), (this.resourceLanguageSettingsSchema.properties[e] = t)
					break
			}
		}
		removeFromSchema(e, t) {
			switch ((delete Xb.properties[e], t.scope)) {
				case 1:
					delete Yb.properties[e]
					break
				case 2:
					delete ey.properties[e]
					break
				case 3:
					delete Zb.properties[e]
					break
				case 7:
					delete ty.properties[e]
					break
				case 4:
					delete ny.properties[e]
					break
				case 5:
				case 6:
					delete Yf.properties[e], delete this.resourceLanguageSettingsSchema.properties[e]
					break
			}
		}
		updateOverridePropertyPatternKey() {
			for (let e of this.overrideIdentifiers.values()) {
				let t = `[${e}]`,
					n = {
						type: "object",
						description: p(
							"overrideSettings.defaultDescription",
							"Configure editor settings to be overridden for a language.",
						),
						errorMessage: p(
							"overrideSettings.errorMessage",
							"This setting does not support per-language configuration.",
						),
						$ref: id,
					}
				this.updatePropertyDefaultValue(t, n),
					(Xb.properties[t] = n),
					(Yb.properties[t] = n),
					(Zb.properties[t] = n),
					(ey.properties[t] = n),
					(ty.properties[t] = n),
					(ny.properties[t] = n),
					(Yf.properties[t] = n)
			}
		}
		registerOverridePropertyPatternKey() {
			let e = {
				type: "object",
				description: p(
					"overrideSettings.defaultDescription",
					"Configure editor settings to be overridden for a language.",
				),
				errorMessage: p(
					"overrideSettings.errorMessage",
					"This setting does not support per-language configuration.",
				),
				$ref: id,
			}
			;(Xb.patternProperties[ya] = e),
				(Yb.patternProperties[ya] = e),
				(Zb.patternProperties[ya] = e),
				(ey.patternProperties[ya] = e),
				(ty.patternProperties[ya] = e),
				(ny.patternProperties[ya] = e),
				(Yf.patternProperties[ya] = e),
				this._onDidSchemaChange.fire()
		}
		updatePropertyDefaultValue(e, t) {
			let n = this.configurationDefaultsOverrides.get(e)?.configurationDefaultOverrideValue,
				r,
				i
			n && (!t.disallowConfigurationDefault || !n.source) && ((r = n.value), (i = n.source)),
				mc(r) && ((r = t.defaultDefaultValue), (i = void 0)),
				mc(r) && (r = LV(t.type)),
				(t.default = r),
				(t.defaultValueSource = i)
		}
	},
	DM = "\\[([^\\]]+)\\]",
	_M = new RegExp(DM, "g"),
	ya = `^(${DM})+$`,
	fo = new RegExp(ya)
function eu(o) {
	let e = []
	if (fo.test(o)) {
		let t = _M.exec(o)
		for (; t?.length; ) {
			let n = t[1].trim()
			n && e.push(n), (t = _M.exec(o))
		}
	}
	return oi(e)
}
function LV(o) {
	switch (Array.isArray(o) ? o[0] : o) {
		case "boolean":
			return !1
		case "integer":
		case "number":
			return 0
		case "string":
			return ""
		case "array":
			return []
		case "object":
			return {}
		default:
			return null
	}
}
var oy = new a_()
yt.add(go.Configuration, oy)
function MV(o, e) {
	return o.trim()
		? fo.test(o)
			? p(
					"config.property.languageDefault",
					"Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.",
					o,
				)
			: oy.getConfigurationProperties()[o] !== void 0
				? p("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", o)
				: e.policy?.name && oy.getPolicyConfigurations().get(e.policy?.name) !== void 0
					? p(
							"config.policy.duplicate",
							"Cannot register '{0}'. The associated policy {1} is already registered with {2}.",
							o,
							e.policy?.name,
							oy.getPolicyConfigurations().get(e.policy?.name),
						)
					: null
		: p("config.property.empty", "Cannot register an empty property")
}
var AM = O("requestService"),
	d_ = class {
		constructor(e) {
			this.original = e
		}
		toJSON() {
			if (!this.headers) {
				let e = Object.create(null)
				for (let t in this.original)
					t.toLowerCase() === "authorization" || t.toLowerCase() === "proxy-authorization"
						? (e[t] = "*****")
						: (e[t] = this.original[t])
				this.headers = e
			}
			return this.headers
		}
	},
	iy = class extends $ {
		constructor(t) {
			super()
			this.logService = t
			this.counter = 0
		}
		async logAndRequest(t, n) {
			let r = `#${++this.counter}: ${t.url}`
			this.logService.trace(`${r} - begin`, t.type, new d_(t.headers ?? {}))
			try {
				let i = await n()
				return this.logService.trace(`${r} - end`, t.type, i.res.statusCode, i.res.headers), i
			} catch (i) {
				throw (this.logService.error(`${r} - error`, t.type, Gm(i)), i)
			}
		}
	}
function FV(o) {
	return (o.res.statusCode && o.res.statusCode >= 200 && o.res.statusCode < 300) || o.res.statusCode === 1223
}
function NV(o) {
	return o.res.statusCode === 204
}
async function OM(o) {
	if (!FV(o)) throw new Error("Server returned " + o.res.statusCode)
	if (NV(o)) return null
	let t = (await XA(o.stream)).toString()
	try {
		return JSON.parse(t)
	} catch (n) {
		throw (
			((n.message +=
				`:
` + t),
			n)
		)
	}
}
var l_ = [],
	kM,
	RM
function UV(o = !0, e = !0) {
	if (kM === o && RM === e) return
	;(kM = o), (RM = e)
	let t = yt.as(go.Configuration),
		n = l_
	;(l_ = [
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: 2,
			properties: {
				"http.useLocalProxyConfiguration": {
					type: "boolean",
					default: e,
					markdownDescription: p(
						"useLocalProxy",
						"Controls whether in the remote extension host the local proxy configuration should be used. This setting only applies as a remote setting during [remote development](https://aka.ms/vscode-remote).",
					),
					restricted: !0,
				},
			},
		},
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: 1,
			properties: {
				"http.electronFetch": {
					type: "boolean",
					default: !1,
					description: p(
						"electronFetch",
						"Controls whether use of Electron's fetch implementation instead of Node.js' should be enabled. All local extensions will get Electron's fetch implementation for the global fetch API.",
					),
					restricted: !0,
				},
			},
		},
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: o ? 1 : 2,
			properties: {
				"http.proxy": {
					type: "string",
					pattern:
						"^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
					markdownDescription: p(
						"proxy",
						"The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyStrictSSL": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"strictSSL",
						"Controls whether the proxy server certificate should be verified against the list of supplied CAs. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyKerberosServicePrincipal": {
					type: "string",
					markdownDescription: p(
						"proxyKerberosServicePrincipal",
						"Overrides the principal service name for Kerberos authentication with the HTTP proxy. A default based on the proxy hostname is used when this is not set. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.noProxy": {
					type: "array",
					items: { type: "string" },
					markdownDescription: p(
						"noProxy",
						"Specifies domain names for which proxy settings should be ignored for HTTP/HTTPS requests. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyAuthorization": {
					type: ["null", "string"],
					default: null,
					markdownDescription: p(
						"proxyAuthorization",
						"The value to send as the `Proxy-Authorization` header for every network request. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxySupport": {
					type: "string",
					enum: ["off", "on", "fallback", "override"],
					enumDescriptions: [
						p("proxySupportOff", "Disable proxy support for extensions."),
						p("proxySupportOn", "Enable proxy support for extensions."),
						p(
							"proxySupportFallback",
							"Enable proxy support for extensions, fall back to request options, when no proxy found.",
						),
						p("proxySupportOverride", "Enable proxy support for extensions, override request options."),
					],
					default: "override",
					markdownDescription: p(
						"proxySupport",
						"Use the proxy support for extensions. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.systemCertificates": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"systemCertificates",
						"Controls whether CA certificates should be loaded from the OS. On Windows and macOS, a reload of the window is required after turning this off. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.experimental.systemCertificatesV2": {
					type: "boolean",
					tags: ["experimental"],
					default: !1,
					markdownDescription: p(
						"systemCertificatesV2",
						"Controls whether experimental loading of CA certificates from the OS should be enabled. This uses a more general approach than the default implementation. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.fetchAdditionalSupport": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"fetchAdditionalSupport",
						"Controls whether Node.js' fetch implementation should be extended with additional support. Currently proxy support ({1}) and system certificates ({2}) are added when the corresponding settings are enabled. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
						"`#http.proxySupport#`",
						"`#http.systemCertificates#`",
					),
					restricted: !0,
				},
			},
		},
	]),
		t.updateConfigurations({ add: l_, remove: n })
}
UV()
var c_ = class o extends $ {
	constructor(t, n = Object.create(null)) {
		super()
		this.database = t
		this.options = n
		this._onDidChangeStorage = this._register(new ai())
		this.onDidChangeStorage = this._onDidChangeStorage.event
		this.state = 0
		this.cache = new Map()
		this.flushDelayer = this._register(new Zi(o.DEFAULT_FLUSH_DELAY))
		this.pendingDeletes = new Set()
		this.pendingInserts = new Map()
		this.pendingClose = void 0
		this.whenFlushedCallbacks = []
		this.registerListeners()
	}
	static {
		this.DEFAULT_FLUSH_DELAY = 100
	}
	registerListeners() {
		this._register(this.database.onDidChangeItemsExternal((t) => this.onDidChangeItemsExternal(t)))
	}
	onDidChangeItemsExternal(t) {
		this._onDidChangeStorage.pause()
		try {
			t.changed?.forEach((n, r) => this.acceptExternal(r, n)),
				t.deleted?.forEach((n) => this.acceptExternal(n, void 0))
		} finally {
			this._onDidChangeStorage.resume()
		}
	}
	acceptExternal(t, n) {
		if (this.state === 2) return
		let r = !1
		bt(n) ? (r = this.cache.delete(t)) : this.cache.get(t) !== n && (this.cache.set(t, n), (r = !0)),
			r && this._onDidChangeStorage.fire({ key: t, external: !0 })
	}
	get items() {
		return this.cache
	}
	get size() {
		return this.cache.size
	}
	async init() {
		this.state === 0 && ((this.state = 1), this.options.hint !== 0 && (this.cache = await this.database.getItems()))
	}
	get(t, n) {
		let r = this.cache.get(t)
		return bt(r) ? n : r
	}
	getBoolean(t, n) {
		let r = this.get(t)
		return bt(r) ? n : r === "true"
	}
	getNumber(t, n) {
		let r = this.get(t)
		return bt(r) ? n : parseInt(r, 10)
	}
	getObject(t, n) {
		let r = this.get(t)
		return bt(r) ? n : Kv(r)
	}
	async set(t, n, r = !1) {
		if (this.state === 2) return
		if (bt(n)) return this.delete(t, r)
		let i = dt(n) || Array.isArray(n) ? TO(n) : String(n)
		if (this.cache.get(t) !== i)
			return (
				this.cache.set(t, i),
				this.pendingInserts.set(t, i),
				this.pendingDeletes.delete(t),
				this._onDidChangeStorage.fire({ key: t, external: r }),
				this.doFlush()
			)
	}
	async delete(t, n = !1) {
		if (!(this.state === 2 || !this.cache.delete(t)))
			return (
				this.pendingDeletes.has(t) || this.pendingDeletes.add(t),
				this.pendingInserts.delete(t),
				this._onDidChangeStorage.fire({ key: t, external: n }),
				this.doFlush()
			)
	}
	async optimize() {
		if (this.state !== 2) return await this.flush(0), this.database.optimize()
	}
	async close() {
		return this.pendingClose || (this.pendingClose = this.doClose()), this.pendingClose
	}
	async doClose() {
		this.state = 2
		try {
			await this.doFlush(0)
		} catch {}
		await this.database.close(() => this.cache)
	}
	get hasPending() {
		return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0
	}
	async flushPending() {
		if (!this.hasPending) return
		let t = { insert: this.pendingInserts, delete: this.pendingDeletes }
		return (
			(this.pendingDeletes = new Set()),
			(this.pendingInserts = new Map()),
			this.database.updateItems(t).finally(() => {
				if (!this.hasPending) for (; this.whenFlushedCallbacks.length; ) this.whenFlushedCallbacks.pop()?.()
			})
		)
	}
	async flush(t) {
		if (!(this.state === 2 || this.pendingClose)) return this.doFlush(t)
	}
	async doFlush(t) {
		return this.options.hint === 1 ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), t)
	}
	async whenFlushed() {
		if (this.hasPending) return new Promise((t) => this.whenFlushedCallbacks.push(t))
	}
	isInMemory() {
		return this.options.hint === 1
	}
}
var Zf = O("environmentService"),
	LM = Zf
var ay = O("IUriIdentityService")
function MM(o) {
	let e = o
	return !!(
		e &&
		typeof e == "object" &&
		typeof e.id == "string" &&
		typeof e.isDefault == "boolean" &&
		typeof e.name == "string" &&
		y.isUri(e.location) &&
		y.isUri(e.globalStorageHome) &&
		y.isUri(e.settingsResource) &&
		y.isUri(e.keybindingsResource) &&
		y.isUri(e.tasksResource) &&
		y.isUri(e.snippetsHome) &&
		y.isUri(e.promptsHome) &&
		y.isUri(e.extensionsResource)
	)
}
var FM = O("IUserDataProfilesService")
function ly(o, e, t, n, r, i) {
	return {
		id: o,
		name: e,
		location: t,
		isDefault: !1,
		icon: r?.icon,
		globalStorageHome: i && r?.useDefaultFlags?.globalState ? i.globalStorageHome : ct(t, "globalStorage"),
		settingsResource: i && r?.useDefaultFlags?.settings ? i.settingsResource : ct(t, "settings.json"),
		keybindingsResource: i && r?.useDefaultFlags?.keybindings ? i.keybindingsResource : ct(t, "keybindings.json"),
		tasksResource: i && r?.useDefaultFlags?.tasks ? i.tasksResource : ct(t, "tasks.json"),
		snippetsHome: i && r?.useDefaultFlags?.snippets ? i.snippetsHome : ct(t, "snippets"),
		promptsHome: i && r?.useDefaultFlags?.prompts ? i.promptsHome : ct(t, "prompts"),
		extensionsResource: i && r?.useDefaultFlags?.extensions ? i.extensionsResource : ct(t, "extensions.json"),
		cacheHome: ct(n, o),
		useDefaultFlags: r?.useDefaultFlags,
		isTransient: r?.transient,
		workspaces: r?.workspaces,
	}
}
var dy = class extends $ {
	constructor(t, n, r, i) {
		super()
		this.environmentService = t
		this.fileService = n
		this.uriIdentityService = r
		this.logService = i
		this._onDidChangeProfiles = this._register(new E())
		this.onDidChangeProfiles = this._onDidChangeProfiles.event
		this._onWillCreateProfile = this._register(new E())
		this.onWillCreateProfile = this._onWillCreateProfile.event
		this._onWillRemoveProfile = this._register(new E())
		this.onWillRemoveProfile = this._onWillRemoveProfile.event
		this._onDidResetWorkspaces = this._register(new E())
		this.onDidResetWorkspaces = this._onDidResetWorkspaces.event
		this.profileCreationPromises = new Map()
		this.transientProfilesObject = { profiles: [], emptyWindows: new Map() }
		;(this.profilesHome = ct(this.environmentService.userRoamingDataHome, "profiles")),
			(this.profilesCacheHome = ct(this.environmentService.cacheHome, "CachedProfilesData"))
	}
	static {
		this.PROFILES_KEY = "userDataProfiles"
	}
	static {
		this.PROFILE_ASSOCIATIONS_KEY = "profileAssociations"
	}
	get defaultProfile() {
		return this.profiles[0]
	}
	get profiles() {
		return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles]
	}
	init() {
		this._profilesObject = void 0
	}
	get profilesObject() {
		if (!this._profilesObject) {
			let t = this.createDefaultProfile(),
				n = [t]
			try {
				for (let i of this.getStoredProfiles()) {
					if (!i.name || !Ee(i.name) || !i.location) {
						this.logService.warn("Skipping the invalid stored profile", i.location || i.name)
						continue
					}
					n.push(
						ly(
							Ht(i.location),
							i.name,
							i.location,
							this.profilesCacheHome,
							{ icon: i.icon, useDefaultFlags: i.useDefaultFlags },
							t,
						),
					)
				}
			} catch (i) {
				this.logService.error(i)
			}
			let r = new Map()
			if (n.length)
				try {
					let i = this.getStoredProfileAssociations()
					if (i.workspaces)
						for (let [s, a] of Object.entries(i.workspaces)) {
							let l = y.parse(s),
								d = n.find((c) => c.id === a)
							if (d) {
								let c = d.workspaces ? d.workspaces.slice(0) : []
								c.push(l), (d.workspaces = c)
							}
						}
					if (i.emptyWindows)
						for (let [s, a] of Object.entries(i.emptyWindows)) {
							let l = n.find((d) => d.id === a)
							l && r.set(s, l)
						}
				} catch (i) {
					this.logService.error(i)
				}
			this._profilesObject = { profiles: n, emptyWindows: r }
		}
		return this._profilesObject
	}
	createDefaultProfile() {
		let t = ly(
			"__default__profile__",
			p("defaultProfile", "Default"),
			this.environmentService.userRoamingDataHome,
			this.profilesCacheHome,
		)
		return {
			...t,
			extensionsResource: this.getDefaultProfileExtensionsLocation() ?? t.extensionsResource,
			isDefault: !0,
		}
	}
	async createTransientProfile(t) {
		let n = "Temp",
			r = new RegExp(`${_r(n)}\\s(\\d+)`),
			i = 0
		for (let a of this.profiles) {
			let l = r.exec(a.name),
				d = l ? parseInt(l[1]) : 0
			i = d > i ? d : i
		}
		let s = `${n} ${i + 1}`
		return this.createProfile(ar(He()).toString(16), s, { transient: !0 }, t)
	}
	async createNamedProfile(t, n, r) {
		return this.createProfile(ar(He()).toString(16), t, n, r)
	}
	async createProfile(t, n, r, i) {
		return await this.doCreateProfile(t, n, r, i)
	}
	async doCreateProfile(t, n, r, i) {
		if (!Ee(n) || !n) throw new Error("Name of the profile is mandatory and must be of type `string`")
		let s = this.profileCreationPromises.get(n)
		return (
			s ||
				((s = (async () => {
					try {
						if (this.profiles.find((u) => u.id === t || (!u.isTransient && !r?.transient && u.name === n)))
							throw new Error(`Profile with ${n} name already exists`)
						let l = i ? this.getWorkspace(i) : void 0
						y.isUri(l) && (r = { ...r, workspaces: [l] })
						let d = ly(t, n, ct(this.profilesHome, t), this.profilesCacheHome, r, this.defaultProfile)
						await this.fileService.createFolder(d.location)
						let c = []
						return (
							this._onWillCreateProfile.fire({
								profile: d,
								join(u) {
									c.push(u)
								},
							}),
							await so.settled(c),
							l && !y.isUri(l) && this.updateEmptyWindowAssociation(l, d, !!d.isTransient),
							this.updateProfiles([d], [], []),
							d
						)
					} finally {
						this.profileCreationPromises.delete(n)
					}
				})()),
				this.profileCreationPromises.set(n, s)),
			s
		)
	}
	async updateProfile(t, n) {
		let r = []
		for (let s of this.profiles) {
			let a
			if (t.id === s.id)
				s.isDefault
					? n.workspaces && ((a = s), (a.workspaces = n.workspaces))
					: (a = ly(
							s.id,
							n.name ?? s.name,
							s.location,
							this.profilesCacheHome,
							{
								icon: n.icon === null ? void 0 : (n.icon ?? s.icon),
								transient: n.transient ?? s.isTransient,
								useDefaultFlags: n.useDefaultFlags ?? s.useDefaultFlags,
								workspaces: n.workspaces ?? s.workspaces,
							},
							this.defaultProfile,
						))
			else if (n.workspaces) {
				let l = s.workspaces?.filter(
					(d) => !n.workspaces?.some((c) => this.uriIdentityService.extUri.isEqual(d, c)),
				)
				s.workspaces?.length !== l?.length && ((a = s), (a.workspaces = l))
			}
			a && r.push(a)
		}
		if (!r.length)
			throw t.isDefault
				? new Error("Cannot update default profile")
				: new Error(`Profile '${t.name}' does not exist`)
		this.updateProfiles([], [], r)
		let i = this.profiles.find((s) => s.id === t.id)
		if (!i) throw new Error(`Profile '${t.name}' was not updated`)
		return i
	}
	async removeProfile(t) {
		if (t.isDefault) throw new Error("Cannot remove default profile")
		let n = this.profiles.find((i) => i.id === t.id)
		if (!n) throw new Error(`Profile '${t.name}' does not exist`)
		let r = []
		this._onWillRemoveProfile.fire({
			profile: n,
			join(i) {
				r.push(i)
			},
		})
		try {
			await Promise.allSettled(r)
		} catch (i) {
			this.logService.error(i)
		}
		this.updateProfiles([], [n], [])
		try {
			await this.fileService.del(n.cacheHome, { recursive: !0 })
		} catch (i) {
			eL(i) !== 1 && this.logService.error(i)
		}
	}
	async setProfileForWorkspace(t, n) {
		let r = this.profiles.find((s) => s.id === n.id)
		if (!r) throw new Error(`Profile '${n.name}' does not exist`)
		let i = this.getWorkspace(t)
		if (y.isUri(i)) {
			let s = r.workspaces ? [...r.workspaces] : []
			s.some((a) => this.uriIdentityService.extUri.isEqual(a, i)) ||
				(s.push(i), await this.updateProfile(r, { workspaces: s }))
		} else this.updateEmptyWindowAssociation(i, r, !1), this.updateStoredProfiles(this.profiles)
	}
	unsetWorkspace(t, n = !1) {
		let r = this.getWorkspace(t)
		if (y.isUri(r)) {
			let i = this.getProfileForWorkspace(t)
			i &&
				this.updateProfile(i, {
					workspaces: i.workspaces?.filter((s) => !this.uriIdentityService.extUri.isEqual(s, r)),
				})
		} else this.updateEmptyWindowAssociation(r, void 0, n), this.updateStoredProfiles(this.profiles)
	}
	async resetWorkspaces() {
		this.transientProfilesObject.emptyWindows.clear(), this.profilesObject.emptyWindows.clear()
		for (let t of this.profiles) t.workspaces = void 0
		this.updateProfiles([], [], this.profiles), this._onDidResetWorkspaces.fire()
	}
	async cleanUp() {
		if (await this.fileService.exists(this.profilesHome)) {
			let t = await this.fileService.resolve(this.profilesHome)
			await Promise.all(
				(t.children || [])
					.filter(
						(n) =>
							n.isDirectory &&
							this.profiles.every((r) => !this.uriIdentityService.extUri.isEqual(r.location, n.resource)),
					)
					.map((n) => this.fileService.del(n.resource, { recursive: !0 })),
			)
		}
	}
	async cleanUpTransientProfiles() {
		let t = this.transientProfilesObject.profiles.filter((n) => !this.isProfileAssociatedToWorkspace(n))
		await Promise.allSettled(t.map((n) => this.removeProfile(n)))
	}
	getProfileForWorkspace(t) {
		let n = this.getWorkspace(t)
		return y.isUri(n)
			? this.profiles.find((r) => r.workspaces?.some((i) => this.uriIdentityService.extUri.isEqual(i, n)))
			: (this.profilesObject.emptyWindows.get(n) ?? this.transientProfilesObject.emptyWindows.get(n))
	}
	getWorkspace(t) {
		return oL(t) ? t.uri : iL(t) ? t.configPath : t.id
	}
	isProfileAssociatedToWorkspace(t) {
		return !!(
			t.workspaces?.length ||
			[...this.profilesObject.emptyWindows.values()].some((n) =>
				this.uriIdentityService.extUri.isEqual(n.location, t.location),
			) ||
			[...this.transientProfilesObject.emptyWindows.values()].some((n) =>
				this.uriIdentityService.extUri.isEqual(n.location, t.location),
			)
		)
	}
	updateProfiles(t, n, r) {
		let i = [...this.profiles, ...t],
			s = this.transientProfilesObject.profiles
		this.transientProfilesObject.profiles = []
		let a = []
		for (let l of i) {
			if (n.some((d) => l.id === d.id)) {
				for (let d of [...this.profilesObject.emptyWindows.keys()])
					l.id === this.profilesObject.emptyWindows.get(d)?.id && this.profilesObject.emptyWindows.delete(d)
				continue
			}
			if (!l.isDefault) {
				l = r.find((c) => l.id === c.id) ?? l
				let d = s.find((c) => l.id === c.id)
				if (l.isTransient) this.transientProfilesObject.profiles.push(l)
				else if (d) {
					for (let [c, u] of this.transientProfilesObject.emptyWindows.entries())
						if (l.id === u.id) {
							this.transientProfilesObject.emptyWindows.delete(c),
								this.profilesObject.emptyWindows.set(c, l)
							break
						}
				}
			}
			l.workspaces?.length === 0 && (l.workspaces = void 0), a.push(l)
		}
		this.updateStoredProfiles(a), this.triggerProfilesChanges(t, n, r)
	}
	triggerProfilesChanges(t, n, r) {
		this._onDidChangeProfiles.fire({ added: t, removed: n, updated: r, all: this.profiles })
	}
	updateEmptyWindowAssociation(t, n, r) {
		;(r = n?.isTransient ? !0 : r),
			r
				? n
					? this.transientProfilesObject.emptyWindows.set(t, n)
					: this.transientProfilesObject.emptyWindows.delete(t)
				: (this.transientProfilesObject.emptyWindows.delete(t),
					n ? this.profilesObject.emptyWindows.set(t, n) : this.profilesObject.emptyWindows.delete(t))
	}
	updateStoredProfiles(t) {
		let n = [],
			r = {},
			i = {}
		for (let s of t)
			if (
				!s.isTransient &&
				(s.isDefault ||
					n.push({ location: s.location, name: s.name, icon: s.icon, useDefaultFlags: s.useDefaultFlags }),
				s.workspaces)
			)
				for (let a of s.workspaces) r[a.toString()] = s.id
		for (let [s, a] of this.profilesObject.emptyWindows.entries()) i[s.toString()] = a.id
		this.saveStoredProfileAssociations({ workspaces: r, emptyWindows: i }),
			this.saveStoredProfiles(n),
			(this._profilesObject = void 0)
	}
	getStoredProfiles() {
		return []
	}
	saveStoredProfiles(t) {
		throw new Error("not implemented")
	}
	getStoredProfileAssociations() {
		return {}
	}
	saveStoredProfileAssociations(t) {
		throw new Error("not implemented")
	}
	getDefaultProfileExtensionsLocation() {}
}
dy = R([S(0, Zf), S(1, fb), S(2, ay), S(3, te)], dy)
var WV = "__$__isNewStorageMarker",
	cy = "__$__targetStorageMarker",
	uy = O("storageService")
function VV(o) {
	let e = o.get(cy)
	if (e)
		try {
			return JSON.parse(e)
		} catch {}
	return Object.create(null)
}
var NM = class o extends $ {
	constructor(t = { flushInterval: o.DEFAULT_FLUSH_INTERVAL }) {
		super()
		this._onDidChangeValue = this._register(new ai())
		this._onDidChangeTarget = this._register(new ai())
		this.onDidChangeTarget = this._onDidChangeTarget.event
		this._onWillSaveState = this._register(new E())
		this.onWillSaveState = this._onWillSaveState.event
		this.runFlushWhenIdle = this._register(new Dn())
		this._workspaceKeyTargets = void 0
		this._profileKeyTargets = void 0
		this._applicationKeyTargets = void 0
		this.flushWhenIdleScheduler = this._register(new Hn(() => this.doFlushWhenIdle(), t.flushInterval))
	}
	static {
		this.DEFAULT_FLUSH_INTERVAL = 60 * 1e3
	}
	onDidChangeValue(t, n, r) {
		return Te.filter(this._onDidChangeValue.event, (i) => i.scope === t && (n === void 0 || i.key === n), r)
	}
	doFlushWhenIdle() {
		this.runFlushWhenIdle.value = _E(() => {
			this.shouldFlushWhenIdle() && this.flush(), this.flushWhenIdleScheduler.schedule()
		})
	}
	shouldFlushWhenIdle() {
		return !0
	}
	stopFlushWhenIdle() {
		Fn([this.runFlushWhenIdle, this.flushWhenIdleScheduler])
	}
	initialize() {
		return (
			this.initializationPromise ||
				(this.initializationPromise = (async () => {
					Ct("code/willInitStorage")
					try {
						await this.doInitialize()
					} finally {
						Ct("code/didInitStorage")
					}
					this.flushWhenIdleScheduler.schedule()
				})()),
			this.initializationPromise
		)
	}
	emitDidChangeValue(t, n) {
		let { key: r, external: i } = n
		if (r === cy) {
			switch (t) {
				case -1:
					this._applicationKeyTargets = void 0
					break
				case 0:
					this._profileKeyTargets = void 0
					break
				case 1:
					this._workspaceKeyTargets = void 0
					break
			}
			this._onDidChangeTarget.fire({ scope: t })
		} else this._onDidChangeValue.fire({ scope: t, key: r, target: this.getKeyTargets(t)[r], external: i })
	}
	emitWillSaveState(t) {
		this._onWillSaveState.fire({ reason: t })
	}
	get(t, n, r) {
		return this.getStorage(n)?.get(t, r)
	}
	getBoolean(t, n, r) {
		return this.getStorage(n)?.getBoolean(t, r)
	}
	getNumber(t, n, r) {
		return this.getStorage(n)?.getNumber(t, r)
	}
	getObject(t, n, r) {
		return this.getStorage(n)?.getObject(t, r)
	}
	storeAll(t, n) {
		this.withPausedEmitters(() => {
			for (let r of t) this.store(r.key, r.value, r.scope, r.target, n)
		})
	}
	store(t, n, r, i, s = !1) {
		if (bt(n)) {
			this.remove(t, r, s)
			return
		}
		this.withPausedEmitters(() => {
			this.updateKeyTarget(t, r, i), this.getStorage(r)?.set(t, n, s)
		})
	}
	remove(t, n, r = !1) {
		this.withPausedEmitters(() => {
			this.updateKeyTarget(t, n, void 0), this.getStorage(n)?.delete(t, r)
		})
	}
	withPausedEmitters(t) {
		this._onDidChangeValue.pause(), this._onDidChangeTarget.pause()
		try {
			t()
		} finally {
			this._onDidChangeValue.resume(), this._onDidChangeTarget.resume()
		}
	}
	keys(t, n) {
		let r = [],
			i = this.getKeyTargets(t)
		for (let s of Object.keys(i)) i[s] === n && r.push(s)
		return r
	}
	updateKeyTarget(t, n, r, i = !1) {
		let s = this.getKeyTargets(n)
		typeof r == "number"
			? s[t] !== r && ((s[t] = r), this.getStorage(n)?.set(cy, JSON.stringify(s), i))
			: typeof s[t] == "number" && (delete s[t], this.getStorage(n)?.set(cy, JSON.stringify(s), i))
	}
	get workspaceKeyTargets() {
		return (
			this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(1)), this._workspaceKeyTargets
		)
	}
	get profileKeyTargets() {
		return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(0)), this._profileKeyTargets
	}
	get applicationKeyTargets() {
		return (
			this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(-1)),
			this._applicationKeyTargets
		)
	}
	getKeyTargets(t) {
		switch (t) {
			case -1:
				return this.applicationKeyTargets
			case 0:
				return this.profileKeyTargets
			default:
				return this.workspaceKeyTargets
		}
	}
	loadKeyTargets(t) {
		let n = this.getStorage(t)
		return n ? VV(n) : Object.create(null)
	}
	isNew(t) {
		return this.getBoolean(WV, t) === !0
	}
	async flush(t = 0) {
		this._onWillSaveState.fire({ reason: t })
		let n = this.getStorage(-1),
			r = this.getStorage(0),
			i = this.getStorage(1)
		switch (t) {
			case 0:
				await so.settled([
					n?.whenFlushed() ?? Promise.resolve(),
					r?.whenFlushed() ?? Promise.resolve(),
					i?.whenFlushed() ?? Promise.resolve(),
				])
				break
			case 1:
				await so.settled([
					n?.flush(0) ?? Promise.resolve(),
					r?.flush(0) ?? Promise.resolve(),
					i?.flush(0) ?? Promise.resolve(),
				])
				break
		}
	}
	async log() {
		let t = this.getStorage(-1)?.items ?? new Map(),
			n = this.getStorage(0)?.items ?? new Map(),
			r = this.getStorage(1)?.items ?? new Map()
		return BV(t, n, r, this.getLogDetails(-1) ?? "", this.getLogDetails(0) ?? "", this.getLogDetails(1) ?? "")
	}
	async optimize(t) {
		return await this.flush(), this.getStorage(t)?.optimize()
	}
	async switch(t, n) {
		return this.emitWillSaveState(0), MM(t) ? this.switchToProfile(t, n) : this.switchToWorkspace(t, n)
	}
	canSwitchProfile(t, n) {
		return !(t.id === n.id || (UM(n) && UM(t)))
	}
	switchData(t, n, r) {
		this.withPausedEmitters(() => {
			let i = new Set()
			for (let [s, a] of t) i.add(s), n.get(s) !== a && this.emitDidChangeValue(r, { key: s, external: !0 })
			for (let [s] of n.items) i.has(s) || this.emitDidChangeValue(r, { key: s, external: !0 })
		})
	}
}
function UM(o) {
	return o.isDefault || !!o.useDefaultFlags?.globalState
}
async function BV(o, e, t, n, r, i) {
	let s = (g) => {
			try {
				return JSON.parse(g)
			} catch {
				return g
			}
		},
		a = new Map(),
		l = new Map()
	o.forEach((g, I) => {
		a.set(I, g), l.set(I, s(g))
	})
	let d = new Map(),
		c = new Map()
	e.forEach((g, I) => {
		d.set(I, g), c.set(I, s(g))
	})
	let u = new Map(),
		m = new Map()
	t.forEach((g, I) => {
		u.set(I, g), m.set(I, s(g))
	}),
		console.group(
			n !== r
				? `Storage: Application (path: ${n})`
				: `Storage: Application & Profile (path: ${n}, default profile)`,
		)
	let f = []
	if (
		(a.forEach((g, I) => {
			f.push({ key: I, value: g })
		}),
		console.table(f),
		console.groupEnd(),
		console.log(l),
		n !== r)
	) {
		console.group(`Storage: Profile (path: ${r}, profile specific)`)
		let g = []
		d.forEach((I, C) => {
			g.push({ key: C, value: I })
		}),
			console.table(g),
			console.groupEnd(),
			console.log(c)
	}
	console.group(`Storage: Workspace (path: ${i})`)
	let h = []
	u.forEach((g, I) => {
		h.push({ key: I, value: g })
	}),
		console.table(h),
		console.groupEnd(),
		console.log(m)
}
var Une = new D("isMac", st, p("isMac", "Whether the operating system is macOS")),
	Hne = new D("isLinux", Ve, p("isLinux", "Whether the operating system is Linux")),
	Wne = new D("isWindows", Ie, p("isWindows", "Whether the operating system is Windows")),
	HM = new D("isWeb", Ro, p("isWeb", "Whether the platform is a web browser")),
	Vne = new D(
		"isMacNative",
		st && !Ro,
		p("isMacNative", "Whether the operating system is macOS on a non-browser platform"),
	),
	Bne = new D("isIOS", iA, p("isIOS", "Whether the operating system is iOS")),
	$ne = new D("isMobile", sA, p("isMobile", "Whether the platform is a mobile web browser")),
	zne = new D("isDevelopment", !1, !0),
	qne = new D("productQualityType", "", p("productQualityType", "Quality type of VS Code")),
	$V = "inputFocus",
	Kne = new D($V, !1, p("inputFocus", "Whether keyboard focus is inside an input box"))
var WM = O("languageService")
var VM = O("modelService")
var lre = new D("workbenchState", void 0, {
		type: "string",
		description: p(
			"workbenchState",
			"The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)",
		),
	}),
	dre = new D("workspaceFolderCount", 0, p("workspaceFolderCount", "The number of root folders in the workspace")),
	cre = new D("openFolderWorkspaceSupport", !0, !0),
	ure = new D("enterMultiRootWorkspaceSupport", !0, !0),
	pre = new D("emptyWorkspaceSupport", !0, !0),
	mre = new D(
		"dirtyWorkingCopies",
		!1,
		p("dirtyWorkingCopies", "Whether there are any working copies with unsaved changes"),
	),
	BM = new D(
		"remoteName",
		"",
		p(
			"remoteName",
			"The name of the remote the window is connected to or an empty string if not connected to any remote",
		),
	),
	fre = new D(
		"virtualWorkspace",
		"",
		p("virtualWorkspace", "The scheme of the current workspace is from a virtual file system or an empty string."),
	),
	gre = new D(
		"temporaryWorkspace",
		!1,
		p("temporaryWorkspace", "The scheme of the current workspace is from a temporary file system."),
	),
	hre = new D("isFullscreen", !1, p("isFullscreen", "Whether the main window is in fullscreen mode")),
	vre = new D(
		"isAuxiliaryWindowFocusedContext",
		!1,
		p("isAuxiliaryWindowFocusedContext", "Whether an auxiliary window is focused"),
	),
	bre = new D("hasWebFileSystemAccess", !1, !0),
	yre = new D(
		"embedderIdentifier",
		void 0,
		p("embedderIdentifier", "The identifier of the embedder according to the product service, if one is defined"),
	),
	Ire = new D("activeEditorIsDirty", !1, p("activeEditorIsDirty", "Whether the active editor has unsaved changes")),
	xre = new D(
		"activeEditorIsNotPreview",
		!1,
		p("activeEditorIsNotPreview", "Whether the active editor is not in preview mode"),
	),
	Cre = new D(
		"activeEditorIsFirstInGroup",
		!1,
		p("activeEditorIsFirstInGroup", "Whether the active editor is the first one in its group"),
	),
	Sre = new D(
		"activeEditorIsLastInGroup",
		!1,
		p("activeEditorIsLastInGroup", "Whether the active editor is the last one in its group"),
	),
	Tre = new D("activeEditorIsPinned", !1, p("activeEditorIsPinned", "Whether the active editor is pinned")),
	Ere = new D("activeEditorIsReadonly", !1, p("activeEditorIsReadonly", "Whether the active editor is read-only")),
	wre = new D(
		"activeCompareEditorCanSwap",
		!1,
		p("activeCompareEditorCanSwap", "Whether the active compare editor can swap sides"),
	),
	Pre = new D(
		"activeEditorCanToggleReadonly",
		!0,
		p("activeEditorCanToggleReadonly", "Whether the active editor can toggle between being read-only or writeable"),
	),
	_re = new D("activeEditorCanRevert", !1, p("activeEditorCanRevert", "Whether the active editor can revert")),
	Dre = new D("activeEditorCanSplitInGroup", !0),
	kre = new D("activeEditor", null, {
		type: "string",
		description: p("activeEditor", "The identifier of the active editor"),
	}),
	Rre = new D(
		"activeEditorAvailableEditorIds",
		"",
		p("activeEditorAvailableEditorIds", "The available editor identifiers that are usable for the active editor"),
	),
	Are = new D(
		"textCompareEditorVisible",
		!1,
		p("textCompareEditorVisible", "Whether a text compare editor is visible"),
	),
	Ore = new D("textCompareEditorActive", !1, p("textCompareEditorActive", "Whether a text compare editor is active")),
	Lre = new D("sideBySideEditorActive", !1, p("sideBySideEditorActive", "Whether a side by side editor is active")),
	Mre = new D("groupEditorsCount", 0, p("groupEditorsCount", "The number of opened editor groups")),
	Fre = new D("activeEditorGroupEmpty", !1, p("activeEditorGroupEmpty", "Whether the active editor group is empty")),
	Nre = new D("activeEditorGroupIndex", 0, p("activeEditorGroupIndex", "The index of the active editor group")),
	Ure = new D(
		"activeEditorGroupLast",
		!1,
		p("activeEditorGroupLast", "Whether the active editor group is the last group"),
	),
	Hre = new D(
		"activeEditorGroupLocked",
		!1,
		p("activeEditorGroupLocked", "Whether the active editor group is locked"),
	),
	zV = new D(
		"multipleEditorGroups",
		!1,
		p("multipleEditorGroups", "Whether there are multiple editor groups opened"),
	),
	Wre = zV.toNegated(),
	Vre = new D(
		"multipleEditorsSelectedInGroup",
		!1,
		p("multipleEditorsSelectedInGroup", "Whether multiple editors have been selected in an editor group"),
	),
	Bre = new D(
		"twoEditorsSelectedInGroup",
		!1,
		p("twoEditorsSelectedInGroup", "Whether exactly two editors have been selected in an editor group"),
	),
	$re = new D(
		"SelectedEditorsInGroupFileOrUntitledResourceContextKey",
		!0,
		p(
			"SelectedEditorsInGroupFileOrUntitledResourceContextKey",
			"Whether all selected editors in a group have a file or untitled resource associated",
		),
	),
	qV = new D(
		"editorPartMultipleEditorGroups",
		!1,
		p("editorPartMultipleEditorGroups", "Whether there are multiple editor groups opened in an editor part"),
	),
	zre = qV.toNegated(),
	qre = new D(
		"editorPartMaximizedEditorGroup",
		!1,
		p("editorPartEditorGroupMaximized", "Editor Part has a maximized group"),
	),
	Kre = new D("isAuxiliaryEditorPart", !1, p("isAuxiliaryEditorPart", "Editor Part is in an auxiliary window")),
	jre = new D("editorIsOpen", !1, p("editorIsOpen", "Whether an editor is open")),
	Gre = new D("inZenMode", !1, p("inZenMode", "Whether Zen mode is enabled")),
	Qre = new D(
		"isCenteredLayout",
		!1,
		p("isMainEditorCenteredLayout", "Whether centered layout is enabled for the main editor"),
	),
	Jre = new D("splitEditorsVertically", !1, p("splitEditorsVertically", "Whether editors split vertically")),
	Xre = new D(
		"mainEditorAreaVisible",
		!0,
		p("mainEditorAreaVisible", "Whether the editor area in the main window is visible"),
	),
	Yre = new D("editorTabsVisible", !0, p("editorTabsVisible", "Whether editor tabs are visible")),
	Zre = new D("sideBarVisible", !1, p("sideBarVisible", "Whether the sidebar is visible")),
	eoe = new D("sideBarFocus", !1, p("sideBarFocus", "Whether the sidebar has keyboard focus")),
	toe = new D("activeViewlet", "", p("activeViewlet", "The identifier of the active viewlet")),
	noe = new D("statusBarFocused", !1, p("statusBarFocused", "Whether the status bar has keyboard focus")),
	roe = new D("titleBarStyle", "custom", p("titleBarStyle", "Style of the window title bar")),
	ooe = new D("titleBarVisible", !1, p("titleBarVisible", "Whether the title bar is visible")),
	ioe = new D("bannerFocused", !1, p("bannerFocused", "Whether the banner has keyboard focus")),
	soe = new D("notificationFocus", !0, p("notificationFocus", "Whether a notification has keyboard focus")),
	aoe = new D(
		"notificationCenterVisible",
		!1,
		p("notificationCenterVisible", "Whether the notifications center is visible"),
	),
	loe = new D(
		"notificationToastsVisible",
		!1,
		p("notificationToastsVisible", "Whether a notification toast is visible"),
	),
	doe = new D("activeAuxiliary", "", p("activeAuxiliary", "The identifier of the active auxiliary panel")),
	coe = new D("auxiliaryBarFocus", !1, p("auxiliaryBarFocus", "Whether the auxiliary bar has keyboard focus")),
	uoe = new D("auxiliaryBarVisible", !1, p("auxiliaryBarVisible", "Whether the auxiliary bar is visible")),
	poe = new D("activePanel", "", p("activePanel", "The identifier of the active panel")),
	moe = new D("panelFocus", !1, p("panelFocus", "Whether the panel has keyboard focus")),
	foe = new D("panelPosition", "bottom", p("panelPosition", "The position of the panel, always 'bottom'")),
	goe = new D(
		"panelAlignment",
		"center",
		p("panelAlignment", "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"),
	),
	hoe = new D("panelVisible", !1, p("panelVisible", "Whether the panel is visible")),
	voe = new D("panelMaximized", !1, p("panelMaximized", "Whether the panel is maximized")),
	boe = new D("focusedView", "", p("focusedView", "The identifier of the view that has keyboard focus"))
var Lr = class {
	constructor(e, t, n, r) {
		this._contextKeyService = e
		this._fileService = t
		this._languageService = n
		this._modelService = r
		this._disposables = new Q()
		;(this._schemeKey = Lr.Scheme.bindTo(this._contextKeyService)),
			(this._filenameKey = Lr.Filename.bindTo(this._contextKeyService)),
			(this._dirnameKey = Lr.Dirname.bindTo(this._contextKeyService)),
			(this._pathKey = Lr.Path.bindTo(this._contextKeyService)),
			(this._langIdKey = Lr.LangId.bindTo(this._contextKeyService)),
			(this._resourceKey = Lr.Resource.bindTo(this._contextKeyService)),
			(this._extensionKey = Lr.Extension.bindTo(this._contextKeyService)),
			(this._hasResource = Lr.HasResource.bindTo(this._contextKeyService)),
			(this._isFileSystemResource = Lr.IsFileSystemResource.bindTo(this._contextKeyService)),
			this._disposables.add(
				t.onDidChangeFileSystemProviderRegistrations(() => {
					let i = this.get()
					this._isFileSystemResource.set(!!(i && t.hasProvider(i)))
				}),
			),
			this._disposables.add(
				r.onModelAdded((i) => {
					qr(i.uri, this.get()) && this._setLangId()
				}),
			),
			this._disposables.add(
				r.onModelLanguageChanged((i) => {
					qr(i.model.uri, this.get()) && this._setLangId()
				}),
			)
	}
	static {
		this.Scheme = new D("resourceScheme", void 0, {
			type: "string",
			description: p("resourceScheme", "The scheme of the resource"),
		})
	}
	static {
		this.Filename = new D("resourceFilename", void 0, {
			type: "string",
			description: p("resourceFilename", "The file name of the resource"),
		})
	}
	static {
		this.Dirname = new D("resourceDirname", void 0, {
			type: "string",
			description: p("resourceDirname", "The folder name the resource is contained in"),
		})
	}
	static {
		this.Path = new D("resourcePath", void 0, {
			type: "string",
			description: p("resourcePath", "The full path of the resource"),
		})
	}
	static {
		this.LangId = new D("resourceLangId", void 0, {
			type: "string",
			description: p("resourceLangId", "The language identifier of the resource"),
		})
	}
	static {
		this.Resource = new D("resource", void 0, {
			type: "URI",
			description: p("resource", "The full value of the resource including scheme and path"),
		})
	}
	static {
		this.Extension = new D("resourceExtname", void 0, {
			type: "string",
			description: p("resourceExtname", "The extension name of the resource"),
		})
	}
	static {
		this.HasResource = new D("resourceSet", void 0, {
			type: "boolean",
			description: p("resourceSet", "Whether a resource is present or not"),
		})
	}
	static {
		this.IsFileSystemResource = new D("isFileSystemResource", void 0, {
			type: "boolean",
			description: p("isFileSystemResource", "Whether the resource is backed by a file system provider"),
		})
	}
	dispose() {
		this._disposables.dispose()
	}
	_setLangId() {
		let e = this.get()
		if (!e) {
			this._langIdKey.set(null)
			return
		}
		let t =
			this._modelService.getModel(e)?.getLanguageId() ??
			this._languageService.guessLanguageIdByFilepathOrFirstLine(e)
		this._langIdKey.set(t)
	}
	set(e) {
		;(e = e ?? void 0),
			!qr(this._value, e) &&
				((this._value = e),
				this._contextKeyService.bufferChangeEvents(() => {
					this._resourceKey.set(e ? e.toString() : null),
						this._schemeKey.set(e ? e.scheme : null),
						this._filenameKey.set(e ? Ht(e) : null),
						this._dirnameKey.set(e ? this.uriToPath(Yi(e)) : null),
						this._pathKey.set(e ? this.uriToPath(e) : null),
						this._setLangId(),
						this._extensionKey.set(e ? Rv(e) : null),
						this._hasResource.set(!!e),
						this._isFileSystemResource.set(e ? this._fileService.hasProvider(e) : !1)
				}))
	}
	uriToPath(e) {
		return e.scheme === W.file ? e.fsPath : e.path
	}
	reset() {
		;(this._value = void 0),
			this._contextKeyService.bufferChangeEvents(() => {
				this._resourceKey.reset(),
					this._schemeKey.reset(),
					this._filenameKey.reset(),
					this._dirnameKey.reset(),
					this._pathKey.reset(),
					this._langIdKey.reset(),
					this._extensionKey.reset(),
					this._hasResource.reset(),
					this._isFileSystemResource.reset()
			})
	}
	get() {
		return this._value
	}
}
Lr = R([S(0, ca), S(1, fb), S(2, WM), S(3, VM)], Lr)
var sd = ((r) => ((r.Panel = "panel"), (r.Terminal = "terminal"), (r.Notebook = "notebook"), (r.Editor = "editor"), r))(
	sd || {},
)
;((e) => {
	function o(t) {
		switch (t) {
			case "panel":
				return "panel"
			case "terminal":
				return "terminal"
			case "notebook":
				return "notebook"
			case "editor":
				return "editor"
		}
		return "panel"
	}
	e.fromRaw = o
})((sd ||= {}))
var fs
;((le) => (
	(le.responseVote = new D("chatSessionResponseVote", "", {
		type: "string",
		description: p(
			"interactiveSessionResponseVote",
			"When the response has been voted up, is set to 'up'. When voted down, is set to 'down'. Otherwise an empty string.",
		),
	})),
	(le.responseDetectedAgentCommand = new D("chatSessionResponseDetectedAgentOrCommand", !1, {
		type: "boolean",
		description: p(
			"chatSessionResponseDetectedAgentOrCommand",
			"When the agent or command was automatically detected",
		),
	})),
	(le.responseSupportsIssueReporting = new D("chatResponseSupportsIssueReporting", !1, {
		type: "boolean",
		description: p(
			"chatResponseSupportsIssueReporting",
			"True when the current chat response supports issue reporting.",
		),
	})),
	(le.responseIsFiltered = new D("chatSessionResponseFiltered", !1, {
		type: "boolean",
		description: p("chatResponseFiltered", "True when the chat response was filtered out by the server."),
	})),
	(le.responseHasError = new D("chatSessionResponseError", !1, {
		type: "boolean",
		description: p("chatResponseErrored", "True when the chat response resulted in an error."),
	})),
	(le.requestInProgress = new D("chatSessionRequestInProgress", !1, {
		type: "boolean",
		description: p("interactiveSessionRequestInProgress", "True when the current request is still in progress."),
	})),
	(le.isRequestPaused = new D("chatRequestIsPaused", !1, {
		type: "boolean",
		description: p("chatRequestIsPaused", "True when the current request is paused."),
	})),
	(le.canRequestBePaused = new D("chatCanRequestBePaused", !1, {
		type: "boolean",
		description: p("chatCanRequestBePaused", "True when the current request can be paused."),
	})),
	(le.isResponse = new D("chatResponse", !1, {
		type: "boolean",
		description: p("chatResponse", "The chat item is a response."),
	})),
	(le.isRequest = new D("chatRequest", !1, {
		type: "boolean",
		description: p("chatRequest", "The chat item is a request"),
	})),
	(le.itemId = new D("chatItemId", "", { type: "string", description: p("chatItemId", "The id of the chat item.") })),
	(le.lastItemId = new D("chatLastItemId", [], {
		type: "string",
		description: p("chatLastItemId", "The id of the last chat item."),
	})),
	(le.editApplied = new D("chatEditApplied", !1, {
		type: "boolean",
		description: p("chatEditApplied", "True when the chat text edits have been applied."),
	})),
	(le.inputHasText = new D("chatInputHasText", !1, {
		type: "boolean",
		description: p("interactiveInputHasText", "True when the chat input has text."),
	})),
	(le.inputHasFocus = new D("chatInputHasFocus", !1, {
		type: "boolean",
		description: p("interactiveInputHasFocus", "True when the chat input has focus."),
	})),
	(le.inChatInput = new D("inChatInput", !1, {
		type: "boolean",
		description: p("inInteractiveInput", "True when focus is in the chat input, false otherwise."),
	})),
	(le.inChatSession = new D("inChat", !1, {
		type: "boolean",
		description: p("inChat", "True when focus is in the chat widget, false otherwise."),
	})),
	(le.instructionsAttached = new D("chatInstructionsAttached", !1, {
		type: "boolean",
		description: p(
			"chatInstructionsAttachedContextDescription",
			"True when the chat has a prompt instructions attached.",
		),
	})),
	(le.chatMode = new D("chatMode", "ask", { type: "string", description: p("chatMode", "The current chat mode.") })),
	(le.supported = Lt.or(HM.toNegated(), BM.notEqualsTo(""))),
	(le.enabled = new D("chatIsEnabled", !1, {
		type: "boolean",
		description: p(
			"chatIsEnabled",
			"True when chat is enabled because a default chat participant is activated with an implementation.",
		),
	})),
	(le.panelParticipantRegistered = new D("chatPanelParticipantRegistered", !1, {
		type: "boolean",
		description: p(
			"chatParticipantRegistered",
			"True when a default chat participant is registered for the panel.",
		),
	})),
	(le.editingParticipantRegistered = new D("chatEditingParticipantRegistered", !1, {
		type: "boolean",
		description: p(
			"chatEditingParticipantRegistered",
			"True when a default chat participant is registered for editing.",
		),
	})),
	(le.chatEditingCanUndo = new D("chatEditingCanUndo", !1, {
		type: "boolean",
		description: p("chatEditingCanUndo", "True when it is possible to undo an interaction in the editing panel."),
	})),
	(le.chatEditingCanRedo = new D("chatEditingCanRedo", !1, {
		type: "boolean",
		description: p("chatEditingCanRedo", "True when it is possible to redo an interaction in the editing panel."),
	})),
	(le.extensionInvalid = new D("chatExtensionInvalid", !1, {
		type: "boolean",
		description: p(
			"chatExtensionInvalid",
			"True when the installed chat extension is invalid and needs to be updated.",
		),
	})),
	(le.inputCursorAtTop = new D("chatCursorAtTop", !1)),
	(le.inputHasAgent = new D("chatInputHasAgent", !1)),
	(le.location = new D("chatLocation", void 0)),
	(le.inQuickChat = new D("quickChatHasFocus", !1, {
		type: "boolean",
		description: p("inQuickChat", "True when the quick chat UI has focus, false otherwise."),
	})),
	(le.hasFileAttachments = new D("chatHasFileAttachments", !1, {
		type: "boolean",
		description: p("chatHasFileAttachments", "True when the chat has file attachments."),
	})),
	(le.languageModelsAreUserSelectable = new D("chatModelsAreUserSelectable", !1, {
		type: "boolean",
		description: p("chatModelsAreUserSelectable", "True when the chat model can be selected manually by the user."),
	})),
	(le.Setup = { hidden: new D("chatSetupHidden", !1, !0), installed: new D("chatSetupInstalled", !1, !0) }),
	(le.Entitlement = {
		signedOut: new D("chatSetupSignedOut", !1, !0),
		canSignUp: new D("chatPlanCanSignUp", !1, !0),
		limited: new D("chatPlanLimited", !1, !0),
		pro: new D("chatPlanPro", !1, !0),
	}),
	(le.chatQuotaExceeded = new D("chatQuotaExceeded", !1, !0)),
	(le.completionsQuotaExceeded = new D("completionsQuotaExceeded", !1, !0)),
	(le.Editing = {
		agentModeDisallowed: new D("chatAgentModeDisallowed", void 0, {
			type: "boolean",
			description: p("chatAgentModeDisallowed", "True when agent mode is not allowed."),
		}),
		hasToolConfirmation: new D("chatHasToolConfirmation", !1, {
			type: "boolean",
			description: p("chatEditingHasToolConfirmation", "True when a tool confirmation is present."),
		}),
	}),
	(le.Tools = {
		toolsCount: new D("toolsCount", 0, {
			type: "number",
			description: p("toolsCount", "The count of tools available in the chat."),
		}),
	})
))((fs ||= {}))
var KV
;((e) => (e.inEditingMode = Lt.or(fs.chatMode.isEqualTo("edit"), fs.chatMode.isEqualTo("agent"))))((KV ||= {}))
var qM = O("chatAgentService"),
	py = class extends $ {
		constructor(t) {
			super()
			this.contextKeyService = t
			this._agents = new Map()
			this._onDidChangeAgents = new E()
			this.onDidChangeAgents = this._onDidChangeAgents.event
			this._agentsContextKeys = new Set()
			this._hasToolsAgent = !1
			this._chatParticipantDetectionProviders = new Map()
			this._agentCompletionProviders = new Map()
			;(this._hasDefaultAgent = fs.enabled.bindTo(this.contextKeyService)),
				(this._defaultAgentRegistered = fs.panelParticipantRegistered.bindTo(this.contextKeyService)),
				(this._editingAgentRegistered = fs.editingParticipantRegistered.bindTo(this.contextKeyService)),
				this._register(
					t.onDidChangeContext((n) => {
						n.affectsSome(this._agentsContextKeys) && this._updateContextKeys()
					}),
				)
		}
		static {
			this.AGENT_LEADER = "@"
		}
		registerAgent(t, n) {
			if (this.getAgent(t)) throw new Error(`Agent already registered: ${JSON.stringify(t)}`)
			let i = this,
				s = n.slashCommands
			n = {
				...n,
				get slashCommands() {
					return s.filter((l) => !l.when || i.contextKeyService.contextMatchesRules(Lt.deserialize(l.when)))
				},
			}
			let a = { data: n }
			return (
				this._agents.set(t, a),
				this._updateAgentsContextKeys(),
				this._updateContextKeys(),
				this._onDidChangeAgents.fire(void 0),
				q(() => {
					this._agents.delete(t),
						this._updateAgentsContextKeys(),
						this._updateContextKeys(),
						this._onDidChangeAgents.fire(void 0)
				})
			)
		}
		_updateAgentsContextKeys() {
			this._agentsContextKeys.clear()
			for (let t of this._agents.values())
				if (t.data.when) {
					let n = Lt.deserialize(t.data.when)
					for (let r of n?.keys() || []) this._agentsContextKeys.add(r)
				}
		}
		_updateContextKeys() {
			let t = !1,
				n = !1,
				r = !1
			for (let i of this.getAgents())
				i.isDefault && (i.modes.includes("agent") ? (r = !0) : i.modes.includes("edit") ? (t = !0) : (n = !0))
			this._editingAgentRegistered.set(t),
				this._defaultAgentRegistered.set(n),
				r !== this._hasToolsAgent &&
					((this._hasToolsAgent = r), this._onDidChangeAgents.fire(this.getDefaultAgent("panel", "agent")))
		}
		registerAgentImplementation(t, n) {
			let r = this._agents.get(t)
			if (!r) throw new Error(`Unknown agent: ${JSON.stringify(t)}`)
			if (r.impl) throw new Error(`Agent already has implementation: ${JSON.stringify(t)}`)
			return (
				r.data.isDefault && this._hasDefaultAgent.set(!0),
				(r.impl = n),
				this._onDidChangeAgents.fire(new tu(r.data, n)),
				q(() => {
					;(r.impl = void 0),
						this._onDidChangeAgents.fire(void 0),
						r.data.isDefault && this._hasDefaultAgent.set(!1)
				})
			)
		}
		registerDynamicAgent(t, n) {
			t.isDynamic = !0
			let r = { data: t, impl: n }
			return (
				this._agents.set(t.id, r),
				this._onDidChangeAgents.fire(new tu(t, n)),
				q(() => {
					this._agents.delete(t.id), this._onDidChangeAgents.fire(void 0)
				})
			)
		}
		registerAgentCompletionProvider(t, n) {
			return (
				this._agentCompletionProviders.set(t, n),
				{
					dispose: () => {
						this._agentCompletionProviders.delete(t)
					},
				}
			)
		}
		async getAgentCompletionItems(t, n, r) {
			return (await this._agentCompletionProviders.get(t)?.(n, r)) ?? []
		}
		updateAgent(t, n) {
			let r = this._agents.get(t)
			if (!r?.impl) throw new Error(`No activated agent with id ${JSON.stringify(t)} registered`)
			;(r.data.metadata = { ...r.data.metadata, ...n }), this._onDidChangeAgents.fire(new tu(r.data, r.impl))
		}
		getDefaultAgent(t, n = "ask") {
			return this._preferExtensionAgent(
				this.getActivatedAgents().filter((r) =>
					n && !r.modes.includes(n) ? !1 : !!r.isDefault && r.locations.includes(t),
				),
			)
		}
		get hasToolsAgent() {
			return !!this._hasToolsAgent
		}
		getContributedDefaultAgent(t) {
			return this._preferExtensionAgent(this.getAgents().filter((n) => !!n.isDefault && n.locations.includes(t)))
		}
		_preferExtensionAgent(t) {
			return w0(t, (n) => !n.isCore) ?? t.at(-1)
		}
		getAgent(t, n = !1) {
			if (!(!this._agentIsEnabled(t) && !n)) return this._agents.get(t)?.data
		}
		_agentIsEnabled(t) {
			let n = typeof t == "string" ? this._agents.get(t) : t
			return !n?.data.when || this.contextKeyService.contextMatchesRules(Lt.deserialize(n.data.when))
		}
		getAgentByFullyQualifiedId(t) {
			let n = kt.find(this._agents.values(), (r) => GV(r.data) === t)?.data
			if (!(n && !this._agentIsEnabled(n.id))) return n
		}
		getAgents() {
			return Array.from(this._agents.values())
				.map((t) => t.data)
				.filter((t) => this._agentIsEnabled(t.id))
		}
		getActivatedAgents() {
			return Array.from(this._agents.values())
				.filter((t) => !!t.impl)
				.filter((t) => this._agentIsEnabled(t.data.id))
				.map((t) => new tu(t.data, t.impl))
		}
		getAgentsByName(t) {
			return this._preferExtensionAgents(this.getAgents().filter((n) => n.name === t))
		}
		_preferExtensionAgents(t) {
			let n = t.filter((r) => !r.isCore)
			return n.length > 0 ? n : t
		}
		agentHasDupeName(t) {
			let n = this.getAgent(t)
			return n
				? this.getAgentsByName(n.name).filter((r) => r.extensionId.value !== n.extensionId.value).length > 0
				: !1
		}
		async invokeAgent(t, n, r, i, s) {
			let a = this._agents.get(t)
			if (!a?.impl) throw new Error(`No activated agent with id "${t}"`)
			return await a.impl.invoke(n, r, i, s)
		}
		setRequestPaused(t, n, r) {
			let i = this._agents.get(t)
			if (!i?.impl) throw new Error(`No activated agent with id "${t}"`)
			i.impl.setRequestPaused?.(n, r)
		}
		async getFollowups(t, n, r, i, s) {
			let a = this._agents.get(t)
			if (!a?.impl) throw new Error(`No activated agent with id "${t}"`)
			return a.impl?.provideFollowups ? a.impl.provideFollowups(n, r, i, s) : []
		}
		async getChatTitle(t, n, r) {
			let i = this._agents.get(t)
			if (!i?.impl) throw new Error(`No activated agent with id "${t}"`)
			if (i.impl?.provideChatTitle) return i.impl.provideChatTitle(n, r)
		}
		registerChatParticipantDetectionProvider(t, n) {
			return (
				this._chatParticipantDetectionProviders.set(t, n),
				q(() => {
					this._chatParticipantDetectionProviders.delete(t)
				})
			)
		}
		hasChatParticipantDetectionProviders() {
			return this._chatParticipantDetectionProviders.size > 0
		}
		async detectAgentOrCommand(t, n, r, i) {
			let s = kt.first(this._chatParticipantDetectionProviders.values())
			if (!s) return
			let a = this.getAgents().reduce((u, m) => {
					if (m.locations.includes(r.location)) {
						u.push({ participant: m.id, disambiguation: m.disambiguation ?? [] })
						for (let f of m.slashCommands)
							u.push({ participant: m.id, command: f.name, disambiguation: f.disambiguation ?? [] })
					}
					return u
				}, []),
				l = await s.provideParticipantDetection(t, n, { ...r, participants: a }, i)
			if (!l) return
			let d = this.getAgent(l.participant)
			if (!d) return
			if (!l.command) return { agent: d }
			let c = d?.slashCommands.find((u) => u.name === l.command)
			if (c) return { agent: d, command: c }
		}
	}
py = R([S(0, ca)], py)
var tu = class {
		constructor(e, t) {
			this.data = e
			this.impl = t
		}
		get id() {
			return this.data.id
		}
		get name() {
			return this.data.name ?? ""
		}
		get fullName() {
			return this.data.fullName ?? ""
		}
		get description() {
			return this.data.description ?? ""
		}
		get extensionId() {
			return this.data.extensionId
		}
		get extensionPublisherId() {
			return this.data.extensionPublisherId
		}
		get extensionPublisherDisplayName() {
			return this.data.publisherDisplayName
		}
		get extensionDisplayName() {
			return this.data.extensionDisplayName
		}
		get isDefault() {
			return this.data.isDefault
		}
		get isCore() {
			return this.data.isCore
		}
		get metadata() {
			return this.data.metadata
		}
		get slashCommands() {
			return this.data.slashCommands
		}
		get locations() {
			return this.data.locations
		}
		get modes() {
			return this.data.modes
		}
		get disambiguation() {
			return this.data.disambiguation
		}
		async invoke(e, t, n, r) {
			return this.impl.invoke(e, t, n, r)
		}
		setRequestPaused(e, t) {
			this.impl.setRequestPaused && this.impl.setRequestPaused(e, t)
		}
		async provideFollowups(e, t, n, r) {
			return this.impl.provideFollowups ? this.impl.provideFollowups(e, t, n, r) : []
		}
		provideSampleQuestions(e, t) {
			if (this.impl.provideSampleQuestions) return this.impl.provideSampleQuestions(e, t)
		}
		toJSON() {
			return this.data
		}
	},
	Xoe = O("chatAgentNameService"),
	Ia = class {
		constructor(e, t, n, r) {
			this.requestService = t
			this.logService = n
			this.storageService = r
			this.registry = ba(this, Object.create(null))
			this.disposed = !1
			if (!e.chatParticipantRegistry) return
			this.url = e.chatParticipantRegistry
			let i = r.get(Ia.StorageKey, -1)
			try {
				this.registry.set(JSON.parse(i ?? "{}"), void 0)
			} catch {
				r.remove(Ia.StorageKey, -1)
			}
			this.refresh()
		}
		static {
			this.StorageKey = "chat.participantNameRegistry"
		}
		refresh() {
			this.disposed ||
				this.update()
					.catch((e) => this.logService.warn("Failed to fetch chat participant registry", e))
					.then(() => Wt(300 * 1e3))
					.then(() => this.refresh())
		}
		async update() {
			let e = await this.requestService.request({ type: "GET", url: this.url }, De.None)
			if (e.res.statusCode !== 200) throw new Error("Could not get extensions report.")
			let t = await OM(e)
			if (!t || t.version !== 1) throw new Error("Unexpected chat participant registry response.")
			let n = t.restrictedChatParticipants
			this.registry.set(n, void 0), this.storageService.store(Ia.StorageKey, JSON.stringify(n), -1, 1)
		}
		getAgentNameRestriction(e) {
			if (e.isCore) return !0
			let t = this.checkAgentNameRestriction(e.name, e).get(),
				n = !e.fullName || this.checkAgentNameRestriction(e.fullName.replace(/\s/g, ""), e).get()
			return t && n
		}
		checkAgentNameRestriction(e, t) {
			return this.registry
				.map((r) => r[e.toLowerCase()])
				.map((r) =>
					r ? r.some((i) => xn(i, i.includes(".") ? t.extensionId.value : t.extensionPublisherId)) : !0,
				)
		}
		dispose() {
			this.disposed = !0
		}
	}
Ia = R([S(0, Yc), S(1, AM), S(2, te), S(3, uy)], Ia)
function GV(o) {
	return `${o.extensionId.value}.${o.id}`
}
function my(o) {
	let e = "name" in o ? o : { ...o, name: o.id }
	return (
		"extensionPublisherId" in e || (e.extensionPublisherId = e.extensionPublisher ?? ""),
		"extensionDisplayName" in e || (e.extensionDisplayName = ""),
		"extensionId" in e || (e.extensionId = new we("")),
		ut(e)
	)
}
var KM = O("chatEditingService")
var oie = new D(
		"chatEditingWidgetFileState",
		void 0,
		p("chatEditingWidgetFileState", "The current state of the file in the chat editing widget"),
	),
	iie = new D(
		"chatEditingAgentSupportsReadonlyReferences",
		void 0,
		p(
			"chatEditingAgentSupportsReadonlyReferences",
			"Whether the chat editing agent supports readonly references (temporary)",
		),
	),
	sie = new D("decidedChatEditingResource", []),
	aie = new D("chatEditingResource", void 0),
	lie = new D("inChatEditingSession", void 0),
	die = new D("hasUndecidedChatEditingResource", !1),
	cie = new D("hasAppliedChatEdits", !1),
	uie = new D("applyingChatEditsFailed", !1)
var nu = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.text = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "text"
		}
		get promptText() {
			return this.text
		}
	},
	m_ = "#",
	QV = "@",
	p_ = "/",
	fy = class o {
		constructor(e, t, n, r, i) {
			this.range = e
			this.editorRange = t
			this.variableName = n
			this.variableArg = r
			this.variableId = i
			this.kind = o.Kind
		}
		static {
			this.Kind = "var"
		}
		get text() {
			let e = this.variableArg ? `:${this.variableArg}` : ""
			return `${m_}${this.variableName}${e}`
		}
		get promptText() {
			return this.text
		}
	},
	gy = class o {
		constructor(e, t, n, r, i, s) {
			this.range = e
			this.editorRange = t
			this.toolName = n
			this.toolId = r
			this.displayName = i
			this.icon = s
			this.kind = o.Kind
		}
		static {
			this.Kind = "tool"
		}
		get text() {
			return `${m_}${this.toolName}`
		}
		get promptText() {
			return this.text
		}
		toVariableEntry() {
			return {
				id: this.toolId,
				name: this.toolName,
				range: this.range,
				value: void 0,
				isTool: !0,
				icon: Yt.isThemeIcon(this.icon) ? this.icon : void 0,
				fullName: this.displayName,
			}
		}
	},
	hy = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.agent = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "agent"
		}
		get text() {
			return `${QV}${this.agent.name}`
		}
		get promptText() {
			return ""
		}
	},
	vy = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.command = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "subcommand"
		}
		get text() {
			return `${p_}${this.command.name}`
		}
		get promptText() {
			return ""
		}
	},
	by = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.slashCommand = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "slash"
		}
		get text() {
			return `${p_}${this.slashCommand.command}`
		}
		get promptText() {
			return `${p_}${this.slashCommand.command}`
		}
	},
	yy = class o {
		constructor(e, t, n, r, i, s, a, l, d, c) {
			this.range = e
			this.editorRange = t
			this.text = n
			this.id = r
			this.modelDescription = i
			this.data = s
			this.fullName = a
			this.icon = l
			this.isFile = d
			this.isDirectory = c
			this.kind = o.Kind
		}
		static {
			this.Kind = "dynamic"
		}
		get referenceText() {
			return this.text.replace(m_, "")
		}
		get promptText() {
			return this.text
		}
		toVariableEntry() {
			return this.id === "vscode.problems"
				? f_.toEntry(this.data.filter)
				: {
						id: this.id,
						name: this.referenceText,
						range: this.range,
						value: this.data,
						fullName: this.fullName,
						icon: this.icon,
						isFile: this.isFile,
						isDirectory: this.isDirectory,
					}
		}
	}
function jM(o) {
	return {
		text: o.text,
		parts: o.parts.map((e) => {
			if (e.kind === nu.Kind) return new nu(new Qr(e.range.start, e.range.endExclusive), e.editorRange, e.text)
			if (e.kind === fy.Kind)
				return new fy(
					new Qr(e.range.start, e.range.endExclusive),
					e.editorRange,
					e.variableName,
					e.variableArg,
					e.variableId || "",
				)
			if (e.kind === gy.Kind)
				return new gy(
					new Qr(e.range.start, e.range.endExclusive),
					e.editorRange,
					e.toolName,
					e.toolId,
					e.displayName,
					e.icon,
				)
			if (e.kind === hy.Kind) {
				let t = e.agent
				return (t = my(t)), new hy(new Qr(e.range.start, e.range.endExclusive), e.editorRange, t)
			} else {
				if (e.kind === vy.Kind)
					return new vy(new Qr(e.range.start, e.range.endExclusive), e.editorRange, e.command)
				if (e.kind === by.Kind)
					return new by(new Qr(e.range.start, e.range.endExclusive), e.editorRange, e.slashCommand)
				if (e.kind === yy.Kind)
					return new yy(
						new Qr(e.range.start, e.range.endExclusive),
						e.editorRange,
						e.text,
						e.id,
						e.modelDescription,
						ut(e.data),
						e.fullName,
						e.icon,
						e.isFile,
						e.isDirectory,
					)
				throw new Error(`Unknown chat request part: ${e.kind}`)
			}
		}),
	}
}
function JV(o) {
	return (
		!!o &&
		typeof o == "object" &&
		"uri" in o &&
		o.uri instanceof y &&
		"version" in o &&
		typeof o.version == "number" &&
		"ranges" in o &&
		Array.isArray(o.ranges) &&
		o.ranges.every(Re.isIRange)
	)
}
function GM(o) {
	return !!o && typeof o == "object" && "documents" in o && Array.isArray(o.documents) && o.documents.every(JV)
}
var QM = O("IChatService")
var f_
;((i) => {
	i.icon = ce.error
	function e(s) {
		return {
			filterUri: s.resource,
			owner: s.owner,
			problemMessage: s.message,
			filterRange: {
				startLineNumber: s.startLineNumber,
				endLineNumber: s.endLineNumber,
				startColumn: s.startColumn,
				endColumn: s.endColumn,
			},
		}
	}
	i.fromMarker = e
	function t(s) {
		return {
			id: n(s),
			name: r(s),
			icon: i.icon,
			value: s,
			kind: "diagnostic",
			range: s.filterRange ? new Qr(s.filterRange.startLineNumber, s.filterRange.endLineNumber) : void 0,
			...s,
		}
	}
	i.toEntry = t
	function n(s) {
		return [s.filterUri, s.owner, s.filterSeverity, s.filterRange?.startLineNumber].join(":")
	}
	i.id = n
	function r(s) {
		let a
		if (
			(((u) => ((u[(u.MaxChars = 30)] = "MaxChars"), (u[(u.MaxSpaceLookback = 10)] = "MaxSpaceLookback")))(
				(a ||= {}),
			),
			s.problemMessage)
		) {
			if (s.problemMessage.length < 30) return s.problemMessage
			let d = s.problemMessage.lastIndexOf(" ", 30)
			return d === -1 || d + 10 < 30
				? s.problemMessage.substring(0, 30) + "\u2026"
				: s.problemMessage.substring(0, d) + "\u2026"
		}
		let l = p("chat.attachment.problems.all", "All Problems")
		return s.filterUri && (l = p("chat.attachment.problems.inFile", "Problems in {0}", Ht(s.filterUri))), l
	}
	i.label = r
})((f_ ||= {}))
function JM(o) {
	return o.kind === "image"
}
var Mr = { reason: "other" },
	xy = class {
		get session() {
			return this._session
		}
		get username() {
			return this.session.requesterUsername
		}
		get avatarIconUri() {
			return this.session.requesterAvatarIconUri
		}
		get attempt() {
			return this._attempt
		}
		get variableData() {
			return this._variableData
		}
		set variableData(e) {
			this._variableData = e
		}
		get confirmation() {
			return this._confirmation
		}
		get locationData() {
			return this._locationData
		}
		get attachedContext() {
			return this._attachedContext
		}
		constructor(e) {
			;(this._session = e.session),
				(this.message = e.message),
				(this._variableData = e.variableData),
				(this.timestamp = e.timestamp),
				(this._attempt = e.attempt ?? 0),
				(this._confirmation = e.confirmation),
				(this._locationData = e.locationData),
				(this._attachedContext = e.attachedContext),
				(this.isCompleteAddedRequest = e.isCompleteAddedRequest ?? !1),
				(this.modelId = e.modelId),
				(this.id = e.restoredId ?? "request_" + He())
		}
		adoptTo(e) {
			this._session = e
		}
	},
	Cy = class {
		constructor(e) {
			this._responseRepr = ""
			this._markdownContent = ""
			;(this._responseParts = e), this._updateRepr()
		}
		get value() {
			return this._responseParts
		}
		toString() {
			return this._responseRepr
		}
		getMarkdown() {
			return this._markdownContent
		}
		_updateRepr() {
			;(this._responseRepr = this.partsToRepr(this._responseParts)),
				(this._markdownContent = this._responseParts
					.map((e) =>
						e.kind === "inlineReference"
							? this.inlineRefToRepr(e)
							: e.kind === "markdownContent" || e.kind === "markdownVuln"
								? e.content.value
								: "",
					)
					.filter((e) => e.length > 0)
					.join(""))
		}
		partsToRepr(e) {
			let t = [],
				n = []
			for (let r of e) {
				let i
				switch (r.kind) {
					case "treeData":
					case "progressMessage":
					case "codeblockUri":
					case "toolInvocation":
					case "toolInvocationSerialized":
					case "undoStop":
						continue
					case "inlineReference":
						i = { text: this.inlineRefToRepr(r) }
						break
					case "command":
						i = { text: r.command.title, isBlock: !0 }
						break
					case "textEditGroup":
					case "notebookEditGroup":
						i = { text: p("editsSummary", "Made changes."), isBlock: !0 }
						break
					case "confirmation":
						i = {
							text: `${r.title}
${r.message}`,
							isBlock: !0,
						}
						break
					default:
						i = { text: r.content.value }
						break
				}
				i.isBlock ? (n.length && (t.push(n.join("")), (n = [])), t.push(i.text)) : n.push(i.text)
			}
			return (
				n.length && t.push(n.join("")),
				t.join(`

`)
			)
		}
		inlineRefToRepr(e) {
			return "uri" in e.inlineReference
				? this.uriToRepr(e.inlineReference.uri)
				: "name" in e.inlineReference
					? "`" + e.inlineReference.name + "`"
					: this.uriToRepr(e.inlineReference)
		}
		uriToRepr(e) {
			return e.scheme === W.http || e.scheme === W.https ? e.toString(!1) : Ht(e)
		}
	},
	g_ = class extends Cy {
		constructor(t, n) {
			let r = t.value.findIndex((i) => i.kind === "undoStop" && i.id === n)
			super(r === -1 ? t.value.slice() : t.value.slice(0, r))
			this.undoStop = n
		}
	},
	h_ = class extends Cy {
		constructor(t) {
			super(
				an(t).map((n) =>
					Kr(n)
						? { content: n, kind: "markdownContent" }
						: "kind" in n
							? n
							: { kind: "treeData", treeData: n },
				),
			)
			this._onDidChangeValue = new E()
			this._citations = []
		}
		get onDidChangeValue() {
			return this._onDidChangeValue.event
		}
		dispose() {
			this._onDidChangeValue.dispose()
		}
		clear() {
			;(this._responseParts = []), this._updateRepr(!0)
		}
		updateContent(t, n) {
			if (t.kind === "markdownContent") {
				let r = this._responseParts.filter((i) => i.kind !== "textEditGroup").at(-1)
				if (!r || r.kind !== "markdownContent" || !ZV(r.content, t.content)) this._responseParts.push(t)
				else {
					let i = this._responseParts.indexOf(r)
					this._responseParts[i] = { ...r, content: e7(r.content, t.content) }
				}
				this._updateRepr(n)
			} else if (t.kind === "textEdit" || t.kind === "notebookEdit") {
				let i =
						t.uri.scheme === W.vscodeNotebookCell &&
						!this._responseParts.find((c) => c.kind === "notebookEditGroup")
							? void 0
							: Jf.parse(t.uri)?.notebook,
					s = i ?? t.uri,
					a = !1,
					l = t.kind === "textEdit" && !i ? "textEditGroup" : "notebookEditGroup",
					d =
						l === "textEditGroup"
							? t.edits
							: t.edits.map((c) => (_b.isTextEdit(c) ? { uri: t.uri, edit: c } : c))
				for (let c = 0; !a && c < this._responseParts.length; c++) {
					let u = this._responseParts[c]
					u.kind === l && !u.done && qr(u.uri, s) && (u.edits.push(d), (u.done = t.done), (a = !0))
				}
				a ||
					this._responseParts.push({ kind: l, uri: s, edits: l === "textEditGroup" ? [d] : d, done: t.done }),
					this._updateRepr(n)
			} else if (t.kind === "progressTask") {
				let r = this._responseParts.push(t) - 1
				this._updateRepr(n)
				let i = t.onDidAddProgress(() => {
					this._updateRepr(!1)
				})
				t.task?.().then((s) => {
					i.dispose(),
						typeof s == "string" && (this._responseParts[r].content = new Vo(s)),
						this._updateRepr(!1)
				})
			} else
				t.kind === "toolInvocation"
					? (t.confirmationMessages &&
							t.confirmed.p.then(() => {
								this._updateRepr(!1)
							}),
						t.isCompletePromise.then(() => {
							this._updateRepr(!1)
						}),
						this._responseParts.push(t),
						this._updateRepr(n))
					: (this._responseParts.push(t), this._updateRepr(n))
		}
		addCitation(t) {
			this._citations.push(t), this._updateRepr()
		}
		_updateRepr(t) {
			super._updateRepr(),
				this._onDidChangeValue &&
					((this._responseRepr += this._citations.length
						? `

` + t7(this._citations)
						: ""),
					t || this._onDidChangeValue.fire())
		}
	},
	ru = class extends $ {
		constructor(t) {
			super()
			this._onDidChange = this._register(new E())
			this.onDidChange = this._onDidChange.event
			this._contentReferences = []
			this._codeCitations = []
			this._progressMessages = []
			this._isStale = !1
			this._isPaused = ba("isPaused", !1)
			;(this._session = t.session),
				(this._agent = t.agent),
				(this._slashCommand = t.slashCommand),
				(this.requestId = t.requestId),
				(this._isComplete = t.isComplete ?? !1),
				(this._isCanceled = t.isCanceled ?? !1),
				(this._vote = t.vote),
				(this._voteDownReason = t.voteDownReason),
				(this._result = t.result),
				(this._followups = t.followups ? [...t.followups] : void 0),
				(this.isCompleteAddedRequest = t.isCompleteAddedRequest ?? !1),
				(this._shouldBeRemovedOnSend = t.shouldBeRemovedOnSend),
				(this._isStale =
					Array.isArray(t.responseContent) &&
					(t.responseContent.length !== 0 ||
						(Kr(t.responseContent) && t.responseContent.value.length !== 0))),
				(this._response = this._register(new h_(t.responseContent))),
				this._register(this._response.onDidChangeValue(() => this._onDidChange.fire(Mr))),
				(this.id = t.restoredId ?? "response_" + He())
		}
		get session() {
			return this._session
		}
		get shouldBeRemovedOnSend() {
			return this._shouldBeRemovedOnSend
		}
		get isComplete() {
			return this._isComplete
		}
		set shouldBeRemovedOnSend(t) {
			;(this._shouldBeRemovedOnSend = t), this._onDidChange.fire(Mr)
		}
		get isCanceled() {
			return this._isCanceled
		}
		get vote() {
			return this._vote
		}
		get voteDownReason() {
			return this._voteDownReason
		}
		get followups() {
			return this._followups
		}
		get entireResponse() {
			return this._finalizedResponse || this._response
		}
		get result() {
			return this._result
		}
		get username() {
			return this.session.responderUsername
		}
		get avatarIcon() {
			return this.session.responderAvatarIcon
		}
		get agent() {
			return this._agent
		}
		get slashCommand() {
			return this._slashCommand
		}
		get agentOrSlashCommandDetected() {
			return this._agentOrSlashCommandDetected ?? !1
		}
		get usedContext() {
			return this._usedContext
		}
		get contentReferences() {
			return Array.from(this._contentReferences)
		}
		get codeCitations() {
			return this._codeCitations
		}
		get progressMessages() {
			return this._progressMessages
		}
		get isStale() {
			return this._isStale
		}
		get isPaused() {
			return this._isPaused
		}
		get isPendingConfirmation() {
			return this._response.value.some(
				(t) =>
					(t.kind === "toolInvocation" && t.isConfirmed === void 0) ||
					(t.kind === "confirmation" && t.isUsed === !1),
			)
		}
		get response() {
			let t = this._shouldBeRemovedOnSend?.afterUndoStop
			return t
				? (this._responseView?.undoStop !== t && (this._responseView = new g_(this._response, t)),
					this._responseView)
				: this._finalizedResponse || this._response
		}
		updateContent(t, n) {
			this.bufferWhenPaused(() => this._response.updateContent(t, n))
		}
		addUndoStop(t) {
			this.bufferWhenPaused(() => {
				this._onDidChange.fire({ reason: "undoStop", id: t.id }), this._response.updateContent(t, !0)
			})
		}
		applyReference(t) {
			t.kind === "usedContext"
				? (this._usedContext = t)
				: t.kind === "reference" && (this._contentReferences.push(t), this._onDidChange.fire(Mr))
		}
		applyCodeCitation(t) {
			this._codeCitations.push(t), this._response.addCitation(t), this._onDidChange.fire(Mr)
		}
		setAgent(t, n) {
			;(this._agent = t),
				(this._slashCommand = n),
				(this._agentOrSlashCommandDetected = !t.isDefault || !!n),
				this._onDidChange.fire(Mr)
		}
		setResult(t) {
			;(this._result = t), this._onDidChange.fire(Mr)
		}
		complete() {
			this._result?.errorDetails?.responseIsRedacted && this._response.clear(),
				(this._isComplete = !0),
				this._onDidChange.fire(Mr)
		}
		cancel() {
			;(this._isComplete = !0), (this._isCanceled = !0), this._onDidChange.fire(Mr)
		}
		setFollowups(t) {
			;(this._followups = t), this._onDidChange.fire(Mr)
		}
		setVote(t) {
			;(this._vote = t), this._onDidChange.fire(Mr)
		}
		setVoteDownReason(t) {
			;(this._voteDownReason = t), this._onDidChange.fire(Mr)
		}
		setEditApplied(t, n) {
			return !this.response.value.includes(t) || !t.state
				? !1
				: ((t.state.applied = n), this._onDidChange.fire(Mr), !0)
		}
		adoptTo(t) {
			;(this._session = t), this._onDidChange.fire(Mr)
		}
		setPaused(t, n) {
			this._isPaused.set(t, n),
				this._onDidChange.fire(Mr),
				this.bufferedPauseContent?.forEach((r) => r()),
				(this.bufferedPauseContent = void 0)
		}
		finalizeUndoState() {
			;(this._finalizedResponse = this.response),
				(this._responseView = void 0),
				(this._shouldBeRemovedOnSend = void 0)
		}
		bufferWhenPaused(t) {
			this._isPaused.get() ? ((this.bufferedPauseContent ??= []), this.bufferedPauseContent.push(t)) : t()
		}
	}
function XV(o) {
	let e = o
	return typeof e == "object" && typeof e.requesterUsername == "string"
}
function YV(o) {
	let e = o
	return (
		XV(o) &&
		typeof e.creationDate == "number" &&
		typeof e.sessionId == "string" &&
		o.requests.every((t) => !t.usedContext || GM(t.usedContext))
	)
}
var Iy = ((n) => (
		(n[(n.Created = 0)] = "Created"),
		(n[(n.Initializing = 1)] = "Initializing"),
		(n[(n.Initialized = 2)] = "Initialized"),
		n
	))(Iy || {}),
	ou = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.initialData = t
			this._initialLocation = n
			this.logService = r
			this.chatAgentService = i
			this.chatEditingService = s
			this._onDidDispose = this._register(new E())
			this.onDidDispose = this._onDidDispose.event
			this._onDidChange = this._register(new E())
			this.onDidChange = this._onDidChange.event
			this._initState = 0
			this._isInitializedDeferred = new Cn()
			this._isImported = !1
			this._checkpoint = void 0
			let a = YV(t)
			t &&
				!a &&
				this.logService.warn(`ChatModel#constructor: Loaded malformed session data: ${JSON.stringify(t)}`),
				(this._isImported = (!!t && !a) || (t?.isImported ?? !1)),
				(this._sessionId = (a && t.sessionId) || He()),
				(this._requests = t ? this._deserialize(t) : []),
				(this._creationDate = (a && t.creationDate) || Date.now()),
				(this._lastMessageDate = (a && t.lastMessageDate) || this._creationDate),
				(this._customTitle = a ? t.customTitle : void 0),
				(this._initialRequesterAvatarIconUri = t?.requesterAvatarIconUri && y.revive(t.requesterAvatarIconUri)),
				(this._initialResponderAvatarIconUri = df(t?.responderAvatarIconUri)
					? y.revive(t.responderAvatarIconUri)
					: t?.responderAvatarIconUri)
		}
		static getDefaultTitle(t) {
			let n = t.at(0)?.message ?? ""
			return (typeof n == "string" ? n : n.text)
				.split(
					`
`,
				)[0]
				.substring(0, 50)
		}
		get sampleQuestions() {
			return this._sampleQuestions
		}
		get sessionId() {
			return this._sessionId
		}
		get requestInProgress() {
			let t = this.lastRequest
			return !t?.response || t.response.isPendingConfirmation ? !1 : !t.response.isComplete
		}
		get requestPausibility() {
			let t = this.lastRequest
			return !t?.response?.agent || t.response.isComplete || t.response.isPendingConfirmation
				? 0
				: t.response.isPaused.get()
					? 1
					: 2
		}
		get hasRequests() {
			return this._requests.length > 0
		}
		get lastRequest() {
			return this._requests.at(-1)
		}
		get creationDate() {
			return this._creationDate
		}
		get lastMessageDate() {
			return this._lastMessageDate
		}
		get _defaultAgent() {
			return this.chatAgentService.getDefaultAgent("panel", "ask")
		}
		get requesterUsername() {
			return this._defaultAgent?.metadata.requester?.name ?? this.initialData?.requesterUsername ?? ""
		}
		get responderUsername() {
			return this._defaultAgent?.fullName ?? this.initialData?.responderUsername ?? ""
		}
		get requesterAvatarIconUri() {
			return this._defaultAgent?.metadata.requester?.icon ?? this._initialRequesterAvatarIconUri
		}
		get responderAvatarIcon() {
			return this._defaultAgent?.metadata.themeIcon ?? this._initialResponderAvatarIconUri
		}
		get initState() {
			return this._initState
		}
		get isImported() {
			return this._isImported
		}
		get customTitle() {
			return this._customTitle
		}
		get title() {
			return this._customTitle || ou.getDefaultTitle(this._requests)
		}
		get initialLocation() {
			return this._initialLocation
		}
		get editingSessionObs() {
			return this._editingSession
		}
		get editingSession() {
			return this._editingSession?.promiseResult.get()?.data
		}
		startEditingSession(t) {
			let n = t
				? this.chatEditingService.startOrContinueGlobalEditingSession(this)
				: this.chatEditingService.createEditingSession(this)
			;(this._editingSession = new jf(n)),
				this._editingSession.promise.then((r) => (this._store.isDisposed ? r.dispose() : this._register(r)))
		}
		_deserialize(t) {
			let n = t.requests
			if (!Array.isArray(n))
				return this.logService.error(`Ignoring malformed session data: ${JSON.stringify(t)}`), []
			try {
				return n.map((r) => {
					let i = typeof r.message == "string" ? this.getParsedRequestFromString(r.message) : jM(r.message),
						s = this.reviveVariableData(r.variableData),
						a = new xy({
							session: this,
							message: i,
							variableData: s,
							timestamp: r.timestamp ?? -1,
							restoredId: r.requestId,
						})
					if (
						((a.shouldBeRemovedOnSend = r.isHidden ? { requestId: r.requestId } : r.shouldBeRemovedOnSend),
						r.response || r.result || r.responseErrorDetails)
					) {
						let l = r.agent && "metadata" in r.agent ? my(r.agent) : void 0,
							d = "responseErrorDetails" in r ? { errorDetails: r.responseErrorDetails } : r.result
						;(a.response = new ru({
							responseContent: r.response ?? [new Vo(r.response)],
							session: this,
							agent: l,
							slashCommand: r.slashCommand,
							requestId: a.id,
							isComplete: !0,
							isCanceled: r.isCanceled,
							vote: r.vote,
							voteDownReason: r.voteDownReason,
							result: d,
							followups: r.followups,
							restoredId: r.responseId,
						})),
							(a.response.shouldBeRemovedOnSend = r.isHidden
								? { requestId: r.requestId }
								: r.shouldBeRemovedOnSend),
							r.usedContext && a.response.applyReference(ut(r.usedContext)),
							r.contentReferences?.forEach((c) => a.response.applyReference(ut(c))),
							r.codeCitations?.forEach((c) => a.response.applyCodeCitation(ut(c)))
					}
					return a
				})
			} catch (r) {
				return this.logService.error("Failed to parse chat data", r), []
			}
		}
		reviveVariableData(t) {
			let n = t && Array.isArray(t.variables) ? t : { variables: [] }
			return (
				(n.variables = n.variables.map((r) =>
					r && "values" in r && Array.isArray(r.values)
						? {
								id: r.id ?? "",
								name: r.name,
								value: r.values[0]?.value,
								range: r.range,
								modelDescription: r.modelDescription,
								references: r.references,
							}
						: r,
				)),
				n
			)
		}
		getParsedRequestFromString(t) {
			let n = [
				new nu(new Qr(0, t.length), { startColumn: 1, startLineNumber: 1, endColumn: 1, endLineNumber: 1 }, t),
			]
			return { text: t, parts: n }
		}
		toggleLastRequestPaused(t) {
			if (this.requestPausibility !== 0 && this.lastRequest?.response?.agent) {
				let n = t ?? !this.lastRequest.response.isPaused.get()
				this.lastRequest.response.setPaused(n),
					this.chatAgentService.setRequestPaused(this.lastRequest.response.agent.id, this.lastRequest.id, n),
					this._onDidChange.fire({ kind: "changedRequest", request: this.lastRequest })
			}
		}
		startInitialize() {
			if (this.initState !== 0)
				throw new Error(`ChatModel is in the wrong state for startInitialize: ${Iy[this.initState]}`)
			this._initState = 1
		}
		deinitialize() {
			;(this._initState = 0), (this._isInitializedDeferred = new Cn())
		}
		initialize(t) {
			if (this.initState !== 1)
				throw new Error(`ChatModel is in the wrong state for initialize: ${Iy[this.initState]}`)
			;(this._initState = 2),
				(this._sampleQuestions = t),
				this._isInitializedDeferred.complete(),
				this._onDidChange.fire({ kind: "initialize" })
		}
		setInitializationError(t) {
			if (this.initState !== 1)
				throw new Error(`ChatModel is in the wrong state for setInitializationError: ${Iy[this.initState]}`)
			this._isInitializedDeferred.isSettled || this._isInitializedDeferred.error(t)
		}
		waitForInitialization() {
			return this._isInitializedDeferred.p
		}
		getRequests() {
			return this._requests
		}
		get checkpoint() {
			return this._checkpoint
		}
		setDisabledRequests(t) {
			this._requests.forEach((n) => {
				let r = t.find((i) => i.requestId === n.id)
				;(n.shouldBeRemovedOnSend = r), n.response && (n.response.shouldBeRemovedOnSend = r)
			}),
				this._onDidChange.fire({ kind: "setHidden", hiddenRequestIds: t })
		}
		addRequest(t, n, r, i, s, a, l, d, c, u) {
			let m = new xy({
				session: this,
				message: t,
				variableData: n,
				timestamp: Date.now(),
				attempt: r,
				confirmation: a,
				locationData: l,
				attachedContext: d,
				isCompleteAddedRequest: c,
				modelId: u,
			})
			return (
				(m.response = new ru({
					responseContent: [],
					session: this,
					agent: i,
					slashCommand: s,
					requestId: m.id,
					isCompleteAddedRequest: c,
				})),
				this._requests.push(m),
				(this._lastMessageDate = Date.now()),
				this._onDidChange.fire({ kind: "addRequest", request: m }),
				m
			)
		}
		setCustomTitle(t) {
			this._customTitle = t
		}
		updateRequest(t, n) {
			;(t.variableData = n), this._onDidChange.fire({ kind: "changedRequest", request: t })
		}
		adoptRequest(t) {
			let n = t.session,
				r = n._requests.findIndex((i) => i.id === t.id)
			r !== -1 &&
				(n._requests.splice(r, 1),
				t.adoptTo(this),
				t.response?.adoptTo(this),
				this._requests.push(t),
				n._onDidChange.fire({ kind: "removeRequest", requestId: t.id, responseId: t.response?.id, reason: 2 }),
				this._onDidChange.fire({ kind: "addRequest", request: t }))
		}
		acceptResponseProgress(t, n, r) {
			if (
				(t.response || (t.response = new ru({ responseContent: [], session: this, requestId: t.id })),
				t.response.isComplete)
			)
				throw new Error("acceptResponseProgress: Adding progress to a completed response")
			n.kind === "markdownContent" ||
			n.kind === "treeData" ||
			n.kind === "inlineReference" ||
			n.kind === "codeblockUri" ||
			n.kind === "markdownVuln" ||
			n.kind === "progressMessage" ||
			n.kind === "command" ||
			n.kind === "textEdit" ||
			n.kind === "notebookEdit" ||
			n.kind === "warning" ||
			n.kind === "progressTask" ||
			n.kind === "confirmation" ||
			n.kind === "toolInvocation"
				? t.response.updateContent(n, r)
				: n.kind === "usedContext" || n.kind === "reference"
					? t.response.applyReference(n)
					: n.kind === "codeCitation"
						? t.response.applyCodeCitation(n)
						: n.kind === "move"
							? this._onDidChange.fire({ kind: "move", target: n.uri, range: n.range })
							: n.kind === "undoStop"
								? t.response.addUndoStop(n)
								: this.logService.error(`Couldn't handle progress: ${JSON.stringify(n)}`)
		}
		removeRequest(t, n = 0) {
			let r = this._requests.findIndex((s) => s.id === t),
				i = this._requests[r]
			r !== -1 &&
				(this._onDidChange.fire({
					kind: "removeRequest",
					requestId: i.id,
					responseId: i.response?.id,
					reason: n,
				}),
				this._requests.splice(r, 1),
				i.response?.dispose())
		}
		cancelRequest(t) {
			t.response && t.response.cancel()
		}
		setResponse(t, n) {
			t.response || (t.response = new ru({ responseContent: [], session: this, requestId: t.id })),
				t.response.setResult(n)
		}
		completeResponse(t) {
			if (!t.response) throw new Error("Call setResponse before completeResponse")
			t.response.complete(), this._onDidChange.fire({ kind: "completedRequest", request: t })
		}
		setFollowups(t, n) {
			t.response && t.response.setFollowups(n)
		}
		setResponseModel(t, n) {
			;(t.response = n), this._onDidChange.fire({ kind: "addResponse", response: n })
		}
		toExport() {
			return {
				requesterUsername: this.requesterUsername,
				requesterAvatarIconUri: this.requesterAvatarIconUri,
				responderUsername: this.responderUsername,
				responderAvatarIconUri: this.responderAvatarIcon,
				initialLocation: this.initialLocation,
				requests: this._requests.map((t) => {
					let n = { ...t.message, parts: t.message.parts.map((s) => (s && "toJSON" in s ? s.toJSON() : s)) },
						r = t.response?.agent,
						i = r && "toJSON" in r ? r.toJSON() : r ? { ...r } : void 0
					return {
						requestId: t.id,
						message: n,
						variableData: t.variableData,
						response: t.response
							? t.response.entireResponse.value.map((s) =>
									s.kind === "treeData" ? s.treeData : s.kind === "markdownContent" ? s.content : s,
								)
							: void 0,
						responseId: t.response?.id,
						shouldBeRemovedOnSend: t.shouldBeRemovedOnSend,
						result: t.response?.result,
						followups: t.response?.followups,
						isCanceled: t.response?.isCanceled,
						vote: t.response?.vote,
						voteDownReason: t.response?.voteDownReason,
						agent: i,
						slashCommand: t.response?.slashCommand,
						usedContext: t.response?.usedContext,
						contentReferences: t.response?.contentReferences,
						codeCitations: t.response?.codeCitations,
						timestamp: t.timestamp,
					}
				}),
			}
		}
		toJSON() {
			return {
				version: 3,
				...this.toExport(),
				sessionId: this.sessionId,
				creationDate: this._creationDate,
				isImported: this._isImported,
				lastMessageDate: this._lastMessageDate,
				customTitle: this._customTitle,
			}
		}
		dispose() {
			this._requests.forEach((t) => t.response?.dispose()), this._onDidDispose.fire(), super.dispose()
		}
	}
ou = R([S(2, te), S(3, qM), S(4, KM)], ou)
function ZV(o, e) {
	if (o.baseUri && e.baseUri) {
		if (
			!(
				o.baseUri.scheme === e.baseUri.scheme &&
				o.baseUri.authority === e.baseUri.authority &&
				o.baseUri.path === e.baseUri.path &&
				o.baseUri.query === e.baseUri.query &&
				o.baseUri.fragment === e.baseUri.fragment
			)
		)
			return !1
	} else if (o.baseUri || e.baseUri) return !1
	return (
		nn(o.isTrusted, e.isTrusted) && o.supportHtml === e.supportHtml && o.supportThemeIcons === e.supportThemeIcons
	)
}
function e7(o, e) {
	let t = typeof e == "string" ? e : e.value
	return {
		value: o.value + t,
		isTrusted: o.isTrusted,
		supportThemeIcons: o.supportThemeIcons,
		supportHtml: o.supportHtml,
		baseUri: o.baseUri,
	}
}
function t7(o) {
	if (o.length === 0) return ""
	let e = o.reduce((n, r) => n.add(r.license), new Set())
	return e.size === 1
		? p("codeCitation", "Similar code found with 1 license type", e.size)
		: p("codeCitations", "Similar code found with {0} license types", e.size)
}
var Sy = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$",
	eae = new RegExp(Sy)
var tae = O("extensionGalleryService")
var nae = O("extensionManagementService")
var rae = O("IGlobalExtensionEnablementService"),
	oae = O("IExtensionTipsService"),
	iae = O("IAllowedExtensionsService")
var sae = ef("extensions", "Extensions"),
	aae = ef("preferences", "Preferences")
var n7 = "extensions.allowed"
yt.as(go.Configuration).registerConfiguration({
	id: "extensions",
	order: 30,
	title: p("extensionsConfigurationTitle", "Extensions"),
	type: "object",
	properties: {
		[n7]: {
			type: "object",
			markdownDescription: p(
				"extensions.allowed",
				"Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. For more information on how to configure this setting, please visit the [Configure Allowed Extensions](https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions) section.",
			),
			default: "*",
			defaultSnippets: [
				{ body: {}, description: p("extensions.allowed.none", "No extensions are allowed.") },
				{ body: { "*": !0 }, description: p("extensions.allowed.all", "All extensions are allowed.") },
			],
			scope: 1,
			policy: {
				name: "AllowedExtensions",
				minimumVersion: "1.96",
				description: p(
					"extensions.allowed.policy",
					"Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. More information: https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions",
				),
			},
			additionalProperties: !1,
			patternProperties: {
				"([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
					anyOf: [
						{
							type: ["boolean", "string"],
							enum: [!0, !1, "stable"],
							description: p("extensions.allow.description", "Allow or disallow the extension."),
							enumDescriptions: [
								p("extensions.allowed.enable.desc", "Extension is allowed."),
								p("extensions.allowed.disable.desc", "Extension is not allowed."),
								p(
									"extensions.allowed.disable.stable.desc",
									"Allow only stable versions of the extension.",
								),
							],
						},
						{
							type: "array",
							items: { type: "string" },
							description: p(
								"extensions.allow.version.description",
								"Allow or disallow specific versions of the extension. To specifcy a platform specific version, use the format `platform@1.2.3`, e.g. `win32-x64@1.2.3`. Supported platforms are `win32-x64`, `win32-arm64`, `linux-x64`, `linux-arm64`, `linux-armhf`, `alpine-x64`, `alpine-arm64`, `darwin-x64`, `darwin-arm64`",
							),
						},
					],
				},
				"([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
					type: ["boolean", "string"],
					enum: [!0, !1, "stable"],
					description: p(
						"extension.publisher.allow.description",
						"Allow or disallow all extensions from the publisher.",
					),
					enumDescriptions: [
						p("extensions.publisher.allowed.enable.desc", "All extensions from the publisher are allowed."),
						p(
							"extensions.publisher.allowed.disable.desc",
							"All extensions from the publisher are not allowed.",
						),
						p(
							"extensions.publisher.allowed.disable.stable.desc",
							"Allow only stable versions of the extensions from the publisher.",
						),
					],
				},
				"\\*": {
					type: "boolean",
					enum: [!0, !1],
					description: p("extensions.allow.all.description", "Allow or disallow all extensions."),
					enumDescriptions: [
						p("extensions.allow.all.enable", "Allow all extensions."),
						p("extensions.allow.all.disable", "Disallow all extensions."),
					],
				},
			},
		},
	},
})
var gae = O("telemetryService"),
	hae = O("customEndpointTelemetryService")
var xa = class {
		constructor(e) {
			this.value = e
			this.isTrustedTelemetryValue = !0
		}
	},
	v_ = class {
		constructor() {
			this.telemetryLevel = 0
			this.sessionId = "someValue.sessionId"
			this.machineId = "someValue.machineId"
			this.sqmId = "someValue.sqmId"
			this.devDeviceId = "someValue.devDeviceId"
			this.firstSessionDate = "someValue.firstSessionDate"
			this.sendErrorTelemetry = !1
		}
		publicLog() {}
		publicLog2() {}
		publicLogError() {}
		publicLogError2() {}
		setExperimentProperty() {}
	},
	Oae = new v_()
var o7 = "telemetry",
	YM = { id: o7, name: p("telemetryLogName", "Telemetry") }
var i7 = new Set(["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"])
function ZM(o) {
	if (!o) return "none"
	let e = zl(o)
	return i7.has(e) ? e : "other"
}
function s7(o, e) {
	if (!o || (!o.includes("/") && !o.includes("\\"))) return o
	let t = o,
		n = []
	for (let a of e)
		for (;;) {
			let l = a.exec(o)
			if (!l) break
			n.push([l.index, a.lastIndex])
		}
	let r = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
		i = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g,
		s = 0
	for (t = ""; ; ) {
		let a = i.exec(o)
		if (!a) break
		let l = n.some(([d, c]) => a.index < c && d < i.lastIndex)
		!r.test(a[0]) && !l && ((t += o.substring(s, a.index) + "<REDACTED: user-file-path>"), (s = i.lastIndex))
	}
	return s < o.length && (t += o.substr(s)), t
}
function a7(o) {
	if (!o) return o
	let e = [
		{ label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
		{ label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
		{ label: "GitHub Token", regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
		{
			label: "Generic Secret",
			regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i,
		},
		{
			label: "CLI Credentials",
			regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/,
		},
		{ label: "Microsoft Entra ID", regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/ },
		{ label: "Email", regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ },
	]
	for (let t of e) if (t.regex.test(o)) return `<REDACTED: ${t.label}>`
	return o
}
function b_(o, e) {
	return ns(o, (t) => {
		if (t instanceof xa || Object.hasOwnProperty.call(t, "isTrustedTelemetryValue")) return t.value
		if (typeof t == "string") {
			let n = t.replaceAll("%20", " ")
			n = s7(n, e)
			for (let r of e) n = n.replace(r, "")
			return (n = a7(n)), n
		}
	})
}
var Jae = new we("pprice.better-merge")
var y_ = class {
		constructor() {
			this._generators = new Map()
			this._cache = new WeakMap()
		}
		register(e, t) {
			this._generators.set(e, t)
		}
		readActivationEvents(e) {
			return this._cache.has(e) || this._cache.set(e, this._readActivationEvents(e)), this._cache.get(e)
		}
		createActivationEventsMap(e) {
			let t = Object.create(null)
			for (let n of e) {
				let r = this.readActivationEvents(n)
				r.length > 0 && (t[we.toKey(n.identifier)] = r)
			}
			return t
		}
		_readActivationEvents(e) {
			if (typeof e.main > "u" && typeof e.browser > "u") return []
			let t = Array.isArray(e.activationEvents) ? e.activationEvents.slice(0) : []
			for (let n = 0; n < t.length; n++) t[n] === "onUri" && (t[n] = `onUri:${we.toKey(e.identifier)}`)
			if (!e.contributes) return t
			for (let n in e.contributes) {
				let r = this._generators.get(n)
				if (!r) continue
				let i = e.contributes[n],
					s = Array.isArray(i) ? i : [i]
				try {
					r(s, t)
				} catch (a) {
					Be(a)
				}
			}
			return t
		}
	},
	I_ = new y_()
var eF = Object.freeze({
	identifier: new we("nullExtensionDescription"),
	name: "Null Extension Description",
	version: "0.0.0",
	publisher: "vscode",
	engines: { vscode: "" },
	extensionLocation: y.parse("void:location"),
	isBuiltin: !1,
	targetPlatform: "undefined",
	isUserBuiltin: !1,
	isUnderDevelopment: !1,
	preRelease: !1,
})
var Ty = O("extensionService"),
	eg = class {
		constructor(e) {
			this.dependency = e
		}
	}
function nt(o, e) {
	return o.enabledApiProposals ? o.enabledApiProposals.includes(e) : !1
}
function M(o, e) {
	if (!nt(o, e))
		throw new Error(`Extension '${o.identifier.value}' CANNOT use API proposal: ${e}.
Its package.json#enabledApiProposals-property declares: ${o.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${e}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${o.identifier.value}`)
}
var l7 = {
		activeComment: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts",
		},
		aiRelatedInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts",
		},
		aiTextSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
			version: 2,
		},
		authLearnMore: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts",
		},
		authSession: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts",
		},
		canonicalUriProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts",
		},
		chatEditing: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts",
		},
		chatParticipantAdditions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts",
		},
		chatParticipantPrivate: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
			version: 7,
		},
		chatProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
		},
		chatReferenceBinaryData: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts",
		},
		chatReferenceDiagnostic: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceDiagnostic.d.ts",
		},
		chatStatusItem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatStatusItem.d.ts",
		},
		chatTab: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts",
		},
		codeActionAI: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts",
		},
		codeActionRanges: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts",
		},
		codiconDecoration: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts",
		},
		commentReactor: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts",
		},
		commentReveal: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts",
		},
		commentThreadApplicability: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts",
		},
		commentingRangeHint: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts",
		},
		commentsDraftState: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts",
		},
		contribAccessibilityHelpContent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts",
		},
		contribCommentEditorActionsMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts",
		},
		contribCommentPeekContext: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts",
		},
		contribCommentThreadAdditionalMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts",
		},
		contribCommentsViewThreadMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts",
		},
		contribDebugCreateConfiguration: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts",
		},
		contribDiffEditorGutterToolBarMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts",
		},
		contribEditSessions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts",
		},
		contribEditorContentMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts",
		},
		contribLabelFormatterWorkspaceTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts",
		},
		contribMenuBarHome: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts",
		},
		contribMergeEditorMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts",
		},
		contribMultiDiffEditorMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts",
		},
		contribNotebookStaticPreloads: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts",
		},
		contribRemoteHelp: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts",
		},
		contribShareMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts",
		},
		contribSourceControlHistoryItemMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts",
		},
		contribSourceControlHistoryTitleMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts",
		},
		contribSourceControlInputBoxMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts",
		},
		contribSourceControlTitleMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts",
		},
		contribStatusBarItems: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts",
		},
		contribViewContainerTitle: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts",
		},
		contribViewsRemote: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts",
		},
		contribViewsWelcome: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts",
		},
		customEditorMove: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts",
		},
		debugVisualization: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts",
		},
		defaultChatParticipant: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
			version: 4,
		},
		diffCommand: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts",
		},
		diffContentOptions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts",
		},
		documentFiltersExclusive: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts",
		},
		editSessionIdentityProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts",
		},
		editorHoverVerbosityLevel: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts",
		},
		editorInsets: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts",
		},
		embeddings: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts",
		},
		extensionRuntime: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts",
		},
		extensionsAny: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts",
		},
		externalUriOpener: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts",
		},
		fileSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts",
		},
		fileSearchProvider2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts",
		},
		findFiles2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
			version: 2,
		},
		findTextInFiles: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts",
		},
		findTextInFiles2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts",
		},
		fsChunks: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts",
		},
		idToken: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts",
		},
		inlineCompletionsAdditions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts",
		},
		inlineEdit: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts",
		},
		interactive: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts",
		},
		interactiveWindow: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts",
		},
		ipc: {
			proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts",
		},
		languageModelCapabilities: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelCapabilities.d.ts",
		},
		languageModelDataPart: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelDataPart.d.ts",
		},
		languageModelSystem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts",
		},
		languageStatusText: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts",
		},
		mappedEditsProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts",
		},
		mcpConfigurationProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mcpConfigurationProvider.d.ts",
		},
		multiDocumentHighlightProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts",
		},
		nativeWindowHandle: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts",
		},
		newSymbolNamesProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts",
		},
		notebookCellExecution: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts",
		},
		notebookCellExecutionState: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts",
		},
		notebookControllerAffinityHidden: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts",
		},
		notebookDeprecated: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts",
		},
		notebookExecution: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts",
		},
		notebookKernelSource: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts",
		},
		notebookLiveShare: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts",
		},
		notebookMessaging: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts",
		},
		notebookMime: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts",
		},
		notebookReplDocument: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts",
		},
		notebookVariableProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts",
		},
		portsAttributes: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts",
		},
		profileContentHandlers: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts",
		},
		quickDiffProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts",
		},
		quickInputButtonLocation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts",
		},
		quickPickItemTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts",
		},
		quickPickSortByLabel: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts",
		},
		resolvers: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts",
		},
		scmActionButton: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts",
		},
		scmHistoryProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts",
		},
		scmMultiDiffEditor: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts",
		},
		scmSelectedProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts",
		},
		scmTextDocument: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts",
		},
		scmValidation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts",
		},
		shareProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts",
		},
		speech: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts",
		},
		statusBarItemTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.statusBarItemTooltip.d.ts",
		},
		tabInputMultiDiff: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts",
		},
		tabInputTextMerge: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts",
		},
		taskPresentationGroup: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts",
		},
		taskProblemMatcherStatus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskProblemMatcherStatus.d.ts",
		},
		telemetry: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts",
		},
		terminalCompletionProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts",
		},
		terminalDataWriteEvent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts",
		},
		terminalDimensions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts",
		},
		terminalExecuteCommandEvent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts",
		},
		terminalQuickFixProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts",
		},
		terminalSelection: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts",
		},
		terminalShellEnv: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalShellEnv.d.ts",
		},
		testObserver: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts",
		},
		testRelatedCode: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts",
		},
		textDocumentEncoding: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textDocumentEncoding.d.ts",
		},
		textEditorDiffInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts",
		},
		textSearchComplete2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts",
		},
		textSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts",
		},
		textSearchProvider2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts",
		},
		timeline: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts",
		},
		tokenInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts",
		},
		treeViewActiveItem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts",
		},
		treeViewMarkdownMessage: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts",
		},
		treeViewReveal: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts",
		},
		tunnelFactory: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts",
		},
		tunnels: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts",
		},
		valueSelectionInQuickPick: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts",
		},
		workspaceTrust: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts",
		},
	},
	iu = Object.freeze(l7)
var E_ = yt.as(od.JSONContribution)
var x_ = class o {
		constructor(e, t) {
			this.added = e
			this.removed = t
		}
		static _toSet(e) {
			let t = new sr()
			for (let n = 0, r = e.length; n < r; n++) t.add(e[n].description.identifier)
			return t
		}
		static compute(e, t) {
			if (!e || !e.length) return new o(t, [])
			if (!t || !t.length) return new o([], e)
			let n = this._toSet(e),
				r = this._toSet(t),
				i = t.filter((a) => !n.has(a.description.identifier)),
				s = e.filter((a) => !r.has(a.description.identifier))
			return new o(i, s)
		}
	},
	C_ = class {
		constructor(e, t, n) {
			;(this.name = e),
				(this.defaultExtensionKind = t),
				(this.canHandleResolver = n),
				(this._handler = null),
				(this._users = null),
				(this._delta = null)
		}
		setHandler(e) {
			if (this._handler !== null) throw new Error("Handler already set!")
			return (
				(this._handler = e),
				this._handle(),
				{
					dispose: () => {
						this._handler = null
					},
				}
			)
		}
		acceptUsers(e) {
			;(this._delta = x_.compute(this._users, e)), (this._users = e), this._handle()
		}
		_handle() {
			if (!(this._handler === null || this._users === null || this._delta === null))
				try {
					this._handler(this._users, this._delta)
				} catch (e) {
					Be(e)
				}
		}
	},
	d7 = {
		type: "string",
		enum: ["ui", "workspace"],
		enumDescriptions: [
			p(
				"ui",
				"UI extension kind. In a remote window, such extensions are enabled only when available on the local machine.",
			),
			p(
				"workspace",
				"Workspace extension kind. In a remote window, such extensions are enabled only when available on the remote.",
			),
		],
	},
	tF = "vscode://schemas/vscode-extensions",
	S_ = {
		properties: {
			engines: {
				type: "object",
				description: p("vscode.extension.engines", "Engine compatibility."),
				properties: {
					vscode: {
						type: "string",
						description: p(
							"vscode.extension.engines.vscode",
							"For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.",
						),
						default: "^1.22.0",
					},
				},
			},
			publisher: {
				description: p("vscode.extension.publisher", "The publisher of the VS Code extension."),
				type: "string",
			},
			displayName: {
				description: p(
					"vscode.extension.displayName",
					"The display name for the extension used in the VS Code gallery.",
				),
				type: "string",
			},
			categories: {
				description: p(
					"vscode.extension.categories",
					"The categories used by the VS Code gallery to categorize the extension.",
				),
				type: "array",
				uniqueItems: !0,
				items: {
					oneOf: [
						{ type: "string", enum: BO },
						{
							type: "string",
							const: "Languages",
							deprecationMessage: p(
								"vscode.extension.category.languages.deprecated",
								"Use 'Programming  Languages' instead",
							),
						},
					],
				},
			},
			galleryBanner: {
				type: "object",
				description: p("vscode.extension.galleryBanner", "Banner used in the VS Code marketplace."),
				properties: {
					color: {
						description: p(
							"vscode.extension.galleryBanner.color",
							"The banner color on the VS Code marketplace page header.",
						),
						type: "string",
					},
					theme: {
						description: p(
							"vscode.extension.galleryBanner.theme",
							"The color theme for the font used in the banner.",
						),
						type: "string",
						enum: ["dark", "light"],
					},
				},
			},
			contributes: {
				description: p(
					"vscode.extension.contributes",
					"All contributions of the VS Code extension represented by this package.",
				),
				type: "object",
				properties: {},
				default: {},
			},
			preview: {
				type: "boolean",
				description: p(
					"vscode.extension.preview",
					"Sets the extension to be flagged as a Preview in the Marketplace.",
				),
			},
			enableProposedApi: {
				type: "boolean",
				deprecationMessage: p(
					"vscode.extension.enableProposedApi.deprecated",
					"Use `enabledApiProposals` instead.",
				),
			},
			enabledApiProposals: {
				markdownDescription: p(
					"vscode.extension.enabledApiProposals",
					"Enable API proposals to try them out. Only valid **during development**. Extensions **cannot be published** with this property. For more details visit: https://code.visualstudio.com/api/advanced-topics/using-proposed-api",
				),
				type: "array",
				uniqueItems: !0,
				items: {
					type: "string",
					enum: Object.keys(iu).map((o) => o),
					markdownEnumDescriptions: Object.values(iu).map((o) => o.proposal),
				},
			},
			api: {
				markdownDescription: p(
					"vscode.extension.api",
					"Describe the API provided by this extension. For more details visit: https://code.visualstudio.com/api/advanced-topics/remote-extensions#handling-dependencies-with-remote-extensions",
				),
				type: "string",
				enum: ["none"],
				enumDescriptions: [
					p(
						"vscode.extension.api.none",
						"Give up entirely the ability to export any APIs. This allows other extensions that depend on this extension to run in a separate extension host process or in a remote machine.",
					),
				],
			},
			activationEvents: {
				description: p("vscode.extension.activationEvents", "Activation events for the VS Code extension."),
				type: "array",
				items: {
					type: "string",
					defaultSnippets: [
						{
							label: "onWebviewPanel",
							description: p(
								"vscode.extension.activationEvents.onWebviewPanel",
								"An activation event emmited when a webview is loaded of a certain viewType",
							),
							body: "onWebviewPanel:viewType",
						},
						{
							label: "onLanguage",
							description: p(
								"vscode.extension.activationEvents.onLanguage",
								"An activation event emitted whenever a file that resolves to the specified language gets opened.",
							),
							body: "onLanguage:${1:languageId}",
						},
						{
							label: "onCommand",
							description: p(
								"vscode.extension.activationEvents.onCommand",
								"An activation event emitted whenever the specified command gets invoked.",
							),
							body: "onCommand:${2:commandId}",
						},
						{
							label: "onDebug",
							description: p(
								"vscode.extension.activationEvents.onDebug",
								"An activation event emitted whenever a user is about to start debugging or about to setup debug configurations.",
							),
							body: "onDebug",
						},
						{
							label: "onDebugInitialConfigurations",
							description: p(
								"vscode.extension.activationEvents.onDebugInitialConfigurations",
								'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).',
							),
							body: "onDebugInitialConfigurations",
						},
						{
							label: "onDebugDynamicConfigurations",
							description: p(
								"vscode.extension.activationEvents.onDebugDynamicConfigurations",
								'An activation event emitted whenever a list of all debug configurations needs to be created (and all provideDebugConfigurations methods for the "dynamic" scope need to be called).',
							),
							body: "onDebugDynamicConfigurations",
						},
						{
							label: "onDebugResolve",
							description: p(
								"vscode.extension.activationEvents.onDebugResolve",
								"An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called).",
							),
							body: "onDebugResolve:${6:type}",
						},
						{
							label: "onDebugAdapterProtocolTracker",
							description: p(
								"vscode.extension.activationEvents.onDebugAdapterProtocolTracker",
								"An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed.",
							),
							body: "onDebugAdapterProtocolTracker:${6:type}",
						},
						{
							label: "workspaceContains",
							description: p(
								"vscode.extension.activationEvents.workspaceContains",
								"An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern.",
							),
							body: "workspaceContains:${4:filePattern}",
						},
						{
							label: "onStartupFinished",
							description: p(
								"vscode.extension.activationEvents.onStartupFinished",
								"An activation event emitted after the start-up finished (after all `*` activated extensions have finished activating).",
							),
							body: "onStartupFinished",
						},
						{
							label: "onTaskType",
							description: p(
								"vscode.extension.activationEvents.onTaskType",
								"An activation event emitted whenever tasks of a certain type need to be listed or resolved.",
							),
							body: "onTaskType:${1:taskType}",
						},
						{
							label: "onFileSystem",
							description: p(
								"vscode.extension.activationEvents.onFileSystem",
								"An activation event emitted whenever a file or folder is accessed with the given scheme.",
							),
							body: "onFileSystem:${1:scheme}",
						},
						{
							label: "onEditSession",
							description: p(
								"vscode.extension.activationEvents.onEditSession",
								"An activation event emitted whenever an edit session is accessed with the given scheme.",
							),
							body: "onEditSession:${1:scheme}",
						},
						{
							label: "onSearch",
							description: p(
								"vscode.extension.activationEvents.onSearch",
								"An activation event emitted whenever a search is started in the folder with the given scheme.",
							),
							body: "onSearch:${7:scheme}",
						},
						{
							label: "onView",
							body: "onView:${5:viewId}",
							description: p(
								"vscode.extension.activationEvents.onView",
								"An activation event emitted whenever the specified view is expanded.",
							),
						},
						{
							label: "onUri",
							body: "onUri",
							description: p(
								"vscode.extension.activationEvents.onUri",
								"An activation event emitted whenever a system-wide Uri directed towards this extension is open.",
							),
						},
						{
							label: "onOpenExternalUri",
							body: "onOpenExternalUri",
							description: p(
								"vscode.extension.activationEvents.onOpenExternalUri",
								"An activation event emitted whenever a external uri (such as an http or https link) is being opened.",
							),
						},
						{
							label: "onCustomEditor",
							body: "onCustomEditor:${9:viewType}",
							description: p(
								"vscode.extension.activationEvents.onCustomEditor",
								"An activation event emitted whenever the specified custom editor becomes visible.",
							),
						},
						{
							label: "onNotebook",
							body: "onNotebook:${1:type}",
							description: p(
								"vscode.extension.activationEvents.onNotebook",
								"An activation event emitted whenever the specified notebook document is opened.",
							),
						},
						{
							label: "onAuthenticationRequest",
							body: "onAuthenticationRequest:${11:authenticationProviderId}",
							description: p(
								"vscode.extension.activationEvents.onAuthenticationRequest",
								"An activation event emitted whenever sessions are requested from the specified authentication provider.",
							),
						},
						{
							label: "onRenderer",
							description: p(
								"vscode.extension.activationEvents.onRenderer",
								"An activation event emitted whenever a notebook output renderer is used.",
							),
							body: "onRenderer:${11:rendererId}",
						},
						{
							label: "onTerminalProfile",
							body: "onTerminalProfile:${1:terminalId}",
							description: p(
								"vscode.extension.activationEvents.onTerminalProfile",
								"An activation event emitted when a specific terminal profile is launched.",
							),
						},
						{
							label: "onTerminalQuickFixRequest",
							body: "onTerminalQuickFixRequest:${1:quickFixId}",
							description: p(
								"vscode.extension.activationEvents.onTerminalQuickFixRequest",
								"An activation event emitted when a command matches the selector associated with this ID",
							),
						},
						{
							label: "onWalkthrough",
							body: "onWalkthrough:${1:walkthroughID}",
							description: p(
								"vscode.extension.activationEvents.onWalkthrough",
								"An activation event emitted when a specified walkthrough is opened.",
							),
						},
						{
							label: "onIssueReporterOpened",
							body: "onIssueReporterOpened",
							description: p(
								"vscode.extension.activationEvents.onIssueReporterOpened",
								"An activation event emitted when the issue reporter is opened.",
							),
						},
						{
							label: "onChatParticipant",
							body: "onChatParticipant:${1:participantId}",
							description: p(
								"vscode.extension.activationEvents.onChatParticipant",
								"An activation event emitted when the specified chat participant is invoked.",
							),
						},
						{
							label: "onLanguageModelTool",
							body: "onLanguageModelTool:${1:toolId}",
							description: p(
								"vscode.extension.activationEvents.onLanguageModelTool",
								"An activation event emitted when the specified language model tool is invoked.",
							),
						},
						{
							label: "onTerminalCompletionsRequested",
							body: "onTerminalCompletionsRequested",
							description: p(
								"vscode.extension.activationEvents.onTerminalCompletionsRequested",
								"An activation event emitted when terminal completions are requested.",
							),
						},
						{
							label: "onMcpCollection",
							description: p(
								"vscode.extension.activationEvents.onMcpCollection",
								"An activation event emitted whenver a tool from the MCP server is requested.",
							),
							body: "onMcpCollection:${2:collectionId}",
						},
						{
							label: "*",
							description: p(
								"vscode.extension.activationEvents.star",
								"An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case.",
							),
							body: "*",
						},
					],
				},
			},
			badges: {
				type: "array",
				description: p(
					"vscode.extension.badges",
					"Array of badges to display in the sidebar of the Marketplace's extension page.",
				),
				items: {
					type: "object",
					required: ["url", "href", "description"],
					properties: {
						url: { type: "string", description: p("vscode.extension.badges.url", "Badge image URL.") },
						href: { type: "string", description: p("vscode.extension.badges.href", "Badge link.") },
						description: {
							type: "string",
							description: p("vscode.extension.badges.description", "Badge description."),
						},
					},
				},
			},
			markdown: {
				type: "string",
				description: p(
					"vscode.extension.markdown",
					"Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.",
				),
				enum: ["github", "standard"],
				default: "github",
			},
			qna: {
				default: "marketplace",
				description: p(
					"vscode.extension.qna",
					"Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether.",
				),
				anyOf: [{ type: ["string", "boolean"], enum: ["marketplace", !1] }, { type: "string" }],
			},
			extensionDependencies: {
				description: p(
					"vscode.extension.extensionDependencies",
					"Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.",
				),
				type: "array",
				uniqueItems: !0,
				items: { type: "string", pattern: Sy },
			},
			extensionPack: {
				description: p(
					"vscode.extension.contributes.extensionPack",
					"A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.",
				),
				type: "array",
				uniqueItems: !0,
				items: { type: "string", pattern: Sy },
			},
			extensionKind: {
				description: p(
					"extensionKind",
					"Define the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions run on the remote.",
				),
				type: "array",
				items: d7,
				default: ["workspace"],
				defaultSnippets: [
					{
						body: ["ui"],
						description: p(
							"extensionKind.ui",
							"Define an extension which can run only on the local machine when connected to remote window.",
						),
					},
					{
						body: ["workspace"],
						description: p(
							"extensionKind.workspace",
							"Define an extension which can run only on the remote machine when connected remote window.",
						),
					},
					{
						body: ["ui", "workspace"],
						description: p(
							"extensionKind.ui-workspace",
							"Define an extension which can run on either side, with a preference towards running on the local machine.",
						),
					},
					{
						body: ["workspace", "ui"],
						description: p(
							"extensionKind.workspace-ui",
							"Define an extension which can run on either side, with a preference towards running on the remote machine.",
						),
					},
					{
						body: [],
						description: p(
							"extensionKind.empty",
							"Define an extension which cannot run in a remote context, neither on the local, nor on the remote machine.",
						),
					},
				],
			},
			capabilities: {
				description: p(
					"vscode.extension.capabilities",
					"Declare the set of supported capabilities by the extension.",
				),
				type: "object",
				properties: {
					virtualWorkspaces: {
						description: p(
							"vscode.extension.capabilities.virtualWorkspaces",
							"Declares whether the extension should be enabled in virtual workspaces. A virtual workspace is a workspace which is not backed by any on-disk resources. When false, this extension will be automatically disabled in virtual workspaces. Default is true.",
						),
						type: ["boolean", "object"],
						defaultSnippets: [
							{ label: "limited", body: { supported: "${1:limited}", description: "${2}" } },
							{ label: "false", body: { supported: !1, description: "${2}" } },
						],
						default: (!0).valueOf,
						properties: {
							supported: {
								markdownDescription: p(
									"vscode.extension.capabilities.virtualWorkspaces.supported",
									"Declares the level of support for virtual workspaces by the extension.",
								),
								type: ["string", "boolean"],
								enum: ["limited", !0, !1],
								enumDescriptions: [
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.limited",
										"The extension will be enabled in virtual workspaces with some functionality disabled.",
									),
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.true",
										"The extension will be enabled in virtual workspaces with all functionality enabled.",
									),
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.false",
										"The extension will not be enabled in virtual workspaces.",
									),
								],
							},
							description: {
								type: "string",
								markdownDescription: p(
									"vscode.extension.capabilities.virtualWorkspaces.description",
									"A description of how virtual workspaces affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.",
								),
							},
						},
					},
					untrustedWorkspaces: {
						description: p(
							"vscode.extension.capabilities.untrustedWorkspaces",
							"Declares how the extension should be handled in untrusted workspaces.",
						),
						type: "object",
						required: ["supported"],
						defaultSnippets: [{ body: { supported: "${1:limited}", description: "${2}" } }],
						properties: {
							supported: {
								markdownDescription: p(
									"vscode.extension.capabilities.untrustedWorkspaces.supported",
									"Declares the level of support for untrusted workspaces by the extension.",
								),
								type: ["string", "boolean"],
								enum: ["limited", !0, !1],
								enumDescriptions: [
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.limited",
										"The extension will be enabled in untrusted workspaces with some functionality disabled.",
									),
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.true",
										"The extension will be enabled in untrusted workspaces with all functionality enabled.",
									),
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.false",
										"The extension will not be enabled in untrusted workspaces.",
									),
								],
							},
							restrictedConfigurations: {
								description: p(
									"vscode.extension.capabilities.untrustedWorkspaces.restrictedConfigurations",
									"A list of configuration keys contributed by the extension that should not use workspace values in untrusted workspaces.",
								),
								type: "array",
								items: { type: "string" },
							},
							description: {
								type: "string",
								markdownDescription: p(
									"vscode.extension.capabilities.untrustedWorkspaces.description",
									"A description of how workspace trust affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.",
								),
							},
						},
					},
				},
			},
			sponsor: {
				description: p(
					"vscode.extension.contributes.sponsor",
					"Specify the location from where users can sponsor your extension.",
				),
				type: "object",
				defaultSnippets: [{ body: { url: "${1:https:}" } }],
				properties: {
					url: {
						description: p(
							"vscode.extension.contributes.sponsor.url",
							"URL from where users can sponsor your extension. It must be a valid URL with a HTTP or HTTPS protocol. Example value: https://github.com/sponsors/nvaccess",
						),
						type: "string",
					},
				},
			},
			scripts: {
				type: "object",
				properties: {
					"vscode:prepublish": {
						description: p(
							"vscode.extension.scripts.prepublish",
							"Script executed before the package is published as a VS Code extension.",
						),
						type: "string",
					},
					"vscode:uninstall": {
						description: p(
							"vscode.extension.scripts.uninstall",
							"Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported.",
						),
						type: "string",
					},
				},
			},
			icon: { type: "string", description: p("vscode.extension.icon", "The path to a 128x128 pixel icon.") },
			l10n: {
				type: "string",
				description: p(
					{
						key: "vscode.extension.l10n",
						comment: ['{Locked="bundle.l10n._locale_.json"}', '{Locked="vscode.l10n API"}'],
					},
					"The relative path to a folder containing localization (bundle.l10n.*.json) files. Must be specified if you are using the vscode.l10n API.",
				),
			},
			pricing: {
				type: "string",
				markdownDescription: p(
					"vscode.extension.pricing",
					"The pricing information for the extension. Can be Free (default) or Trial. For more details visit: https://code.visualstudio.com/api/working-with-extensions/publishing-extension#extension-pricing-label",
				),
				enum: ["Free", "Trial"],
				default: "Free",
			},
		},
	},
	T_ = class {
		constructor() {
			this._extensionPoints = new Map()
		}
		registerExtensionPoint(e) {
			if (this._extensionPoints.has(e.extensionPoint))
				throw new Error("Duplicate extension point: " + e.extensionPoint)
			let t = new C_(e.extensionPoint, e.defaultExtensionKind, e.canHandleResolver)
			return (
				this._extensionPoints.set(e.extensionPoint, t),
				e.activationEventsGenerator && I_.register(e.extensionPoint, e.activationEventsGenerator),
				(S_.properties.contributes.properties[e.extensionPoint] = e.jsonSchema),
				E_.registerSchema(tF, S_),
				t
			)
		}
		getExtensionPoints() {
			return Array.from(this._extensionPoints.values())
		}
	},
	nF = { ExtensionsRegistry: "ExtensionsRegistry" }
yt.add(nF.ExtensionsRegistry, new T_())
var Ey = yt.as(nF.ExtensionsRegistry)
E_.registerSchema(tF, S_)
E_.registerSchema(CM, {
	properties: {
		extensionEnabledApiProposals: {
			description: p(
				"product.extensionEnabledApiProposals",
				"API proposals that the respective extensions can freely use.",
			),
			type: "object",
			properties: {},
			additionalProperties: {
				anyOf: [
					{
						type: "array",
						uniqueItems: !0,
						items: {
							type: "string",
							enum: Object.keys(iu),
							markdownEnumDescriptions: Object.values(iu).map((o) => o.proposal),
						},
					},
				],
			},
		},
	},
})
var zle = O("ILanguageModelsService"),
	rF = {
		type: "object",
		properties: {
			vendor: {
				type: "string",
				description: p(
					"vscode.extension.contributes.languageModels.vendor",
					"A globally unique vendor of language models.",
				),
			},
		},
	},
	c7 = Ey.registerExtensionPoint({
		extensionPoint: "languageModels",
		jsonSchema: {
			description: p(
				"vscode.extension.contributes.languageModels",
				"Contribute language models of a specific vendor.",
			),
			oneOf: [rF, { type: "array", items: rF }],
		},
		activationEventsGenerator: (o, e) => {
			for (let t of o) e.push(`onLanguageModelChat:${t.vendor}`)
		},
	}),
	wy = class {
		constructor(e, t, n) {
			this._extensionService = e
			this._logService = t
			this._contextKeyService = n
			this._store = new Q()
			this._providers = new Map()
			this._vendors = new Set()
			this._onDidChangeProviders = this._store.add(new E())
			this.onDidChangeLanguageModels = this._onDidChangeProviders.event
			;(this._hasUserSelectableModels = fs.languageModelsAreUserSelectable.bindTo(this._contextKeyService)),
				this._store.add(
					c7.setHandler((r) => {
						this._vendors.clear()
						for (let s of r) {
							if (!nt(s.description, "chatProvider")) {
								s.collector.error(
									p(
										"vscode.extension.contributes.languageModels.chatProviderRequired",
										"This contribution point requires the 'chatProvider' proposal.",
									),
								)
								continue
							}
							for (let a of kt.wrap(s.value)) {
								if (this._vendors.has(a.vendor)) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.vendorAlreadyRegistered",
											"The vendor '{0}' is already registered and cannot be registered twice",
											a.vendor,
										),
									)
									continue
								}
								if (Qi(a.vendor)) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.emptyVendor",
											"The vendor field cannot be empty.",
										),
									)
									continue
								}
								if (a.vendor.trim() !== a.vendor) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.whitespaceVendor",
											"The vendor field cannot start or end with whitespace.",
										),
									)
									continue
								}
								this._vendors.add(a.vendor)
							}
						}
						let i = []
						for (let [s, a] of this._providers)
							this._vendors.has(a.metadata.vendor) || (this._providers.delete(s), i.push(s))
						i.length > 0 && this._onDidChangeProviders.fire({ removed: i })
					}),
				)
		}
		dispose() {
			this._store.dispose(), this._providers.clear()
		}
		getLanguageModelIds() {
			return Array.from(this._providers.keys())
		}
		lookupLanguageModel(e) {
			return this._providers.get(e)?.metadata
		}
		async selectLanguageModels(e) {
			if (e.vendor) await this._extensionService.activateByEvent(`onLanguageModelChat:${e.vendor}}`)
			else {
				let n = Array.from(this._vendors).map((r) =>
					this._extensionService.activateByEvent(`onLanguageModelChat:${r}`),
				)
				await Promise.all(n)
			}
			let t = []
			for (let [n, r] of this._providers)
				(e.vendor === void 0 || r.metadata.vendor === e.vendor) &&
					(e.family === void 0 || r.metadata.family === e.family) &&
					(e.version === void 0 || r.metadata.version === e.version) &&
					(e.id === void 0 || r.metadata.id === e.id) &&
					(!r.metadata.targetExtensions ||
						r.metadata.targetExtensions.some((i) => we.equals(i, e.extension))) &&
					t.push(n)
			return this._logService.trace("[LM] selected language models", e, t), t
		}
		registerLanguageModelChat(e, t) {
			if (
				(this._logService.trace("[LM] registering language model chat", e, t.metadata),
				!this._vendors.has(t.metadata.vendor))
			)
				throw new Error(`Chat response provider uses UNKNOWN vendor ${t.metadata.vendor}.`)
			if (this._providers.has(e))
				throw new Error(`Chat response provider with identifier ${e} is already registered.`)
			return (
				this._providers.set(e, t),
				this._onDidChangeProviders.fire({ added: [{ identifier: e, metadata: t.metadata }] }),
				this.updateUserSelectableModelsContext(),
				q(() => {
					this.updateUserSelectableModelsContext(),
						this._providers.delete(e) &&
							(this._onDidChangeProviders.fire({ removed: [e] }),
							this._logService.trace("[LM] UNregistered language model chat", e, t.metadata))
				})
			)
		}
		updateUserSelectableModelsContext() {
			let e = Array.from(this._providers.values()).some(
					(n) => n.metadata.isUserSelectable && !n.metadata.isDefault,
				),
				t = Array.from(this._providers.values()).some((n) => n.metadata.isDefault)
			this._hasUserSelectableModels.set(e && t)
		}
		async sendChatRequest(e, t, n, r, i) {
			let s = this._providers.get(e)
			if (!s) throw new Error(`Chat response provider with identifier ${e} is not registered.`)
			return s.sendChatRequest(n, t, r, i)
		}
		computeTokenLength(e, t, n) {
			let r = this._providers.get(e)
			if (!r) throw new Error(`Chat response provider with identifier ${e} is not registered.`)
			return r.provideTokenCount(t, n)
		}
	}
wy = R([S(0, Ty), S(1, te), S(2, ca)], wy)
var Xle = new D("debugType", void 0, {
		type: "string",
		description: p("debugType", "Debug type of the active debug session. For example 'python'."),
	}),
	Yle = new D("debugConfigurationType", void 0, {
		type: "string",
		description: p(
			"debugConfigurationType",
			"Debug type of the selected launch configuration. For example 'python'.",
		),
	}),
	Zle = new D("debugState", "inactive", {
		type: "string",
		description: p(
			"debugState",
			"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.",
		),
	}),
	p7 = "debugUx",
	ede = new D(p7, "default", {
		type: "string",
		description: p(
			"debugUX",
			"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.",
		),
	}),
	tde = new D("hasDebugged", !1, {
		type: "boolean",
		description: p("hasDebugged", "True when a debug session has been started at least once, false otherwise."),
	}),
	nde = new D("inDebugMode", !1, {
		type: "boolean",
		description: p("inDebugMode", "True when debugging, false otherwise."),
	}),
	rde = new D("inDebugRepl", !1, {
		type: "boolean",
		description: p("inDebugRepl", "True when focus is in the debug console, false otherwise."),
	}),
	ode = new D("breakpointWidgetVisible", !1, {
		type: "boolean",
		description: p(
			"breakpointWidgetVisibile",
			"True when breakpoint editor zone widget is visible, false otherwise.",
		),
	}),
	ide = new D("inBreakpointWidget", !1, {
		type: "boolean",
		description: p(
			"inBreakpointWidget",
			"True when focus is in the breakpoint editor zone widget, false otherwise.",
		),
	}),
	sde = new D("breakpointsFocused", !0, {
		type: "boolean",
		description: p("breakpointsFocused", "True when the BREAKPOINTS view is focused, false otherwise."),
	}),
	ade = new D("watchExpressionsFocused", !0, {
		type: "boolean",
		description: p("watchExpressionsFocused", "True when the WATCH view is focused, false otherwise."),
	}),
	lde = new D("watchExpressionsExist", !1, {
		type: "boolean",
		description: p("watchExpressionsExist", "True when at least one watch expression exists, false otherwise."),
	}),
	dde = new D("variablesFocused", !0, {
		type: "boolean",
		description: p("variablesFocused", "True when the VARIABLES views is focused, false otherwise"),
	}),
	cde = new D("expressionSelected", !1, {
		type: "boolean",
		description: p(
			"expressionSelected",
			"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.",
		),
	}),
	ude = new D("breakpointInputFocused", !1, {
		type: "boolean",
		description: p("breakpointInputFocused", "True when the input box has focus in the BREAKPOINTS view."),
	}),
	pde = new D("callStackItemType", void 0, {
		type: "string",
		description: p(
			"callStackItemType",
			"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'",
		),
	}),
	mde = new D("callStackSessionIsAttach", !1, {
		type: "boolean",
		description: p(
			"callStackSessionIsAttach",
			"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.",
		),
	}),
	fde = new D("callStackItemStopped", !1, {
		type: "boolean",
		description: p(
			"callStackItemStopped",
			"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.",
		),
	}),
	gde = new D("callStackSessionHasOneThread", !1, {
		type: "boolean",
		description: p(
			"callStackSessionHasOneThread",
			"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.",
		),
	}),
	hde = new D("callStackFocused", !0, {
		type: "boolean",
		description: p("callStackFocused", "True when the CALLSTACK view is focused, false otherwise."),
	}),
	vde = new D("watchItemType", void 0, {
		type: "string",
		description: p(
			"watchItemType",
			"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'",
		),
	}),
	bde = new D("canViewMemory", void 0, {
		type: "boolean",
		description: p("canViewMemory", "Indicates whether the item in the view has an associated memory refrence."),
	}),
	yde = new D("breakpointItemType", void 0, {
		type: "string",
		description: p(
			"breakpointItemType",
			"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'",
		),
	}),
	Ide = new D("breakpointItemBytes", void 0, {
		type: "boolean",
		description: p(
			"breakpointItemIsDataBytes",
			"Whether the breakpoint item is a data breakpoint on a byte range.",
		),
	}),
	xde = new D("breakpointHasModes", !1, {
		type: "boolean",
		description: p("breakpointHasModes", "Whether the breakpoint has multiple modes it can switch to."),
	}),
	Cde = new D("breakpointSupportsCondition", !1, {
		type: "boolean",
		description: p("breakpointSupportsCondition", "True when the focused breakpoint supports conditions."),
	}),
	Sde = new D("loadedScriptsSupported", !1, {
		type: "boolean",
		description: p("loadedScriptsSupported", "True when the focused sessions supports the LOADED SCRIPTS view"),
	}),
	Tde = new D("loadedScriptsItemType", void 0, {
		type: "string",
		description: p(
			"loadedScriptsItemType",
			"Represents the item type of the focused element in the LOADED SCRIPTS view.",
		),
	}),
	Ede = new D("focusedSessionIsAttach", !1, {
		type: "boolean",
		description: p("focusedSessionIsAttach", "True when the focused session is 'attach'."),
	}),
	wde = new D("focusedSessionIsNoDebug", !1, {
		type: "boolean",
		description: p("focusedSessionIsNoDebug", "True when the focused session is run without debugging."),
	}),
	Pde = new D("stepBackSupported", !1, {
		type: "boolean",
		description: p("stepBackSupported", "True when the focused session supports 'stepBack' requests."),
	}),
	_de = new D("restartFrameSupported", !1, {
		type: "boolean",
		description: p("restartFrameSupported", "True when the focused session supports 'restartFrame' requests."),
	}),
	Dde = new D("stackFrameSupportsRestart", !1, {
		type: "boolean",
		description: p("stackFrameSupportsRestart", "True when the focused stack frame supports 'restartFrame'."),
	}),
	kde = new D("jumpToCursorSupported", !1, {
		type: "boolean",
		description: p("jumpToCursorSupported", "True when the focused session supports 'jumpToCursor' request."),
	}),
	Rde = new D("stepIntoTargetsSupported", !1, {
		type: "boolean",
		description: p("stepIntoTargetsSupported", "True when the focused session supports 'stepIntoTargets' request."),
	}),
	Ade = new D("breakpointsExist", !1, {
		type: "boolean",
		description: p("breakpointsExist", "True when at least one breakpoint exists."),
	}),
	Ode = new D("debuggersAvailable", !1, {
		type: "boolean",
		description: p("debuggersAvailable", "True when there is at least one debug extensions active."),
	}),
	Lde = new D("debugExtensionAvailable", !0, {
		type: "boolean",
		description: p(
			"debugExtensionsAvailable",
			"True when there is at least one debug extension installed and enabled.",
		),
	}),
	Mde = new D("debugProtocolVariableMenuContext", void 0, {
		type: "string",
		description: p(
			"debugProtocolVariableMenuContext",
			"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.",
		),
	}),
	Fde = new D("debugSetVariableSupported", !1, {
		type: "boolean",
		description: p("debugSetVariableSupported", "True when the focused session supports 'setVariable' request."),
	}),
	Nde = new D("debugSetDataBreakpointAddressSupported", !1, {
		type: "boolean",
		description: p(
			"debugSetDataBreakpointAddressSupported",
			"True when the focused session supports 'getBreakpointInfo' request on an address.",
		),
	}),
	Ude = new D("debugSetExpressionSupported", !1, {
		type: "boolean",
		description: p(
			"debugSetExpressionSupported",
			"True when the focused session supports 'setExpression' request.",
		),
	}),
	Hde = new D("breakWhenValueChangesSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueChangesSupported",
			"True when the focused session supports to break when value changes.",
		),
	}),
	Wde = new D("breakWhenValueIsAccessedSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueIsAccessedSupported",
			"True when the focused breakpoint supports to break when value is accessed.",
		),
	}),
	Vde = new D("breakWhenValueIsReadSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueIsReadSupported",
			"True when the focused breakpoint supports to break when value is read.",
		),
	}),
	Bde = new D("terminateDebuggeeSupported", !1, {
		type: "boolean",
		description: p(
			"terminateDebuggeeSupported",
			"True when the focused session supports the terminate debuggee capability.",
		),
	}),
	$de = new D("suspendDebuggeeSupported", !1, {
		type: "boolean",
		description: p(
			"suspendDebuggeeSupported",
			"True when the focused session supports the suspend debuggee capability.",
		),
	}),
	zde = new D("variableEvaluateNamePresent", !1, {
		type: "boolean",
		description: p(
			"variableEvaluateNamePresent",
			"True when the focused variable has an 'evalauteName' field set.",
		),
	}),
	qde = new D("variableIsReadonly", !1, {
		type: "boolean",
		description: p("variableIsReadonly", "True when the focused variable is read-only."),
	}),
	Kde = new D("variableValue", !1, {
		type: "string",
		description: p("variableValue", "Value of the variable, present for debug visualization clauses."),
	}),
	jde = new D("variableType", !1, {
		type: "string",
		description: p("variableType", "Type of the variable, present for debug visualization clauses."),
	}),
	Gde = new D("variableInterfaces", !1, {
		type: "array",
		description: p(
			"variableInterfaces",
			"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.",
		),
	}),
	Qde = new D("variableName", !1, {
		type: "string",
		description: p("variableName", "Name of the variable, present for debug visualization clauses."),
	}),
	Jde = new D("variableLanguage", !1, {
		type: "string",
		description: p("variableLanguage", "Language of the variable source, present for debug visualization clauses."),
	}),
	Xde = new D("variableExtensionId", !1, {
		type: "string",
		description: p(
			"variableExtensionId",
			"Extension ID of the variable source, present for debug visualization clauses.",
		),
	}),
	Yde = new D("exceptionWidgetVisible", !1, {
		type: "boolean",
		description: p("exceptionWidgetVisible", "True when the exception widget is visible."),
	}),
	Zde = new D("multiSessionRepl", !1, {
		type: "boolean",
		description: p("multiSessionRepl", "True when there is more than 1 debug console."),
	}),
	ece = new D("multiSessionDebug", !1, {
		type: "boolean",
		description: p("multiSessionDebug", "True when there is more than 1 active debug session."),
	}),
	tce = new D("disassembleRequestSupported", !1, {
		type: "boolean",
		description: p("disassembleRequestSupported", "True when the focused sessions supports disassemble request."),
	}),
	nce = new D("disassemblyViewFocus", !1, {
		type: "boolean",
		description: p("disassemblyViewFocus", "True when the Disassembly View is focused."),
	}),
	rce = new D("languageSupportsDisassembleRequest", !1, {
		type: "boolean",
		description: p(
			"languageSupportsDisassembleRequest",
			"True when the language in the current editor supports disassemble request.",
		),
	}),
	oce = new D("focusedStackFrameHasInstructionReference", !1, {
		type: "boolean",
		description: p(
			"focusedStackFrameHasInstructionReference",
			"True when the focused stack frame has instruction pointer reference.",
		),
	})
var ice = {
	enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
	default: "openOnFirstSessionStart",
	description: p("internalConsoleOptions", "Controls when the internal Debug Console should open."),
}
var w_ = ((t) => ((t[(t.Initial = 1)] = "Initial"), (t[(t.Dynamic = 2)] = "Dynamic"), t))(w_ || {})
var sce = O("debugService")
var m7
;((t) => ((t.deserialize = (n) => n), (t.serialize = (n) => n)))((m7 ||= {}))
var f7
;((t) => (
	(t.deserialize = (n) => ({
		id: n.id,
		name: n.name,
		iconPath: n.iconPath && { light: y.revive(n.iconPath.light), dark: y.revive(n.iconPath.dark) },
		iconClass: n.iconClass,
		visualization: n.visualization,
	})),
	(t.serialize = (n) => n)
))((f7 ||= {}))
var ze = class o {
	constructor(e, t = e.length) {
		this.path = e
		this.viewEnd = t
		if (e.length === 0 || t < 1) throw new Error("cannot create test with empty path")
	}
	static fromExtHostTestItem(e, t, n = e.parent) {
		if (e._isRoot) return new o([t])
		let r = [e.id]
		for (let i = n; i && i.id !== t; i = i.parent) r.push(i.id)
		return r.push(t), new o(r.reverse())
	}
	static isRoot(e) {
		return !e.includes("\0")
	}
	static root(e) {
		let t = e.indexOf("\0")
		return t === -1 ? e : e.slice(0, t)
	}
	static fromString(e) {
		return new o(e.split("\0"))
	}
	static join(e, t) {
		return new o([...e.path, t])
	}
	static split(e) {
		return e.split("\0")
	}
	static joinToString(e, t) {
		return e.toString() + "\0" + t
	}
	static parentId(e) {
		let t = e.lastIndexOf("\0")
		return t === -1 ? void 0 : e.slice(0, t)
	}
	static localId(e) {
		let t = e.lastIndexOf("\0")
		return t === -1 ? e : e.slice(t + 1)
	}
	static isChild(e, t) {
		return t[e.length] === "\0" && t.startsWith(e)
	}
	static compare(e, t) {
		return e === t ? 0 : o.isChild(e, t) ? 2 : o.isChild(t, e) ? 3 : 1
	}
	static getLengthOfCommonPrefix(e, t) {
		if (e === 0) return 0
		let n = 0
		for (; n < e - 1; ) {
			for (let r = 1; r < e; r++) {
				let i = t(r - 1),
					s = t(r)
				if (i.path[n] !== s.path[n]) return n
			}
			n++
		}
		return n
	}
	get rootId() {
		return new o(this.path, 1)
	}
	get parentId() {
		return this.viewEnd > 1 ? new o(this.path, this.viewEnd - 1) : void 0
	}
	get localId() {
		return this.path[this.viewEnd - 1]
	}
	get controllerId() {
		return this.path[0]
	}
	get isRoot() {
		return this.viewEnd === 1
	}
	*idsFromRoot() {
		for (let e = 1; e <= this.viewEnd; e++) yield new o(this.path, e)
	}
	*idsToRoot() {
		for (let e = this.viewEnd; e > 0; e--) yield new o(this.path, e)
	}
	compare(e) {
		if (typeof e == "string") return o.compare(this.toString(), e)
		for (let t = 0; t < e.viewEnd && t < this.viewEnd; t++) if (e.path[t] !== this.path[t]) return 1
		return e.viewEnd > this.viewEnd ? 2 : e.viewEnd < this.viewEnd ? 3 : 0
	}
	toJSON() {
		return this.toString()
	}
	toString() {
		if (!this.stringifed) {
			this.stringifed = this.path[0]
			for (let e = 1; e < this.viewEnd; e++) (this.stringifed += "\0"), (this.stringifed += this.path[e])
		}
		return this.stringifed
	}
}
var vce = {
	2: p("testing.runProfileBitset.run", "Run"),
	4: p("testing.runProfileBitset.debug", "Debug"),
	8: p("testing.runProfileBitset.coverage", "Coverage"),
}
var oF = (o) => "runId" in o,
	tg
;((t) => (
	(t.serialize = (n) => ({ range: n.range.toJSON(), uri: n.uri.toJSON() })),
	(t.deserialize = (n, r) => ({ range: Re.lift(r.range), uri: n.asCanonicalUri(y.revive(r.uri)) }))
))((tg ||= {}))
var P_
;((t) => (
	(t.serialize = (n) => ({ label: n.label, uri: n.uri?.toJSON(), position: n.position?.toJSON() })),
	(t.deserialize = (n, r) => ({
		label: r.label,
		uri: r.uri ? n.asCanonicalUri(y.revive(r.uri)) : void 0,
		position: r.position ? cn.lift(r.position) : void 0,
	}))
))((P_ ||= {}))
var __
;((t) => (
	(t.serialize = (n) => ({
		message: n.message,
		type: 0,
		expected: n.expected,
		actual: n.actual,
		contextValue: n.contextValue,
		location: n.location && tg.serialize(n.location),
		stackTrace: n.stackTrace?.map(P_.serialize),
	})),
	(t.deserialize = (n, r) => ({
		message: r.message,
		type: 0,
		expected: r.expected,
		actual: r.actual,
		contextValue: r.contextValue,
		location: r.location && tg.deserialize(n, r.location),
		stackTrace: r.stackTrace && r.stackTrace.map((i) => P_.deserialize(n, i)),
	}))
))((__ ||= {}))
var D_
;((t) => (
	(t.serialize = (n) => ({
		message: n.message,
		type: 1,
		offset: n.offset,
		length: n.length,
		location: n.location && tg.serialize(n.location),
	})),
	(t.deserialize = (n, r) => ({
		message: r.message,
		type: 1,
		offset: r.offset,
		length: r.length,
		location: r.location && tg.deserialize(n, r.location),
	}))
))((D_ ||= {}))
var k_
;((n) => (
	(n.serialize = (r) => (r.type === 0 ? __.serialize(r) : D_.serialize(r))),
	(n.deserialize = (r, i) => (i.type === 0 ? __.deserialize(r, i) : D_.deserialize(r, i))),
	(n.isDiffable = (r) => r.type === 0 && r.actual !== void 0 && r.expected !== void 0)
))((k_ ||= {}))
var Py
;((n) => (
	(n.serializeWithoutMessages = (r) => ({ state: r.state, duration: r.duration, messages: [] })),
	(n.serialize = (r) => ({ state: r.state, duration: r.duration, messages: r.messages.map(k_.serialize) })),
	(n.deserialize = (r, i) => ({
		state: i.state,
		duration: i.duration,
		messages: i.messages.map((s) => k_.deserialize(r, s)),
	}))
))((Py ||= {}))
var iF = "\0",
	su = (o, e) => o + iF + e,
	ky = (o) => {
		let e = o.indexOf(iF)
		return { ctrlId: o.slice(0, e), tagId: o.slice(e + 1) }
	},
	R_
;((t) => (
	(t.serialize = (n) => ({
		extId: n.extId,
		label: n.label,
		tags: n.tags,
		busy: n.busy,
		children: void 0,
		uri: n.uri?.toJSON(),
		range: n.range?.toJSON() || null,
		description: n.description,
		error: n.error,
		sortText: n.sortText,
	})),
	(t.deserialize = (n, r) => ({
		extId: r.extId,
		label: r.label,
		tags: r.tags,
		busy: r.busy,
		children: void 0,
		uri: r.uri ? n.asCanonicalUri(y.revive(r.uri)) : void 0,
		range: r.range ? Re.lift(r.range) : null,
		description: r.description,
		error: r.error,
		sortText: r.sortText,
	}))
))((R_ ||= {}))
var ad
;((t) => (
	(t.serialize = (n) => ({ expand: n.expand, item: R_.serialize(n.item) })),
	(t.deserialize = (n, r) => ({
		controllerId: ze.root(r.item.extId),
		expand: r.expand,
		item: R_.deserialize(n, r.item),
	}))
))((ad ||= {}))
var _y
;((t) => (
	(t.serialize = (n) => {
		let r
		return (
			n.item &&
				((r = {}),
				n.item.label !== void 0 && (r.label = n.item.label),
				n.item.tags !== void 0 && (r.tags = n.item.tags),
				n.item.busy !== void 0 && (r.busy = n.item.busy),
				n.item.uri !== void 0 && (r.uri = n.item.uri?.toJSON()),
				n.item.range !== void 0 && (r.range = n.item.range?.toJSON()),
				n.item.description !== void 0 && (r.description = n.item.description),
				n.item.error !== void 0 && (r.error = n.item.error),
				n.item.sortText !== void 0 && (r.sortText = n.item.sortText)),
			{ extId: n.extId, expand: n.expand, item: r }
		)
	}),
	(t.deserialize = (n) => {
		let r
		return (
			n.item &&
				((r = {}),
				n.item.label !== void 0 && (r.label = n.item.label),
				n.item.tags !== void 0 && (r.tags = n.item.tags),
				n.item.busy !== void 0 && (r.busy = n.item.busy),
				n.item.range !== void 0 && (r.range = n.item.range ? Re.lift(n.item.range) : null),
				n.item.description !== void 0 && (r.description = n.item.description),
				n.item.error !== void 0 && (r.error = n.item.error),
				n.item.sortText !== void 0 && (r.sortText = n.item.sortText)),
			{ extId: n.extId, expand: n.expand, item: r }
		)
	})
))((_y ||= {}))
var Ry = (o, e) => {
		e.expand !== void 0 && (o.expand = e.expand),
			e.item !== void 0 && (o.item = o.item ? Object.assign(o.item, e.item) : e.item)
	},
	g7
;((n) => (
	(n.serializeWithoutMessages = (r) => ({
		...ad.serialize(r),
		ownComputedState: r.ownComputedState,
		computedState: r.computedState,
		tasks: r.tasks.map(Py.serializeWithoutMessages),
	})),
	(n.serialize = (r) => ({
		...ad.serialize(r),
		ownComputedState: r.ownComputedState,
		computedState: r.computedState,
		tasks: r.tasks.map(Py.serialize),
	})),
	(n.deserialize = (r, i) => ({
		...ad.deserialize(r, i),
		ownComputedState: i.ownComputedState,
		computedState: i.computedState,
		tasks: i.tasks.map((s) => Py.deserialize(r, s)),
		retired: !0,
	}))
))((g7 ||= {}))
var sF
;((t) => (
	(t.empty = () => ({ covered: 0, total: 0 })),
	(t.sum = (n, r) => {
		;(n.covered += r.covered), (n.total += r.total)
	})
))((sF ||= {}))
var h7
;((n) => (
	(n.serialize = (r) => ({
		id: r.id,
		statement: r.statement,
		branch: r.branch,
		declaration: r.declaration,
		testIds: r.testIds,
		uri: r.uri.toJSON(),
	})),
	(n.deserialize = (r, i) => ({
		id: i.id,
		statement: i.statement,
		branch: i.branch,
		declaration: i.declaration,
		testIds: i.testIds,
		uri: r.asCanonicalUri(y.revive(i.uri)),
	})),
	(n.empty = (r, i) => ({ id: r, uri: i, statement: sF.empty() }))
))((h7 ||= {}))
function M_(o) {
	return { ...o, location: o.location?.toJSON() }
}
function F_(o) {
	return (
		(o.location = o.location ? (cn.isIPosition(o.location) ? cn.lift(o.location) : Re.lift(o.location)) : void 0), o
	)
}
var v7
;((t) => (
	(t.serialize = (n) => (n.type === 0 ? O_.serialize(n) : L_.serialize(n))),
	(t.deserialize = (n) => (n.type === 0 ? O_.deserialize(n) : L_.deserialize(n)))
))((v7 ||= {}))
var A_
;((t) => ((t.serialize = M_), (t.deserialize = F_)))((A_ ||= {}))
var O_
;((t) => ((t.serialize = M_), (t.deserialize = F_)))((O_ ||= {}))
var L_
;((t) => (
	(t.serialize = (n) => ({ ...M_(n), branches: n.branches?.map(A_.serialize) })),
	(t.deserialize = (n) => ({ ...F_(n), branches: n.branches?.map(A_.deserialize) }))
))((L_ ||= {}))
var Ay
;((t) => (
	(t.deserialize = (n, r) =>
		r.op === 0
			? { op: r.op, item: ad.deserialize(n, r.item) }
			: r.op === 1
				? { op: r.op, item: _y.deserialize(r.item) }
				: r.op === 2
					? { op: r.op, uri: n.asCanonicalUri(y.revive(r.uri)), docv: r.docv }
					: r),
	(t.serialize = (n) =>
		n.op === 0
			? { op: n.op, item: ad.serialize(n.item) }
			: n.op === 1
				? { op: n.op, item: _y.serialize(n.item) }
				: n)
))((Ay ||= {}))
var Dy = class {
	constructor(e) {
		this.uriIdentity = e
		this._tags = new Map()
		this.items = new Map()
		this.roots = new Set()
		this.busyControllerCount = 0
		this.pendingRootCount = 0
		this.tags = this._tags
	}
	apply(e) {
		let t = this.createChangeCollector()
		for (let n of e)
			switch (n.op) {
				case 0:
					this.add(ad.deserialize(this.uriIdentity, n.item), t)
					break
				case 1:
					this.update(_y.deserialize(n.item), t)
					break
				case 3:
					this.remove(n.itemId, t)
					break
				case 5:
					this.retireTest(n.itemId)
					break
				case 4:
					this.updatePendingRoots(n.amount)
					break
				case 6:
					this._tags.set(n.tag.id, n.tag)
					break
				case 7:
					this._tags.delete(n.id)
					break
			}
		t.complete?.()
	}
	add(e, t) {
		let n = ze.parentId(e.item.extId)?.toString(),
			r
		if (!n) (r = this.createItem(e)), this.roots.add(r), this.items.set(e.item.extId, r)
		else if (this.items.has(n)) {
			let i = this.items.get(n)
			i.children.add(e.item.extId), (r = this.createItem(e, i)), this.items.set(e.item.extId, r)
		} else {
			console.error(`Test with unknown parent ID: ${JSON.stringify(e)}`)
			return
		}
		return t.add?.(r), e.expand === 2 && this.busyControllerCount++, r
	}
	update(e, t) {
		let n = this.items.get(e.extId)
		if (n)
			return (
				e.expand !== void 0 &&
					(n.expand === 2 && this.busyControllerCount--, e.expand === 2 && this.busyControllerCount++),
				Ry(n, e),
				t.update?.(n),
				n
			)
	}
	remove(e, t) {
		let n = this.items.get(e)
		if (!n) return
		let r = ze.parentId(n.item.extId)?.toString()
		r ? this.items.get(r).children.delete(n.item.extId) : this.roots.delete(n)
		let i = [[e]]
		for (; i.length; )
			for (let s of i.pop()) {
				let a = this.items.get(s)
				a &&
					(i.push(a.children),
					this.items.delete(s),
					t.remove?.(a, a !== n),
					a.expand === 2 && this.busyControllerCount--)
			}
	}
	retireTest(e) {}
	updatePendingRoots(e) {
		this.pendingRootCount += e
	}
	createChangeCollector() {
		return {}
	}
}
var Oy = O("editorGroupsService")
var zce = O("editorService"),
	aF = -1,
	lF = -2
var ng = (o, e) => o === e,
	b7 = {
		range: (o, e) => (o === e ? !0 : !o || !e ? !1 : o.equalsRange(e)),
		busy: ng,
		label: ng,
		description: ng,
		error: ng,
		sortText: ng,
		tags: (o, e) => !(o.length !== e.length || o.some((t) => !e.includes(t))),
	},
	y7 = Object.entries(b7),
	I7 = (o, e) => {
		let t
		for (let [n, r] of y7) r(o[n], e[n]) || (t ? (t[n] = e[n]) : (t = { [n]: e[n] }))
		return t
	},
	Ly = class extends $ {
		constructor(t) {
			super()
			this.options = t
			this.debounceSendDiff = this._register(new Hn(() => this.flushDiff(), 200))
			this.diffOpEmitter = this._register(new E())
			this.tree = new Map()
			this.tags = new Map()
			this.diff = []
			this.onDidGenerateDiff = this.diffOpEmitter.event
			;(this.root.canResolveChildren = !0), this.upsertItem(this.root, void 0)
		}
		get root() {
			return this.options.root
		}
		set resolveHandler(t) {
			this._resolveHandler = t
			for (let n of this.tree.values()) this.updateExpandability(n)
		}
		get resolveHandler() {
			return this._resolveHandler
		}
		collectDiff() {
			let t = this.diff
			return (this.diff = []), t
		}
		pushDiff(t) {
			switch (t.op) {
				case 2: {
					for (let n of this.diff)
						if (n.op === 2 && n.uri === t.uri) {
							n.docv = t.docv
							return
						}
					break
				}
				case 1: {
					let n = this.diff[this.diff.length - 1]
					if (n) {
						if (n.op === 1 && n.item.extId === t.item.extId) {
							Ry(n.item, t.item)
							return
						}
						if (n.op === 0 && n.item.item.extId === t.item.extId) {
							Ry(n.item, t.item)
							return
						}
					}
					break
				}
			}
			this.diff.push(t), this.debounceSendDiff.isScheduled() || this.debounceSendDiff.schedule()
		}
		expand(t, n) {
			let r = this.tree.get(t)
			if (r) {
				if (((r.expandLevels === void 0 || n > r.expandLevels) && (r.expandLevels = n), r.expand === 1)) {
					let i = this.resolveChildren(r)
					return i.isOpen()
						? this.expandChildren(r, n - 1)
						: i.wait().then(() => this.expandChildren(r, n - 1))
				} else if (r.expand === 3)
					return r.resolveBarrier?.isOpen() === !1
						? r.resolveBarrier.wait().then(() => this.expandChildren(r, n - 1))
						: this.expandChildren(r, n - 1)
			}
		}
		dispose() {
			for (let t of this.tree.values()) this.options.getApiFor(t.actual).listener = void 0
			this.tree.clear(), (this.diff = []), super.dispose()
		}
		onTestItemEvent(t, n) {
			switch (n.op) {
				case 3:
					this.removeItem(ze.joinToString(t.fullId, n.id))
					break
				case 0:
					this.upsertItem(n.item, t)
					break
				case 5:
					for (let r of n.ops) this.onTestItemEvent(t, r)
					break
				case 1:
					this.diffTagRefs(n.new, n.old, t.fullId.toString())
					break
				case 2:
					this.updateExpandability(t)
					break
				case 4:
					this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), item: n.update } })
					break
				case 6:
					this.documentSynced(t.actual.uri)
					break
				default:
					uc(n)
			}
		}
		documentSynced(t) {
			t && this.pushDiff({ op: 2, uri: t, docv: this.options.getDocumentVersion(t) })
		}
		upsertItem(t, n) {
			let r = ze.fromExtHostTestItem(t, this.root.id, n?.actual),
				i = this.options.getApiFor(t)
			i.parent && i.parent !== n?.actual && this.options.getChildren(i.parent).delete(t.id)
			let s = this.tree.get(r.toString())
			if (!s) {
				;(s = { fullId: r, actual: t, expandLevels: n?.expandLevels ? n.expandLevels - 1 : void 0, expand: 0 }),
					t.tags.forEach(this.incrementTagRefs, this),
					this.tree.set(s.fullId.toString(), s),
					this.setItemParent(t, n),
					this.pushDiff({
						op: 0,
						item: {
							controllerId: this.options.controllerId,
							expand: s.expand,
							item: this.options.toITestItem(t),
						},
					}),
					this.connectItemAndChildren(t, s, n)
				return
			}
			if (s.actual === t) {
				this.connectItem(t, s, n)
				return
			}
			if (s.actual.uri?.toString() !== t.uri?.toString())
				return this.removeItem(r.toString()), this.upsertItem(t, n)
			let a = this.options.getChildren(s.actual),
				l = s.actual,
				d = I7(this.options.toITestItem(l), this.options.toITestItem(t))
			;(this.options.getApiFor(l).listener = void 0),
				(s.actual = t),
				(s.resolveBarrier = void 0),
				(s.expand = 0),
				d &&
					(d.hasOwnProperty("tags") && (this.diffTagRefs(t.tags, l.tags, r.toString()), delete d.tags),
					this.onTestItemEvent(s, { op: 4, update: d })),
				this.connectItemAndChildren(t, s, n)
			for (let [u, m] of a) this.options.getChildren(t).get(m.id) || this.removeItem(ze.joinToString(r, m.id))
			let c = s.expandLevels
			c !== void 0 &&
				queueMicrotask(() => {
					s.expand === 1 && ((s.expandLevels = void 0), this.expand(r.toString(), c))
				}),
				this.documentSynced(s.actual.uri)
		}
		diffTagRefs(t, n, r) {
			let i = new Set(n.map((s) => s.id))
			for (let s of t) i.delete(s.id) || this.incrementTagRefs(s)
			this.pushDiff({
				op: 1,
				item: { extId: r, item: { tags: t.map((s) => su(this.options.controllerId, s.id)) } },
			}),
				i.forEach(this.decrementTagRefs, this)
		}
		incrementTagRefs(t) {
			let n = this.tags.get(t.id)
			n
				? n.refCount++
				: (this.tags.set(t.id, { refCount: 1 }),
					this.pushDiff({ op: 6, tag: { id: su(this.options.controllerId, t.id) } }))
		}
		decrementTagRefs(t) {
			let n = this.tags.get(t)
			n && !--n.refCount && (this.tags.delete(t), this.pushDiff({ op: 7, id: su(this.options.controllerId, t) }))
		}
		setItemParent(t, n) {
			this.options.getApiFor(t).parent = n && n.actual !== this.root ? n.actual : void 0
		}
		connectItem(t, n, r) {
			this.setItemParent(t, r)
			let i = this.options.getApiFor(t)
			;(i.parent = r?.actual), (i.listener = (s) => this.onTestItemEvent(n, s)), this.updateExpandability(n)
		}
		connectItemAndChildren(t, n, r) {
			this.connectItem(t, n, r)
			for (let [i, s] of this.options.getChildren(t)) this.upsertItem(s, n)
		}
		updateExpandability(t) {
			let n
			this._resolveHandler
				? t.resolveBarrier
					? (n = t.resolveBarrier.isOpen() ? 3 : 2)
					: (n = t.actual.canResolveChildren ? 1 : 0)
				: (n = 0),
				n !== t.expand &&
					((t.expand = n),
					this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), expand: n } }),
					n === 1 && t.expandLevels !== void 0 && this.resolveChildren(t))
		}
		expandChildren(t, n) {
			if (n < 0) return
			let r = []
			for (let [i, s] of this.options.getChildren(t.actual)) {
				let a = this.expand(ze.joinToString(t.fullId, s.id), n)
				io(a) && r.push(a)
			}
			if (r.length) return Promise.all(r).then(() => {})
		}
		resolveChildren(t) {
			if (t.resolveBarrier) return t.resolveBarrier
			if (!this._resolveHandler) {
				let s = new dn()
				return s.open(), s
			}
			;(t.expand = 2), this.pushExpandStateUpdate(t)
			let n = (t.resolveBarrier = new dn()),
				r = (s) => {
					console.error(
						`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`,
						s,
					)
				},
				i
			try {
				i = this._resolveHandler(t.actual === this.root ? void 0 : t.actual)
			} catch (s) {
				r(s)
			}
			return (
				io(i)
					? i.catch(r).then(() => {
							n.open(), this.updateExpandability(t)
						})
					: (n.open(), this.updateExpandability(t)),
				t.resolveBarrier
			)
		}
		pushExpandStateUpdate(t) {
			this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), expand: t.expand } })
		}
		removeItem(t) {
			let n = this.tree.get(t)
			if (!n) throw new Error("attempting to remove non-existent child")
			this.pushDiff({ op: 3, itemId: t })
			let r = [n]
			for (; r.length; ) {
				let i = r.pop()
				if (i) {
					this.options.getApiFor(i.actual).listener = void 0
					for (let s of i.actual.tags) this.decrementTagRefs(s.id)
					this.tree.delete(i.fullId.toString())
					for (let [s, a] of this.options.getChildren(i.actual))
						r.push(this.tree.get(ze.joinToString(i.fullId, a.id)))
				}
			}
		}
		flushDiff() {
			let t = this.collectDiff()
			t.length && this.diffOpEmitter.fire(t)
		}
	},
	N_ = class extends Error {
		constructor(e) {
			super(`Attempted to insert a duplicate test item ID ${e}`)
		}
	},
	Ca = class extends Error {
		constructor(e) {
			super(`TestItem with ID "${e}" is invalid. Make sure to create it from the createTestItem method.`)
		}
	},
	U_ = class extends Error {
		constructor(e, t, n) {
			super(
				`TestItem with ID "${e}" is from controller "${t}" and cannot be added as a child of an item from controller "${n}".`,
			)
		}
	},
	dF = (o, e, t) => {
		let n = new Map()
		return {
			get size() {
				return n.size
			},
			forEach(r, i) {
				for (let s of n.values()) r.call(i, s, this)
			},
			[Symbol.iterator]() {
				return n.entries()
			},
			replace(r) {
				let i = new Map(),
					s = new Set(n.keys()),
					a = { op: 5, ops: [] }
				for (let l of r) {
					if (!(l instanceof t)) throw new Ca(l.id)
					let d = e(l).controllerId
					if (d !== o.controllerId) throw new U_(l.id, d, o.controllerId)
					if (i.has(l.id)) throw new N_(l.id)
					i.set(l.id, l), s.delete(l.id), a.ops.push({ op: 0, item: l })
				}
				for (let l of s.keys()) a.ops.push({ op: 3, id: l })
				o.listener?.(a), (n = i)
			},
			add(r) {
				if (!(r instanceof t)) throw new Ca(r.id)
				n.set(r.id, r), o.listener?.({ op: 0, item: r })
			},
			delete(r) {
				n.delete(r) && o.listener?.({ op: 3, id: r })
			},
			get(r) {
				return n.get(r)
			},
			toJSON() {
				return Array.from(n.values())
			},
		}
	}
var cF = new WeakMap(),
	uF = (o, e) => {
		let t = { controllerId: e }
		return cF.set(o, t), t
	},
	au = (o) => {
		let e = cF.get(o)
		if (!e) throw new Ca(o?.id || "<unknown>")
		return e
	}
var pF = O("remoteAuthorityResolverService")
var lu = class {
		constructor(e) {
			this.id = e
			this.type = 1
		}
		toString() {
			return `Managed(${this.id})`
		}
	},
	My = class {
		constructor(e, t) {
			this.host = e
			this.port = t
			this.type = 0
		}
		toString() {
			return `WebSocket(${this.host}:${this.port})`
		}
	}
var du = class o extends Kn {
	static isNotAvailable(e) {
		return e instanceof o && e._code === "NotAvailable"
	}
	static isTemporarilyNotAvailable(e) {
		return e instanceof o && e._code === "TemporarilyNotAvailable"
	}
	static isNoResolverFound(e) {
		return e instanceof o && e._code === "NoResolverFound"
	}
	static isInvalidAuthority(e) {
		return e instanceof o && e._code === "InvalidAuthority"
	}
	static isHandled(e) {
		return e instanceof o && e.isHandled
	}
	constructor(e, t = "Unknown", n) {
		super(e),
			(this._message = e),
			(this._code = t),
			(this._detail = n),
			(this.isHandled = t === "NotAvailable" && n === !0),
			Object.setPrototypeOf(this, o.prototype)
	}
}
function H_(o) {
	let e = o.indexOf("+")
	return e === -1 ? o : o.substring(0, e)
}
function me(o) {
	return Object.assign(o, {
		apply: function (...t) {
			if (t.length === 0) return Reflect.construct(o, [])
			{
				let n = t.length === 1 ? [] : t[1]
				return Reflect.construct(o, n, t[0].constructor)
			}
		},
		call: function (...t) {
			if (t.length === 0) return Reflect.construct(o, [])
			{
				let [n, ...r] = t
				return Reflect.construct(o, r, n.constructor)
			}
		},
	})
}
var W_ = ((t) => ((t[(t.Top = 0)] = "Top"), (t[(t.Bottom = 1)] = "Bottom"), t))(W_ || {})
var pd,
	ye = class {
		constructor(e) {
			qm(this, pd)
			Kh(this, pd, e)
		}
		static from(...e) {
			let t = e
			return new ye(function () {
				if (t) {
					for (let n of t) n && typeof n.dispose == "function" && n.dispose()
					t = void 0
				}
			})
		}
		dispose() {
			typeof sn(this, pd) == "function" && (sn(this, pd).call(this), Kh(this, pd, void 0))
		}
	}
;(pd = new WeakMap()), (ye = R([me], ye))
var Pe = class {
	static Min(...e) {
		if (e.length === 0) throw new TypeError()
		let t = e[0]
		for (let n = 1; n < e.length; n++) {
			let r = e[n]
			r.isBefore(t) && (t = r)
		}
		return t
	}
	static Max(...e) {
		if (e.length === 0) throw new TypeError()
		let t = e[0]
		for (let n = 1; n < e.length; n++) {
			let r = e[n]
			r.isAfter(t) && (t = r)
		}
		return t
	}
	static isPosition(e) {
		if (!e) return !1
		if (e instanceof Pe) return !0
		let { line: t, character: n } = e
		return typeof t == "number" && typeof n == "number"
	}
	static of(e) {
		if (e instanceof Pe) return e
		if (this.isPosition(e)) return new Pe(e.line, e.character)
		throw new Error("Invalid argument, is NOT a position-like object")
	}
	get line() {
		return this._line
	}
	get character() {
		return this._character
	}
	constructor(e, t) {
		if (e < 0) throw We("line must be non-negative")
		if (t < 0) throw We("character must be non-negative")
		;(this._line = e), (this._character = t)
	}
	isBefore(e) {
		return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character < e._character
	}
	isBeforeOrEqual(e) {
		return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character <= e._character
	}
	isAfter(e) {
		return !this.isBeforeOrEqual(e)
	}
	isAfterOrEqual(e) {
		return !this.isBefore(e)
	}
	isEqual(e) {
		return this._line === e._line && this._character === e._character
	}
	compareTo(e) {
		return this._line < e._line
			? -1
			: this._line > e.line
				? 1
				: this._character < e._character
					? -1
					: this._character > e._character
						? 1
						: 0
	}
	translate(e, t = 0) {
		if (e === null || t === null) throw We()
		let n
		return (
			typeof e > "u"
				? (n = 0)
				: typeof e == "number"
					? (n = e)
					: ((n = typeof e.lineDelta == "number" ? e.lineDelta : 0),
						(t = typeof e.characterDelta == "number" ? e.characterDelta : 0)),
			n === 0 && t === 0 ? this : new Pe(this.line + n, this.character + t)
		)
	}
	with(e, t = this.character) {
		if (e === null || t === null) throw We()
		let n
		return (
			typeof e > "u"
				? (n = this.line)
				: typeof e == "number"
					? (n = e)
					: ((n = typeof e.line == "number" ? e.line : this.line),
						(t = typeof e.character == "number" ? e.character : this.character)),
			n === this.line && t === this.character ? this : new Pe(n, t)
		)
	}
	toJSON() {
		return { line: this.line, character: this.character }
	}
	[Symbol.for("debug.description")]() {
		return `(${this.line}:${this.character})`
	}
}
Pe = R([me], Pe)
var pe = class {
	static isRange(e) {
		return e instanceof pe ? !0 : e ? Pe.isPosition(e.start) && Pe.isPosition(e.end) : !1
	}
	static of(e) {
		if (e instanceof pe) return e
		if (this.isRange(e)) return new pe(e.start, e.end)
		throw new Error("Invalid argument, is NOT a range-like object")
	}
	get start() {
		return this._start
	}
	get end() {
		return this._end
	}
	constructor(e, t, n, r) {
		let i, s
		if (
			(typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof r == "number"
				? ((i = new Pe(e, t)), (s = new Pe(n, r)))
				: Pe.isPosition(e) && Pe.isPosition(t) && ((i = Pe.of(e)), (s = Pe.of(t))),
			!i || !s)
		)
			throw new Error("Invalid arguments")
		i.isBefore(s) ? ((this._start = i), (this._end = s)) : ((this._start = s), (this._end = i))
	}
	contains(e) {
		return pe.isRange(e)
			? this.contains(e.start) && this.contains(e.end)
			: Pe.isPosition(e)
				? !(Pe.of(e).isBefore(this._start) || this._end.isBefore(e))
				: !1
	}
	isEqual(e) {
		return this._start.isEqual(e._start) && this._end.isEqual(e._end)
	}
	intersection(e) {
		let t = Pe.Max(e.start, this._start),
			n = Pe.Min(e.end, this._end)
		if (!t.isAfter(n)) return new pe(t, n)
	}
	union(e) {
		if (this.contains(e)) return this
		if (e.contains(this)) return e
		let t = Pe.Min(e.start, this._start),
			n = Pe.Max(e.end, this.end)
		return new pe(t, n)
	}
	get isEmpty() {
		return this._start.isEqual(this._end)
	}
	get isSingleLine() {
		return this._start.line === this._end.line
	}
	with(e, t = this.end) {
		if (e === null || t === null) throw We()
		let n
		return (
			e
				? Pe.isPosition(e)
					? (n = e)
					: ((n = e.start || this.start), (t = e.end || this.end))
				: (n = this.start),
			n.isEqual(this._start) && t.isEqual(this.end) ? this : new pe(n, t)
		)
	}
	toJSON() {
		return [this.start, this.end]
	}
	[Symbol.for("debug.description")]() {
		return fF(this)
	}
}
pe = R([me], pe)
var Vn = class extends pe {
	static isSelection(e) {
		return e instanceof Vn
			? !0
			: e
				? pe.isRange(e) &&
					Pe.isPosition(e.anchor) &&
					Pe.isPosition(e.active) &&
					typeof e.isReversed == "boolean"
				: !1
	}
	get anchor() {
		return this._anchor
	}
	get active() {
		return this._active
	}
	constructor(e, t, n, r) {
		let i, s
		if (
			(typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof r == "number"
				? ((i = new Pe(e, t)), (s = new Pe(n, r)))
				: Pe.isPosition(e) && Pe.isPosition(t) && ((i = Pe.of(e)), (s = Pe.of(t))),
			!i || !s)
		)
			throw new Error("Invalid arguments")
		super(i, s), (this._anchor = i), (this._active = s)
	}
	get isReversed() {
		return this._anchor === this._end
	}
	toJSON() {
		return { start: this.start, end: this.end, active: this.active, anchor: this.anchor }
	}
	[Symbol.for("debug.description")]() {
		return C7(this)
	}
}
Vn = R([me], Vn)
function fF(o) {
	return o.isEmpty
		? `[${o.start.line}:${o.start.character})`
		: `[${o.start.line}:${o.start.character} -> ${o.end.line}:${o.end.character})`
}
function C7(o) {
	let e = fF(o)
	return o.isEmpty || (o.active.isEqual(o.start) ? (e = `|${e}`) : (e = `${e}|`)), e
}
var gF = (o) => {
		if (typeof o != "string" || o.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(o)) throw We("connectionToken")
	},
	Fy = class {
		static isResolvedAuthority(e) {
			return (
				e &&
				typeof e == "object" &&
				typeof e.host == "string" &&
				typeof e.port == "number" &&
				(e.connectionToken === void 0 || typeof e.connectionToken == "string")
			)
		}
		constructor(e, t, n) {
			if (typeof e != "string" || e.length === 0) throw We("host")
			if (typeof t != "number" || t === 0 || Math.round(t) !== t) throw We("port")
			typeof n < "u" && gF(n), (this.host = e), (this.port = Math.round(t)), (this.connectionToken = n)
		}
	},
	Ha = class {
		constructor(e, t) {
			this.makeConnection = e
			this.connectionToken = t
			typeof t < "u" && gF(t)
		}
		static isManagedResolvedAuthority(e) {
			return (
				e &&
				typeof e == "object" &&
				typeof e.makeConnection == "function" &&
				(e.connectionToken === void 0 || typeof e.connectionToken == "string")
			)
		}
	},
	wi = class o extends Error {
		static NotAvailable(e, t) {
			return new o(e, "NotAvailable", t)
		}
		static TemporarilyNotAvailable(e) {
			return new o(e, "TemporarilyNotAvailable")
		}
		constructor(e, t = "Unknown", n) {
			super(e),
				(this._message = e),
				(this._code = t),
				(this._detail = n),
				Object.setPrototypeOf(this, o.prototype)
		}
	},
	qu = ((t) => ((t[(t.LF = 1)] = "LF"), (t[(t.CRLF = 2)] = "CRLF"), t))(qu || {}),
	lI = ((n) => (
		(n[(n.Replace = 1)] = "Replace"), (n[(n.Append = 2)] = "Append"), (n[(n.Prepend = 3)] = "Prepend"), n
	))(lI || {}),
	Ln = class {
		static isTextEdit(e) {
			return e instanceof Ln ? !0 : e ? pe.isRange(e) && typeof e.newText == "string" : !1
		}
		static replace(e, t) {
			return new Ln(e, t)
		}
		static insert(e, t) {
			return Ln.replace(new pe(e, e), t)
		}
		static delete(e) {
			return Ln.replace(e, "")
		}
		static setEndOfLine(e) {
			let t = new Ln(new pe(new Pe(0, 0), new Pe(0, 0)), "")
			return (t.newEol = e), t
		}
		get range() {
			return this._range
		}
		set range(e) {
			if (e && !pe.isRange(e)) throw We("range")
			this._range = e
		}
		get newText() {
			return this._newText || ""
		}
		set newText(e) {
			if (e && typeof e != "string") throw We("newText")
			this._newText = e
		}
		get newEol() {
			return this._newEol
		}
		set newEol(e) {
			if (e && typeof e != "number") throw We("newEol")
			this._newEol = e
		}
		constructor(e, t) {
			;(this._range = e), (this._newText = t)
		}
		toJSON() {
			return { range: this.range, newText: this.newText, newEol: this._newEol }
		}
	}
Ln = R([me], Ln)
var Fr = class {
	static isNotebookCellEdit(e) {
		return e instanceof Fr ? !0 : e ? dr.isNotebookRange(e) && Array.isArray(e.newCells) : !1
	}
	static replaceCells(e, t) {
		return new Fr(e, t)
	}
	static insertCells(e, t) {
		return new Fr(new dr(e, e), t)
	}
	static deleteCells(e) {
		return new Fr(e, [])
	}
	static updateCellMetadata(e, t) {
		let n = new Fr(new dr(e, e), [])
		return (n.newCellMetadata = t), n
	}
	static updateNotebookMetadata(e) {
		let t = new Fr(new dr(0, 0), [])
		return (t.newNotebookMetadata = e), t
	}
	constructor(e, t) {
		;(this.range = e), (this.newCells = t)
	}
}
Fr = R([me], Fr)
var gd = class o {
	static isSnippetTextEdit(e) {
		return e instanceof o ? !0 : e ? pe.isRange(e.range) && Wn.isSnippetString(e.snippet) : !1
	}
	static replace(e, t) {
		return new o(e, t)
	}
	static insert(e, t) {
		return o.replace(new pe(e, e), t)
	}
	constructor(e, t) {
		;(this.range = e), (this.snippet = t)
	}
}
var Jr = class {
	constructor() {
		this._edits = []
	}
	_allEntries() {
		return this._edits
	}
	renameFile(e, t, n, r) {
		this._edits.push({ _type: 1, from: e, to: t, options: n, metadata: r })
	}
	createFile(e, t, n) {
		this._edits.push({ _type: 1, from: void 0, to: e, options: t, metadata: n })
	}
	deleteFile(e, t, n) {
		this._edits.push({ _type: 1, from: e, to: void 0, options: t, metadata: n })
	}
	replaceNotebookMetadata(e, t, n) {
		this._edits.push({ _type: 3, metadata: n, uri: e, edit: { editType: 5, metadata: t } })
	}
	replaceNotebookCells(e, t, n, r) {
		let i = t.start,
			s = t.end
		;(i !== s || n.length > 0) &&
			this._edits.push({ _type: 5, uri: e, index: i, count: s - i, cells: n, metadata: r })
	}
	replaceNotebookCellMetadata(e, t, n, r) {
		this._edits.push({ _type: 3, metadata: r, uri: e, edit: { editType: 3, index: t, metadata: n } })
	}
	replace(e, t, n, r) {
		this._edits.push({ _type: 2, uri: e, edit: new Ln(t, n), metadata: r })
	}
	insert(e, t, n, r) {
		this.replace(e, new pe(t, t), n, r)
	}
	delete(e, t, n) {
		this.replace(e, t, "", n)
	}
	has(e) {
		return this._edits.some((t) => t._type === 2 && t.uri.toString() === e.toString())
	}
	set(e, t) {
		if (t)
			for (let n of t) {
				if (!n) continue
				let r, i
				Array.isArray(n) ? ((r = n[0]), (i = n[1])) : (r = n),
					Fr.isNotebookCellEdit(r)
						? r.newCellMetadata
							? this.replaceNotebookCellMetadata(e, r.range.start, r.newCellMetadata, i)
							: r.newNotebookMetadata
								? this.replaceNotebookMetadata(e, r.newNotebookMetadata, i)
								: this.replaceNotebookCells(e, r.range, r.newCells, i)
						: gd.isSnippetTextEdit(r)
							? this._edits.push({
									_type: 6,
									uri: e,
									range: r.range,
									edit: r.snippet,
									metadata: i,
									keepWhitespace: r.keepWhitespace,
								})
							: this._edits.push({ _type: 2, uri: e, edit: r, metadata: i })
			}
		else {
			for (let n = 0; n < this._edits.length; n++) {
				let r = this._edits[n]
				switch (r._type) {
					case 2:
					case 6:
					case 3:
					case 5:
						r.uri.toString() === e.toString() && (this._edits[n] = void 0)
						break
				}
			}
			A0(this._edits)
		}
	}
	get(e) {
		let t = []
		for (let n of this._edits) n._type === 2 && n.uri.toString() === e.toString() && t.push(n.edit)
		return t
	}
	entries() {
		let e = new ft()
		for (let t of this._edits)
			if (t._type === 2) {
				let n = e.get(t.uri)
				n || ((n = [t.uri, []]), e.set(t.uri, n)), n[1].push(t.edit)
			}
		return [...e.values()]
	}
	get size() {
		return this.entries().length
	}
	toJSON() {
		return this.entries()
	}
}
Jr = R([me], Jr)
var Wn = class {
	constructor(e) {
		this._tabstop = 1
		this.value = e || ""
	}
	static isSnippetString(e) {
		return e instanceof Wn ? !0 : e ? typeof e.value == "string" : !1
	}
	static _escape(e) {
		return e.replace(/\$|}|\\/g, "\\$&")
	}
	appendText(e) {
		return (this.value += Wn._escape(e)), this
	}
	appendTabstop(e = this._tabstop++) {
		return (this.value += "$"), (this.value += e), this
	}
	appendPlaceholder(e, t = this._tabstop++) {
		if (typeof e == "function") {
			let n = new Wn()
			;(n._tabstop = this._tabstop), e(n), (this._tabstop = n._tabstop), (e = n.value)
		} else e = Wn._escape(e)
		return (
			(this.value += "${"), (this.value += t), (this.value += ":"), (this.value += e), (this.value += "}"), this
		)
	}
	appendChoice(e, t = this._tabstop++) {
		let n = e.map((r) => r.replaceAll(/[|\\,]/g, "\\$&")).join(",")
		return (
			(this.value += "${"), (this.value += t), (this.value += "|"), (this.value += n), (this.value += "|}"), this
		)
	}
	appendVariable(e, t) {
		if (typeof t == "function") {
			let n = new Wn()
			;(n._tabstop = this._tabstop), t(n), (this._tabstop = n._tabstop), (t = n.value)
		} else typeof t == "string" && (t = t.replace(/\$|}/g, "\\$&"))
		return (
			(this.value += "${"),
			(this.value += e),
			t && ((this.value += ":"), (this.value += t)),
			(this.value += "}"),
			this
		)
	}
}
Wn = R([me], Wn)
var dI = ((t) => ((t[(t.Unnecessary = 1)] = "Unnecessary"), (t[(t.Deprecated = 2)] = "Deprecated"), t))(dI || {}),
	Ku = ((r) => (
		(r[(r.Hint = 3)] = "Hint"),
		(r[(r.Information = 2)] = "Information"),
		(r[(r.Warning = 1)] = "Warning"),
		(r[(r.Error = 0)] = "Error"),
		r
	))(Ku || {}),
	rn = class {
		static isLocation(e) {
			return e instanceof rn ? !0 : e ? pe.isRange(e.range) && y.isUri(e.uri) : !1
		}
		constructor(e, t) {
			if (((this.uri = e), t))
				if (pe.isRange(t)) this.range = pe.of(t)
				else if (Pe.isPosition(t)) this.range = new pe(t, t)
				else throw new Error("Illegal argument")
		}
		toJSON() {
			return { uri: this.uri, range: this.range }
		}
	}
rn = R([me], rn)
var hs = class {
	static is(e) {
		return e
			? typeof e.message == "string" && e.location && pe.isRange(e.location.range) && y.isUri(e.location.uri)
			: !1
	}
	constructor(e, t) {
		;(this.location = e), (this.message = t)
	}
	static isEqual(e, t) {
		return e === t
			? !0
			: !e || !t
				? !1
				: e.message === t.message &&
					e.location.range.isEqual(t.location.range) &&
					e.location.uri.toString() === t.location.uri.toString()
	}
}
hs = R([me], hs)
var Sa = class {
	constructor(e, t, n = 0) {
		if (!pe.isRange(e)) throw new TypeError("range must be set")
		if (!t) throw new TypeError("message must be set")
		;(this.range = e), (this.message = t), (this.severity = n)
	}
	toJSON() {
		return {
			severity: Ku[this.severity],
			message: this.message,
			range: this.range,
			source: this.source,
			code: this.code,
		}
	}
	static isEqual(e, t) {
		return e === t
			? !0
			: !e || !t
				? !1
				: e.message === t.message &&
					e.severity === t.severity &&
					e.code === t.code &&
					e.severity === t.severity &&
					e.source === t.source &&
					e.range.isEqual(t.range) &&
					mn(e.tags, t.tags) &&
					mn(e.relatedInformation, t.relatedInformation, hs.isEqual)
	}
}
Sa = R([me], Sa)
var ld = class {
	constructor(e, t) {
		if (!e) throw new Error("Illegal argument, contents must be defined")
		Array.isArray(e) ? (this.contents = e) : (this.contents = [e]), (this.range = t)
	}
}
ld = R([me], ld)
var Ta = class extends ld {
	constructor(e, t, n, r) {
		super(e, t), (this.canIncreaseVerbosity = n), (this.canDecreaseVerbosity = r)
	}
}
Ta = R([me], Ta)
var V_ = ((t) => ((t[(t.Increase = 0)] = "Increase"), (t[(t.Decrease = 1)] = "Decrease"), t))(V_ || {}),
	cI = ((n) => ((n[(n.Text = 0)] = "Text"), (n[(n.Read = 1)] = "Read"), (n[(n.Write = 2)] = "Write"), n))(cI || {}),
	Ea = class {
		constructor(e, t = 0) {
			;(this.range = e), (this.kind = t)
		}
		toJSON() {
			return { range: this.range, kind: cI[this.kind] }
		}
	}
Ea = R([me], Ea)
var wa = class {
	constructor(e, t) {
		;(this.uri = e), (this.highlights = t)
	}
	toJSON() {
		return { uri: this.uri, highlights: this.highlights.map((e) => e.toJSON()) }
	}
}
wa = R([me], wa)
var og = ((j) => (
		(j[(j.File = 0)] = "File"),
		(j[(j.Module = 1)] = "Module"),
		(j[(j.Namespace = 2)] = "Namespace"),
		(j[(j.Package = 3)] = "Package"),
		(j[(j.Class = 4)] = "Class"),
		(j[(j.Method = 5)] = "Method"),
		(j[(j.Property = 6)] = "Property"),
		(j[(j.Field = 7)] = "Field"),
		(j[(j.Constructor = 8)] = "Constructor"),
		(j[(j.Enum = 9)] = "Enum"),
		(j[(j.Interface = 10)] = "Interface"),
		(j[(j.Function = 11)] = "Function"),
		(j[(j.Variable = 12)] = "Variable"),
		(j[(j.Constant = 13)] = "Constant"),
		(j[(j.String = 14)] = "String"),
		(j[(j.Number = 15)] = "Number"),
		(j[(j.Boolean = 16)] = "Boolean"),
		(j[(j.Array = 17)] = "Array"),
		(j[(j.Object = 18)] = "Object"),
		(j[(j.Key = 19)] = "Key"),
		(j[(j.Null = 20)] = "Null"),
		(j[(j.EnumMember = 21)] = "EnumMember"),
		(j[(j.Struct = 22)] = "Struct"),
		(j[(j.Event = 23)] = "Event"),
		(j[(j.Operator = 24)] = "Operator"),
		(j[(j.TypeParameter = 25)] = "TypeParameter"),
		j
	))(og || {}),
	uI = ((e) => ((e[(e.Deprecated = 1)] = "Deprecated"), e))(uI || {}),
	ho = class {
		static validate(e) {
			if (!e.name) throw new Error("name must not be falsy")
		}
		constructor(e, t, n, r, i) {
			;(this.name = e),
				(this.kind = t),
				(this.containerName = i),
				typeof n == "string" && (this.containerName = n),
				r instanceof rn ? (this.location = r) : n instanceof pe && (this.location = new rn(r, n)),
				ho.validate(this)
		}
		toJSON() {
			return { name: this.name, kind: og[this.kind], location: this.location, containerName: this.containerName }
		}
	}
ho = R([me], ho)
var Xr = class {
	static validate(e) {
		if (!e.name) throw new Error("name must not be falsy")
		if (!e.range.contains(e.selectionRange)) throw new Error("selectionRange must be contained in fullRange")
		e.children?.forEach(Xr.validate)
	}
	constructor(e, t, n, r, i) {
		;(this.name = e),
			(this.detail = t),
			(this.kind = n),
			(this.range = r),
			(this.selectionRange = i),
			(this.children = []),
			Xr.validate(this)
	}
}
Xr = R([me], Xr)
var pI = ((t) => ((t[(t.Invoke = 1)] = "Invoke"), (t[(t.Automatic = 2)] = "Automatic"), t))(pI || {}),
	yi = class {
		constructor(e, t) {
			;(this.title = e), (this.kind = t)
		}
	}
yi = R([me], yi)
var lt = class {
	constructor(e) {
		this.value = e
	}
	append(e) {
		return new lt(this.value ? this.value + lt.sep + e : e)
	}
	intersects(e) {
		return this.contains(e) || e.contains(this)
	}
	contains(e) {
		return this.value === e.value || e.value.startsWith(this.value + lt.sep)
	}
}
;(lt.sep = "."), (lt = R([me], lt))
lt.Empty = new lt("")
lt.QuickFix = lt.Empty.append("quickfix")
lt.Refactor = lt.Empty.append("refactor")
lt.RefactorExtract = lt.Refactor.append("extract")
lt.RefactorInline = lt.Refactor.append("inline")
lt.RefactorMove = lt.Refactor.append("move")
lt.RefactorRewrite = lt.Refactor.append("rewrite")
lt.Source = lt.Empty.append("source")
lt.SourceOrganizeImports = lt.Source.append("organizeImports")
lt.SourceFixAll = lt.Source.append("fixAll")
lt.Notebook = lt.Empty.append("notebook")
var Ii = class {
	constructor(e, t) {
		if (((this.range = e), (this.parent = t), t && !t.range.contains(this.range)))
			throw new Error("Invalid argument: parent must contain this range")
	}
}
Ii = R([me], Ii)
var Wa = class {
		constructor(e, t, n, r, i, s) {
			;(this.kind = e),
				(this.name = t),
				(this.detail = n),
				(this.uri = r),
				(this.range = i),
				(this.selectionRange = s)
		}
	},
	yu = class {
		constructor(e, t) {
			;(this.fromRanges = t), (this.from = e)
		}
	},
	Iu = class {
		constructor(e, t) {
			;(this.fromRanges = t), (this.to = e)
		}
	},
	mI = ((n) => (
		(n[(n.Information = 0)] = "Information"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Error = 2)] = "Error"), n
	))(mI || {}),
	Pa = class {
		constructor(e, t) {
			;(this.range = e), (this.command = t)
		}
		get isResolved() {
			return !!this.command
		}
	}
Pa = R([me], Pa)
var Yn,
	en = class {
		constructor(e, t = !1) {
			qm(this, Yn)
			Kh(this, Yn, new Vo(e, { supportThemeIcons: t }))
		}
		static isMarkdownString(e) {
			return e instanceof en
				? !0
				: e && e.appendCodeblock && e.appendMarkdown && e.appendText && e.value !== void 0
		}
		get value() {
			return sn(this, Yn).value
		}
		set value(e) {
			sn(this, Yn).value = e
		}
		get isTrusted() {
			return sn(this, Yn).isTrusted
		}
		set isTrusted(e) {
			sn(this, Yn).isTrusted = e
		}
		get supportThemeIcons() {
			return sn(this, Yn).supportThemeIcons
		}
		set supportThemeIcons(e) {
			sn(this, Yn).supportThemeIcons = e
		}
		get supportHtml() {
			return sn(this, Yn).supportHtml
		}
		set supportHtml(e) {
			sn(this, Yn).supportHtml = e
		}
		get baseUri() {
			return sn(this, Yn).baseUri
		}
		set baseUri(e) {
			sn(this, Yn).baseUri = e
		}
		appendText(e) {
			return sn(this, Yn).appendText(e), this
		}
		appendMarkdown(e) {
			return sn(this, Yn).appendMarkdown(e), this
		}
		appendCodeblock(e, t) {
			return sn(this, Yn).appendCodeblock(t ?? "", e), this
		}
	}
;(Yn = new WeakMap()), (en = R([me], en))
var cu = class {
	constructor(e, t) {
		;(this.label = e), (this.documentation = t)
	}
}
cu = R([me], cu)
var uu = class {
	constructor(e, t) {
		;(this.label = e), (this.documentation = t), (this.parameters = [])
	}
}
uu = R([me], uu)
var pu = class {
	constructor() {
		this.activeSignature = 0
		this.activeParameter = 0
		this.signatures = []
	}
}
pu = R([me], pu)
var B_ = ((n) => (
		(n[(n.Invoke = 1)] = "Invoke"),
		(n[(n.TriggerCharacter = 2)] = "TriggerCharacter"),
		(n[(n.ContentChange = 3)] = "ContentChange"),
		n
	))(B_ || {}),
	$_ = ((t) => ((t[(t.Type = 1)] = "Type"), (t[(t.Parameter = 2)] = "Parameter"), t))($_ || {}),
	_a = class {
		constructor(e) {
			this.value = e
		}
	}
_a = R([me], _a)
var Da = class {
	constructor(e, t, n) {
		;(this.position = e), (this.label = t), (this.kind = n)
	}
}
Da = R([me], Da)
var fI = ((n) => (
		(n[(n.Invoke = 0)] = "Invoke"),
		(n[(n.TriggerCharacter = 1)] = "TriggerCharacter"),
		(n[(n.TriggerForIncompleteCompletions = 2)] = "TriggerForIncompleteCompletions"),
		n
	))(fI || {}),
	ig = ((K) => (
		(K[(K.Text = 0)] = "Text"),
		(K[(K.Method = 1)] = "Method"),
		(K[(K.Function = 2)] = "Function"),
		(K[(K.Constructor = 3)] = "Constructor"),
		(K[(K.Field = 4)] = "Field"),
		(K[(K.Variable = 5)] = "Variable"),
		(K[(K.Class = 6)] = "Class"),
		(K[(K.Interface = 7)] = "Interface"),
		(K[(K.Module = 8)] = "Module"),
		(K[(K.Property = 9)] = "Property"),
		(K[(K.Unit = 10)] = "Unit"),
		(K[(K.Value = 11)] = "Value"),
		(K[(K.Enum = 12)] = "Enum"),
		(K[(K.Keyword = 13)] = "Keyword"),
		(K[(K.Snippet = 14)] = "Snippet"),
		(K[(K.Color = 15)] = "Color"),
		(K[(K.File = 16)] = "File"),
		(K[(K.Reference = 17)] = "Reference"),
		(K[(K.Folder = 18)] = "Folder"),
		(K[(K.EnumMember = 19)] = "EnumMember"),
		(K[(K.Constant = 20)] = "Constant"),
		(K[(K.Struct = 21)] = "Struct"),
		(K[(K.Event = 22)] = "Event"),
		(K[(K.Operator = 23)] = "Operator"),
		(K[(K.TypeParameter = 24)] = "TypeParameter"),
		(K[(K.User = 25)] = "User"),
		(K[(K.Issue = 26)] = "Issue"),
		K
	))(ig || {}),
	gI = ((e) => ((e[(e.Deprecated = 1)] = "Deprecated"), e))(gI || {}),
	ka = class {
		constructor(e, t) {
			;(this.label = e), (this.kind = t)
		}
		toJSON() {
			return {
				label: this.label,
				kind: this.kind && ig[this.kind],
				detail: this.detail,
				documentation: this.documentation,
				sortText: this.sortText,
				filterText: this.filterText,
				preselect: this.preselect,
				insertText: this.insertText,
				textEdit: this.textEdit,
			}
		}
	}
ka = R([me], ka)
var Bo = class {
	constructor(e = [], t = !1) {
		;(this.items = e), (this.isIncomplete = t)
	}
}
Bo = R([me], Bo)
var mu = class {
	constructor(e, t, n) {
		;(this.insertText = e), (this.range = t), (this.command = n)
	}
}
mu = R([me], mu)
var fu = class {
	constructor(e) {
		this.commands = void 0
		this.suppressSuggestions = void 0
		this.items = e
	}
}
fu = R([me], fu)
var hI = ((r) => (
		(r[(r.Unknown = 0)] = "Unknown"),
		(r[(r.Word = 1)] = "Word"),
		(r[(r.Line = 2)] = "Line"),
		(r[(r.Suggest = 3)] = "Suggest"),
		r
	))(hI || {}),
	vI = ((u) => (
		(u[(u.Active = -1)] = "Active"),
		(u[(u.Beside = -2)] = "Beside"),
		(u[(u.One = 1)] = "One"),
		(u[(u.Two = 2)] = "Two"),
		(u[(u.Three = 3)] = "Three"),
		(u[(u.Four = 4)] = "Four"),
		(u[(u.Five = 5)] = "Five"),
		(u[(u.Six = 6)] = "Six"),
		(u[(u.Seven = 7)] = "Seven"),
		(u[(u.Eight = 8)] = "Eight"),
		(u[(u.Nine = 9)] = "Nine"),
		u
	))(vI || {}),
	bI = ((t) => ((t[(t.Left = 1)] = "Left"), (t[(t.Right = 2)] = "Right"), t))(bI || {})
function hF(o, e) {
	return `${we.toKey(o)}.${e}`
}
var yI = ((r) => (
		(r[(r.Off = 0)] = "Off"),
		(r[(r.On = 1)] = "On"),
		(r[(r.Relative = 2)] = "Relative"),
		(r[(r.Interval = 3)] = "Interval"),
		r
	))(yI || {}),
	II = ((n) => (
		(n[(n.Manual = 1)] = "Manual"), (n[(n.AfterDelay = 2)] = "AfterDelay"), (n[(n.FocusOut = 3)] = "FocusOut"), n
	))(II || {}),
	xI = ((r) => (
		(r[(r.Default = 0)] = "Default"),
		(r[(r.InCenter = 1)] = "InCenter"),
		(r[(r.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
		(r[(r.AtTop = 3)] = "AtTop"),
		r
	))(xI || {}),
	xd = ((n) => (
		(n[(n.Keyboard = 1)] = "Keyboard"), (n[(n.Mouse = 2)] = "Mouse"), (n[(n.Command = 3)] = "Command"), n
	))(xd || {}),
	CI = ((n) => (
		(n[(n.Addition = 1)] = "Addition"),
		(n[(n.Deletion = 2)] = "Deletion"),
		(n[(n.Modification = 3)] = "Modification"),
		n
	))(CI || {}),
	SI = ((t) => ((t[(t.Undo = 1)] = "Undo"), (t[(t.Redo = 2)] = "Redo"), t))(SI || {}),
	TI = ((r) => (
		(r[(r.OpenOpen = 0)] = "OpenOpen"),
		(r[(r.ClosedClosed = 1)] = "ClosedClosed"),
		(r[(r.OpenClosed = 2)] = "OpenClosed"),
		(r[(r.ClosedOpen = 3)] = "ClosedOpen"),
		r
	))(TI || {})
;((e) => {
	function o(t) {
		switch (t) {
			case "keyboard":
				return 1
			case "mouse":
				return 2
			case "api":
			case "code.jump":
			case "code.navigation":
				return 3
		}
	}
	e.fromValue = o
})((xd ||= {}))
var Cd = ((r) => (
	(r[(r.Other = 0)] = "Other"),
	(r[(r.Comment = 1)] = "Comment"),
	(r[(r.String = 2)] = "String"),
	(r[(r.RegEx = 3)] = "RegEx"),
	r
))(Cd || {})
;((e) => {
	function o(t) {
		switch (t) {
			case 0:
				return "other"
			case 1:
				return "comment"
			case 2:
				return "string"
			case 3:
				return "regex"
		}
		return "other"
	}
	e.toString = o
})((Cd ||= {}))
var Ra = class {
	constructor(e, t) {
		if (t && !y.isUri(t)) throw We("target")
		if (!pe.isRange(e) || e.isEmpty) throw We("range")
		;(this.range = e), (this.target = t)
	}
}
Ra = R([me], Ra)
var $o = class {
	constructor(e, t, n, r) {
		;(this.red = e), (this.green = t), (this.blue = n), (this.alpha = r)
	}
}
$o = R([me], $o)
var Aa = class {
	constructor(e, t) {
		if (t && !(t instanceof $o)) throw We("color")
		if (!pe.isRange(e) || e.isEmpty) throw We("range")
		;(this.range = e), (this.color = t)
	}
}
Aa = R([me], Aa)
var Oa = class {
	constructor(e) {
		if (!e || typeof e != "string") throw We("label")
		this.label = e
	}
}
Oa = R([me], Oa)
var z_ = ((n) => (
		(n[(n.Error = 0)] = "Error"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Information = 2)] = "Information"), n
	))(z_ || {}),
	q_ = ((i) => (
		(i[(i.Unknown = 0)] = "Unknown"),
		(i[(i.Shutdown = 1)] = "Shutdown"),
		(i[(i.Process = 2)] = "Process"),
		(i[(i.User = 3)] = "User"),
		(i[(i.Extension = 4)] = "Extension"),
		i
	))(q_ || {}),
	EI = ((n) => ((n[(n.Low = 0)] = "Low"), (n[(n.Medium = 1)] = "Medium"), (n[(n.High = 2)] = "High"), n))(EI || {}),
	K_ = ((f) => (
		(f[(f.Sh = 1)] = "Sh"),
		(f[(f.Bash = 2)] = "Bash"),
		(f[(f.Fish = 3)] = "Fish"),
		(f[(f.Csh = 4)] = "Csh"),
		(f[(f.Ksh = 5)] = "Ksh"),
		(f[(f.Zsh = 6)] = "Zsh"),
		(f[(f.CommandPrompt = 7)] = "CommandPrompt"),
		(f[(f.GitBash = 8)] = "GitBash"),
		(f[(f.PowerShell = 9)] = "PowerShell"),
		(f[(f.Python = 10)] = "Python"),
		(f[(f.Julia = 11)] = "Julia"),
		(f[(f.NuShell = 12)] = "NuShell"),
		(f[(f.Node = 13)] = "Node"),
		f
	))(K_ || {}),
	Ny = class {
		constructor(e, t, n) {
			this.startIndex = e
			this.length = t
			this.tooltip = n
			if (typeof e != "number" || e < 0) throw We("startIndex")
			if (typeof t != "number" || t < 1) throw We("length")
			if (n !== void 0 && typeof n != "string") throw We("tooltip")
		}
	},
	Uy = class {
		constructor(e) {
			this.uri = e
		}
	},
	Hy = class {
		constructor(e) {
			this.terminalCommand = e
		}
	},
	j_ = ((t) => ((t[(t.Panel = 1)] = "Panel"), (t[(t.Editor = 2)] = "Editor"), t))(j_ || {}),
	Wy = class {
		constructor(e) {
			this.options = e
			if (typeof e != "object") throw We("options")
		}
	},
	G_ = ((l) => (
		(l[(l.File = 0)] = "File"),
		(l[(l.Folder = 1)] = "Folder"),
		(l[(l.Method = 2)] = "Method"),
		(l[(l.Alias = 3)] = "Alias"),
		(l[(l.Argument = 4)] = "Argument"),
		(l[(l.Option = 5)] = "Option"),
		(l[(l.OptionValue = 6)] = "OptionValue"),
		(l[(l.Flag = 7)] = "Flag"),
		l
	))(G_ || {}),
	Vy = class {
		constructor(e, t, n, r, i, s, a, l, d) {
			;(this.label = e),
				(this.icon = t),
				(this.detail = n),
				(this.documentation = r),
				(this.isFile = i),
				(this.isDirectory = s),
				(this.isKeyword = a),
				(this.replacementIndex = l ?? 0),
				(this.replacementLength = d ?? 0)
		}
	},
	By = class {
		constructor(e, t) {
			;(this.items = e ?? []), (this.resourceRequestConfig = t)
		}
	},
	Q_ = ((n) => ((n[(n.Always = 1)] = "Always"), (n[(n.Silent = 2)] = "Silent"), (n[(n.Never = 3)] = "Never"), n))(
		Q_ || {},
	),
	J_ = ((f) => (
		(f.Changed = "changed"),
		(f.ProcessStarted = "processStarted"),
		(f.ProcessEnded = "processEnded"),
		(f.Terminated = "terminated"),
		(f.Start = "start"),
		(f.AcquiredInput = "acquiredInput"),
		(f.DependsOnStarted = "dependsOnStarted"),
		(f.Active = "active"),
		(f.Inactive = "inactive"),
		(f.End = "end"),
		(f.ProblemMatcherStarted = "problemMatcherStarted"),
		(f.ProblemMatcherEnded = "problemMatcherEnded"),
		(f.ProblemMatcherFoundErrors = "problemMatcherFoundErrors"),
		f
	))(J_ || {}),
	X_ = ((n) => ((n[(n.Shared = 1)] = "Shared"), (n[(n.Dedicated = 2)] = "Dedicated"), (n[(n.New = 3)] = "New"), n))(
		X_ || {},
	),
	un = class {
		constructor(e, t) {
			this.label = t
			if (typeof e != "string") throw We("name")
			if (typeof t != "string") throw We("name")
			this._id = e
		}
		static from(e) {
			switch (e) {
				case "clean":
					return un.Clean
				case "build":
					return un.Build
				case "rebuild":
					return un.Rebuild
				case "test":
					return un.Test
				default:
					return
			}
		}
		get id() {
			return this._id
		}
	}
;(un.Clean = new un("clean", "Clean")),
	(un.Build = new un("build", "Build")),
	(un.Rebuild = new un("rebuild", "Rebuild")),
	(un.Test = new un("test", "Test")),
	(un = R([me], un))
function vF(o) {
	let e = ""
	for (let t = 0; t < o.length; t++) e += o[t].replace(/,/g, ",,") + ","
	return e
}
var xi = class {
	constructor(e, t, n) {
		if (typeof e != "string") throw We("process")
		;(this._args = []),
			(this._process = e),
			t !== void 0 && (Array.isArray(t) ? ((this._args = t), (this._options = n)) : (this._options = t))
	}
	get process() {
		return this._process
	}
	set process(e) {
		if (typeof e != "string") throw We("process")
		this._process = e
	}
	get args() {
		return this._args
	}
	set args(e) {
		Array.isArray(e) || (e = []), (this._args = e)
	}
	get options() {
		return this._options
	}
	set options(e) {
		this._options = e
	}
	computeId() {
		let e = []
		if ((e.push("process"), this._process !== void 0 && e.push(this._process), this._args && this._args.length > 0))
			for (let t of this._args) e.push(t)
		return vF(e)
	}
}
xi = R([me], xi)
var zo = class {
	constructor(e, t, n) {
		this._args = []
		if (Array.isArray(t)) {
			if (!e) throw We("command can't be undefined or null")
			if (typeof e != "string" && typeof e.value != "string") throw We("command")
			;(this._command = e), t && (this._args = t), (this._options = n)
		} else {
			if (typeof e != "string") throw We("commandLine")
			;(this._commandLine = e), (this._options = t)
		}
	}
	get commandLine() {
		return this._commandLine
	}
	set commandLine(e) {
		if (typeof e != "string") throw We("commandLine")
		this._commandLine = e
	}
	get command() {
		return this._command ? this._command : ""
	}
	set command(e) {
		if (typeof e != "string" && typeof e.value != "string") throw We("command")
		this._command = e
	}
	get args() {
		return this._args
	}
	set args(e) {
		this._args = e || []
	}
	get options() {
		return this._options
	}
	set options(e) {
		this._options = e
	}
	computeId() {
		let e = []
		if (
			(e.push("shell"),
			this._commandLine !== void 0 && e.push(this._commandLine),
			this._command !== void 0 && e.push(typeof this._command == "string" ? this._command : this._command.value),
			this._args && this._args.length > 0)
		)
			for (let t of this._args) e.push(typeof t == "string" ? t : t.value)
		return vF(e)
	}
}
zo = R([me], zo)
var Y_ = ((n) => ((n[(n.Escape = 1)] = "Escape"), (n[(n.Strong = 2)] = "Strong"), (n[(n.Weak = 3)] = "Weak"), n))(
		Y_ || {},
	),
	wI = ((t) => ((t[(t.Global = 1)] = "Global"), (t[(t.Workspace = 2)] = "Workspace"), t))(wI || {}),
	hd = class {
		constructor(e) {
			this._callback = e
		}
		computeId() {
			return "customExecution" + He()
		}
		set callback(e) {
			this._callback = e
		}
		get callback() {
			return this._callback
		}
	},
	gn = class {
		constructor(e, t, n, r, i, s) {
			this.__deprecated = !1
			this._definition = this.definition = e
			let a
			typeof t == "string"
				? ((this._name = this.name = t),
					(this._source = this.source = n),
					(this.execution = r),
					(a = i),
					(this.__deprecated = !0))
				: t === 1 || t === 2
					? ((this.target = t),
						(this._name = this.name = n),
						(this._source = this.source = r),
						(this.execution = i),
						(a = s))
					: ((this.target = t),
						(this._name = this.name = n),
						(this._source = this.source = r),
						(this.execution = i),
						(a = s)),
				typeof a == "string"
					? ((this._problemMatchers = [a]), (this._hasDefinedMatchers = !0))
					: Array.isArray(a)
						? ((this._problemMatchers = a), (this._hasDefinedMatchers = !0))
						: ((this._problemMatchers = []), (this._hasDefinedMatchers = !1)),
				(this._isBackground = !1),
				(this._presentationOptions = Object.create(null)),
				(this._runOptions = Object.create(null))
		}
		get _id() {
			return this.__id
		}
		set _id(e) {
			this.__id = e
		}
		get _deprecated() {
			return this.__deprecated
		}
		clear() {
			this.__id !== void 0 &&
				((this.__id = void 0), (this._scope = void 0), this.computeDefinitionBasedOnExecution())
		}
		computeDefinitionBasedOnExecution() {
			this._execution instanceof xi
				? (this._definition = { type: gn.ProcessType, id: this._execution.computeId() })
				: this._execution instanceof zo
					? (this._definition = { type: gn.ShellType, id: this._execution.computeId() })
					: this._execution instanceof hd
						? (this._definition = { type: gn.ExtensionCallbackType, id: this._execution.computeId() })
						: (this._definition = { type: gn.EmptyType, id: He() })
		}
		get definition() {
			return this._definition
		}
		set definition(e) {
			if (e == null) throw We("Kind can't be undefined or null")
			this.clear(), (this._definition = e)
		}
		get scope() {
			return this._scope
		}
		set target(e) {
			this.clear(), (this._scope = e)
		}
		get name() {
			return this._name
		}
		set name(e) {
			if (typeof e != "string") throw We("name")
			this.clear(), (this._name = e)
		}
		get execution() {
			return this._execution
		}
		set execution(e) {
			e === null && (e = void 0), this.clear(), (this._execution = e)
			let t = this._definition.type
			;(gn.EmptyType === t || gn.ProcessType === t || gn.ShellType === t || gn.ExtensionCallbackType === t) &&
				this.computeDefinitionBasedOnExecution()
		}
		get problemMatchers() {
			return this._problemMatchers
		}
		set problemMatchers(e) {
			if (Array.isArray(e)) this.clear(), (this._problemMatchers = e), (this._hasDefinedMatchers = !0)
			else {
				this.clear(), (this._problemMatchers = []), (this._hasDefinedMatchers = !1)
				return
			}
		}
		get hasDefinedMatchers() {
			return this._hasDefinedMatchers
		}
		get isBackground() {
			return this._isBackground
		}
		set isBackground(e) {
			e !== !0 && e !== !1 && (e = !1), this.clear(), (this._isBackground = e)
		}
		get source() {
			return this._source
		}
		set source(e) {
			if (typeof e != "string" || e.length === 0) throw We("source must be a string of length > 0")
			this.clear(), (this._source = e)
		}
		get group() {
			return this._group
		}
		set group(e) {
			e === null && (e = void 0), this.clear(), (this._group = e)
		}
		get detail() {
			return this._detail
		}
		set detail(e) {
			e === null && (e = void 0), (this._detail = e)
		}
		get presentationOptions() {
			return this._presentationOptions
		}
		set presentationOptions(e) {
			e == null && (e = Object.create(null)), this.clear(), (this._presentationOptions = e)
		}
		get runOptions() {
			return this._runOptions
		}
		set runOptions(e) {
			e == null && (e = Object.create(null)), this.clear(), (this._runOptions = e)
		}
	}
;(gn.ExtensionCallbackType = "customExecution"),
	(gn.ProcessType = "process"),
	(gn.ShellType = "shell"),
	(gn.EmptyType = "$empty"),
	(gn = R([me], gn))
var PI = ((n) => (
		(n[(n.SourceControl = 1)] = "SourceControl"),
		(n[(n.Window = 10)] = "Window"),
		(n[(n.Notification = 15)] = "Notification"),
		n
	))(PI || {}),
	Z_
;((e) => {
	function o(t) {
		let n = t
		return fn(n.value)
			? n.tooltip && !Ee(n.tooltip)
				? (console.log("INVALID view badge, invalid tooltip", n.tooltip), !1)
				: !0
			: (console.log("INVALID view badge, invalid value", n.value), !1)
	}
	e.isViewBadge = o
})((Z_ ||= {}))
var Ci = class {
	constructor(e, t = 0) {
		this.collapsibleState = t
		y.isUri(e) ? (this.resourceUri = e) : (this.label = e)
	}
	static isTreeItem(e, t) {
		let n = e
		if (n.checkboxState !== void 0) {
			let r = fn(n.checkboxState)
					? n.checkboxState
					: dt(n.checkboxState) && fn(n.checkboxState.state)
						? n.checkboxState.state
						: void 0,
				i = !fn(n.checkboxState) && dt(n.checkboxState) ? n.checkboxState.tooltip : void 0
			if (r === void 0 || (r !== 1 && r !== 0) || (i !== void 0 && !Ee(i)))
				return console.log("INVALID tree item, invalid checkboxState", n.checkboxState), !1
		}
		if (e instanceof Ci) return !0
		if (n.label !== void 0 && !Ee(n.label) && !n.label?.label)
			return console.log("INVALID tree item, invalid label", n.label), !1
		if (n.id !== void 0 && !Ee(n.id)) return console.log("INVALID tree item, invalid id", n.id), !1
		if (n.iconPath !== void 0 && !Ee(n.iconPath) && !y.isUri(n.iconPath) && (!n.iconPath || !Ee(n.iconPath.id))) {
			let r = n.iconPath
			if (!r || (!Ee(r.light) && !y.isUri(r.light) && !Ee(r.dark) && !y.isUri(r.dark)))
				return console.log("INVALID tree item, invalid iconPath", n.iconPath), !1
		}
		return n.description !== void 0 && !Ee(n.description) && typeof n.description != "boolean"
			? (console.log("INVALID tree item, invalid description", n.description), !1)
			: n.resourceUri !== void 0 && !y.isUri(n.resourceUri)
				? (console.log("INVALID tree item, invalid resourceUri", n.resourceUri), !1)
				: n.tooltip !== void 0 && !Ee(n.tooltip) && !(n.tooltip instanceof en)
					? (console.log("INVALID tree item, invalid tooltip", n.tooltip), !1)
					: n.command !== void 0 && !n.command.command
						? (console.log("INVALID tree item, invalid command", n.command), !1)
						: n.collapsibleState !== void 0 && n.collapsibleState < 0 && n.collapsibleState > 2
							? (console.log("INVALID tree item, invalid collapsibleState", n.collapsibleState), !1)
							: n.contextValue !== void 0 && !Ee(n.contextValue)
								? (console.log("INVALID tree item, invalid contextValue", n.contextValue), !1)
								: n.accessibilityInformation !== void 0 && !n.accessibilityInformation?.label
									? (console.log(
											"INVALID tree item, invalid accessibilityInformation",
											n.accessibilityInformation,
										),
										!1)
									: !0
	}
}
Ci = R([me], Ci)
var _I = ((n) => (
		(n[(n.None = 0)] = "None"), (n[(n.Collapsed = 1)] = "Collapsed"), (n[(n.Expanded = 2)] = "Expanded"), n
	))(_I || {}),
	DI = ((t) => ((t[(t.Unchecked = 0)] = "Unchecked"), (t[(t.Checked = 1)] = "Checked"), t))(DI || {}),
	dd = class {
		constructor(e) {
			this.value = e
		}
		async asString() {
			return typeof this.value == "string" ? this.value : JSON.stringify(this.value)
		}
		asFile() {}
	}
dd = R([me], dd)
var Va = class extends dd {},
	$y = class extends Va {
		#e
		constructor(e) {
			super(""), (this.#e = e)
		}
		asFile() {
			return this.#e
		}
	},
	zy = class {
		constructor(e, t, n, r) {
			;(this.name = e), (this.uri = t), (this._itemId = n), (this._getData = r)
		}
		data() {
			return this._getData()
		}
	},
	gs,
	md,
	rg,
	vo = class {
		constructor(e) {
			qm(this, md)
			qm(this, gs, new Map())
			for (let [t, n] of e ?? []) {
				let r = sn(this, gs).get(Km(this, md, rg).call(this, t))
				r ? r.push(n) : sn(this, gs).set(Km(this, md, rg).call(this, t), [n])
			}
		}
		get(e) {
			return sn(this, gs).get(Km(this, md, rg).call(this, e))?.[0]
		}
		set(e, t) {
			sn(this, gs).set(Km(this, md, rg).call(this, e), [t])
		}
		forEach(e, t) {
			for (let [n, r] of sn(this, gs)) for (let i of r) e.call(t, i, n, this)
		}
		*[Symbol.iterator]() {
			for (let [e, t] of sn(this, gs)) for (let n of t) yield [e, n]
		}
	}
;(gs = new WeakMap()),
	(md = new WeakSet()),
	(rg = function (e) {
		return e.toLowerCase()
	}),
	(vo = R([me], vo))
var gu = class {
	constructor(e, t, n) {
		;(this.insertText = e), (this.title = t), (this.kind = n)
	}
}
gu = R([me], gu)
var eD = ((t) => ((t[(t.Automatic = 0)] = "Automatic"), (t[(t.PasteAs = 1)] = "PasteAs"), t))(eD || {}),
	bo = class o {
		constructor(e) {
			this.value = e
		}
		static {
			this.sep = "."
		}
		append(...e) {
			return new o((this.value ? [this.value, ...e] : e).join(o.sep))
		}
		intersects(e) {
			return this.contains(e) || e.contains(this)
		}
		contains(e) {
			return this.value === e.value || e.value.startsWith(this.value + o.sep)
		}
	}
bo.Empty = new bo("")
bo.Text = new bo("text")
bo.TextUpdateImports = bo.Text.append("updateImports")
var qy = class {
		constructor(e, t, n) {
			;(this.title = t), (this.insertText = e), (this.kind = n)
		}
	},
	Vt = class {
		constructor(e, t) {
			;(this.id = e), (this.color = t)
		}
		static isThemeIcon(e) {
			return typeof e.id != "string" ? (console.log("INVALID ThemeIcon, invalid id", e.id), !1) : !0
		}
	}
Vt = R([me], Vt)
Vt.File = new Vt("file")
Vt.Folder = new Vt("folder")
var vs = class {
	constructor(e) {
		this.id = e
	}
}
vs = R([me], vs)
var kI = ((n) => (
		(n[(n.Global = 1)] = "Global"),
		(n[(n.Workspace = 2)] = "Workspace"),
		(n[(n.WorkspaceFolder = 3)] = "WorkspaceFolder"),
		n
	))(kI || {}),
	Si = class {
		get base() {
			return this._base
		}
		set base(e) {
			;(this._base = e), (this._baseUri = y.file(e))
		}
		get baseUri() {
			return this._baseUri
		}
		set baseUri(e) {
			;(this._baseUri = e), (this._base = e.fsPath)
		}
		constructor(e, t) {
			if (typeof e != "string" && (!e || (!y.isUri(e) && !y.isUri(e.uri)))) throw We("base")
			if (typeof t != "string") throw We("pattern")
			typeof e == "string"
				? (this.baseUri = y.file(e))
				: y.isUri(e)
					? (this.baseUri = e)
					: (this.baseUri = e.uri),
				(this.pattern = t)
		}
		toJSON() {
			return { pattern: this.pattern, base: this.base, baseUri: this.baseUri.toJSON() }
		}
	}
Si = R([me], Si)
var bF = new WeakMap()
function yF(o, e) {
	bF.set(o, e)
}
var bs = class {
	constructor(e, t, n, r, i) {
		;(this.enabled = typeof e == "boolean" ? e : !0),
			typeof t == "string" && (this.condition = t),
			typeof n == "string" && (this.hitCondition = n),
			typeof r == "string" && (this.logMessage = r),
			typeof i == "string" && (this.mode = i)
	}
	get id() {
		return this._id || (this._id = bF.get(this) ?? He()), this._id
	}
}
bs = R([me], bs)
var qo = class extends bs {
	constructor(e, t, n, r, i, s) {
		if ((super(t, n, r, i, s), e === null)) throw We("location")
		this.location = e
	}
}
qo = R([me], qo)
var Ko = class extends bs {
	constructor(e, t, n, r, i, s) {
		super(t, n, r, i, s), (this.functionName = e)
	}
}
Ko = R([me], Ko)
var cd = class extends bs {
	constructor(e, t, n, r, i, s, a, l) {
		if ((super(r, i, s, a, l), !t)) throw We("dataId")
		;(this.label = e), (this.dataId = t), (this.canPersist = n)
	}
}
cd = R([me], cd)
var jo = class {
	constructor(e, t, n) {
		;(this.command = e), (this.args = t || []), (this.options = n)
	}
}
jo = R([me], jo)
var Go = class {
	constructor(e, t) {
		;(this.port = e), (this.host = t)
	}
}
Go = R([me], Go)
var Ti = class {
	constructor(e) {
		this.path = e
	}
}
Ti = R([me], Ti)
var ys = class {
	constructor(e) {
		this.implementation = e
	}
}
ys = R([me], ys)
var xu = class {
		constructor(e, t, n) {
			this.session = e
			this.threadId = t
			this.frameId = n
		}
	},
	Cu = class {
		constructor(e, t) {
			this.session = e
			this.threadId = t
		}
	},
	La = class {
		constructor(e, t) {
			;(this.range = e), (this.expression = t)
		}
	}
La = R([me], La)
var RI = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(RI || {}),
	Ma = class {
		constructor(e, t) {
			;(this.range = e), (this.text = t)
		}
	}
Ma = R([me], Ma)
var Fa = class {
	constructor(e, t, n = !0) {
		;(this.range = e), (this.variableName = t), (this.caseSensitiveLookup = n)
	}
}
Fa = R([me], Fa)
var Na = class {
	constructor(e, t) {
		;(this.range = e), (this.expression = t)
	}
}
Na = R([me], Na)
var hu = class {
	constructor(e, t) {
		;(this.frameId = e), (this.stoppedLocation = t)
	}
}
hu = R([me], hu)
var tD = ((e) => ((e[(e.AIGenerated = 1)] = "AIGenerated"), e))(tD || {}),
	AI = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(AI || {}),
	Ky = class {
		constructor(e, t) {
			;(this.newSymbolName = e), (this.tags = t)
		}
	},
	OI = ((n) => (
		(n[(n.Changed = 1)] = "Changed"), (n[(n.Created = 2)] = "Created"), (n[(n.Deleted = 3)] = "Deleted"), n
	))(OI || {}),
	rt = class extends Error {
		static FileExists(e) {
			return new rt(e, "EntryExists", rt.FileExists)
		}
		static FileNotFound(e) {
			return new rt(e, "EntryNotFound", rt.FileNotFound)
		}
		static FileNotADirectory(e) {
			return new rt(e, "EntryNotADirectory", rt.FileNotADirectory)
		}
		static FileIsADirectory(e) {
			return new rt(e, "EntryIsADirectory", rt.FileIsADirectory)
		}
		static NoPermissions(e) {
			return new rt(e, "NoPermissions", rt.NoPermissions)
		}
		static Unavailable(e) {
			return new rt(e, "Unavailable", rt.Unavailable)
		}
		constructor(e, t = "Unknown", n) {
			super(y.isUri(e) ? e.toString(!0) : e),
				(this.code = n?.name ?? "Unknown"),
				cP(this, t),
				Object.setPrototypeOf(this, rt.prototype),
				typeof Error.captureStackTrace == "function" &&
					typeof n == "function" &&
					Error.captureStackTrace(this, n)
		}
	}
rt = R([me], rt)
var vu = class {
	constructor(e, t, n) {
		;(this.start = e), (this.end = t), (this.kind = n)
	}
}
vu = R([me], vu)
var LI = ((n) => (
		(n[(n.Comment = 1)] = "Comment"), (n[(n.Imports = 2)] = "Imports"), (n[(n.Region = 3)] = "Region"), n
	))(LI || {}),
	MI = ((t) => ((t[(t.Collapsed = 0)] = "Collapsed"), (t[(t.Expanded = 1)] = "Expanded"), t))(MI || {}),
	nD = ((t) => ((t[(t.Editing = 0)] = "Editing"), (t[(t.Preview = 1)] = "Preview"), t))(nD || {}),
	rD = ((t) => ((t[(t.Published = 0)] = "Published"), (t[(t.Draft = 1)] = "Draft"), t))(rD || {}),
	FI = ((t) => ((t[(t.Unresolved = 0)] = "Unresolved"), (t[(t.Resolved = 1)] = "Resolved"), t))(FI || {}),
	NI = ((t) => ((t[(t.Current = 0)] = "Current"), (t[(t.Outdated = 1)] = "Outdated"), t))(NI || {}),
	UI = ((t) => ((t[(t.Reply = 1)] = "Reply"), (t[(t.Comment = 2)] = "Comment"), t))(UI || {}),
	vd = class {
		constructor(e, t = []) {
			;(this.tokenTypes = e), (this.tokenModifiers = t)
		}
	}
function S7(o) {
	return typeof o > "u" || W0(o)
}
var jy = class o {
		constructor(e) {
			if (
				((this._prevLine = 0),
				(this._prevChar = 0),
				(this._dataIsSortedAndDeltaEncoded = !0),
				(this._data = []),
				(this._dataLen = 0),
				(this._tokenTypeStrToInt = new Map()),
				(this._tokenModifierStrToInt = new Map()),
				(this._hasLegend = !1),
				e)
			) {
				this._hasLegend = !0
				for (let t = 0, n = e.tokenTypes.length; t < n; t++) this._tokenTypeStrToInt.set(e.tokenTypes[t], t)
				for (let t = 0, n = e.tokenModifiers.length; t < n; t++)
					this._tokenModifierStrToInt.set(e.tokenModifiers[t], t)
			}
		}
		push(e, t, n, r, i) {
			if (
				typeof e == "number" &&
				typeof t == "number" &&
				typeof n == "number" &&
				typeof r == "number" &&
				(typeof i == "number" || typeof i > "u")
			)
				return typeof i > "u" && (i = 0), this._pushEncoded(e, t, n, r, i)
			if (pe.isRange(e) && typeof t == "string" && S7(n)) return this._push(e, t, n)
			throw We()
		}
		_push(e, t, n) {
			if (!this._hasLegend) throw new Error("Legend must be provided in constructor")
			if (e.start.line !== e.end.line) throw new Error("`range` cannot span multiple lines")
			if (!this._tokenTypeStrToInt.has(t)) throw new Error("`tokenType` is not in the provided legend")
			let r = e.start.line,
				i = e.start.character,
				s = e.end.character - e.start.character,
				a = this._tokenTypeStrToInt.get(t),
				l = 0
			if (n)
				for (let d of n) {
					if (!this._tokenModifierStrToInt.has(d))
						throw new Error("`tokenModifier` is not in the provided legend")
					let c = this._tokenModifierStrToInt.get(d)
					l |= (1 << c) >>> 0
				}
			this._pushEncoded(r, i, s, a, l)
		}
		_pushEncoded(e, t, n, r, i) {
			if (
				this._dataIsSortedAndDeltaEncoded &&
				(e < this._prevLine || (e === this._prevLine && t < this._prevChar))
			) {
				this._dataIsSortedAndDeltaEncoded = !1
				let l = (this._data.length / 5) | 0,
					d = 0,
					c = 0
				for (let u = 0; u < l; u++) {
					let m = this._data[5 * u],
						f = this._data[5 * u + 1]
					m === 0 ? ((m = d), (f += c)) : (m += d),
						(this._data[5 * u] = m),
						(this._data[5 * u + 1] = f),
						(d = m),
						(c = f)
				}
			}
			let s = e,
				a = t
			this._dataIsSortedAndDeltaEncoded &&
				this._dataLen > 0 &&
				((s -= this._prevLine), s === 0 && (a -= this._prevChar)),
				(this._data[this._dataLen++] = s),
				(this._data[this._dataLen++] = a),
				(this._data[this._dataLen++] = n),
				(this._data[this._dataLen++] = r),
				(this._data[this._dataLen++] = i),
				(this._prevLine = e),
				(this._prevChar = t)
		}
		static _sortAndDeltaEncode(e) {
			let t = [],
				n = (e.length / 5) | 0
			for (let a = 0; a < n; a++) t[a] = a
			t.sort((a, l) => {
				let d = e[5 * a],
					c = e[5 * l]
				if (d === c) {
					let u = e[5 * a + 1],
						m = e[5 * l + 1]
					return u - m
				}
				return d - c
			})
			let r = new Uint32Array(e.length),
				i = 0,
				s = 0
			for (let a = 0; a < n; a++) {
				let l = 5 * t[a],
					d = e[l + 0],
					c = e[l + 1],
					u = e[l + 2],
					m = e[l + 3],
					f = e[l + 4],
					h = d - i,
					g = h === 0 ? c - s : c,
					I = 5 * a
				;(r[I + 0] = h), (r[I + 1] = g), (r[I + 2] = u), (r[I + 3] = m), (r[I + 4] = f), (i = d), (s = c)
			}
			return r
		}
		build(e) {
			return this._dataIsSortedAndDeltaEncoded
				? new Qo(new Uint32Array(this._data), e)
				: new Qo(o._sortAndDeltaEncode(this._data), e)
		}
	},
	Qo = class {
		constructor(e, t) {
			;(this.resultId = t), (this.data = e)
		}
	},
	Su = class {
		constructor(e, t, n) {
			;(this.start = e), (this.deleteCount = t), (this.data = n)
		}
	},
	Ba = class {
		constructor(e, t) {
			;(this.resultId = t), (this.edits = e)
		}
	},
	HI = ((t) => ((t[(t.Separate = 0)] = "Separate"), (t[(t.MergeWithParent = 1)] = "MergeWithParent"), t))(HI || {}),
	Gy = class {
		constructor(e) {
			this.name = e
		}
	},
	oD = ((t) => ((t[(t.Title = 1)] = "Title"), (t[(t.Inline = 2)] = "Inline"), t))(oD || {}),
	bi = class {
		constructor() {}
	}
;(bi.Back = { iconPath: new Vt("arrow-left") }), (bi = R([me], bi))
var WI = ((t) => ((t[(t.Separator = -1)] = "Separator"), (t[(t.Default = 0)] = "Default"), t))(WI || {}),
	VI = ((n) => ((n[(n.Info = 1)] = "Info"), (n[(n.Warning = 2)] = "Warning"), (n[(n.Error = 3)] = "Error"), n))(
		VI || {},
	),
	BI = ((t) => ((t[(t.UI = 1)] = "UI"), (t[(t.Workspace = 2)] = "Workspace"), t))(BI || {}),
	bd = class {
		static validate(e) {
			if (typeof e.badge == "string") {
				let t = mE(e.badge, 0)
				if ((t < e.badge.length && (t += mE(e.badge, t)), e.badge.length > t))
					throw new Error("The 'badge'-property must be undefined or a short character")
			} else if (e.badge && !Vt.isThemeIcon(e.badge))
				throw new Error("The 'badge'-property is not a valid ThemeIcon")
			if (!e.color && !e.badge && !e.tooltip) throw new Error("The decoration is empty")
			return !0
		}
		constructor(e, t, n) {
			;(this.badge = e), (this.tooltip = t), (this.color = n)
		}
	},
	ud = class {
		constructor(e) {
			this.kind = e
		}
	}
ud = R([me], ud)
var $I = ((r) => (
		(r[(r.Light = 1)] = "Light"),
		(r[(r.Dark = 2)] = "Dark"),
		(r[(r.HighContrast = 3)] = "HighContrast"),
		(r[(r.HighContrastLight = 4)] = "HighContrastLight"),
		r
	))($I || {}),
	dr = class o {
		static isNotebookRange(e) {
			return e instanceof o ? !0 : e ? typeof e.start == "number" && typeof e.end == "number" : !1
		}
		get start() {
			return this._start
		}
		get end() {
			return this._end
		}
		get isEmpty() {
			return this._start === this._end
		}
		constructor(e, t) {
			if (e < 0) throw We("start must be positive")
			if (t < 0) throw We("end must be positive")
			e <= t ? ((this._start = e), (this._end = t)) : ((this._start = t), (this._end = e))
		}
		with(e) {
			let t = this._start,
				n = this._end
			return (
				e.start !== void 0 && (t = e.start),
				e.end !== void 0 && (n = e.end),
				t === this._start && n === this._end ? this : new o(t, n)
			)
		}
	},
	xs = class o {
		static validate(e) {
			if (typeof e.kind != "number") throw new Error("NotebookCellData MUST have 'kind' property")
			if (typeof e.value != "string") throw new Error("NotebookCellData MUST have 'value' property")
			if (typeof e.languageId != "string") throw new Error("NotebookCellData MUST have 'languageId' property")
		}
		static isNotebookCellDataArray(e) {
			return Array.isArray(e) && e.every((t) => o.isNotebookCellData(t))
		}
		static isNotebookCellData(e) {
			return !0
		}
		constructor(e, t, n, r, i, s, a) {
			;(this.kind = e),
				(this.value = t),
				(this.languageId = n),
				(this.mime = r),
				(this.outputs = i ?? []),
				(this.metadata = s),
				(this.executionSummary = a),
				o.validate(this)
		}
	},
	Tu = class {
		constructor(e) {
			this.cells = e
		}
	},
	Eu = class o {
		constructor(e, t) {
			this.data = e
			this.mime = t
			let n = PP(t, !0)
			if (!n) throw new Error(`INVALID mime type: ${t}. Must be in the format "type/subtype[;optionalparameter]"`)
			this.mime = n
		}
		static isNotebookCellOutputItem(e) {
			return e instanceof o ? !0 : e ? typeof e.mime == "string" && e.data instanceof Uint8Array : !1
		}
		static error(e) {
			let t = { name: e.name, message: e.message, stack: e.stack }
			return o.json(t, "application/vnd.code.notebook.error")
		}
		static stdout(e) {
			return o.text(e, "application/vnd.code.notebook.stdout")
		}
		static stderr(e) {
			return o.text(e, "application/vnd.code.notebook.stderr")
		}
		static bytes(e, t = "application/octet-stream") {
			return new o(e, t)
		}
		static #e = new TextEncoder()
		static text(e, t = po.text) {
			let n = o.#e.encode(String(e))
			return new o(n, t)
		}
		static json(e, t = "text/x-json") {
			let n = JSON.stringify(e, void 0, "	")
			return o.text(n, t)
		}
	},
	Cs = class o {
		static isNotebookCellOutput(e) {
			return e instanceof o
				? !0
				: !e || typeof e != "object"
					? !1
					: typeof e.id == "string" && Array.isArray(e.items)
		}
		static ensureUniqueMimeTypes(e, t = !1) {
			let n = new Set(),
				r = new Set()
			for (let i = 0; i < e.length; i++) {
				let s = e[i],
					a = PP(s.mime)
				if (!n.has(a) || Qb(a)) {
					n.add(a)
					continue
				}
				r.add(i), t && console.warn(`DUPLICATED mime type '${s.mime}' will be dropped`)
			}
			return r.size === 0 ? e : e.filter((i, s) => !r.has(s))
		}
		constructor(e, t, n) {
			;(this.items = o.ensureUniqueMimeTypes(e, !0)),
				typeof t == "string"
					? ((this.id = t), (this.metadata = n))
					: ((this.id = He()), (this.metadata = t ?? n))
		}
	},
	Qy = class {
		constructor(e, t, n) {
			this.label = e
			this.uri = t
			this.position = n
		}
	},
	zI = ((t) => ((t[(t.Markup = 1)] = "Markup"), (t[(t.Code = 2)] = "Code"), t))(zI || {}),
	sg = ((n) => (
		(n[(n.Idle = 1)] = "Idle"), (n[(n.Pending = 2)] = "Pending"), (n[(n.Executing = 3)] = "Executing"), n
	))(sg || {}),
	qI = ((t) => ((t[(t.Left = 1)] = "Left"), (t[(t.Right = 2)] = "Right"), t))(qI || {}),
	KI = ((r) => (
		(r[(r.Default = 0)] = "Default"),
		(r[(r.InCenter = 1)] = "InCenter"),
		(r[(r.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
		(r[(r.AtTop = 3)] = "AtTop"),
		r
	))(KI || {}),
	Jy = class {
		constructor(e, t) {
			this.text = e
			this.alignment = t
		}
	},
	iD = ((t) => ((t[(t.Default = 1)] = "Default"), (t[(t.Preferred = 2)] = "Preferred"), t))(iD || {}),
	jI = ((n) => (
		(n[(n.Default = 1)] = "Default"), (n[(n.Preferred = 2)] = "Preferred"), (n[(n.Hidden = -1)] = "Hidden"), n
	))(jI || {}),
	wu = class {
		constructor(e, t = []) {
			this.uri = e
			this.provides = an(t)
		}
	},
	Xy = class {
		constructor(e) {
			this.label = e
		}
	},
	GI = ((t) => ((t[(t.Named = 1)] = "Named"), (t[(t.Indexed = 2)] = "Indexed"), t))(GI || {}),
	bu = class {
		constructor(e, t) {
			this.label = e
			this.timestamp = t
		}
	}
bu = R([me], bu)
var QI = ((n) => (
		(n[(n.Production = 1)] = "Production"), (n[(n.Development = 2)] = "Development"), (n[(n.Test = 3)] = "Test"), n
	))(QI || {}),
	JI = ((t) => ((t[(t.Node = 1)] = "Node"), (t[(t.Webworker = 2)] = "Webworker"), t))(JI || {}),
	ag = ((r) => (
		(r[(r.Other = 0)] = "Other"),
		(r[(r.Comment = 1)] = "Comment"),
		(r[(r.String = 2)] = "String"),
		(r[(r.RegEx = 3)] = "RegEx"),
		r
	))(ag || {}),
	Yy = class {
		constructor(e, t) {
			this.ranges = e
			this.wordPattern = t
		}
	},
	Zy = class {
		constructor(e) {
			this._autoForwardAction = e
		}
		get autoForwardAction() {
			return this._autoForwardAction
		}
	},
	sD = ((s) => (
		(s[(s.Queued = 1)] = "Queued"),
		(s[(s.Running = 2)] = "Running"),
		(s[(s.Passed = 3)] = "Passed"),
		(s[(s.Failed = 4)] = "Failed"),
		(s[(s.Skipped = 5)] = "Skipped"),
		(s[(s.Errored = 6)] = "Errored"),
		s
	))(sD || {}),
	XI = ((n) => ((n[(n.Run = 1)] = "Run"), (n[(n.Debug = 2)] = "Debug"), (n[(n.Coverage = 3)] = "Coverage"), n))(
		XI || {},
	),
	Pu = class {
		constructor(e, t, n) {
			this.controllerId = e
			this.profileId = t
			this.kind = n
		}
	},
	Ua = class {
		constructor(e = void 0, t = void 0, n = void 0, r = !1, i = !0) {
			this.include = e
			this.exclude = t
			this.profile = n
			this.continuous = r
			this.preserveFocus = i
		}
	}
Ua = R([me], Ua)
var Ei = class {
	constructor(e) {
		this.message = e
	}
	static diff(e, t, n) {
		let r = new Ei(e)
		return (r.expectedOutput = t), (r.actualOutput = n), r
	}
}
Ei = R([me], Ei)
var Is = class {
	constructor(e) {
		this.id = e
	}
}
Is = R([me], Is)
var eI = class {
		constructor(e, t, n) {
			this.label = e
			this.uri = t
			this.position = n
		}
	},
	fd = class {
		constructor(e, t) {
			this.covered = e
			this.total = t
			lg(this)
		}
	}
function lg(o) {
	if (o) {
		if (o.covered > o.total)
			throw new Error(
				`The total number of covered items (${o.covered}) cannot be greater than the total (${o.total})`,
			)
		if (o.total < 0) throw new Error(`The number of covered items (${o.total}) cannot be negative`)
	}
}
var Ss = class o {
		constructor(e, t, n, r, i = []) {
			this.uri = e
			this.statementCoverage = t
			this.branchCoverage = n
			this.declarationCoverage = r
			this.includesTests = i
		}
		static fromDetails(e, t) {
			let n = new fd(0, 0),
				r = new fd(0, 0),
				i = new fd(0, 0)
			for (let a of t)
				if ("branches" in a) {
					;(n.total += 1), (n.covered += a.executed ? 1 : 0)
					for (let l of a.branches) (r.total += 1), (r.covered += l.executed ? 1 : 0)
				} else (i.total += 1), (i.covered += a.executed ? 1 : 0)
			let s = new o(e, n, r.total > 0 ? r : void 0, i.total > 0 ? i : void 0)
			return (s.detailedCoverage = t), s
		}
	},
	_u = class {
		constructor(e, t, n = []) {
			this.executed = e
			this.location = t
			this.branches = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	Du = class {
		constructor(e, t, n) {
			this.executed = e
			this.location = t
			this.label = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	ku = class {
		constructor(e, t, n) {
			this.name = e
			this.executed = t
			this.location = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	aD = ((r) => (
		(r[(r.None = 0)] = "None"),
		(r[(r.Option = 1)] = "Option"),
		(r[(r.Default = 2)] = "Default"),
		(r[(r.Preferred = 3)] = "Preferred"),
		r
	))(aD || {}),
	lD = ((n) => (
		(n[(n.Untrusted = 0)] = "Untrusted"),
		(n[(n.Trusted = 1)] = "Trusted"),
		(n[(n.Unspecified = 2)] = "Unspecified"),
		n
	))(lD || {}),
	dD = ((s) => (
		(s[(s.Notify = 1)] = "Notify"),
		(s[(s.OpenBrowser = 2)] = "OpenBrowser"),
		(s[(s.OpenPreview = 3)] = "OpenPreview"),
		(s[(s.Silent = 4)] = "Silent"),
		(s[(s.Ignore = 5)] = "Ignore"),
		(s[(s.OpenBrowserOnce = 6)] = "OpenBrowserOnce"),
		s
	))(dD || {}),
	$a = class {
		constructor(e, t, n, r, i, s) {
			;(this.kind = e),
				(this.name = t),
				(this.detail = n),
				(this.uri = r),
				(this.range = i),
				(this.selectionRange = s)
		}
	},
	za = class {
		constructor(e) {
			this.uri = e
		}
	},
	Ts = class {
		constructor(e, t) {
			this.original = e
			this.modified = t
		}
	},
	Ru = class {
		constructor(e, t, n, r) {
			this.base = e
			this.input1 = t
			this.input2 = n
			this.result = r
		}
	},
	qa = class {
		constructor(e, t) {
			this.uri = e
			this.viewType = t
		}
	},
	Au = class {
		constructor(e) {
			this.viewType = e
		}
	},
	Ka = class {
		constructor(e, t) {
			this.uri = e
			this.notebookType = t
		}
	},
	ja = class {
		constructor(e, t, n) {
			this.original = e
			this.modified = t
			this.notebookType = n
		}
	},
	Ou = class {
		constructor() {}
	},
	Lu = class {
		constructor(e, t) {
			this.uri = e
			this.inputBoxUri = t
		}
	},
	Mu = class {
		constructor() {}
	},
	Fu = class {
		constructor(e) {
			this.textDiffs = e
		}
	},
	cD = ((t) => ((t[(t.Down = 0)] = "Down"), (t[(t.Up = 1)] = "Up"), t))(cD || {}),
	uD = ((t) => ((t[(t.Action = 1)] = "Action"), (t[(t.Toolbar = 2)] = "Toolbar"), t))(uD || {}),
	pD = ((n) => ((n[(n.Short = 1)] = "Short"), (n[(n.Medium = 2)] = "Medium"), (n[(n.Full = 3)] = "Full"), n))(
		pD || {},
	),
	tI = class {
		constructor(e, t, n) {
			;(this.id = e), (this.label = t), (this.values = n)
		}
	},
	YI = ((n) => (
		(n[(n.Accepted = 1)] = "Accepted"), (n[(n.Rejected = 2)] = "Rejected"), (n[(n.Saved = 3)] = "Saved"), n
	))(YI || {}),
	mD = ((i) => (
		(i[(i.Unhelpful = 0)] = "Unhelpful"),
		(i[(i.Helpful = 1)] = "Helpful"),
		(i[(i.Undone = 2)] = "Undone"),
		(i[(i.Accepted = 3)] = "Accepted"),
		(i[(i.Bug = 4)] = "Bug"),
		i
	))(mD || {}),
	ZI = ((t) => ((t[(t.Unhelpful = 0)] = "Unhelpful"), (t[(t.Helpful = 1)] = "Helpful"), t))(ZI || {}),
	Es = class {
		constructor(e) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			this.value = typeof e == "string" ? new en(e) : e
		}
	},
	Pi = class {
		constructor(e, t) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			;(this.value = typeof e == "string" ? new en(e) : e), (this.vulnerabilities = t)
		}
	},
	ws = class {
		constructor(e, t, n, r) {
			;(this.title = e), (this.message = t), (this.data = n), (this.buttons = r)
		}
	},
	Ps = class {
		constructor(e, t) {
			;(this.value = e), (this.baseUri = t)
		}
	},
	_i = class {
		constructor(e, t) {
			;(this.value = e), (this.value2 = e), (this.title = t)
		}
	},
	yd = class {
		constructor(e) {
			this.value = e
		}
	},
	Ga = class {
		constructor(e, t) {
			;(this.value = e), (this.task = t)
		}
	},
	Di = class {
		constructor(e) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			this.value = typeof e == "string" ? new en(e) : e
		}
	},
	_s = class {
		constructor(e) {
			this.value = e
		}
	},
	yo = class {
		constructor(e, t, n) {
			;(this.value = e), (this.iconPath = t), (this.options = n)
		}
	},
	Ds = class {
		constructor(e, t) {
			;(this.value = e), (this.isEdit = t)
		}
	},
	ks = class {
		constructor(e, t, n) {
			;(this.value = e), (this.license = t), (this.snippet = n)
		}
	},
	Rs = class {
		constructor(e, t) {
			this.uri = e
			this.range = t
		}
	},
	ki = class {
		constructor(e, t) {
			;(this.uri = e),
				t === !0 ? ((this.isDone = !0), (this.edits = [])) : (this.edits = Array.isArray(t) ? t : [t])
		}
	},
	As = class {
		constructor(e, t) {
			;(this.uri = e),
				t === !0 ? ((this.isDone = !0), (this.edits = [])) : (this.edits = Array.isArray(t) ? t : [t])
		}
	},
	Nu = class {
		constructor(e, t, n, r, i) {
			this.prompt = e
			this.command = t
			this.references = n
			this.participant = r
			this.toolReferences = i
		}
	},
	Uu = class {
		constructor(e, t, n, r) {
			this.response = e
			this.result = t
			this.participant = n
			this.command = r
		}
	},
	ex = ((r) => (
		(r[(r.Panel = 1)] = "Panel"),
		(r[(r.Terminal = 2)] = "Terminal"),
		(r[(r.Notebook = 3)] = "Notebook"),
		(r[(r.Editor = 4)] = "Editor"),
		r
	))(ex || {}),
	fD = ((n) => (
		(n[(n.Complete = 1)] = "Complete"), (n[(n.Partial = 2)] = "Partial"), (n[(n.Omitted = 3)] = "Omitted"), n
	))(fD || {}),
	Hu = class {
		constructor(e, t, n) {
			this.document = e
			this.selection = t
			this.wholeRange = n
		}
	},
	Wu = class {
		constructor(e) {
			this.cell = e
		}
	},
	Vu = class {
		constructor(e, t, n) {
			;(this.mimeType = e), (this.data = t), (this.reference = n)
		}
	},
	Bu = class {
		constructor(e) {
			this.diagnostics = e
		}
	},
	dg = ((n) => ((n[(n.User = 1)] = "User"), (n[(n.Assistant = 2)] = "Assistant"), (n[(n.System = 3)] = "System"), n))(
		dg || {},
	),
	Os = class {
		constructor(e, t, n) {
			;(this.callId = e), (this.content = t), (this.isError = n ?? !1)
		}
	},
	nI = class {
		constructor(e, t, n) {
			this.command = e
			this.language = t
			this.confirmationMessages = n
		}
	},
	gD = ((n) => ((n[(n.Info = 0)] = "Info"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Error = 2)] = "Error"), n))(
		gD || {},
	),
	$u = class o {
		constructor(e, t, n) {
			this._content = []
			;(this.role = e), (this.content = t), (this.name = n)
		}
		static User(e, t) {
			return new o(1, e, t)
		}
		static Assistant(e, t) {
			return new o(2, e, t)
		}
		set content(e) {
			typeof e == "string" ? (this._content = [new Pt(e)]) : (this._content = e)
		}
		get content() {
			return this._content
		}
		set content2(e) {
			e && (this.content = e.map((t) => (typeof t == "string" ? new Pt(t) : t)))
		}
		get content2() {
			return this.content.map((e) => (e instanceof Pt ? e.value : e))
		}
	},
	zu = class o {
		constructor(e, t, n) {
			this._content = []
			;(this.role = e), (this.content = t), (this.name = n)
		}
		static User(e, t) {
			return new o(1, e, t)
		}
		static Assistant(e, t) {
			return new o(2, e, t)
		}
		set content(e) {
			typeof e == "string" ? (this._content = [new Pt(e)]) : (this._content = e)
		}
		get content() {
			return this._content
		}
		set content2(e) {
			e && (this.content = e.map((t) => (typeof t == "string" ? new Pt(t) : t)))
		}
		get content2() {
			return this.content.map((e) => (e instanceof Pt ? e.value : e))
		}
	},
	Io = class {
		constructor(e, t, n) {
			;(this.callId = e), (this.name = t), (this.input = n)
		}
	},
	Pt = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 21, value: this.value }
		}
	},
	Id = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 23, value: this.value }
		}
	},
	hD = ((i) => (
		(i.PNG = "image/png"),
		(i.JPEG = "image/jpeg"),
		(i.GIF = "image/gif"),
		(i.WEBP = "image/webp"),
		(i.BMP = "image/bmp"),
		i
	))(hD || {}),
	xo = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 22, value: this.value }
		}
	}
var Nr = class o extends Error {
		static #e = "LanguageModelError"
		static NotFound(e) {
			return new o(e, o.NotFound.name)
		}
		static NoPermissions(e) {
			return new o(e, o.NoPermissions.name)
		}
		static Blocked(e) {
			return new o(e, o.Blocked.name)
		}
		static tryDeserialize(e) {
			if (e.name === o.#e) return new o(e.message, e.code, e.cause)
		}
		constructor(e, t, n) {
			super(e, { cause: n }), (this.name = o.#e), (this.code = t ?? "")
		}
	},
	Qa = class {
		constructor(e) {
			this.content = e
		}
		toJSON() {
			return { $mid: 20, content: this.content }
		}
	},
	rI = class extends Qa {},
	vD = ((t) => ((t[(t.Auto = 1)] = "Auto"), (t[(t.Required = 2)] = "Required"), t))(vD || {}),
	bD = ((r) => (
		(r[(r.SymbolInformation = 1)] = "SymbolInformation"),
		(r[(r.CommandInformation = 2)] = "CommandInformation"),
		(r[(r.SearchInformation = 3)] = "SearchInformation"),
		(r[(r.SettingInformation = 4)] = "SettingInformation"),
		r
	))(bD || {}),
	yD = ((i) => (
		(i[(i.Started = 1)] = "Started"),
		(i[(i.Recognizing = 2)] = "Recognizing"),
		(i[(i.Recognized = 3)] = "Recognized"),
		(i[(i.Stopped = 4)] = "Stopped"),
		(i[(i.Error = 5)] = "Error"),
		i
	))(yD || {}),
	ID = ((n) => ((n[(n.Started = 1)] = "Started"), (n[(n.Stopped = 2)] = "Stopped"), (n[(n.Error = 3)] = "Error"), n))(
		ID || {},
	),
	xD = ((t) => ((t[(t.Recognized = 1)] = "Recognized"), (t[(t.Stopped = 2)] = "Stopped"), t))(xD || {}),
	oI = class {
		constructor(e, t) {
			this.text = e
			this.range = t
		}
	},
	tx = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(tx || {}),
	iI = class {
		constructor(e, t, n, r) {
			this.label = e
			this.command = t
			this.args = n
			this.env = r
		}
	},
	sI = class {
		constructor(e, t) {
			this.label = e
			this.uri = t
			this.headers = []
		}
	}
var Zn
;((t) => {
	function o(n) {
		let { selectionStartLineNumber: r, selectionStartColumn: i, positionLineNumber: s, positionColumn: a } = n,
			l = new Pe(r - 1, i - 1),
			d = new Pe(s - 1, a - 1)
		return new Vn(l, d)
	}
	t.to = o
	function e(n) {
		let { anchor: r, active: i } = n
		return {
			selectionStartLineNumber: r.line + 1,
			selectionStartColumn: r.character + 1,
			positionLineNumber: i.line + 1,
			positionColumn: i.character + 1,
		}
	}
	t.from = e
})((Zn ||= {}))
var H
;((t) => {
	function o(n) {
		if (!n) return
		let { start: r, end: i } = n
		return {
			startLineNumber: r.line + 1,
			startColumn: r.character + 1,
			endLineNumber: i.line + 1,
			endColumn: i.character + 1,
		}
	}
	t.from = o
	function e(n) {
		if (!n) return
		let { startLineNumber: r, startColumn: i, endLineNumber: s, endColumn: a } = n
		return new pe(r - 1, i - 1, s - 1, a - 1)
	}
	t.to = e
})((H ||= {}))
var Ja
;((t) => {
	function o(n) {
		return { uri: n.uri, range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new rn(y.revive(n.uri), H.to(n.range))
	}
	t.to = e
})((Ja ||= {}))
var DD
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 0:
				return 0
			case 3:
				return 3
			case 2:
				return 2
		}
	}
	e.to = o
})((DD ||= {}))
var Je
;((t) => {
	function o(n) {
		return new Pe(n.lineNumber - 1, n.column - 1)
	}
	t.to = o
	function e(n) {
		return { lineNumber: n.line + 1, column: n.character + 1 }
	}
	t.from = e
})((Je ||= {}))
var Fs
;((n) => {
	function o(r, i, s) {
		return Ye(an(r).map((a) => e(a, i, s)))
	}
	n.from = o
	function e(r, i, s) {
		if (typeof r == "string") return { $serialized: !0, language: r, isBuiltin: s?.isBuiltin }
		if (r)
			return {
				$serialized: !0,
				language: r.language,
				scheme: t(r.scheme, i),
				pattern: yr.from(r.pattern) ?? void 0,
				exclusive: r.exclusive,
				notebookType: r.notebookType,
				isBuiltin: s?.isBuiltin,
			}
	}
	function t(r, i) {
		return i && typeof r == "string" ? i.transformOutgoingScheme(r) : r
	}
})((Fs ||= {}))
var CD
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
				return 2
			default:
				return
		}
	}
	t.to = e
})((CD ||= {}))
var _d
;((t) => {
	function o(n) {
		let r
		return (
			n.code &&
				(Ee(n.code) || fn(n.code)
					? (r = String(n.code))
					: (r = { value: String(n.code.value), target: n.code.target })),
			{
				...H.from(n.range),
				message: n.message,
				source: n.source,
				code: r,
				severity: nx.from(n.severity),
				relatedInformation: n.relatedInformation && n.relatedInformation.map(SD.from),
				tags: Array.isArray(n.tags) ? Ye(n.tags.map(CD.from)) : void 0,
			}
		)
	}
	t.from = o
	function e(n) {
		let r = new Sa(H.to(n), n.message, nx.to(n.severity))
		return (
			(r.source = n.source),
			(r.code = Ee(n.code) ? n.code : n.code?.value),
			(r.relatedInformation = n.relatedInformation && n.relatedInformation.map(SD.to)),
			(r.tags = n.tags && Ye(n.tags.map(CD.to))),
			r
		)
	}
	t.to = e
})((_d ||= {}))
var SD
;((t) => {
	function o(n) {
		return { ...H.from(n.location.range), message: n.message, resource: n.location.uri }
	}
	t.from = o
	function e(n) {
		return new hs(new rn(n.resource, H.to(n)), n.message)
	}
	t.to = e
})((SD ||= {}))
var nx
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 8
			case 1:
				return 4
			case 2:
				return 2
			case 3:
				return 1
		}
		return 8
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 2:
				return 2
			case 4:
				return 1
			case 8:
				return 0
			case 1:
				return 3
			default:
				return 0
		}
	}
	t.to = e
})((nx ||= {}))
var wt
;((t) => {
	function o(n) {
		return typeof n == "number" && n >= 1 ? n - 1 : n === -2 ? lF : aF
	}
	t.from = o
	function e(n) {
		if (typeof n == "number" && n >= 0) return n + 1
		throw new Error("invalid 'EditorGroupColumn'")
	}
	t.to = e
})((wt ||= {}))
function _7(o) {
	return typeof o.range < "u"
}
function kD(o) {
	return o.length === 0 ? !0 : !!_7(o[0])
}
var Ce
;((s) => {
	function o(a) {
		return a.map(s.from)
	}
	s.fromMany = o
	function e(a) {
		return a && typeof a == "object" && typeof a.language == "string" && typeof a.value == "string"
	}
	function t(a) {
		let l
		if (e(a)) {
			let { language: u, value: m } = a
			l = {
				value:
					"```" +
					u +
					`
` +
					m +
					"\n```\n",
			}
		} else
			en.isMarkdownString(a)
				? (l = {
						value: a.value,
						isTrusted: a.isTrusted,
						supportThemeIcons: a.supportThemeIcons,
						supportHtml: a.supportHtml,
						baseUri: a.baseUri,
					})
				: typeof a == "string"
					? (l = { value: a })
					: (l = { value: "" })
		let d = Object.create(null)
		l.uris = d
		let c = ({ href: u }) => {
			try {
				let m = y.parse(u, !0)
				;(m = m.with({ query: n(m.query, d) })), (d[u] = m)
			} catch {}
			return ""
		}
		return (
			Tt.walkTokens(Tt.lexer(l.value), (u) => {
				u.type === "link"
					? c({ href: u.href })
					: u.type === "image" && typeof u.href == "string" && c(yL(u.href))
			}),
			l
		)
	}
	s.from = t
	function n(a, l) {
		if (!a) return a
		let d
		try {
			d = Kv(a)
		} catch {}
		if (!d) return a
		let c = !1
		return (
			(d = ns(d, (u) => {
				if (y.isUri(u)) {
					let m = `__uri_${Math.random().toString(16).slice(2, 8)}`
					return (l[m] = u), (c = !0), m
				} else return
			})),
			c ? JSON.stringify(d) : a
		)
	}
	function r(a) {
		let l = new en(a.value, a.supportThemeIcons)
		return (
			(l.isTrusted = a.isTrusted),
			(l.supportHtml = a.supportHtml),
			(l.baseUri = a.baseUri ? y.from(a.baseUri) : void 0),
			l
		)
	}
	s.to = r
	function i(a) {
		if (a) return typeof a == "string" ? a : s.from(a)
	}
	s.fromStrict = i
})((Ce ||= {}))
function IF(o) {
	return kD(o)
		? o.map((e) => ({
				range: H.from(e.range),
				hoverMessage: Array.isArray(e.hoverMessage)
					? Ce.fromMany(e.hoverMessage)
					: e.hoverMessage
						? Ce.from(e.hoverMessage)
						: void 0,
				renderOptions: e.renderOptions,
			}))
		: o.map((e) => ({ range: H.from(e) }))
}
function vg(o) {
	return typeof o > "u" ? o : typeof o == "string" ? y.file(o) : o
}
var cg
;((e) => {
	function o(t) {
		return typeof t > "u"
			? t
			: {
					contentText: t.contentText,
					contentIconPath: t.contentIconPath ? vg(t.contentIconPath) : void 0,
					border: t.border,
					borderColor: t.borderColor,
					fontStyle: t.fontStyle,
					fontWeight: t.fontWeight,
					textDecoration: t.textDecoration,
					color: t.color,
					backgroundColor: t.backgroundColor,
					margin: t.margin,
					width: t.width,
					height: t.height,
				}
	}
	e.from = o
})((cg ||= {}))
var TD
;((e) => {
	function o(t) {
		return typeof t > "u"
			? t
			: {
					backgroundColor: t.backgroundColor,
					outline: t.outline,
					outlineColor: t.outlineColor,
					outlineStyle: t.outlineStyle,
					outlineWidth: t.outlineWidth,
					border: t.border,
					borderColor: t.borderColor,
					borderRadius: t.borderRadius,
					borderSpacing: t.borderSpacing,
					borderStyle: t.borderStyle,
					borderWidth: t.borderWidth,
					fontStyle: t.fontStyle,
					fontWeight: t.fontWeight,
					textDecoration: t.textDecoration,
					cursor: t.cursor,
					color: t.color,
					opacity: t.opacity,
					letterSpacing: t.letterSpacing,
					gutterIconPath: t.gutterIconPath ? vg(t.gutterIconPath) : void 0,
					gutterIconSize: t.gutterIconSize,
					overviewRulerColor: t.overviewRulerColor,
					before: t.before ? cg.from(t.before) : void 0,
					after: t.after ? cg.from(t.after) : void 0,
				}
	}
	e.from = o
})((TD ||= {}))
var xF
;((e) => {
	function o(t) {
		if (typeof t > "u") return t
		switch (t) {
			case 0:
				return 0
			case 1:
				return 1
			case 2:
				return 2
			case 3:
				return 3
		}
	}
	e.from = o
})((xF ||= {}))
var RD
;((e) => {
	function o(t) {
		return {
			isWholeLine: t.isWholeLine,
			rangeBehavior: t.rangeBehavior ? xF.from(t.rangeBehavior) : void 0,
			overviewRulerLane: t.overviewRulerLane,
			light: t.light ? TD.from(t.light) : void 0,
			dark: t.dark ? TD.from(t.dark) : void 0,
			backgroundColor: t.backgroundColor,
			outline: t.outline,
			outlineColor: t.outlineColor,
			outlineStyle: t.outlineStyle,
			outlineWidth: t.outlineWidth,
			border: t.border,
			borderColor: t.borderColor,
			borderRadius: t.borderRadius,
			borderSpacing: t.borderSpacing,
			borderStyle: t.borderStyle,
			borderWidth: t.borderWidth,
			fontStyle: t.fontStyle,
			fontWeight: t.fontWeight,
			textDecoration: t.textDecoration,
			cursor: t.cursor,
			color: t.color,
			opacity: t.opacity,
			letterSpacing: t.letterSpacing,
			gutterIconPath: t.gutterIconPath ? vg(t.gutterIconPath) : void 0,
			gutterIconSize: t.gutterIconSize,
			overviewRulerColor: t.overviewRulerColor,
			before: t.before ? cg.from(t.before) : void 0,
			after: t.after ? cg.from(t.after) : void 0,
		}
	}
	e.from = o
})((RD ||= {}))
var on
;((t) => {
	function o(n) {
		return { text: n.newText, eol: n.newEol && Ed.from(n.newEol), range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		let r = new Ln(H.to(n.range), n.text)
		return (r.newEol = typeof n.eol > "u" ? void 0 : Ed.to(n.eol)), r
	}
	t.to = e
})((on ||= {}))
var $n
;((t) => {
	function o(n, r) {
		let i = { edits: [] }
		if (n instanceof Jr) {
			let s = new dc()
			for (let a of n._allEntries()) a._type === 1 && y.isUri(a.to) && a.from === void 0 && s.add(a.to)
			for (let a of n._allEntries())
				if (a._type === 1) {
					let l
					a.options?.contents &&
						(ArrayBuffer.isView(a.options.contents)
							? (l = { type: "base64", value: Ol(z.wrap(a.options.contents)) })
							: (l = { type: "dataTransferItem", id: a.options.contents._itemId })),
						i.edits.push({
							oldResource: a.from,
							newResource: a.to,
							options: { ...a.options, contents: l },
							metadata: a.metadata,
						})
				} else
					a._type === 2
						? i.edits.push({
								resource: a.uri,
								textEdit: on.from(a.edit),
								versionId: s.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
								metadata: a.metadata,
							})
						: a._type === 6
							? i.edits.push({
									resource: a.uri,
									textEdit: {
										range: H.from(a.range),
										text: a.edit.value,
										insertAsSnippet: !0,
										keepWhitespace: a.keepWhitespace,
									},
									versionId: s.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
									metadata: a.metadata,
								})
							: a._type === 3
								? i.edits.push({
										metadata: a.metadata,
										resource: a.uri,
										cellEdit: a.edit,
										notebookVersionId: r?.getNotebookDocumentVersion(a.uri),
									})
								: a._type === 5 &&
									i.edits.push({
										metadata: a.metadata,
										resource: a.uri,
										notebookVersionId: r?.getNotebookDocumentVersion(a.uri),
										cellEdit: {
											editType: 1,
											index: a.index,
											count: a.count,
											cells: a.cells.map(pg.from),
										},
									})
		}
		return i
	}
	t.from = o
	function e(n) {
		let r = new Jr(),
			i = new ft()
		for (let s of n.edits)
			if (s.textEdit) {
				let a = s,
					l = y.revive(a.resource),
					d = H.to(a.textEdit.range),
					c = a.textEdit.text,
					u = a.textEdit.insertAsSnippet,
					m
				u ? (m = gd.replace(d, new Wn(c))) : (m = Ln.replace(d, c))
				let f = i.get(l)
				f ? f.push(m) : i.set(l, [m])
			} else r.renameFile(y.revive(s.oldResource), y.revive(s.newResource), s.options)
		for (let [s, a] of i) r.set(s, a)
		return r
	}
	t.to = e
})(($n ||= {}))
var Yr
;((n) => {
	let o = Object.create(null)
	;(o[0] = 0),
		(o[1] = 1),
		(o[2] = 2),
		(o[3] = 3),
		(o[4] = 4),
		(o[5] = 5),
		(o[6] = 6),
		(o[7] = 7),
		(o[8] = 8),
		(o[9] = 9),
		(o[10] = 10),
		(o[11] = 11),
		(o[12] = 12),
		(o[13] = 13),
		(o[14] = 14),
		(o[15] = 15),
		(o[16] = 16),
		(o[17] = 17),
		(o[18] = 18),
		(o[19] = 19),
		(o[20] = 20),
		(o[21] = 21),
		(o[22] = 22),
		(o[23] = 23),
		(o[24] = 24),
		(o[25] = 25)
	function e(r) {
		return typeof o[r] == "number" ? o[r] : 6
	}
	n.from = e
	function t(r) {
		for (let i in o) if (o[i] === r) return Number(i)
		return 6
	}
	n.to = t
})((Yr ||= {}))
var Ls
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.to = e
})((Ls ||= {}))
var Xa
;((t) => {
	function o(n) {
		return {
			name: n.name,
			kind: Yr.from(n.kind),
			tags: n.tags && n.tags.map(Ls.from),
			containerName: n.containerName,
			location: Bn.from(n.location),
		}
	}
	t.from = o
	function e(n) {
		let r = new ho(n.name, Yr.to(n.kind), n.containerName, Bn.to(n.location))
		return (r.tags = n.tags && n.tags.map(Ls.to)), r
	}
	t.to = e
})((Xa ||= {}))
var AD
;((t) => {
	function o(n) {
		let r = {
			name: n.name || "!!MISSING: name!!",
			detail: n.detail,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			kind: Yr.from(n.kind),
			tags: n.tags?.map(Ls.from) ?? [],
		}
		return n.children && (r.children = n.children.map(o)), r
	}
	t.from = o
	function e(n) {
		let r = new Xr(n.name, n.detail, Yr.to(n.kind), H.to(n.range), H.to(n.selectionRange))
		return ri(n.tags) && (r.tags = n.tags.map(Ls.to)), n.children && (r.children = n.children.map(e)), r
	}
	t.to = e
})((AD ||= {}))
var Ns
;((t) => {
	function o(n) {
		let r = new Wa(Yr.to(n.kind), n.name, n.detail || "", y.revive(n.uri), H.to(n.range), H.to(n.selectionRange))
		return (r._sessionId = n._sessionId), (r._itemId = n._itemId), r
	}
	t.to = o
	function e(n, r, i) {
		if (((r = r ?? n._sessionId), (i = i ?? n._itemId), r === void 0 || i === void 0))
			throw new Error("invalid item")
		return {
			_sessionId: r,
			_itemId: i,
			name: n.name,
			detail: n.detail,
			kind: Yr.from(n.kind),
			uri: n.uri,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			tags: n.tags?.map(Ls.from),
		}
	}
	t.from = e
})((Ns ||= {}))
var OD
;((e) => {
	function o(t) {
		return new yu(
			Ns.to(t.from),
			t.fromRanges.map((n) => H.to(n)),
		)
	}
	e.to = o
})((OD ||= {}))
var LD
;((e) => {
	function o(t) {
		return new Iu(
			Ns.to(t.to),
			t.fromRanges.map((n) => H.to(n)),
		)
	}
	e.to = o
})((LD ||= {}))
var Bn
;((t) => {
	function o(n) {
		return { range: n.range && H.from(n.range), uri: n.uri }
	}
	t.from = o
	function e(n) {
		return new rn(y.revive(n.uri), H.to(n.range))
	}
	t.to = e
})((Bn ||= {}))
var Qu
;((t) => {
	function o(n) {
		let r = n,
			i = n
		return {
			originSelectionRange: r.originSelectionRange ? H.from(r.originSelectionRange) : void 0,
			uri: r.targetUri ? r.targetUri : i.uri,
			range: H.from(r.targetRange ? r.targetRange : i.range),
			targetSelectionRange: r.targetSelectionRange ? H.from(r.targetSelectionRange) : void 0,
		}
	}
	t.from = o
	function e(n) {
		return {
			targetUri: y.revive(n.uri),
			targetRange: H.to(n.range),
			targetSelectionRange: n.targetSelectionRange ? H.to(n.targetSelectionRange) : void 0,
			originSelectionRange: n.originSelectionRange ? H.to(n.originSelectionRange) : void 0,
		}
	}
	t.to = e
})((Qu ||= {}))
var Ju
;((t) => {
	function o(n) {
		return {
			range: H.from(n.range),
			contents: Ce.fromMany(n.contents),
			canIncreaseVerbosity: n.canIncreaseVerbosity,
			canDecreaseVerbosity: n.canDecreaseVerbosity,
		}
	}
	t.from = o
	function e(n) {
		let r = n.contents.map(Ce.to),
			i = H.to(n.range),
			s = n.canIncreaseVerbosity,
			a = n.canDecreaseVerbosity
		return new Ta(r, i, s, a)
	}
	t.to = e
})((Ju ||= {}))
var MD
;((t) => {
	function o(n) {
		return { range: H.from(n.range), expression: n.expression }
	}
	t.from = o
	function e(n) {
		return new La(H.to(n.range), n.expression)
	}
	t.to = e
})((MD ||= {}))
var bg
;((t) => {
	function o(n) {
		if (n instanceof Ma) return { type: "text", range: H.from(n.range), text: n.text }
		if (n instanceof Fa)
			return {
				type: "variable",
				range: H.from(n.range),
				variableName: n.variableName,
				caseSensitiveLookup: n.caseSensitiveLookup,
			}
		if (n instanceof Na) return { type: "expression", range: H.from(n.range), expression: n.expression }
		throw new Error("Unknown 'InlineValue' type")
	}
	t.from = o
	function e(n) {
		switch (n.type) {
			case "text":
				return { range: H.to(n.range), text: n.text }
			case "variable":
				return {
					range: H.to(n.range),
					variableName: n.variableName,
					caseSensitiveLookup: n.caseSensitiveLookup,
				}
			case "expression":
				return { range: H.to(n.range), expression: n.expression }
		}
	}
	t.to = e
})((bg ||= {}))
var yg
;((t) => {
	function o(n) {
		return { frameId: n.frameId, stoppedLocation: H.from(n.stoppedLocation) }
	}
	t.from = o
	function e(n) {
		return new hu(n.frameId, H.to(n.stoppedLocation))
	}
	t.to = e
})((yg ||= {}))
var Td
;((t) => {
	function o(n) {
		return { range: H.from(n.range), kind: n.kind }
	}
	t.from = o
	function e(n) {
		return new Ea(H.to(n.range), n.kind)
	}
	t.to = e
})((Td ||= {}))
var FD
;((t) => {
	function o(n) {
		return { uri: n.uri, highlights: n.highlights.map(Td.from) }
	}
	t.from = o
	function e(n) {
		return new wa(y.revive(n.uri), n.highlights.map(Td.to))
	}
	t.to = e
})((FD ||= {}))
var CF
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 2:
				return 2
			case 0:
			default:
				return 0
		}
	}
	e.to = o
})((CF ||= {}))
var ND
;((e) => {
	function o(t) {
		return { triggerKind: CF.to(t.triggerKind), triggerCharacter: t.triggerCharacter }
	}
	e.to = o
})((ND ||= {}))
var rx
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.to = e
})((rx ||= {}))
var ox
;((r) => {
	let o = new Map([
		[1, 0],
		[2, 1],
		[3, 2],
		[4, 3],
		[5, 4],
		[6, 5],
		[7, 7],
		[21, 6],
		[8, 8],
		[9, 9],
		[10, 12],
		[11, 13],
		[20, 14],
		[12, 15],
		[19, 16],
		[13, 17],
		[14, 27],
		[0, 18],
		[15, 19],
		[16, 20],
		[17, 21],
		[18, 23],
		[22, 10],
		[23, 11],
		[24, 24],
		[26, 26],
		[25, 25],
	])
	function e(i) {
		return o.get(i) ?? 9
	}
	r.from = e
	let t = new Map([
		[0, 1],
		[1, 2],
		[2, 3],
		[3, 4],
		[4, 5],
		[5, 6],
		[7, 7],
		[6, 21],
		[8, 8],
		[9, 9],
		[12, 10],
		[13, 11],
		[14, 20],
		[15, 12],
		[16, 19],
		[17, 13],
		[27, 14],
		[18, 0],
		[19, 15],
		[20, 16],
		[21, 17],
		[23, 18],
		[10, 22],
		[11, 23],
		[24, 24],
		[25, 25],
		[26, 26],
	])
	function n(i) {
		return t.get(i) ?? 9
	}
	r.to = n
})((ox ||= {}))
var UD
;((e) => {
	function o(t, n) {
		let r = new ka(t.label)
		return (
			(r.insertText = t.insertText),
			(r.kind = ox.to(t.kind)),
			(r.tags = t.tags?.map(rx.to)),
			(r.detail = t.detail),
			(r.documentation = Kr(t.documentation) ? Ce.to(t.documentation) : t.documentation),
			(r.sortText = t.sortText),
			(r.filterText = t.filterText),
			(r.preselect = t.preselect),
			(r.commitCharacters = t.commitCharacters),
			Re.isIRange(t.range)
				? (r.range = H.to(t.range))
				: typeof t.range == "object" &&
					(r.range = { inserting: H.to(t.range.insert), replacing: H.to(t.range.replace) }),
			(r.keepWhitespace = typeof t.insertTextRules > "u" ? !1 : !!(t.insertTextRules & 1)),
			typeof t.insertTextRules < "u" && t.insertTextRules & 4
				? (r.insertText = new Wn(t.insertText))
				: ((r.insertText = t.insertText),
					(r.textEdit = r.range instanceof pe ? new Ln(r.range, r.insertText) : void 0)),
			t.additionalTextEdits &&
				t.additionalTextEdits.length > 0 &&
				(r.additionalTextEdits = t.additionalTextEdits.map((i) => on.to(i))),
			(r.command = n && t.command ? n.fromInternal(t.command) : void 0),
			r
		)
	}
	e.to = o
})((UD ||= {}))
var ED
;((t) => {
	function o(n) {
		if (typeof n.label != "string" && !Array.isArray(n.label)) throw new TypeError("Invalid label")
		return { label: n.label, documentation: Ce.fromStrict(n.documentation) }
	}
	t.from = o
	function e(n) {
		return { label: n.label, documentation: Kr(n.documentation) ? Ce.to(n.documentation) : n.documentation }
	}
	t.to = e
})((ED ||= {}))
var wD
;((t) => {
	function o(n) {
		return {
			label: n.label,
			documentation: Ce.fromStrict(n.documentation),
			parameters: Array.isArray(n.parameters) ? n.parameters.map(ED.from) : [],
			activeParameter: n.activeParameter,
		}
	}
	t.from = o
	function e(n) {
		return {
			label: n.label,
			documentation: Kr(n.documentation) ? Ce.to(n.documentation) : n.documentation,
			parameters: Array.isArray(n.parameters) ? n.parameters.map(ED.to) : [],
			activeParameter: n.activeParameter,
		}
	}
	t.to = e
})((wD ||= {}))
var Xu
;((t) => {
	function o(n) {
		return {
			activeSignature: n.activeSignature,
			activeParameter: n.activeParameter,
			signatures: Array.isArray(n.signatures) ? n.signatures.map(wD.from) : [],
		}
	}
	t.from = o
	function e(n) {
		return {
			activeSignature: n.activeSignature,
			activeParameter: n.activeParameter,
			signatures: Array.isArray(n.signatures) ? n.signatures.map(wD.to) : [],
		}
	}
	t.to = e
})((Xu ||= {}))
var HD
;((e) => {
	function o(t, n) {
		let r = new Da(
			Je.to(n.position),
			typeof n.label == "string" ? n.label : n.label.map(SF.to.bind(void 0, t)),
			n.kind && ix.to(n.kind),
		)
		return (
			(r.textEdits = n.textEdits && n.textEdits.map(on.to)),
			(r.tooltip = Kr(n.tooltip) ? Ce.to(n.tooltip) : n.tooltip),
			(r.paddingLeft = n.paddingLeft),
			(r.paddingRight = n.paddingRight),
			r
		)
	}
	e.to = o
})((HD ||= {}))
var SF
;((e) => {
	function o(t, n) {
		let r = new _a(n.label)
		return (
			(r.tooltip = Kr(n.tooltip) ? Ce.to(n.tooltip) : n.tooltip),
			DP.is(n.command) && (r.command = t.fromInternal(n.command)),
			n.location && (r.location = Bn.to(n.location)),
			r
		)
	}
	e.to = o
})((SF ||= {}))
var ix
;((t) => {
	function o(n) {
		return n
	}
	t.from = o
	function e(n) {
		return n
	}
	t.to = e
})((ix ||= {}))
var Us
;((t) => {
	function o(n) {
		return { range: H.from(n.range), url: n.target, tooltip: n.tooltip }
	}
	t.from = o
	function e(n) {
		let r
		if (n.url)
			try {
				r = typeof n.url == "string" ? y.parse(n.url, !0) : y.revive(n.url)
			} catch {}
		let i = new Ra(H.to(n.range), r)
		return (i.tooltip = n.tooltip), i
	}
	t.to = e
})((Us ||= {}))
var Ig
;((t) => {
	function o(n) {
		let r = new Oa(n.label)
		return (
			n.textEdit && (r.textEdit = on.to(n.textEdit)),
			n.additionalTextEdits && (r.additionalTextEdits = n.additionalTextEdits.map((i) => on.to(i))),
			r
		)
	}
	t.to = o
	function e(n) {
		return {
			label: n.label,
			textEdit: n.textEdit ? on.from(n.textEdit) : void 0,
			additionalTextEdits: n.additionalTextEdits ? n.additionalTextEdits.map((r) => on.from(r)) : void 0,
		}
	}
	t.from = e
})((Ig ||= {}))
var Dd
;((t) => {
	function o(n) {
		return new $o(n[0], n[1], n[2], n[3])
	}
	t.to = o
	function e(n) {
		return [n.red, n.green, n.blue, n.alpha]
	}
	t.from = e
})((Dd ||= {}))
var WD
;((t) => {
	function o(n) {
		return { range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new Ii(H.to(n.range))
	}
	t.to = e
})((WD ||= {}))
var xg
;((e) => {
	function o(t) {
		switch (t) {
			case 2:
				return 2
			case 1:
				return 1
			case 3:
			case 4:
				return 3
		}
	}
	e.to = o
})((xg ||= {}))
var kd
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 0
			case 2:
				return 2
			case 3:
				return 3
			case 1:
			default:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 0:
				return 0
			case 2:
				return 2
			case 3:
				return 3
			case 1:
			default:
				return 1
		}
	}
	t.to = e
})((kd ||= {}))
var Ed
;((t) => {
	function o(n) {
		if (n === 2) return 1
		if (n === 1) return 0
	}
	t.from = o
	function e(n) {
		if (n === 1) return 2
		if (n === 0) return 1
	}
	t.to = e
})((Ed ||= {}))
var VD
;((e) => {
	function o(t) {
		if (typeof t == "object") return t.viewId
		switch (t) {
			case 1:
				return 3
			case 10:
				return 10
			case 15:
				return 15
		}
		throw new Error("Unknown 'ProgressLocation'")
	}
	e.from = o
})((VD ||= {}))
var Cg
;((t) => {
	function o(n) {
		let r = { start: n.start + 1, end: n.end + 1 }
		return n.kind && (r.kind = PD.from(n.kind)), r
	}
	t.from = o
	function e(n) {
		let r = { start: n.start - 1, end: n.end - 1 }
		return n.kind && (r.kind = PD.to(n.kind)), r
	}
	t.to = e
})((Cg ||= {}))
var PD
;((t) => {
	function o(n) {
		if (n)
			switch (n) {
				case 1:
					return cs.Comment
				case 2:
					return cs.Imports
				case 3:
					return cs.Region
			}
	}
	t.from = o
	function e(n) {
		if (n)
			switch (n.value) {
				case cs.Comment.value:
					return 1
				case cs.Imports.value:
					return 2
				case cs.Region.value:
					return 3
			}
	}
	t.to = e
})((PD ||= {}))
var Sg
;((e) => {
	function o(t) {
		if (t)
			return {
				pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
				inactive: t.background,
				preserveFocus: t.preserveFocus,
				selection: typeof t.selection == "object" ? H.from(t.selection) : void 0,
				override: typeof t.override == "boolean" ? UP.id : void 0,
			}
	}
	e.from = o
})((Sg ||= {}))
var yr
;((r) => {
	function o(i) {
		return i instanceof Si
			? i.toJSON()
			: typeof i == "string"
				? i
				: e(i) || t(i)
					? new Si(i.baseUri ?? i.base, i.pattern).toJSON()
					: i
	}
	r.from = o
	function e(i) {
		let s = i
		return s ? y.isUri(s.baseUri) && typeof s.pattern == "string" : !1
	}
	function t(i) {
		let s = i
		return s ? typeof s.base == "string" && typeof s.pattern == "string" : !1
	}
	function n(i) {
		return typeof i == "string" ? i : new Si(y.revive(i.baseUri), i.pattern)
	}
	r.to = n
})((yr ||= {}))
var BD
;((e) => {
	function o(t) {
		if (t) {
			if (Array.isArray(t)) return t.map(o)
			if (typeof t == "string") return t
			{
				let n = t
				return {
					language: n.language,
					scheme: n.scheme,
					pattern: yr.from(n.pattern) ?? void 0,
					exclusive: n.exclusive,
					notebookType: n.notebookType,
				}
			}
		} else return
	}
	e.from = o
})((BD ||= {}))
var Zr
;((t) => {
	function o(n) {
		return { start: n.start, end: n.end }
	}
	t.from = o
	function e(n) {
		return new dr(n.start, n.end)
	}
	t.to = e
})((Zr ||= {}))
var ju
;((t) => {
	function o(n) {
		return {
			timing:
				typeof n.runStartTime == "number" && typeof n.runEndTime == "number"
					? { startTime: n.runStartTime, endTime: n.runEndTime }
					: void 0,
			executionOrder: n.executionOrder,
			success: n.lastRunSuccess,
		}
	}
	t.to = o
	function e(n) {
		return {
			lastRunSuccess: n.success,
			runStartTime: n.timing?.startTime,
			runEndTime: n.timing?.endTime,
			executionOrder: n.executionOrder,
		}
	}
	t.from = e
})((ju ||= {}))
var $D
;((e) => {
	function o(t) {
		if (t === 1) return 2
		if (t === 2) return
		if (t === 3) return 3
		throw new Error(`Unknown state: ${t}`)
	}
	e.to = o
})(($D ||= {}))
var ug
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
			default:
				return 2
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
			default:
				return 2
		}
	}
	t.to = e
})((ug ||= {}))
var Ya
;((t) => {
	function o(n) {
		let r = { metadata: n.metadata ?? Object.create(null), cells: [] }
		for (let i of n.cells) xs.validate(i), r.cells.push(pg.from(i))
		return r
	}
	t.from = o
	function e(n) {
		let r = new Tu(n.cells.map(pg.to))
		return Yh(n.metadata) || (r.metadata = n.metadata), r
	}
	t.to = e
})((Ya ||= {}))
var pg
;((t) => {
	function o(n) {
		return {
			cellKind: ug.from(n.kind),
			language: n.languageId,
			mime: n.mime,
			source: n.value,
			metadata: n.metadata,
			internalMetadata: ju.from(n.executionSummary ?? {}),
			outputs: n.outputs ? n.outputs.map(Ms.from) : [],
		}
	}
	t.from = o
	function e(n) {
		return new xs(
			ug.to(n.cellKind),
			n.source,
			n.language,
			n.mime,
			n.outputs ? n.outputs.map(Ms.to) : void 0,
			n.metadata,
			n.internalMetadata ? ju.to(n.internalMetadata) : void 0,
		)
	}
	t.to = e
})((pg ||= {}))
var wd
;((t) => {
	function o(n) {
		return { mime: n.mime, valueBytes: z.wrap(n.data) }
	}
	t.from = o
	function e(n) {
		return new Eu(n.valueBytes.buffer, n.mime)
	}
	t.to = e
})((wd ||= {}))
var Ms
;((t) => {
	function o(n) {
		return { outputId: n.id, items: n.items.map(wd.from), metadata: n.metadata }
	}
	t.from = o
	function e(n) {
		let r = n.items.map(wd.to)
		return new Cs(r, n.outputId, n.metadata)
	}
	t.to = e
})((Ms ||= {}))
var Tg
;((n) => {
	function o(r) {
		return t(r)
			? { include: yr.from(r.include) ?? void 0, exclude: yr.from(r.exclude) ?? void 0 }
			: (yr.from(r) ?? void 0)
	}
	n.from = o
	function e(r) {
		return t(r) ? { include: yr.to(r.include), exclude: yr.to(r.exclude) } : yr.to(r)
	}
	n.to = e
	function t(r) {
		let i = r
		return i ? !bt(i.include) && !bt(i.exclude) : !1
	}
})((Tg ||= {}))
var zD
;((e) => {
	function o(t, n, r) {
		let i = typeof t.command == "string" ? { title: "", command: t.command } : t.command
		return {
			alignment: t.alignment === 1 ? 1 : 2,
			command: n.toInternal(i, r),
			text: t.text,
			tooltip: t.tooltip,
			accessibilityInformation: t.accessibilityInformation,
			priority: t.priority,
		}
	}
	e.from = o
})((zD ||= {}))
var qD
;((e) => {
	function o(t, n, r) {
		let i = typeof t.command == "string" ? { title: "", command: t.command } : t.command
		return {
			command: n.toInternal(i, r),
			label: t.label,
			description: t.description,
			detail: t.detail,
			documentation: t.documentation,
		}
	}
	e.from = o
})((qD ||= {}))
var KD
;((e) => {
	function o(t) {
		return {
			transientOutputs: t?.transientOutputs ?? !1,
			transientCellMetadata: t?.transientCellMetadata ?? {},
			transientDocumentMetadata: t?.transientDocumentMetadata ?? {},
			cellContentMetadata: t?.cellContentMetadata ?? {},
		}
	}
	e.from = o
})((KD ||= {}))
var sx
;((t) => {
	function o(n) {
		return { uri: n.uri, provides: n.provides }
	}
	t.from = o
	function e(n) {
		return new wu(y.revive(n.uri), n.provides)
	}
	t.to = e
})((sx ||= {}))
var Yu
;((t) => {
	function o(n) {
		return {
			message: Ce.fromStrict(n.message) || "",
			type: 0,
			expected: n.expectedOutput,
			actual: n.actualOutput,
			contextValue: n.contextValue,
			location: n.location && { range: H.from(n.location.range), uri: n.location.uri },
			stackTrace: n.stackTrace?.map((r) => ({
				label: r.label,
				position: r.position && Je.from(r.position),
				uri: r.uri && y.revive(r.uri).toJSON(),
			})),
		}
	}
	t.from = o
	function e(n) {
		let r = new Ei(typeof n.message == "string" ? n.message : Ce.to(n.message))
		return (
			(r.actualOutput = n.actual),
			(r.expectedOutput = n.expected),
			(r.contextValue = n.contextValue),
			(r.location = n.location ? Bn.to(n.location) : void 0),
			r
		)
	}
	t.to = e
})((Yu ||= {}))
var Co
;((t) => ((t.namespace = su), (t.denamespace = ky)))((Co ||= {}))
var jD
;((e) => {
	function o(t) {
		return { controllerId: t.controllerId, profileId: t.profileId, group: Zu.from(t.kind) }
	}
	e.from = o
})((jD ||= {}))
var Zu
;((t) => {
	let o = { 3: 8, 2: 4, 1: 2 }
	function e(n) {
		return o.hasOwnProperty(n) ? o[n] : 2
	}
	t.from = e
})((Zu ||= {}))
var Ri
;((t) => {
	function o(n) {
		let r = au(n).controllerId
		return {
			extId: ze.fromExtHostTestItem(n, r).toString(),
			label: n.label,
			uri: y.revive(n.uri),
			busy: n.busy,
			tags: n.tags.map((i) => Co.namespace(r, i.id)),
			range: Re.lift(H.from(n.range)),
			description: n.description || null,
			sortText: n.sortText || null,
			error: (n.error && Ce.fromStrict(n.error)) || null,
		}
	}
	t.from = o
	function e(n) {
		return {
			parent: void 0,
			error: void 0,
			id: ze.fromString(n.extId).localId,
			label: n.label,
			uri: y.revive(n.uri),
			tags: (n.tags || []).map((r) => {
				let { tagId: i } = Co.denamespace(r)
				return new Is(i)
			}),
			children: {
				add: () => {},
				delete: () => {},
				forEach: () => {},
				*[Symbol.iterator]() {},
				get: () => {},
				replace: () => {},
				size: 0,
			},
			range: H.to(n.range || void 0),
			canResolveChildren: !1,
			busy: n.busy,
			description: n.description || void 0,
			sortText: n.sortText || void 0,
		}
	}
	t.toPlain = e
})((Ri ||= {}))
;((t) => {
	function o(n) {
		return { id: n.id }
	}
	t.from = o
	function e(n) {
		return new Is(n.id)
	}
	t.to = e
})((Co ||= {}))
var GD
;((t) => {
	let o = (n, r) => {
		let i = n.value
		if (!i) return
		let s = {
			...Ri.toPlain(i.item),
			parent: r,
			taskStates: i.tasks.map((a) => ({
				state: a.state,
				duration: a.duration,
				messages: a.messages.filter((l) => l.type === 0).map(Yu.to),
			})),
			children: [],
		}
		if (n.children)
			for (let a of n.children.values()) {
				let l = o(a, s)
				l && s.children.push(l)
			}
		return s
	}
	function e(n) {
		let r = new wb()
		for (let a of n.items) r.insert(ze.fromString(a.item.extId).path, a)
		let i = [r.nodes],
			s = []
		for (; i.length; ) for (let a of i.pop()) a.value ? s.push(a) : a.children && i.push(a.children.values())
		return { completedAt: n.completedAt, results: s.map((a) => o(a)).filter(rr) }
	}
	t.to = e
})((GD ||= {}))
var Eg
;((s) => {
	function o(a) {
		return { covered: a.covered, total: a.total }
	}
	function e(a) {
		return "line" in a ? Je.from(a) : H.from(a)
	}
	function t(a) {
		if (a) return "endLineNumber" in a ? H.to(a) : Je.to(a)
	}
	function n(a) {
		if (a.type === 1) {
			let l = []
			if (a.branches)
				for (let d of a.branches) l.push({ executed: d.count, location: t(d.location), label: d.label })
			return new _u(
				a.count,
				t(a.location),
				a.branches?.map((d) => new Du(d.count, t(d.location), d.label)),
			)
		} else return new ku(a.name, a.count, t(a.location))
	}
	s.to = n
	function r(a) {
		if (typeof a.executed == "number" && a.executed < 0) throw new Error(`Invalid coverage count ${a.executed}`)
		return "branches" in a
			? {
					count: a.executed,
					location: e(a.location),
					type: 1,
					branches: a.branches.length
						? a.branches.map((l) => ({
								count: l.executed,
								location: l.location && e(l.location),
								label: l.label,
							}))
						: void 0,
				}
			: { type: 0, name: a.name, count: a.executed, location: e(a.location) }
	}
	s.fromDetails = r
	function i(a, l, d) {
		return (
			lg(d.statementCoverage),
			lg(d.branchCoverage),
			lg(d.declarationCoverage),
			{
				id: l,
				uri: d.uri,
				statement: o(d.statementCoverage),
				branch: d.branchCoverage && o(d.branchCoverage),
				declaration: d.declarationCoverage && o(d.declarationCoverage),
				testIds:
					d instanceof Ss && d.includesTests.length
						? d.includesTests.map((c) => ze.fromExtHostTestItem(c, a).toString())
						: void 0,
			}
		)
	}
	s.fromFile = i
})((Eg ||= {}))
var QD
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	e.to = o
})((QD ||= {}))
var Hs
;((t) => {
	function o(n) {
		let r = new $a(Yr.to(n.kind), n.name, n.detail || "", y.revive(n.uri), H.to(n.range), H.to(n.selectionRange))
		return (r._sessionId = n._sessionId), (r._itemId = n._itemId), r
	}
	t.to = o
	function e(n, r, i) {
		if (((r = r ?? n._sessionId), (i = i ?? n._itemId), r === void 0 || i === void 0))
			throw new Error("invalid item")
		return {
			_sessionId: r,
			_itemId: i,
			kind: Yr.from(n.kind),
			name: n.name,
			detail: n.detail ?? "",
			uri: n.uri,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			tags: n.tags?.map(Ls.from),
		}
	}
	t.from = e
})((Hs ||= {}))
var wg
;((e) => {
	function o(t) {
		if (t) return { value: t.value, tooltip: t.tooltip }
	}
	e.from = o
})((wg ||= {}))
var Sd
;((r) => {
	function o(i, s, a) {
		let l = s.fileData
		return l
			? new $y(
					new zy(
						l.name,
						y.revive(l.uri),
						l.id,
						zi(() => a(l.id)),
					),
				)
			: i === po.uriList && s.uriListData
				? new Va(n(s.uriListData))
				: new Va(s.asString)
	}
	r.to = o
	async function e(i, s, a = He()) {
		let l = await s.asString()
		if (i === po.uriList) return { id: a, asString: l, fileData: void 0, uriListData: t(l) }
		let d = s.asFile()
		return { id: a, asString: l, fileData: d ? { name: d.name, uri: d.uri, id: d._itemId ?? d.id } : void 0 }
	}
	r.from = e
	function t(i) {
		return Ib.split(i).map((s) => {
			if (s.startsWith("#")) return s
			try {
				return y.parse(s)
			} catch {}
			return s
		})
	}
	function n(i) {
		return Ib.create(i.map((s) => (typeof s == "string" ? s : y.revive(s))))
	}
})((Sd ||= {}))
var Rd
;((n) => {
	function o(r, i) {
		let s = r.items.map(([a, l]) => [a, Sd.to(a, l, i)])
		return new vo(s)
	}
	n.toDataTransfer = o
	async function e(r) {
		return { items: await Promise.all(Array.from(r, async ([s, a]) => [s, await Sd.from(s, a)])) }
	}
	n.from = e
	async function t(r) {
		return { items: await Promise.all(Array.from(r, async ([s, a]) => [s, await Sd.from(s, a, a.id)])) }
	}
	n.fromList = t
})((Rd ||= {}))
var Pg
;((t) => {
	function o(n, r) {
		return {
			kind: "reply",
			agentId: n.participant ?? r?.agentId ?? "",
			subCommand: n.command ?? r?.command,
			message: n.prompt,
			title: n.label,
		}
	}
	t.from = o
	function e(n) {
		return { prompt: n.message, label: n.title, participant: n.agentId, command: n.subCommand }
	}
	t.to = e
})((Pg ||= {}))
var mg
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 3
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	t.to = o
	function e(n) {
		switch (n) {
			case 3:
				return 0
			case 1:
				return 1
			case 2:
				return 2
		}
		return 1
	}
	t.from = e
})((mg ||= {}))
var D7
;((t) => {
	function o(n) {
		let r = n.content
				.map((a) => {
					if (a.type === "text") return new Pt(a.value)
					if (a.type === "tool_result") {
						let l = a.value.map((d) => (d.type === "text" ? new Pt(d.value) : new xo(d.value)))
						return new Os(a.toolCallId, l, a.isError)
					} else return a.type === "image_url" ? void 0 : new Io(a.toolCallId, a.name, a.parameters)
				})
				.filter((a) => a !== void 0),
			i = mg.to(n.role)
		return new $u(i, r, n.name)
	}
	t.to = o
	function e(n) {
		let r = mg.from(n.role),
			i = n.name,
			s = n.content
		typeof s == "string" && (s = [new Pt(s)])
		let a = s.map((l) => {
			if (l instanceof Os)
				return {
					type: "tool_result",
					toolCallId: l.callId,
					value: Ye(
						l.content.map((d) =>
							d instanceof Pt
								? { type: "text", value: d.value }
								: d instanceof xo
									? { type: "prompt_tsx", value: d.value }
									: void 0,
						),
					),
					isError: l.isError,
				}
			if (l instanceof Io) return { type: "tool_use", toolCallId: l.callId, name: l.name, parameters: l.input }
			if (l instanceof Pt) return { type: "text", value: l.value }
			if (typeof l != "string") throw new Error("Unexpected chat message content type")
			return { type: "text", value: l }
		})
		return { role: r, name: i, content: a }
	}
	t.from = e
})((D7 ||= {}))
var _g
;((t) => {
	function o(n) {
		let r = n.content.map((a) => {
				if (a.type === "text") return new Pt(a.value)
				if (a.type === "tool_result") {
					let l = a.value.map((d) => (d.type === "text" ? new Pt(d.value) : new xo(d.value)))
					return new Os(a.toolCallId, l, a.isError)
				} else if (a.type === "image_url") {
					let l = { mimeType: a.value.mimeType, data: a.value.data.buffer }
					return new Id(l)
				} else return new Io(a.toolCallId, a.name, a.parameters)
			}),
			i = mg.to(n.role)
		return new zu(i, r, n.name)
	}
	t.to = o
	function e(n) {
		let r = mg.from(n.role),
			i = n.name,
			s = n.content
		typeof s == "string" && (s = [new Pt(s)])
		let a = s.map((l) => {
			if (l instanceof Os)
				return {
					type: "tool_result",
					toolCallId: l.callId,
					value: Ye(
						l.content.map((d) =>
							d instanceof Pt
								? { type: "text", value: d.value }
								: d instanceof xo
									? { type: "prompt_tsx", value: d.value }
									: void 0,
						),
					),
					isError: l.isError,
				}
			if (l instanceof Id)
				return { type: "image_url", value: { mimeType: l.value.mimeType, data: z.wrap(l.value.data) } }
			if (l instanceof Io) return { type: "tool_use", toolCallId: l.callId, name: l.name, parameters: l.input }
			if (l instanceof Pt) return { type: "text", value: l.value }
			if (typeof l != "string") throw new Error("Unexpected chat message content type")
			return { type: "text", value: l }
		})
		return { role: r, name: i, content: a }
	}
	t.from = e
})((_g ||= {}))
var fg
;((t) => {
	function o(n) {
		return { kind: "markdownContent", content: Ce.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new Es(Ce.to(n.content))
	}
	t.to = e
})((fg ||= {}))
var ax
;((t) => {
	function o(n) {
		return { kind: "codeblockUri", uri: n.value, isEdit: n.isEdit }
	}
	t.from = o
	function e(n) {
		return new Ds(y.revive(n.uri), n.isEdit)
	}
	t.to = e
})((ax ||= {}))
var lx
;((t) => {
	function o(n) {
		return { kind: "markdownVuln", content: Ce.from(n.value), vulnerabilities: n.vulnerabilities }
	}
	t.from = o
	function e(n) {
		return new Pi(Ce.to(n.content), n.vulnerabilities)
	}
	t.to = e
})((lx ||= {}))
var dx
;((e) => {
	function o(t) {
		return { kind: "confirmation", title: t.title, message: t.message, data: t.data, buttons: t.buttons }
	}
	e.from = o
})((dx ||= {}))
var gg
;((t) => {
	function o(n) {
		let { value: r, baseUri: i } = n
		function s(a, l) {
			return a.map((d) => {
				let c = y.joinPath(l, d.name)
				return { label: d.name, uri: c, children: d.children && s(d.children, c) }
			})
		}
		return { kind: "treeData", treeData: { label: Ht(i), uri: i, children: s(r, i) } }
	}
	t.from = o
	function e(n) {
		let r = ut(n.treeData)
		function i(l) {
			return l.map((d) => ({ name: d.label, children: d.children && i(d.children) }))
		}
		let s = r.uri,
			a = r.children ? i(r.children) : []
		return new Ps(a, s)
	}
	t.to = e
})((gg ||= {}))
var Gu
;((t) => {
	function o(n) {
		let r = (s) => y.isUri(s),
			i = (s) => "name" in s
		return {
			kind: "inlineReference",
			name: n.title,
			inlineReference: r(n.value) ? n.value : i(n.value) ? Xa.from(n.value) : Ja.from(n.value),
		}
	}
	t.from = o
	function e(n) {
		let r = ut(n)
		return new _i(
			y.isUri(r.inlineReference)
				? r.inlineReference
				: "location" in r.inlineReference
					? Xa.to(r.inlineReference)
					: Ja.to(r.inlineReference),
			n.name,
		)
	}
	t.to = e
})((Gu ||= {}))
var Dg
;((t) => {
	function o(n) {
		return { kind: "progressMessage", content: Ce.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new yd(n.content.value)
	}
	t.to = e
})((Dg ||= {}))
var kg
;((t) => {
	function o(n) {
		return { kind: "warning", content: Ce.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new Di(n.content.value)
	}
	t.to = e
})((kg ||= {}))
var TF
;((t) => {
	function o(n) {
		return { kind: "move", uri: n.uri, range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new Rs(y.revive(n.uri), H.to(n.range))
	}
	t.to = e
})((TF ||= {}))
var cx
;((e) => {
	function o(t) {
		return { kind: "progressTask", content: Ce.from(t.value) }
	}
	e.from = o
})((cx ||= {}))
var JD
;((e) => {
	function o(t) {
		return { kind: "progressTaskResult", content: typeof t == "string" ? Ce.from(t) : void 0 }
	}
	e.from = o
})((JD ||= {}))
var hg
;((t) => {
	function o(n, r, i) {
		return {
			kind: "command",
			command: r.toInternal(n.value, i) ?? { command: n.value.command, title: n.value.title },
		}
	}
	t.from = o
	function e(n, r) {
		return new _s(r.fromInternal(n.command) ?? { command: n.command.id, title: n.command.title })
	}
	t.to = e
})((hg ||= {}))
var ux
;((t) => {
	function o(n) {
		return { kind: "textEdit", uri: n.uri, edits: n.edits.map((r) => on.from(r)), done: n.isDone }
	}
	t.from = o
	function e(n) {
		let r = new ki(
			y.revive(n.uri),
			n.edits.map((i) => on.to(i)),
		)
		return (r.isDone = n.done), r
	}
	t.to = e
})((ux ||= {}))
var px
;((e) => {
	function o(t) {
		return t.newCellMetadata
			? { editType: 3, index: t.range.start, metadata: t.newCellMetadata }
			: t.newNotebookMetadata
				? { editType: 5, metadata: t.newNotebookMetadata }
				: {
						editType: 1,
						index: t.range.start,
						count: t.range.end - t.range.start,
						cells: t.newCells.map(pg.from),
					}
	}
	e.from = o
})((px ||= {}))
var mx
;((e) => {
	function o(t) {
		return { kind: "notebookEdit", uri: t.uri, edits: t.edits.map(px.from), done: t.isDone }
	}
	e.from = o
})((mx ||= {}))
var Pd
;((t) => {
	function o(n) {
		let r = Yt.isThemeIcon(n.iconPath)
			? n.iconPath
			: y.isUri(n.iconPath)
				? { light: y.revive(n.iconPath) }
				: n.iconPath &&
					  "light" in n.iconPath &&
					  "dark" in n.iconPath &&
					  y.isUri(n.iconPath.light) &&
					  y.isUri(n.iconPath.dark)
					? { light: y.revive(n.iconPath.light), dark: y.revive(n.iconPath.dark) }
					: void 0
		return typeof n.value == "object" && "variableName" in n.value
			? {
					kind: "reference",
					reference: {
						variableName: n.value.variableName,
						value: y.isUri(n.value.value) || !n.value.value ? n.value.value : Ja.from(n.value.value),
					},
					iconPath: r,
					options: n.options,
				}
			: {
					kind: "reference",
					reference: y.isUri(n.value) || typeof n.value == "string" ? n.value : Ja.from(n.value),
					iconPath: r,
					options: n.options,
				}
	}
	t.from = o
	function e(n) {
		let r = ut(n),
			i = (s) => (y.isUri(s) ? s : Ja.to(s))
		return new yo(
			typeof r.reference == "string"
				? r.reference
				: "variableName" in r.reference
					? { variableName: r.reference.variableName, value: r.reference.value && i(r.reference.value) }
					: i(r.reference),
		)
	}
	t.to = e
})((Pd ||= {}))
var fx
;((e) => {
	function o(t) {
		return { kind: "codeCitation", value: t.value, license: t.license, snippet: t.snippet }
	}
	e.from = o
})((fx ||= {}))
var gx
;((n) => {
	function o(r, i, s) {
		return r instanceof Es
			? fg.from(r)
			: r instanceof _i
				? Gu.from(r)
				: r instanceof yo
					? Pd.from(r)
					: r instanceof yd
						? Dg.from(r)
						: r instanceof Ps
							? gg.from(r)
							: r instanceof _s
								? hg.from(r, i, s)
								: r instanceof ki
									? ux.from(r)
									: r instanceof As
										? mx.from(r)
										: r instanceof Pi
											? lx.from(r)
											: r instanceof Ds
												? ax.from(r)
												: r instanceof Di
													? kg.from(r)
													: r instanceof ws
														? dx.from(r)
														: r instanceof ks
															? fx.from(r)
															: r instanceof Rs
																? TF.from(r)
																: { kind: "markdownContent", content: Ce.from("") }
	}
	n.from = o
	function e(r, i) {
		switch (r.kind) {
			case "reference":
				return Pd.to(r)
			case "markdownContent":
			case "inlineReference":
			case "progressMessage":
			case "treeData":
			case "command":
				return t(r, i)
		}
	}
	n.to = e
	function t(r, i) {
		switch (r.kind) {
			case "markdownContent":
				return fg.to(r)
			case "inlineReference":
				return Gu.to(r)
			case "progressMessage":
				return
			case "treeData":
				return gg.to(r)
			case "command":
				return hg.to(r, i)
		}
	}
	n.toContent = t
})((gx ||= {}))
var hx
;((e) => {
	function o(t, n, r, i, s) {
		let a = t.variables.variables.filter((c) => c.isTool),
			l = t.variables.variables.filter((c) => !c.isTool),
			d = {
				prompt: t.message,
				command: t.command,
				attempt: t.attempt ?? 0,
				enableCommandDetection: t.enableCommandDetection ?? !0,
				isParticipantDetected: t.isParticipantDetected ?? !1,
				references: l.map((c) => vx.to(c, i)),
				toolReferences: a.map(bx.to),
				location: Rg.to(t.location),
				acceptedConfirmationData: t.acceptedConfirmationData,
				rejectedConfirmationData: t.rejectedConfirmationData,
				location2: n,
				toolInvocationToken: Object.freeze({ sessionId: t.sessionId }),
				tools: s,
				model: r,
			}
		return t.requestId ? { ...d, id: t.requestId } : d
	}
	e.to = o
})((hx ||= {}))
var XD
;((e) => {
	function o(t) {
		return { prompt: t.prompt, files: t.files.map((n) => y.revive(n)) }
	}
	e.to = o
})((XD ||= {}))
var Rg
;((t) => {
	function o(n) {
		switch (n) {
			case "notebook":
				return 3
			case "terminal":
				return 2
			case "panel":
				return 1
			case "editor":
				return 4
		}
	}
	t.to = o
	function e(n) {
		switch (n) {
			case 3:
				return "notebook"
			case 2:
				return "terminal"
			case 1:
				return "panel"
			case 4:
				return "editor"
		}
	}
	t.from = e
})((Rg ||= {}))
var vx
;((e) => {
	function o(t, n) {
		let r = t.value
		if (!r) throw new Error("Invalid value reference")
		if (df(r)) r = y.revive(r)
		else if (r && typeof r == "object" && "uri" in r && "range" in r && df(r.uri)) r = Ja.to(ut(r))
		else if (JM(t)) {
			let i = t.references?.[0]?.reference
			r = new Vu(
				t.mimeType ?? "image/png",
				() => Promise.resolve(new Uint8Array(Object.values(t.value))),
				i && y.isUri(i) ? i : void 0,
			)
		} else if (t.kind === "diagnostic") {
			let i = t.filterSeverity && nx.to(t.filterSeverity),
				s = t.filterUri && y.revive(t.filterUri).toString()
			r = new Bu(
				n
					.map(([a, l]) =>
						t.filterUri && a.toString() !== s
							? [a, []]
							: [
									a,
									l.filter(
										(d) =>
											!(
												(i && d.severity > i) ||
												(t.filterRange &&
													!Re.areIntersectingOrTouching(t.filterRange, H.from(d.range)))
											),
									),
								],
					)
					.filter(([, a]) => a.length > 0),
			)
		}
		return {
			id: t.id,
			name: t.name,
			range: t.range && [t.range.start, t.range.endExclusive],
			value: r,
			modelDescription: t.modelDescription,
		}
	}
	e.to = o
})((vx ||= {}))
var bx
;((e) => {
	function o(t) {
		if (t.value) throw new Error("Invalid tool reference")
		return { name: t.id, range: t.range && [t.range.start, t.range.endExclusive] }
	}
	e.to = o
})((bx ||= {}))
var YD
;((e) => {
	function o(t, n, r) {
		return {
			id: t.id,
			label: t.label,
			fullName: t.fullName,
			icon: t.icon?.id,
			value: t.values[0].value,
			insertText: t.insertText,
			detail: t.detail,
			documentation: t.documentation,
			command: n.toInternal(t.command, r),
		}
	}
	e.from = o
})((YD ||= {}))
var ep
;((n) => {
	function o(r) {
		return { errorDetails: r.errorDetails, metadata: t(r.metadata), nextQuestion: r.nextQuestion }
	}
	n.to = o
	function e(r) {
		return { errorDetails: r.errorDetails, metadata: r.metadata, nextQuestion: r.nextQuestion }
	}
	n.from = e
	function t(r) {
		return ns(r, (i) => {
			if (i.$mid === 20) return new Qa(ns(i.content, t))
			if (i.$mid === 21) return new Pt(i.value)
			if (i.$mid === 22) return new xo(i.value)
		})
	}
})((ep ||= {}))
var ZD
;((e) => {
	function o(t, n, r) {
		if (n.action.kind === "vote") return
		let i = ep.to(t)
		if (n.action.kind === "command") {
			let s = n.action.commandButton.command
			return {
				action: {
					kind: "command",
					commandButton: { command: r.fromInternal(s) ?? { command: s.id, title: s.title } },
				},
				result: i,
			}
		} else
			return n.action.kind === "followUp"
				? { action: { kind: "followUp", followup: Pg.to(n.action.followup) }, result: i }
				: n.action.kind === "inlineChat"
					? { action: { kind: "editor", accepted: n.action.action === "accepted" }, result: i }
					: n.action.kind === "chatEditingSessionAction"
						? {
								action: {
									kind: "chatEditingSessionAction",
									outcome:
										new Map([
											["accepted", 1],
											["rejected", 2],
											["saved", 3],
										]).get(n.action.outcome) ?? 2,
									uri: y.revive(n.action.uri),
									hasRemainingEdits: n.action.hasRemainingEdits,
								},
								result: i,
							}
						: { action: n.action, result: i }
	}
	e.to = o
})((ZD ||= {}))
var yx
;((e) => {
	function o(t, n, r) {
		return "terminalCommand" in t
			? { terminalCommand: t.terminalCommand, shouldExecute: t.shouldExecute }
			: "uri" in t
				? { uri: t.uri }
				: n.toInternal(t, r)
	}
	e.from = o
})((yx ||= {}))
var _D
;((e) => {
	function o(t) {
		return { ...t, documentation: Ce.fromStrict(t.documentation) }
	}
	e.from = o
})((_D ||= {}))
var ek
;((e) => {
	function o(t) {
		return Array.isArray(t)
			? { items: t.map((n) => _D.from(n)) }
			: {
					items: t.items.map((n) => _D.from(n)),
					resourceRequestConfig: t.resourceRequestConfig ? EF.from(t.resourceRequestConfig) : void 0,
				}
	}
	e.from = o
})((ek ||= {}))
var EF
;((e) => {
	function o(t) {
		return { ...t, pathSeparator: Ie ? "\\" : "/", cwd: t.cwd ? y.revive(t.cwd) : void 0 }
	}
	e.from = o
})((EF ||= {}))
var tk
;((e) => {
	function o(t) {
		return { kind: wF.to(t.kind), acceptedLength: t.acceptedLength }
	}
	e.to = o
})((tk ||= {}))
var wF
;((e) => {
	function o(t) {
		switch (t) {
			case 0:
				return 1
			case 1:
				return 2
			case 2:
				return 3
			default:
				return 0
		}
	}
	e.to = o
})((wF ||= {}))
var nk
;((e) => {
	function o(t, n) {
		return {
			id: n,
			label: t.label,
			description: t.description,
			canEdit: t.canEdit,
			collapsibleState: t.collapsibleState || 0,
			contextValue: t.contextValue,
		}
	}
	e.from = o
})((nk ||= {}))
var rk
;((e) => {
	function o(t) {
		return { name: t.id, description: t.modelDescription, inputSchema: t.inputSchema, tags: t.tags ?? [] }
	}
	e.to = o
})((rk ||= {}))
var Ix
;((t) => {
	function o(n) {
		return new Qa(n.content.map((r) => (r.kind === "text" ? new Pt(r.value) : new xo(r.value))))
	}
	t.to = o
	function e(n, r) {
		return (
			n.toolResultMessage && M(r, "chatParticipantPrivate"),
			{
				content: n.content.map((i) => {
					if (i instanceof Pt) return { kind: "text", value: i.value }
					if (i instanceof xo) return { kind: "promptTsx", value: i.value }
					throw new Error("Unknown LanguageModelToolResult part type")
				}),
				toolResultMessage: Ce.fromStrict(n.toolResultMessage),
				toolResultDetails: n.toolResultDetails?.map((i) => (y.isUri(i) ? i : Ja.from(i))),
			}
		)
	}
	t.from = e
})((Ix ||= {}))
var ok
;((e) => {
	function o(t) {
		return t
	}
	e.fromThemeIcon = o
})((ok ||= {}))
var xx = class o {
		constructor(e, t) {
			this.line = e
			this.character = t
		}
		isBefore(e) {
			return !1
		}
		isBeforeOrEqual(e) {
			return !1
		}
		isAfter(e) {
			return !1
		}
		isAfterOrEqual(e) {
			return !1
		}
		isEqual(e) {
			return !1
		}
		compareTo(e) {
			return 0
		}
		translate(e, t) {
			return new o(0, 0)
		}
		with(e) {
			return new o(0, 0)
		}
	},
	tp = class o {
		constructor(e, t, n, r) {
			this.isEmpty = !1
			this.isSingleLine = !1
			;(this.start = new xx(e, t)), (this.end = new xx(n, r))
		}
		contains(e) {
			return !1
		}
		isEqual(e) {
			return !1
		}
		intersection(e) {}
		union(e) {
			return new o(0, 0, 0, 0)
		}
		with(e) {
			return new o(0, 0, 0, 0)
		}
	},
	cr = class {
		constructor(e, t, n) {
			this.uri = e
			this.ranges = t
			this.previewText = n
		}
	},
	Ai = class {
		constructor(e, t, n) {
			this.uri = e
			this.text = t
			this.lineNumber = n
		}
	},
	Cx = ((n) => (
		(n[(n.None = 1)] = "None"),
		(n[(n.FilesExclude = 2)] = "FilesExclude"),
		(n[(n.SearchAndFilesExclude = 3)] = "SearchAndFilesExclude"),
		n
	))(Cx || {}),
	Ag = ((t) => ((t[(t.Information = 1)] = "Information"), (t[(t.Warning = 2)] = "Warning"), t))(Ag || {})
var Za = 2e4,
	PF = "\u27EA ",
	_F = " characters skipped \u27EB",
	R7 = (PF.length + _F.length + 5) * 2,
	A7 = O("searchService")
function Og(o) {
	return !!o.rangeLocations && !!o.previewText
}
var np = class {
	constructor(e, t, n, r) {
		this.rangeLocations = []
		this.webviewIndex = r
		let i = Array.isArray(t) ? t : [t]
		if (n && n.matchLines === 1 && O7(i)) {
			e = TA(e, n.matchLines)
			let s = "",
				a = 0,
				l = 0,
				d = Math.floor(n.charsPerLine / 5)
			for (let c of i) {
				let u = Math.max(c.startColumn - d, 0),
					m = c.startColumn + n.charsPerLine
				if (u > l + d + R7) {
					let f = PF + (u - l) + _F
					;(s += f + e.slice(u, m)), (a += u - (l + f.length))
				} else s += e.slice(l, m)
				;(l = m),
					this.rangeLocations.push({ source: c, preview: new ik(0, c.startColumn - a, c.endColumn - a) })
			}
			this.previewText = s
		} else {
			let s = Array.isArray(t) ? t[0].startLineNumber : t.startLineNumber,
				a = El(t, (l) => ({
					preview: new rp(l.startLineNumber - s, l.startColumn, l.endLineNumber - s, l.endColumn),
					source: l,
				}))
			;(this.rangeLocations = Array.isArray(a) ? a : [a]), (this.previewText = e)
		}
	}
}
function O7(o) {
	let e = o[0].startLineNumber
	for (let t of o) if (t.startLineNumber !== e || t.endLineNumber !== e) return !1
	return !0
}
var rp = class {
		constructor(e, t, n, r) {
			;(this.startLineNumber = e), (this.startColumn = t), (this.endLineNumber = n), (this.endColumn = r)
		}
	},
	ik = class extends rp {
		constructor(e, t, n) {
			super(e, t, e, n)
		}
	}
function DF(o, e = !0) {
	let t = o && o.files && o.files.exclude,
		n = e && o && o.search && o.search.exclude
	if (!t && !n) return
	if (!t || !n) return t || n || void 0
	let r = Object.create(null)
	return (r = fr(r, je(t))), (r = fr(r, je(n), !0)), r
}
function sk(o, e) {
	return o.excludePattern && vi(o.excludePattern, e)
		? !1
		: o.includePattern || o.usingSearchPaths
			? o.includePattern && vi(o.includePattern, e)
				? !0
				: o.usingSearchPaths
					? !!o.folderQueries &&
						o.folderQueries.some((t) => {
							let n = t.folder.fsPath
							if (zr(e, n)) {
								let r = Oo(n, e)
								return !t.includePattern || !!vi(t.includePattern, r)
							} else return !1
						})
					: !1
			: !0
}
var Oi = class extends Error {
	constructor(t, n) {
		super(t)
		this.code = n
	}
}
function ak(o) {
	let e = { message: o.message, code: o.code }
	return new Error(JSON.stringify(e))
}
function kF(o) {
	return !!o.path
}
function Lg(o, e, t = !0) {
	let n = o.searchPath ? o.searchPath : o.relativePath
	return t ? CA(n, e) : vi(e, n)
}
function el(o, e) {
	let t = { ...(o || {}), ...(e || {}) }
	return Object.keys(t).filter((n) => {
		let r = t[n]
		return typeof r == "boolean" && r
	})
}
var op = class {
	constructor(e, t) {
		this._parsedIncludeExpression = null
		;(this._excludeExpression =
			t.excludePattern?.map((r) => ({ ...(e.excludePattern || {}), ...(r.pattern || {}) })) ?? []),
			this._excludeExpression.length === 0 && (this._excludeExpression = [e.excludePattern || {}]),
			(this._parsedExcludeExpression = this._excludeExpression.map((r) => Xn(r)))
		let n = e.includePattern
		t.includePattern && (n ? (n = { ...n, ...t.includePattern }) : (n = t.includePattern)),
			n && (this._parsedIncludeExpression = Xn(n))
	}
	_evalParsedExcludeExpression(e, t, n) {
		let r = null
		for (let i of this._parsedExcludeExpression) {
			let s = i(e, t, n)
			if (typeof s == "string") {
				r = s
				break
			}
		}
		return r
	}
	matchesExcludesSync(e, t, n) {
		return !!(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, t, n))
	}
	includedInQuerySync(e, t, n) {
		return !(
			(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, t, n)) ||
			(this._parsedIncludeExpression && !this._parsedIncludeExpression(e, t, n))
		)
	}
	includedInQuery(e, t, n) {
		let r = () => (this._parsedIncludeExpression ? !!this._parsedIncludeExpression(e, t, n) : !0)
		return Promise.all(
			this._parsedExcludeExpression.map((i) => {
				let s = i(e, t, n)
				return io(s) ? s.then((a) => (a ? !1 : r())) : r()
			}),
		).then((i) => i.some((s) => !!s))
	}
	hasSiblingExcludeClauses() {
		return this._excludeExpression.reduce((e, t) => L7(t) || e, !1)
	}
}
function L7(o) {
	for (let e in o) if (typeof o[e] != "boolean") return !0
	return !1
}
function RF(o) {
	if (!o) return
	let e
	return (t) => (e || (e = (o() || Promise.resolve([])).then((n) => (n ? AF(n) : {}))), e.then((n) => !!n[t]))
}
function Mg(o) {
	if (!o) return
	let e
	return (t) => {
		if (!e) {
			let n = o()
			e = n ? AF(n) : {}
		}
		return !!e[t]
	}
}
function AF(o) {
	let e = {}
	for (let t of o) e[t] = !0
	return e
}
function Sx(o) {
	return o.flatMap((e) => e.patterns.map((t) => (e.baseUri ? { baseUri: e.baseUri, pattern: t } : t)))
}
var Fg = { matchLines: 100, charsPerLine: 1e4 }
var M7 = !1,
	dk = class {
		constructor(e, t, n) {
			this.id = e
			this.dependencies = t
			this.callback = n
		}
	}
var ck = class o {
		constructor() {
			this._isWebWorker =
				typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope"
			this._isRenderer = typeof document == "object"
			this._defineCalls = []
			this._state = 1
		}
		static {
			this.INSTANCE = new o()
		}
		_initialize() {
			if (this._state === 1) {
				if (globalThis.define) {
					this._state = 3
					return
				}
			} else return
			;(this._state = 2),
				(globalThis.define = (e, t, n) => {
					typeof e != "string" && ((n = t), (t = e), (e = null)),
						(typeof t != "object" || !Array.isArray(t)) && ((n = t), (t = null)),
						this._defineCalls.push(new dk(e, t, n))
				}),
				(globalThis.define.amd = !0),
				this._isRenderer
					? (this._amdPolicy =
							globalThis._VSCODE_WEB_PACKAGE_TTP ??
							window.trustedTypes?.createPolicy("amdLoader", {
								createScriptURL(e) {
									if (
										e.startsWith(window.location.origin) ||
										e.startsWith(`${W.vscodeFileResource}://${CE}`)
									)
										return e
									throw new Error(`[trusted_script_src] Invalid script url: ${e}`)
								},
							}))
					: this._isWebWorker &&
						(this._amdPolicy =
							globalThis._VSCODE_WEB_PACKAGE_TTP ??
							globalThis.trustedTypes?.createPolicy("amdLoader", {
								createScriptURL(e) {
									return e
								},
							}))
		}
		async load(e) {
			if ((this._initialize(), this._state === 3))
				return new Promise((s) => {
					let a = He()
					globalThis.define(a, [e], function (l) {
						s(l)
					})
				})
			let t = await (this._isWebWorker
				? this._workerLoadScript(e)
				: this._isRenderer
					? this._rendererLoadScript(e)
					: this._nodeJSLoadScript(e))
			if (!t) {
				console.warn(`Did not receive a define call from script ${e}`)
				return
			}
			let n = {},
				r = [],
				i = []
			if (Array.isArray(t.dependencies)) for (let s of t.dependencies) s === "exports" ? r.push(n) : i.push(s)
			if (i.length > 0)
				throw new Error(`Cannot resolve dependencies for script ${e}. The dependencies are: ${i.join(", ")}`)
			return typeof t.callback == "function" ? (t.callback(...r) ?? n) : t.callback
		}
		_rendererLoadScript(e) {
			return new Promise((t, n) => {
				let r = document.createElement("script")
				r.setAttribute("async", "async"), r.setAttribute("type", "text/javascript")
				let i = () => {
						r.removeEventListener("load", s), r.removeEventListener("error", a)
					},
					s = (l) => {
						i(), t(this._defineCalls.pop())
					},
					a = (l) => {
						i(), n(l)
					}
				r.addEventListener("load", s),
					r.addEventListener("error", a),
					this._amdPolicy && (e = this._amdPolicy.createScriptURL(e)),
					r.setAttribute("src", e),
					window.document.getElementsByTagName("head")[0].appendChild(r)
			})
		}
		async _workerLoadScript(e) {
			return this._amdPolicy && (e = this._amdPolicy.createScriptURL(e)), await import(e), this._defineCalls.pop()
		}
		async _nodeJSLoadScript(e) {
			try {
				let t = (await import("fs")).default,
					n = (await import("vm")).default,
					r = (await import("module")).default,
					i = y.parse(e).fsPath,
					s = t.readFileSync(i).toString(),
					a = r.wrap(s.replace(/^#!.*/, ""))
				return new n.Script(a).runInThisContext().apply(), this._defineCalls.pop()
			} catch (t) {
				throw t
			}
		}
	},
	lk = new Map()
async function ip(o, e, t) {
	t === void 0 &&
		(t = !!(globalThis._VSCODE_PRODUCT_JSON ?? globalThis.vscode?.context?.configuration()?.product)?.commit)
	let n = e ? `${o}/${e}` : o
	if (lk.has(n)) return lk.get(n)
	let r
	if (/^\w[\w\d+.-]*:\/\//.test(n)) r = n
	else {
		let l = `${M7 && t && !Ro ? NA : FA}/${n}`
		r = Ic.asBrowserUri(l).toString(!0)
	}
	let i = ck.INSTANCE.load(r)
	return lk.set(n, i), i
}
var Ug = "utf8",
	gk = "utf8bom",
	Ex = "utf16be",
	wx = "utf16le"
var Tx = [254, 255],
	pk = [255, 254],
	Ng = [239, 187, 191],
	F7 = 512,
	N7 = 512,
	U7 = 512 * 8,
	H7 = 512 * 128
var mk = class extends Error {
		constructor(t, n) {
			super(t)
			this.decodeStreamErrorKind = n
		}
	},
	fk = class o {
		constructor(e) {
			this.iconvLiteDecoder = e
		}
		static async create(e) {
			let t
			if (e !== Ug) t = (await ip("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js")).getDecoder(MF(e))
			else {
				let n = new TextDecoder()
				t = {
					write(r) {
						return n.decode(r, { stream: !0 })
					},
					end() {
						return n.decode()
					},
				}
			}
			return new o(t)
		}
		write(e) {
			return this.iconvLiteDecoder.write(e)
		}
		end() {
			return this.iconvLiteDecoder.end()
		}
	}
function OF(o, e) {
	let t = (e.minBytesRequiredForDetection ?? e.guessEncoding) ? U7 : N7
	return new Promise((n, r) => {
		let i = Al((u) => u.join("")),
			s = [],
			a = 0,
			l,
			d = new _e(),
			c = async () => {
				try {
					let u = await j7({ buffer: z.concat(s), bytesRead: a }, e.guessEncoding, e.candidateGuessEncodings)
					if (u.seemsBinary && e.acceptTextOnly)
						throw new mk("Stream is binary but only text is accepted for decoding", 1)
					;(u.encoding = await e.overwriteEncoding(u.encoding)), (l = await fk.create(u.encoding))
					let m = l.write(z.concat(s).buffer)
					i.write(m), (s.length = 0), (a = 0), n({ stream: i, detected: u })
				} catch (u) {
					d.cancel(), i.destroy(), r(u)
				}
			}
		Uv(
			o,
			{
				onData: async (u) => {
					l
						? i.write(l.write(u.buffer))
						: (s.push(u),
							(a += u.byteLength),
							a >= t && (o.pause(), await c(), setTimeout(() => o.resume())))
				},
				onError: (u) => i.error(u),
				onEnd: async () => {
					l || (await c()), i.end(l?.end())
				},
			},
			d.token,
		)
	})
}
async function LF(o, e, t) {
	let r = (await ip("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js")).getEncoder(MF(e), t),
		i = !1,
		s = !1
	return {
		read() {
			if (s) return null
			let a = o.read()
			if (typeof a != "string") {
				if (((s = !0), !i && t?.addBOM))
					switch (e) {
						case Ug:
						case gk:
							return z.wrap(Uint8Array.from(Ng))
						case Ex:
							return z.wrap(Uint8Array.from(Tx))
						case wx:
							return z.wrap(Uint8Array.from(pk))
					}
				let l = r.end()
				return l && l.length > 0 ? ((i = !0), z.wrap(l)) : null
			}
			return (i = !0), z.wrap(r.write(a))
		},
	}
}
function MF(o) {
	return o === gk || o === null ? Ug : o
}
function W7(o, e) {
	if (!o || e < Tx.length) return null
	let t = o.readUInt8(0),
		n = o.readUInt8(1)
	if (t === Tx[0] && n === Tx[1]) return Ex
	if (t === pk[0] && n === pk[1]) return wx
	if (e < Ng.length) return null
	let r = o.readUInt8(2)
	return t === Ng[0] && n === Ng[1] && r === Ng[2] ? gk : null
}
var V7 = ["ascii", "utf-16", "utf-32"]
async function B7(o, e) {
	let t = await ip("jschardet", "dist/jschardet.min.js"),
		n = o.slice(0, H7),
		r = K7(n.buffer)
	e && ((e = Ye(e.map((a) => q7(a)))), e.length === 0 && (e = void 0))
	let i
	try {
		i = t.detect(r, e ? { detectEncodings: e } : void 0)
	} catch {
		return null
	}
	if (!i || !i.encoding) return null
	let s = i.encoding.toLowerCase()
	return 0 <= V7.indexOf(s) ? null : z7(i.encoding)
}
var $7 = { ibm866: "cp866", big5: "cp950" }
function FF(o) {
	return o.replace(/[^a-zA-Z0-9]/g, "").toLowerCase()
}
function z7(o) {
	let e = FF(o)
	return $7[e] || e
}
function q7(o) {
	let e = FF(o),
		t = G7[e]
	return t ? t.guessableName : void 0
}
function K7(o) {
	let e = ""
	for (let t = 0; t < o.length; t++) e += String.fromCharCode(o[t])
	return e
}
function NF(o) {
	switch (o) {
		case "shiftjis":
			return "shift-jis"
		case "utf16le":
			return "utf-16le"
		case "utf16be":
			return "utf-16be"
		case "big5hkscs":
			return "big5-hkscs"
		case "eucjp":
			return "euc-jp"
		case "euckr":
			return "euc-kr"
		case "koi8r":
			return "koi8-r"
		case "koi8u":
			return "koi8-u"
		case "macroman":
			return "x-mac-roman"
		case "utf8bom":
			return "utf8"
		default: {
			let e = o.match(/windows(\d+)/)
			return e ? "windows-" + e[1] : o
		}
	}
}
function j7({ buffer: o, bytesRead: e }, t, n) {
	let r = W7(o, e),
		i = !1
	if (r !== Ex && r !== wx && o) {
		let s = !0,
			a = !0,
			l = !1
		for (let d = 0; d < e && d < F7; d++) {
			let c = d % 2 === 1,
				u = o.readUInt8(d) === 0
			if (
				(u && (l = !0),
				s && ((c && !u) || (!c && u)) && (s = !1),
				a && ((c && u) || (!c && !u)) && (a = !1),
				u && !s && !a)
			)
				break
		}
		l && (s ? (r = wx) : a ? (r = Ex) : (i = !0))
	}
	return t && !i && !r && o
		? B7(o.slice(0, e), n).then((s) => ({ seemsBinary: !1, encoding: s }))
		: { seemsBinary: i, encoding: r }
}
var uk = {
		utf8: { labelLong: "UTF-8", labelShort: "UTF-8", order: 1, alias: "utf8bom", guessableName: "UTF-8" },
		utf8bom: { labelLong: "UTF-8 with BOM", labelShort: "UTF-8 with BOM", encodeOnly: !0, order: 2, alias: "utf8" },
		utf16le: { labelLong: "UTF-16 LE", labelShort: "UTF-16 LE", order: 3, guessableName: "UTF-16LE" },
		utf16be: { labelLong: "UTF-16 BE", labelShort: "UTF-16 BE", order: 4, guessableName: "UTF-16BE" },
		windows1252: {
			labelLong: "Western (Windows 1252)",
			labelShort: "Windows 1252",
			order: 5,
			guessableName: "windows-1252",
		},
		iso88591: { labelLong: "Western (ISO 8859-1)", labelShort: "ISO 8859-1", order: 6 },
		iso88593: { labelLong: "Western (ISO 8859-3)", labelShort: "ISO 8859-3", order: 7 },
		iso885915: { labelLong: "Western (ISO 8859-15)", labelShort: "ISO 8859-15", order: 8 },
		macroman: { labelLong: "Western (Mac Roman)", labelShort: "Mac Roman", order: 9 },
		cp437: { labelLong: "DOS (CP 437)", labelShort: "CP437", order: 10 },
		windows1256: { labelLong: "Arabic (Windows 1256)", labelShort: "Windows 1256", order: 11 },
		iso88596: { labelLong: "Arabic (ISO 8859-6)", labelShort: "ISO 8859-6", order: 12 },
		windows1257: { labelLong: "Baltic (Windows 1257)", labelShort: "Windows 1257", order: 13 },
		iso88594: { labelLong: "Baltic (ISO 8859-4)", labelShort: "ISO 8859-4", order: 14 },
		iso885914: { labelLong: "Celtic (ISO 8859-14)", labelShort: "ISO 8859-14", order: 15 },
		windows1250: {
			labelLong: "Central European (Windows 1250)",
			labelShort: "Windows 1250",
			order: 16,
			guessableName: "windows-1250",
		},
		iso88592: {
			labelLong: "Central European (ISO 8859-2)",
			labelShort: "ISO 8859-2",
			order: 17,
			guessableName: "ISO-8859-2",
		},
		cp852: { labelLong: "Central European (CP 852)", labelShort: "CP 852", order: 18 },
		windows1251: {
			labelLong: "Cyrillic (Windows 1251)",
			labelShort: "Windows 1251",
			order: 19,
			guessableName: "windows-1251",
		},
		cp866: { labelLong: "Cyrillic (CP 866)", labelShort: "CP 866", order: 20, guessableName: "IBM866" },
		cp1125: { labelLong: "Cyrillic (CP 1125)", labelShort: "CP 1125", order: 21, guessableName: "IBM1125" },
		iso88595: {
			labelLong: "Cyrillic (ISO 8859-5)",
			labelShort: "ISO 8859-5",
			order: 22,
			guessableName: "ISO-8859-5",
		},
		koi8r: { labelLong: "Cyrillic (KOI8-R)", labelShort: "KOI8-R", order: 23, guessableName: "KOI8-R" },
		koi8u: { labelLong: "Cyrillic (KOI8-U)", labelShort: "KOI8-U", order: 24 },
		iso885913: { labelLong: "Estonian (ISO 8859-13)", labelShort: "ISO 8859-13", order: 25 },
		windows1253: {
			labelLong: "Greek (Windows 1253)",
			labelShort: "Windows 1253",
			order: 26,
			guessableName: "windows-1253",
		},
		iso88597: { labelLong: "Greek (ISO 8859-7)", labelShort: "ISO 8859-7", order: 27, guessableName: "ISO-8859-7" },
		windows1255: {
			labelLong: "Hebrew (Windows 1255)",
			labelShort: "Windows 1255",
			order: 28,
			guessableName: "windows-1255",
		},
		iso88598: {
			labelLong: "Hebrew (ISO 8859-8)",
			labelShort: "ISO 8859-8",
			order: 29,
			guessableName: "ISO-8859-8",
		},
		iso885910: { labelLong: "Nordic (ISO 8859-10)", labelShort: "ISO 8859-10", order: 30 },
		iso885916: { labelLong: "Romanian (ISO 8859-16)", labelShort: "ISO 8859-16", order: 31 },
		windows1254: { labelLong: "Turkish (Windows 1254)", labelShort: "Windows 1254", order: 32 },
		iso88599: { labelLong: "Turkish (ISO 8859-9)", labelShort: "ISO 8859-9", order: 33 },
		windows1258: { labelLong: "Vietnamese (Windows 1258)", labelShort: "Windows 1258", order: 34 },
		gbk: { labelLong: "Simplified Chinese (GBK)", labelShort: "GBK", order: 35 },
		gb18030: { labelLong: "Simplified Chinese (GB18030)", labelShort: "GB18030", order: 36 },
		cp950: { labelLong: "Traditional Chinese (Big5)", labelShort: "Big5", order: 37, guessableName: "Big5" },
		big5hkscs: { labelLong: "Traditional Chinese (Big5-HKSCS)", labelShort: "Big5-HKSCS", order: 38 },
		shiftjis: { labelLong: "Japanese (Shift JIS)", labelShort: "Shift JIS", order: 39, guessableName: "SHIFT_JIS" },
		eucjp: { labelLong: "Japanese (EUC-JP)", labelShort: "EUC-JP", order: 40, guessableName: "EUC-JP" },
		euckr: { labelLong: "Korean (EUC-KR)", labelShort: "EUC-KR", order: 41, guessableName: "EUC-KR" },
		windows874: { labelLong: "Thai (Windows 874)", labelShort: "Windows 874", order: 42 },
		iso885911: { labelLong: "Latin/Thai (ISO 8859-11)", labelShort: "ISO 8859-11", order: 43 },
		koi8ru: { labelLong: "Cyrillic (KOI8-RU)", labelShort: "KOI8-RU", order: 44 },
		koi8t: { labelLong: "Tajik (KOI8-T)", labelShort: "KOI8-T", order: 45 },
		gb2312: {
			labelLong: "Simplified Chinese (GB 2312)",
			labelShort: "GB 2312",
			order: 46,
			guessableName: "GB2312",
		},
		cp865: { labelLong: "Nordic DOS (CP 865)", labelShort: "CP 865", order: 47 },
		cp850: { labelLong: "Western European DOS (CP 850)", labelShort: "CP 850", order: 48 },
	},
	G7 = (() => {
		let o = {}
		for (let e in uk) uk[e].guessableName && (o[e] = uk[e])
		return o
	})()
var UF = O("textFileService")
function HF(o) {
	let e = !1
	return {
		read() {
			return e ? null : ((e = !0), o)
		},
	}
}
function Wg(o, e, t) {
	return new Xi((n) => hk(n, t)).isEqual(o, e)
}
function Q7(o, e, t) {
	return Wg(o.uri, e.uri, t) ? 0 : Lo(o.uri.toString(), e.uri.toString())
}
function J7(o, e, t) {
	return o.index !== e.index
		? o.index < e.index
			? -1
			: 1
		: Wg(o.uri, e.uri, t)
			? Lo(o.name, e.name)
			: Lo(o.uri.toString(), e.uri.toString())
}
function VF(o, e, t, n) {
	let r = o.slice(0).sort((s, a) => t(s, a, n)),
		i = e.slice(0).sort((s, a) => t(s, a, n))
	return k0(r, i, (s, a) => t(s, a, n))
}
function hk(o, e) {
	let t = e.getCapabilities(o.scheme)
	return !(t && t & 1024)
}
var Hg = class o extends vb {
		constructor(t, n, r, i, s, a, l) {
			super(
				t,
				r.map((d) => new Ql(d)),
				i,
				s,
				l,
			)
			this._name = n
			this._isUntitled = a
			this._workspaceFolders = []
			;(this._structure = hr.forUris(l, () => !0)),
				r.forEach((d) => {
					this._workspaceFolders.push(d), this._structure.set(d.uri, d)
				})
		}
		static toExtHostWorkspace(t, n, r, i) {
			if (!t) return { workspace: null, added: [], removed: [] }
			let { id: s, name: a, folders: l, configuration: d, transient: c, isUntitled: u } = t,
				m = [],
				f = n
			n
				? l.forEach((C, T) => {
						let w = y.revive(C.uri),
							L = o._findFolder(r || n, w, i)
						L
							? ((L.name = C.name), (L.index = C.index), m.push(L))
							: m.push({ uri: w, name: C.name, index: T })
					})
				: m.push(...l.map(({ uri: C, name: T, index: w }) => ({ uri: y.revive(C), name: T, index: w }))),
				m.sort((C, T) => (C.index < T.index ? -1 : 1))
			let h = new o(s, a, m, !!c, d ? y.revive(d) : null, !!u, (C) => hk(C, i)),
				{ added: g, removed: I } = VF(f ? f.workspaceFolders : [], h.workspaceFolders, Q7, i)
			return { workspace: h, added: g, removed: I }
		}
		static _findFolder(t, n, r) {
			for (let i = 0; i < t.folders.length; i++) {
				let s = t.workspaceFolders[i]
				if (Wg(s.uri, n, r)) return s
			}
		}
		get name() {
			return this._name
		}
		get isUntitled() {
			return this._isUntitled
		}
		get workspaceFolders() {
			return this._workspaceFolders.slice(0)
		}
		getWorkspaceFolder(t, n) {
			return n && this._structure.get(t) && (t = Yi(t)), this._structure.findSubstr(t)
		}
		resolveWorkspaceFolder(t) {
			return this._structure.get(t)
		}
	},
	sp = class {
		constructor(e, t, n, r, i) {
			this._onDidChangeWorkspace = new E()
			this.onDidChangeWorkspace = this._onDidChangeWorkspace.event
			this._onDidGrantWorkspaceTrust = new E()
			this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event
			this._activeSearchCallbacks = []
			this._trusted = !1
			this._editSessionIdentityProviders = new Map()
			this._providerHandlePool = 0
			this._onWillCreateEditSessionIdentityEvent = new si()
			this._canonicalUriProviders = new Map()
			;(this._logService = r),
				(this._extHostFileSystemInfo = n),
				(this._uriTransformerService = i),
				(this._requestIdProvider = new pb()),
				(this._barrier = new dn()),
				(this._proxy = e.getProxy(N.MainThreadWorkspace)),
				(this._messageService = e.getProxy(N.MainThreadMessageService))
			let s = t.workspace
			this._confirmedWorkspace = s
				? new Hg(
						s.id,
						s.name,
						[],
						!!s.transient,
						s.configuration ? y.revive(s.configuration) : null,
						!!s.isUntitled,
						(a) => hk(a, n),
					)
				: void 0
		}
		$initializeWorkspace(e, t) {
			console.log("initializeWorkspace", e, t),
				(this._trusted = t),
				this.$acceptWorkspaceData(e),
				this._barrier.open()
		}
		waitForInitializeCall() {
			return this._barrier.wait()
		}
		get workspace() {
			return this._actualWorkspace
		}
		get name() {
			return this._actualWorkspace ? this._actualWorkspace.name : void 0
		}
		get workspaceFile() {
			if (this._actualWorkspace && this._actualWorkspace.configuration)
				return this._actualWorkspace.isUntitled
					? y.from({ scheme: W.untitled, path: Ht(Yi(this._actualWorkspace.configuration)) })
					: this._actualWorkspace.configuration
		}
		get _actualWorkspace() {
			return this._unconfirmedWorkspace || this._confirmedWorkspace
		}
		getWorkspaceFolders() {
			if (this._actualWorkspace) return this._actualWorkspace.workspaceFolders.slice(0)
		}
		async getWorkspaceFolders2() {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.workspaceFolders.slice(0)
		}
		updateWorkspaceFolders(e, t, n, ...r) {
			let i = []
			if (
				(Array.isArray(r) &&
					r.forEach((c) => {
						y.isUri(c.uri) &&
							!i.some((u) => Wg(u.uri, c.uri, this._extHostFileSystemInfo)) &&
							i.push({ uri: c.uri, name: c.name || cf(c.uri) })
					}),
				this._unconfirmedWorkspace ||
					[t, n].some((c) => typeof c != "number" || c < 0) ||
					(n === 0 && i.length === 0))
			)
				return !1
			let s = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : []
			if (t + n > s.length) return !1
			let a = s.slice(0)
			a.splice(t, n, ...i.map((c) => ({ uri: c.uri, name: c.name || cf(c.uri), index: void 0 })))
			for (let c = 0; c < a.length; c++) {
				let u = a[c]
				if (a.some((m, f) => f !== c && Wg(u.uri, m.uri, this._extHostFileSystemInfo))) return !1
			}
			a.forEach((c, u) => (c.index = u))
			let { added: l, removed: d } = VF(s, a, J7, this._extHostFileSystemInfo)
			if (l.length === 0 && d.length === 0) return !1
			if (this._proxy) {
				let c = e.displayName || e.name
				this._proxy.$updateWorkspaceFolders(c, t, n, i).then(void 0, (u) => {
					this._unconfirmedWorkspace = void 0
					let m = { source: { identifier: e.identifier, label: e.displayName || e.name } }
					this._messageService.$showMessage(
						rL.Error,
						p("updateerror", "Extension '{0}' failed to update workspace folders: {1}", c, u.toString()),
						m,
						[],
					)
				})
			}
			return this.trySetWorkspaceFolders(a), !0
		}
		getWorkspaceFolder(e, t) {
			if (this._actualWorkspace) return this._actualWorkspace.getWorkspaceFolder(e, t)
		}
		async getWorkspaceFolder2(e, t) {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.getWorkspaceFolder(e, t)
		}
		async resolveWorkspaceFolder(e) {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.resolveWorkspaceFolder(e)
		}
		getPath() {
			if (!this._actualWorkspace) return
			let { folders: e } = this._actualWorkspace
			if (e.length !== 0) return e[0].uri.fsPath
		}
		getRelativePath(e, t) {
			let n,
				r = ""
			if ((typeof e == "string" ? ((n = y.file(e)), (r = e)) : typeof e < "u" && ((n = e), (r = e.fsPath)), !n))
				return r
			let i = this.getWorkspaceFolder(n, !0)
			if (!i) return r
			typeof t > "u" && this._actualWorkspace && (t = this._actualWorkspace.folders.length > 1)
			let s = uf(i.uri, n)
			return t && i.name && (s = `${i.name}/${s}`), s
		}
		trySetWorkspaceFolders(e) {
			this._actualWorkspace &&
				(this._unconfirmedWorkspace =
					Hg.toExtHostWorkspace(
						{
							id: this._actualWorkspace.id,
							name: this._actualWorkspace.name,
							configuration: this._actualWorkspace.configuration,
							folders: e,
							isUntitled: this._actualWorkspace.isUntitled,
						},
						this._actualWorkspace,
						void 0,
						this._extHostFileSystemInfo,
					).workspace || void 0)
		}
		$acceptWorkspaceData(e) {
			let {
				workspace: t,
				added: n,
				removed: r,
			} = Hg.toExtHostWorkspace(
				e,
				this._confirmedWorkspace,
				this._unconfirmedWorkspace,
				this._extHostFileSystemInfo,
			)
			;(this._confirmedWorkspace = t || void 0),
				(this._unconfirmedWorkspace = void 0),
				this._onDidChangeWorkspace.fire(Object.freeze({ added: n, removed: r }))
		}
		findFiles(e, t, n, r, i = De.None) {
			this._logService.trace(
				`extHostWorkspace#findFiles: fileSearch, extension: ${r.value}, entryPoint: findFiles`,
			)
			let s = "",
				a = !0
			return (
				t === null ? (a = !1) : t !== void 0 && (typeof t == "string" ? (s = t) : (s = t.pattern)),
				this._findFilesImpl(
					{ type: "include", value: e },
					{ exclude: [s], maxResults: n, useExcludeSettings: a ? 2 : 1, useIgnoreFiles: { local: !1 } },
					i,
				)
			)
		}
		findFiles2(e, t = {}, n, r = De.None) {
			return (
				this._logService.trace(
					`extHostWorkspace#findFiles2New: fileSearch, extension: ${n.value}, entryPoint: findFiles2New`,
				),
				this._findFilesImpl({ type: "filePatterns", value: e }, t, r)
			)
		}
		async _findFilesImpl(e, t, n) {
			if (n.isCancellationRequested) return Promise.resolve([])
			let r = e.type === "include" ? [e.value] : (e.value ?? [])
			if (!Array.isArray(r))
				throw (
					(console.error("Invalid file pattern provided", r),
					new Error(`Invalid file pattern provided ${JSON.stringify(r)}`))
				)
			let i = r.map((s) => {
				let a = WF(t.exclude),
					l = {
						ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
						disregardIgnoreFiles:
							typeof t.useIgnoreFiles?.local == "boolean" ? !t.useIgnoreFiles.local : void 0,
						disregardGlobalIgnoreFiles:
							typeof t.useIgnoreFiles?.global == "boolean" ? !t.useIgnoreFiles.global : void 0,
						disregardParentIgnoreFiles:
							typeof t.useIgnoreFiles?.parent == "boolean" ? !t.useIgnoreFiles.parent : void 0,
						disregardExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings === 1,
						disregardSearchExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings !== 3,
						maxResults: t.maxResults,
						excludePattern: a.length > 0 ? a : void 0,
						_reason: "startFileSearch",
						shouldGlobSearch: e.type === "include" ? void 0 : !0,
					},
					d = Px(yr.from(s)),
					c = d?.folder
				return (
					e.type === "include" ? (l.includePattern = d?.pattern) : (l.filePattern = d?.pattern),
					{ folder: c, options: l }
				)
			})
			return this._findFilesBase(i, n)
		}
		async _findFilesBase(e, t) {
			return (
				await Promise.all(
					e?.map((r) =>
						this._proxy
							.$startFileSearch(r.folder ?? null, r.options, t)
							.then((i) => (Array.isArray(i) ? i.map((s) => y.revive(s)) : [])),
					) ?? [],
				)
			).flat()
		}
		findTextInFiles2(e, t, n, r = De.None) {
			this._logService.trace(
				`extHostWorkspace#findTextInFiles2: textSearch, extension: ${n.value}, entryPoint: findTextInFiles2`,
			)
			let i = (m) => {
					if (!t) return { folder: void 0, options: {} }
					let f = m ? Px(yr.from(m)) : void 0,
						h = t.exclude ? WF(t.exclude) : void 0
					return {
						options: {
							ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
							disregardIgnoreFiles: typeof t.useIgnoreFiles == "boolean" ? !t.useIgnoreFiles : void 0,
							disregardGlobalIgnoreFiles:
								typeof t.useIgnoreFiles?.global == "boolean" ? !t.useIgnoreFiles?.global : void 0,
							disregardParentIgnoreFiles:
								typeof t.useIgnoreFiles?.parent == "boolean" ? !t.useIgnoreFiles?.parent : void 0,
							disregardExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings === 1,
							disregardSearchExcludeSettings:
								t.useExcludeSettings !== void 0 && t.useExcludeSettings !== 3,
							fileEncoding: t.encoding,
							maxResults: t.maxResults,
							previewOptions: t.previewOptions
								? {
										matchLines: t.previewOptions?.numMatchLines ?? 100,
										charsPerLine: t.previewOptions?.charsPerLine ?? 1e4,
									}
								: void 0,
							surroundingContext: t.surroundingContext,
							includePattern: f?.pattern,
							excludePattern: h,
						},
						folder: f?.folder,
					}
				},
				a = (t?.include?.map((m) => i(m)) ?? [i(void 0)]).filter((m) => !!m),
				l = new Q(),
				d = l.add(new E()),
				c = this.findTextInFilesBase(e, a, (m, f) => d.fire({ result: m, uri: f }), r)
			return {
				results: new ci(async (m) => {
					l.add(
						d.event((f) => {
							let h = f.result,
								g = f.uri
							Og(h)
								? m.emitOne(
										new cr(
											g,
											h.rangeLocations.map((I) => ({
												previewRange: new pe(
													I.preview.startLineNumber,
													I.preview.startColumn,
													I.preview.endLineNumber,
													I.preview.endColumn,
												),
												sourceRange: new pe(
													I.source.startLineNumber,
													I.source.startColumn,
													I.source.endLineNumber,
													I.source.endColumn,
												),
											})),
											h.previewText,
										),
									)
								: m.emitOne(new Ai(g, h.text, h.lineNumber))
						}),
					),
						await c
				}),
				complete: c.then((m) => (l.dispose(), { limitHit: m?.limitHit ?? !1 })),
			}
		}
		async findTextInFilesBase(e, t, n, r = De.None) {
			let i = this._requestIdProvider.getNext(),
				s = !1
			if (
				(r.onCancellationRequested((a) => {
					s = !0
				}),
				(this._activeSearchCallbacks[i] = (a) => {
					if (s) return
					let l = y.revive(a.resource)
					a.results.forEach((d) => {
						let c = ut(d)
						n(c, l)
					})
				}),
				r.isCancellationRequested)
			)
				return {}
			try {
				let a = await Promise.all(
					t?.map((l) => this._proxy.$startTextSearch(e, l.folder ?? null, l.options, i, r) || {}) ?? [],
				)
				return (
					delete this._activeSearchCallbacks[i],
					a.reduce(
						(l, d) => ({
							limitHit: l?.limitHit || (d?.limitHit ?? !1),
							message: [l?.message ?? [], d?.message ?? []].flat(),
						}),
						{},
					) ?? { limitHit: !1 }
				)
			} catch (a) {
				throw (delete this._activeSearchCallbacks[i], a)
			}
		}
		async findTextInFiles(e, t, n, r, i = De.None) {
			this._logService.trace(
				`extHostWorkspace#findTextInFiles: textSearch, extension: ${r.value}, entryPoint: findTextInFiles`,
			)
			let s = typeof t.previewOptions > "u" ? { matchLines: 100, charsPerLine: 1e4 } : t.previewOptions,
				a = Px(yr.from(t.include)),
				l = typeof t.exclude == "string" ? t.exclude : t.exclude ? t.exclude.pattern : void 0,
				d = {
					ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
					disregardIgnoreFiles: typeof t.useIgnoreFiles == "boolean" ? !t.useIgnoreFiles : void 0,
					disregardGlobalIgnoreFiles:
						typeof t.useGlobalIgnoreFiles == "boolean" ? !t.useGlobalIgnoreFiles : void 0,
					disregardParentIgnoreFiles:
						typeof t.useParentIgnoreFiles == "boolean" ? !t.useParentIgnoreFiles : void 0,
					disregardExcludeSettings: typeof t.useDefaultExcludes == "boolean" ? !t.useDefaultExcludes : !0,
					disregardSearchExcludeSettings: typeof t.useSearchExclude == "boolean" ? !t.useSearchExclude : !0,
					fileEncoding: t.encoding,
					maxResults: t.maxResults,
					previewOptions: s,
					surroundingContext: t.afterContext,
					includePattern: a?.pattern,
					excludePattern: l ? [{ pattern: l }] : void 0,
				},
				c = (u, m) => {
					Og(u)
						? n({
								uri: m,
								preview: {
									text: u.previewText,
									matches: El(
										u.rangeLocations,
										(f) =>
											new pe(
												f.preview.startLineNumber,
												f.preview.startColumn,
												f.preview.endLineNumber,
												f.preview.endColumn,
											),
									),
								},
								ranges: El(
									u.rangeLocations,
									(f) =>
										new pe(
											f.source.startLineNumber,
											f.source.startColumn,
											f.source.endLineNumber,
											f.source.endColumn,
										),
								),
							})
						: n({ uri: m, text: u.text, lineNumber: u.lineNumber })
				}
			return this.findTextInFilesBase(e, [{ options: d, folder: a?.folder }], c, i)
		}
		$handleTextSearchResult(e, t) {
			this._activeSearchCallbacks[t]?.(e)
		}
		async save(e) {
			let t = await this._proxy.$save(e, { saveAs: !1 })
			return y.revive(t)
		}
		async saveAs(e) {
			let t = await this._proxy.$save(e, { saveAs: !0 })
			return y.revive(t)
		}
		saveAll(e) {
			return this._proxy.$saveAll(e)
		}
		resolveProxy(e) {
			return this._proxy.$resolveProxy(e)
		}
		lookupAuthorization(e) {
			return this._proxy.$lookupAuthorization(e)
		}
		lookupKerberosAuthorization(e) {
			return this._proxy.$lookupKerberosAuthorization(e)
		}
		loadCertificates() {
			return this._proxy.$loadCertificates()
		}
		get trusted() {
			return this._trusted
		}
		requestWorkspaceTrust(e) {
			return this._proxy.$requestWorkspaceTrust(e)
		}
		$onDidGrantWorkspaceTrust() {
			this._trusted || ((this._trusted = !0), this._onDidGrantWorkspaceTrust.fire())
		}
		registerEditSessionIdentityProvider(e, t) {
			if (this._editSessionIdentityProviders.has(e))
				throw new Error(`A provider has already been registered for scheme ${e}`)
			this._editSessionIdentityProviders.set(e, t)
			let n = this._uriTransformerService.transformOutgoingScheme(e),
				r = this._providerHandlePool++
			return (
				this._proxy.$registerEditSessionIdentityProvider(r, n),
				q(() => {
					this._editSessionIdentityProviders.delete(e), this._proxy.$unregisterEditSessionIdentityProvider(r)
				})
			)
		}
		async $getEditSessionIdentifier(e, t) {
			this._logService.info("Getting edit session identifier for workspaceFolder", e)
			let n = await this.resolveWorkspaceFolder(y.revive(e))
			if (!n) {
				this._logService.warn("Unable to resolve workspace folder")
				return
			}
			this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", n)
			let r = this._editSessionIdentityProviders.get(n.uri.scheme)
			if ((this._logService.info(`Provider for scheme ${n.uri.scheme} is defined: `, !!r), !r)) return
			let i = await r.provideEditSessionIdentity(n, t)
			if ((this._logService.info("Provider returned edit session identifier: ", i), !!i)) return i
		}
		async $provideEditSessionIdentityMatch(e, t, n, r) {
			this._logService.info("Getting edit session identifier for workspaceFolder", e)
			let i = await this.resolveWorkspaceFolder(y.revive(e))
			if (!i) {
				this._logService.warn("Unable to resolve workspace folder")
				return
			}
			this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", i)
			let s = this._editSessionIdentityProviders.get(i.uri.scheme)
			if ((this._logService.info(`Provider for scheme ${i.uri.scheme} is defined: `, !!s), !s)) return
			let a = await s.provideEditSessionIdentityMatch?.(t, n, r)
			if ((this._logService.info("Provider returned edit session identifier match result: ", a), !!a)) return a
		}
		getOnWillCreateEditSessionIdentityEvent(e) {
			return (t, n, r) => {
				let i = function (a) {
					t.call(n, a)
				}
				return (i.extension = e), this._onWillCreateEditSessionIdentityEvent.event(i, void 0, r)
			}
		}
		async $onWillCreateEditSessionIdentity(e, t, n) {
			let r = await this.resolveWorkspaceFolder(y.revive(e))
			if (r === void 0) throw new Error("Unable to resolve workspace folder")
			await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: r }, t, async (i, s) => {
				let a = Date.now()
				await Promise.resolve(i),
					Date.now() - a > n &&
						this._logService.warn("SLOW edit session create-participant", s.extension.identifier)
			}),
				t.isCancellationRequested
		}
		registerCanonicalUriProvider(e, t) {
			if (this._canonicalUriProviders.has(e))
				throw new Error(`A provider has already been registered for scheme ${e}`)
			this._canonicalUriProviders.set(e, t)
			let n = this._uriTransformerService.transformOutgoingScheme(e),
				r = this._providerHandlePool++
			return (
				this._proxy.$registerCanonicalUriProvider(r, n),
				q(() => {
					this._canonicalUriProviders.delete(e), this._proxy.$unregisterCanonicalUriProvider(r)
				})
			)
		}
		async provideCanonicalUri(e, t, n) {
			let r = this._canonicalUriProviders.get(e.scheme)
			if (!r) return
			let i = await r.provideCanonicalUri?.(y.revive(e), t, n)
			if (i) return i
		}
		async $provideCanonicalUri(e, t, n) {
			return this.provideCanonicalUri(y.revive(e), { targetScheme: t }, n)
		}
		async decode(e, t, n) {
			let r = await this._proxy.$resolveDecoding(t, n),
				i = (
					await OF(YA(z.wrap(e)), {
						...r,
						acceptTextOnly: !0,
						overwriteEncoding: (s) =>
							s === null || s === r.preferredEncoding
								? Promise.resolve(r.preferredEncoding)
								: this._proxy.$validateDetectedEncoding(t, s, n),
					})
				).stream
			return Nv(i, (s) => s.join(""))
		}
		async encode(e, t, n) {
			let { encoding: r, addBOM: i } = await this._proxy.$resolveEncoding(t, n)
			if (r === Ug && !i) return z.fromString(e).buffer
			let s = await LF(HF(e), r, { addBOM: i })
			return JA(s).buffer
		}
	}
sp = R([S(0, ie), S(1, Xe), S(2, uo), S(3, te), S(4, pi)], sp)
var Sn = O("IExtHostWorkspace")
function Px(o) {
	let e, t
	if (o)
		return typeof o == "string" ? (e = o) : ((e = o.pattern), (t = y.revive(o.baseUri))), { pattern: e, folder: t }
}
function WF(o) {
	return (
		o?.map((e) => {
			if (typeof e == "string") return e === "" ? void 0 : { pattern: e, uri: void 0 }
			{
				let t = Px(e)
				return t ? { pattern: t.pattern, uri: t.folder } : void 0
			}
		}) ?? []
	).filter((e) => !!e)
}
var BF
;((e) => (e.DEFAULT = { allowTrailingComma: !0 }))((BF ||= {}))
function X7(o, e = !1) {
	let t = 0,
		n = o.length,
		r = "",
		i = 0,
		s = 16,
		a = 0
	function l(g) {
		let I = 0,
			C = 0
		for (; I < g; ) {
			let T = o.charCodeAt(t)
			if (T >= 48 && T <= 57) C = C * 16 + T - 48
			else if (T >= 65 && T <= 70) C = C * 16 + T - 65 + 10
			else if (T >= 97 && T <= 102) C = C * 16 + T - 97 + 10
			else break
			t++, I++
		}
		return I < g && (C = -1), C
	}
	function d(g) {
		;(t = g), (r = ""), (i = 0), (s = 16), (a = 0)
	}
	function c() {
		let g = t
		if (o.charCodeAt(t) === 48) t++
		else for (t++; t < o.length && ap(o.charCodeAt(t)); ) t++
		if (t < o.length && o.charCodeAt(t) === 46)
			if ((t++, t < o.length && ap(o.charCodeAt(t)))) for (t++; t < o.length && ap(o.charCodeAt(t)); ) t++
			else return (a = 3), o.substring(g, t)
		let I = t
		if (t < o.length && (o.charCodeAt(t) === 69 || o.charCodeAt(t) === 101))
			if (
				(t++,
				((t < o.length && o.charCodeAt(t) === 43) || o.charCodeAt(t) === 45) && t++,
				t < o.length && ap(o.charCodeAt(t)))
			) {
				for (t++; t < o.length && ap(o.charCodeAt(t)); ) t++
				I = t
			} else a = 3
		return o.substring(g, I)
	}
	function u() {
		let g = "",
			I = t
		for (;;) {
			if (t >= n) {
				;(g += o.substring(I, t)), (a = 2)
				break
			}
			let C = o.charCodeAt(t)
			if (C === 34) {
				;(g += o.substring(I, t)), t++
				break
			}
			if (C === 92) {
				if (((g += o.substring(I, t)), t++, t >= n)) {
					a = 2
					break
				}
				switch (o.charCodeAt(t++)) {
					case 34:
						g += '"'
						break
					case 92:
						g += "\\"
						break
					case 47:
						g += "/"
						break
					case 98:
						g += "\b"
						break
					case 102:
						g += "\f"
						break
					case 110:
						g += `
`
						break
					case 114:
						g += "\r"
						break
					case 116:
						g += "	"
						break
					case 117: {
						let w = l(4)
						w >= 0 ? (g += String.fromCharCode(w)) : (a = 4)
						break
					}
					default:
						a = 5
				}
				I = t
				continue
			}
			if (C >= 0 && C <= 31)
				if (_x(C)) {
					;(g += o.substring(I, t)), (a = 2)
					break
				} else a = 6
			t++
		}
		return g
	}
	function m() {
		if (((r = ""), (a = 0), (i = t), t >= n)) return (i = n), (s = 17)
		let g = o.charCodeAt(t)
		if (vk(g)) {
			do t++, (r += String.fromCharCode(g)), (g = o.charCodeAt(t))
			while (vk(g))
			return (s = 15)
		}
		if (_x(g))
			return (
				t++,
				(r += String.fromCharCode(g)),
				g === 13 &&
					o.charCodeAt(t) === 10 &&
					(t++,
					(r += `
`)),
				(s = 14)
			)
		switch (g) {
			case 123:
				return t++, (s = 1)
			case 125:
				return t++, (s = 2)
			case 91:
				return t++, (s = 3)
			case 93:
				return t++, (s = 4)
			case 58:
				return t++, (s = 6)
			case 44:
				return t++, (s = 5)
			case 34:
				return t++, (r = u()), (s = 10)
			case 47: {
				let I = t - 1
				if (o.charCodeAt(t + 1) === 47) {
					for (t += 2; t < n && !_x(o.charCodeAt(t)); ) t++
					return (r = o.substring(I, t)), (s = 12)
				}
				if (o.charCodeAt(t + 1) === 42) {
					t += 2
					let C = n - 1,
						T = !1
					for (; t < C; ) {
						if (o.charCodeAt(t) === 42 && o.charCodeAt(t + 1) === 47) {
							;(t += 2), (T = !0)
							break
						}
						t++
					}
					return T || (t++, (a = 1)), (r = o.substring(I, t)), (s = 13)
				}
				return (r += String.fromCharCode(g)), t++, (s = 16)
			}
			case 45:
				if (((r += String.fromCharCode(g)), t++, t === n || !ap(o.charCodeAt(t)))) return (s = 16)
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				return (r += c()), (s = 11)
			default:
				for (; t < n && f(g); ) t++, (g = o.charCodeAt(t))
				if (i !== t) {
					switch (((r = o.substring(i, t)), r)) {
						case "true":
							return (s = 8)
						case "false":
							return (s = 9)
						case "null":
							return (s = 7)
					}
					return (s = 16)
				}
				return (r += String.fromCharCode(g)), t++, (s = 16)
		}
	}
	function f(g) {
		if (vk(g) || _x(g)) return !1
		switch (g) {
			case 125:
			case 93:
			case 123:
			case 91:
			case 34:
			case 58:
			case 44:
			case 47:
				return !1
		}
		return !0
	}
	function h() {
		let g
		do g = m()
		while (g >= 12 && g <= 15)
		return g
	}
	return {
		setPosition: d,
		getPosition: () => t,
		scan: e ? h : m,
		getToken: () => s,
		getTokenValue: () => r,
		getTokenOffset: () => i,
		getTokenLength: () => t - i,
		getTokenError: () => a,
	}
}
function vk(o) {
	return (
		o === 32 ||
		o === 9 ||
		o === 11 ||
		o === 12 ||
		o === 160 ||
		o === 5760 ||
		(o >= 8192 && o <= 8203) ||
		o === 8239 ||
		o === 8287 ||
		o === 12288 ||
		o === 65279
	)
}
function _x(o) {
	return o === 10 || o === 13 || o === 8232 || o === 8233
}
function ap(o) {
	return o >= 48 && o <= 57
}
function $F(o, e, t = BF.DEFAULT) {
	let n = X7(o, !1)
	function r(Y) {
		return Y ? () => Y(n.getTokenOffset(), n.getTokenLength()) : () => !0
	}
	function i(Y) {
		return Y ? (j) => Y(j, n.getTokenOffset(), n.getTokenLength()) : () => !0
	}
	let s = r(e.onObjectBegin),
		a = i(e.onObjectProperty),
		l = r(e.onObjectEnd),
		d = r(e.onArrayBegin),
		c = r(e.onArrayEnd),
		u = i(e.onLiteralValue),
		m = i(e.onSeparator),
		f = r(e.onComment),
		h = i(e.onError),
		g = t && t.disallowComments,
		I = t && t.allowTrailingComma
	function C() {
		for (;;) {
			let Y = n.scan()
			switch (n.getTokenError()) {
				case 4:
					T(14)
					break
				case 5:
					T(15)
					break
				case 3:
					T(13)
					break
				case 1:
					g || T(11)
					break
				case 2:
					T(12)
					break
				case 6:
					T(16)
					break
			}
			switch (Y) {
				case 12:
				case 13:
					g ? T(10) : f()
					break
				case 16:
					T(1)
					break
				case 15:
				case 14:
					break
				default:
					return Y
			}
		}
	}
	function T(Y, j = [], K = []) {
		if ((h(Y), j.length + K.length > 0)) {
			let qe = n.getToken()
			for (; qe !== 17; ) {
				if (j.indexOf(qe) !== -1) {
					C()
					break
				} else if (K.indexOf(qe) !== -1) break
				qe = C()
			}
		}
	}
	function w(Y) {
		let j = n.getTokenValue()
		return Y ? u(j) : a(j), C(), !0
	}
	function L() {
		switch (n.getToken()) {
			case 11: {
				let Y = 0
				try {
					;(Y = JSON.parse(n.getTokenValue())), typeof Y != "number" && (T(2), (Y = 0))
				} catch {
					T(2)
				}
				u(Y)
				break
			}
			case 7:
				u(null)
				break
			case 8:
				u(!0)
				break
			case 9:
				u(!1)
				break
			default:
				return !1
		}
		return C(), !0
	}
	function A() {
		return n.getToken() !== 10
			? (T(3, [], [2, 5]), !1)
			: (w(!1), n.getToken() === 6 ? (m(":"), C(), oe() || T(4, [], [2, 5])) : T(5, [], [2, 5]), !0)
	}
	function J() {
		s(), C()
		let Y = !1
		for (; n.getToken() !== 2 && n.getToken() !== 17; ) {
			if (n.getToken() === 5) {
				if ((Y || T(4, [], []), m(","), C(), n.getToken() === 2 && I)) break
			} else Y && T(6, [], [])
			A() || T(4, [], [2, 5]), (Y = !0)
		}
		return l(), n.getToken() !== 2 ? T(7, [2], []) : C(), !0
	}
	function ne() {
		d(), C()
		let Y = !1
		for (; n.getToken() !== 4 && n.getToken() !== 17; ) {
			if (n.getToken() === 5) {
				if ((Y || T(4, [], []), m(","), C(), n.getToken() === 4 && I)) break
			} else Y && T(6, [], [])
			oe() || T(4, [], [4, 5]), (Y = !0)
		}
		return c(), n.getToken() !== 4 ? T(8, [4], []) : C(), !0
	}
	function oe() {
		switch (n.getToken()) {
			case 3:
				return ne()
			case 1:
				return J()
			case 10:
				return w(!0)
			default:
				return L()
		}
	}
	return (
		C(),
		n.getToken() === 17
			? t.allowEmptyContent
				? !0
				: (T(4, [], []), !1)
			: oe()
				? (n.getToken() !== 17 && T(9, [], []), !0)
				: (T(4, [], []), !1)
	)
}
function Vg(o) {
	return Object.isFrozen(o) ? o : Jv(o)
}
var nl = class o {
		constructor(e, t, n, r, i) {
			this._contents = e
			this._keys = t
			this._overrides = n
			this.raw = r
			this.logService = i
			this.overrideConfigurations = new Map()
		}
		static createEmptyModel(e) {
			return new o({}, [], [], void 0, e)
		}
		get rawConfiguration() {
			if (!this._rawConfiguration)
				if (this.raw) {
					let e = (Array.isArray(this.raw) ? this.raw : [this.raw]).map((t) => {
						if (t instanceof o) return t
						let n = new bk("", this.logService)
						return n.parseRaw(t), n.configurationModel
					})
					this._rawConfiguration = e.reduce((t, n) => (n === t ? n : t.merge(n)), e[0])
				} else this._rawConfiguration = this
			return this._rawConfiguration
		}
		get contents() {
			return this._contents
		}
		get overrides() {
			return this._overrides
		}
		get keys() {
			return this._keys
		}
		isEmpty() {
			return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0
		}
		getValue(e) {
			return e ? Xf(this.contents, e) : this.contents
		}
		inspect(e, t) {
			let n = this
			return {
				get value() {
					return Vg(n.rawConfiguration.getValue(e))
				},
				get override() {
					return t ? Vg(n.rawConfiguration.getOverrideValue(e, t)) : void 0
				},
				get merged() {
					return Vg(t ? n.rawConfiguration.override(t).getValue(e) : n.rawConfiguration.getValue(e))
				},
				get overrides() {
					let r = []
					for (let { contents: i, identifiers: s, keys: a } of n.rawConfiguration.overrides) {
						let l = new o(i, a, [], void 0, n.logService).getValue(e)
						l !== void 0 && r.push({ identifiers: s, value: l })
					}
					return r.length ? Vg(r) : void 0
				},
			}
		}
		getOverrideValue(e, t) {
			let n = this.getContentsForOverrideIdentifer(t)
			return n ? (e ? Xf(n, e) : n) : void 0
		}
		getKeysForOverrideIdentifier(e) {
			let t = []
			for (let n of this.overrides) n.identifiers.includes(e) && t.push(...n.keys)
			return oi(t)
		}
		getAllOverrideIdentifiers() {
			let e = []
			for (let t of this.overrides) e.push(...t.identifiers)
			return oi(e)
		}
		override(e) {
			let t = this.overrideConfigurations.get(e)
			return t || ((t = this.createOverrideConfigurationModel(e)), this.overrideConfigurations.set(e, t)), t
		}
		merge(...e) {
			let t = je(this.contents),
				n = je(this.overrides),
				r = [...this.keys],
				i = this.raw ? (Array.isArray(this.raw) ? [...this.raw] : [this.raw]) : [this]
			for (let s of e)
				if ((i.push(...(s.raw ? (Array.isArray(s.raw) ? s.raw : [s.raw]) : [s])), !s.isEmpty())) {
					this.mergeContents(t, s.contents)
					for (let a of s.overrides) {
						let [l] = n.filter((d) => mn(d.identifiers, a.identifiers))
						l
							? (this.mergeContents(l.contents, a.contents),
								l.keys.push(...a.keys),
								(l.keys = oi(l.keys)))
							: n.push(je(a))
					}
					for (let a of s.keys) r.indexOf(a) === -1 && r.push(a)
				}
			return new o(t, r, n, !i.length || i.every((s) => s instanceof o) ? void 0 : i, this.logService)
		}
		createOverrideConfigurationModel(e) {
			let t = this.getContentsForOverrideIdentifer(e)
			if (!t || typeof t != "object" || !Object.keys(t).length) return this
			let n = {}
			for (let r of oi([...Object.keys(this.contents), ...Object.keys(t)])) {
				let i = this.contents[r],
					s = t[r]
				s && (typeof i == "object" && typeof s == "object" ? ((i = je(i)), this.mergeContents(i, s)) : (i = s)),
					(n[r] = i)
			}
			return new o(n, this.keys, this.overrides, void 0, this.logService)
		}
		mergeContents(e, t) {
			for (let n of Object.keys(t)) {
				if (n in e && dt(e[n]) && dt(t[n])) {
					this.mergeContents(e[n], t[n])
					continue
				}
				e[n] = je(t[n])
			}
		}
		getContentsForOverrideIdentifer(e) {
			let t = null,
				n = null,
				r = (i) => {
					i && (n ? this.mergeContents(n, i) : (n = je(i)))
				}
			for (let i of this.overrides)
				i.identifiers.length === 1 && i.identifiers[0] === e
					? (t = i.contents)
					: i.identifiers.includes(e) && r(i.contents)
			return r(t), n
		}
		toJSON() {
			return { contents: this.contents, overrides: this.overrides, keys: this.keys }
		}
		addValue(e, t) {
			this.updateValue(e, t, !0)
		}
		setValue(e, t) {
			this.updateValue(e, t, !1)
		}
		removeValue(e) {
			let t = this.keys.indexOf(e)
			t !== -1 &&
				(this.keys.splice(t, 1),
				SM(this.contents, e),
				fo.test(e) &&
					this.overrides.splice(
						this.overrides.findIndex((n) => mn(n.identifiers, eu(e))),
						1,
					))
		}
		updateValue(e, t, n) {
			if (
				(i_(this.contents, e, t, (r) => this.logService.error(r)),
				(n = n || this.keys.indexOf(e) === -1),
				n && this.keys.push(e),
				fo.test(e))
			) {
				let r = eu(e),
					i = {
						identifiers: r,
						keys: Object.keys(this.contents[e]),
						contents: Jb(this.contents[e], (a) => this.logService.error(a)),
					},
					s = this.overrides.findIndex((a) => mn(a.identifiers, r))
				s !== -1 ? (this.overrides[s] = i) : this.overrides.push(i)
			}
		}
	},
	bk = class {
		constructor(e, t) {
			this._name = e
			this.logService = t
			this._raw = null
			this._configurationModel = null
			this._restrictedConfigurations = []
			this._parseErrors = []
		}
		get configurationModel() {
			return this._configurationModel || nl.createEmptyModel(this.logService)
		}
		get restrictedConfigurations() {
			return this._restrictedConfigurations
		}
		get errors() {
			return this._parseErrors
		}
		parse(e, t) {
			if (!bt(e)) {
				let n = this.doParseContent(e)
				this.parseRaw(n, t)
			}
		}
		reparse(e) {
			this._raw && this.parseRaw(this._raw, e)
		}
		parseRaw(e, t) {
			this._raw = e
			let { contents: n, keys: r, overrides: i, restricted: s, hasExcludedProperties: a } = this.doParseRaw(e, t)
			;(this._configurationModel = new nl(n, r, i, a ? [e] : void 0, this.logService)),
				(this._restrictedConfigurations = s || [])
		}
		doParseContent(e) {
			let t = {},
				n = null,
				r = [],
				i = [],
				s = []
			function a(d) {
				Array.isArray(r) ? r.push(d) : n !== null && (r[n] = d)
			}
			let l = {
				onObjectBegin: () => {
					let d = {}
					a(d), i.push(r), (r = d), (n = null)
				},
				onObjectProperty: (d) => {
					n = d
				},
				onObjectEnd: () => {
					r = i.pop()
				},
				onArrayBegin: () => {
					let d = []
					a(d), i.push(r), (r = d), (n = null)
				},
				onArrayEnd: () => {
					r = i.pop()
				},
				onLiteralValue: a,
				onError: (d, c, u) => {
					s.push({ error: d, offset: c, length: u })
				},
			}
			if (e)
				try {
					$F(e, l), (t = r[0] || {})
				} catch (d) {
					this.logService.error(`Error while parsing settings file ${this._name}: ${d}`),
						(this._parseErrors = [d])
				}
			return t
		}
		doParseRaw(e, t) {
			let n = yt.as(go.Configuration).getConfigurationProperties(),
				r = this.filter(e, n, !0, t)
			e = r.raw
			let i = Jb(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)),
				s = Object.keys(e),
				a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`))
			return {
				contents: i,
				keys: s,
				overrides: a,
				restricted: r.restricted,
				hasExcludedProperties: r.hasExcludedProperties,
			}
		}
		filter(e, t, n, r) {
			let i = !1
			if (!r?.scopes && !r?.skipRestricted && !r?.exclude?.length)
				return { raw: e, restricted: [], hasExcludedProperties: i }
			let s = {},
				a = []
			for (let l in e)
				if (fo.test(l) && n) {
					let d = this.filter(e[l], t, !1, r)
					;(s[l] = d.raw), (i = i || d.hasExcludedProperties), a.push(...d.restricted)
				} else {
					let d = t[l]
					d?.restricted && a.push(l), this.shouldInclude(l, d, r) ? (s[l] = e[l]) : (i = !0)
				}
			return { raw: s, restricted: a, hasExcludedProperties: i }
		}
		shouldInclude(e, t, n) {
			if (n.exclude?.includes(e)) return !1
			if (n.include?.includes(e)) return !0
			if ((n.skipRestricted && t?.restricted) || (n.skipUnregistered && !t)) return !1
			let r = t ? (typeof t.scope < "u" ? t.scope : 4) : void 0
			return r === void 0 || n.scopes === void 0 ? !0 : n.scopes.includes(r)
		}
		toOverrides(e, t) {
			let n = []
			for (let r of Object.keys(e))
				if (fo.test(r)) {
					let i = {}
					for (let s in e[r]) i[s] = e[r][s]
					n.push({ identifiers: eu(r), keys: Object.keys(i), contents: Jb(i, t) })
				}
			return n
		}
	}
var yk = class {
		constructor(e, t, n, r, i, s, a, l, d, c, u, m, f) {
			this.key = e
			this.overrides = t
			this._value = n
			this.overrideIdentifiers = r
			this.defaultConfiguration = i
			this.policyConfiguration = s
			this.applicationConfiguration = a
			this.userConfiguration = l
			this.localUserConfiguration = d
			this.remoteUserConfiguration = c
			this.workspaceConfiguration = u
			this.folderConfigurationModel = m
			this.memoryConfigurationModel = f
		}
		get value() {
			return Vg(this._value)
		}
		toInspectValue(e) {
			return e?.value !== void 0 || e?.override !== void 0 || e?.overrides !== void 0 ? e : void 0
		}
		get defaultInspectValue() {
			return (
				this._defaultInspectValue ||
					(this._defaultInspectValue = this.defaultConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._defaultInspectValue
			)
		}
		get defaultValue() {
			return this.defaultInspectValue.merged
		}
		get default() {
			return this.toInspectValue(this.defaultInspectValue)
		}
		get policyInspectValue() {
			return (
				this._policyInspectValue === void 0 &&
					(this._policyInspectValue = this.policyConfiguration
						? this.policyConfiguration.inspect(this.key)
						: null),
				this._policyInspectValue
			)
		}
		get policyValue() {
			return this.policyInspectValue?.merged
		}
		get policy() {
			return this.policyInspectValue?.value !== void 0 ? { value: this.policyInspectValue.value } : void 0
		}
		get applicationInspectValue() {
			return (
				this._applicationInspectValue === void 0 &&
					(this._applicationInspectValue = this.applicationConfiguration
						? this.applicationConfiguration.inspect(this.key)
						: null),
				this._applicationInspectValue
			)
		}
		get applicationValue() {
			return this.applicationInspectValue?.merged
		}
		get application() {
			return this.toInspectValue(this.applicationInspectValue)
		}
		get userInspectValue() {
			return (
				this._userInspectValue ||
					(this._userInspectValue = this.userConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userInspectValue
			)
		}
		get userValue() {
			return this.userInspectValue.merged
		}
		get user() {
			return this.toInspectValue(this.userInspectValue)
		}
		get userLocalInspectValue() {
			return (
				this._userLocalInspectValue ||
					(this._userLocalInspectValue = this.localUserConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userLocalInspectValue
			)
		}
		get userLocalValue() {
			return this.userLocalInspectValue.merged
		}
		get userLocal() {
			return this.toInspectValue(this.userLocalInspectValue)
		}
		get userRemoteInspectValue() {
			return (
				this._userRemoteInspectValue ||
					(this._userRemoteInspectValue = this.remoteUserConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userRemoteInspectValue
			)
		}
		get userRemoteValue() {
			return this.userRemoteInspectValue.merged
		}
		get userRemote() {
			return this.toInspectValue(this.userRemoteInspectValue)
		}
		get workspaceInspectValue() {
			return (
				this._workspaceInspectValue === void 0 &&
					(this._workspaceInspectValue = this.workspaceConfiguration
						? this.workspaceConfiguration.inspect(this.key, this.overrides.overrideIdentifier)
						: null),
				this._workspaceInspectValue
			)
		}
		get workspaceValue() {
			return this.workspaceInspectValue?.merged
		}
		get workspace() {
			return this.toInspectValue(this.workspaceInspectValue)
		}
		get workspaceFolderInspectValue() {
			return (
				this._workspaceFolderInspectValue === void 0 &&
					(this._workspaceFolderInspectValue = this.folderConfigurationModel
						? this.folderConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier)
						: null),
				this._workspaceFolderInspectValue
			)
		}
		get workspaceFolderValue() {
			return this.workspaceFolderInspectValue?.merged
		}
		get workspaceFolder() {
			return this.toInspectValue(this.workspaceFolderInspectValue)
		}
		get memoryInspectValue() {
			return (
				this._memoryInspectValue === void 0 &&
					(this._memoryInspectValue = this.memoryConfigurationModel.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._memoryInspectValue
			)
		}
		get memoryValue() {
			return this.memoryInspectValue.merged
		}
		get memory() {
			return this.toInspectValue(this.memoryInspectValue)
		}
	},
	lp = class o {
		constructor(e, t, n, r, i, s, a, l, d, c) {
			this._defaultConfiguration = e
			this._policyConfiguration = t
			this._applicationConfiguration = n
			this._localUserConfiguration = r
			this._remoteUserConfiguration = i
			this._workspaceConfiguration = s
			this._folderConfigurations = a
			this._memoryConfiguration = l
			this._memoryConfigurationByResource = d
			this.logService = c
			this._workspaceConsolidatedConfiguration = null
			this._foldersConsolidatedConfigurations = new ft()
			this._userConfiguration = null
		}
		getValue(e, t, n) {
			return this.getConsolidatedConfigurationModel(e, t, n).getValue(e)
		}
		updateValue(e, t, n = {}) {
			let r
			n.resource
				? ((r = this._memoryConfigurationByResource.get(n.resource)),
					r ||
						((r = nl.createEmptyModel(this.logService)),
						this._memoryConfigurationByResource.set(n.resource, r)))
				: (r = this._memoryConfiguration),
				t === void 0 ? r.removeValue(e) : r.setValue(e, t),
				n.resource || (this._workspaceConsolidatedConfiguration = null)
		}
		inspect(e, t, n) {
			let r = this.getConsolidatedConfigurationModel(e, t, n),
				i = this.getFolderConfigurationModelForResource(t.resource, n),
				s = t.resource
					? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration
					: this._memoryConfiguration,
				a = new Set()
			for (let l of r.overrides) for (let d of l.identifiers) r.getOverrideValue(e, d) !== void 0 && a.add(d)
			return new yk(
				e,
				t,
				r.getValue(e),
				a.size ? [...a] : void 0,
				this._defaultConfiguration,
				this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration,
				this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration,
				this.userConfiguration,
				this.localUserConfiguration,
				this.remoteUserConfiguration,
				n ? this._workspaceConfiguration : void 0,
				i || void 0,
				s,
			)
		}
		keys(e) {
			let t = this.getFolderConfigurationModelForResource(void 0, e)
			return {
				default: this._defaultConfiguration.keys.slice(0),
				user: this.userConfiguration.keys.slice(0),
				workspace: this._workspaceConfiguration.keys.slice(0),
				workspaceFolder: t ? t.keys.slice(0) : [],
			}
		}
		updateDefaultConfiguration(e) {
			;(this._defaultConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updatePolicyConfiguration(e) {
			this._policyConfiguration = e
		}
		updateApplicationConfiguration(e) {
			;(this._applicationConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateLocalUserConfiguration(e) {
			;(this._localUserConfiguration = e),
				(this._userConfiguration = null),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateRemoteUserConfiguration(e) {
			;(this._remoteUserConfiguration = e),
				(this._userConfiguration = null),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateWorkspaceConfiguration(e) {
			;(this._workspaceConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateFolderConfiguration(e, t) {
			this._folderConfigurations.set(e, t), this._foldersConsolidatedConfigurations.delete(e)
		}
		deleteFolderConfiguration(e) {
			this.folderConfigurations.delete(e), this._foldersConsolidatedConfigurations.delete(e)
		}
		compareAndUpdateDefaultConfiguration(e, t) {
			let n = []
			if (!t) {
				let { added: r, updated: i, removed: s } = tl(this._defaultConfiguration, e)
				t = [...r, ...i, ...s]
			}
			for (let r of t)
				for (let i of eu(r)) {
					let s = this._defaultConfiguration.getKeysForOverrideIdentifier(i),
						a = e.getKeysForOverrideIdentifier(i),
						l = [
							...a.filter((d) => s.indexOf(d) === -1),
							...s.filter((d) => a.indexOf(d) === -1),
							...s.filter(
								(d) =>
									!nn(this._defaultConfiguration.override(i).getValue(d), e.override(i).getValue(d)),
							),
						]
					n.push([i, l])
				}
			return this.updateDefaultConfiguration(e), { keys: t, overrides: n }
		}
		compareAndUpdatePolicyConfiguration(e) {
			let { added: t, updated: n, removed: r } = tl(this._policyConfiguration, e),
				i = [...t, ...n, ...r]
			return i.length && this.updatePolicyConfiguration(e), { keys: i, overrides: [] }
		}
		compareAndUpdateApplicationConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = tl(this.applicationConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateApplicationConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateLocalUserConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = tl(this.localUserConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateLocalUserConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateRemoteUserConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = tl(this.remoteUserConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateRemoteUserConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateWorkspaceConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = tl(this.workspaceConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateWorkspaceConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateFolderConfiguration(e, t) {
			let n = this.folderConfigurations.get(e),
				{ added: r, updated: i, removed: s, overrides: a } = tl(n, t),
				l = [...r, ...i, ...s]
			return (l.length || !n) && this.updateFolderConfiguration(e, t), { keys: l, overrides: a }
		}
		compareAndDeleteFolderConfiguration(e) {
			let t = this.folderConfigurations.get(e)
			if (!t) throw new Error("Unknown folder")
			this.deleteFolderConfiguration(e)
			let { added: n, updated: r, removed: i, overrides: s } = tl(t, void 0)
			return { keys: [...n, ...r, ...i], overrides: s }
		}
		get defaults() {
			return this._defaultConfiguration
		}
		get applicationConfiguration() {
			return this._applicationConfiguration
		}
		get userConfiguration() {
			if (!this._userConfiguration)
				if (this._remoteUserConfiguration.isEmpty()) this._userConfiguration = this._localUserConfiguration
				else {
					let e = this._localUserConfiguration.merge(this._remoteUserConfiguration)
					this._userConfiguration = new nl(e.contents, e.keys, e.overrides, void 0, this.logService)
				}
			return this._userConfiguration
		}
		get localUserConfiguration() {
			return this._localUserConfiguration
		}
		get remoteUserConfiguration() {
			return this._remoteUserConfiguration
		}
		get workspaceConfiguration() {
			return this._workspaceConfiguration
		}
		get folderConfigurations() {
			return this._folderConfigurations
		}
		getConsolidatedConfigurationModel(e, t, n) {
			let r = this.getConsolidatedConfigurationModelForResource(t, n)
			if (
				(t.overrideIdentifier && (r = r.override(t.overrideIdentifier)),
				!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0)
			) {
				r = r.merge()
				for (let i of this._policyConfiguration.keys) r.setValue(i, this._policyConfiguration.getValue(i))
			}
			return r
		}
		getConsolidatedConfigurationModelForResource({ resource: e }, t) {
			let n = this.getWorkspaceConsolidatedConfiguration()
			if (t && e) {
				let r = t.getFolder(e)
				r && (n = this.getFolderConsolidatedConfiguration(r.uri) || n)
				let i = this._memoryConfigurationByResource.get(e)
				i && (n = n.merge(i))
			}
			return n
		}
		getWorkspaceConsolidatedConfiguration() {
			return (
				this._workspaceConsolidatedConfiguration ||
					(this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(
						this.applicationConfiguration,
						this.userConfiguration,
						this._workspaceConfiguration,
						this._memoryConfiguration,
					)),
				this._workspaceConsolidatedConfiguration
			)
		}
		getFolderConsolidatedConfiguration(e) {
			let t = this._foldersConsolidatedConfigurations.get(e)
			if (!t) {
				let n = this.getWorkspaceConsolidatedConfiguration(),
					r = this._folderConfigurations.get(e)
				r ? ((t = n.merge(r)), this._foldersConsolidatedConfigurations.set(e, t)) : (t = n)
			}
			return t
		}
		getFolderConfigurationModelForResource(e, t) {
			if (t && e) {
				let n = t.getFolder(e)
				if (n) return this._folderConfigurations.get(n.uri)
			}
		}
		toData() {
			return {
				defaults: {
					contents: this._defaultConfiguration.contents,
					overrides: this._defaultConfiguration.overrides,
					keys: this._defaultConfiguration.keys,
				},
				policy: {
					contents: this._policyConfiguration.contents,
					overrides: this._policyConfiguration.overrides,
					keys: this._policyConfiguration.keys,
				},
				application: {
					contents: this.applicationConfiguration.contents,
					overrides: this.applicationConfiguration.overrides,
					keys: this.applicationConfiguration.keys,
					raw: Array.isArray(this.applicationConfiguration.raw) ? void 0 : this.applicationConfiguration.raw,
				},
				userLocal: {
					contents: this.localUserConfiguration.contents,
					overrides: this.localUserConfiguration.overrides,
					keys: this.localUserConfiguration.keys,
					raw: Array.isArray(this.localUserConfiguration.raw) ? void 0 : this.localUserConfiguration.raw,
				},
				userRemote: {
					contents: this.remoteUserConfiguration.contents,
					overrides: this.remoteUserConfiguration.overrides,
					keys: this.remoteUserConfiguration.keys,
					raw: Array.isArray(this.remoteUserConfiguration.raw) ? void 0 : this.remoteUserConfiguration.raw,
				},
				workspace: {
					contents: this._workspaceConfiguration.contents,
					overrides: this._workspaceConfiguration.overrides,
					keys: this._workspaceConfiguration.keys,
				},
				folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
					let { contents: n, overrides: r, keys: i } = this._folderConfigurations.get(t)
					return e.push([t, { contents: n, overrides: r, keys: i }]), e
				}, []),
			}
		}
		allKeys() {
			let e = new Set()
			return (
				this._defaultConfiguration.keys.forEach((t) => e.add(t)),
				this.userConfiguration.keys.forEach((t) => e.add(t)),
				this._workspaceConfiguration.keys.forEach((t) => e.add(t)),
				this._folderConfigurations.forEach((t) => t.keys.forEach((n) => e.add(n))),
				[...e.values()]
			)
		}
		allOverrideIdentifiers() {
			let e = new Set()
			return (
				this._defaultConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this.userConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this._workspaceConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this._folderConfigurations.forEach((t) => t.getAllOverrideIdentifiers().forEach((n) => e.add(n))),
				[...e.values()]
			)
		}
		getAllKeysForOverrideIdentifier(e) {
			let t = new Set()
			return (
				this._defaultConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this.userConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this._workspaceConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this._folderConfigurations.forEach((n) => n.getKeysForOverrideIdentifier(e).forEach((r) => t.add(r))),
				[...t.values()]
			)
		}
		static parse(e, t) {
			let n = this.parseConfigurationModel(e.defaults, t),
				r = this.parseConfigurationModel(e.policy, t),
				i = this.parseConfigurationModel(e.application, t),
				s = this.parseConfigurationModel(e.userLocal, t),
				a = this.parseConfigurationModel(e.userRemote, t),
				l = this.parseConfigurationModel(e.workspace, t),
				d = e.folders.reduce(
					(c, u) => (c.set(y.revive(u[0]), this.parseConfigurationModel(u[1], t)), c),
					new ft(),
				)
			return new o(n, r, i, s, a, l, d, nl.createEmptyModel(t), new ft(), t)
		}
		static parseConfigurationModel(e, t) {
			return new nl(e.contents, e.keys, e.overrides, e.raw, t)
		}
	}
var Dx = class {
	constructor(e, t, n, r, i) {
		this.change = e
		this.previous = t
		this.currentConfiguraiton = n
		this.currentWorkspace = r
		this.logService = i
		this._marker = `
`
		this._markerCode1 = this._marker.charCodeAt(0)
		this._markerCode2 = 46
		this.affectedKeys = new Set()
		this._previousConfiguration = void 0
		for (let s of e.keys) this.affectedKeys.add(s)
		for (let [, s] of e.overrides) for (let a of s) this.affectedKeys.add(a)
		this._affectsConfigStr = this._marker
		for (let s of this.affectedKeys) this._affectsConfigStr += s + this._marker
	}
	get previousConfiguration() {
		return (
			!this._previousConfiguration &&
				this.previous &&
				(this._previousConfiguration = lp.parse(this.previous.data, this.logService)),
			this._previousConfiguration
		)
	}
	affectsConfiguration(e, t) {
		let n = this._marker + e,
			r = this._affectsConfigStr.indexOf(n)
		if (r < 0) return !1
		let i = r + n.length
		if (i >= this._affectsConfigStr.length) return !1
		let s = this._affectsConfigStr.charCodeAt(i)
		if (s !== this._markerCode1 && s !== this._markerCode2) return !1
		if (t) {
			let a = this.previousConfiguration
					? this.previousConfiguration.getValue(e, t, this.previous?.workspace)
					: void 0,
				l = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace)
			return !nn(a, l)
		}
		return !0
	}
}
function tl(o, e) {
	let { added: t, removed: n, updated: r } = zF(e?.rawConfiguration, o?.rawConfiguration),
		i = [],
		s = o?.getAllOverrideIdentifiers() || [],
		a = e?.getAllOverrideIdentifiers() || []
	if (e) {
		let l = a.filter((d) => !s.includes(d))
		for (let d of l) i.push([d, e.getKeysForOverrideIdentifier(d)])
	}
	if (o) {
		let l = s.filter((d) => !a.includes(d))
		for (let d of l) i.push([d, o.getKeysForOverrideIdentifier(d)])
	}
	if (e && o) {
		for (let l of s)
			if (a.includes(l)) {
				let d = zF(
					{ contents: o.getOverrideValue(void 0, l) || {}, keys: o.getKeysForOverrideIdentifier(l) },
					{ contents: e.getOverrideValue(void 0, l) || {}, keys: e.getKeysForOverrideIdentifier(l) },
				)
				i.push([l, [...d.added, ...d.removed, ...d.updated]])
			}
	}
	return { added: t, removed: n, updated: r, overrides: i }
}
function zF(o, e) {
	let t = o ? (e ? o.keys.filter((i) => e.keys.indexOf(i) === -1) : [...o.keys]) : [],
		n = e ? (o ? e.keys.filter((i) => o.keys.indexOf(i) === -1) : [...e.keys]) : [],
		r = []
	if (o && e) {
		for (let i of e.keys)
			if (o.keys.indexOf(i) !== -1) {
				let s = Xf(e.contents, i),
					a = Xf(o.contents, i)
				nn(s, a) || r.push(i)
			}
	}
	return { added: t, removed: n, updated: r }
}
function kx(o, e) {
	if (e) {
		let t = e.split("."),
			n = o
		for (let r = 0; n && r < t.length; r++) n = n[t[r]]
		return n
	}
}
function e8(o) {
	return o instanceof y
}
function t8(o) {
	return o && o.uri instanceof y && o.languageId && typeof o.languageId == "string"
}
function n8(o) {
	return o && !o.uri && o.languageId && typeof o.languageId == "string"
}
function r8(o) {
	return o && o.uri instanceof y && (!o.name || typeof o.name == "string") && (!o.index || typeof o.index == "number")
}
function qF(o) {
	if (e8(o)) return { resource: o }
	if (t8(o)) return { resource: o.uri, overrideIdentifier: o.languageId }
	if (n8(o)) return { overrideIdentifier: o.languageId }
	if (r8(o)) return { resource: o.uri }
	if (o === null) return { resource: null }
}
var dp = class {
	constructor(e, t, n) {
		;(this._proxy = e.getProxy(N.MainThreadConfiguration)),
			(this._extHostWorkspace = t),
			(this._logService = n),
			(this._barrier = new dn()),
			(this._actual = null)
	}
	getConfigProvider() {
		return this._barrier.wait().then((e) => this._actual)
	}
	$initializeConfiguration(e) {
		;(this._actual = new Ik(this._proxy, this._extHostWorkspace, e, this._logService)), this._barrier.open()
	}
	$acceptConfigurationChanged(e, t) {
		this.getConfigProvider().then((n) => n.$acceptConfigurationChanged(e, t))
	}
}
dp = R([S(0, ie), S(1, Sn), S(2, te)], dp)
var Ik = class {
		constructor(e, t, n, r) {
			this._onDidChangeConfiguration = new E()
			;(this._proxy = e),
				(this._logService = r),
				(this._extHostWorkspace = t),
				(this._configuration = lp.parse(n, r)),
				(this._configurationScopes = this._toMap(n.configurationScopes))
		}
		get onDidChangeConfiguration() {
			return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event
		}
		$acceptConfigurationChanged(e, t) {
			let n = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace }
			;(this._configuration = lp.parse(e, this._logService)),
				(this._configurationScopes = this._toMap(e.configurationScopes)),
				this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(t, n))
		}
		getConfiguration(e, t, n) {
			console.log("getConfiguration", e, t, n)
			let r = qF(t) || {},
				i = this._toReadonlyValue(this._configuration.getValue(e, r, this._extHostWorkspace.workspace))
			e && this._validateConfigurationAccess(e, r, n?.identifier)
			function s(l) {
				if (l == null) return null
				if (typeof l == "boolean") return l ? 2 : 5
				switch (l) {
					case 1:
						return 2
					case 2:
						return 5
					case 3:
						return 6
				}
			}
			let a = {
				has(l) {
					return typeof kx(i, l) < "u"
				},
				get: (l, d) => {
					this._validateConfigurationAccess(e ? `${e}.${l}` : l, r, n?.identifier)
					let c = kx(i, l)
					if (typeof c > "u") c = d
					else {
						let u,
							m = (f, h) => {
								if (dt(f)) {
									let g,
										I = () => {
											;(u = u || je(i)), (g = g || kx(u, h))
										}
									return new Proxy(f, {
										get: (C, T) => {
											if (typeof T == "string" && T.toLowerCase() === "tojson")
												return I(), () => g
											if (u) return (g = g || kx(u, h)), g[T]
											let w = C[T]
											return typeof T == "string" ? m(w, `${h}.${T}`) : w
										},
										set: (C, T, w) => (I(), g && (g[T] = w), !0),
										deleteProperty: (C, T) => (I(), g && delete g[T], !0),
										defineProperty: (C, T, w) => (I(), g && Object.defineProperty(g, T, w), !0),
									})
								}
								return Array.isArray(f) ? je(f) : f
							}
						c = m(c, l)
					}
					return c
				},
				update: (l, d, c, u) => {
					l = e ? `${e}.${l}` : l
					let m = s(c)
					return d !== void 0
						? this._proxy.$updateConfigurationOption(m, l, d, r, u)
						: this._proxy.$removeConfigurationOption(m, l, r, u)
				},
				inspect: (l) => {
					l = e ? `${e}.${l}` : l
					let d = this._configuration.inspect(l, r, this._extHostWorkspace.workspace)
					if (d)
						return {
							key: l,
							defaultValue: je(d.policy?.value ?? d.default?.value),
							globalLocalValue: je(d.userLocal?.value),
							globalRemoteValue: je(d.userRemote?.value),
							globalValue: je(d.user?.value ?? d.application?.value),
							workspaceValue: je(d.workspace?.value),
							workspaceFolderValue: je(d.workspaceFolder?.value),
							defaultLanguageValue: je(d.default?.override),
							globalLocalLanguageValue: je(d.userLocal?.override),
							globalRemoteLanguageValue: je(d.userRemote?.override),
							globalLanguageValue: je(d.user?.override ?? d.application?.override),
							workspaceLanguageValue: je(d.workspace?.override),
							workspaceFolderLanguageValue: je(d.workspaceFolder?.override),
							languageIds: je(d.overrideIdentifiers),
						}
				},
			}
			return typeof i == "object" && fr(a, i, !1), Object.freeze(a)
		}
		_toReadonlyValue(e) {
			let t = (n) =>
				dt(n)
					? new Proxy(n, {
							get: (r, i) => t(r[i]),
							set: (r, i, s) => {
								throw new Error(
									`TypeError: Cannot assign to read only property '${String(i)}' of object`,
								)
							},
							deleteProperty: (r, i) => {
								throw new Error(`TypeError: Cannot delete read only property '${String(i)}' of object`)
							},
							defineProperty: (r, i) => {
								throw new Error(
									`TypeError: Cannot define property '${String(i)}' for a readonly object`,
								)
							},
							setPrototypeOf: (r) => {
								throw new Error("TypeError: Cannot set prototype for a readonly object")
							},
							isExtensible: () => !1,
							preventExtensions: () => !0,
						})
					: n
			return t(e)
		}
		_validateConfigurationAccess(e, t, n) {
			let r = fo.test(e) ? 5 : this._configurationScopes.get(e),
				i = n ? `[${n.value}] ` : ""
			if (5 === r) {
				typeof t?.resource > "u" &&
					this._logService.warn(
						`${i}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${e}', provide the URI of a resource or 'null' for any resource.`,
					)
				return
			}
			if (4 === r) {
				t?.resource &&
					this._logService.warn(
						`${i}Accessing a window scoped configuration for a resource is not expected. To associate '${e}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`,
					)
				return
			}
		}
		_toConfigurationChangeEvent(e, t) {
			let n = new Dx(e, t, this._configuration, this._extHostWorkspace.workspace, this._logService)
			return Object.freeze({ affectsConfiguration: (r, i) => n.affectsConfiguration(r, qF(i)) })
		}
		_toMap(e) {
			return e.reduce((t, n) => (t.set(n[0], n[1]), t), new Map())
		}
	},
	pn = O("IExtHostConfiguration")
var xk = class {
		constructor(e, t) {
			this.versionId = e
			this.removedDueToLooping = t
		}
	},
	Ws = class o {
		constructor(e, t) {
			this._activationEventsReader = e
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this._versionId = 0
			;(this._extensionDescriptions = t), this._initialize()
		}
		static isHostExtension(e, t, n) {
			if (t.getExtensionDescription(e)) return !1
			let r = n.getExtensionDescription(e)
			return r ? !!((r.main || r.browser) && r.api === "none") : !1
		}
		_initialize() {
			this._extensionDescriptions.sort(o8),
				(this._extensionsMap = new On()),
				(this._extensionsArr = []),
				(this._activationMap = new Map())
			for (let e of this._extensionDescriptions) {
				if (this._extensionsMap.has(e.identifier)) {
					console.error("Extension `" + e.identifier.value + "` is already registered")
					continue
				}
				this._extensionsMap.set(e.identifier, e), this._extensionsArr.push(e)
				let t = this._activationEventsReader.readActivationEvents(e)
				for (let n of t)
					this._activationMap.has(n) || this._activationMap.set(n, []), this._activationMap.get(n).push(e)
			}
		}
		set(e) {
			return (
				(this._extensionDescriptions = e),
				this._initialize(),
				this._versionId++,
				this._onDidChange.fire(void 0),
				{ versionId: this._versionId }
			)
		}
		deltaExtensions(e, t) {
			;(this._extensionDescriptions = jF(this._extensionDescriptions, t)),
				(this._extensionDescriptions = this._extensionDescriptions.concat(e))
			let n = o._findLoopingExtensions(this._extensionDescriptions)
			return (
				(this._extensionDescriptions = jF(
					this._extensionDescriptions,
					n.map((r) => r.identifier),
				)),
				this._initialize(),
				this._versionId++,
				this._onDidChange.fire(void 0),
				new xk(this._versionId, n)
			)
		}
		static _findLoopingExtensions(e) {
			let t = new (class {
					constructor() {
						this._arcs = new Map()
						this._nodesSet = new Set()
						this._nodesArr = []
					}
					addNode(a) {
						this._nodesSet.has(a) || (this._nodesSet.add(a), this._nodesArr.push(a))
					}
					addArc(a, l) {
						this.addNode(a),
							this.addNode(l),
							this._arcs.has(a) ? this._arcs.get(a).push(l) : this._arcs.set(a, [l])
					}
					getArcs(a) {
						return this._arcs.has(a) ? this._arcs.get(a) : []
					}
					hasOnlyGoodArcs(a, l) {
						let d = t.getArcs(a)
						for (let c = 0; c < d.length; c++) if (!l.has(d[c])) return !1
						return !0
					}
					getNodes() {
						return this._nodesArr
					}
				})(),
				n = new On()
			for (let a of e)
				if ((n.set(a.identifier, a), a.extensionDependencies))
					for (let l of a.extensionDependencies) t.addArc(we.toKey(a.identifier), we.toKey(l))
			let r = new Set()
			t.getNodes()
				.filter((a) => t.getArcs(a).length === 0)
				.forEach((a) => r.add(a))
			let i = t.getNodes().filter((a) => !r.has(a)),
				s
			do {
				s = !1
				for (let a = 0; a < i.length; a++) {
					let l = i[a]
					t.hasOnlyGoodArcs(l, r) && (i.splice(a, 1), a--, r.add(l), (s = !0))
				}
			} while (s)
			return i.map((a) => n.get(a))
		}
		containsActivationEvent(e) {
			return this._activationMap.has(e)
		}
		containsExtension(e) {
			return this._extensionsMap.has(e)
		}
		getExtensionDescriptionsForActivationEvent(e) {
			let t = this._activationMap.get(e)
			return t ? t.slice(0) : []
		}
		getAllExtensionDescriptions() {
			return this._extensionsArr.slice(0)
		}
		getSnapshot() {
			return new Ck(this._versionId, this.getAllExtensionDescriptions())
		}
		getExtensionDescription(e) {
			let t = this._extensionsMap.get(e)
			return t || void 0
		}
		getExtensionDescriptionByUUID(e) {
			for (let t of this._extensionsArr) if (t.uuid === e) return t
		}
		getExtensionDescriptionByIdOrUUID(e, t) {
			return this.getExtensionDescription(e) ?? (t ? this.getExtensionDescriptionByUUID(t) : void 0)
		}
	},
	Ck = class {
		constructor(e, t) {
			this.versionId = e
			this.extensions = t
		}
	}
function o8(o, e) {
	let t = o.isBuiltin ? 0 : o.isUnderDevelopment ? 2 : 1,
		n = e.isBuiltin ? 0 : e.isUnderDevelopment ? 2 : 1
	if (t !== n) return t - n
	let r = Ue.basename(o.extensionLocation.path),
		i = Ue.basename(e.extensionLocation.path)
	return r < i ? -1 : r > i ? 1 : 0
}
function jF(o, e) {
	let t = new sr(e)
	return o.filter((n) => !t.has(n.identifier))
}
var Ad = class o {
		static {
			this.NONE = new o(!1, -1, -1, -1)
		}
		constructor(e, t, n, r) {
			;(this.startup = e),
				(this.codeLoadingTime = t),
				(this.activateCallTime = n),
				(this.activateResolvedTime = r)
		}
	},
	up = class {
		constructor(e) {
			;(this._startup = e),
				(this._codeLoadingStart = -1),
				(this._codeLoadingStop = -1),
				(this._activateCallStart = -1),
				(this._activateCallStop = -1),
				(this._activateResolveStart = -1),
				(this._activateResolveStop = -1)
		}
		_delta(e, t) {
			return e === -1 || t === -1 ? -1 : t - e
		}
		build() {
			return new Ad(
				this._startup,
				this._delta(this._codeLoadingStart, this._codeLoadingStop),
				this._delta(this._activateCallStart, this._activateCallStop),
				this._delta(this._activateResolveStart, this._activateResolveStop),
			)
		}
		codeLoadingStart() {
			this._codeLoadingStart = Date.now()
		}
		codeLoadingStop() {
			this._codeLoadingStop = Date.now()
		}
		activateCallStart() {
			this._activateCallStart = Date.now()
		}
		activateCallStop() {
			this._activateCallStop = Date.now()
		}
		activateResolveStart() {
			this._activateResolveStart = Date.now()
		}
		activateResolveStop() {
			this._activateResolveStop = Date.now()
		}
	},
	Od = class {
		constructor(e, t, n, r, i, s) {
			;(this.activationFailed = e),
				(this.activationFailedError = t),
				(this.activationTimes = n),
				(this.module = r),
				(this.exports = i),
				(this.disposable = s)
		}
	},
	Rx = class extends Od {
		constructor(e) {
			super(!1, null, e, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	Ax = class extends Od {
		constructor() {
			super(!1, null, Ad.NONE, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	pp = class extends Od {
		constructor(e) {
			super(!0, e, Ad.NONE, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	cp = class {
		constructor(e, t, n, r) {
			this._logService = r
			;(this._registry = e),
				(this._globalRegistry = t),
				(this._host = n),
				(this._operations = new On()),
				(this._alreadyActivatedEvents = Object.create(null))
		}
		dispose() {
			for (let [e, t] of this._operations) t.dispose()
		}
		async waitForActivatingExtensions() {
			let e = []
			for (let [t, n] of this._operations) e.push(n.wait())
			await Promise.all(e)
		}
		isActivated(e) {
			let t = this._operations.get(e)
			return !!(t && t.value)
		}
		getActivatedExtension(e) {
			let t = this._operations.get(e)
			if (!t || !t.value) throw new Error(`Extension '${e.value}' is not known or not activated`)
			return t.value
		}
		async activateByEvent(e, t) {
			if (this._alreadyActivatedEvents[e]) return
			let n = this._registry.getExtensionDescriptionsForActivationEvent(e)
			await this._activateExtensions(
				n.map((r) => ({
					id: r.identifier,
					reason: { startup: t, extensionId: r.identifier, activationEvent: e },
				})),
			),
				(this._alreadyActivatedEvents[e] = !0)
		}
		activateById(e, t) {
			gt.logIncoming(0, 0, 0, "activateById start: " + e.value)
			let n = this._registry.getExtensionDescription(e)
			if ((gt.logIncoming(0, 0, 0, "activateById desc: " + n), !n))
				throw new Error(`Extension '${e.value}' is not known`)
			return this._activateExtensions([{ id: n.identifier, reason: t }])
		}
		async _activateExtensions(e) {
			let t = e.filter((n) => !this.isActivated(n.id)).map((n) => this._handleActivationRequest(n))
			await Promise.all(t.map((n) => n.wait()))
		}
		_handleActivationRequest(e) {
			if (this._operations.has(e.id)) return this._operations.get(e.id)
			if (this._isHostExtension(e.id)) return this._createAndSaveOperation(e, null, [], null)
			let t = this._registry.getExtensionDescription(e.id)
			if (!t) {
				let i = new Error(`Cannot activate unknown extension '${e.id.value}'`),
					s = this._createAndSaveOperation(e, null, [], new pp(i))
				return this._host.onExtensionActivationError(e.id, i, new eg(e.id.value)), s
			}
			let n = [],
				r = typeof t.extensionDependencies > "u" ? [] : t.extensionDependencies
			for (let i of r) {
				if (this._isResolvedExtension(i)) continue
				let s = this._operations.get(i)
				if (s) {
					n.push(s)
					continue
				}
				if (this._isHostExtension(i)) {
					n.push(
						this._handleActivationRequest({
							id: this._globalRegistry.getExtensionDescription(i).identifier,
							reason: e.reason,
						}),
					)
					continue
				}
				let a = this._registry.getExtensionDescription(i)
				if (a) {
					if (!a.main && !a.browser) continue
					n.push(this._handleActivationRequest({ id: a.identifier, reason: e.reason }))
					continue
				}
				let l = t.displayName || t.identifier.value,
					d = new Error(
						`Cannot activate the '${l}' extension because it depends on unknown extension '${i}'`,
					),
					c = this._createAndSaveOperation(e, t.displayName, [], new pp(d))
				return this._host.onExtensionActivationError(t.identifier, d, new eg(i)), c
			}
			return this._createAndSaveOperation(e, t.displayName, n, null)
		}
		_createAndSaveOperation(e, t, n, r) {
			let i = new Bg(e.id, t, e.reason, n, r, this._host, this._logService)
			return this._operations.set(e.id, i), i
		}
		_isHostExtension(e) {
			return Ws.isHostExtension(e, this._registry, this._globalRegistry)
		}
		_isResolvedExtension(e) {
			let t = this._globalRegistry.getExtensionDescription(e)
			return t ? !t.main && !t.browser : !1
		}
	}
cp = R([S(3, te)], cp)
var Bg = class {
	constructor(e, t, n, r, i, s, a) {
		this._id = e
		this._displayName = t
		this._reason = n
		this._deps = r
		this._value = i
		this._host = s
		this._logService = a
		this._barrier = new dn()
		this._isDisposed = !1
		this._initialize()
	}
	get value() {
		return this._value
	}
	get friendlyName() {
		return this._displayName || this._id.value
	}
	dispose() {
		this._isDisposed = !0
	}
	wait() {
		return this._barrier.wait()
	}
	async _initialize() {
		await this._waitForDepsThenActivate(), this._barrier.open()
	}
	async _waitForDepsThenActivate() {
		if (!this._value) {
			for (; this._deps.length > 0; ) {
				for (let e = 0; e < this._deps.length; e++) {
					let t = this._deps[e]
					if (t.value && !t.value.activationFailed) {
						this._deps.splice(e, 1), e--
						continue
					}
					if (t.value && t.value.activationFailed) {
						let n = new Error(
							`Cannot activate the '${this.friendlyName}' extension because its dependency '${t.friendlyName}' failed to activate`,
						)
						;(n.detail = t.value.activationFailedError),
							(this._value = new pp(n)),
							this._host.onExtensionActivationError(this._id, n, null)
						return
					}
				}
				this._deps.length > 0 && (await Promise.race(this._deps.map((e) => e.wait())))
			}
			await this._activate()
		}
	}
	async _activate() {
		try {
			this._value = await this._host.actualActivateExtension(this._id, this._reason)
		} catch (e) {
			let t = new Error()
			if (
				(e && e.name && (t.name = e.name),
				e && e.message
					? (t.message = `Activating extension '${this._id.value}' failed: ${e.message}.`)
					: (t.message = `Activating extension '${this._id.value}' failed: ${e}.`),
				e && e.stack && (t.stack = e.stack),
				(this._value = new pp(t)),
				this._isDisposed && bn(e))
			)
				return
			this._host.onExtensionActivationError(this._id, t, null),
				this._logService.error(`Activating extension ${this._id.value} failed due to an error:`),
				this._logService.error(e)
		}
	}
}
Bg = R([S(6, te)], Bg)
var mp = class {
		constructor(e, t) {
			this._logService = t
			this._onDidChangeStorage = new E()
			this.onDidChangeStorage = this._onDidChangeStorage.event
			this._proxy = e.getProxy(N.MainThreadStorage)
		}
		registerExtensionStorageKeysToSync(e, t) {
			this._proxy.$registerExtensionStorageKeysToSync(e, t)
		}
		async initializeExtensionStorage(e, t, n) {
			let r = await this._proxy.$initializeExtensionStorage(e, t),
				i
			return r && (i = this.safeParseValue(e, t, r)), i || n
		}
		setValue(e, t, n) {
			return this._proxy.$setValue(e, t, n)
		}
		$acceptValue(e, t, n) {
			let r = this.safeParseValue(e, t, n)
			r && this._onDidChangeStorage.fire({ shared: e, key: t, value: r })
		}
		safeParseValue(e, t, n) {
			try {
				return JSON.parse(n)
			} catch (r) {
				this._logService.error(
					`[extHostStorage] unexpected error parsing storage contents (extensionId: ${t}, global: ${e}): ${r}`,
				)
			}
		}
	},
	fp = O("IExtHostStorage")
var $g = class {
		constructor(e, t, n) {
			this._deferredPromises = new Map()
			;(this._id = e),
				(this._shared = t),
				(this._storage = n),
				(this._init = this._storage
					.initializeExtensionStorage(this._shared, this._id, Object.create(null))
					.then((r) => ((this._value = r), this))),
				(this._storageListener = this._storage.onDidChangeStorage((r) => {
					r.shared === this._shared && r.key === this._id && (this._value = r.value)
				})),
				(this._scheduler = new Hn(() => {
					let r = this._deferredPromises
					;(this._deferredPromises = new Map()),
						(async () => {
							try {
								await this._storage.setValue(this._shared, this._id, this._value)
								for (let i of r.values()) i.complete()
							} catch (i) {
								for (let s of r.values()) s.error(i)
							}
						})()
				}, 0))
		}
		keys() {
			return Object.entries(this._value ?? {})
				.filter(([, e]) => e !== void 0)
				.map(([e]) => e)
		}
		get whenReady() {
			return this._init
		}
		get(e, t) {
			let n = this._value[e]
			return typeof n > "u" && (n = t), n
		}
		update(e, t) {
			t !== null && typeof t == "object" ? (this._value[e] = JSON.parse(JSON.stringify(t))) : (this._value[e] = t)
			let n = this._deferredPromises.get(e)
			if (n !== void 0) return n.p
			let r = new Cn()
			return this._deferredPromises.set(e, r), this._scheduler.isScheduled() || this._scheduler.schedule(), r.p
		}
		dispose() {
			this._storageListener.dispose()
		}
	},
	Ox = class extends $g {
		setKeysForSync(e) {
			this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, e)
		}
		constructor(e, t) {
			super(e.identifier.value, !0, t), (this._extension = e)
		}
	}
var Ir = class {
	constructor(e, t) {
		this._fileSystemProvider = new Map()
		this._writeQueue = new Cc()
		this._proxy = e.getProxy(N.MainThreadFileSystem)
		let n = this
		this.value = Object.freeze({
			async stat(r) {
				try {
					let i,
						s = n._fileSystemProvider.get(r.scheme)
					return (
						s
							? (await n._proxy.$ensureActivation(r.scheme), (i = await s.impl.stat(r)))
							: (i = await n._proxy.$stat(r)),
						{
							type: i.type,
							ctime: i.ctime,
							mtime: i.mtime,
							size: i.size,
							permissions: i.permissions === 1 ? 1 : void 0,
						}
					)
				} catch (i) {
					Ir._handleError(i)
				}
			},
			async readDirectory(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i
						? (await n._proxy.$ensureActivation(r.scheme), (await i.impl.readDirectory(r)).slice())
						: await n._proxy.$readdir(r)
				} catch (i) {
					return Ir._handleError(i)
				}
			},
			async createDirectory(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i && !i.isReadonly
						? (await n._proxy.$ensureActivation(r.scheme), await n.mkdirp(i.impl, i.extUri, r))
						: await n._proxy.$mkdir(r)
				} catch (i) {
					return Ir._handleError(i)
				}
			},
			async readFile(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i
						? (await n._proxy.$ensureActivation(r.scheme), (await i.impl.readFile(r)).slice())
						: (await n._proxy.$readFile(r)).buffer
				} catch (i) {
					return Ir._handleError(i)
				}
			},
			async writeFile(r, i) {
				try {
					let s = n._fileSystemProvider.get(r.scheme)
					return s && !s.isReadonly
						? (await n._proxy.$ensureActivation(r.scheme),
							await n.mkdirp(s.impl, s.extUri, s.extUri.dirname(r)),
							await n._writeQueue.queueFor(r, () =>
								Promise.resolve(s.impl.writeFile(r, i, { create: !0, overwrite: !0 })),
							))
						: await n._proxy.$writeFile(r, z.wrap(i))
				} catch (s) {
					return Ir._handleError(s)
				}
			},
			async delete(r, i) {
				try {
					let s = n._fileSystemProvider.get(r.scheme)
					return s && !s.isReadonly && !i?.useTrash
						? (await n._proxy.$ensureActivation(r.scheme), await s.impl.delete(r, { recursive: !1, ...i }))
						: await n._proxy.$delete(r, { recursive: !1, useTrash: !1, atomic: !1, ...i })
				} catch (s) {
					return Ir._handleError(s)
				}
			},
			async rename(r, i, s) {
				try {
					return await n._proxy.$rename(r, i, { overwrite: !1, ...s })
				} catch (a) {
					return Ir._handleError(a)
				}
			},
			async copy(r, i, s) {
				try {
					return await n._proxy.$copy(r, i, { overwrite: !1, ...s })
				} catch (a) {
					return Ir._handleError(a)
				}
			},
			isWritableFileSystem(r) {
				let i = t.getCapabilities(r)
				if (typeof i == "number") return !(i & 2048)
			},
		})
	}
	async mkdirp(e, t, n) {
		let r = []
		for (; !t.isEqual(n, t.dirname(n)); )
			try {
				if (((await e.stat(n)).type & 2) === 0)
					throw rt.FileExists(
						`Unable to create folder '${n.scheme === W.file ? n.fsPath : n.toString(!0)}' that already exists but is not a directory`,
					)
				break
			} catch (i) {
				if (Wc(i) !== "EntryNotFound") throw i
				r.push(t.basename(n)), (n = t.dirname(n))
			}
		for (let i = r.length - 1; i >= 0; i--) {
			n = t.joinPath(n, r[i])
			try {
				await e.createDirectory(n)
			} catch (s) {
				if (Wc(s) !== "EntryExists") throw s
			}
		}
	}
	static _handleError(e) {
		if (e instanceof rt) throw e
		if (e instanceof ga)
			switch (e.code) {
				case "EntryExists":
					throw rt.FileExists(e.message)
				case "EntryNotFound":
					throw rt.FileNotFound(e.message)
				case "EntryNotADirectory":
					throw rt.FileNotADirectory(e.message)
				case "EntryIsADirectory":
					throw rt.FileIsADirectory(e.message)
				case "NoPermissions":
					throw rt.NoPermissions(e.message)
				case "Unavailable":
					throw rt.Unavailable(e.message)
				default:
					throw new rt(e.message, e.name)
			}
		if (!(e instanceof Error)) throw new rt(String(e))
		if (e.name === "ENOPRO" || e.message.includes("ENOPRO")) throw rt.Unavailable(e.message)
		switch (e.name) {
			case "EntryExists":
				throw rt.FileExists(e.message)
			case "EntryNotFound":
				throw rt.FileNotFound(e.message)
			case "EntryNotADirectory":
				throw rt.FileNotADirectory(e.message)
			case "EntryIsADirectory":
				throw rt.FileIsADirectory(e.message)
			case "NoPermissions":
				throw rt.NoPermissions(e.message)
			case "Unavailable":
				throw rt.Unavailable(e.message)
			default:
				throw new rt(e.message, e.name)
		}
	}
	addFileSystemProvider(e, t, n) {
		return (
			this._fileSystemProvider.set(e, {
				impl: t,
				extUri: n?.isCaseSensitive ? et : SE,
				isReadonly: !!n?.isReadonly,
			}),
			q(() => this._fileSystemProvider.delete(e))
		)
	}
	getFileSystemProviderExtUri(e) {
		return this._fileSystemProvider.get(e)?.extUri ?? et
	}
}
Ir = R([S(0, ie), S(1, uo)], Ir)
var Li = O("IExtHostConsumerFileSystem")
var hp = O("IExtensionStoragePaths"),
	gp = class {
		constructor(e, t, n) {
			this._logService = t
			this._extHostFileSystem = n
			;(this._workspace = e.workspace ?? void 0),
				(this._environment = e.environment),
				(this.whenReady = this._getOrCreateWorkspaceStoragePath().then((r) => (this._value = r)))
		}
		async _getWorkspaceStorageURI(e) {
			return y.joinPath(this._environment.workspaceStorageHome, e)
		}
		async _getOrCreateWorkspaceStoragePath() {
			if (!this._workspace) return Promise.resolve(void 0)
			let e = this._workspace.id,
				t = await this._getWorkspaceStorageURI(e)
			try {
				return (
					await this._extHostFileSystem.value.stat(t),
					this._logService.trace("[ExtHostStorage] storage dir already exists", t),
					t
				)
			} catch {}
			try {
				return (
					this._logService.trace("[ExtHostStorage] creating dir and metadata-file", t),
					await this._extHostFileSystem.value.createDirectory(t),
					await this._extHostFileSystem.value.writeFile(
						y.joinPath(t, "meta.json"),
						new TextEncoder().encode(
							JSON.stringify(
								{
									id: this._workspace.id,
									configuration: y.revive(this._workspace.configuration)?.toString(),
									name: this._workspace.name,
								},
								void 0,
								2,
							),
						),
					),
					t
				)
			} catch (n) {
				this._logService.error("[ExtHostStorage]", n)
				return
			}
		}
		workspaceValue(e) {
			if (this._value) return y.joinPath(this._value, e.identifier.value)
		}
		globalValue(e) {
			return y.joinPath(this._environment.globalStorageHome, e.identifier.value.toLowerCase())
		}
		onWillDeactivateAll() {}
	}
gp = R([S(0, Xe), S(1, te), S(2, Li)], gp)
var GF = O("tunnelService"),
	xhe = O("sharedTunnelsService")
function QF(o) {
	return !!o.forwardPort
}
function i8(o) {
	if (o.scheme !== "http" && o.scheme !== "https") return
	let e = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(o.authority)
	if (e) return { address: e[1], port: +e[2] }
}
var bp = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"]
function Mi(o) {
	return bp.indexOf(o) >= 0
}
var zg = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"]
function So(o) {
	return zg.indexOf(o) >= 0
}
function JF(o, e, t, n) {
	if (t === 1) return !1
	if (t === 2 && So(e)) {
		let r = /(\d+)\.(\d+)\.(\d+)/g.exec(n)
		if (r?.length === 4 && parseInt(r[1]) >= 18) return !1
	}
	return o < 1024
}
var Lx = class {
		constructor(e, t, n) {
			this.remoteAddress = e
			this.localAddress = t
			this._dispose = n
			this._onDispose = new E()
			this.onDidDispose = this._onDispose.event
		}
		dispose() {
			return this._onDispose.fire(), this._dispose()
		}
	},
	vp = class extends $ {
		constructor(t, n) {
			super()
			this.logService = t
			this.configurationService = n
			this._onTunnelOpened = new E()
			this.onTunnelOpened = this._onTunnelOpened.event
			this._onTunnelClosed = new E()
			this.onTunnelClosed = this._onTunnelClosed.event
			this._onAddedTunnelProvider = new E()
			this.onAddedTunnelProvider = this._onAddedTunnelProvider.event
			this._tunnels = new Map()
			this._canElevate = !1
			this._canChangeProtocol = !0
			this._privacyOptions = []
			this._factoryInProgress = new Set()
		}
		get hasTunnelProvider() {
			return !!this._tunnelProvider
		}
		get defaultTunnelHost() {
			let t = this.configurationService.getValue("remote.localPortHost")
			return !t || t === "localhost" ? "127.0.0.1" : "0.0.0.0"
		}
		setTunnelProvider(t) {
			return (
				(this._tunnelProvider = t),
				t
					? (this._onAddedTunnelProvider.fire(),
						{
							dispose: () => {
								;(this._tunnelProvider = void 0), (this._canElevate = !1), (this._privacyOptions = [])
							},
						})
					: ((this._canElevate = !1),
						(this._privacyOptions = []),
						this._onAddedTunnelProvider.fire(),
						{ dispose: () => {} })
			)
		}
		setTunnelFeatures(t) {
			;(this._canElevate = t.elevation),
				(this._privacyOptions = t.privacyOptions),
				(this._canChangeProtocol = t.protocol)
		}
		get canChangeProtocol() {
			return this._canChangeProtocol
		}
		get canElevate() {
			return this._canElevate
		}
		get canChangePrivacy() {
			return this._privacyOptions.length > 0
		}
		get privacyOptions() {
			return this._privacyOptions
		}
		get tunnels() {
			return this.getTunnels()
		}
		async getTunnels() {
			let t = [],
				n = Array.from(this._tunnels.values())
			for (let r of n) {
				let i = Array.from(r.values())
				for (let s of i) {
					let a = await s.value
					a && typeof a != "string" && t.push(a)
				}
			}
			return t
		}
		async dispose() {
			super.dispose()
			for (let t of this._tunnels.values()) {
				for (let { value: n } of t.values()) await n.then((r) => (typeof r != "string" ? r?.dispose() : void 0))
				t.clear()
			}
			this._tunnels.clear()
		}
		setEnvironmentTunnel(t, n, r, i, s) {
			this.addTunnelToMap(
				t,
				n,
				Promise.resolve({
					tunnelRemoteHost: t,
					tunnelRemotePort: n,
					localAddress: r,
					privacy: i,
					protocol: s,
					dispose: () => Promise.resolve(),
				}),
			)
		}
		async getExistingTunnel(t, n) {
			;(So(t) || Mi(t)) && (t = bp[0])
			let r = this.getTunnelFromMap(t, n)
			if (r) return ++r.refcount, r.value
		}
		openTunnel(t, n, r, i, s, a = !1, l, d) {
			this.logService.trace(
				`ForwardedPorts: (TunnelService) openTunnel request for ${n}:${r} on local port ${s}.`,
			)
			let c = this._tunnelProvider ?? t
			if (!c) return
			if (
				(n || (n = "localhost"),
				i || (i = this.defaultTunnelHost),
				this._tunnelProvider && this._factoryInProgress.has(r))
			) {
				this.logService.debug(
					"ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.",
				)
				return
			}
			let u = this.retainOrCreateTunnel(c, n, r, i, s, a, l, d)
			return u
				? u.then((m) => {
						if (m) {
							if (typeof m == "string")
								return (
									this.logService.trace(
										"ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.",
									),
									this.removeEmptyOrErrorTunnelFromMap(n, r),
									m
								)
						} else {
							this.logService.trace("ForwardedPorts: (TunnelService) New tunnel is undefined."),
								this.removeEmptyOrErrorTunnelFromMap(n, r)
							return
						}
						this.logService.trace("ForwardedPorts: (TunnelService) New tunnel established.")
						let f = this.makeTunnel(m)
						return (
							(m.tunnelRemoteHost !== n || m.tunnelRemotePort !== r) &&
								this.logService.warn(
									"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.",
								),
							l &&
								m.privacy !== l &&
								this.logService.warn(
									"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.",
								),
							this._onTunnelOpened.fire(f),
							f
						)
					})
				: (this.logService.trace("ForwardedPorts: (TunnelService) Tunnel was not created."), u)
		}
		makeTunnel(t) {
			return {
				tunnelRemotePort: t.tunnelRemotePort,
				tunnelRemoteHost: t.tunnelRemoteHost,
				tunnelLocalPort: t.tunnelLocalPort,
				localAddress: t.localAddress,
				privacy: t.privacy,
				protocol: t.protocol,
				dispose: async () => {
					this.logService.trace(
						`ForwardedPorts: (TunnelService) dispose request for ${t.tunnelRemoteHost}:${t.tunnelRemotePort} `,
					)
					let n = this._tunnels.get(t.tunnelRemoteHost)
					if (n) {
						let r = n.get(t.tunnelRemotePort)
						r && (r.refcount--, await this.tryDisposeTunnel(t.tunnelRemoteHost, t.tunnelRemotePort, r))
					}
				},
			}
		}
		async tryDisposeTunnel(t, n, r) {
			if (r.refcount <= 0) {
				this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${t}:${n}.`)
				let i = r.value.then(async (s) => {
					s &&
						typeof s != "string" &&
						(await s.dispose(!0),
						this._onTunnelClosed.fire({ host: s.tunnelRemoteHost, port: s.tunnelRemotePort }))
				})
				return this._tunnels.has(t) && this._tunnels.get(t).delete(n), i
			}
		}
		async closeTunnel(t, n) {
			this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${t}:${n} `)
			let r = this._tunnels.get(t)
			if (r && r.has(n)) {
				let i = r.get(n)
				;(i.refcount = 0), await this.tryDisposeTunnel(t, n, i)
			}
		}
		addTunnelToMap(t, n, r) {
			this._tunnels.has(t) || this._tunnels.set(t, new Map()),
				this._tunnels.get(t).set(n, { refcount: 1, value: r })
		}
		async removeEmptyOrErrorTunnelFromMap(t, n) {
			let r = this._tunnels.get(t)
			if (r) {
				let i = r.get(n),
					s = i ? await i.value : void 0
				;(!s || typeof s == "string") && r.delete(n), r.size === 0 && this._tunnels.delete(t)
			}
		}
		getTunnelFromMap(t, n) {
			let r = [t]
			Mi(t) ? (r.push(...bp), r.push(...zg)) : So(t) && r.push(...zg)
			let i = r.map((s) => this._tunnels.get(s))
			for (let s of i) {
				let a = s?.get(n)
				if (a) return a
			}
		}
		canTunnel(t) {
			return !!i8(t)
		}
		createWithProvider(t, n, r, i, s, a, l) {
			this.logService.trace(
				`ForwardedPorts: (TunnelService) Creating tunnel with provider ${n}:${r} on local port ${i}.`,
			)
			let d = r
			this._factoryInProgress.add(d)
			let c = i === void 0 ? r : i,
				u = { elevationRequired: s ? this.isPortPrivileged(c) : !1 },
				m = {
					remoteAddress: { host: n, port: r },
					localAddressPort: i,
					privacy: a,
					public: a ? a !== "private" : void 0,
					protocol: l,
				},
				f = t.forwardPort(m, u)
			return (
				f
					? (this.addTunnelToMap(n, r, f),
						f.finally(() => {
							this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created by provider."),
								this._factoryInProgress.delete(d)
						}))
					: this._factoryInProgress.delete(d),
				f
			)
		}
	}
vp = R([S(0, te), S(1, vr)], vp)
var Sk = class extends Lx {},
	YF
;((t) => {
	function o(n) {
		return {
			remoteAddress: n.remoteAddress,
			localAddress: n.localAddress,
			public: !!n.public,
			privacy: n.privacy ?? (n.public ? "public" : "private"),
			protocol: n.protocol,
		}
	}
	t.fromApiTunnel = o
	function e(n) {
		return {
			remoteAddress: { host: n.tunnelRemoteHost, port: n.tunnelRemotePort },
			localAddress: n.localAddress,
			public: n.privacy !== "constantPrivate" && n.privacy !== "constantPrivate",
			privacy: n.privacy,
			protocol: n.protocol,
		}
	}
	t.fromServiceTunnel = e
})((YF ||= {}))
var ol = O("IExtHostTunnelService"),
	rl = class extends $ {
		constructor(t, n, r) {
			super()
			this.logService = r
			this._showCandidatePort = () => Promise.resolve(!0)
			this._extensionTunnels = new Map()
			this._onDidChangeTunnels = new E()
			this.onDidChangeTunnels = this._onDidChangeTunnels.event
			this._providerHandleCounter = 0
			this._portAttributesProviders = new Map()
			this._proxy = t.getProxy(N.MainThreadTunnelService)
		}
		async openTunnel(t, n) {
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) ${t.identifier.value} called openTunnel API for ${n.remoteAddress.host}:${n.remoteAddress.port}.`,
			)
			let r = await this._proxy.$openTunnel(n, t.displayName)
			if (r) {
				let i = new Sk(r.remoteAddress, r.localAddress, () => this._proxy.$closeTunnel(r.remoteAddress))
				return this._register(i), i
			}
		}
		async getTunnels() {
			return this._proxy.$getTunnels()
		}
		nextPortAttributesProviderHandle() {
			return this._providerHandleCounter++
		}
		registerPortsAttributesProvider(t, n) {
			t.portRange === void 0 &&
				t.commandPattern === void 0 &&
				this.logService.error("PortAttributesProvider must specify either a portRange or a commandPattern")
			let r = this.nextPortAttributesProviderHandle()
			return (
				this._portAttributesProviders.set(r, { selector: t, provider: n }),
				this._proxy.$registerPortsAttributesProvider(t, r),
				new ye(() => {
					this._portAttributesProviders.delete(r), this._proxy.$unregisterPortsAttributesProvider(r)
				})
			)
		}
		async $providePortAttributes(t, n, r, i, s) {
			let a = []
			for (let d of t) {
				let c = this._portAttributesProviders.get(d)
				if (!c) return []
				a.push(
					...(await Promise.all(
						n.map(async (u) => {
							let m
							try {
								m = await c.provider.providePortAttributes({ port: u, pid: r, commandLine: i }, s)
							} catch {
								m = await c.provider.providePortAttributes(u, r, i, s)
							}
							return { providedAttributes: m, port: u }
						}),
					)),
				)
			}
			let l = a.filter((d) => !!d.providedAttributes)
			return l.length > 0
				? l.map((d) => ({ autoForwardAction: d.providedAttributes.autoForwardAction, port: d.port }))
				: []
		}
		async $registerCandidateFinder(t) {}
		registerTunnelProvider(t, n) {
			if (this._forwardPortProvider)
				throw new Error(
					"A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.",
				)
			this._forwardPortProvider = async (i, s) => (await t.provideTunnel(i, s, De.None)) ?? void 0
			let r = n.tunnelFeatures
				? {
						elevation: !!n.tunnelFeatures?.elevation,
						privacyOptions: n.tunnelFeatures?.privacyOptions,
						protocol: n.tunnelFeatures.protocol === void 0 ? !0 : n.tunnelFeatures.protocol,
					}
				: void 0
			return (
				this._proxy.$setTunnelProvider(r, !0),
				Promise.resolve(
					q(() => {
						;(this._forwardPortProvider = void 0), this._proxy.$setTunnelProvider(void 0, !1)
					}),
				)
			)
		}
		async setTunnelFactory(t, n) {
			if (t) {
				t.candidatePortSource !== void 0 && this._proxy.$setCandidatePortSource(t.candidatePortSource),
					t.showCandidatePort &&
						((this._showCandidatePort = t.showCandidatePort), this._proxy.$setCandidateFilter())
				let r = t.tunnelFactory ?? (n ? this.makeManagedTunnelFactory(n) : void 0)
				if (r) {
					this._forwardPortProvider = r
					let i = t.tunnelFeatures?.privacyOptions ?? []
					t.tunnelFeatures?.public &&
						i.length === 0 &&
						(i = [
							{ id: "private", label: p("tunnelPrivacy.private", "Private"), themeIcon: "lock" },
							{ id: "public", label: p("tunnelPrivacy.public", "Public"), themeIcon: "eye" },
						])
					let s = t.tunnelFeatures
						? {
								elevation: !!t.tunnelFeatures?.elevation,
								public: !!t.tunnelFeatures?.public,
								privacyOptions: i,
								protocol: !0,
							}
						: void 0
					this._proxy.$setTunnelProvider(s, !!t.tunnelFactory)
				}
			} else this._forwardPortProvider = void 0
			return q(() => {
				this._forwardPortProvider = void 0
			})
		}
		makeManagedTunnelFactory(t) {}
		async $closeTunnel(t, n) {
			if (this._extensionTunnels.has(t.host)) {
				let r = this._extensionTunnels.get(t.host)
				r.has(t.port) &&
					(n && r.get(t.port).disposeListener.dispose(),
					await r.get(t.port).tunnel.dispose(),
					r.delete(t.port))
			}
		}
		async $onDidTunnelsChange() {
			this._onDidChangeTunnels.fire()
		}
		async $forwardPort(t, n) {
			if (this._forwardPortProvider)
				try {
					this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.")
					let r = this._forwardPortProvider(t, n)
					if (
						(this.logService.trace(
							"ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.",
						),
						r !== void 0)
					) {
						let i = await r
						if (
							(this.logService.trace(
								"ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.",
							),
							i === void 0)
						) {
							this.logService.error("ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined")
							return
						}
						this._extensionTunnels.has(t.remoteAddress.host) ||
							this._extensionTunnels.set(t.remoteAddress.host, new Map())
						let s = this._register(
							i.onDidDispose(
								() => (
									this.logService.trace(
										"ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.",
									),
									this._proxy.$closeTunnel(i.remoteAddress)
								),
							),
						)
						return (
							this._extensionTunnels
								.get(t.remoteAddress.host)
								.set(t.remoteAddress.port, { tunnel: i, disposeListener: s }),
							YF.fromApiTunnel(i)
						)
					} else this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined")
				} catch (r) {
					if (
						(this.logService.trace("ForwardedPorts: (ExtHostTunnelService) tunnel provider error"),
						r instanceof Error)
					)
						return r.message
				}
		}
		async $applyCandidateFilter(t) {
			let n = await Promise.all(t.map((i) => this._showCandidatePort(i.host, i.port, i.detail ?? ""))),
				r = t.filter((i, s) => n[s])
			return (
				this.logService.trace(
					`ForwardedPorts: (ExtHostTunnelService) filtered from ${t.map((i) => i.port).join(", ")} to ${r.map((i) => i.port).join(", ")}`,
				),
				r
			)
		}
	}
rl = R([S(0, ie), S(1, Xe), S(2, te)], rl)
function ZF(o) {
	return [...o.entries()]
}
function e2(o) {
	return o ? [...o.entries()] : []
}
var Qhe = new D("terminalTabFocusMode", !1, !0)
var Jhe = O("ptyService")
var s8 = { Backend: "workbench.contributions.terminal.processBackend" },
	Tk = class {
		constructor() {
			this._backends = new Map()
		}
		get backends() {
			return this._backends
		}
		registerTerminalBackend(e) {
			let t = this._sanitizeRemoteAuthority(e.remoteAuthority)
			if (this._backends.has(t))
				throw new Error(`A terminal backend with remote authority '${t}' was already registered.`)
			this._backends.set(t, e)
		}
		getTerminalBackend(e) {
			return this._backends.get(this._sanitizeRemoteAuthority(e))
		}
		_sanitizeRemoteAuthority(e) {
			return e?.toLowerCase() ?? ""
		}
	}
yt.add(s8.Backend, new Tk())
var Xhe = O("localPtyService"),
	Yhe = O("terminalLogService")
var Fx = class {
	constructor(e) {
		this._callback = e
		this._terminalBufferMap = new Map()
	}
	dispose() {
		for (let e of this._terminalBufferMap.values()) e.dispose()
	}
	startBuffering(e, t, n = 5) {
		let r = t((i) => {
			let s = typeof i == "string" ? i : i.data,
				a = this._terminalBufferMap.get(e)
			if (a) {
				a.data.push(s)
				return
			}
			let l = setTimeout(() => this.flushBuffer(e), n)
			;(a = {
				data: [s],
				timeoutId: l,
				dispose: () => {
					clearTimeout(l), this.flushBuffer(e), r.dispose()
				},
			}),
				this._terminalBufferMap.set(e, a)
		})
		return r
	}
	stopBuffering(e) {
		this._terminalBufferMap.get(e)?.dispose()
	}
	flushBuffer(e) {
		let t = this._terminalBufferMap.get(e)
		t && (this._terminalBufferMap.delete(e), this._callback(e, t.data.join("")))
	}
}
var Ld = (o, e, t, n) => {
		let r = e
		return {
			enumerable: !0,
			configurable: !1,
			get() {
				return r
			},
			set(i) {
				if (!t(r, i)) {
					let s = r
					;(r = i), o.listener?.(n(i, s))
				}
			},
		}
	},
	yp = (o, e) => o === e,
	il = {
		range: (o, e) => (o === e ? !0 : !o || !e ? !1 : o.isEqual(e)),
		label: yp,
		description: yp,
		sortText: yp,
		busy: yp,
		error: yp,
		canResolveChildren: yp,
		tags: (o, e) => !(o.length !== e.length || o.some((t) => !e.find((n) => t.id === n.id))),
	},
	Ip = (o) => (e) => ({ op: 4, update: o(e) }),
	a8 = (o, e) => ({
		range: (() => {
			let t,
				n = Ip((r) => ({ range: Re.lift(H.from(r)) }))
			return {
				enumerable: !0,
				configurable: !1,
				get() {
					return t
				},
				set(r) {
					o.listener?.({ op: 6 }), il.range(t, r) || ((t = r), o.listener?.(n(r)))
				},
			}
		})(),
		label: Ld(
			o,
			e,
			il.label,
			Ip((t) => ({ label: t })),
		),
		description: Ld(
			o,
			void 0,
			il.description,
			Ip((t) => ({ description: t })),
		),
		sortText: Ld(
			o,
			void 0,
			il.sortText,
			Ip((t) => ({ sortText: t })),
		),
		canResolveChildren: Ld(o, !1, il.canResolveChildren, (t) => ({ op: 2, state: t })),
		busy: Ld(
			o,
			!1,
			il.busy,
			Ip((t) => ({ busy: t })),
		),
		error: Ld(
			o,
			void 0,
			il.error,
			Ip((t) => ({ error: Ce.fromStrict(t) || null })),
		),
		tags: Ld(o, [], il.tags, (t, n) => ({ op: 1, new: t.map(Co.from), old: n.map(Co.from) })),
	}),
	l8 = (o) => {
		let e = ze.fromString(o.extId),
			t = new Vs(e.controllerId, e.localId, o.label, y.revive(o.uri) || void 0)
		return (
			(t.range = H.to(o.range || void 0)),
			(t.description = o.description || void 0),
			(t.sortText = o.sortText || void 0),
			(t.tags = o.tags.map((n) => Co.to({ id: ky(n).tagId }))),
			t
		)
	},
	Ek = (o) => {
		let e
		for (let t of o.tests) {
			let n = l8(t.item)
			;(au(n).parent = e), (e = n)
		}
		return e
	},
	Vs = class o {
		constructor(e, t, n, r) {
			if (t.includes("\0")) throw new Error(`Test IDs may not include the ${JSON.stringify(t)} symbol`)
			let i = uF(this, e)
			Object.defineProperties(this, {
				id: { value: t, enumerable: !0, writable: !1 },
				uri: { value: r, enumerable: !0, writable: !1 },
				parent: {
					enumerable: !1,
					get() {
						return i.parent instanceof xp ? void 0 : i.parent
					},
				},
				children: { value: dF(i, au, o), enumerable: !0, writable: !1 },
				...a8(i, n),
			})
		}
	},
	xp = class extends Vs {
		constructor(t, n) {
			super(t, t, n, void 0)
			this._isRoot = !0
		}
	},
	Nx = class extends Ly {
		constructor(e, t, n) {
			super({
				controllerId: e,
				getDocumentVersion: (r) => r && n.getDocument(r)?.version,
				getApiFor: au,
				getChildren: (r) => r.children,
				root: new xp(e, t),
				toITestItem: Ri.from,
			})
		}
	}
var Ux = ((t) => ((t[(t.Desktop = 1)] = "Desktop"), (t[(t.Web = 2)] = "Web"), t))(Ux || {})
function wk(o) {
	let e = z.alloc(1)
	switch (o) {
		case 0:
			e.writeUInt8(1, 0)
			break
		case 1:
			e.writeUInt8(2, 0)
			break
		case 2:
			e.writeUInt8(3, 0)
			break
	}
	return e
}
function t2(o, e) {
	if (o.byteLength !== 1) return !1
	switch (o.readUInt8(0)) {
		case 1:
			return e === 0
		case 2:
			return e === 1
		case 3:
			return e === 2
		default:
			return !1
	}
}
var Cp = class extends $ {
	constructor(t, n, r) {
		super()
		this.initData = n
		this._onDidChangeTelemetryEnabled = this._register(new E())
		this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event
		this._onDidChangeTelemetryConfiguration = this._register(new E())
		this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event
		this._productConfig = { usage: !0, error: !0 }
		this._level = 0
		this._inLoggingOnlyMode = !1
		this._telemetryLoggers = new Map()
		this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly
		let i = n.remote.isRemote ? "remoteExtHostTelemetry" : t ? "workerExtHostTelemetry" : "extHostTelemetry"
		this._outputLogger = this._register(
			r.createLogger(i, {
				name: p(
					"extensionTelemetryLog",
					"Extension Telemetry{0}",
					this._inLoggingOnlyMode ? " (Not Sent)" : "",
				),
				hidden: !0,
				group: YM,
			}),
		)
	}
	getTelemetryConfiguration() {
		return this._level === 3
	}
	getTelemetryDetails() {
		return {
			isCrashEnabled: this._level >= 1,
			isErrorsEnabled: this._productConfig.error ? this._level >= 2 : !1,
			isUsageEnabled: this._productConfig.usage ? this._level >= 3 : !1,
		}
	}
	instantiateLogger(t, n, r) {
		let i = this.getTelemetryDetails(),
			s = new qg(n, r, t, this._outputLogger, this._inLoggingOnlyMode, this.getBuiltInCommonProperties(t), {
				isUsageEnabled: i.isUsageEnabled,
				isErrorsEnabled: i.isErrorsEnabled,
			}),
			a = this._telemetryLoggers.get(t.identifier.value) ?? []
		return this._telemetryLoggers.set(t.identifier.value, [...a, s]), s.apiTelemetryLogger
	}
	$initializeTelemetryLevel(t, n, r) {
		;(this._level = t), (this._productConfig = r ?? { usage: !0, error: !0 })
	}
	getBuiltInCommonProperties(t) {
		let n = Object.create(null)
		switch (
			((n["common.extname"] = `${t.publisher}.${t.name}`),
			(n["common.extversion"] = t.version),
			(n["common.vscodemachineid"] = this.initData.telemetryInfo.machineId),
			(n["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId),
			(n["common.vscodecommithash"] = this.initData.commit),
			(n["common.sqmid"] = this.initData.telemetryInfo.sqmId),
			(n["common.devDeviceId"] = this.initData.telemetryInfo.devDeviceId),
			(n["common.vscodeversion"] = this.initData.version),
			(n["common.isnewappinstall"] = Pk(this.initData.telemetryInfo.firstSessionDate)),
			(n["common.product"] = this.initData.environment.appHost),
			this.initData.uiKind)
		) {
			case 2:
				n["common.uikind"] = "web"
				break
			case 1:
				n["common.uikind"] = "desktop"
				break
			default:
				n["common.uikind"] = "unknown"
		}
		return (n["common.remotename"] = zl(ZM(this.initData.remote.authority))), n
	}
	$onDidChangeTelemetryLevel(t) {
		;(this._oldTelemetryEnablement = this.getTelemetryConfiguration()), (this._level = t)
		let n = this.getTelemetryDetails()
		this._telemetryLoggers.forEach((r, i) => {
			let s = r.filter((a) => !a.isDisposed)
			s.length === 0 ? this._telemetryLoggers.delete(i) : this._telemetryLoggers.set(i, s)
		}),
			this._telemetryLoggers.forEach((r) => {
				for (let i of r) i.updateTelemetryEnablements(n.isUsageEnabled, n.isErrorsEnabled)
			}),
			this._oldTelemetryEnablement !== this.getTelemetryConfiguration() &&
				this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration()),
			this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails())
	}
	onExtensionError(t, n) {
		let i = this._telemetryLoggers.get(t.value)?.filter((a) => !a.isDisposed)
		if (!i) return this._telemetryLoggers.delete(t.value), !1
		let s = !1
		for (let a of i) a.ignoreUnhandledExtHostErrors || (a.logError(n), (s = !0))
		return s
	}
}
Cp = R([S(1, Xe), S(2, co)], Cp)
var qg = class {
	constructor(e, t, n, r, i, s, a) {
		this._extension = n
		this._logger = r
		this._inLoggingOnlyMode = i
		this._commonProperties = s
		this._onDidChangeEnableStates = new E()
		;(this.ignoreUnhandledExtHostErrors = t?.ignoreUnhandledErrors ?? !1),
			(this._ignoreBuiltinCommonProperties = t?.ignoreBuiltInCommonProperties ?? !1),
			(this._additionalCommonProperties = t?.additionalCommonProperties),
			(this._sender = e),
			(this._telemetryEnablements = { isUsageEnabled: a.isUsageEnabled, isErrorsEnabled: a.isErrorsEnabled })
	}
	static validateSender(e) {
		if (typeof e != "object") throw new TypeError("TelemetrySender argument is invalid")
		if (typeof e.sendEventData != "function")
			throw new TypeError("TelemetrySender.sendEventData must be a function")
		if (typeof e.sendErrorData != "function")
			throw new TypeError("TelemetrySender.sendErrorData must be a function")
		if (typeof e.flush < "u" && typeof e.flush != "function")
			throw new TypeError("TelemetrySender.flush must be a function or undefined")
	}
	updateTelemetryEnablements(e, t) {
		this._apiObject &&
			((this._telemetryEnablements = { isUsageEnabled: e, isErrorsEnabled: t }),
			this._onDidChangeEnableStates.fire(this._apiObject))
	}
	mixInCommonPropsAndCleanData(e) {
		let t = "properties" in e ? (e.properties ?? {}) : e
		return (
			(t = b_(t, [])),
			this._additionalCommonProperties && (t = fr(t, this._additionalCommonProperties)),
			this._ignoreBuiltinCommonProperties || (t = fr(t, this._commonProperties)),
			"properties" in e ? (e.properties = t) : (e = t),
			e
		)
	}
	logEvent(e, t) {
		this._sender &&
			(this._extension.publisher === "vscode"
				? (e = this._extension.name + "/" + e)
				: (e = this._extension.identifier.value + "/" + e),
			(t = this.mixInCommonPropsAndCleanData(t || {})),
			this._inLoggingOnlyMode || this._sender?.sendEventData(e, t),
			this._logger.trace(e, t))
	}
	logUsage(e, t) {
		this._telemetryEnablements.isUsageEnabled && this.logEvent(e, t)
	}
	logError(e, t) {
		if (!(!this._telemetryEnablements.isErrorsEnabled || !this._sender))
			if (typeof e == "string") this.logEvent(e, t)
			else {
				let n = { name: e.name, message: e.message, stack: e.stack, cause: e.cause },
					r = b_(n, []),
					i = new Error(r.message, { cause: r.cause })
				;(i.stack = r.stack),
					(i.name = r.name),
					(t = this.mixInCommonPropsAndCleanData(t || {})),
					this._inLoggingOnlyMode || this._sender.sendErrorData(i, t),
					this._logger.trace("exception", t)
			}
	}
	get apiTelemetryLogger() {
		if (!this._apiObject) {
			let e = this,
				t = {
					logUsage: e.logUsage.bind(e),
					get isUsageEnabled() {
						return e._telemetryEnablements.isUsageEnabled
					},
					get isErrorsEnabled() {
						return e._telemetryEnablements.isErrorsEnabled
					},
					logError: e.logError.bind(e),
					dispose: e.dispose.bind(e),
					onDidChangeEnableStates: e._onDidChangeEnableStates.event.bind(e),
				}
			this._apiObject = Object.freeze(t)
		}
		return this._apiObject
	}
	get isDisposed() {
		return !this._sender
	}
	dispose() {
		if (this._sender?.flush) {
			let e = this._sender
			;(this._sender = void 0), Promise.resolve(e.flush()).then((e = void 0)), (this._apiObject = void 0)
		} else this._sender = void 0
	}
}
function Pk(o) {
	let e = Date.now() - new Date(o).getTime()
	return isNaN(e) ? !1 : e < 1e3 * 60 * 60 * 24
}
var sl = O("IExtHostTelemetry")
var Sp = class {
	constructor(e, t, n) {
		this._commands = new Map()
		this._apiCommands = new Map()
		;(this.#e = e.getProxy(N.MainThreadCommands)),
			(this._logService = t),
			(this.#n = n),
			(this.#t = e.getProxy(N.MainThreadTelemetry)),
			(this.converter = new _k(
				this,
				(r) => {
					let i = this._apiCommands.get(r)
					return i?.result === ge.Void ? i : void 0
				},
				t,
			)),
			(this._argumentProcessors = [
				{
					processArgument(r) {
						return ut(r)
					},
				},
				{
					processArgument(r) {
						return ns(r, function (i) {
							if (Re.isIRange(i)) return H.to(i)
							if (cn.isIPosition(i)) return Je.to(i)
							if (Re.isIRange(i.range) && y.isUri(i.uri)) return Bn.to(i)
							if (i instanceof z) return i.buffer.buffer
							if (!Array.isArray(i)) return i
						})
					},
				},
			])
	}
	#e
	#t
	#n
	registerArgumentProcessor(e) {
		this._argumentProcessors.push(e)
	}
	registerApiCommand(e) {
		let t = this.registerCommand(
			!1,
			e.id,
			async (...n) => {
				let r = e.args.map((s, a) => {
						if (!s.validate(n[a]))
							throw new Error(
								`Invalid argument '${s.name}' when running '${e.id}', received: ${typeof n[a] == "object" ? JSON.stringify(n[a], null, "	") : n[a]} `,
							)
						return s.convert(n[a])
					}),
					i = await this.executeCommand(e.internalId, ...r)
				return e.result.convert(i, n, this.converter)
			},
			void 0,
			{ description: e.description, args: e.args, returns: e.result.description },
		)
		return (
			this._apiCommands.set(e.id, e),
			new ye(() => {
				t.dispose(), this._apiCommands.delete(e.id)
			})
		)
	}
	registerCommand(e, t, n, r, i, s) {
		if ((this._logService.trace("ExtHostCommands#registerCommand", t), !t.trim().length))
			throw new Error("invalid id")
		if (this._commands.has(t)) throw new Error(`command '${t}' already exists`)
		return (
			this._commands.set(t, { callback: n, thisArg: r, metadata: i, extension: s }),
			e && this.#e.$registerCommand(t),
			new ye(() => {
				this._commands.delete(t) && e && this.#e.$unregisterCommand(t)
			})
		)
	}
	executeCommand(e, ...t) {
		return this._logService.trace("ExtHostCommands#executeCommand", e), this._doExecuteCommand(e, t, !0)
	}
	async _doExecuteCommand(e, t, n) {
		if (this._commands.has(e))
			return this.#e.$fireCommandActivationEvent(e), this._executeContributedCommand(e, t, !1)
		{
			let r = !1,
				i = ns(t, function (s) {
					if (s instanceof Pe) return Je.from(s)
					if (s instanceof pe) return H.from(s)
					if (s instanceof rn) return Bn.from(s)
					if (dr.isNotebookRange(s)) return Zr.from(s)
					if (s instanceof ArrayBuffer) return (r = !0), z.wrap(new Uint8Array(s))
					if (s instanceof Uint8Array) return (r = !0), z.wrap(s)
					if (s instanceof z) return (r = !0), s
					if (!Array.isArray(s)) return s
				})
			try {
				let s = await this.#e.$executeCommand(e, r ? new Xt(i) : i, n)
				return ut(s)
			} catch (s) {
				if (s instanceof Error && s.message === "$executeCommand:retry") return this._doExecuteCommand(e, t, !1)
				throw s
			}
		}
	}
	async _executeContributedCommand(e, t, n) {
		let r = this._commands.get(e)
		if (!r) throw new Error("Unknown command")
		let { callback: i, thisArg: s, metadata: a } = r
		if (a?.args)
			for (let d = 0; d < a.args.length; d++)
				try {
					z0(t[d], a.args[d].constraint)
				} catch {
					throw new Error(
						`Running the contributed command: '${e}' failed. Illegal argument '${a.args[d].name}' - ${a.args[d].description}`,
					)
				}
		let l = zt.create()
		try {
			return await i.apply(s, t)
		} catch (d) {
			if (e === this.converter.delegatingCommandId) {
				let c = this.converter.getActualCommand(...t)
				c && (e = c.command)
			}
			if ((bn(d) || this._logService.error(d, e, r.extension?.identifier), !n)) throw d
			if (r.extension?.identifier) {
				let c = this.#n.onExtensionError(r.extension.identifier, d)
				this._logService.trace("forwarded error to extension?", c, r.extension?.identifier)
			}
			throw new (class extends Error {
				constructor() {
					super(Jn(d))
					this.id = e
					this.source = r.extension?.displayName ?? r.extension?.name
				}
			})()
		} finally {
			this._reportTelemetry(r, e, l.elapsed())
		}
	}
	_reportTelemetry(e, t, n) {
		e.extension &&
			this.#t.$publicLog2("Extension:ActionExecuted", {
				extensionId: e.extension.identifier.value,
				id: new xa(t),
				duration: n,
			})
	}
	$executeContributedCommand(e, ...t) {
		this._logService.trace("ExtHostCommands#$executeContributedCommand", e)
		let n = this._commands.get(e)
		return n
			? ((t = t.map((r) => this._argumentProcessors.reduce((i, s) => s.processArgument(i, n.extension), r))),
				this._executeContributedCommand(e, t, !0))
			: Promise.reject(new Error(`Contributed command '${e}' does not exist.`))
	}
	getCommands(e = !1) {
		return (
			this._logService.trace("ExtHostCommands#getCommands", e),
			this.#e.$getCommands().then((t) => (e && (t = t.filter((n) => n[0] !== "_")), t))
		)
	}
	$getContributedCommandMetadata() {
		let e = Object.create(null)
		for (let [t, n] of this._commands) {
			let { metadata: r } = n
			r && (e[t] = r)
		}
		return Promise.resolve(e)
	}
}
Sp = R([S(0, ie), S(1, te), S(2, sl)], Sp)
var Tn = O("IExtHostCommands"),
	_k = class {
		constructor(e, t, n) {
			this._commands = e
			this._lookupApiCommand = t
			this._logService = n
			this.delegatingCommandId = `__vsc${He()}`
			this._cache = new Map()
			this._cachIdPool = 0
			this._commands.registerCommand(!0, this.delegatingCommandId, this._executeConvertedCommand, this)
		}
		toInternal(e, t) {
			if (!e) return
			let n = { $ident: void 0, id: e.command, title: e.title, tooltip: e.tooltip }
			if (!e.command) return n
			let r = this._lookupApiCommand(e.command)
			if (r) (n.id = r.internalId), (n.arguments = r.args.map((i, s) => i.convert(e.arguments && e.arguments[s])))
			else if (ri(e.arguments)) {
				let i = `${e.command} /${++this._cachIdPool}`
				this._cache.set(i, e),
					t.add(
						q(() => {
							this._cache.delete(i), this._logService.trace("CommandsConverter#DISPOSE", i)
						}),
					),
					(n.$ident = i),
					(n.id = this.delegatingCommandId),
					(n.arguments = [i]),
					this._logService.trace("CommandsConverter#CREATE", e.command, i)
			}
			return n
		}
		fromInternal(e) {
			return typeof e.$ident == "string"
				? this._cache.get(e.$ident)
				: { command: e.id, title: e.title, arguments: e.arguments }
		}
		getActualCommand(...e) {
			return this._cache.get(e[0])
		}
		_executeConvertedCommand(...e) {
			let t = this.getActualCommand(...e)
			return (
				this._logService.trace("CommandsConverter#EXECUTE", e[0], t ? t.command : "MISSING"),
				t
					? this._commands.executeCommand(t.command, ...(t.arguments || []))
					: Promise.reject(`Actual command not found, wanted to execute ${e[0]}`)
			)
		}
	},
	G = class o {
		constructor(e, t, n, r) {
			this.name = e
			this.description = t
			this.validate = n
			this.convert = r
		}
		static {
			this.Uri = new o(
				"uri",
				"Uri of a text document",
				(e) => y.isUri(e),
				(e) => e,
			)
		}
		static {
			this.Position = new o("position", "A position in a text document", (e) => Pe.isPosition(e), Je.from)
		}
		static {
			this.Range = new o("range", "A range in a text document", (e) => pe.isRange(e), H.from)
		}
		static {
			this.Selection = new o("selection", "A selection in a text document", (e) => Vn.isSelection(e), Zn.from)
		}
		static {
			this.Number = new o(
				"number",
				"",
				(e) => typeof e == "number",
				(e) => e,
			)
		}
		static {
			this.String = new o(
				"string",
				"",
				(e) => typeof e == "string",
				(e) => e,
			)
		}
		static Arr(e) {
			return new o(
				`${e.name}_array`,
				`Array of ${e.name}, ${e.description}`,
				(t) => Array.isArray(t) && t.every((n) => e.validate(n)),
				(t) => t.map((n) => e.convert(n)),
			)
		}
		static {
			this.CallHierarchyItem = new o("item", "A call hierarchy item", (e) => e instanceof Wa, Ns.from)
		}
		static {
			this.TypeHierarchyItem = new o("item", "A type hierarchy item", (e) => e instanceof $a, Hs.from)
		}
		static {
			this.TestItem = new o("testItem", "A VS Code TestItem", (e) => e instanceof Vs, Ri.from)
		}
		static {
			this.TestProfile = new o("testProfile", "A VS Code test profile", (e) => e instanceof Pu, jD.from)
		}
		optional() {
			return new o(
				this.name,
				`(optional) ${this.description}`,
				(e) => e == null || this.validate(e),
				(e) => (e === void 0 ? void 0 : e === null ? null : this.convert(e)),
			)
		}
		with(e, t) {
			return new o(e ?? this.name, t ?? this.description, this.validate, this.convert)
		}
	},
	ge = class o {
		constructor(e, t) {
			this.description = e
			this.convert = t
		}
		static {
			this.Void = new o("no result", (e) => e)
		}
	},
	be = class {
		constructor(e, t, n, r, i) {
			this.id = e
			this.internalId = t
			this.description = n
			this.args = r
			this.result = i
		}
	}
var er = O("IExtHostTerminalService"),
	Ep = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._proxy = t
			this._id = n
			this._creationOptions = r
			this._name = i
			this._disposed = !1
			this._state = { isInteractedWith: !1, shell: void 0 }
			this.isOpen = !1
			this._onWillDispose = this._register(new E())
			this.onWillDispose = this._onWillDispose.event
			;(this._creationOptions = Object.freeze(this._creationOptions)),
				(this._pidPromise = new Promise((a) => (this._pidPromiseComplete = a)))
			let s = this
			this.value = {
				get name() {
					return s._name || ""
				},
				get processId() {
					return s._pidPromise
				},
				get creationOptions() {
					return s._creationOptions
				},
				get exitStatus() {
					return s._exitStatus
				},
				get state() {
					return s._state
				},
				get selection() {
					return s._selection
				},
				get shellIntegration() {
					return s.shellIntegration
				},
				sendText(a, l = !0) {
					s._checkDisposed(), s._proxy.$sendText(s._id, a, l)
				},
				show(a) {
					s._checkDisposed(), s._proxy.$show(s._id, a)
				},
				hide() {
					s._checkDisposed(), s._proxy.$hide(s._id)
				},
				dispose() {
					s._disposed || ((s._disposed = !0), s._proxy.$dispose(s._id))
				},
				get dimensions() {
					if (!(s._cols === void 0 || s._rows === void 0)) return { columns: s._cols, rows: s._rows }
				},
			}
		}
		dispose() {
			this._onWillDispose.fire(), super.dispose()
		}
		async create(t, n) {
			if (typeof this._id != "string") throw new Error("Terminal has already been created")
			await this._proxy.$createTerminal(this._id, {
				name: t.name,
				shellPath: t.shellPath ?? void 0,
				shellArgs: t.shellArgs ?? void 0,
				cwd: t.cwd ?? n?.cwd ?? void 0,
				env: t.env ?? void 0,
				icon: r2(t.iconPath) ?? void 0,
				color: Bc.isThemeColor(t.color) ? t.color.id : void 0,
				initialText: t.message ?? void 0,
				strictEnv: t.strictEnv ?? void 0,
				hideFromUser: t.hideFromUser ?? void 0,
				forceShellIntegration: n?.forceShellIntegration ?? void 0,
				isFeatureTerminal: n?.isFeatureTerminal ?? void 0,
				isExtensionOwnedTerminal: !0,
				useShellEnvironment: n?.useShellEnvironment ?? void 0,
				location: n?.location || this._serializeParentTerminal(t.location, n?.resolvedExtHostIdentifier),
				isTransient: t.isTransient ?? void 0,
			})
		}
		async createExtensionTerminal(t, n, r, i, s) {
			if (typeof this._id != "string") throw new Error("Terminal has already been created")
			if (
				(await this._proxy.$createTerminal(this._id, {
					name: this._name,
					isExtensionCustomPtyTerminal: !0,
					icon: i,
					color: Bc.isThemeColor(s) ? s.id : void 0,
					location: n?.location || this._serializeParentTerminal(t, r),
					isTransient: !0,
				}),
				typeof this._id == "string")
			)
				throw new Error("Terminal creation failed")
			return this._id
		}
		_serializeParentTerminal(t, n) {
			return typeof t == "object"
				? "parentTerminal" in t && t.parentTerminal && n
					? { parentTerminal: n }
					: "viewColumn" in t
						? { viewColumn: wt.from(t.viewColumn), preserveFocus: t.preserveFocus }
						: void 0
				: t
		}
		_checkDisposed() {
			if (this._disposed) throw new Error("Terminal has already been disposed")
		}
		set name(t) {
			this._name = t
		}
		setExitStatus(t, n) {
			this._exitStatus = Object.freeze({ code: t, reason: n })
		}
		setDimensions(t, n) {
			return (t === this._cols && n === this._rows) || t === 0 || n === 0
				? !1
				: ((this._cols = t), (this._rows = n), !0)
		}
		setInteractedWith() {
			return this._state.isInteractedWith ? !1 : ((this._state = { ...this._state, isInteractedWith: !0 }), !0)
		}
		setShellType(t) {
			return this._state.shell !== t ? ((this._state = { ...this._state, shell: t }), !0) : !1
		}
		setSelection(t) {
			this._selection = t
		}
		_setProcessId(t) {
			this._pidPromiseComplete
				? (this._pidPromiseComplete(t), (this._pidPromiseComplete = void 0))
				: this._pidPromise.then((n) => {
						n !== t && (this._pidPromise = Promise.resolve(t))
					})
		}
	},
	Kg = class {
		constructor(e) {
			this._pty = e
			this.id = 0
			this.shouldPersist = !1
			this._onProcessData = new E()
			this.onProcessData = this._onProcessData.event
			this._onProcessReady = new E()
			this._onDidChangeProperty = new E()
			this.onDidChangeProperty = this._onDidChangeProperty.event
			this._onProcessExit = new E()
			this.onProcessExit = this._onProcessExit.event
		}
		get onProcessReady() {
			return this._onProcessReady.event
		}
		refreshProperty(e) {
			throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${e}`)
		}
		updateProperty(e, t) {
			throw new Error(
				`updateProperty is not suppported in extension owned terminals. property: ${e}, value: ${t}`,
			)
		}
		async start() {}
		shutdown() {
			this._pty.close()
		}
		input(e) {
			this._pty.handleInput?.(e)
		}
		resize(e, t) {
			this._pty.setDimensions?.({ columns: e, rows: t })
		}
		clearBuffer() {}
		async processBinary(e) {}
		acknowledgeDataEvent(e) {}
		async setUnicodeVersion(e) {}
		getInitialCwd() {
			return Promise.resolve("")
		}
		getCwd() {
			return Promise.resolve("")
		}
		startSendingEvents(e) {
			this._pty.onDidWrite((t) => this._onProcessData.fire(t)),
				this._pty.onDidClose?.((t = void 0) => {
					this._onProcessExit.fire(t === void 0 ? void 0 : t)
				}),
				this._pty.onDidOverrideDimensions?.((t) => {
					t &&
						this._onDidChangeProperty.fire({
							type: "overrideDimensions",
							value: { cols: t.columns, rows: t.rows },
						})
				}),
				this._pty.onDidChangeName?.((t) => {
					this._onDidChangeProperty.fire({ type: "title", value: t })
				}),
				this._pty.open(e || void 0),
				e && this._pty.setDimensions?.(e),
				this._onProcessReady.fire({ pid: -1, cwd: "", windowsPty: void 0 })
		}
	},
	d8 = 1,
	Md = class extends $ {
		constructor(t, n, r) {
			super()
			this._extHostCommands = n
			this._terminals = []
			this._terminalProcesses = new Map()
			this._terminalProcessDisposables = {}
			this._extensionTerminalAwaitingStart = {}
			this._getTerminalPromises = {}
			this._environmentVariableCollections = new Map()
			this._lastQuickFixCommands = this._register(new Dn())
			this._linkProviders = new Set()
			this._completionProviders = new Map()
			this._profileProviders = new Map()
			this._quickFixProviders = new Map()
			this._terminalLinkCache = new Map()
			this._terminalLinkCancellationSource = new Map()
			this._onDidCloseTerminal = new E()
			this.onDidCloseTerminal = this._onDidCloseTerminal.event
			this._onDidOpenTerminal = new E()
			this.onDidOpenTerminal = this._onDidOpenTerminal.event
			this._onDidChangeActiveTerminal = new E()
			this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event
			this._onDidChangeTerminalDimensions = new E()
			this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event
			this._onDidChangeTerminalState = new E()
			this.onDidChangeTerminalState = this._onDidChangeTerminalState.event
			this._onDidChangeShell = new E()
			this.onDidChangeShell = this._onDidChangeShell.event
			this._onDidWriteTerminalData = new E({
				onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
				onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents(),
			})
			this.onDidWriteTerminalData = this._onDidWriteTerminalData.event
			this._onDidExecuteCommand = new E({
				onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
				onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents(),
			})
			this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event
			;(this._proxy = r.getProxy(N.MainThreadTerminalService)),
				(this._bufferer = new Fx(this._proxy.$sendProcessData)),
				this._proxy.$registerProcessSupport(t),
				this._extHostCommands.registerArgumentProcessor({
					processArgument: (i) => {
						let s = (a) => {
							let l = a
							return this.getTerminalById(l.instanceId)?.value
						}
						switch (i?.$mid) {
							case 15:
								return s(i)
							default: {
								if (Array.isArray(i))
									for (let a = 0; a < i.length && i[a].$mid === 15; a++) i[a] = s(i[a])
								return i
							}
						}
					},
				}),
				this._register({
					dispose: () => {
						for (let [i, s] of this._terminalProcesses) s.shutdown(!0)
					},
				})
		}
		get activeTerminal() {
			return this._activeTerminal?.value
		}
		get terminals() {
			return this._terminals.map((t) => t.value)
		}
		getDefaultShell(t) {
			return (t ? this._defaultAutomationProfile : this._defaultProfile)?.path || ""
		}
		getDefaultShellArgs(t) {
			return (t ? this._defaultAutomationProfile : this._defaultProfile)?.args || []
		}
		createExtensionTerminal(t, n) {
			let r = new Ep(this._proxy, He(), t, t.name),
				i = new Kg(t.pty)
			return (
				r
					.createExtensionTerminal(
						t.location,
						n,
						this._serializeParentTerminal(t, n).resolvedExtHostIdentifier,
						r2(t.iconPath),
						c8(t.color),
					)
					.then((s) => {
						let a = this._setupExtHostProcessListeners(s, i)
						this._terminalProcessDisposables[s] = a
					}),
				this._terminals.push(r),
				r.value
			)
		}
		_serializeParentTerminal(t, n) {
			if (((n = n || {}), t.location && typeof t.location == "object" && "parentTerminal" in t.location)) {
				let r = t.location.parentTerminal
				if (r) {
					let i = this._terminals.find((s) => s.value === r)
					i && (n.resolvedExtHostIdentifier = i._id)
				}
			} else
				t.location && typeof t.location != "object"
					? (n.location = t.location)
					: n.location &&
						typeof n.location == "object" &&
						"splitActiveTerminal" in n.location &&
						(n.location = { splitActiveTerminal: !0 })
			return n
		}
		attachPtyToTerminal(t, n) {
			if (!this.getTerminalById(t)) throw new Error(`Cannot resolve terminal with id ${t} for virtual process`)
			let i = new Kg(n),
				s = this._setupExtHostProcessListeners(t, i)
			this._terminalProcessDisposables[t] = s
		}
		async $acceptActiveTerminalChanged(t) {
			let n = this._activeTerminal
			if (t === null) {
				;(this._activeTerminal = void 0),
					n !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal)
				return
			}
			let r = this.getTerminalById(t)
			r &&
				((this._activeTerminal = r),
				n !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal.value))
		}
		async $acceptTerminalProcessData(t, n) {
			let r = this.getTerminalById(t)
			r && this._onDidWriteTerminalData.fire({ terminal: r.value, data: n })
		}
		async $acceptTerminalDimensions(t, n, r) {
			let i = this.getTerminalById(t)
			i &&
				i.setDimensions(n, r) &&
				this._onDidChangeTerminalDimensions.fire({ terminal: i.value, dimensions: i.value.dimensions })
		}
		async $acceptDidExecuteCommand(t, n) {
			let r = this.getTerminalById(t)
			r && this._onDidExecuteCommand.fire({ terminal: r.value, ...n })
		}
		async $acceptTerminalMaximumDimensions(t, n, r) {
			this._terminalProcesses.get(t)?.resize(n, r)
		}
		async $acceptTerminalTitleChange(t, n) {
			let r = this.getTerminalById(t)
			r && (r.name = n)
		}
		async $acceptTerminalClosed(t, n, r) {
			let i = this._getTerminalObjectIndexById(this._terminals, t)
			if (i !== null) {
				let s = this._terminals.splice(i, 1)[0]
				s.setExitStatus(n, r), this._onDidCloseTerminal.fire(s.value)
			}
		}
		$acceptTerminalOpened(t, n, r, i) {
			if (n) {
				let l = this._getTerminalObjectIndexById(this._terminals, n)
				if (l !== null) {
					;(this._terminals[l]._id = t),
						this._onDidOpenTerminal.fire(this.terminals[l]),
						(this._terminals[l].isOpen = !0)
					return
				}
			}
			let s = {
					name: i.name,
					shellPath: i.executable,
					shellArgs: i.args,
					cwd: typeof i.cwd == "string" ? i.cwd : y.revive(i.cwd),
					env: i.env,
					hideFromUser: i.hideFromUser,
				},
				a = new Ep(this._proxy, t, s, r)
			this._terminals.push(a), this._onDidOpenTerminal.fire(a.value), (a.isOpen = !0)
		}
		async $acceptTerminalProcessId(t, n) {
			this.getTerminalById(t)?._setProcessId(n)
		}
		async $startExtensionTerminal(t, n) {
			let r = this.getTerminalById(t)
			if (!r)
				return {
					message: p(
						"launchFail.idMissingOnExtHost",
						"Could not find the terminal with id {0} on the extension host",
						t,
					),
				}
			r.isOpen ||
				(await new Promise((s) => {
					let a = this.onDidOpenTerminal(async (l) => {
						l === r.value && (a.dispose(), s())
					})
				}))
			let i = this._terminalProcesses.get(t)
			i ? i.startSendingEvents(n) : (this._extensionTerminalAwaitingStart[t] = { initialDimensions: n })
		}
		_setupExtHostProcessListeners(t, n) {
			let r = new Q()
			r.add(n.onProcessReady((s) => this._proxy.$sendProcessReady(t, s.pid, s.cwd, s.windowsPty))),
				r.add(n.onDidChangeProperty((s) => this._proxy.$sendProcessProperty(t, s))),
				this._bufferer.startBuffering(t, n.onProcessData),
				r.add(n.onProcessExit((s) => this._onProcessExit(t, s))),
				this._terminalProcesses.set(t, n)
			let i = this._extensionTerminalAwaitingStart[t]
			return (
				i &&
					n instanceof Kg &&
					(n.startSendingEvents(i.initialDimensions), delete this._extensionTerminalAwaitingStart[t]),
				r
			)
		}
		$acceptProcessAckDataEvent(t, n) {
			this._terminalProcesses.get(t)?.acknowledgeDataEvent(n)
		}
		$acceptProcessInput(t, n) {
			this._terminalProcesses.get(t)?.input(n)
		}
		$acceptTerminalInteraction(t) {
			let n = this.getTerminalById(t)
			n?.setInteractedWith() && this._onDidChangeTerminalState.fire(n.value)
		}
		$acceptTerminalSelection(t, n) {
			this.getTerminalById(t)?.setSelection(n)
		}
		$acceptProcessResize(t, n, r) {
			try {
				this._terminalProcesses.get(t)?.resize(n, r)
			} catch (i) {
				if (i.code !== "EPIPE" && i.code !== "ERR_IPC_CHANNEL_CLOSED") throw i
			}
		}
		$acceptProcessShutdown(t, n) {
			this._terminalProcesses.get(t)?.shutdown(n)
		}
		$acceptProcessRequestInitialCwd(t) {
			this._terminalProcesses
				.get(t)
				?.getInitialCwd()
				.then((n) => this._proxy.$sendProcessProperty(t, { type: "initialCwd", value: n }))
		}
		$acceptProcessRequestCwd(t) {
			this._terminalProcesses
				.get(t)
				?.getCwd()
				.then((n) => this._proxy.$sendProcessProperty(t, { type: "cwd", value: n }))
		}
		$acceptProcessRequestLatency(t) {
			return Promise.resolve(t)
		}
		registerProfileProvider(t, n, r) {
			if (this._profileProviders.has(n)) throw new Error(`Terminal profile provider "${n}" already registered`)
			return (
				this._profileProviders.set(n, r),
				this._proxy.$registerProfileProvider(n, t.identifier.value),
				new ye(() => {
					this._profileProviders.delete(n), this._proxy.$unregisterProfileProvider(n)
				})
			)
		}
		registerTerminalCompletionProvider(t, n, ...r) {
			if (this._completionProviders.has(n.id))
				throw new Error(`Terminal completion provider "${n.id}" already registered`)
			return (
				this._completionProviders.set(n.id, n),
				this._proxy.$registerCompletionProvider(n.id, t.identifier.value, ...r),
				new ye(() => {
					this._completionProviders.delete(n.id), this._proxy.$unregisterCompletionProvider(n.id)
				})
			)
		}
		async $provideTerminalCompletions(t, n) {
			let r = new _e().token
			if (r.isCancellationRequested || !this.activeTerminal) return
			let i = this._completionProviders.get(t)
			if (!i) return
			let s = await i.provideTerminalCompletions(this.activeTerminal, n, r)
			if (s != null) return ek.from(s)
		}
		$acceptTerminalShellType(t, n) {
			let r = this.getTerminalById(t)
			r?.setShellType(n) && this._onDidChangeTerminalState.fire(r.value)
		}
		registerTerminalQuickFixProvider(t, n, r) {
			if (this._quickFixProviders.has(t))
				throw new Error(`Terminal quick fix provider "${t}" is already registered`)
			return (
				this._quickFixProviders.set(t, r),
				this._proxy.$registerQuickFixProvider(t, n),
				new ye(() => {
					this._quickFixProviders.delete(t), this._proxy.$unregisterQuickFixProvider(t)
				})
			)
		}
		async $provideTerminalQuickFixes(t, n) {
			let r = new _e().token
			if (r.isCancellationRequested) return
			let i = this._quickFixProviders.get(t)
			if (!i) return
			let s = await i.provideTerminalQuickFixes(n, r)
			if (s === null || (Array.isArray(s) && s.length === 0)) return
			let a = new Q()
			if (((this._lastQuickFixCommands.value = a), !Array.isArray(s)))
				return s ? yx.from(s, this._extHostCommands.converter, a) : void 0
			let l = []
			for (let d of s) {
				let c = yx.from(d, this._extHostCommands.converter, a)
				c && l.push(c)
			}
			return l
		}
		async $createContributedProfileTerminal(t, n) {
			let r = new _e().token,
				i = await this._profileProviders.get(t)?.provideTerminalProfile(r)
			if (!r.isCancellationRequested) {
				if ((i && !("options" in i) && (i = { options: i }), !i || !("options" in i)))
					throw new Error(`No terminal profile options provided for id "${t}"`)
				if ("pty" in i.options) {
					this.createExtensionTerminal(i.options, n)
					return
				}
				this.createTerminalFromOptions(i.options, n)
			}
		}
		registerLinkProvider(t) {
			return (
				this._linkProviders.add(t),
				this._linkProviders.size === 1 && this._proxy.$startLinkProvider(),
				new ye(() => {
					this._linkProviders.delete(t), this._linkProviders.size === 0 && this._proxy.$stopLinkProvider()
				})
			)
		}
		async $provideLinks(t, n) {
			let r = this.getTerminalById(t)
			if (!r) return []
			this._terminalLinkCache.delete(t), this._terminalLinkCancellationSource.get(t)?.dispose(!0)
			let s = new _e()
			this._terminalLinkCancellationSource.set(t, s)
			let a = [],
				l = { terminal: r.value, line: n },
				d = []
			for (let m of this._linkProviders)
				d.push(
					so.withAsyncBody(async (f) => {
						s.token.onCancellationRequested(() => f({ provider: m, links: [] }))
						let h = (await m.provideTerminalLinks(l, s.token)) || []
						s.token.isCancellationRequested || f({ provider: m, links: h })
					}),
				)
			let c = await Promise.all(d)
			if (s.token.isCancellationRequested) return []
			let u = new Map()
			for (let m of c)
				m &&
					m.links.length > 0 &&
					a.push(
						...m.links.map((f) => {
							let h = { id: d8++, startIndex: f.startIndex, length: f.length, label: f.tooltip }
							return u.set(h.id, { provider: m.provider, link: f }), h
						}),
					)
			return this._terminalLinkCache.set(t, u), a
		}
		$activateLink(t, n) {
			let r = this._terminalLinkCache.get(t)?.get(n)
			r && r.provider.handleTerminalLink(r.link)
		}
		_onProcessExit(t, n) {
			this._bufferer.stopBuffering(t),
				this._terminalProcesses.delete(t),
				delete this._extensionTerminalAwaitingStart[t]
			let r = this._terminalProcessDisposables[t]
			r && (r.dispose(), delete this._terminalProcessDisposables[t]), this._proxy.$sendProcessExit(t, n)
		}
		getTerminalById(t) {
			return this._getTerminalObjectById(this._terminals, t)
		}
		getTerminalIdByApiObject(t) {
			let n = this._terminals.findIndex((r) => r.value === t)
			return n >= 0 ? n : null
		}
		_getTerminalObjectById(t, n) {
			let r = this._getTerminalObjectIndexById(t, n)
			return r !== null ? t[r] : null
		}
		_getTerminalObjectIndexById(t, n) {
			let r = t.findIndex((i) => i._id === n)
			return r >= 0 ? r : null
		}
		getEnvironmentVariableCollection(t) {
			let n = this._environmentVariableCollections.get(t.identifier.value)
			return (
				n || ((n = this._register(new Hx())), this._setEnvironmentVariableCollection(t.identifier.value, n)),
				n.getScopedEnvironmentVariableCollection(void 0)
			)
		}
		_syncEnvironmentVariableCollection(t, n) {
			let r = ZF(n.map),
				i = e2(n.descriptionMap)
			this._proxy.$setEnvironmentVariableCollection(t, n.persistent, r.length === 0 ? void 0 : r, i)
		}
		$initEnvironmentVariableCollections(t) {
			t.forEach((n) => {
				let r = n[0],
					i = this._register(new Hx(n[1]))
				this._setEnvironmentVariableCollection(r, i)
			})
		}
		$acceptDefaultProfile(t, n) {
			let r = this._defaultProfile
			;(this._defaultProfile = t),
				(this._defaultAutomationProfile = n),
				r?.path !== t.path && this._onDidChangeShell.fire(t.path)
		}
		_setEnvironmentVariableCollection(t, n) {
			this._environmentVariableCollections.set(t, n),
				this._register(
					n.onDidChangeCollection(() => {
						this._syncEnvironmentVariableCollection(t, n)
					}),
				)
		}
	}
Md = R([S(1, Tn), S(2, ie)], Md)
var Hx = class extends $ {
		constructor(t) {
			super()
			this.map = new Map()
			this.scopedCollections = new Map()
			this.descriptionMap = new Map()
			this._persistent = !0
			this._onDidChangeCollection = new E()
			this.map = new Map(t)
		}
		get persistent() {
			return this._persistent
		}
		set persistent(t) {
			;(this._persistent = t), this._onDidChangeCollection.fire()
		}
		get onDidChangeCollection() {
			return this._onDidChangeCollection && this._onDidChangeCollection.event
		}
		getScopedEnvironmentVariableCollection(t) {
			let n = this.getScopeKey(t),
				r = this.scopedCollections.get(n)
			return (
				r ||
					((r = new Dk(this, t)),
					this.scopedCollections.set(n, r),
					this._register(r.onDidChangeCollection(() => this._onDidChangeCollection.fire()))),
				r
			)
		}
		replace(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 1, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		append(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 2, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		prepend(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 3, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		_setIfDiffers(t, n) {
			if (n.options && n.options.applyAtProcessCreation === !1 && !n.options.applyAtShellIntegration)
				throw new Error(
					"EnvironmentVariableMutatorOptions must apply at either process creation or shell integration",
				)
			let r = this.getKey(t, n.scope),
				i = this.map.get(r),
				s = n.options
					? {
							applyAtProcessCreation: n.options.applyAtProcessCreation ?? !1,
							applyAtShellIntegration: n.options.applyAtShellIntegration ?? !1,
						}
					: { applyAtProcessCreation: !0 }
			if (
				!i ||
				i.value !== n.value ||
				i.type !== n.type ||
				i.options?.applyAtProcessCreation !== s.applyAtProcessCreation ||
				i.options?.applyAtShellIntegration !== s.applyAtShellIntegration ||
				i.scope?.workspaceFolder?.index !== n.scope?.workspaceFolder?.index
			) {
				let a = this.getKey(t, n.scope),
					l = { variable: t, ...n, options: s }
				this.map.set(a, l), this._onDidChangeCollection.fire()
			}
		}
		get(t, n) {
			let r = this.getKey(t, n),
				i = this.map.get(r)
			return i ? n2(i) : void 0
		}
		getKey(t, n) {
			let r = this.getScopeKey(n)
			return r.length ? `${t}:::${r}` : t
		}
		getScopeKey(t) {
			return this.getWorkspaceKey(t?.workspaceFolder) ?? ""
		}
		getWorkspaceKey(t) {
			return t ? t.uri.toString() : void 0
		}
		getVariableMap(t) {
			let n = new Map()
			for (let [r, i] of this.map) this.getScopeKey(i.scope) === this.getScopeKey(t) && n.set(i.variable, n2(i))
			return n
		}
		delete(t, n) {
			let r = this.getKey(t, n)
			this.map.delete(r), this._onDidChangeCollection.fire()
		}
		clear(t) {
			if (t?.workspaceFolder) {
				for (let [n, r] of this.map)
					r.scope?.workspaceFolder?.index === t.workspaceFolder.index && this.map.delete(n)
				this.clearDescription(t)
			} else this.map.clear(), this.descriptionMap.clear()
			this._onDidChangeCollection.fire()
		}
		setDescription(t, n) {
			let r = this.getScopeKey(n),
				i = this.descriptionMap.get(r)
			if (!i || i.description !== t) {
				let s
				typeof t == "string"
					? (s = t)
					: (s = t?.value.split(`

`)[0])
				let a = { description: s, scope: n }
				this.descriptionMap.set(r, a), this._onDidChangeCollection.fire()
			}
		}
		getDescription(t) {
			let n = this.getScopeKey(t)
			return this.descriptionMap.get(n)?.description
		}
		clearDescription(t) {
			let n = this.getScopeKey(t)
			this.descriptionMap.delete(n)
		}
	},
	Dk = class {
		constructor(e, t) {
			this.collection = e
			this.scope = t
			this._onDidChangeCollection = new E()
		}
		get persistent() {
			return this.collection.persistent
		}
		set persistent(e) {
			this.collection.persistent = e
		}
		get onDidChangeCollection() {
			return this._onDidChangeCollection && this._onDidChangeCollection.event
		}
		getScoped(e) {
			return this.collection.getScopedEnvironmentVariableCollection(e)
		}
		replace(e, t, n) {
			this.collection.replace(e, t, n, this.scope)
		}
		append(e, t, n) {
			this.collection.append(e, t, n, this.scope)
		}
		prepend(e, t, n) {
			this.collection.prepend(e, t, n, this.scope)
		}
		get(e) {
			return this.collection.get(e, this.scope)
		}
		forEach(e, t) {
			this.collection.getVariableMap(this.scope).forEach((n, r) => e.call(t, r, n, this), this.scope)
		}
		[Symbol.iterator]() {
			return this.collection.getVariableMap(this.scope).entries()
		}
		delete(e) {
			this.collection.delete(e, this.scope), this._onDidChangeCollection.fire(void 0)
		}
		clear() {
			this.collection.clear(this.scope)
		}
		set description(e) {
			this.collection.setDescription(e, this.scope)
		}
		get description() {
			return this.collection.getDescription(this.scope)
		}
	},
	Tp = class extends Md {
		constructor(e, t) {
			super(!1, e, t)
		}
		createTerminal(e, t, n) {
			throw new Sl()
		}
		createTerminalFromOptions(e, t) {
			throw new Sl()
		}
	}
Tp = R([S(0, Tn), S(1, ie)], Tp)
function r2(o) {
	if (!(!o || typeof o == "string")) return "id" in o ? { id: o.id, color: o.color } : o
}
function c8(o) {
	return Bc.isThemeColor(o) ? o : void 0
}
function n2(o) {
	let e = { ...o }
	return delete e.scope, (e.options = e.options ?? void 0), delete e.variable, e
}
var Wx = "__",
	lye = O("IAuthenticationService"),
	dye = O("IAuthenticationExtensionsService")
var Pp = O("IExtHostAuthentication"),
	wp = class {
		constructor(e) {
			this._authenticationProviders = new Map()
			this._onDidChangeSessions = new E()
			this._getSessionTaskSingler = new kk()
			this._proxy = e.getProxy(N.MainThreadAuthentication)
		}
		getExtensionScopedSessionsEvent(e) {
			let t = e.toLowerCase()
			return Te.chain(this._onDidChangeSessions.event, (n) =>
				n
					.filter((r) => !r.extensionIdFilter || r.extensionIdFilter.includes(t))
					.map((r) => ({ provider: r.provider })),
			)
		}
		async getSession(e, t, n, r = {}) {
			let i = we.toKey(e.identifier),
				s = [...n].sort().join(" "),
				l = Object.keys(r)
					.sort()
					.map((d) => `${d}:${!!r[d]}`)
					.join(", ")
			return await this._getSessionTaskSingler.getOrCreate(`${i} ${t} ${s} ${l}`, async () => {
				await this._proxy.$ensureProvider(t)
				let d = e.displayName || e.name
				return this._proxy.$getSession(t, n, i, d, r)
			})
		}
		async getAccounts(e) {
			return await this._proxy.$ensureProvider(e), await this._proxy.$getAccounts(e)
		}
		async removeSession(e, t) {
			let n = this._authenticationProviders.get(e)
			return n ? n.provider.removeSession(t) : this._proxy.$removeSession(e, t)
		}
		registerAuthenticationProvider(e, t, n, r) {
			if (this._authenticationProviders.get(e))
				throw new Error(`An authentication provider with id '${e}' is already registered.`)
			this._authenticationProviders.set(e, {
				label: t,
				provider: n,
				options: r ?? { supportsMultipleAccounts: !1 },
			})
			let i = n.onDidChangeSessions((s) => this._proxy.$sendDidChangeSessions(e, s))
			return (
				this._proxy.$registerAuthenticationProvider(e, t, r?.supportsMultipleAccounts ?? !1),
				new ye(() => {
					i.dispose(),
						this._authenticationProviders.delete(e),
						this._proxy.$unregisterAuthenticationProvider(e)
				})
			)
		}
		async $createSession(e, t, n) {
			let r = this._authenticationProviders.get(e)
			if (r) return await r.provider.createSession(t, n)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		async $removeSession(e, t) {
			let n = this._authenticationProviders.get(e)
			if (n) return await n.provider.removeSession(t)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		async $getSessions(e, t, n) {
			let r = this._authenticationProviders.get(e)
			if (r) return await r.provider.getSessions(t, n)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		$onDidChangeAuthenticationSessions(e, t, n) {
			return (
				e.startsWith(Wx) ||
					this._onDidChangeSessions.fire({ provider: { id: e, label: t }, extensionIdFilter: n }),
				Promise.resolve()
			)
		}
	}
wp = R([S(0, ie)], wp)
var kk = class {
	constructor() {
		this._inFlightPromises = new Map()
	}
	getOrCreate(e, t) {
		let n = this._inFlightPromises.get(e)
		if (n) return n
		let r = t().finally(() => this._inFlightPromises.delete(e))
		return this._inFlightPromises.set(e, r), r
	}
}
var _p = O("IExtHostLanguageModels"),
	Vx = class {
		constructor(e, t) {
			this.option = e
			this.stream = new Ec()
			this.stream = t ?? new Ec()
		}
	},
	Rk = class {
		constructor() {
			this._responseStreams = new Map()
			this._defaultStream = new Ec()
			this._isDone = !1
			let e = this
			this.apiObject = {
				get stream() {
					return e._defaultStream.asyncIterable
				},
				get text() {
					return ci
						.map(e._defaultStream.asyncIterable, (t) => {
							if (t instanceof Pt) return t.value
						})
						.coalesce()
				},
			}
		}
		*_streams() {
			if (this._responseStreams.size > 0) for (let [, e] of this._responseStreams) yield e.stream
			else yield this._defaultStream
		}
		handleFragment(e) {
			if (this._isDone) return
			let t = this._responseStreams.get(e.index)
			t ||
				(this._responseStreams.size === 0 ? (t = new Vx(e.index, this._defaultStream)) : (t = new Vx(e.index)),
				this._responseStreams.set(e.index, t))
			let n
			e.part.type === "text"
				? (n = new Pt(e.part.value))
				: (n = new Io(e.part.toolCallId, e.part.name, e.part.parameters)),
				t.stream.emitOne(n)
		}
		reject(e) {
			this._isDone = !0
			for (let t of this._streams()) t.reject(e)
		}
		resolve() {
			this._isDone = !0
			for (let e of this._streams()) e.resolve()
		}
	},
	Bs = class {
		constructor(e, t, n) {
			this._logService = t
			this._extHostAuthentication = n
			this._onDidChangeModelAccess = new E()
			this._onDidChangeProviders = new E()
			this.onDidChangeProviders = this._onDidChangeProviders.event
			this._languageModels = new Map()
			this._allLanguageModelData = new Map()
			this._modelAccessList = new On()
			this._pendingRequest = new Map()
			this._ignoredFileProviders = new Map()
			this._languageAccessInformationExtensions = new Set()
			this._proxy = e.getProxy(N.MainThreadLanguageModels)
		}
		static {
			this._idPool = 1
		}
		dispose() {
			this._onDidChangeModelAccess.dispose(), this._onDidChangeProviders.dispose()
		}
		registerLanguageModel(e, t, n, r) {
			let i = Bs._idPool++
			this._languageModels.set(i, { extension: e.identifier, provider: n, languageModelId: t })
			let s
			r.auth &&
				(s = {
					providerLabel: e.displayName || e.name,
					accountLabel: typeof r.auth == "object" ? r.auth.label : void 0,
				}),
				this._proxy.$registerLanguageModelProvider(i, `${we.toKey(e.identifier)}/${t}`, {
					extension: e.identifier,
					id: t,
					vendor: r.vendor ?? we.toKey(e.identifier),
					name: r.name ?? "",
					family: r.family ?? "",
					version: r.version,
					maxInputTokens: r.maxInputTokens,
					maxOutputTokens: r.maxOutputTokens,
					auth: s,
					targetExtensions: r.extensions,
					isDefault: r.isDefault,
					isUserSelectable: r.isUserSelectable,
					capabilities: r.capabilities,
				})
			let a = n.onDidReceiveLanguageModelResponse2?.(({ extensionId: l, participant: d, tokenCount: c }) => {
				this._proxy.$whenLanguageModelChatRequestMade(t, new we(l), d, c)
			})
			return q(() => {
				this._languageModels.delete(i), this._proxy.$unregisterProvider(i), a?.dispose()
			})
		}
		async $startChatRequest(e, t, n, r, i, s) {
			let a = this._languageModels.get(e)
			if (!a) throw new Error("Provider not found")
			let l = new ha(async (c) => {
					if (s.isCancellationRequested) {
						this._logService.warn(
							`[CHAT](${a.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`,
						)
						return
					}
					let u
					if (
						(c.part instanceof Io
							? (u = {
									type: "tool_use",
									name: c.part.name,
									parameters: c.part.input,
									toolCallId: c.part.callId,
								})
							: c.part instanceof Pt && (u = { type: "text", value: c.part.value }),
						!u)
					) {
						this._logService.warn(`[CHAT](${a.extension.value}) UNKNOWN part ${JSON.stringify(c)}`)
						return
					}
					this._proxy.$reportResponsePart(t, { index: c.index, part: u })
				}),
				d
			try {
				d = a.provider.provideLanguageModelResponse(r.value.map(_g.to), i, we.toKey(n), l, s)
			} catch (c) {
				throw c
			}
			Promise.resolve(d).then(
				() => {
					this._proxy.$reportResponseDone(t, void 0)
				},
				(c) => {
					this._proxy.$reportResponseDone(t, Po(c))
				},
			)
		}
		$provideTokenLength(e, t, n) {
			let r = this._languageModels.get(e)
			return r ? Promise.resolve(r.provider.provideTokenCount(t, n)) : Promise.resolve(0)
		}
		$acceptChatModelMetadata(e) {
			if (e.added)
				for (let { identifier: t, metadata: n } of e.added)
					this._allLanguageModelData.set(t, { metadata: n, apiObjects: new On() })
			if (e.removed)
				for (let t of e.removed) {
					this._allLanguageModelData.delete(t)
					for (let [n, r] of this._pendingRequest)
						r.languageModelId === t && (r.res.reject(new xt()), this._pendingRequest.delete(n))
				}
			e.added?.forEach((t) => this._fakeAuthPopulate(t.metadata)), this._onDidChangeProviders.fire(void 0)
		}
		async getDefaultLanguageModel(e) {
			let t = kt.find(this._allLanguageModelData.entries(), ([, n]) => !!n.metadata.isDefault)?.[0]
			if (t) return this.getLanguageModelByIdentifier(e, t)
		}
		async getLanguageModelByIdentifier(e, t) {
			let n = this._allLanguageModelData.get(t)
			if (!n) return
			this._isUsingAuth(e.identifier, n.metadata) && (await this._fakeAuthPopulate(n.metadata))
			let r = n.apiObjects.get(e.identifier)
			if (!r) {
				let i = this
				;(r = {
					id: n.metadata.id,
					vendor: n.metadata.vendor,
					family: n.metadata.family,
					version: n.metadata.version,
					name: n.metadata.name,
					capabilities: {
						supportsImageToText: n.metadata.capabilities?.vision ?? !1,
						supportsToolCalling: n.metadata.capabilities?.toolCalling ?? !1,
					},
					maxInputTokens: n.metadata.maxInputTokens,
					countTokens(s, a) {
						if (!i._allLanguageModelData.has(t)) throw Nr.NotFound(t)
						return i._computeTokenLength(t, s, a ?? De.None)
					},
					sendRequest(s, a, l) {
						if (!i._allLanguageModelData.has(t)) throw Nr.NotFound(t)
						return i._sendChatRequest(e, t, s, a ?? {}, l ?? De.None)
					},
				}),
					Object.freeze(r),
					n.apiObjects.set(e.identifier, r)
			}
			return r
		}
		async selectLanguageModels(e, t) {
			let n = await this._proxy.$selectChatModels({ ...t, extension: e.identifier }),
				r = []
			for (let i of n) {
				let s = await this.getLanguageModelByIdentifier(e, i)
				s && r.push(s)
			}
			return r
		}
		async _sendChatRequest(e, t, n, r, i) {
			let s = this._convertMessages(e, n),
				a = e.identifier,
				l = this._allLanguageModelData.get(t)?.metadata
			if (!l || !this._allLanguageModelData.has(t)) throw Nr.NotFound(`Language model '${t}' is unknown.`)
			if (
				this._isUsingAuth(a, l) &&
				(!(await this._getAuthAccess(
					e,
					{ identifier: l.extension, displayName: l.auth.providerLabel },
					r.justification,
					!1,
				)) ||
					!this._modelAccessList.get(a)?.has(l.extension))
			)
				throw Nr.NoPermissions(`Language model '${t}' cannot be used by '${a.value}'.`)
			let d = (Math.random() * 1e6) | 0,
				c = new Rk()
			this._pendingRequest.set(d, { languageModelId: t, res: c })
			try {
				await this._proxy.$tryStartChatRequest(a, t, d, new Xt(s), r, i)
			} catch (u) {
				throw (this._pendingRequest.delete(d), Nr.tryDeserialize(u) ?? u)
			}
			return c.apiObject
		}
		_convertMessages(e, t) {
			let n = []
			for (let r of t) r.role === 3 && M(e, "languageModelSystem"), n.push(_g.from(r))
			return n
		}
		async $acceptResponsePart(e, t) {
			let n = this._pendingRequest.get(e)
			n && n.res.handleFragment(t)
		}
		async $acceptResponseDone(e, t) {
			let n = this._pendingRequest.get(e)
			n && (this._pendingRequest.delete(e), t ? n.res.reject(Nr.tryDeserialize(t) ?? HT(t)) : n.res.resolve())
		}
		async _getAuthAccess(e, t, n, r) {
			let i = Wx + t.identifier.value
			if (await this._extHostAuthentication.getSession(e, i, [], { silent: !0 }))
				return this.$updateModelAccesslist([{ from: e.identifier, to: t.identifier, enabled: !0 }]), !0
			if (r) return !1
			try {
				let a = n ? p("chatAccessWithJustification", "Justification: {1}", t.displayName, n) : void 0
				return (
					await this._extHostAuthentication.getSession(e, i, [], { forceNewSession: { detail: a } }),
					this.$updateModelAccesslist([{ from: e.identifier, to: t.identifier, enabled: !0 }]),
					!0
				)
			} catch {
				return !1
			}
		}
		_isUsingAuth(e, t) {
			return !!t.auth && !we.equals(t.extension, e)
		}
		async _fakeAuthPopulate(e) {
			if (e.auth)
				for (let t of this._languageAccessInformationExtensions)
					try {
						await this._getAuthAccess(t, { identifier: e.extension, displayName: "" }, void 0, !0)
					} catch (n) {
						this._logService.error("Fake Auth request failed"), this._logService.error(n)
					}
		}
		async _computeTokenLength(e, t, n) {
			if (!this._allLanguageModelData.get(e)) throw Nr.NotFound(`Language model '${e}' is unknown.`)
			let i = kt.find(this._languageModels.values(), (s) => s.languageModelId === e)
			return i
				? i.provider.provideTokenCount(t, n)
				: this._proxy.$countTokens(e, typeof t == "string" ? t : _g.from(t), n)
		}
		$updateModelAccesslist(e) {
			let t = new Array()
			for (let { from: n, to: r, enabled: i } of e) {
				let s = this._modelAccessList.get(n) ?? new sr()
				if (s.has(r) !== i) {
					i ? s.add(r) : s.delete(r), this._modelAccessList.set(n, s)
					let l = { from: n, to: r }
					t.push(l), this._onDidChangeModelAccess.fire(l)
				}
			}
		}
		createLanguageModelAccessInformation(e) {
			this._languageAccessInformationExtensions.add(e)
			let t = this,
				n = Te.signal(Te.filter(this._onDidChangeModelAccess.event, (i) => we.equals(i.from, e.identifier))),
				r = Te.signal(this._onDidChangeProviders.event)
			return {
				get onDidChange() {
					return Te.any(n, r)
				},
				canSendRequest(i) {
					let s
					e: for (let [l, d] of t._allLanguageModelData)
						for (let c of d.apiObjects.values())
							if (c === i) {
								s = d.metadata
								break e
							}
					if (!s) return
					if (!t._isUsingAuth(e.identifier, s)) return !0
					let a = t._modelAccessList.get(e.identifier)
					if (a) return a.has(s.extension)
				},
			}
		}
		fileIsIgnored(e, t, n) {
			return M(e, "chatParticipantAdditions"), this._proxy.$fileIsIgnored(t, n)
		}
		async $isFileIgnored(e, t, n) {
			let r = this._ignoredFileProviders.get(e)
			if (!r) throw new Error("Unknown LanguageModelIgnoredFileProvider")
			return (await r.provideFileIgnored(y.revive(t), n)) ?? !1
		}
		registerIgnoredFileProvider(e, t) {
			M(e, "chatParticipantPrivate")
			let n = Bs._idPool++
			return (
				this._proxy.$registerFileIgnoreProvider(n),
				this._ignoredFileProviders.set(n, t),
				q(() => {
					this._proxy.$unregisterFileIgnoreProvider(n), this._ignoredFileProviders.delete(n)
				})
			)
		}
	}
Bs = R([S(0, ie), S(1, te), S(2, Pp)], Bs)
function Dp(o, e = Ie) {
	return _v(o, e) ? o.charAt(0).toUpperCase() + o.slice(1) : o
}
function o2(o, e) {
	return o.replace(/^~($|\/|\\)/, `${e}$1`)
}
var u8 = 60,
	p8 = u8 * 60,
	Ak = p8 * 24,
	rIe = Ak * 7,
	oIe = Ak * 30,
	iIe = Ak * 365
function i2(o) {
	return (
		o.getFullYear() +
		"-" +
		String(o.getMonth() + 1).padStart(2, "0") +
		"-" +
		String(o.getDate()).padStart(2, "0") +
		"T" +
		String(o.getHours()).padStart(2, "0") +
		":" +
		String(o.getMinutes()).padStart(2, "0") +
		":" +
		String(o.getSeconds()).padStart(2, "0") +
		"." +
		(o.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) +
		"Z"
	)
}
var s2 = {
	DateTimeFormat(o, e) {
		try {
			return new Intl.DateTimeFormat(o, e)
		} catch {
			return new Intl.DateTimeFormat(void 0, e)
		}
	},
	Collator(o, e) {
		try {
			return new Intl.Collator(o, e)
		} catch {
			return new Intl.Collator(void 0, e)
		}
	},
	Segmenter(o, e) {
		try {
			return new Intl.Segmenter(o, e)
		} catch {
			return new Intl.Segmenter(void 0, e)
		}
	},
	Locale(o, e) {
		try {
			return new Intl.Locale(o, e)
		} catch {
			return new Intl.Locale(li, e)
		}
	},
}
var kp = class o {
	constructor(e) {
		let t = iE(e)
		;(this._defaultValue = t), (this._asciiMap = o._createAsciiMap(t)), (this._map = new Map())
	}
	static _createAsciiMap(e) {
		let t = new Uint8Array(256)
		return t.fill(e), t
	}
	set(e, t) {
		let n = iE(t)
		e >= 0 && e < 256 ? (this._asciiMap[e] = n) : this._map.set(e, n)
	}
	get(e) {
		return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue
	}
	clear() {
		this._asciiMap.fill(this._defaultValue), this._map.clear()
	}
}
var Ok = class extends kp {
		constructor(t, n) {
			super(0)
			this._segmenter = null
			this._cachedLine = null
			this._cachedSegments = []
			;(this.intlSegmenterLocales = n),
				this.intlSegmenterLocales.length > 0
					? (this._segmenter = s2.Segmenter(this.intlSegmenterLocales, { granularity: "word" }))
					: (this._segmenter = null)
			for (let r = 0, i = t.length; r < i; r++) this.set(t.charCodeAt(r), 2)
			this.set(32, 1), this.set(9, 1)
		}
		findPrevIntlWordBeforeOrAtOffset(t, n) {
			let r = null
			for (let i of this._getIntlSegmenterWordsOnLine(t)) {
				if (i.index > n) break
				r = i
			}
			return r
		}
		findNextIntlWordAtOrAfterOffset(t, n) {
			for (let r of this._getIntlSegmenterWordsOnLine(t)) if (!(r.index < n)) return r
			return null
		}
		_getIntlSegmenterWordsOnLine(t) {
			return this._segmenter
				? this._cachedLine === t
					? this._cachedSegments
					: ((this._cachedLine = t),
						(this._cachedSegments = this._filterWordSegments(this._segmenter.segment(t))),
						this._cachedSegments)
				: []
		}
		_filterWordSegments(t) {
			let n = []
			for (let r of t) this._isWordLike(r) && n.push(r)
			return n
		}
		_isWordLike(t) {
			return !!t.isWordLike
		}
	},
	a2 = new _o(10)
function l2(o, e) {
	let t = `${o}/${e.join(",")}`,
		n = a2.get(t)
	return n || ((n = new Ok(o, e)), a2.set(t, n)), n
}
var jg = class {
	constructor(e, t, n, r) {
		;(this.searchString = e), (this.isRegex = t), (this.matchCase = n), (this.wordSeparators = r)
	}
	parseSearchRequest() {
		if (this.searchString === "") return null
		let e
		this.isRegex
			? (e = Lk(this.searchString))
			: (e =
					this.searchString.indexOf(`
`) >= 0)
		let t = null
		try {
			t = bv(this.searchString, this.isRegex, {
				matchCase: this.matchCase,
				wholeWord: !1,
				multiline: e,
				global: !0,
				unicode: !0,
			})
		} catch {
			return null
		}
		if (!t) return null
		let n = !this.isRegex && !e
		return (
			n && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (n = this.matchCase),
			new kb(t, this.wordSeparators ? l2(this.wordSeparators, []) : null, n ? this.searchString : null)
		)
	}
}
function Lk(o) {
	if (!o || o.length === 0) return !1
	for (let e = 0, t = o.length; e < t; e++) {
		let n = o.charCodeAt(e)
		if (n === 10) return !0
		if (n === 92) {
			if ((e++, e >= t)) break
			let r = o.charCodeAt(e)
			if (r === 110 || r === 114 || r === 87) return !0
		}
	}
	return !1
}
function Mk(o, e, t) {
	if (!t) return new Yl(o, null)
	let n = []
	for (let r = 0, i = e.length; r < i; r++) n[r] = e[r]
	return new Yl(o, n)
}
function f8(o, e, t, n, r) {
	if (n === 0) return !0
	let i = e.charCodeAt(n - 1)
	if (o.get(i) !== 0 || i === 13 || i === 10) return !0
	if (r > 0) {
		let s = e.charCodeAt(n)
		if (o.get(s) !== 0) return !0
	}
	return !1
}
function g8(o, e, t, n, r) {
	if (n + r === t) return !0
	let i = e.charCodeAt(n + r)
	if (o.get(i) !== 0 || i === 13 || i === 10) return !0
	if (r > 0) {
		let s = e.charCodeAt(n + r - 1)
		if (o.get(s) !== 0) return !0
	}
	return !1
}
function Fk(o, e, t, n, r) {
	return f8(o, e, t, n, r) && g8(o, e, t, n, r)
}
var Bx = class {
	constructor(e, t) {
		;(this._wordSeparators = e),
			(this._searchRegex = t),
			(this._prevMatchStartIndex = -1),
			(this._prevMatchLength = 0)
	}
	reset(e) {
		;(this._searchRegex.lastIndex = e), (this._prevMatchStartIndex = -1), (this._prevMatchLength = 0)
	}
	next(e) {
		let t = e.length,
			n
		do {
			if (this._prevMatchStartIndex + this._prevMatchLength === t || ((n = this._searchRegex.exec(e)), !n))
				return null
			let r = n.index,
				i = n[0].length
			if (r === this._prevMatchStartIndex && i === this._prevMatchLength) {
				if (i === 0) {
					pE(e, t, this._searchRegex.lastIndex) > 65535
						? (this._searchRegex.lastIndex += 2)
						: (this._searchRegex.lastIndex += 1)
					continue
				}
				return null
			}
			if (
				((this._prevMatchStartIndex = r),
				(this._prevMatchLength = i),
				!this._wordSeparators || Fk(this._wordSeparators, e, t, r, i))
			)
				return n
		} while (n)
		return null
	}
}
function d2(o) {
	return o.scheme !== W.file && o.scheme !== W.vscodeRemote
}
function h8(o) {
	if (o.folders.length) return o.folders.every((e) => d2(e.uri)) ? o.folders[0].uri : void 0
	if (o.configuration && d2(o.configuration)) return o.configuration
}
function c2(o) {
	return h8(o)?.scheme
}
var $x = Zf
var zx = O("remoteAgentService"),
	DIe = new (class {
		constructor() {
			this.maxSampleCount = 5
			this.sampleDelay = 2e3
			this.initial = []
			this.maxInitialCount = 3
			this.average = []
			this.maxAverageCount = 100
			this.highLatencyMultiple = 2
			this.highLatencyMinThreshold = 500
			this.highLatencyMaxThreshold = 1500
			this.lastMeasurement = void 0
		}
		get latency() {
			return this.lastMeasurement
		}
		async measure(o) {
			let e = 1 / 0
			for (let n = 0; n < this.maxSampleCount; n++) {
				let r = await o.getRoundTripTime()
				if (r === void 0) return
				;(e = Math.min(e, r / 2)), await Wt(this.sampleDelay)
			}
			this.average.push(e), this.average.length > this.maxAverageCount && this.average.shift()
			let t
			return (
				this.initial.length < this.maxInitialCount
					? this.initial.push(e)
					: (t = this.initial.reduce((n, r) => n + r, 0) / this.initial.length),
				(this.lastMeasurement = {
					initial: t,
					current: e,
					average: this.average.reduce((n, r) => n + r, 0) / this.average.length,
					high:
						typeof t > "u"
							? !1
							: e > this.highLatencyMaxThreshold ||
								(e > this.highLatencyMinThreshold && e > t * this.highLatencyMultiple),
				}),
				this.lastMeasurement
			)
		}
	})()
var u2 = O("pathService"),
	Rp = class {
		constructor(e, t, n, r) {
			this.localUserHome = e
			this.remoteAgentService = t
			this.environmentService = n
			this.contextService = r
			;(this.resolveOS = (async () => (await this.remoteAgentService.getEnvironment())?.os || wl)()),
				(this.resolveUserHome = (async () => {
					let i = await this.remoteAgentService.getEnvironment()
					return (this.maybeUnresolvedUserHome = i?.userHome ?? e)
				})())
		}
		hasValidBasename(e, t, n) {
			return typeof t == "string" || typeof t > "u"
				? this.resolveOS.then((r) => this.doHasValidBasename(e, r, t))
				: this.doHasValidBasename(e, t, n)
		}
		doHasValidBasename(e, t, n) {
			return e.scheme === W.file || e.scheme === W.vscodeRemote ? wA(n ?? Ht(e), t === 1) : !0
		}
		get defaultUriScheme() {
			return Rp.findDefaultUriScheme(this.environmentService, this.contextService)
		}
		static findDefaultUriScheme(e, t) {
			if (e.remoteAuthority) return W.vscodeRemote
			let n = c2(t.getWorkspace())
			if (n) return n
			let r = t.getWorkspace().folders[0]
			if (r) return r.uri.scheme
			let i = t.getWorkspace().configuration
			return i ? i.scheme : W.file
		}
		userHome(e) {
			return e?.preferLocal ? this.localUserHome : this.resolveUserHome
		}
		get resolvedUserHome() {
			return this.maybeUnresolvedUserHome
		}
		get path() {
			return this.resolveOS.then((e) => (e === 1 ? qt : Ue))
		}
		async fileURI(e) {
			let t = ""
			if (((await this.resolveOS) === 1 && (e = e.replace(/\\/g, "/")), e[0] === "/" && e[1] === "/")) {
				let r = e.indexOf("/", 2)
				r === -1 ? ((t = e.substring(2)), (e = "/")) : ((t = e.substring(2, r)), (e = e.substring(r) || "/"))
			}
			return y.from({ scheme: W.file, authority: t, path: e, query: "", fragment: "" })
		}
	}
Rp = R([S(1, zx), S(2, $x), S(3, mi)], Rp)
function b8(o) {
	return typeof o == "object" && "uri" in o && "pattern" in o
}
var Gg = class {
	constructor(e, t, n, r, i, s) {
		this.configurationService = e
		this.workspaceContextService = t
		this.editorGroupsService = n
		this.logService = r
		this.pathService = i
		this.uriIdentityService = s
	}
	aiText(e, t, n = {}) {
		return { ...this.commonQuery(t?.map(Nf), n), type: 3, contentPattern: e }
	}
	text(e, t, n = {}) {
		e = this.getContentPattern(e, n)
		let r = this.configurationService.getValue(),
			i = t && t.some((a) => !this.configurationService.getValue({ resource: a }).search.useRipgrep)
		return {
			...this.commonQuery(t?.map(Nf), n),
			type: 2,
			contentPattern: e,
			previewOptions: n.previewOptions,
			maxFileSize: n.maxFileSize,
			usePCRE2: r.search.usePCRE2 || i || !1,
			surroundingContext: n.surroundingContext,
			userDisabledExcludesAndIgnoreFiles: n.disregardExcludeSettings && n.disregardIgnoreFiles,
		}
	}
	getContentPattern(e, t) {
		let n = this.configurationService.getValue()
		e.isRegExp && (e.pattern = e.pattern.replace(/\r?\n/g, "\\n"))
		let r = { ...e, wordSeparators: n.editor.wordSeparators }
		return (
			this.isCaseSensitive(e, t) && (r.isCaseSensitive = !0),
			this.isMultiline(e) && (r.isMultiline = !0),
			t.notebookSearchConfig?.includeMarkupInput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookMarkdownInput = t.notebookSearchConfig.includeMarkupInput)),
			t.notebookSearchConfig?.includeMarkupPreview &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookMarkdownPreview = t.notebookSearchConfig.includeMarkupPreview)),
			t.notebookSearchConfig?.includeCodeInput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookCellInput = t.notebookSearchConfig.includeCodeInput)),
			t.notebookSearchConfig?.includeOutput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookCellOutput = t.notebookSearchConfig.includeOutput)),
			r
		)
	}
	file(e, t = {}) {
		return {
			...this.commonQuery(e, t),
			type: 1,
			filePattern: t.filePattern ? t.filePattern.trim() : t.filePattern,
			exists: t.exists,
			sortByScore: t.sortByScore,
			cacheKey: t.cacheKey,
			shouldGlobMatchFilePattern: t.shouldGlobSearch,
		}
	}
	handleIncludeExclude(e, t) {
		if (!e) return {}
		if (Array.isArray(e)) {
			if (((e = e.filter((n) => n.length > 0).map(qx)), !e.length)) return {}
		} else e = qx(e)
		return t ? this.parseSearchPaths(e) : { pattern: Nk(...(Array.isArray(e) ? e : [e])) }
	}
	commonQuery(e = [], t = {}) {
		let n = Array.isArray(t.excludePattern) ? t.excludePattern.map((c) => c.pattern).flat() : t.excludePattern
		n = n?.length === 1 ? n[0] : n
		let r = this.handleIncludeExclude(t.includePattern, t.expandPatterns),
			i = this.handleIncludeExclude(n, t.expandPatterns),
			s = e.length > 1,
			a = (
				r.searchPaths && r.searchPaths.length
					? r.searchPaths.map((c) => this.getFolderQueryForSearchPath(c, t, i))
					: e.map((c) => this.getFolderQueryForRoot(c, t, i, s))
			).filter((c) => !!c),
			l = {
				_reason: t._reason,
				folderQueries: a,
				usingSearchPaths: !!(r.searchPaths && r.searchPaths.length),
				extraFileResources: t.extraFileResources,
				excludePattern: i.pattern,
				includePattern: r.pattern,
				onlyOpenEditors: t.onlyOpenEditors,
				maxResults: t.maxResults,
				onlyFileScheme: t.onlyFileScheme,
			}
		if (t.onlyOpenEditors) {
			let c = Ye(this.editorGroupsService.groups.flatMap((f) => f.editors.map((h) => h.resource)))
			this.logService.trace("QueryBuilder#commonQuery - openEditor URIs", JSON.stringify(c))
			let u = c.filter((f) => sk(l, f.fsPath)),
				m = this.commonQueryFromFileList(u)
			return (
				this.logService.trace("QueryBuilder#commonQuery - openEditor Query", JSON.stringify(m)), { ...l, ...m }
			)
		}
		let d = t.extraFileResources && t.extraFileResources.filter((c) => sk(l, c.fsPath))
		return (l.extraFileResources = d && d.length ? d : void 0), l
	}
	commonQueryFromFileList(e) {
		let t = [],
			n = new ft(),
			r = {},
			i = !1
		return (
			e.forEach((s) => {
				if (s.scheme === W.walkThrough) return
				if (WA(s)) {
					let l =
							this.workspaceContextService.getWorkspaceFolder(s)?.uri ??
							this.uriIdentityService.extUri.dirname(s),
						d = n.get(l)
					d || ((i = !0), (d = { folder: l, includePattern: {} }), t.push(d), n.set(l, d))
					let c = Oo(l.fsPath, s.fsPath)
					Do(d.includePattern)[c.replace(/\\/g, "/")] = !0
				} else s.fsPath && ((i = !0), (r[s.fsPath] = !0))
			}),
			{ folderQueries: t, includePattern: r, usingSearchPaths: !0, excludePattern: i ? void 0 : { "**/*": !0 } }
		)
	}
	isCaseSensitive(e, t) {
		if (t.isSmartCase) {
			if (e.isRegExp) {
				if (fE(e.pattern, !0)) return !0
			} else if (fE(e.pattern)) return !0
		}
		return !!e.isCaseSensitive
	}
	isMultiline(e) {
		return e.isMultiline ||
			(e.isRegExp && Lk(e.pattern)) ||
			e.pattern.indexOf(`
`) >= 0
			? !0
			: !!e.isMultiline
	}
	parseSearchPaths(e) {
		let t = (u) => In(u) || /^\.\.?([\/\\]|$)/.test(u),
			r = (Array.isArray(e) ? e : I8(e)).map((u) => {
				let m = this.pathService.resolvedUserHome
				return m ? o2(u, m.scheme === W.file ? m.fsPath : m.path) : u
			}),
			i = sc(r, (u) => (t(u) ? "searchPaths" : "exprSegments")),
			s = (i.exprSegments || [])
				.map((u) => Dr(u, "/"))
				.map((u) => Dr(u, "\\"))
				.map((u) => (u[0] === "." && (u = "*" + u), x8(u))),
			a = {},
			l = this.expandSearchPathPatterns(i.searchPaths || [])
		l && l.length && (a.searchPaths = l)
		let d = s.flat(),
			c = Nk(...d)
		return c && (a.pattern = c), a
	}
	getExcludesForFolder(e, t) {
		return t.disregardExcludeSettings ? void 0 : DF(e, !t.disregardSearchExcludeSettings)
	}
	expandSearchPathPatterns(e) {
		if (!e || !e.length) return []
		let t = e.flatMap((r) => {
				let { pathPortion: i, globPortion: s } = y8(r)
				return (
					s && (s = Uk(s)), this.expandOneSearchPath(i).flatMap((l) => this.resolveOneSearchPathPattern(l, s))
				)
			}),
			n = new Map()
		return (
			t.forEach((r) => {
				let i = r.searchPath.toString(),
					s = n.get(i)
				s
					? r.pattern && ((s.pattern = s.pattern || {}), (s.pattern[r.pattern] = !0))
					: n.set(i, { searchPath: r.searchPath, pattern: r.pattern ? Nk(r.pattern) : void 0 })
			}),
			Array.from(n.values())
		)
	}
	expandOneSearchPath(e) {
		if (In(e)) {
			let t = this.workspaceContextService.getWorkspace().folders
			return t[0] && t[0].uri.scheme !== W.file
				? [{ searchPath: t[0].uri.with({ path: e }) }]
				: [{ searchPath: y.file(jn(e)) }]
		}
		if (this.workspaceContextService.getWorkbenchState() === 2) {
			let t = this.workspaceContextService.getWorkspace().folders[0].uri
			if (((e = qx(e)), e.startsWith("../") || e === "..")) {
				let r = Ue.resolve(t.path, e)
				return [{ searchPath: t.with({ path: r }) }]
			}
			let n = Uk(e)
			return [{ searchPath: t, pattern: n }]
		} else {
			if (e === "./" || e === ".\\") return []
			{
				let t = e.replace(/^\.[\/\\]/, ""),
					r = this.workspaceContextService
						.getWorkspace()
						.folders.map((i) => {
							let s = t.match(new RegExp(`^${_r(i.name)}(?:/(.*)|$)`))
							return s ? { match: s, folder: i } : null
						})
						.filter(rr)
				if (r.length)
					return r.map((i) => {
						let s = i.match[1]
						return { searchPath: i.folder.uri, pattern: s && Uk(s) }
					})
				{
					let i = e.match(/\.[\/\\](.+)[\/\\]?/),
						s = i ? i[1] : e,
						a = p("search.noWorkspaceWithName", "Workspace folder does not exist: {0}", s)
					throw new Error(a)
				}
			}
		}
	}
	resolveOneSearchPathPattern(e, t) {
		let n = e.pattern && t ? `${e.pattern}/${t}` : e.pattern || t,
			r = [{ searchPath: e.searchPath, pattern: n }]
		return n && !n.endsWith("**") && r.push({ searchPath: e.searchPath, pattern: n + "/**" }), r
	}
	getFolderQueryForSearchPath(e, t, n) {
		let r = this.getFolderQueryForRoot(Nf(e.searchPath), t, n, !1)
		return r ? { ...r, includePattern: e.pattern } : null
	}
	getFolderQueryForRoot(e, t, n, r) {
		let i,
			s = y.isUri(e) ? e : e.uri,
			a = t.excludePattern?.map((f) => {
				let h = t.excludePattern && b8(f) ? f.uri : void 0
				return !h || !(y.isUri(e) && this.uriIdentityService.extUri.isEqual(e, h)) ? h : void 0
			})
		if ((a?.length || (a = [void 0]), n.searchPaths)) {
			let f = n.searchPaths.filter((h) => qr(h.searchPath, s))[0]
			if (f && !f.pattern) return null
			f && (i = f.pattern)
		}
		let l = this.configurationService.getValue({ resource: s }),
			c = { ...(this.getExcludesForFolder(l, t) || {}), ...(i || {}) },
			u = y.isUri(e) ? Ht(e) : e.name,
			m = a.map((f) => (Object.keys(c).length > 0 ? { folder: f, pattern: c } : void 0)).filter((f) => f)
		return {
			folder: s,
			folderName: r ? u : void 0,
			excludePattern: m,
			fileEncoding: l.files && l.files.encoding,
			disregardIgnoreFiles:
				typeof t.disregardIgnoreFiles == "boolean" ? t.disregardIgnoreFiles : !l.search.useIgnoreFiles,
			disregardGlobalIgnoreFiles:
				typeof t.disregardGlobalIgnoreFiles == "boolean"
					? t.disregardGlobalIgnoreFiles
					: !l.search.useGlobalIgnoreFiles,
			disregardParentIgnoreFiles:
				typeof t.disregardParentIgnoreFiles == "boolean"
					? t.disregardParentIgnoreFiles
					: !l.search.useParentIgnoreFiles,
			ignoreSymlinks: typeof t.ignoreSymlinks == "boolean" ? t.ignoreSymlinks : !l.search.followSymlinks,
		}
	}
}
Gg = R([S(0, vr), S(1, mi), S(2, Oy), S(3, te), S(4, u2), S(5, ay)], Gg)
function y8(o) {
	let e = o.match(/[\*\{\}\(\)\[\]\?]/)
	if (e) {
		let t = e.index,
			n = o.substr(0, t).match(/[/|\\][^/\\]*$/)
		if (n) {
			let r = o.substr(0, n.index)
			return r.match(/[/\\]/) || (r += "/"), { pathPortion: r, globPortion: o.substr((n.index || 0) + 1) }
		}
	}
	return { pathPortion: o }
}
function Nk(...o) {
	return o.length ? o.reduce((e, t) => ((e[t] = !0), e), Object.create(null)) : void 0
}
function I8(o) {
	return rd(o, ",")
		.map((e) => e.trim())
		.filter((e) => !!e.length)
}
function x8(o) {
	return [`**/${o}/**`, `**/${o}`].map((t) => t.replace(/\*\*\/\*\*/g, "**"))
}
function qx(o) {
	return o.replace(/\\/g, "/")
}
function Uk(o) {
	return qx(o).replace(/^\.\//, "").replace(/\/+$/g, "")
}
var C8 = 7e3
function m2(o, e) {
	let t = e.activationEvents
	if (!t) return Promise.resolve(void 0)
	let n = [],
		r = []
	for (let c of t)
		if (/^workspaceContains:/.test(c)) {
			let u = c.substr(18)
			u.indexOf("*") >= 0 || u.indexOf("?") >= 0 || o.forceUsingSearch ? r.push(u) : n.push(u)
		}
	if (n.length === 0 && r.length === 0) return Promise.resolve(void 0)
	let { promise: i, resolve: s } = ff(),
		a = (c) => s({ activationEvent: c }),
		l = Promise.all(n.map((c) => S8(o, c, a))).then(() => {}),
		d = T8(o, e.identifier, r, a)
	return (
		Promise.all([l, d]).then(() => {
			s(void 0)
		}),
		i
	)
}
async function S8(o, e, t) {
	for (let n of o.folders)
		if (await o.exists(ct(y.revive(n), e))) {
			t(`workspaceContains:${e}`)
			return
		}
}
async function T8(o, e, t, n) {
	if (t.length === 0) return Promise.resolve(void 0)
	let r = new _e(),
		i = o.checkExists(o.folders, t, r.token),
		s = setTimeout(async () => {
			r.cancel(),
				o.logService.info(
					`Not activating extension '${e.value}': Timed out while searching for 'workspaceContains' pattern ${t.join(",")}`,
				)
		}, C8),
		a = !1
	try {
		a = await i
	} catch (l) {
		bn(l) || Be(l)
	}
	r.dispose(), clearTimeout(s), a && n(`workspaceContains:${t.join(",")}`)
}
var Ap = class {
		constructor(e) {
			this._onDidChangePassword = new E()
			this.onDidChangePassword = this._onDidChangePassword.event
			this._proxy = e.getProxy(N.MainThreadSecretState)
		}
		async $onDidChangePassword(e) {
			this._onDidChangePassword.fire(e)
		}
		get(e, t) {
			return this._proxy.$getPassword(e, t)
		}
		store(e, t, n) {
			return this._proxy.$setPassword(e, t, n)
		}
		delete(e, t) {
			return this._proxy.$deletePassword(e, t)
		}
	},
	Op = O("IExtHostSecretState")
var Kx = class {
	constructor(e, t) {
		this.disposables = new Q()
		;(this._id = we.toKey(e.identifier)),
			(this.#e = t),
			(this.onDidChange = Te.map(
				Te.filter(this.#e.onDidChangePassword, (n) => n.extensionId === this._id),
				(n) => ({ key: n.key }),
				this.disposables,
			))
	}
	#e
	dispose() {
		this.disposables.dispose()
	}
	get(e) {
		return this.#e.get(this._id, e)
	}
	store(e, t) {
		return this.#e.store(this._id, e, t)
	}
	delete(e) {
		return this.#e.delete(this._id, e)
	}
}
var Lp = class {
	constructor(e, t, n) {
		this.logService = n
		this.bundleCache = new Map()
		;(this._proxy = t.getProxy(N.MainThreadLocalization)),
			(this.currentLanguage = e.environment.appLanguage),
			(this.isDefaultLanguage = this.currentLanguage === li)
	}
	getMessage(e, t) {
		let { message: n, args: r, comment: i } = t
		if (this.isDefaultLanguage) return dE(n, r ?? {})
		let s = n
		i && i.length > 0 && (s += `/${Array.isArray(i) ? i.join("") : i}`)
		let a = this.bundleCache.get(e)?.contents[s]
		return (
			a ||
				this.logService.warn(
					`Using default string since no string found in i18n bundle that has the key: ${s}`,
				),
			dE(a ?? n, r ?? {})
		)
	}
	getBundle(e) {
		return this.bundleCache.get(e)?.contents
	}
	getBundleUri(e) {
		return this.bundleCache.get(e)?.uri
	}
	async initializeLocalizedMessages(e) {
		if (this.isDefaultLanguage || (!e.l10n && !e.isBuiltin) || this.bundleCache.has(e.identifier.value)) return
		let t,
			n = await this.getBundleLocation(e)
		if (!n) {
			this.logService.error(`No bundle location found for extension ${e.identifier.value}`)
			return
		}
		try {
			let r = await this._proxy.$fetchBundleContents(n),
				i = JSON.parse(r)
			t = e.isBuiltin ? i.contents?.bundle : i
		} catch (r) {
			this.logService.error(`Failed to load translations for ${e.identifier.value} from ${n}: ${r.message}`)
			return
		}
		t && this.bundleCache.set(e.identifier.value, { contents: t, uri: n })
	}
	async getBundleLocation(e) {
		if (e.isBuiltin) {
			let t = await this._proxy.$fetchBuiltInBundleUri(e.identifier.value, this.currentLanguage)
			return y.revive(t)
		}
		return e.l10n ? y.joinPath(e.extensionLocation, e.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0
	}
}
Lp = R([S(0, Xe), S(1, ie), S(2, te)], Lp)
var Mp = O("IExtHostLocalizationService")
var Np = O("IExtHostManagedSockets"),
	Fp = class {
		constructor(e) {
			this._remoteSocketIdCounter = 0
			this._factory = null
			this._managedRemoteSockets = new Map()
			this._proxy = e.getProxy(N.MainThreadManagedSockets)
		}
		setFactory(e, t) {
			for (let n of this._managedRemoteSockets.values()) n.dispose()
			this._factory && this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId),
				(this._factory = new Hk(e, t)),
				this._proxy.$registerSocketFactory(this._factory.socketFactoryId)
		}
		async $openRemoteSocket(e) {
			if (!this._factory || this._factory.socketFactoryId !== e) throw new Error(`No socket factory with id ${e}`)
			let t = ++this._remoteSocketIdCounter,
				n = await this._factory.makeConnection(),
				r = new Q()
			return (
				this._managedRemoteSockets.set(t, new Wk(t, n, r)),
				r.add(q(() => this._managedRemoteSockets.delete(t))),
				r.add(
					n.onDidEnd(() => {
						this._proxy.$onDidManagedSocketEnd(t), r.dispose()
					}),
				),
				r.add(
					n.onDidClose((i) => {
						this._proxy.$onDidManagedSocketClose(t, i?.stack ?? i?.message), r.dispose()
					}),
				),
				r.add(n.onDidReceiveMessage((i) => this._proxy.$onDidManagedSocketHaveData(t, z.wrap(i)))),
				t
			)
		}
		$remoteSocketWrite(e, t) {
			this._managedRemoteSockets.get(e)?.actual.send(t.buffer)
		}
		$remoteSocketEnd(e) {
			let t = this._managedRemoteSockets.get(e)
			t && (t.actual.end(), t.dispose())
		}
		async $remoteSocketDrain(e) {
			await this._managedRemoteSockets.get(e)?.actual.drain?.()
		}
	}
Fp = R([S(0, ie)], Fp)
var Hk = class {
		constructor(e, t) {
			this.socketFactoryId = e
			this.makeConnection = t
		}
	},
	Wk = class extends $ {
		constructor(t, n, r) {
			super()
			this.socketId = t
			this.actual = n
			this._register(r)
		}
	}
var $k = O("IHostUtils"),
	al = class extends $ {
		constructor(t, n, r, i, s, a, l, d, c, u, m, f, h) {
			super()
			this._extHostManagedSockets = f
			this._extHostLanguageModels = h
			this._onDidChangeRemoteConnectionData = this._register(new E())
			this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event
			this._realPathCache = new Map()
			this._isTerminating = !1
			;(this._hostUtils = n),
				(this._extHostContext = r),
				(this._initData = l),
				(this._extHostWorkspace = i),
				(this._extHostConfiguration = s),
				(this._logService = a),
				(this._extHostTunnelService = c),
				(this._extHostTerminalService = u),
				(this._extHostLocalizationService = m),
				(this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(N.MainThreadWorkspace)),
				(this._mainThreadTelemetryProxy = this._extHostContext.getProxy(N.MainThreadTelemetry)),
				(this._mainThreadExtensionsProxy = this._extHostContext.getProxy(N.MainThreadExtensionService)),
				(this._almostReadyToRunExtensions = new dn()),
				(this._readyToStartExtensionHost = new dn()),
				(this._readyToRunExtensions = new dn()),
				(this._eagerExtensionsActivated = new dn()),
				(this._activationEventsReader = new Bk(this._initData.extensions.activationEvents)),
				(this._globalRegistry = new Ws(this._activationEventsReader, this._initData.extensions.allExtensions))
			let g = new sr(this._initData.extensions.myExtensions)
			;(this._myRegistry = new Ws(this._activationEventsReader, h2(this._globalRegistry, g))),
				na &&
					(this._logService.info(
						`Creating extension host with the following global extensions: ${Up(this._globalRegistry)}`,
					),
					this._logService.info(
						`Creating extension host with the following local extensions: ${Up(this._myRegistry)}`,
					)),
				(this._storage = new mp(this._extHostContext, this._logService)),
				(this._secretState = new Ap(this._extHostContext)),
				(this._storagePath = d),
				(this._instaService = this._store.add(
					t.createChild(new fa([fp, this._storage], [Op, this._secretState])),
				)),
				(this._activator = this._register(
					new cp(
						this._myRegistry,
						this._globalRegistry,
						{
							onExtensionActivationError: (I, C, T) => {
								this._mainThreadExtensionsProxy.$onExtensionActivationError(I, Po(C), T)
							},
							actualActivateExtension: async (I, C) => {
								if (Ws.isHostExtension(I, this._myRegistry, this._globalRegistry))
									return await this._mainThreadExtensionsProxy.$activateExtension(I, C), new Ax()
								let T = this._myRegistry.getExtensionDescription(I)
								return this._activateExtension(T, C)
							},
						},
						this._logService,
					),
				)),
				(this._extensionPathIndex = null),
				(this._resolvers = Object.create(null)),
				(this._started = !1),
				(this._remoteConnectionData = this._initData.remote.connectionData)
		}
		getRemoteConnectionData() {
			return this._remoteConnectionData
		}
		async initialize() {
			try {
				await this._beforeAlmostReadyToRunExtensions(),
					this._almostReadyToRunExtensions.open(),
					await this._extHostWorkspace.waitForInitializeCall(),
					Ct("code/extHost/ready"),
					this._readyToStartExtensionHost.open(),
					this._initData.autoStart && this._startExtensionHost()
			} catch (t) {
				Be(t)
			}
		}
		async _deactivateAll() {
			this._storagePath.onWillDeactivateAll()
			let t = []
			try {
				t = this._myRegistry
					.getAllExtensionDescriptions()
					.map((s) => s.identifier)
					.filter((s) => this.isActivated(s))
					.map((s) => this._deactivate(s))
			} catch {}
			await Promise.all(t)
		}
		terminate(t, n = 0) {
			if (this._isTerminating) return
			;(this._isTerminating = !0),
				this._logService.info(`Extension host terminating: ${t}`),
				this._logService.flush(),
				this._extHostTerminalService.dispose(),
				this._activator.dispose(),
				jm((i) => {
					this._logService.error(i)
				}),
				this._extHostContext.dispose()
			let r = this._deactivateAll()
			Promise.race([Wt(5e3), r]).finally(() => {
				this._hostUtils.pid
					? this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${n}`)
					: this._logService.info(`Extension host exiting with code ${n}`),
					this._logService.flush(),
					this._logService.dispose(),
					this._hostUtils.exit(n)
			})
		}
		isActivated(t) {
			return this._readyToRunExtensions.isOpen() ? this._activator.isActivated(t) : !1
		}
		async getExtension(t) {
			let n = await this._mainThreadExtensionsProxy.$getExtension(t)
			return (
				n && { ...n, identifier: new we(n.identifier.value), extensionLocation: y.revive(n.extensionLocation) }
			)
		}
		_activateByEvent(t, n) {
			return gt.logIncoming(0, 0, 0, "_activateByEvent: " + t), this._activator.activateByEvent(t, n)
		}
		_activateById(t, n) {
			return this._activator.activateById(t, n)
		}
		activateByIdWithErrors(t, n) {
			return this._activateById(t, n).then(() => {
				let r = this._activator.getActivatedExtension(t)
				if (r.activationFailed) return Promise.reject(r.activationFailedError)
			})
		}
		getExtensionRegistry() {
			return this._readyToRunExtensions.wait().then((t) => this._myRegistry)
		}
		getExtensionExports(t) {
			if (this._readyToRunExtensions.isOpen()) return this._activator.getActivatedExtension(t).exports
			try {
				return this._activator.getActivatedExtension(t).exports
			} catch {
				return null
			}
		}
		async _realPathExtensionUri(t) {
			if (t.scheme === W.file && this._hostUtils.fsRealpath) {
				let n = t.fsPath
				this._realPathCache.has(n) || this._realPathCache.set(n, this._hostUtils.fsRealpath(n))
				let r = await this._realPathCache.get(n)
				return y.file(r)
			}
			return t
		}
		async getExtensionPathIndex() {
			return (
				this._extensionPathIndex ||
					(this._extensionPathIndex = this._createExtensionPathIndex(
						this._myRegistry.getAllExtensionDescriptions(),
					).then((t) => new Vk(t))),
				this._extensionPathIndex
			)
		}
		async _createExtensionPathIndex(t) {
			let n = hr.forUris((r) => Rl.ignorePathCasing(r))
			return (
				await Promise.all(
					t.map(async (r) => {
						if (this._getEntryPoint(r)) {
							let i = await this._realPathExtensionUri(r.extensionLocation)
							n.set(i, r)
						}
					}),
				),
				n
			)
		}
		_deactivate(t) {
			let n = Promise.resolve(void 0)
			if (!this._readyToRunExtensions.isOpen() || !this._activator.isActivated(t)) return n
			let r = this._activator.getActivatedExtension(t)
			if (!r) return n
			try {
				typeof r.module.deactivate == "function" &&
					(n = Promise.resolve(r.module.deactivate()).then(
						void 0,
						(i) => (this._logService.error(i), Promise.resolve(void 0)),
					))
			} catch (i) {
				this._logService.error(`An error occurred when deactivating the extension '${t.value}':`),
					this._logService.error(i)
			}
			try {
				r.disposable.dispose()
			} catch (i) {
				this._logService.error(
					`An error occurred when disposing the subscriptions for extension '${t.value}':`,
				),
					this._logService.error(i)
			}
			return n
		}
		async _activateExtension(t, n) {
			return (
				this._initData.remote.isRemote
					? this._mainThreadExtensionsProxy.$onWillActivateExtension(t.identifier)
					: await this._mainThreadExtensionsProxy.$onWillActivateExtension(t.identifier),
				this._doActivateExtension(t, n).then(
					(r) => {
						let i = r.activationTimes
						return (
							this._mainThreadExtensionsProxy.$onDidActivateExtension(
								t.identifier,
								i.codeLoadingTime,
								i.activateCallTime,
								i.activateResolvedTime,
								n,
							),
							this._logExtensionActivationTimes(t, n, "success", i),
							r
						)
					},
					(r) => {
						throw (this._logExtensionActivationTimes(t, n, "failure"), r)
					},
				)
			)
		}
		_logExtensionActivationTimes(t, n, r, i) {
			let s = g2(t, n)
			this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", { ...s, ...(i || {}), outcome: r })
		}
		_doActivateExtension(t, n) {
			let r = g2(t, n)
			this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", r)
			let i = this._getEntryPoint(t)
			if (!i) return Promise.resolve(new Rx(Ad.NONE))
			this._logService.info(
				`ExtensionService#_doActivateExtension ${t.identifier.value}, startup: ${n.startup}, activationEvent: '${n.activationEvent}'${t.identifier.value !== n.extensionId.value ? `, root cause: ${n.extensionId.value}` : ""}`,
			),
				this._logService.flush()
			let s = this._isESM(t),
				a = new Q(),
				l = new up(n.startup)
			return Promise.all([
				s
					? this._loadESMModule(t, ct(t.extensionLocation, i), l)
					: this._loadCommonJSModule(t, ct(t.extensionLocation, i), l),
				this._loadExtensionContext(t, a),
			])
				.then(
					(d) => (
						Ct(`code/extHost/willActivateExtension/${t.identifier.value}`),
						al._callActivate(this._logService, t.identifier, d[0], d[1], a, l)
					),
				)
				.then((d) => (Ct(`code/extHost/didActivateExtension/${t.identifier.value}`), d))
		}
		_loadExtensionContext(t, n) {
			let r = this._extHostLanguageModels.createLanguageModelAccessInformation(t),
				i = n.add(new Ox(t, this._storage)),
				s = n.add(new $g(t.identifier.value, !1, this._storage)),
				a = n.add(new Kx(t, this._secretState)),
				l = t.isUnderDevelopment ? (this._initData.environment.extensionTestsLocationURI ? 3 : 2) : 1,
				d = this._initData.remote.isRemote ? 2 : 1
			return (
				this._logService.trace(`ExtensionService#loadExtensionContext ${t.identifier.value}`),
				Promise.all([i.whenReady, s.whenReady, this._storagePath.whenReady]).then(() => {
					let c = this,
						u,
						m,
						f = nt(t, "ipc") ? this._initData.messagePorts?.get(we.toKey(t.identifier)) : void 0
					return Object.freeze({
						globalState: i,
						workspaceState: s,
						secrets: a,
						subscriptions: [],
						get languageModelAccessInformation() {
							return r
						},
						get extensionUri() {
							return t.extensionLocation
						},
						get extensionPath() {
							return t.extensionLocation.fsPath
						},
						asAbsolutePath(h) {
							return Fe(t.extensionLocation.fsPath, h)
						},
						get storagePath() {
							return c._storagePath.workspaceValue(t)?.fsPath
						},
						get globalStoragePath() {
							return c._storagePath.globalValue(t).fsPath
						},
						get logPath() {
							return Fe(c._initData.logsLocation.fsPath, t.identifier.value)
						},
						get logUri() {
							return y.joinPath(c._initData.logsLocation, t.identifier.value)
						},
						get storageUri() {
							return c._storagePath.workspaceValue(t)
						},
						get globalStorageUri() {
							return c._storagePath.globalValue(t)
						},
						get extensionMode() {
							return l
						},
						get extension() {
							return u === void 0 && (u = new ll(c, t.identifier, t, d, !1)), u
						},
						get extensionRuntime() {
							return M(t, "extensionRuntime"), c.extensionRuntime
						},
						get environmentVariableCollection() {
							return c._extHostTerminalService.getEnvironmentVariableCollection(t)
						},
						get messagePassingProtocol() {
							if (!m) {
								if (!f) return
								let h = Te.buffer(Te.fromDOMEventEmitter(f, "message", (g) => g.data))
								f.start(), (m = { onDidReceiveMessage: h, postMessage: f.postMessage.bind(f) })
							}
							return m
						},
					})
				})
			)
		}
		static _callActivate(t, n, r, i, s, a) {
			return (
				(r = r || { activate: void 0, deactivate: void 0 }),
				this._callActivateOptional(t, n, r, i, a).then(
					(l) =>
						new Od(
							!1,
							null,
							a.build(),
							r,
							l,
							q(() => {
								s.dispose(), Fn(i.subscriptions)
							}),
						),
				)
			)
		}
		static _callActivateOptional(t, n, r, i, s) {
			if (typeof r.activate == "function")
				try {
					s.activateCallStart(), t.trace(`ExtensionService#_callActivateOptional ${n.value}`)
					let a = typeof global == "object" ? global : self,
						l = r.activate.apply(a, [i])
					return (
						s.activateCallStop(),
						s.activateResolveStart(),
						Promise.resolve(l).then((d) => (s.activateResolveStop(), d))
					)
				} catch (a) {
					return Promise.reject(a)
				}
			else return Promise.resolve(r)
		}
		_activateOneStartupFinished(t, n) {
			this._activateById(t.identifier, { startup: !1, extensionId: t.identifier, activationEvent: n }).then(
				void 0,
				(r) => {
					this._logService.error(r)
				},
			)
		}
		_activateAllStartupFinishedDeferred(t, n = 0) {
			let i = Date.now()
			dv(() => {
				for (let s = n; s < t.length; s += 1) {
					let a = t[s]
					for (let l of a.activationEvents ?? [])
						if (l === "onStartupFinished")
							if (Date.now() - i > 50) {
								this._activateAllStartupFinishedDeferred(t, s)
								break
							} else this._activateOneStartupFinished(a, l)
				}
			})
		}
		_activateAllStartupFinished() {
			gt.logIncoming(0, 0, 0, "activateAllStartupFinished start"),
				this._mainThreadExtensionsProxy.$setPerformanceMarks(nO()),
				this._extHostConfiguration.getConfigProvider().then((t) => {
					gt.logIncoming(0, 0, 0, "activateAllStartupFinished getConfigProvider")
					let n = t.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation"),
						r = this._myRegistry.getAllExtensionDescriptions()
					if (n)
						gt.logIncoming(0, 0, 0, "activateAllStartupFinished shouldDeferActivation"),
							this._activateAllStartupFinishedDeferred(r)
					else {
						gt.logIncoming(0, 0, 0, "activateAllStartupFinished !shouldDeferActivation")
						for (let i of r)
							if (i.activationEvents)
								for (let s of i.activationEvents)
									s === "onStartupFinished" && this._activateOneStartupFinished(i, s)
					}
				})
		}
		_handleEagerExtensions() {
			gt.logIncoming(0, 0, 0, "handleEagerExtensions start")
			let t = this._activateByEvent("*", !0).then(void 0, (a) => {
				this._logService.error(a)
			})
			this._register(
				this._extHostWorkspace.onDidChangeWorkspace((a) =>
					this._handleWorkspaceContainsEagerExtensions(a.added),
				),
			)
			let n = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [],
				r = this._handleWorkspaceContainsEagerExtensions(n),
				i = this._handleRemoteResolverEagerExtensions(),
				s = Promise.all([i, t, r]).then(() => {})
			return (
				Promise.race([s, Wt(1e4)]).then(() => {
					this._activateAllStartupFinished()
				}),
				s
			)
		}
		_handleWorkspaceContainsEagerExtensions(t) {
			return (
				gt.logIncoming(0, 0, 0, "handleWorkspaceContainsEagerExtensions start: " + t.length),
				t.length === 0
					? Promise.resolve(void 0)
					: Promise.all(
							this._myRegistry
								.getAllExtensionDescriptions()
								.map((n) => this._handleWorkspaceContainsEagerExtension(t, n)),
						).then(() => {
							gt.logIncoming(0, 0, 0, "handleWorkspaceContainsEagerExtensions end")
						})
			)
		}
		async _handleWorkspaceContainsEagerExtension(t, n) {
			if (this.isActivated(n.identifier)) return
			let r = !this._initData.remote.isRemote && !!this._initData.remote.authority,
				i = {
					logService: this._logService,
					folders: t.map((a) => a.uri),
					forceUsingSearch: r || !this._hostUtils.fsExists,
					exists: (a) => this._hostUtils.fsExists(a.fsPath),
					checkExists: (a, l, d) => this._mainThreadWorkspaceProxy.$checkExists(a, l, d),
				},
				s = await m2(i, n)
			if (s)
				return this._activateById(n.identifier, {
					startup: !0,
					extensionId: n.identifier,
					activationEvent: s.activationEvent,
				}).then(void 0, (a) => this._logService.error(a))
		}
		async _handleRemoteResolverEagerExtensions() {
			if ((gt.logIncoming(0, 0, 0, "handleRemoteResolverEagerExtensions start"), this._initData.remote.authority))
				return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, !1)
		}
		async $extensionTestsExecute() {
			await this._eagerExtensionsActivated.wait()
			try {
				return await this._doHandleExtensionTests()
			} catch (t) {
				throw (console.error(t), t)
			}
		}
		async _doHandleExtensionTests() {
			let { extensionDevelopmentLocationURI: t, extensionTestsLocationURI: n } = this._initData.environment
			if (!t || !n) throw new Error(p("extensionTestError1", "Cannot load test runner."))
			let r = (await this.getExtensionPathIndex()).findSubstr(n),
				s = await (this._isESM(r, n.path)
					? this._loadESMModule(null, n, new up(!1))
					: this._loadCommonJSModule(null, n, new up(!1)))
			if (!s || typeof s.run != "function")
				throw new Error(
					p("extensionTestError", "Path {0} does not point to a valid extension test runner.", n.toString()),
				)
			return new Promise((a, l) => {
				let d = (m, f) => {
						m
							? (na && this._logService.error("Test runner called back with error", m), l(m))
							: (na &&
									(f
										? this._logService.info(`Test runner called back with ${f} failures.`)
										: this._logService.info("Test runner called back with successful outcome.")),
								a(typeof f == "number" && f > 0 ? 1 : 0))
					},
					c = oo(n),
					u = s.run(c, d)
				u &&
					u.then &&
					u
						.then(() => {
							na && this._logService.info("Test runner finished successfully."), a(0)
						})
						.catch((m) => {
							na && this._logService.error("Test runner finished with error", m),
								l(m instanceof Error && m.stack ? m.stack : String(m))
						})
			})
		}
		_startExtensionHost() {
			if ((gt.logIncoming(0, 0, 0, "startExtensionHost start"), this._started))
				throw (
					(gt.logIncoming(0, 0, 0, "Extension host is already started!"),
					new Error("Extension host is already started!"))
				)
			return (
				(this._started = !0),
				this._readyToStartExtensionHost
					.wait()
					.then(() => this._readyToRunExtensions.open())
					.then(() => Promise.race([this._activator.waitForActivatingExtensions(), Wt(1e3)]))
					.then(() => this._handleEagerExtensions())
					.then(() => {
						this._eagerExtensionsActivated.open(), this._logService.info("Eager extensions activated")
					})
			)
		}
		registerRemoteAuthorityResolver(t, n) {
			return (
				(this._resolvers[t] = n),
				q(() => {
					delete this._resolvers[t]
				})
			)
		}
		async getRemoteExecServer(t) {
			let { resolver: n } = await this._activateAndGetResolver(t)
			return n?.resolveExecServer?.(t, { resolveAttempt: 0 })
		}
		async _activateAndGetResolver(t) {
			let n = t.indexOf("+")
			if (n === -1) throw new wi("Not an authority that can be resolved!", "InvalidAuthority")
			let r = t.substr(0, n)
			return (
				await this._almostReadyToRunExtensions.wait(),
				await this._activateByEvent(`onResolveRemoteAuthority:${r}`, !1),
				{ authorityPrefix: r, resolver: this._resolvers[r] }
			)
		}
		async $resolveAuthority(t, n) {
			let r = zt.create(!1),
				i = () => `[resolveAuthority(${H_(t)},${n})][${r.elapsed()}ms] `,
				s = (w) => this._logService.info(`${i()}${w}`),
				a = (w) => this._logService.warn(`${i()}${w}`),
				l = (w, L = void 0) => this._logService.error(`${i()}${w}`, L),
				d = (w) => {
					if (w instanceof wi)
						return { type: "error", error: { code: w._code, message: w._message, detail: w._detail } }
					throw w
				},
				c = async (w) => {
					s(`activating resolver for ${w}...`)
					let { resolver: L, authorityPrefix: A } = await this._activateAndGetResolver(w)
					if (!L)
						throw (
							(l(`no resolver for ${A}`),
							new wi(`No remote extension installed to resolve ${A}.`, "NoResolverFound"))
						)
					return { resolver: L, authorityPrefix: A, remoteAuthority: w }
				},
				u = t.split(/@|%40/g).reverse()
			s(`activating remote resolvers ${u.join(" -> ")}`)
			let m
			try {
				m = await Promise.all(u.map(c)).catch(async (w) => {
					if (!(w instanceof wi) || w._code !== "InvalidAuthority") throw w
					return a(`resolving nested authorities failed: ${w.message}`), [await c(t)]
				})
			} catch (w) {
				return d(w)
			}
			let f = new Sc()
			f.cancelAndSet(() => s("waiting..."), 1e3)
			let h, g
			for (let [w, { authorityPrefix: L, resolver: A, remoteAuthority: J }] of m.entries())
				try {
					if (w === m.length - 1)
						s("invoking final resolve()..."),
							Ct(`code/extHost/willResolveAuthority/${L}`),
							(h = await A.resolve(J, { resolveAttempt: n, execServer: g })),
							Ct(`code/extHost/didResolveAuthorityOK/${L}`),
							s("setting tunnel factory..."),
							this._register(
								await this._extHostTunnelService.setTunnelFactory(
									A,
									Ha.isManagedResolvedAuthority(h) ? h : void 0,
								),
							)
					else {
						if (
							(s(`invoking resolveExecServer() for ${J}`),
							Ct(`code/extHost/willResolveExecServer/${L}`),
							(g = await A.resolveExecServer?.(J, { resolveAttempt: n, execServer: g })),
							!g)
						)
							throw new wi(`Exec server was not available for ${J}`, "NoResolverFound")
						Ct(`code/extHost/didResolveExecServerOK/${L}`)
					}
				} catch (ne) {
					return (
						Ct(`code/extHost/didResolveAuthorityError/${L}`), l("returned an error", ne), f.dispose(), d(ne)
					)
				}
			f.dispose()
			let I = {
					environmentTunnels: h.environmentTunnels,
					features: h.tunnelFeatures
						? {
								elevation: h.tunnelFeatures.elevation,
								privacyOptions: h.tunnelFeatures.privacyOptions,
								protocol: h.tunnelFeatures.protocol === void 0 ? !0 : h.tunnelFeatures.protocol,
							}
						: void 0,
				},
				C = {
					extensionHostEnv: h.extensionHostEnv,
					isTrusted: h.isTrusted,
					authenticationSession: h.authenticationSessionForInitializingExtensions
						? {
								id: h.authenticationSessionForInitializingExtensions.id,
								providerId: h.authenticationSessionForInitializingExtensions.providerId,
							}
						: void 0,
				}
			s(`returned ${Ha.isManagedResolvedAuthority(h) ? "managed authority" : `${h.host}:${h.port}`}`)
			let T
			if (Ha.isManagedResolvedAuthority(h)) {
				let w = n
				this._extHostManagedSockets.setFactory(w, h.makeConnection),
					(T = { authority: t, connectTo: new lu(w), connectionToken: h.connectionToken })
			} else T = { authority: t, connectTo: new My(h.host, h.port), connectionToken: h.connectionToken }
			return { type: "ok", value: { authority: T, options: C, tunnelInformation: I } }
		}
		async $getCanonicalURI(t, n) {
			this._logService.info(`$getCanonicalURI invoked for authority (${H_(t)})`)
			let { resolver: r } = await this._activateAndGetResolver(t)
			if (!r) return null
			let i = y.revive(n)
			if (typeof r.getCanonicalURI > "u") return i
			let s = await Jt(() => r.getCanonicalURI(i))
			return s || i
		}
		async $startExtensionHost(t) {
			t.toAdd.forEach((a) => (a.extensionLocation = y.revive(a.extensionLocation)))
			let { globalRegistry: n, myExtensions: r } = f2(
					this._activationEventsReader,
					this._globalRegistry,
					this._myRegistry,
					t,
				),
				i = await this._createExtensionPathIndex(r)
			return (
				(await this.getExtensionPathIndex()).setSearchTree(i),
				this._globalRegistry.set(n.getAllExtensionDescriptions()),
				this._myRegistry.set(r),
				na &&
					(this._logService.info(`$startExtensionHost: global extensions: ${Up(this._globalRegistry)}`),
					this._logService.info(`$startExtensionHost: local extensions: ${Up(this._myRegistry)}`)),
				this._startExtensionHost()
			)
		}
		$activateByEvent(t, n) {
			return n === 1
				? this._almostReadyToRunExtensions.wait().then((r) => this._activateByEvent(t, !1))
				: this._readyToRunExtensions.wait().then((r) => this._activateByEvent(t, !1))
		}
		async $activate(t, n) {
			return (
				console.log("activate", t, n),
				await this._readyToRunExtensions.wait(),
				this._myRegistry.getExtensionDescription(t) ? (await this._activateById(t, n), !0) : !1
			)
		}
		async $deltaExtensions(t) {
			t.toAdd.forEach((a) => (a.extensionLocation = y.revive(a.extensionLocation)))
			let { globalRegistry: n, myExtensions: r } = f2(
					this._activationEventsReader,
					this._globalRegistry,
					this._myRegistry,
					t,
				),
				i = await this._createExtensionPathIndex(r)
			return (
				(await this.getExtensionPathIndex()).setSearchTree(i),
				this._globalRegistry.set(n.getAllExtensionDescriptions()),
				this._myRegistry.set(r),
				na &&
					(this._logService.info(`$deltaExtensions: global extensions: ${Up(this._globalRegistry)}`),
					this._logService.info(`$deltaExtensions: local extensions: ${Up(this._myRegistry)}`)),
				Promise.resolve(void 0)
			)
		}
		async $test_latency(t) {
			return t
		}
		async $test_up(t) {
			return t.byteLength
		}
		async $test_down(t) {
			let n = z.alloc(t),
				r = Math.random() % 256
			for (let i = 0; i < t; i++) n.writeUInt8(r, i)
			return n
		}
		async $updateRemoteConnectionData(t) {
			;(this._remoteConnectionData = t), this._onDidChangeRemoteConnectionData.fire()
		}
		_isESM(t, n) {
			return (n ??= t?.main), n?.endsWith(".mjs") || t?.type === "module"
		}
	}
al = R(
	[
		S(0, Uo),
		S(1, $k),
		S(2, ie),
		S(3, Sn),
		S(4, pn),
		S(5, te),
		S(6, Xe),
		S(7, hp),
		S(8, ol),
		S(9, er),
		S(10, Mp),
		S(11, Np),
		S(12, _p),
	],
	al,
)
function f2(o, e, t, n) {
	o.addActivationEvents(n.addActivationEvents)
	let r = new Ws(o, e.getAllExtensionDescriptions())
	r.deltaExtensions(n.toAdd, n.toRemove)
	let i = new sr(t.getAllExtensionDescriptions().map((a) => a.identifier))
	for (let a of n.myToRemove) i.delete(a)
	for (let a of n.myToAdd) i.add(a)
	let s = h2(r, i)
	return { globalRegistry: r, myExtensions: s }
}
function g2(o, e) {
	return {
		id: o.identifier.value,
		name: o.name,
		extensionVersion: o.version,
		publisherDisplayName: o.publisher,
		activationEvents: o.activationEvents ? o.activationEvents.join(",") : null,
		isBuiltin: o.isBuiltin,
		reason: e.activationEvent,
		reasonId: e.extensionId.value,
	}
}
function Up(o) {
	return o
		.getAllExtensionDescriptions()
		.map((e) => e.identifier.value)
		.join(",")
}
var ur = O("IExtHostExtensionService"),
	ll = class {
		#e
		#t
		#n
		constructor(e, t, n, r, i) {
			;(this.#e = e),
				(this.#t = t),
				(this.#n = n.identifier),
				(this.id = n.identifier.value),
				(this.extensionUri = n.extensionLocation),
				(this.extensionPath = jn(oo(n.extensionLocation))),
				(this.packageJSON = n),
				(this.extensionKind = r),
				(this.isFromDifferentExtensionHost = i)
		}
		get isActive() {
			return this.#e.isActivated(this.#n)
		}
		get exports() {
			if (!(this.packageJSON.api === "none" || this.isFromDifferentExtensionHost))
				return this.#e.getExtensionExports(this.#n)
		}
		async activate() {
			if (this.isFromDifferentExtensionHost) throw new Error("Cannot activate foreign extension")
			return (
				await this.#e.activateByIdWithErrors(this.#n, {
					startup: !1,
					extensionId: this.#t,
					activationEvent: "api",
				}),
				this.exports
			)
		}
	}
function h2(o, e) {
	return o.getAllExtensionDescriptions().filter((t) => e.has(t.identifier))
}
var Vk = class {
		constructor(e) {
			this._searchTree = e
		}
		setSearchTree(e) {
			this._searchTree = e
		}
		findSubstr(e) {
			return this._searchTree.findSubstr(e)
		}
		forEach(e) {
			return this._searchTree.forEach(e)
		}
	},
	Bk = class {
		constructor(e) {
			this._map = new On()
			this.addActivationEvents(e)
		}
		readActivationEvents(e) {
			return this._map.get(e.identifier) ?? []
		}
		addActivationEvents(e) {
			for (let t of Object.keys(e)) this._map.set(t, e[t])
		}
	}
var jx = class {
		static async installEarlyHandler(e) {
			Error.stackTraceLimit = 100
			let t = e.get(te),
				r = e.get(ie).getProxy(N.MainThreadErrors)
			jm((i) => {
				t.error(i)
				let s = Po(i)
				r.$onUnexpectedError(s)
			})
		}
		static async installFullHandler(e) {
			let t = e.get(te),
				n = e.get(ie),
				r = e.get(ur),
				i = e.get(sl),
				s = n.getProxy(N.MainThreadExtensionService),
				a = n.getProxy(N.MainThreadErrors),
				l = await r.getExtensionPathIndex(),
				d = new WeakMap()
			function c(f, h) {
				if (d.has(f)) return d.get(f).stack
				let g = "",
					I,
					C
				for (let w of h)
					(g += `
	at ${w.toString()}`),
						(C = w.getFileName()),
						!I && C && (I = l.findSubstr(y.file(C)))
				let T = `${f.name || "Error"}: ${f.message || ""}${g}`
				return d.set(f, { extensionIdentifier: I?.identifier, stack: T }), T
			}
			let u = Symbol("prepareStackTrace wrapped"),
				m = c
			Object.defineProperty(Error, "prepareStackTrace", {
				configurable: !1,
				get() {
					return m
				},
				set(f) {
					if (f === c || !f || f[u]) {
						m = f || c
						return
					}
					;(m = function (h, g) {
						return c(h, g), f.call(Error, h, g)
					}),
						Object.assign(m, { [u]: !0 })
				},
			}),
				jm((f) => {
					t.error(f)
					let h = Po(f),
						g
					if ((f instanceof Fc ? (g = f.extension) : (g = d.get(f)?.extensionIdentifier), g)) {
						s.$onExtensionRuntimeError(g, h)
						let I = i.onExtensionError(g, f)
						t.trace("forwarded error to extension?", I, g)
					}
				}),
				ac.addListener((f) => {
					let h = Po(f)
					a.$onUnexpectedError(h)
				})
		}
	},
	Gx = class o {
		constructor(e, t, n, r, i) {
			;(this._hostUtils = n),
				(this._rpcProtocol = new zv(e, new sa("extension_protocol"), r)),
				(t = o._transform(t, this._rpcProtocol))
			let s = new fa(...JO())
			s.set(Xe, { _serviceBrand: void 0, ...t, messagePorts: i }),
				s.set(ie, new db(this._rpcProtocol)),
				s.set(pi, new cb(r)),
				s.set($k, n)
			let a = new lb(s, !0)
			a.invokeFunction(jx.installEarlyHandler),
				(this._logService = a.invokeFunction((l) => l.get(te))),
				Ct("code/extHost/didCreateServices"),
				this._hostUtils.pid
					? this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`)
					: this._logService.info("Extension host started"),
				this._logService.trace("initData", t),
				(this._extensionService = a.invokeFunction((l) => l.get(ur))),
				this._extensionService.initialize(),
				a.invokeFunction(jx.installFullHandler)
		}
		async asBrowserUri(e) {
			let t = this._rpcProtocol.getProxy(N.MainThreadExtensionService)
			return y.revive(await t.$asBrowserUri(e))
		}
		terminate(e) {
			this._extensionService.terminate(e)
		}
		static _transform(e, t) {
			e.extensions.allExtensions.forEach((r) => {
				r.extensionLocation = y.revive(t.transformIncomingURIs(r.extensionLocation))
			}),
				(e.environment.appRoot = y.revive(t.transformIncomingURIs(e.environment.appRoot)))
			let n = e.environment.extensionDevelopmentLocationURI
			return (
				n &&
					(e.environment.extensionDevelopmentLocationURI = n.map((r) =>
						y.revive(t.transformIncomingURIs(r)),
					)),
				(e.environment.extensionTestsLocationURI = y.revive(
					t.transformIncomingURIs(e.environment.extensionTestsLocationURI),
				)),
				(e.environment.globalStorageHome = y.revive(t.transformIncomingURIs(e.environment.globalStorageHome))),
				(e.environment.workspaceStorageHome = y.revive(
					t.transformIncomingURIs(e.environment.workspaceStorageHome),
				)),
				(e.nlsBaseUrl = y.revive(t.transformIncomingURIs(e.nlsBaseUrl))),
				(e.logsLocation = y.revive(t.transformIncomingURIs(e.logsLocation))),
				(e.workspace = t.transformIncomingURIs(e.workspace)),
				e
			)
		}
	}
function E8(o) {
	return {
		transformIncoming: (e) =>
			e.scheme === "vscode-remote"
				? { scheme: "file", path: e.path, query: e.query, fragment: e.fragment }
				: e.scheme === "file"
					? { scheme: "vscode-local", path: e.path, query: e.query, fragment: e.fragment }
					: e,
		transformOutgoing: (e) =>
			e.scheme === "file"
				? { scheme: "vscode-remote", authority: o, path: e.path, query: e.query, fragment: e.fragment }
				: e.scheme === "vscode-local"
					? { scheme: "file", path: e.path, query: e.query, fragment: e.fragment }
					: e,
		transformOutgoingScheme: (e) => (e === "file" ? "vscode-remote" : e === "vscode-local" ? "file" : e),
	}
}
function v2(o) {
	return new Bv(E8(o))
}
var Hp = class o {
		constructor(e) {
			this.pipeName = e
			this.type = 1
		}
		static {
			this.ENV_KEY = "VSCODE_EXTHOST_IPC_HOOK"
		}
		serialize(e) {
			e[o.ENV_KEY] = this.pipeName
		}
	},
	Qg = class o {
		constructor() {
			this.type = 2
		}
		static {
			this.ENV_KEY = "VSCODE_EXTHOST_WILL_SEND_SOCKET"
		}
		serialize(e) {
			e[o.ENV_KEY] = "1"
		}
	},
	Jg = class o {
		constructor() {
			this.type = 3
		}
		static {
			this.ENV_KEY = "VSCODE_WILL_SEND_MESSAGE_PORT"
		}
		serialize(e) {
			e[o.ENV_KEY] = "1"
		}
	}
function w8(o) {
	delete o[Hp.ENV_KEY], delete o[Qg.ENV_KEY], delete o[Jg.ENV_KEY]
}
function b2(o) {
	if (o[Hp.ENV_KEY]) return zk(o, new Hp(o[Hp.ENV_KEY]))
	if (o[Qg.ENV_KEY]) return zk(o, new Qg())
	if (o[Jg.ENV_KEY]) return zk(o, new Jg())
	throw new Error("No connection information defined in environment!")
}
function zk(o, e) {
	return w8(o), e
}
var qSe = new D("inOutput", !1),
	KSe = new D("activeLogOutput", !1),
	jSe = new D("activeLogOutput.isLog", !1),
	GSe = new D("activeLogOutput.levelSettable", !1),
	QSe = new D("activeLogOutput.level", ""),
	JSe = new D("activeLogOutput.levelIsDefault", !1),
	XSe = new D("outputView.scrollLock", !1),
	YSe = new D("activeOutputChannel", ""),
	ZSe = new D("output.filter.trace", !0),
	eTe = new D("output.filter.debug", !0),
	tTe = new D("output.filter.info", !0),
	nTe = new D("output.filter.warning", !0),
	rTe = new D("output.filter.error", !0),
	oTe = new D("outputFilterFocus", !1),
	iTe = new D("output.filter.categories", ""),
	sTe = O("outputService")
var P8 = { OutputChannels: "workbench.contributions.outputChannels" }
function _8(o) {
	return Array.isArray(o.source)
}
var qk = class {
	constructor() {
		this.channels = new Map()
		this._onDidRegisterChannel = new E()
		this.onDidRegisterChannel = this._onDidRegisterChannel.event
		this._onDidRemoveChannel = new E()
		this.onDidRemoveChannel = this._onDidRemoveChannel.event
		this._onDidUpdateChannelFiles = new E()
		this.onDidUpdateChannelSources = this._onDidUpdateChannelFiles.event
	}
	registerChannel(e) {
		this.channels.has(e.id) || (this.channels.set(e.id, e), this._onDidRegisterChannel.fire(e.id))
	}
	getChannels() {
		let e = []
		return this.channels.forEach((t) => e.push(t)), e
	}
	getChannel(e) {
		return this.channels.get(e)
	}
	updateChannelSources(e, t) {
		let n = this.channels.get(e)
		n && _8(n) && ((n.source = t), this._onDidUpdateChannelFiles.fire(n))
	}
	removeChannel(e) {
		let t = this.channels.get(e)
		t && (this.channels.delete(e), this._onDidRemoveChannel.fire(t))
	}
}
yt.add(P8.OutputChannels, new qk())
var Qx = class extends pa {
		constructor(t, n, r, i, s) {
			super()
			this.id = t
			this.name = n
			this.logger = r
			this.proxy = i
			this.extension = s
			this.offset = 0
			this.visible = !1
			this.setLevel(r.getLevel()),
				this._register(r.onDidChangeLogLevel((a) => this.setLevel(a))),
				this._register(q(() => this.proxy.$dispose(this.id)))
		}
		get logLevel() {
			return this.getLevel()
		}
		appendLine(t) {
			this.append(
				t +
					`
`,
			)
		}
		append(t) {
			this.info(t)
		}
		clear() {
			let t = this.offset
			this.logger.flush(), this.proxy.$update(this.id, 3, t)
		}
		replace(t) {
			let n = this.offset
			this.info(t), this.proxy.$update(this.id, 2, n), this.visible && this.logger.flush()
		}
		show(t, n) {
			this.logger.flush(), this.proxy.$reveal(this.id, !!(typeof t == "boolean" ? t : n))
		}
		hide() {
			this.proxy.$close(this.id)
		}
		log(t, n) {
			;(this.offset += z.fromString(n).byteLength),
				jO(this.logger, t, n),
				this.visible && (this.logger.flush(), this.proxy.$update(this.id, 1))
		}
	},
	Kk = class extends Qx {
		appendLine(e) {
			this.append(e)
		}
	},
	Wp = class {
		constructor(e, t, n, r, i, s) {
			this.initData = t
			this.extHostFileSystem = n
			this.extHostFileSystemInfo = r
			this.loggerService = i
			this.logService = s
			this.extensionLogDirectoryPromise = new Map()
			this.namePool = 1
			this.channels = new Map()
			this.visibleChannelId = null
			;(this.proxy = e.getProxy(N.MainThreadOutputService)),
				(this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(
					t.logsLocation,
					`output_logging_${i2(new Date()).replace(/-|:|\.\d+Z$/g, "")}`,
				))
		}
		$setVisibleChannel(e) {
			this.visibleChannelId = e
			for (let [t, n] of this.channels) n.visible = t === this.visibleChannelId
		}
		createOutputChannel(e, t, n) {
			if (((e = e.trim()), !e)) throw new Error("illegal argument `name`. must not be falsy")
			let r = typeof t == "object" && t.log,
				i = Ee(t) ? t : void 0
			if (Ee(i) && !i.trim()) throw new Error("illegal argument `languageId`. must not be empty")
			let s,
				a = this.initData.environment.extensionLogLevel?.find(([c]) => we.equals(n.identifier, c))?.[1]
			a && (s = GO(a))
			let l = new Q(),
				d = r ? this.doCreateLogOutputChannel(e, s, n, l) : this.doCreateOutputChannel(e, i, n, l)
			return (
				d.then((c) => {
					this.channels.set(c.id, c),
						(c.visible = c.id === this.visibleChannelId),
						l.add(q(() => this.channels.delete(c.id)))
				}),
				r
					? this.createExtHostLogOutputChannel(e, s ?? this.logService.getLevel(), d, l)
					: this.createExtHostOutputChannel(e, d, l)
			)
		}
		async doCreateOutputChannel(e, t, n, r) {
			this.outputDirectoryPromise ||
				(this.outputDirectoryPromise = this.extHostFileSystem.value
					.createDirectory(this.outputsLocation)
					.then(() => this.outputsLocation))
			let i = await this.outputDirectoryPromise,
				s = this.extHostFileSystemInfo.extUri.joinPath(
					i,
					`${this.namePool++}-${e.replace(/[\\/:\*\?"<>\|]/g, "")}.log`,
				),
				a = r.add(
					this.loggerService.createLogger(s, {
						logLevel: "always",
						donotRotate: !0,
						donotUseFormatters: !0,
						hidden: !0,
					}),
				),
				l = await this.proxy.$register(e, s, t, n.identifier.value)
			return r.add(q(() => this.loggerService.deregisterLogger(s))), new Qx(l, e, a, this.proxy, n)
		}
		async doCreateLogOutputChannel(e, t, n, r) {
			let i = await this.createExtensionLogDirectory(n),
				s = e.replace(/[\\/:\*\?"<>\|]/g, ""),
				a = this.extHostFileSystemInfo.extUri.joinPath(i, `${s}.log`),
				l = `${n.identifier.value}.${s}`,
				d = r.add(
					this.loggerService.createLogger(a, {
						id: l,
						name: e,
						logLevel: t,
						extensionId: n.identifier.value,
					}),
				)
			return r.add(q(() => this.loggerService.deregisterLogger(a))), new Kk(l, e, d, this.proxy, n)
		}
		createExtensionLogDirectory(e) {
			let t = this.extensionLogDirectoryPromise.get(e.identifier.value)
			if (!t) {
				let n = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, e.identifier.value)
				this.extensionLogDirectoryPromise.set(
					e.identifier.value,
					(t = (async () => {
						try {
							await this.extHostFileSystem.value.createDirectory(n)
						} catch (r) {
							if (Wc(r) !== "EntryExists") throw r
						}
						return n
					})()),
				)
			}
			return t
		}
		createExtHostOutputChannel(e, t, n) {
			let r = () => {
				if (n.isDisposed) throw new Error("Channel has been closed")
			}
			return (
				t.then((i) => n.add(i)),
				{
					get name() {
						return e
					},
					append(i) {
						r(), t.then((s) => s.append(i))
					},
					appendLine(i) {
						r(), t.then((s) => s.appendLine(i))
					},
					clear() {
						r(), t.then((i) => i.clear())
					},
					replace(i) {
						r(), t.then((s) => s.replace(i))
					},
					show(i, s) {
						r(), t.then((a) => a.show(i, s))
					},
					hide() {
						r(), t.then((i) => i.hide())
					},
					dispose() {
						n.dispose()
					},
				}
			)
		}
		createExtHostLogOutputChannel(e, t, n, r) {
			let i = () => {
					if (r.isDisposed) throw new Error("Channel has been closed")
				},
				s = r.add(new E())
			function a(l) {
				;(t = l), s.fire(l)
			}
			return (
				n.then((l) => {
					l.logLevel !== t && a(l.logLevel), r.add(l.onDidChangeLogLevel((d) => a(d)))
				}),
				{
					...this.createExtHostOutputChannel(e, n, r),
					get logLevel() {
						return t
					},
					onDidChangeLogLevel: s.event,
					trace(l, ...d) {
						i(), n.then((c) => c.trace(l, ...d))
					},
					debug(l, ...d) {
						i(), n.then((c) => c.debug(l, ...d))
					},
					info(l, ...d) {
						i(), n.then((c) => c.info(l, ...d))
					},
					warn(l, ...d) {
						i(), n.then((c) => c.warn(l, ...d))
					},
					error(l, ...d) {
						i(), n.then((c) => c.error(l, ...d))
					},
				}
			)
		}
	}
Wp = R([S(0, ie), S(1, Xe), S(2, Li), S(3, uo), S(4, co), S(5, te)], Wp)
var Jx = O("IExtHostOutputService")
var Fi = class {
	constructor(e, t) {
		this._logService = t
		this._provider = new Map()
		this._proxy = e.getProxy(N.MainThreadDecorations)
	}
	static {
		this._handlePool = 0
	}
	static {
		this._maxEventSize = 250
	}
	registerFileDecorationProvider(e, t) {
		let n = Fi._handlePool++
		this._provider.set(n, { provider: e, extensionDescription: t }),
			this._proxy.$registerDecorationProvider(n, t.identifier.value)
		let r =
			e.onDidChangeFileDecorations &&
			e.onDidChangeFileDecorations((i) => {
				if (!i) {
					this._proxy.$onDidChange(n, null)
					return
				}
				let s = an(i)
				if (s.length <= Fi._maxEventSize) {
					this._proxy.$onDidChange(n, s)
					return
				}
				this._logService.warn(
					"[Decorations] CAPPING events from decorations provider",
					t.identifier.value,
					s.length,
				)
				let a = s.map((c) => ({ uri: c, rank: gA(c.path, "/") })),
					l = D0(a, (c, u) => c.rank - u.rank || Lo(c.uri.path, u.uri.path)),
					d = []
				e: for (let c of l) {
					let u
					for (let m of c) {
						let f = Qt(m.uri.path)
						if (u !== f && ((u = f), d.push(m.uri) >= Fi._maxEventSize)) break e
					}
				}
				this._proxy.$onDidChange(n, d)
			})
		return new ye(() => {
			r?.dispose(), this._proxy.$unregisterDecorationProvider(n), this._provider.delete(n)
		})
	}
	async $provideDecorations(e, t, n) {
		if (!this._provider.has(e)) return Object.create(null)
		let r = Object.create(null),
			{ provider: i, extensionDescription: s } = this._provider.get(e)
		return (
			await Promise.all(
				t.map(async (a) => {
					try {
						let { uri: l, id: d } = a,
							c = await Promise.resolve(i.provideFileDecoration(y.revive(l), n))
						if (!c) return
						try {
							bd.validate(c),
								c.badge && typeof c.badge != "string" && M(s, "codiconDecoration"),
								(r[d] = [c.propagate, c.tooltip, c.badge, c.color])
						} catch (u) {
							this._logService.warn(`INVALID decoration from extension '${s.identifier.value}': ${u}`)
						}
					} catch (l) {
						this._logService.error(l)
					}
				}),
			),
			r
		)
	}
}
Fi = R([S(0, ie), S(1, te)], Fi)
var Xx = O("IExtHostDecorations")
var Yx = class {
	constructor(e) {
		;(this.values = e),
			(this.prefixSum = new Uint32Array(e.length)),
			(this.prefixSumValidIndex = new Int32Array(1)),
			(this.prefixSumValidIndex[0] = -1)
	}
	getCount() {
		return this.values.length
	}
	insertValues(e, t) {
		e = Dl(e)
		let n = this.values,
			r = this.prefixSum,
			i = t.length
		return i === 0
			? !1
			: ((this.values = new Uint32Array(n.length + i)),
				this.values.set(n.subarray(0, e), 0),
				this.values.set(n.subarray(e), e + i),
				this.values.set(t, e),
				e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
				(this.prefixSum = new Uint32Array(this.values.length)),
				this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)),
				!0)
	}
	setValue(e, t) {
		return (
			(e = Dl(e)),
			(t = Dl(t)),
			this.values[e] === t
				? !1
				: ((this.values[e] = t),
					e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
					!0)
		)
	}
	removeValues(e, t) {
		;(e = Dl(e)), (t = Dl(t))
		let n = this.values,
			r = this.prefixSum
		if (e >= n.length) return !1
		let i = n.length - e
		return (
			t >= i && (t = i),
			t === 0
				? !1
				: ((this.values = new Uint32Array(n.length - t)),
					this.values.set(n.subarray(0, e), 0),
					this.values.set(n.subarray(e + t), e),
					(this.prefixSum = new Uint32Array(this.values.length)),
					e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
					this.prefixSumValidIndex[0] >= 0 &&
						this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)),
					!0)
		)
	}
	getTotalSum() {
		return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1)
	}
	getPrefixSum(e) {
		return e < 0 ? 0 : ((e = Dl(e)), this._getPrefixSum(e))
	}
	_getPrefixSum(e) {
		if (e <= this.prefixSumValidIndex[0]) return this.prefixSum[e]
		let t = this.prefixSumValidIndex[0] + 1
		t === 0 && ((this.prefixSum[0] = this.values[0]), t++), e >= this.values.length && (e = this.values.length - 1)
		for (let n = t; n <= e; n++) this.prefixSum[n] = this.prefixSum[n - 1] + this.values[n]
		return (this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e)), this.prefixSum[e]
	}
	getIndexOf(e) {
		;(e = Math.floor(e)), this.getTotalSum()
		let t = 0,
			n = this.values.length - 1,
			r = 0,
			i = 0,
			s = 0
		for (; t <= n; )
			if (((r = (t + (n - t) / 2) | 0), (i = this.prefixSum[r]), (s = i - this.values[r]), e < s)) n = r - 1
			else if (e >= i) t = r + 1
			else break
		return new jk(r, e - s)
	}
}
var jk = class {
	constructor(e, t) {
		this.index = e
		this.remainder = t
		this._prefixSumIndexOfResultBrand = void 0
		;(this.index = e), (this.remainder = t)
	}
}
var Zx = class {
	constructor(e, t, n, r) {
		;(this._uri = e),
			(this._lines = t),
			(this._eol = n),
			(this._versionId = r),
			(this._lineStarts = null),
			(this._cachedTextValue = null)
	}
	dispose() {
		this._lines.length = 0
	}
	get version() {
		return this._versionId
	}
	getText() {
		return (
			this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)),
			this._cachedTextValue
		)
	}
	onEvents(e) {
		e.eol && e.eol !== this._eol && ((this._eol = e.eol), (this._lineStarts = null))
		let t = e.changes
		for (let n of t)
			this._acceptDeleteRange(n.range),
				this._acceptInsertText(new cn(n.range.startLineNumber, n.range.startColumn), n.text)
		;(this._versionId = e.versionId), (this._cachedTextValue = null)
	}
	_ensureLineStarts() {
		if (!this._lineStarts) {
			let e = this._eol.length,
				t = this._lines.length,
				n = new Uint32Array(t)
			for (let r = 0; r < t; r++) n[r] = this._lines[r].length + e
			this._lineStarts = new Yx(n)
		}
	}
	_setLineText(e, t) {
		;(this._lines[e] = t),
			this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length)
	}
	_acceptDeleteRange(e) {
		if (e.startLineNumber === e.endLineNumber) {
			if (e.startColumn === e.endColumn) return
			this._setLineText(
				e.startLineNumber - 1,
				this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) +
					this._lines[e.startLineNumber - 1].substring(e.endColumn - 1),
			)
			return
		}
		this._setLineText(
			e.startLineNumber - 1,
			this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) +
				this._lines[e.endLineNumber - 1].substring(e.endColumn - 1),
		),
			this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber),
			this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber)
	}
	_acceptInsertText(e, t) {
		if (t.length === 0) return
		let n = Iv(t)
		if (n.length === 1) {
			this._setLineText(
				e.lineNumber - 1,
				this._lines[e.lineNumber - 1].substring(0, e.column - 1) +
					n[0] +
					this._lines[e.lineNumber - 1].substring(e.column - 1),
			)
			return
		}
		;(n[n.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1)),
			this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0])
		let r = new Uint32Array(n.length - 1)
		for (let i = 1; i < n.length; i++)
			this._lines.splice(e.lineNumber + i - 1, 0, n[i]), (r[i - 1] = n[i].length + this._eol.length)
		this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r)
	}
}
var Gk = new Map()
function y2(o, e) {
	e ? Gk.set(o, e) : Gk.delete(o)
}
function D8(o) {
	return Gk.get(o)
}
var eC = class extends Zx {
		constructor(t, n, r, i, s, a, l, d) {
			super(n, r, i, s)
			this._proxy = t
			this._languageId = a
			this._isDirty = l
			this._encoding = d
			this._isDisposed = !1
		}
		dispose() {
			yn(!this._isDisposed), (this._isDisposed = !0), (this._isDirty = !1)
		}
		equalLines(t) {
			return mn(this._lines, t)
		}
		get document() {
			if (!this._document) {
				let t = this
				this._document = {
					get uri() {
						return t._uri
					},
					get fileName() {
						return t._uri.fsPath
					},
					get isUntitled() {
						return t._uri.scheme === W.untitled
					},
					get languageId() {
						return t._languageId
					},
					get version() {
						return t._versionId
					},
					get isClosed() {
						return t._isDisposed
					},
					get isDirty() {
						return t._isDirty
					},
					get encoding() {
						return t._encoding
					},
					save() {
						return t._save()
					},
					getText(n) {
						return n ? t._getTextInRange(n) : t.getText()
					},
					get eol() {
						return t._eol ===
							`
`
							? 1
							: 2
					},
					get lineCount() {
						return t._lines.length
					},
					lineAt(n) {
						return t._lineAt(n)
					},
					offsetAt(n) {
						return t._offsetAt(n)
					},
					positionAt(n) {
						return t._positionAt(n)
					},
					validateRange(n) {
						return t._validateRange(n)
					},
					validatePosition(n) {
						return t._validatePosition(n)
					},
					getWordRangeAtPosition(n, r) {
						return t._getWordRangeAtPosition(n, r)
					},
					[Symbol.for("debug.description")]() {
						return `TextDocument(${t._uri.toString()})`
					},
				}
			}
			return Object.freeze(this._document)
		}
		_acceptLanguageId(t) {
			yn(!this._isDisposed), (this._languageId = t)
		}
		_acceptIsDirty(t) {
			yn(!this._isDisposed), (this._isDirty = t)
		}
		_acceptEncoding(t) {
			yn(!this._isDisposed), (this._encoding = t)
		}
		_save() {
			return this._isDisposed
				? Promise.reject(new Error("Document has been closed"))
				: this._proxy.$trySaveDocument(this._uri)
		}
		_getTextInRange(t) {
			let n = this._validateRange(t)
			if (n.isEmpty) return ""
			if (n.isSingleLine) return this._lines[n.start.line].substring(n.start.character, n.end.character)
			let r = this._eol,
				i = n.start.line,
				s = n.end.line,
				a = []
			a.push(this._lines[i].substring(n.start.character))
			for (let l = i + 1; l < s; l++) a.push(this._lines[l])
			return a.push(this._lines[s].substring(0, n.end.character)), a.join(r)
		}
		_lineAt(t) {
			let n
			if (
				(t instanceof Pe ? (n = t.line) : typeof t == "number" && (n = t),
				typeof n != "number" || n < 0 || n >= this._lines.length || Math.floor(n) !== n)
			)
				throw new Error("Illegal value for `line`")
			return new Qk(n, this._lines[n], n === this._lines.length - 1)
		}
		_offsetAt(t) {
			return (
				(t = this._validatePosition(t)),
				this._ensureLineStarts(),
				this._lineStarts.getPrefixSum(t.line - 1) + t.character
			)
		}
		_positionAt(t) {
			;(t = Math.floor(t)), (t = Math.max(0, t)), this._ensureLineStarts()
			let n = this._lineStarts.getIndexOf(t),
				r = this._lines[n.index].length
			return new Pe(n.index, Math.min(n.remainder, r))
		}
		_validateRange(t) {
			if (!(t instanceof pe)) throw new Error("Invalid argument")
			let n = this._validatePosition(t.start),
				r = this._validatePosition(t.end)
			return n === t.start && r === t.end ? t : new pe(n.line, n.character, r.line, r.character)
		}
		_validatePosition(t) {
			if (!(t instanceof Pe)) throw new Error("Invalid argument")
			if (this._lines.length === 0) return t.with(0, 0)
			let { line: n, character: r } = t,
				i = !1
			if (n < 0) (n = 0), (r = 0), (i = !0)
			else if (n >= this._lines.length) (n = this._lines.length - 1), (r = this._lines[n].length), (i = !0)
			else {
				let s = this._lines[n].length
				r < 0 ? ((r = 0), (i = !0)) : r > s && ((r = s), (i = !0))
			}
			return i ? new Pe(n, r) : t
		}
		_getWordRangeAtPosition(t, n) {
			let r = this._validatePosition(t)
			if (!n) n = D8(this._languageId)
			else if (yv(n))
				throw new Error(
					`[getWordRangeAtPosition]: ignoring custom regexp '${n.source}' because it matches the empty string.`,
				)
			let i = dw(r.character + 1, lw(n), this._lines[r.line], 0)
			if (i) return new pe(r.line, i.startColumn - 1, r.line, i.endColumn - 1)
		}
	},
	Qk = class {
		constructor(e, t, n) {
			;(this._line = e), (this._text = t), (this._isLastLine = n)
		}
		get lineNumber() {
			return this._line
		}
		get text() {
			return this._text
		}
		get range() {
			return new pe(this._line, 0, this._line, this._text.length)
		}
		get rangeIncludingLineBreak() {
			return this._isLastLine ? this.range : new pe(this._line, 0, this._line + 1, 0)
		}
		get firstNonWhitespaceCharacterIndex() {
			return /^(\s*)/.exec(this._text)[1].length
		}
		get isEmptyOrWhitespace() {
			return this.firstNonWhitespaceCharacterIndex === this._text.length
		}
	}
var dl = class {
		constructor(e) {
			;(this._prefix = e), (this._lastId = 0)
		}
		nextId() {
			return this._prefix + ++this._lastId
		}
	},
	cEe = new dl("id#")
var tC = class o {
		static {
			this._Keys = new dl("TextEditorDecorationType")
		}
		constructor(e, t, n) {
			let r = o._Keys.nextId()
			e.$registerTextEditorDecorationType(t.identifier, r, RD.from(n)),
				(this.value = Object.freeze({
					key: r,
					dispose() {
						e.$removeTextEditorDecorationType(r)
					},
				}))
		}
	},
	Jk = class {
		constructor(e, t) {
			this._collectedEdits = []
			this._setEndOfLine = void 0
			this._finalized = !1
			;(this._document = e),
				(this._documentVersionId = e.version),
				(this._undoStopBefore = t.undoStopBefore),
				(this._undoStopAfter = t.undoStopAfter)
		}
		finalize() {
			return (
				(this._finalized = !0),
				{
					documentVersionId: this._documentVersionId,
					edits: this._collectedEdits,
					setEndOfLine: this._setEndOfLine,
					undoStopBefore: this._undoStopBefore,
					undoStopAfter: this._undoStopAfter,
				}
			)
		}
		_throwIfFinalized() {
			if (this._finalized) throw new Error("Edit is only valid while callback runs")
		}
		replace(e, t) {
			this._throwIfFinalized()
			let n = null
			if (e instanceof Pe) n = new pe(e, e)
			else if (e instanceof pe) n = e
			else throw new Error("Unrecognized location")
			this._pushEdit(n, t, !1)
		}
		insert(e, t) {
			this._throwIfFinalized(), this._pushEdit(new pe(e, e), t, !0)
		}
		delete(e) {
			this._throwIfFinalized()
			let t = null
			if (e instanceof pe) t = e
			else throw new Error("Unrecognized location")
			this._pushEdit(t, null, !0)
		}
		_pushEdit(e, t, n) {
			let r = this._document.validateRange(e)
			this._collectedEdits.push({ range: r, text: t, forceMoveMarkers: n })
		}
		setEndOfLine(e) {
			if ((this._throwIfFinalized(), e !== 1 && e !== 2)) throw We("endOfLine")
			this._setEndOfLine = e
		}
	},
	Xk = class {
		constructor(e, t, n, r) {
			;(this._proxy = e), (this._id = t), this._accept(n), (this._logService = r)
			let i = this
			this.value = {
				get tabSize() {
					return i._tabSize
				},
				set tabSize(s) {
					i._setTabSize(s)
				},
				get indentSize() {
					return i._indentSize
				},
				set indentSize(s) {
					i._setIndentSize(s)
				},
				get insertSpaces() {
					return i._insertSpaces
				},
				set insertSpaces(s) {
					i._setInsertSpaces(s)
				},
				get cursorStyle() {
					return i._cursorStyle
				},
				set cursorStyle(s) {
					i._setCursorStyle(s)
				},
				get lineNumbers() {
					return i._lineNumbers
				},
				set lineNumbers(s) {
					i._setLineNumbers(s)
				},
			}
		}
		_accept(e) {
			;(this._tabSize = e.tabSize),
				(this._indentSize = e.indentSize),
				(this._originalIndentSize = e.originalIndentSize),
				(this._insertSpaces = e.insertSpaces),
				(this._cursorStyle = e.cursorStyle),
				(this._lineNumbers = kd.to(e.lineNumbers))
		}
		_validateTabSize(e) {
			if (e === "auto") return "auto"
			if (typeof e == "number") {
				let t = Math.floor(e)
				return t > 0 ? t : null
			}
			if (typeof e == "string") {
				let t = parseInt(e, 10)
				return isNaN(t) ? null : t > 0 ? t : null
			}
			return null
		}
		_setTabSize(e) {
			let t = this._validateTabSize(e)
			if (t !== null) {
				if (typeof t == "number") {
					if (this._tabSize === t) return
					this._tabSize = t
				}
				this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, { tabSize: t }))
			}
		}
		_validateIndentSize(e) {
			if (e === "tabSize") return "tabSize"
			if (typeof e == "number") {
				let t = Math.floor(e)
				return t > 0 ? t : null
			}
			if (typeof e == "string") {
				let t = parseInt(e, 10)
				return isNaN(t) ? null : t > 0 ? t : null
			}
			return null
		}
		_setIndentSize(e) {
			let t = this._validateIndentSize(e)
			if (t !== null) {
				if (typeof t == "number") {
					if (this._originalIndentSize === t) return
					;(this._indentSize = t), (this._originalIndentSize = t)
				}
				this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, { indentSize: t }))
			}
		}
		_validateInsertSpaces(e) {
			return e === "auto" ? "auto" : e === "false" ? !1 : !!e
		}
		_setInsertSpaces(e) {
			let t = this._validateInsertSpaces(e)
			if (typeof t == "boolean") {
				if (this._insertSpaces === t) return
				this._insertSpaces = t
			}
			this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, { insertSpaces: t }))
		}
		_setCursorStyle(e) {
			this._cursorStyle !== e &&
				((this._cursorStyle = e),
				this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, { cursorStyle: e })))
		}
		_setLineNumbers(e) {
			this._lineNumbers !== e &&
				((this._lineNumbers = e),
				this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, { lineNumbers: kd.from(e) })))
		}
		assign(e) {
			let t = {},
				n = !1
			if (typeof e.tabSize < "u") {
				let r = this._validateTabSize(e.tabSize)
				r === "auto"
					? ((n = !0), (t.tabSize = r))
					: typeof r == "number" && this._tabSize !== r && ((this._tabSize = r), (n = !0), (t.tabSize = r))
			}
			if (typeof e.indentSize < "u") {
				let r = this._validateIndentSize(e.indentSize)
				r === "tabSize"
					? ((n = !0), (t.indentSize = r))
					: typeof r == "number" &&
						this._originalIndentSize !== r &&
						((this._indentSize = r), (this._originalIndentSize = r), (n = !0), (t.indentSize = r))
			}
			if (typeof e.insertSpaces < "u") {
				let r = this._validateInsertSpaces(e.insertSpaces)
				r === "auto"
					? ((n = !0), (t.insertSpaces = r))
					: this._insertSpaces !== r && ((this._insertSpaces = r), (n = !0), (t.insertSpaces = r))
			}
			typeof e.cursorStyle < "u" &&
				this._cursorStyle !== e.cursorStyle &&
				((this._cursorStyle = e.cursorStyle), (n = !0), (t.cursorStyle = e.cursorStyle)),
				typeof e.lineNumbers < "u" &&
					this._lineNumbers !== e.lineNumbers &&
					((this._lineNumbers = e.lineNumbers), (n = !0), (t.lineNumbers = kd.from(e.lineNumbers))),
				n && this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, t))
		}
		_warnOnError(e, t) {
			t.catch((n) => {
				this._logService.warn(`ExtHostTextEditorOptions '${e}' failed:'`), this._logService.warn(n)
			})
		}
	},
	nC = class {
		constructor(e, t, n, r, i, s, a, l) {
			this.id = e
			this._proxy = t
			this._logService = n
			this._disposed = !1
			this._hasDecorationsForKey = new Set()
			;(this._selections = i),
				(this._options = new Xk(this._proxy, this.id, s, n)),
				(this._visibleRanges = a),
				(this._viewColumn = l)
			let d = this
			this.value = Object.freeze({
				get document() {
					return r.value
				},
				set document(c) {
					throw new wo("document")
				},
				get selection() {
					return d._selections && d._selections[0]
				},
				set selection(c) {
					if (!(c instanceof Vn)) throw We("selection")
					;(d._selections = [c]), d._trySetSelection()
				},
				get selections() {
					return d._selections
				},
				set selections(c) {
					if (!Array.isArray(c) || c.some((u) => !(u instanceof Vn))) throw We("selections")
					;(d._selections = c), d._trySetSelection()
				},
				get visibleRanges() {
					return d._visibleRanges
				},
				set visibleRanges(c) {
					throw new wo("visibleRanges")
				},
				get diffInformation() {
					return d._diffInformation
				},
				get options() {
					return d._options.value
				},
				set options(c) {
					d._disposed || d._options.assign(c)
				},
				get viewColumn() {
					return d._viewColumn
				},
				set viewColumn(c) {
					throw new wo("viewColumn")
				},
				edit(c, u = { undoStopBefore: !0, undoStopAfter: !0 }) {
					if (d._disposed) return Promise.reject(new Error("TextEditor#edit not possible on closed editors"))
					let m = new Jk(r.value, u)
					return c(m), d._applyEdit(m)
				},
				insertSnippet(c, u, m = { undoStopBefore: !0, undoStopAfter: !0 }) {
					if (d._disposed)
						return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"))
					let f
					if (!u || (Array.isArray(u) && u.length === 0)) f = d._selections.map((h) => H.from(h))
					else if (u instanceof Pe) {
						let { lineNumber: h, column: g } = Je.from(u)
						f = [{ startLineNumber: h, startColumn: g, endLineNumber: h, endColumn: g }]
					} else if (u instanceof pe) f = [H.from(u)]
					else {
						f = []
						for (let h of u)
							if (h instanceof pe) f.push(H.from(h))
							else {
								let { lineNumber: g, column: I } = Je.from(h)
								f.push({ startLineNumber: g, startColumn: I, endLineNumber: g, endColumn: I })
							}
					}
					return (
						m.keepWhitespace === void 0 && (m.keepWhitespace = !1),
						t.$tryInsertSnippet(e, r.value.version, c.value, f, m)
					)
				},
				setDecorations(c, u) {
					let m = u.length === 0
					;(m && !d._hasDecorationsForKey.has(c.key)) ||
						(m ? d._hasDecorationsForKey.delete(c.key) : d._hasDecorationsForKey.add(c.key),
						d._runOnProxy(() => {
							if (kD(u)) return t.$trySetDecorations(e, c.key, IF(u))
							{
								let f = new Array(4 * u.length)
								for (let h = 0, g = u.length; h < g; h++) {
									let I = u[h]
									;(f[4 * h] = I.start.line + 1),
										(f[4 * h + 1] = I.start.character + 1),
										(f[4 * h + 2] = I.end.line + 1),
										(f[4 * h + 3] = I.end.character + 1)
								}
								return t.$trySetDecorationsFast(e, c.key, f)
							}
						}))
				},
				revealRange(c, u) {
					d._runOnProxy(() => t.$tryRevealRange(e, H.from(c), u || 0))
				},
				show(c) {
					t.$tryShowEditor(e, wt.from(c))
				},
				hide() {
					t.$tryHideEditor(e)
				},
				[Symbol.for("debug.description")]() {
					return `TextEditor(${this.document.uri.toString()})`
				},
			})
		}
		dispose() {
			yn(!this._disposed), (this._disposed = !0)
		}
		_acceptOptions(e) {
			yn(!this._disposed), this._options._accept(e)
		}
		_acceptVisibleRanges(e) {
			yn(!this._disposed), (this._visibleRanges = e)
		}
		_acceptViewColumn(e) {
			yn(!this._disposed), (this._viewColumn = e)
		}
		_acceptSelections(e) {
			yn(!this._disposed), (this._selections = e)
		}
		_acceptDiffInformation(e) {
			yn(!this._disposed), (this._diffInformation = e)
		}
		async _trySetSelection() {
			let e = this._selections.map(Zn.from)
			return await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, e)), this.value
		}
		_applyEdit(e) {
			let t = e.finalize()
			if (t.edits.length === 0 && !t.setEndOfLine) return Promise.resolve(!0)
			let n = t.edits.map((i) => i.range)
			n.sort((i, s) =>
				i.end.line === s.end.line
					? i.end.character === s.end.character
						? i.start.line === s.start.line
							? i.start.character - s.start.character
							: i.start.line - s.start.line
						: i.end.character - s.end.character
					: i.end.line - s.end.line,
			)
			for (let i = 0, s = n.length - 1; i < s; i++) {
				let a = n[i].end
				if (n[i + 1].start.isBefore(a)) return Promise.reject(new Error("Overlapping ranges are not allowed!"))
			}
			let r = t.edits.map((i) => ({ range: H.from(i.range), text: i.text, forceMoveMarkers: i.forceMoveMarkers }))
			return this._proxy.$tryApplyEdits(this.id, t.documentVersionId, r, {
				setEndOfLine: typeof t.setEndOfLine == "number" ? Ed.from(t.setEndOfLine) : void 0,
				undoStopBefore: t.undoStopBefore,
				undoStopAfter: t.undoStopAfter,
			})
		}
		_runOnProxy(e) {
			return this._disposed
				? (this._logService.warn("TextEditor is closed/disposed"), Promise.resolve(void 0))
				: e().then(
						() => this,
						(t) => ((t instanceof Error && t.name === "DISPOSED") || this._logService.warn(t), null),
					)
		}
	}
var Yk = class {
		constructor(e) {
			this.value = e
			this._count = 0
		}
		ref() {
			this._count++
		}
		unref() {
			return --this._count === 0
		}
	},
	Vp = class {
		constructor(e, t) {
			this._extHostRpc = e
			this._logService = t
			this._activeEditorId = null
			this._editors = new Map()
			this._documents = new ft()
			this._onDidAddDocuments = new E()
			this._onDidRemoveDocuments = new E()
			this._onDidChangeVisibleTextEditors = new E()
			this._onDidChangeActiveTextEditor = new E()
			this.onDidAddDocuments = this._onDidAddDocuments.event
			this.onDidRemoveDocuments = this._onDidRemoveDocuments.event
			this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event
			this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event
		}
		$acceptDocumentsAndEditorsDelta(e) {
			this.acceptDocumentsAndEditorsDelta(e)
		}
		acceptDocumentsAndEditorsDelta(e) {
			let t = [],
				n = [],
				r = []
			if (e.removedDocuments)
				for (let i of e.removedDocuments) {
					let s = y.revive(i),
						a = this._documents.get(s)
					a?.unref() && (this._documents.delete(s), t.push(a.value))
				}
			if (e.addedDocuments)
				for (let i of e.addedDocuments) {
					let s = y.revive(i.uri),
						a = this._documents.get(s)
					if (a && s.scheme !== W.vscodeNotebookCell && s.scheme !== W.vscodeInteractiveInput)
						throw new Error(`document '${s} already exists!'`)
					a ||
						((a = new Yk(
							new eC(
								this._extHostRpc.getProxy(N.MainThreadDocuments),
								s,
								i.lines,
								i.EOL,
								i.versionId,
								i.languageId,
								i.isDirty,
								i.encoding,
							),
						)),
						this._documents.set(s, a),
						n.push(a.value)),
						a.ref()
				}
			if (e.removedEditors)
				for (let i of e.removedEditors) {
					let s = this._editors.get(i)
					this._editors.delete(i), s && r.push(s)
				}
			if (e.addedEditors)
				for (let i of e.addedEditors) {
					let s = y.revive(i.documentUri)
					yn(this._documents.has(s), `document '${s}' does not exist`),
						yn(!this._editors.has(i.id), `editor '${i.id}' already exists!`)
					let a = this._documents.get(s).value,
						l = new nC(
							i.id,
							this._extHostRpc.getProxy(N.MainThreadTextEditors),
							this._logService,
							new Rt(() => a.document),
							i.selections.map(Zn.to),
							i.options,
							i.visibleRanges.map((d) => H.to(d)),
							typeof i.editorPosition == "number" ? wt.to(i.editorPosition) : void 0,
						)
					this._editors.set(i.id, l)
				}
			e.newActiveEditor !== void 0 &&
				(yn(
					e.newActiveEditor === null || this._editors.has(e.newActiveEditor),
					`active editor '${e.newActiveEditor}' does not exist`,
				),
				(this._activeEditorId = e.newActiveEditor)),
				Fn(t),
				Fn(r),
				e.removedDocuments && this._onDidRemoveDocuments.fire(t),
				e.addedDocuments && this._onDidAddDocuments.fire(n),
				(e.removedEditors || e.addedEditors) &&
					this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((i) => i.value)),
				e.newActiveEditor !== void 0 && this._onDidChangeActiveTextEditor.fire(this.activeEditor())
		}
		getDocument(e) {
			return this._documents.get(e)?.value
		}
		allDocuments() {
			return kt.map(this._documents.values(), (e) => e.value)
		}
		getEditor(e) {
			return this._editors.get(e)
		}
		activeEditor(e) {
			if (!this._activeEditorId) return
			let t = this._editors.get(this._activeEditorId)
			return e ? t : t?.value
		}
		allEditors() {
			return [...this._editors.values()]
		}
	}
Vp = R([S(0, ie), S(1, te)], Vp)
var eo = O("IExtHostDocumentsAndEditors")
var $s = O("IExtHostApiDeprecationService"),
	Bp = class {
		constructor(e, t) {
			this._extHostLogService = t
			this._reportedUsages = new Set()
			this._telemetryShape = e.getProxy(N.MainThreadTelemetry)
		}
		report(e, t, n) {
			let r = this.getUsageKey(e, t)
			this._reportedUsages.has(r) ||
				(this._reportedUsages.add(r),
				t.isUnderDevelopment &&
					this._extHostLogService.warn(`[Deprecation Warning] '${e}' is deprecated. ${n}`),
				this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
					extensionId: t.identifier.value,
					apiId: e,
				}))
		}
		getUsageKey(e, t) {
			return `${e}-${t.identifier.value}`
		}
	}
Bp = R([S(0, ie), S(1, te)], Bp)
var WEe = Object.freeze(
	new (class {
		report(o, e, t) {}
	})(),
)
var k8 = {
		type: "object",
		additionalProperties: !1,
		properties: {
			type: {
				type: "string",
				description: p(
					"TaskDefinition.description",
					"The actual task type. Please note that types starting with a '$' are reserved for internal usage.",
				),
			},
			required: { type: "array", items: { type: "string" } },
			properties: {
				type: "object",
				description: p("TaskDefinition.properties", "Additional properties of the task type"),
				additionalProperties: { $ref: "http://json-schema.org/draft-07/schema#" },
			},
			when: {
				type: "string",
				markdownDescription: p(
					"TaskDefinition.when",
					"Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information.",
				),
				default: "",
			},
		},
	},
	I2
;((e) => {
	function o(t, n, r) {
		if (!t) return
		let i = Ee(t.type) ? t.type : void 0
		if (!i || i.length === 0) {
			r.error(
				p(
					"TaskTypeConfiguration.noType",
					"The task type configuration is missing the required 'taskType' property",
				),
			)
			return
		}
		let s = []
		if (Array.isArray(t.required)) for (let a of t.required) Ee(a) && s.push(a)
		return {
			extensionId: n.value,
			taskType: i,
			required: s,
			properties: t.properties ? je(t.properties) : {},
			when: t.when ? Lt.deserialize(t.when) : void 0,
		}
	}
	e.from = o
})((I2 ||= {}))
var R8 = Ey.registerExtensionPoint({
		extensionPoint: "taskDefinitions",
		activationEventsGenerator: (o, e) => {
			for (let t of o) t.type && e.push(`onTaskType:${t.type}`)
		},
		jsonSchema: { description: p("TaskDefinitionExtPoint", "Contributes task kinds"), type: "array", items: k8 },
	}),
	Zk = class {
		constructor() {
			this._onDefinitionsChanged = new E()
			this.onDefinitionsChanged = this._onDefinitionsChanged.event
			;(this.taskTypes = Object.create(null)),
				(this.readyPromise = new Promise((e, t) => {
					R8.setHandler((n, r) => {
						this._schema = void 0
						try {
							for (let i of r.removed) {
								let s = i.value
								for (let a of s)
									this.taskTypes && a.type && this.taskTypes[a.type] && delete this.taskTypes[a.type]
							}
							for (let i of r.added) {
								let s = i.value
								for (let a of s) {
									let l = I2.from(a, i.description.identifier, i.collector)
									l && (this.taskTypes[l.taskType] = l)
								}
							}
							;(r.removed.length > 0 || r.added.length > 0) && this._onDefinitionsChanged.fire()
						} catch {}
						e(void 0)
					})
				}))
		}
		onReady() {
			return this.readyPromise
		}
		get(e) {
			return this.taskTypes[e]
		}
		all() {
			return Object.keys(this.taskTypes).map((e) => this.taskTypes[e])
		}
		getJsonSchema() {
			if (this._schema === void 0) {
				let e = []
				for (let t of this.all()) {
					let n = { type: "object", additionalProperties: !1 }
					t.required.length > 0 && (n.required = t.required.slice(0)),
						t.properties !== void 0
							? (n.properties = je(t.properties))
							: (n.properties = Object.create(null)),
						(n.properties.type = { type: "string", enum: [t.taskType] }),
						e.push(n)
				}
				this._schema = { oneOf: e }
			}
			return this._schema
		}
	},
	x2 = new Zk()
var C2 = "settings",
	ewe = new D("taskRunning", !1, p("tasks.taskRunningContext", "Whether a task is currently running.")),
	twe = new D("taskTerminalActive", !1, p("taskTerminalActive", "Whether the active terminal is a task terminal.")),
	nwe = ef("tasksCategory", "Tasks"),
	tR = ((n) => ((n[(n.Escape = 1)] = "Escape"), (n[(n.Strong = 2)] = "Strong"), (n[(n.Weak = 3)] = "Weak"), n))(
		tR || {},
	)
;((e) => {
	function o(t) {
		if (!t) return 2
		switch (t.toLowerCase()) {
			case "escape":
				return 1
			case "strong":
				return 2
			case "weak":
				return 3
			default:
				return 2
		}
	}
	e.from = o
})((tR ||= {}))
var A8
;((e) => (e.defaults = { cwd: "${workspaceFolder}" }))((A8 ||= {}))
var nR = ((n) => ((n[(n.Always = 1)] = "Always"), (n[(n.Silent = 2)] = "Silent"), (n[(n.Never = 3)] = "Never"), n))(
	nR || {},
)
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "always":
				return 1
			case "silent":
				return 2
			case "never":
				return 3
			default:
				return 1
		}
	}
	e.fromString = o
})((nR ||= {}))
var rR = ((n) => (
	(n[(n.Never = 1)] = "Never"), (n[(n.OnProblem = 2)] = "OnProblem"), (n[(n.Always = 3)] = "Always"), n
))(rR || {})
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "always":
				return 3
			case "never":
				return 1
			case "onproblem":
				return 2
			default:
				return 2
		}
	}
	e.fromString = o
})((rR ||= {}))
var oR = ((n) => ((n[(n.Shared = 1)] = "Shared"), (n[(n.Dedicated = 2)] = "Dedicated"), (n[(n.New = 3)] = "New"), n))(
	oR || {},
)
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "shared":
				return 1
			case "dedicated":
				return 2
			case "new":
				return 3
			default:
				return 1
		}
	}
	e.fromString = o
})((oR ||= {}))
var O8
;((e) =>
	(e.defaults = { echo: !0, reveal: 1, revealProblems: 1, focus: !1, panel: 1, showReuseMessage: !0, clear: !1 }))(
	(O8 ||= {}),
)
var iR = ((n) => (
	(n[(n.Shell = 1)] = "Shell"), (n[(n.Process = 2)] = "Process"), (n[(n.CustomExecution = 3)] = "CustomExecution"), n
))(iR || {})
;((t) => {
	function o(n) {
		switch (n.toLowerCase()) {
			case "shell":
				return 1
			case "process":
				return 2
			case "customExecution":
				return 3
			default:
				return 2
		}
	}
	t.fromString = o
	function e(n) {
		switch (n) {
			case 1:
				return "shell"
			case 2:
				return "process"
			case 3:
				return "customExecution"
			default:
				return "process"
		}
	}
	t.toString = e
})((iR ||= {}))
var L8
;((e) => {
	function o(t) {
		return Ee(t) ? t : t.value
	}
	e.value = o
})((L8 ||= {}))
var M8
;((s) => {
	;(s.Clean = { _id: "clean", isDefault: !1 }),
		(s.Build = { _id: "build", isDefault: !1 }),
		(s.Rebuild = { _id: "rebuild", isDefault: !1 }),
		(s.Test = { _id: "test", isDefault: !1 })
	function r(a) {
		return a === s.Clean._id || a === s.Build._id || a === s.Rebuild._id || a === s.Test._id
	}
	s.is = r
	function i(a) {
		if (a !== void 0) return Ee(a) ? (r(a) ? { _id: a, isDefault: !1 } : void 0) : a
	}
	s.from = i
})((M8 ||= {}))
var F8
;((s) => {
	;(s.Workspace = "workspace"),
		(s.Extension = "extension"),
		(s.InMemory = "inMemory"),
		(s.WorkspaceFile = "workspaceFile"),
		(s.User = "user")
	function i(a) {
		switch (a) {
			case s.User:
				return 2
			case s.WorkspaceFile:
				return 5
			default:
				return 6
		}
	}
	s.toConfigurationTarget = i
})((F8 ||= {}))
var N8
;((e) => (e.defaults = { reevaluateOnRerun: !0, runOn: 1, instanceLimit: 1 }))((N8 ||= {}))
var sR = ((t) => ((t[(t.Process = 1)] = "Process"), (t[(t.Terminal = 2)] = "Terminal"), t))(sR || {})
;((e) => (e._default = 2))((sR ||= {}))
var U8
;((a) => {
	function o(l) {
		return {
			taskId: l._id,
			taskName: l.configurationProperties.name,
			runType: l.configurationProperties.isBackground ? "background" : "singleRun",
			group: l.configurationProperties.group,
			__task: l,
		}
	}
	function e(l, d, c) {
		return { ...o(l), kind: "start", terminalId: d, resolvedVariables: c }
	}
	a.start = e
	function t(l, d, c) {
		return { ...o(l), kind: "processStarted", terminalId: d, processId: c }
	}
	a.processStarted = t
	function n(l, d, c) {
		return { ...o(l), kind: "processEnded", terminalId: d, exitCode: c }
	}
	a.processEnded = n
	function r(l, d, c) {
		return { ...o(l), kind: "terminated", exitReason: c, terminalId: d }
	}
	a.terminated = r
	function i(l, d, c) {
		return { ...o(d), kind: l, terminalId: c }
	}
	a.general = i
	function s() {
		return { kind: "changed" }
	}
	a.changed = s
})((U8 ||= {}))
var eR
;((t) => {
	function o(n) {
		let r = Object.keys(n).sort(),
			i = ""
		for (let s of r) {
			let a = n[s]
			a instanceof Object ? (a = o(a)) : typeof a == "string" && (a = a.replace(/,/g, ",,")),
				(i += s + "," + a + ",")
		}
		return i
	}
	function e(n) {
		let i = { _key: o(n), type: n.taskType }
		return Object.assign(i, n), i
	}
	t.create = e
})((eR ||= {}))
var H8
;((e) => {
	function o(t, n) {
		let r = x2.get(t.type)
		if (r === void 0) {
			let l = je(t)
			return delete l._key, eR.create(l)
		}
		let i = Object.create(null)
		i.type = r.taskType
		let s = new Set()
		r.required.forEach((l) => s.add(l))
		let a = r.properties
		for (let l of Object.keys(a)) {
			let d = t[l]
			if (d != null) i[l] = d
			else if (s.has(l)) {
				let c = a[l]
				if (c.default !== void 0) i[l] = je(c.default)
				else
					switch (c.type) {
						case "boolean":
							i[l] = !1
							break
						case "number":
						case "integer":
							i[l] = 0
							break
						case "string":
							i[l] = ""
							break
						default:
							n.error(
								p(
									"TaskDefinition.missingRequiredProperty",
									"Error: the task identifier '{0}' is missing the required property '{1}'. The task identifier will be ignored.",
									JSON.stringify(t, void 0, 0),
									l,
								),
							)
							return
					}
			}
		}
		return eR.create(i)
	}
	e.createTaskIdentifier = o
})((H8 ||= {}))
var aR
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((aR ||= {}))
var lR
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((lR ||= {}))
var S2
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((S2 ||= {}))
var rC
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && !!i.process
		} else return !1
	}
	n.is = o
	function e(r) {
		if (r == null) return
		let i = { process: r.process, args: r.args }
		return r.options && (i.options = S2.from(r.options)), i
	}
	n.from = e
	function t(r) {
		if (r != null) return new xi(r.process, r.args, r.options)
	}
	n.to = t
})((rC ||= {}))
var T2
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((T2 ||= {}))
var oC
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && (!!i.commandLine || !!i.command)
		} else return !1
	}
	n.is = o
	function e(r) {
		if (r == null) return
		let i = {}
		return (
			r.commandLine !== void 0 ? (i.commandLine = r.commandLine) : ((i.command = r.command), (i.args = r.args)),
			r.options && (i.options = T2.from(r.options)),
			i
		)
	}
	n.from = e
	function t(r) {
		if (!(r == null || (r.command === void 0 && r.commandLine === void 0)))
			return r.commandLine ? new zo(r.commandLine, r.options) : new zo(r.command, r.args ? r.args : [], r.options)
	}
	n.to = t
})((oC ||= {}))
var Jo
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && i.customExecution === "customExecution"
		} else return !1
	}
	n.is = o
	function e(r) {
		return { customExecution: "customExecution" }
	}
	n.from = e
	function t(r, i) {
		return i.get(r)
	}
	n.to = t
})((Jo ||= {}))
var dR
;((e) => {
	function o(t, n) {
		let r
		return (
			t.scope !== void 0 && typeof t.scope != "number"
				? (r = t.scope.uri)
				: t.scope !== void 0 &&
					typeof t.scope == "number" &&
					(t.scope === 2 && n && n.workspaceFile ? (r = n.workspaceFile) : (r = C2)),
			{ id: t._id, workspaceFolder: r }
		)
	}
	e.from = o
})((dR ||= {}))
var E2
;((e) => {
	function o(t) {
		if (t != null) return { _id: t.id, isDefault: t.isDefault }
	}
	e.from = o
})((E2 ||= {}))
var Ni
;((n) => {
	function o(r, i) {
		if (r == null) return []
		let s = []
		for (let a of r) {
			let l = e(a, i)
			l && s.push(l)
		}
		return s
	}
	n.fromMany = o
	function e(r, i) {
		if (r == null) return
		let s
		r.execution instanceof xi
			? (s = rC.from(r.execution))
			: r.execution instanceof zo
				? (s = oC.from(r.execution))
				: r.execution && r.execution instanceof hd && (s = Jo.from(r.execution))
		let a = aR.from(r.definition),
			l
		return (
			r.scope ? (typeof r.scope == "number" ? (l = r.scope) : (l = r.scope.uri)) : (l = 2),
			!a || !l
				? void 0
				: {
						_id: r._id,
						definition: a,
						name: r.name,
						source: { extensionId: i.identifier.value, label: r.source, scope: l },
						execution: s,
						isBackground: r.isBackground,
						group: E2.from(r.group),
						presentationOptions: lR.from(r.presentationOptions),
						problemMatchers: an(r.problemMatchers),
						hasDefinedMatchers: r.hasDefinedMatchers,
						runOptions: r.runOptions ? r.runOptions : { reevaluateOnRerun: !0 },
						detail: r.detail,
					}
		)
	}
	n.from = e
	async function t(r, i, s) {
		if (r == null) return
		let a
		rC.is(r.execution)
			? (a = rC.to(r.execution))
			: oC.is(r.execution)
				? (a = oC.to(r.execution))
				: Jo.is(r.execution) && (a = Jo.to(r._id, s))
		let l = aR.to(r.definition),
			d
		if (
			(r.source &&
				(r.source.scope !== void 0
					? typeof r.source.scope == "number"
						? (d = r.source.scope)
						: (d = await i.resolveWorkspaceFolder(y.revive(r.source.scope)))
					: (d = 2)),
			!l || !d)
		)
			return
		let c = new gn(l, d, r.name, r.source.label, a, r.problemMatchers)
		return (
			r.isBackground !== void 0 && (c.isBackground = r.isBackground),
			r.group !== void 0 &&
				((c.group = un.from(r.group._id)),
				c.group &&
					r.group.isDefault &&
					((c.group = new un(c.group.id, c.group.label)),
					r.group.isDefault === !0 && (c.group.isDefault = r.group.isDefault))),
			r.presentationOptions && (c.presentationOptions = lR.to(r.presentationOptions)),
			r._id && (c._id = r._id),
			r.detail && (c.detail = r.detail),
			c
		)
	}
	n.to = t
})((Ni ||= {}))
var w2
;((t) => {
	function o(n) {
		return n
	}
	t.from = o
	function e(n) {
		if (n) return Object.assign(Object.create(null), n)
	}
	t.to = e
})((w2 ||= {}))
var Xg = class {
		constructor(e, t, n) {
			this._id = t
			this._task = n
			this.#e = e
		}
		#e
		get task() {
			return this._task
		}
		terminate() {
			this.#e.terminateTask(this)
		}
		fireDidStartProcess(e) {}
		fireDidEndProcess(e) {}
	},
	Fd = class {
		constructor(e, t, n, r, i, s, a, l) {
			this._onDidExecuteTask = new E()
			this._onDidTerminateTask = new E()
			this._onDidTaskProcessStarted = new E()
			this._onDidTaskProcessEnded = new E()
			this._onDidStartTaskProblemMatchers = new E()
			this._onDidEndTaskProblemMatchers = new E()
			;(this._proxy = e.getProxy(N.MainThreadTask)),
				(this._workspaceProvider = n),
				(this._editorService = r),
				(this._configurationService = i),
				(this._terminalService = s),
				(this._handleCounter = 0),
				(this._handlers = new Map()),
				(this._taskExecutions = new Map()),
				(this._taskExecutionPromises = new Map()),
				(this._providedCustomExecutions2 = new Map()),
				(this._notProvidedCustomExecutions = new Set()),
				(this._activeCustomExecutions2 = new Map()),
				(this._logService = a),
				(this._deprecationService = l),
				this._proxy.$registerSupportedExecutions(!0)
		}
		registerTaskProvider(e, t, n) {
			if (!n) return new ye(() => {})
			let r = this.nextHandle()
			return (
				this._handlers.set(r, { type: t, provider: n, extension: e }),
				this._proxy.$registerTaskProvider(r, t),
				new ye(() => {
					this._handlers.delete(r), this._proxy.$unregisterTaskProvider(r)
				})
			)
		}
		registerTaskSystem(e, t) {
			this._proxy.$registerTaskSystem(e, t)
		}
		fetchTasks(e) {
			return this._proxy.$fetchTasks(w2.from(e)).then(async (t) => {
				let n = []
				for (let r of t) {
					let i = await Ni.to(r, this._workspaceProvider, this._providedCustomExecutions2)
					i && n.push(i)
				}
				return n
			})
		}
		get taskExecutions() {
			let e = []
			return this._taskExecutions.forEach((t) => e.push(t)), e
		}
		terminateTask(e) {
			if (!(e instanceof Xg)) throw new Error("No valid task execution provided")
			return this._proxy.$terminateTask(e._id)
		}
		get onDidStartTask() {
			return this._onDidExecuteTask.event
		}
		async $onDidStartTask(e, t, n) {
			let r = this._providedCustomExecutions2.get(e.id)
			r &&
				(this._activeCustomExecutions2.set(e.id, r),
				this._terminalService.attachPtyToTerminal(t, await r.callback(n))),
				(this._lastStartedTask = e.id),
				this._onDidExecuteTask.fire({ execution: await this.getTaskExecution(e) })
		}
		get onDidEndTask() {
			return this._onDidTerminateTask.event
		}
		async $OnDidEndTask(e) {
			if (!this._taskExecutionPromises.has(e.id)) return
			let t = await this.getTaskExecution(e)
			this._taskExecutionPromises.delete(e.id),
				this._taskExecutions.delete(e.id),
				this.customExecutionComplete(e),
				this._onDidTerminateTask.fire({ execution: t })
		}
		get onDidStartTaskProcess() {
			return this._onDidTaskProcessStarted.event
		}
		async $onDidStartTaskProcess(e) {
			let t = await this.getTaskExecution(e.id)
			this._onDidTaskProcessStarted.fire({ execution: t, processId: e.processId })
		}
		get onDidEndTaskProcess() {
			return this._onDidTaskProcessEnded.event
		}
		async $onDidEndTaskProcess(e) {
			let t = await this.getTaskExecution(e.id)
			this._onDidTaskProcessEnded.fire({ execution: t, exitCode: e.exitCode })
		}
		get onDidStartTaskProblemMatchers() {
			return this._onDidStartTaskProblemMatchers.event
		}
		async $onDidStartTaskProblemMatchers(e) {
			let t
			try {
				t = await this.getTaskExecution(e.execution.id)
			} catch {
				return
			}
			this._onDidStartTaskProblemMatchers.fire({ execution: t })
		}
		get onDidEndTaskProblemMatchers() {
			return this._onDidEndTaskProblemMatchers.event
		}
		async $onDidEndTaskProblemMatchers(e) {
			let t
			try {
				t = await this.getTaskExecution(e.execution.id)
			} catch {
				return
			}
			this._onDidEndTaskProblemMatchers.fire({ execution: t, hasErrors: e.hasErrors })
		}
		$provideTasks(e, t) {
			let n = this._handlers.get(e)
			if (!n) return Promise.reject(new Error("no handler found"))
			let r = [],
				i = Jt(() => n.provider.provideTasks(De.None)).then((s) => this.provideTasksInternal(t, r, n, s))
			return new Promise((s) => {
				i.then((a) => {
					Promise.all(r).then(() => {
						s(a)
					})
				})
			})
		}
		async $resolveTask(e, t) {
			let n = this._handlers.get(e)
			if (!n) return Promise.reject(new Error("no handler found"))
			if (t.definition.type !== n.type)
				throw new Error(
					`Unexpected: Task of type [${t.definition.type}] cannot be resolved by provider of type [${n.type}].`,
				)
			let r = await Ni.to(t, this._workspaceProvider, this._providedCustomExecutions2)
			if (!r) throw new Error("Unexpected: Task cannot be resolved.")
			let i = await n.provider.resolveTask(r, De.None)
			if (!i) return
			this.checkDeprecation(i, n)
			let s = Ni.from(i, n.extension)
			if (!s) throw new Error("Unexpected: Task cannot be resolved.")
			if (i.definition !== r.definition)
				throw new Error(
					"Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.",
				)
			return Jo.is(s.execution) && (await this.addCustomExecution(s, i, !0)), await this.resolveTaskInternal(s)
		}
		nextHandle() {
			return this._handleCounter++
		}
		async addCustomExecution(e, t, n) {
			let r = await this._proxy.$createTaskId(e)
			!n &&
				!this._providedCustomExecutions2.has(r) &&
				(this._notProvidedCustomExecutions.add(r), this._activeCustomExecutions2.set(r, t.execution)),
				this._providedCustomExecutions2.set(r, t.execution)
		}
		async getTaskExecution(e, t) {
			if (typeof e == "string") {
				let i = this._taskExecutionPromises.get(e)
				if (!i) throw new Kn("Unexpected: The specified task is missing an execution")
				return i
			}
			let n = this._taskExecutionPromises.get(e.id)
			if (n) return n
			let r
			return (
				t
					? (r = Promise.resolve(new Xg(this, e.id, t)))
					: (r = Ni.to(e.task, this._workspaceProvider, this._providedCustomExecutions2).then((i) => {
							if (!i) throw new Kn("Unexpected: Task does not exist.")
							return new Xg(this, e.id, i)
						})),
				this._taskExecutionPromises.set(e.id, r),
				r.then((i) => (this._taskExecutions.set(e.id, i), i))
			)
		}
		checkDeprecation(e, t) {
			e._deprecated &&
				this._deprecationService.report(
					"Task.constructor",
					t.extension,
					"Use the Task constructor that takes a `scope` instead.",
				)
		}
		customExecutionComplete(e) {
			this._activeCustomExecutions2.get(e.id) && this._activeCustomExecutions2.delete(e.id),
				this._notProvidedCustomExecutions.has(e.id) &&
					this._lastStartedTask !== e.id &&
					(this._providedCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.delete(e.id))
			let n = this._notProvidedCustomExecutions.values(),
				r = n.next()
			for (; !r.done; )
				!this._activeCustomExecutions2.has(r.value) &&
					this._lastStartedTask !== r.value &&
					(this._providedCustomExecutions2.delete(r.value),
					this._notProvidedCustomExecutions.delete(r.value)),
					(r = n.next())
		}
	}
Fd = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, eo), S(4, pn), S(5, er), S(6, te), S(7, $s)], Fd)
var $p = class extends Fd {
	constructor(e, t, n, r, i, s, a, l) {
		super(e, t, n, r, i, s, a, l),
			this.registerTaskSystem(W.vscodeRemote, { scheme: W.vscodeRemote, authority: "", platform: tE(0) })
	}
	async executeTask(e, t) {
		if (!t.execution) throw new Error("Tasks to execute must include an execution")
		let n = Ni.from(t, e)
		if (n === void 0) throw new Error("Task is not valid")
		if (Jo.is(n.execution)) await this.addCustomExecution(n, t, !1)
		else throw new Sl()
		let r = await this.getTaskExecution(await this._proxy.$getTaskExecution(n), t)
		return (
			this._proxy.$executeTask(n).catch((i) => {
				throw new Error(i)
			}),
			r
		)
	}
	provideTasksInternal(e, t, n, r) {
		let i = []
		if (r)
			for (let s of r) {
				if ((this.checkDeprecation(s, n), !s.definition || !e[s.definition.type])) {
					let l = s.source ? s.source : "No task source"
					this._logService.warn(
						`The task [${l}, ${s.name}] uses an undefined task type. The task will be ignored in the future.`,
					)
				}
				let a = Ni.from(s, n.extension)
				a && Jo.is(a.execution)
					? (i.push(a), t.push(this.addCustomExecution(a, s, !0)))
					: this._logService.warn("Only custom execution tasks supported.")
			}
		return { tasks: i, extension: n.extension }
	}
	async resolveTaskInternal(e) {
		if (Jo.is(e.execution)) return e
		this._logService.warn("Only custom execution tasks supported.")
	}
	async $resolveVariables(e, t) {
		return { process: void 0, variables: Object.create(null) }
	}
	async $jsonTasksSupported() {
		return !1
	}
	async $findExecutable(e, t, n) {}
}
$p = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, eo), S(4, pn), S(5, er), S(6, te), S(7, $s)], $p)
var zp = O("IExtHostTask")
var qp = class {
	constructor() {
		this.pendingRequests = new Map()
		this.queue = []
		this._onError = new E()
		this._onExit = new E()
		this.sequence = 1
	}
	get onError() {
		return this._onError.event
	}
	get onExit() {
		return this._onExit.event
	}
	onMessage(e) {
		this.messageCallback && this._onError.fire(new Error("attempt to set more than one 'Message' callback")),
			(this.messageCallback = e)
	}
	onEvent(e) {
		this.eventCallback && this._onError.fire(new Error("attempt to set more than one 'Event' callback")),
			(this.eventCallback = e)
	}
	onRequest(e) {
		this.requestCallback && this._onError.fire(new Error("attempt to set more than one 'Request' callback")),
			(this.requestCallback = e)
	}
	sendResponse(e) {
		e.seq > 0
			? this._onError.fire(new Error(`attempt to send more than one response for command ${e.command}`))
			: this.internalSend("response", e)
	}
	sendRequest(e, t, n, r) {
		let i = { command: e }
		if (
			(t && Object.keys(t).length > 0 && (i.arguments = t), this.internalSend("request", i), typeof r == "number")
		) {
			let s = setTimeout(() => {
				clearTimeout(s)
				let a = this.pendingRequests.get(i.seq)
				if (a) {
					this.pendingRequests.delete(i.seq)
					let l = {
						type: "response",
						seq: 0,
						request_seq: i.seq,
						success: !1,
						command: e,
						message: p("timeout", "Timeout after {0} ms for '{1}'", r, e),
					}
					a(l)
				}
			}, r)
		}
		return n && this.pendingRequests.set(i.seq, n), i.seq
	}
	acceptMessage(e) {
		this.messageCallback
			? this.messageCallback(e)
			: (this.queue.push(e), this.queue.length === 1 && this.processQueue())
	}
	needsTaskBoundaryBetween(e, t) {
		return e.type !== "event" || t.type !== "event"
	}
	async processQueue() {
		let e
		for (; this.queue.length; ) {
			if (
				((!e || this.needsTaskBoundaryBetween(this.queue[0], e)) && (await Wt(0)), (e = this.queue.shift()), !e)
			)
				return
			switch (e.type) {
				case "event":
					this.eventCallback?.(e)
					break
				case "request":
					this.requestCallback?.(e)
					break
				case "response": {
					let t = e,
						n = this.pendingRequests.get(t.request_seq)
					n && (this.pendingRequests.delete(t.request_seq), n(t))
					break
				}
			}
		}
	}
	internalSend(e, t) {
		;(t.type = e), (t.seq = this.sequence++), this.sendMessage(t)
	}
	async cancelPendingRequests() {
		if (this.pendingRequests.size === 0) return Promise.resolve()
		let e = new Map()
		this.pendingRequests.forEach((t, n) => e.set(n, t)),
			await Wt(500),
			e.forEach((t, n) => {
				t({ type: "response", seq: 0, request_seq: n, success: !1, command: "canceled", message: "canceled" }),
					this.pendingRequests.delete(n)
			})
	}
	getPendingRequestIds() {
		return Array.from(this.pendingRequests.keys())
	}
	dispose() {
		this.queue = []
	}
}
function P2(o) {
	return o.type && (o.label || o.program || o.runtime)
}
var W8 = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/
function V8(o) {
	return !!(o && o.match(W8))
}
function _2(o) {
	if (typeof o.path == "string" && !(typeof o.sourceReference == "number" && o.sourceReference > 0)) {
		if (V8(o.path)) return y.parse(o.path)
		if (In(o.path)) return y.file(o.path)
	}
	return o.path
}
function D2(o) {
	if (typeof o.path == "object") {
		let e = y.revive(o.path)
		if (e) return e.scheme === W.file ? e.fsPath : e.toString()
	}
	return o.path
}
function k2(o, e) {
	let t = e ? _2 : D2,
		n = je(o)
	return (
		A2(n, (r, i) => {
			r && i && (i.path = t(i))
		}),
		n
	)
}
function R2(o, e) {
	let t = e ? _2 : D2,
		n = je(o)
	return (
		A2(n, (r, i) => {
			!r && i && (i.path = t(i))
		}),
		n
	)
}
function A2(o, e) {
	switch (o.type) {
		case "event": {
			let t = o
			switch (t.event) {
				case "output":
					e(!1, t.body.source)
					break
				case "loadedSource":
					e(!1, t.body.source)
					break
				case "breakpoint":
					e(!1, t.body.breakpoint.source)
					break
				default:
					break
			}
			break
		}
		case "request": {
			let t = o
			switch (t.command) {
				case "setBreakpoints":
					e(!0, t.arguments.source)
					break
				case "breakpointLocations":
					e(!0, t.arguments.source)
					break
				case "source":
					e(!0, t.arguments.source)
					break
				case "gotoTargets":
					e(!0, t.arguments.source)
					break
				case "launchVSCode":
					t.arguments.args.forEach((n) => e(!1, n))
					break
				default:
					break
			}
			break
		}
		case "response": {
			let t = o
			if (t.success && t.body)
				switch (t.command) {
					case "stackTrace":
						t.body.stackFrames.forEach((n) => e(!1, n.source))
						break
					case "loadedSources":
						t.body.sources.forEach((n) => e(!1, n))
						break
					case "scopes":
						t.body.scopes.forEach((n) => e(!1, n.source))
						break
					case "setFunctionBreakpoints":
						t.body.breakpoints.forEach((n) => e(!1, n.source))
						break
					case "setBreakpoints":
						t.body.breakpoints.forEach((n) => e(!1, n.source))
						break
					case "disassemble":
						t.body?.instructions.forEach((r) => e(!1, r.location))
						break
					case "locations":
						e(!1, t.body?.source)
						break
					default:
						break
				}
			break
		}
	}
}
var Xo = O("IExtHostEditorTabs"),
	iC = class {
		constructor(e, t, n) {
			;(this._activeTabIdGetter = n), (this._parentGroup = t), this.acceptDtoUpdate(e)
		}
		get apiObject() {
			if (!this._apiObject) {
				let e = this,
					t = {
						get isActive() {
							return e._dto.id === e._activeTabIdGetter()
						},
						get label() {
							return e._dto.label
						},
						get input() {
							return e._input
						},
						get isDirty() {
							return e._dto.isDirty
						},
						get isPinned() {
							return e._dto.isPinned
						},
						get isPreview() {
							return e._dto.isPreview
						},
						get group() {
							return e._parentGroup.apiObject
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		get tabId() {
			return this._dto.id
		}
		acceptDtoUpdate(e) {
			;(this._dto = e), (this._input = this._initInput())
		}
		_initInput() {
			switch (this._dto.input.kind) {
				case 1:
					return new za(y.revive(this._dto.input.uri))
				case 2:
					return new Ts(y.revive(this._dto.input.original), y.revive(this._dto.input.modified))
				case 3:
					return new Ru(
						y.revive(this._dto.input.base),
						y.revive(this._dto.input.input1),
						y.revive(this._dto.input.input2),
						y.revive(this._dto.input.result),
					)
				case 6:
					return new qa(y.revive(this._dto.input.uri), this._dto.input.viewType)
				case 7:
					return new Au(this._dto.input.viewType)
				case 4:
					return new Ka(y.revive(this._dto.input.uri), this._dto.input.notebookType)
				case 5:
					return new ja(
						y.revive(this._dto.input.original),
						y.revive(this._dto.input.modified),
						this._dto.input.notebookType,
					)
				case 8:
					return new Ou()
				case 9:
					return new Lu(y.revive(this._dto.input.uri), y.revive(this._dto.input.inputBoxUri))
				case 10:
					return new Mu()
				case 11:
					return new Fu(
						this._dto.input.diffEditors.map((e) => new Ts(y.revive(e.original), y.revive(e.modified))),
					)
				default:
					return
			}
		}
	},
	cR = class {
		constructor(e, t) {
			this._tabs = []
			this._activeTabId = ""
			;(this._dto = e), (this._activeGroupIdGetter = t)
			for (let n of e.tabs)
				n.isActive && (this._activeTabId = n.id), this._tabs.push(new iC(n, this, () => this.activeTabId()))
		}
		get apiObject() {
			if (!this._apiObject) {
				let e = this,
					t = {
						get isActive() {
							return e._dto.groupId === e._activeGroupIdGetter()
						},
						get viewColumn() {
							return wt.to(e._dto.viewColumn)
						},
						get activeTab() {
							return e._tabs.find((n) => n.tabId === e._activeTabId)?.apiObject
						},
						get tabs() {
							return Object.freeze(e._tabs.map((n) => n.apiObject))
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		get groupId() {
			return this._dto.groupId
		}
		get tabs() {
			return this._tabs
		}
		acceptGroupDtoUpdate(e) {
			this._dto = e
		}
		acceptTabOperation(e) {
			if (e.kind === 0) {
				let n = new iC(e.tabDto, this, () => this.activeTabId())
				return this._tabs.splice(e.index, 0, n), e.tabDto.isActive && (this._activeTabId = n.tabId), n
			} else if (e.kind === 1) {
				let n = this._tabs.splice(e.index, 1)[0]
				if (!n) throw new Error(`Tab close updated received for index ${e.index} which does not exist`)
				return n.tabId === this._activeTabId && (this._activeTabId = ""), n
			} else if (e.kind === 3) {
				if (e.oldIndex === void 0) throw new Error("Invalid old index on move IPC")
				let n = this._tabs.splice(e.oldIndex, 1)[0]
				if (!n) throw new Error(`Tab move updated received for index ${e.oldIndex} which does not exist`)
				return this._tabs.splice(e.index, 0, n), n
			}
			let t = this._tabs.find((n) => n.tabId === e.tabDto.id)
			if (!t) throw new Error("INVALID tab")
			return (
				e.tabDto.isActive
					? (this._activeTabId = e.tabDto.id)
					: this._activeTabId === e.tabDto.id && !e.tabDto.isActive && (this._activeTabId = ""),
				t.acceptDtoUpdate(e.tabDto),
				t
			)
		}
		activeTabId() {
			return this._activeTabId
		}
	},
	Kp = class {
		constructor(e) {
			this._onDidChangeTabs = new E()
			this._onDidChangeTabGroups = new E()
			this._extHostTabGroups = []
			this._proxy = e.getProxy(N.MainThreadEditorTabs)
		}
		get tabGroups() {
			if (!this._apiObject) {
				let e = this,
					t = {
						onDidChangeTabGroups: e._onDidChangeTabGroups.event,
						onDidChangeTabs: e._onDidChangeTabs.event,
						get all() {
							return Object.freeze(e._extHostTabGroups.map((n) => n.apiObject))
						},
						get activeTabGroup() {
							let n = e._activeGroupId
							return Do(e._extHostTabGroups.find((i) => i.groupId === n)?.apiObject)
						},
						close: async (n, r) => {
							let i = Array.isArray(n) ? n : [n]
							return i.length ? (B8(i[0]) ? this._closeGroups(i, r) : this._closeTabs(i, r)) : !0
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		$acceptEditorTabModel(e) {
			let t = new Set(this._extHostTabGroups.map((d) => d.groupId)),
				n = new Set(e.map((d) => d.groupId)),
				r = NT(t, n),
				i = this._extHostTabGroups.filter((d) => r.removed.includes(d.groupId)).map((d) => d.apiObject),
				s = [],
				a = []
			this._extHostTabGroups = e.map((d) => {
				let c = new cR(d, () => this._activeGroupId)
				return r.added.includes(c.groupId) ? s.push(c.apiObject) : a.push(c.apiObject), c
			})
			let l = Do(e.find((d) => d.isActive === !0)?.groupId)
			l !== void 0 && this._activeGroupId !== l && (this._activeGroupId = l),
				this._onDidChangeTabGroups.fire(Object.freeze({ opened: s, closed: i, changed: a }))
		}
		$acceptTabGroupUpdate(e) {
			let t = this._extHostTabGroups.find((n) => n.groupId === e.groupId)
			if (!t) throw new Error("Update Group IPC call received before group creation.")
			t.acceptGroupDtoUpdate(e),
				e.isActive && (this._activeGroupId = e.groupId),
				this._onDidChangeTabGroups.fire(Object.freeze({ changed: [t.apiObject], opened: [], closed: [] }))
		}
		$acceptTabOperation(e) {
			let t = this._extHostTabGroups.find((r) => r.groupId === e.groupId)
			if (!t) throw new Error("Update Tabs IPC call received before group creation.")
			let n = t.acceptTabOperation(e)
			switch (e.kind) {
				case 0:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [n.apiObject], closed: [], changed: [] }))
					return
				case 1:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [], closed: [n.apiObject], changed: [] }))
					return
				case 3:
				case 2:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [], closed: [], changed: [n.apiObject] }))
					return
			}
		}
		_findExtHostTabFromApi(e) {
			for (let t of this._extHostTabGroups) for (let n of t.tabs) if (n.apiObject === e) return n
		}
		_findExtHostTabGroupFromApi(e) {
			return this._extHostTabGroups.find((t) => t.apiObject === e)
		}
		async _closeTabs(e, t) {
			let n = []
			for (let r of e) {
				let i = this._findExtHostTabFromApi(r)
				if (!i) throw new Error("Tab close: Invalid tab not found!")
				n.push(i.tabId)
			}
			return this._proxy.$closeTab(n, t)
		}
		async _closeGroups(e, t) {
			let n = []
			for (let r of e) {
				let i = this._findExtHostTabGroupFromApi(r)
				if (!i) throw new Error("Group close: Invalid group not found!")
				n.push(i.groupId)
			}
			return this._proxy.$closeGroup(n, t)
		}
	}
Kp = R([S(0, ie)], Kp)
function B8(o) {
	return o.tabs !== void 0
}
var uPe = {
	6: p("testState.errored", "Errored"),
	4: p("testState.failed", "Failed"),
	3: p("testState.passed", "Passed"),
	1: p("testState.queued", "Queued"),
	2: p("testState.running", "Running"),
	5: p("testState.skipped", "Skipped"),
	0: p("testState.unset", "Not yet run"),
}
var pPe = { 4: p("testGroup.debug", "Debug"), 2: p("testGroup.run", "Run"), 8: p("testGroup.coverage", "Coverage") }
var z8 = 0,
	O2 = new WeakMap(),
	zs = O("IExtHostTesting"),
	jp = class extends $ {
		constructor(t, n, r, i) {
			super()
			this.logService = n
			this.commands = r
			this.editors = i
			this.resultsChangedEmitter = this._register(new E())
			this.controllers = new Map()
			this.defaultProfilesChangedEmitter = this._register(new E())
			this.followupProviders = new Set()
			this.testFollowups = new Map()
			this.onResultsChanged = this.resultsChangedEmitter.event
			this.results = []
			;(this.proxy = t.getProxy(N.MainThreadTesting)),
				(this.observer = new gR(this.proxy)),
				(this.runTracker = new pR(this.proxy, n)),
				r.registerArgumentProcessor({
					processArgument: (s) => {
						switch (s?.$mid) {
							case 16: {
								let a = s,
									l = a.tests[a.tests.length - 1].item.extId
								return this.controllers.get(ze.root(l))?.collection.tree.get(l)?.actual ?? Ek(s)
							}
							case 18: {
								let { test: a, message: l } = s,
									d = a.item.extId
								return {
									test:
										this.controllers.get(ze.root(d))?.collection.tree.get(d)?.actual ??
										Ek({ $mid: 16, tests: [a] }),
									message: Yu.to(l),
								}
							}
							default:
								return s
						}
					},
				}),
				r.registerCommand(!1, "testing.getExplorerSelection", async () => {
					let s = await r.executeCommand("_testing.getExplorerSelection"),
						a = (l) => {
							let d = this.controllers.get(ze.root(l))
							if (d) return ze.isRoot(l) ? d.controller : d.collection.tree.get(l)?.actual
						}
					return { include: s?.include.map(a).filter(rr) || [], exclude: s?.exclude.map(a).filter(rr) || [] }
				})
		}
		createTestController(t, n, r, i) {
			if (this.controllers.has(n)) throw new Error(`Attempt to insert a duplicate controller with ID "${n}"`)
			let s = new Q(),
				a = s.add(new Nx(n, r, this.editors))
			a.root.label = r
			let l = new Map(),
				d = new Set(),
				c = this.proxy,
				u = () => {
					let h = 0
					i && (h |= 2)
					let g = f.relatedCodeProvider
					return g && (g?.provideRelatedTests && (h |= 8), g?.provideRelatedCode && (h |= 4)), h
				},
				m = {
					items: a.root.children,
					get label() {
						return r
					},
					set label(h) {
						;(r = h), (a.root.label = h), c.$updateController(n, { label: r })
					},
					get refreshHandler() {
						return i
					},
					set refreshHandler(h) {
						;(i = h), c.$updateController(n, { capabilities: u() })
					},
					get id() {
						return n
					},
					get relatedCodeProvider() {
						return f.relatedCodeProvider
					},
					set relatedCodeProvider(h) {
						M(t, "testRelatedCode"),
							(f.relatedCodeProvider = h),
							c.$updateController(n, { capabilities: u() })
					},
					createRunProfile: (h, g, I, C, T, w) => {
						let L = ar(h)
						for (; l.has(L); ) L++
						return new aC(
							this.proxy,
							l,
							d,
							this.defaultProfilesChangedEmitter.event,
							n,
							L,
							h,
							g,
							I,
							C,
							T,
							w,
						)
					},
					createTestItem(h, g, I) {
						return new Vs(n, h, g, I)
					},
					createTestRun: (h, g, I = !0) => this.runTracker.createTestRun(t, n, a, h, g, I),
					invalidateTestResults: (h) => {
						if (h === void 0) this.proxy.$markTestRetired(void 0)
						else {
							let g = h instanceof Array ? h : [h]
							this.proxy.$markTestRetired(g.map((I) => ze.fromExtHostTestItem(I, n).toString()))
						}
					},
					set resolveHandler(h) {
						a.resolveHandler = h
					},
					get resolveHandler() {
						return a.resolveHandler
					},
					dispose: () => {
						s.dispose()
					},
				},
				f = { controller: m, collection: a, profiles: l, extension: t, activeProfiles: d }
			return (
				c.$registerTestController(n, r, u()),
				s.add(q(() => c.$unregisterTestController(n))),
				this.controllers.set(n, f),
				s.add(q(() => this.controllers.delete(n))),
				s.add(a.onDidGenerateDiff((h) => c.$publishDiff(n, h.map(Ay.serialize)))),
				m
			)
		}
		createTestObserver() {
			return this.observer.checkout()
		}
		async runTests(t, n = De.None) {
			let r = L2(t)
			if (!r) throw new Error("The request passed to `vscode.test.runTests` must include a profile")
			let i = this.controllers.get(r.controllerId)
			if (!i) throw new Error("Controller not found")
			await this.proxy.$runTests(
				{
					preserveFocus: t.preserveFocus ?? !0,
					group: Zu.from(r.kind),
					targets: [
						{
							testIds: t.include?.map((s) =>
								ze.fromExtHostTestItem(s, i.collection.root.id).toString(),
							) ?? [i.collection.root.id],
							profileId: r.profileId,
							controllerId: r.controllerId,
						},
					],
					exclude: t.exclude?.map((s) => s.id),
				},
				n,
			)
		}
		registerTestFollowupProvider(t) {
			return (
				this.followupProviders.add(t),
				{
					dispose: () => {
						this.followupProviders.delete(t)
					},
				}
			)
		}
		async $getTestsRelatedToCode(t, n, r) {
			let i = this.editors.getDocument(y.revive(t))
			if (!i) return []
			let s = Je.to(n),
				a = []
			return (
				await Promise.all(
					[...this.controllers.values()].map(async (l) => {
						let d
						try {
							d = await l.relatedCodeProvider?.provideRelatedTests?.(i.document, s, r)
						} catch (c) {
							r.isCancellationRequested ||
								this.logService.warn(
									`Error thrown while providing related tests for ${l.controller.label}`,
									c,
								)
						}
						if (d) {
							for (let c of d) a.push(ze.fromExtHostTestItem(c, l.controller.id).toString())
							l.collection.flushDiff()
						}
					}),
				),
				a
			)
		}
		async $getCodeRelatedToTest(t, n) {
			let r = this.controllers.get(ze.root(t))
			if (!r) return []
			let i = r.collection.tree.get(t)
			return i ? ((await r.relatedCodeProvider?.provideRelatedCode?.(i.actual, n))?.map(Bn.from) ?? []) : []
		}
		$syncTests() {
			for (let { collection: t } of this.controllers.values()) t.flushDiff()
			return Promise.resolve()
		}
		async $getCoverageDetails(t, n, r) {
			return (await this.runTracker.getCoverageDetails(t, n, r))?.map(Eg.fromDetails)
		}
		async $disposeRun(t) {
			this.runTracker.disposeTestRun(t)
		}
		$configureRunProfile(t, n) {
			this.controllers.get(t)?.profiles.get(n)?.configureHandler?.()
		}
		$setDefaultRunProfiles(t) {
			let n = new Map()
			for (let [r, i] of Object.entries(t)) {
				let s = this.controllers.get(r)
				if (!s) continue
				let a = new Map(),
					l = i.filter((c) => !s.activeProfiles.has(c)),
					d = [...s.activeProfiles].filter((c) => !i.includes(c))
				for (let c of l) a.set(c, !0), s.activeProfiles.add(c)
				for (let c of d) a.set(c, !1), s.activeProfiles.delete(c)
				a.size && n.set(r, a)
			}
			this.defaultProfilesChangedEmitter.fire(n)
		}
		async $refreshTests(t, n) {
			await this.controllers.get(t)?.controller.refreshHandler?.(n)
		}
		$publishTestResults(t) {
			;(this.results = Object.freeze(
				t
					.map((n) => {
						let r = GD.to(n),
							i = n.tasks.findIndex((s) => s.hasCoverage)
						return (
							i !== -1 &&
								(r.getDetailedCoverage = (s, a = De.None) =>
									this.proxy.$getCoverageDetails(n.id, i, s, a).then((l) => l.map(Eg.to))),
							O2.set(r, n.id),
							r
						)
					})
					.concat(this.results)
					.sort((n, r) => r.completedAt - n.completedAt)
					.slice(0, 32),
			)),
				this.resultsChangedEmitter.fire()
		}
		async $expandTest(t, n) {
			let r = this.controllers.get(ze.fromString(t).controllerId)?.collection
			r && (await r.expand(t, n < 0 ? 1 / 0 : n), r.flushDiff())
		}
		$acceptDiff(t) {
			this.observer.applyDiff(t.map((n) => Ay.deserialize({ asCanonicalUri: (r) => r }, n)))
		}
		async $runControllerTests(t, n) {
			return Promise.all(t.map((r) => this.runControllerTestRequest(r, !1, n)))
		}
		async $startContinuousRun(t, n) {
			let r = new _e(n),
				i = await Promise.all(t.map((s) => this.runControllerTestRequest(s, !0, r.token)))
			return (
				!n.isCancellationRequested &&
					!i.some((s) => s.error) &&
					(await new Promise((s) => n.onCancellationRequested(s))),
				r.dispose(!0),
				i
			)
		}
		async $provideTestFollowups(t, n) {
			let r = this.results.find((a) => O2.get(a) === t.resultId),
				i = r && K8(ze.fromString(t.extId), r?.results)
			if (!i) return []
			let s = []
			return (
				await Promise.all(
					[...this.followupProviders].map(async (a) => {
						try {
							let l = await a.provideFollowup(r, i, t.taskIndex, t.messageIndex, n)
							l && (s = s.concat(l))
						} catch (l) {
							this.logService.error("Error thrown while providing followup for test message", l)
						}
					}),
				),
				n.isCancellationRequested
					? []
					: s.map((a) => {
							let l = z8++
							return this.testFollowups.set(l, a), { title: a.title, id: l }
						})
			)
		}
		$disposeTestFollowups(t) {
			for (let n of t) this.testFollowups.delete(n)
		}
		$executeTestFollowup(t) {
			let n = this.testFollowups.get(t)
			return n ? this.commands.executeCommand(n.command, ...(n.arguments || [])) : Promise.resolve()
		}
		$cancelExtensionTestRun(t, n) {
			t === void 0 ? this.runTracker.cancelAllRuns() : this.runTracker.cancelRunById(t, n)
		}
		getMetadataForRun(t) {
			for (let n of this.runTracker.trackers) {
				let r = n.getTaskIdForRun(t)
				if (r) return { taskId: r, runId: n.id }
			}
		}
		async runControllerTestRequest(t, n, r) {
			let i = this.controllers.get(t.controllerId)
			if (!i) return {}
			let { collection: s, profiles: a, extension: l } = i,
				d = a.get(t.profileId)
			if (!d) return {}
			let c = t.testIds.map((h) => s.tree.get(h)).filter(rr),
				u = t.excludeExtIds
					.map((h) => i.collection.tree.get(h))
					.filter(rr)
					.filter((h) => c.some((g) => g.fullId.compare(h.fullId) === 2))
			if (!c.length) return {}
			let m = new Ua(
					c.some((h) => h.actual instanceof xp) ? void 0 : c.map((h) => h.actual),
					u.map((h) => h.actual),
					d,
					n,
				),
				f = oF(t) && this.runTracker.prepareForMainThreadTestRun(l, m, sC.fromInternal(t, i.collection), d, r)
			try {
				return await d.runHandler(m, r), {}
			} catch (h) {
				return { error: String(h) }
			} finally {
				f && f.hasRunningTasks && !r.isCancellationRequested && (await Te.toPromise(f.onEnd))
			}
		}
	}
jp = R([S(0, ie), S(1, te), S(2, Tn), S(3, eo)], jp)
var q8 = 1e4
var uR = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.dto = t
			this.proxy = n
			this.logService = r
			this.profile = i
			this.extension = s
			this.state = 0
			this.running = 0
			this.tasks = new Map()
			this.sharedTestIds = new Set()
			this.endEmitter = this._register(new E())
			this.publishedCoverage = new Map()
			this.onEnd = this.endEmitter.event
			this.cts = this._register(new _e(a))
			let l = this._register(new Hn(() => this.forciblyEndTasks(), q8))
			this._register(this.cts.token.onCancellationRequested(() => l.schedule()))
			let d = new E()
			;(this.onDidDispose = d.event),
				this._register(
					q(() => {
						d.fire(), d.dispose()
					}),
				)
		}
		get hasRunningTasks() {
			return this.running > 0
		}
		get id() {
			return this.dto.id
		}
		getTaskIdForRun(t) {
			for (let [n, { run: r }] of this.tasks) if (r === t) return n
		}
		cancel(t) {
			t
				? this.tasks.get(t)?.cts.cancel()
				: this.state === 0
					? (this.cts.cancel(), (this.state = 1))
					: this.state === 1 && this.forciblyEndTasks()
		}
		async getCoverageDetails(t, n, r) {
			let [, i] = ze.fromString(t).path,
				s = this.publishedCoverage.get(t)
			if (!s) return []
			let { report: a, extIds: l } = s,
				d = this.tasks.get(i)
			if (!d) throw new Error("unreachable: run task was not found")
			let c
			if (n && a instanceof Ss) {
				let m = l.indexOf(n)
				if (m === -1) return []
				c = a.includesTests[m]
			}
			return (
				(await (c
					? this.profile?.loadDetailedCoverageForTest?.(d.run, a, c, r)
					: this.profile?.loadDetailedCoverage?.(d.run, a, r))) ?? []
			)
		}
		createRun(t) {
			let n = this.dto.id,
				r = this.dto.controllerId,
				i = He(),
				s =
					(u) =>
					(m, ...f) => {
						if (l) {
							this.logService.warn(`Setting the state of test "${m.id}" is a no-op after the run ends.`)
							return
						}
						this.ensureTestIsKnown(m), u(m, ...f)
					},
				a = (u, m) => {
					let f = m instanceof Array ? m.map(Yu.from) : [Yu.from(m)]
					if (u.uri && u.range) {
						let h = { range: H.from(u.range), uri: u.uri }
						for (let g of f) g.location = g.location || h
					}
					this.proxy.$appendTestMessagesInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), f)
				},
				l = !1,
				d = this._register(new _e(this.cts.token)),
				c = {
					isPersisted: this.dto.isPersisted,
					token: d.token,
					name: t,
					onDidDispose: this.onDidDispose,
					addCoverage: (u) => {
						if (l) return
						let m = u instanceof Ss ? u.includesTests : []
						if (m.length) for (let g of m) this.ensureTestIsKnown(g)
						let f = u.uri.toString(),
							h = new ze([n, i, f]).toString()
						this.publishedCoverage.set(h, {
							report: u,
							extIds: m.map((g) => ze.fromExtHostTestItem(g, r).toString()),
						}),
							this.proxy.$appendCoverage(n, i, Eg.fromFile(r, h, u))
					},
					enqueued: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 1)
					}),
					skipped: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 5)
					}),
					started: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 2)
					}),
					errored: s((u, m, f) => {
						a(u, m), this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 6, f)
					}),
					failed: s((u, m, f) => {
						a(u, m), this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 4, f)
					}),
					passed: s((u, m) => {
						this.proxy.$updateTestStateInRun(
							n,
							i,
							ze.fromExtHostTestItem(u, this.dto.controllerId).toString(),
							3,
							m,
						)
					}),
					appendOutput: (u, m, f) => {
						l ||
							(f && this.ensureTestIsKnown(f),
							this.proxy.$appendOutputToRun(
								n,
								i,
								z.fromString(u),
								m && Bn.from(m),
								f && ze.fromExtHostTestItem(f, r).toString(),
							))
					},
					end: () => {
						l || ((l = !0), this.proxy.$finishedTestRunTask(n, i), --this.running || this.markEnded())
					},
				}
			return (
				this.running++,
				this.tasks.set(i, { run: c, cts: d }),
				this.proxy.$startedTestRunTask(n, {
					id: i,
					ctrlId: this.dto.controllerId,
					name: t || this.extension.displayName || this.extension.identifier.value,
					running: !0,
				}),
				c
			)
		}
		forciblyEndTasks() {
			for (let { run: t } of this.tasks.values()) t.end()
		}
		markEnded() {
			this.state !== 2 && ((this.state = 2), this.endEmitter.fire())
		}
		ensureTestIsKnown(t) {
			if (!(t instanceof Vs)) throw new Ca(t.id)
			if (this.sharedTestIds.has(ze.fromExtHostTestItem(t, this.dto.controllerId).toString())) return
			let n = [],
				r = this.dto.colllection.root
			for (;;) {
				let i = Ri.from(t)
				if ((n.unshift(i), this.sharedTestIds.has(i.extId) || (this.sharedTestIds.add(i.extId), t === r))) break
				t = t.parent || r
			}
			this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, n)
		}
		dispose() {
			this.markEnded(), super.dispose()
		}
	},
	pR = class {
		constructor(e, t) {
			this.proxy = e
			this.logService = t
			this.tracked = new Map()
			this.trackedById = new Map()
		}
		get trackers() {
			return this.tracked.values()
		}
		getCoverageDetails(e, t, n) {
			let r = ze.root(e)
			return this.trackedById.get(r)?.getCoverageDetails(e, t, n) || []
		}
		disposeTestRun(e) {
			this.trackedById.get(e)?.dispose(), this.trackedById.delete(e)
			for (let [t, { id: n }] of this.tracked) n === e && this.tracked.delete(t)
		}
		prepareForMainThreadTestRun(e, t, n, r, i) {
			return this.getTracker(t, n, r, e, i)
		}
		cancelRunById(e, t) {
			this.trackedById.get(e)?.cancel(t)
		}
		cancelAllRuns() {
			for (let e of this.tracked.values()) e.cancel()
		}
		createTestRun(e, t, n, r, i, s) {
			let a = this.tracked.get(r)
			if (a) return a.createRun(i)
			let l = sC.fromPublic(t, n, r, s),
				d = L2(r)
			this.proxy.$startedExtensionTestRun({
				controllerId: t,
				continuous: !!r.continuous,
				profile: d && { group: Zu.from(d.kind), id: d.profileId },
				exclude: r.exclude?.map((u) => ze.fromExtHostTestItem(u, n.root.id).toString()) ?? [],
				id: l.id,
				include: r.include?.map((u) => ze.fromExtHostTestItem(u, n.root.id).toString()) ?? [n.root.id],
				preserveFocus: r.preserveFocus ?? !0,
				persist: s,
			})
			let c = this.getTracker(r, l, r.profile, e)
			return (
				Te.once(c.onEnd)(() => {
					this.proxy.$finishedExtensionTestRun(l.id)
				}),
				c.createRun(i)
			)
		}
		getTracker(e, t, n, r, i) {
			let s = new uR(t, this.proxy, this.logService, n, r, i)
			return this.tracked.set(e, s), this.trackedById.set(s.id, s), s
		}
	},
	L2 = (o) => {
		if (o.profile) {
			if (!(o.profile instanceof aC))
				throw new Error(
					"TestRunRequest.profile is not an instance created from TestController.createRunProfile",
				)
			return o.profile
		}
	},
	sC = class o {
		constructor(e, t, n, r) {
			this.controllerId = e
			this.id = t
			this.isPersisted = n
			this.colllection = r
		}
		static fromPublic(e, t, n, r) {
			return new o(e, He(), r, t)
		}
		static fromInternal(e, t) {
			return new o(e.controllerId, e.runId, !0, t)
		}
	},
	mR = class {
		constructor(e) {
			this.emitter = e
			this.added = new Set()
			this.updated = new Set()
			this.removed = new Set()
			this.alreadyRemoved = new Set()
		}
		get isEmpty() {
			return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0
		}
		add(e) {
			this.added.add(e)
		}
		update(e) {
			Object.assign(e.revived, Ri.toPlain(e.item)), this.added.has(e) || this.updated.add(e)
		}
		remove(e) {
			if (this.added.has(e)) {
				this.added.delete(e)
				return
			}
			this.updated.delete(e)
			let t = ze.parentId(e.item.extId)
			if (t && this.alreadyRemoved.has(t.toString())) {
				this.alreadyRemoved.add(e.item.extId)
				return
			}
			this.removed.add(e)
		}
		getChangeEvent() {
			let { added: e, updated: t, removed: n } = this
			return {
				get added() {
					return [...e].map((r) => r.revived)
				},
				get updated() {
					return [...t].map((r) => r.revived)
				},
				get removed() {
					return [...n].map((r) => r.revived)
				},
			}
		}
		complete() {
			this.isEmpty || this.emitter.fire(this.getChangeEvent())
		}
	},
	fR = class extends Dy {
		constructor() {
			super(...arguments)
			this.changeEmitter = new E()
			this.onDidChangeTests = this.changeEmitter.event
		}
		get rootTests() {
			return this.roots
		}
		getMirroredTestDataById(t) {
			return this.items.get(t)
		}
		getMirroredTestDataByReference(t) {
			return this.items.get(t.id)
		}
		createItem(t, n) {
			return { ...t, revived: Ri.toPlain(t.item), depth: n ? n.depth + 1 : 0, children: new Set() }
		}
		createChangeCollector() {
			return new mR(this.changeEmitter)
		}
	},
	gR = class {
		constructor(e) {
			this.proxy = e
		}
		checkout() {
			this.current || (this.current = this.createObserverData())
			let e = this.current
			return (
				e.observers++,
				{
					onDidChangeTest: e.tests.onDidChangeTests,
					get tests() {
						return [...e.tests.rootTests].map((t) => t.revived)
					},
					dispose: zi(() => {
						--e.observers === 0 && (this.proxy.$unsubscribeFromDiffs(), (this.current = void 0))
					}),
				}
			)
		}
		getMirroredTestDataByReference(e) {
			return this.current?.tests.getMirroredTestDataByReference(e)
		}
		applyDiff(e) {
			this.current?.tests.apply(e)
		}
		createObserverData() {
			let e = new fR({ asCanonicalUri: (t) => t })
			return this.proxy.$subscribeToDiffs(), { observers: 0, tests: e }
		}
	},
	Yg = (o, e, t, n) => {
		t ? Object.assign(t, n) : e.$updateTestRunConfig(o.controllerId, o.profileId, n)
	},
	aC = class extends Pu {
		constructor(t, n, r, i, s, a, l, d, c, u = !1, m = void 0, f = !1) {
			super(s, a, d)
			this._label = l
			this.runHandler = c
			this._tag = m
			this._supportsContinuousRun = f
			;(this.#e = t), (this.#i = n), (this.#t = r), (this.#n = i), n.set(a, this)
			let h = Zu.from(d)
			u && r.add(a),
				(this.#r = {
					profileId: a,
					controllerId: s,
					tag: m ? Co.namespace(this.controllerId, m.id) : null,
					label: l,
					group: h,
					isDefault: u,
					hasConfigurationHandler: !1,
					supportsContinuousRun: f,
				}),
				queueMicrotask(() => {
					this.#r && (this.#e.$publishTestRunProfile(this.#r), (this.#r = void 0))
				})
		}
		#e
		#t
		#n
		#r
		#i
		get label() {
			return this._label
		}
		set label(t) {
			t !== this._label && ((this._label = t), Yg(this, this.#e, this.#r, { label: t }))
		}
		get supportsContinuousRun() {
			return this._supportsContinuousRun
		}
		set supportsContinuousRun(t) {
			t !== this._supportsContinuousRun &&
				((this._supportsContinuousRun = t), Yg(this, this.#e, this.#r, { supportsContinuousRun: t }))
		}
		get isDefault() {
			return this.#t.has(this.profileId)
		}
		set isDefault(t) {
			t !== this.isDefault &&
				(t ? this.#t.add(this.profileId) : this.#t.delete(this.profileId),
				Yg(this, this.#e, this.#r, { isDefault: t }))
		}
		get tag() {
			return this._tag
		}
		set tag(t) {
			t?.id !== this._tag?.id &&
				((this._tag = t), Yg(this, this.#e, this.#r, { tag: t ? Co.namespace(this.controllerId, t.id) : null }))
		}
		get configureHandler() {
			return this._configureHandler
		}
		set configureHandler(t) {
			t !== this._configureHandler &&
				((this._configureHandler = t), Yg(this, this.#e, this.#r, { hasConfigurationHandler: !!t }))
		}
		get onDidChangeDefault() {
			return Te.chain(this.#n, (t) => t.map((n) => n.get(this.controllerId)?.get(this.profileId)).filter(rr))
		}
		dispose() {
			this.#i?.delete(this.profileId) &&
				((this.#i = void 0), this.#e.$removeTestProfile(this.controllerId, this.profileId)),
				(this.#r = void 0)
		}
	}
function K8(o, e) {
	for (let t = 0; t < o.path.length; t++) {
		let n = e.find((r) => r.id === o.path[t])
		if (!n) return
		if (t === o.path.length - 1) return n
		e = n.children
	}
}
var u_e = O("configurationResolverService"),
	hR = ((K) => (
		(K.Unknown = "unknown"),
		(K.Env = "env"),
		(K.Config = "config"),
		(K.Command = "command"),
		(K.Input = "input"),
		(K.ExtensionInstallFolder = "extensionInstallFolder"),
		(K.WorkspaceFolder = "workspaceFolder"),
		(K.Cwd = "cwd"),
		(K.WorkspaceFolderBasename = "workspaceFolderBasename"),
		(K.UserHome = "userHome"),
		(K.LineNumber = "lineNumber"),
		(K.ColumnNumber = "columnNumber"),
		(K.SelectedText = "selectedText"),
		(K.File = "file"),
		(K.FileWorkspaceFolder = "fileWorkspaceFolder"),
		(K.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename"),
		(K.RelativeFile = "relativeFile"),
		(K.RelativeFileDirname = "relativeFileDirname"),
		(K.FileDirname = "fileDirname"),
		(K.FileExtname = "fileExtname"),
		(K.FileBasename = "fileBasename"),
		(K.FileBasenameNoExtension = "fileBasenameNoExtension"),
		(K.FileDirnameBasename = "fileDirnameBasename"),
		(K.ExecPath = "execPath"),
		(K.ExecInstallFolder = "execInstallFolder"),
		(K.PathSeparator = "pathSeparator"),
		(K.PathSeparatorAlias = "/"),
		K
	))(hR || {}),
	M2 = Object.values(hR).filter((o) => typeof o == "string"),
	zn = class extends Kn {
		constructor(t, n) {
			super(n)
			this.variable = t
		}
	}
var Zg = class o {
	constructor(e) {
		this.locations = new Map()
		typeof e == "string"
			? ((this.stringRoot = !0), (this.root = { value: e }))
			: ((this.stringRoot = !1), (this.root = structuredClone(e)))
	}
	static {
		this.VARIABLE_LHS = "${"
	}
	static parse(e) {
		if (e instanceof o) return e
		let t = new o(e)
		return t.applyPlatformSpecificKeys(), t.parseObject(t.root), t
	}
	applyPlatformSpecificKeys() {
		let e = this.root,
			t = Ie ? "windows" : st ? "osx" : Ve ? "linux" : void 0
		t === void 0 ||
			!e ||
			typeof e != "object" ||
			!e.hasOwnProperty(t) ||
			(Object.keys(e[t]).forEach((n) => (e[n] = e[t][n])), delete e.windows, delete e.osx, delete e.linux)
	}
	parseVariable(e, t) {
		if (e[t] !== "$" || e[t + 1] !== "{") return
		let n = t + 2,
			r = 1
		for (; n < e.length; ) {
			if (e[n] === "{") r++
			else if (e[n] === "}" && (r--, r === 0)) break
			n++
		}
		if (r !== 0) return
		let i = e.slice(t, n + 1),
			s = e.substring(t + 2, n),
			a = s.indexOf(":")
		return a === -1
			? { replacement: { id: i, name: s, inner: s }, end: n }
			: { replacement: { id: i, inner: s, name: s.slice(0, a), arg: s.slice(a + 1) }, end: n }
	}
	parseObject(e) {
		if (!(typeof e != "object" || e === null)) {
			if (Array.isArray(e)) {
				for (let t = 0; t < e.length; t++) {
					let n = e[t]
					typeof n == "string" ? this.parseString(e, t, n) : this.parseObject(n)
				}
				return
			}
			for (let [t, n] of Object.entries(e)) typeof n == "string" ? this.parseString(e, t, n) : this.parseObject(n)
			for (let [t] of Object.entries(e)) this.parseString(e, t, t, !0)
		}
	}
	parseString(e, t, n, r) {
		let i = 0
		for (; i < n.length; ) {
			let s = n.indexOf("${", i)
			if (s === -1) break
			let a = this.parseVariable(n, s)
			if (a) {
				let l = this.locations.get(a.replacement.id) || { locations: [], replacement: a.replacement }
				l.locations.push({ object: e, propertyName: t, replaceKeyName: r }),
					this.locations.set(a.replacement.id, l),
					(i = a.end + 1)
			} else i = s + 2
		}
	}
	unresolved() {
		return kt.map(
			kt.filter(this.locations.values(), (e) => e.resolved === void 0),
			(e) => e.replacement,
		)
	}
	resolved() {
		return kt.map(
			kt.filter(this.locations.values(), (e) => !!e.resolved),
			(e) => [e.replacement, e.resolved],
		)
	}
	resolve(e, t) {
		typeof t != "object" && (t = { value: String(t) })
		let n = this.locations.get(e.id)
		if (n) {
			if (t.value !== void 0)
				for (let { object: r, propertyName: i, replaceKeyName: s } of n.locations || [])
					if (s && typeof i == "string") {
						let a = r[i],
							l = i.replaceAll(e.id, t.value)
						delete r[i], (r[l] = a)
					} else {
						let a = r[i].replaceAll(e.id, t.value)
						r[i] = a
					}
			n.resolved = t
		}
	}
	toObject() {
		return this.stringRoot ? this.root.value : this.root
	}
}
var lC = class {
	constructor(e, t, n, r) {
		this._contributedVariables = new Map()
		this.resolvableVariables = new Set(M2)
		;(this._context = e),
			(this._labelService = t),
			(this._userHomePromise = n),
			r && (this._envVariablesPromise = r.then((i) => this.prepareEnv(i)))
	}
	prepareEnv(e) {
		if (Ie) {
			let t = Object.create(null)
			return (
				Object.keys(e).forEach((n) => {
					t[n.toLowerCase()] = e[n]
				}),
				t
			)
		}
		return e
	}
	async resolveWithEnvironment(e, t, n) {
		let r = Zg.parse(n),
			i = { env: this.prepareEnv(e), userHome: void 0 }
		for (let s of r.unresolved()) {
			let a = await this.evaluateSingleVariable(i, s, t?.uri)
			a !== void 0 && r.resolve(s, String(a))
		}
		return r.toObject()
	}
	async resolveAsync(e, t) {
		let n = Zg.parse(t),
			r = { env: await this._envVariablesPromise, userHome: await this._userHomePromise }
		for (let i of n.unresolved()) {
			let s = await this.evaluateSingleVariable(r, i, e?.uri)
			s !== void 0 && n.resolve(i, String(s))
		}
		return n.toObject()
	}
	resolveWithInteractionReplace(e, t) {
		throw new Error("resolveWithInteractionReplace not implemented.")
	}
	resolveWithInteraction(e, t) {
		throw new Error("resolveWithInteraction not implemented.")
	}
	contributeVariable(e, t) {
		if (this._contributedVariables.has(e)) throw new Error("Variable " + e + " is contributed twice.")
		this.resolvableVariables.add(e), this._contributedVariables.set(e, t)
	}
	fsPath(e) {
		return this._labelService ? this._labelService.getUriLabel(e, { noPrefix: !0 }) : e.fsPath
	}
	async evaluateSingleVariable(e, t, n, r) {
		let { name: i, arg: s } = t,
			a = (c) => {
				let u = this._context.getFilePath()
				if (u) return Dp(u)
				throw new zn(
					c,
					p("canNotResolveFile", "Variable {0} can not be resolved. Please open an editor.", t.id),
				)
			},
			l = (c) => {
				let u = a(c)
				if (this._context.getWorkspaceFolderPathForFile) {
					let m = this._context.getWorkspaceFolderPathForFile()
					if (m) return Dp(m)
				}
				throw new zn(
					c,
					p(
						"canNotResolveFolderForFile",
						"Variable {0}: can not find workspace folder of '{1}'.",
						t.id,
						Ze(u),
					),
				)
			},
			d = (c) => {
				if (s) {
					let u = this._context.getFolderUri(s)
					if (u) return u
					throw new zn(
						c,
						p("canNotFindFolder", "Variable {0} can not be resolved. No such folder '{1}'.", c, s),
					)
				}
				if (n) return n
				throw this._context.getWorkspaceFolderCount() > 1
					? new zn(
							c,
							p(
								"canNotResolveWorkspaceFolderMultiRoot",
								"Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.",
								c,
							),
						)
					: new zn(
							c,
							p(
								"canNotResolveWorkspaceFolder",
								"Variable {0} can not be resolved. Please open a folder.",
								c,
							),
						)
			}
		switch (i) {
			case "env":
				if (s) {
					if (e.env) {
						let c = e.env[Ie ? s.toLowerCase() : s]
						if (Ee(c)) return c
					}
					return ""
				}
				throw new zn(
					"env",
					p(
						"missingEnvVarName",
						"Variable {0} can not be resolved because no environment variable name is given.",
						t.id,
					),
				)
			case "config":
				if (s) {
					let c = this._context.getConfigurationValue(n, s)
					if (bt(c))
						throw new zn(
							"config",
							p(
								"configNotFound",
								"Variable {0} can not be resolved because setting '{1}' not found.",
								t.id,
								s,
							),
						)
					if (dt(c))
						throw new zn(
							"config",
							p(
								"configNoString",
								"Variable {0} can not be resolved because '{1}' is a structured value.",
								t.id,
								s,
							),
						)
					return c
				}
				throw new zn(
					"config",
					p("missingConfigName", "Variable {0} can not be resolved because no settings name is given.", t.id),
				)
			case "command":
				return this.resolveFromMap("command", t.id, s, r, "command")
			case "input":
				return this.resolveFromMap("input", t.id, s, r, "input")
			case "extensionInstallFolder":
				if (s) {
					let c = await this._context.getExtension(s)
					if (!c)
						throw new zn(
							"extensionInstallFolder",
							p(
								"extensionNotInstalled",
								"Variable {0} can not be resolved because the extension {1} is not installed.",
								t.id,
								s,
							),
						)
					return this.fsPath(c.extensionLocation)
				}
				throw new zn(
					"extensionInstallFolder",
					p(
						"missingExtensionName",
						"Variable {0} can not be resolved because no extension name is given.",
						t.id,
					),
				)
			default:
				switch (i) {
					case "workspaceRoot":
					case "workspaceFolder": {
						let c = d("workspaceFolder")
						return c ? Dp(this.fsPath(c)) : void 0
					}
					case "cwd": {
						if (!n && !s) return Ao()
						let c = d("cwd")
						return c ? Dp(this.fsPath(c)) : void 0
					}
					case "workspaceRootFolderName":
					case "workspaceFolderBasename": {
						let c = d("workspaceFolderBasename")
						return c ? Dp(Ze(this.fsPath(c))) : void 0
					}
					case "userHome":
						if (e.userHome) return e.userHome
						throw new zn(
							"userHome",
							p(
								"canNotResolveUserHome",
								"Variable {0} can not be resolved. UserHome path is not defined",
								t.id,
							),
						)
					case "lineNumber": {
						let c = this._context.getLineNumber()
						if (c) return c
						throw new zn(
							"lineNumber",
							p(
								"canNotResolveLineNumber",
								"Variable {0} can not be resolved. Make sure to have a line selected in the active editor.",
								t.id,
							),
						)
					}
					case "columnNumber": {
						let c = this._context.getColumnNumber()
						if (c) return c
						throw new Error(
							p(
								"canNotResolveColumnNumber",
								"Variable {0} can not be resolved. Make sure to have a column selected in the active editor.",
								t.id,
							),
						)
					}
					case "selectedText": {
						let c = this._context.getSelectedText()
						if (c) return c
						throw new zn(
							"selectedText",
							p(
								"canNotResolveSelectedText",
								"Variable {0} can not be resolved. Make sure to have some text selected in the active editor.",
								t.id,
							),
						)
					}
					case "file":
						return a("file")
					case "fileWorkspaceFolder":
						return l("fileWorkspaceFolder")
					case "fileWorkspaceFolderBasename":
						return Ze(l("fileWorkspaceFolderBasename"))
					case "relativeFile":
						return n || s ? Oo(this.fsPath(d("relativeFile")), a("relativeFile")) : a("relativeFile")
					case "relativeFileDirname": {
						let c = Qt(a("relativeFileDirname"))
						if (n || s) {
							let u = Oo(this.fsPath(d("relativeFileDirname")), c)
							return u.length === 0 ? "." : u
						}
						return c
					}
					case "fileDirname":
						return Qt(a("fileDirname"))
					case "fileExtname":
						return ra(a("fileExtname"))
					case "fileBasename":
						return Ze(a("fileBasename"))
					case "fileBasenameNoExtension": {
						let c = Ze(a("fileBasenameNoExtension"))
						return c.slice(0, c.length - ra(c).length)
					}
					case "fileDirnameBasename":
						return Ze(Qt(a("fileDirnameBasename")))
					case "execPath": {
						let c = this._context.getExecPath()
						return c || t.id
					}
					case "execInstallFolder": {
						let c = this._context.getAppRoot()
						return c || t.id
					}
					case "pathSeparator":
					case "/":
						return at
					default:
						try {
							return this.resolveFromMap("unknown", t.id, s, r, void 0)
						} catch {
							return t.id
						}
				}
		}
	}
	resolveFromMap(e, t, n, r, i) {
		if (n && r) {
			let s = i === void 0 ? r[n] : r[i + ":" + n]
			if (typeof s == "string") return s
			throw new zn(
				e,
				p("noValueForCommand", "Variable {0} can not be resolved because the command has no value.", t),
			)
		}
		return t
	}
}
var Yo = O("IExtHostVariableResolverProvider"),
	vR = class extends lC {
		constructor(e, t, n, r, i, s, a) {
			function l() {
				if (n) {
					let d = n.activeEditor()
					if (d) return d.document.uri
					let c = r.tabGroups.all.find((u) => u.isActive)?.activeTab
					if (c !== void 0) {
						if (c.input instanceof Ts || c.input instanceof ja) return c.input.modified
						if (c.input instanceof za || c.input instanceof Ka || c.input instanceof qa) return c.input.uri
					}
				}
			}
			super(
				{
					getFolderUri: (d) => {
						let c = s.folders.filter((u) => u.name === d)
						if (c && c.length > 0) return c[0].uri
					},
					getWorkspaceFolderCount: () => s.folders.length,
					getConfigurationValue: (d, c) => i.getConfiguration(void 0, d).get(c),
					getAppRoot: () => Ao(),
					getExecPath: () => Er.VSCODE_EXEC_PATH,
					getFilePath: () => {
						let d = l()
						if (d) return jn(d.fsPath)
					},
					getWorkspaceFolderPathForFile: () => {
						if (t) {
							let d = l()
							if (d) {
								let c = t.getWorkspaceFolder(d)
								if (c) return jn(c.uri.fsPath)
							}
						}
					},
					getSelectedText: () => {
						if (n) {
							let d = n.activeEditor()
							if (d && !d.selection.isEmpty) return d.document.getText(d.selection)
						}
					},
					getLineNumber: () => {
						if (n) {
							let d = n.activeEditor()
							if (d) return String(d.selection.end.line + 1)
						}
					},
					getColumnNumber: () => {
						if (n) {
							let d = n.activeEditor()
							if (d) return String(d.selection.end.character + 1)
						}
					},
					getExtension: (d) => e.getExtension(d),
				},
				void 0,
				a ? Promise.resolve(a) : void 0,
				Promise.resolve(Er),
			)
		}
	},
	cl = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.extensionService = t
			this.workspaceService = n
			this.editorService = r
			this.configurationService = i
			this.editorTabs = s
			this._resolver = new Rt(async () => {
				let t = await this.configurationService.getConfigProvider(),
					r = { folders: (await this.workspaceService.getWorkspaceFolders2()) || [] }
				return (
					this._register(
						this.workspaceService.onDidChangeWorkspace(async (i) => {
							r.folders = (await this.workspaceService.getWorkspaceFolders2()) || []
						}),
					),
					new vR(
						this.extensionService,
						this.workspaceService,
						this.editorService,
						this.editorTabs,
						t,
						r,
						this.homeDir(),
					)
				)
			})
		}
		getResolver() {
			return this._resolver.value
		}
		homeDir() {}
	}
cl = R([S(0, ur), S(1, Sn), S(2, eo), S(3, pn), S(4, Xo)], cl)
var Qp = O("IExtHostDebugService"),
	Nd = class extends $ {
		constructor(t, n, r, i, s, a, l, d) {
			super()
			this._workspaceService = n
			this._extensionService = r
			this._configurationService = i
			this._editorTabs = s
			this._variableResolver = a
			this._commands = l
			this._testing = d
			this._debugSessions = new Map()
			this._debugVisualizationTreeItemIdsCounter = 0
			this._debugVisualizationProviders = new Map()
			this._debugVisualizationTrees = new Map()
			this._debugVisualizationTreeItemIds = new WeakMap()
			this._debugVisualizationElements = new Map()
			this._visualizers = new Map()
			this._visualizerIdCounter = 0
			;(this._configProviderHandleCounter = 0),
				(this._configProviders = []),
				(this._adapterFactoryHandleCounter = 0),
				(this._adapterFactories = []),
				(this._trackerFactoryHandleCounter = 0),
				(this._trackerFactories = []),
				(this._debugAdapters = new Map()),
				(this._debugAdaptersTrackers = new Map()),
				(this._onDidStartDebugSession = this._register(new E())),
				(this._onDidTerminateDebugSession = this._register(new E())),
				(this._onDidChangeActiveDebugSession = this._register(new E())),
				(this._onDidReceiveDebugSessionCustomEvent = this._register(new E())),
				(this._debugServiceProxy = t.getProxy(N.MainThreadDebugService)),
				(this._onDidChangeBreakpoints = this._register(new E())),
				(this._onDidChangeActiveStackItem = this._register(new E())),
				(this._activeDebugConsole = new yR(this._debugServiceProxy)),
				(this._breakpoints = new Map()),
				this._extensionService.getExtensionRegistry().then((c) => {
					this._register(
						c.onDidChange((u) => {
							this.registerAllDebugTypes(c)
						}),
					),
						this.registerAllDebugTypes(c)
				}),
				(this._telemetryProxy = t.getProxy(N.MainThreadTelemetry))
		}
		get onDidStartDebugSession() {
			return this._onDidStartDebugSession.event
		}
		get onDidTerminateDebugSession() {
			return this._onDidTerminateDebugSession.event
		}
		get onDidChangeActiveDebugSession() {
			return this._onDidChangeActiveDebugSession.event
		}
		get activeDebugSession() {
			return this._activeDebugSession?.api
		}
		get onDidReceiveDebugSessionCustomEvent() {
			return this._onDidReceiveDebugSessionCustomEvent.event
		}
		get activeDebugConsole() {
			return this._activeDebugConsole.value
		}
		async $getVisualizerTreeItem(t, n) {
			let r = this.hydrateVisualizationContext(n)
			if (!r) return
			let i = await this._debugVisualizationTrees.get(t)?.getTreeItem?.(r)
			return i ? this.convertVisualizerTreeItem(t, i) : void 0
		}
		registerDebugVisualizationTree(t, n, r) {
			let i = we.toKey(t.identifier),
				s = this.extensionVisKey(i, n)
			if (this._debugVisualizationProviders.has(s))
				throw new Error(`A debug visualization provider with id '${n}' is already registered`)
			return (
				this._debugVisualizationTrees.set(s, r),
				this._debugServiceProxy.$registerDebugVisualizerTree(s, !!r.editItem),
				q(() => {
					this._debugServiceProxy.$unregisterDebugVisualizerTree(s), this._debugVisualizationTrees.delete(n)
				})
			)
		}
		async $getVisualizerTreeItemChildren(t, n) {
			let r = this._debugVisualizationElements.get(n)?.item
			return r
				? (await this._debugVisualizationTrees.get(t)?.getChildren?.(r))?.map((s) =>
						this.convertVisualizerTreeItem(t, s),
					) || []
				: []
		}
		async $editVisualizerTreeItem(t, n) {
			let r = this._debugVisualizationElements.get(t)
			if (!r) return
			let i = await this._debugVisualizationTrees.get(r.provider)?.editItem?.(r.item, n)
			return this.convertVisualizerTreeItem(r.provider, i || r.item)
		}
		$disposeVisualizedTree(t) {
			let n = this._debugVisualizationElements.get(t)
			if (!n) return
			let r = [n.children]
			for (let i of r)
				if (i)
					for (let s of i)
						r.push(this._debugVisualizationElements.get(s)?.children),
							this._debugVisualizationElements.delete(s)
		}
		convertVisualizerTreeItem(t, n) {
			let r = this._debugVisualizationTreeItemIds.get(n)
			return (
				r ||
					((r = this._debugVisualizationTreeItemIdsCounter++),
					this._debugVisualizationTreeItemIds.set(n, r),
					this._debugVisualizationElements.set(r, { provider: t, item: n })),
				nk.from(n, r)
			)
		}
		asDebugSourceUri(t, n) {
			let r = t
			if (typeof r.sourceReference == "number" && r.sourceReference > 0) {
				let i = `debug:${encodeURIComponent(r.path || "")}`,
					s = "?"
				return (
					n && ((i += `${s}session=${encodeURIComponent(n.id)}`), (s = "&")),
					(i += `${s}ref=${r.sourceReference}`),
					y.parse(i)
				)
			} else {
				if (r.path) return y.file(r.path)
				throw new Error(
					"cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.",
				)
			}
		}
		registerAllDebugTypes(t) {
			let n = []
			for (let r of t.getAllExtensionDescriptions())
				if (r.contributes) {
					let i = r.contributes.debuggers
					if (i && i.length > 0) for (let s of i) P2(s) && n.push(s.type)
				}
			this._debugServiceProxy.$registerDebugTypes(n)
		}
		get activeStackItem() {
			return this._activeStackItem
		}
		get onDidChangeActiveStackItem() {
			return this._onDidChangeActiveStackItem.event
		}
		get onDidChangeBreakpoints() {
			return this._onDidChangeBreakpoints.event
		}
		get breakpoints() {
			let t = []
			return this._breakpoints.forEach((n) => t.push(n)), t
		}
		async $resolveDebugVisualizer(t, n) {
			let r = this._visualizers.get(t)
			if (!r) throw new Error(`No debug visualizer found with id '${t}'`)
			let { v: i, provider: s, extensionId: a } = r
			if (
				(i.visualization || ((i = (await s.resolveDebugVisualization?.(i, n)) || i), (r.v = i)),
				!i.visualization)
			)
				throw new Error(`No visualization returned from resolveDebugVisualization in '${s}'`)
			return this.serializeVisualization(a, i.visualization)
		}
		async $executeDebugVisualizerCommand(t) {
			let n = this._visualizers.get(t)
			if (!n) throw new Error(`No debug visualizer found with id '${t}'`)
			let r = n.v.visualization
			r && "command" in r && this._commands.executeCommand(r.command, ...(r.arguments || []))
		}
		hydrateVisualizationContext(t) {
			let n = this._debugSessions.get(t.sessionId)
			return (
				n && {
					session: n.api,
					variable: t.variable,
					containerId: t.containerId,
					frameId: t.frameId,
					threadId: t.threadId,
				}
			)
		}
		async $provideDebugVisualizers(t, n, r, i) {
			let s = this.hydrateVisualizationContext(r),
				a = this.extensionVisKey(t, n),
				l = this._debugVisualizationProviders.get(a)
			if (!s || !l) return []
			let d = await l.provideDebugVisualization(s, i)
			return d
				? d.map((c) => {
						let u = ++this._visualizerIdCounter
						this._visualizers.set(u, { v: c, provider: l, extensionId: t })
						let m = c.iconPath ? this.getIconPathOrClass(c.iconPath) : void 0
						return {
							id: u,
							name: c.name,
							iconClass: m?.iconClass,
							iconPath: m?.iconPath,
							visualization: this.serializeVisualization(t, c.visualization),
						}
					})
				: []
		}
		$disposeDebugVisualizers(t) {
			for (let n of t) this._visualizers.delete(n)
		}
		registerDebugVisualizationProvider(t, n, r) {
			if (!t.contributes?.debugVisualizers?.some((a) => a.id === n))
				throw new Error(
					`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${n})`,
				)
			let i = we.toKey(t.identifier),
				s = this.extensionVisKey(i, n)
			if (this._debugVisualizationProviders.has(s))
				throw new Error(`A debug visualization provider with id '${n}' is already registered`)
			return (
				this._debugVisualizationProviders.set(s, r),
				this._debugServiceProxy.$registerDebugVisualizer(i, n),
				q(() => {
					this._debugServiceProxy.$unregisterDebugVisualizer(i, n),
						this._debugVisualizationProviders.delete(n)
				})
			)
		}
		addBreakpoints(t) {
			let n = t.filter((s) => {
				let a = s.id
				return this._breakpoints.has(a) ? !1 : (this._breakpoints.set(a, s), !0)
			})
			this.fireBreakpointChanges(n, [], [])
			let r = [],
				i = new Map()
			for (let s of n)
				if (s instanceof qo) {
					let a = i.get(s.location.uri.toString())
					a ||
						((a = { type: "sourceMulti", uri: s.location.uri, lines: [] }),
						i.set(s.location.uri.toString(), a),
						r.push(a)),
						a.lines.push({
							id: s.id,
							enabled: s.enabled,
							condition: s.condition,
							hitCondition: s.hitCondition,
							logMessage: s.logMessage,
							line: s.location.range.start.line,
							character: s.location.range.start.character,
							mode: s.mode,
						})
				} else
					s instanceof Ko &&
						r.push({
							type: "function",
							id: s.id,
							enabled: s.enabled,
							hitCondition: s.hitCondition,
							logMessage: s.logMessage,
							condition: s.condition,
							functionName: s.functionName,
							mode: s.mode,
						})
			return this._debugServiceProxy.$registerBreakpoints(r)
		}
		removeBreakpoints(t) {
			let n = t.filter((a) => this._breakpoints.delete(a.id))
			this.fireBreakpointChanges([], n, [])
			let r = n.filter((a) => a instanceof qo).map((a) => a.id),
				i = n.filter((a) => a instanceof Ko).map((a) => a.id),
				s = n.filter((a) => a instanceof cd).map((a) => a.id)
			return this._debugServiceProxy.$unregisterBreakpoints(r, i, s)
		}
		startDebugging(t, n, r) {
			let i = r.testRun && this._testing.getMetadataForRun(r.testRun)
			return this._debugServiceProxy.$startDebugging(t ? t.uri : void 0, n, {
				parentSessionID: r.parentSession ? r.parentSession.id : void 0,
				lifecycleManagedByParent: r.lifecycleManagedByParent,
				repl: r.consoleMode === 1 ? "mergeWithParent" : "separate",
				noDebug: r.noDebug,
				compact: r.compact,
				suppressSaveBeforeStart: r.suppressSaveBeforeStart,
				testRun: i && { runId: i.runId, taskId: i.taskId },
				suppressDebugStatusbar: r.suppressDebugStatusbar ?? r.debugUI?.simple,
				suppressDebugToolbar: r.suppressDebugToolbar ?? r.debugUI?.simple,
				suppressDebugView: r.suppressDebugView ?? r.debugUI?.simple,
			})
		}
		stopDebugging(t) {
			return this._debugServiceProxy.$stopDebugging(t ? t.id : void 0)
		}
		registerDebugConfigurationProvider(t, n, r) {
			if (!n) return new ye(() => {})
			let i = this._configProviderHandleCounter++
			return (
				this._configProviders.push({ type: t, handle: i, provider: n }),
				this._debugServiceProxy.$registerDebugConfigurationProvider(
					t,
					r,
					!!n.provideDebugConfigurations,
					!!n.resolveDebugConfiguration,
					!!n.resolveDebugConfigurationWithSubstitutedVariables,
					i,
				),
				new ye(() => {
					;(this._configProviders = this._configProviders.filter((s) => s.provider !== n)),
						this._debugServiceProxy.$unregisterDebugConfigurationProvider(i)
				})
			)
		}
		registerDebugAdapterDescriptorFactory(t, n, r) {
			if (!r) return new ye(() => {})
			if (!this.definesDebugType(t, n))
				throw new Error(
					`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${n}' debugger.`,
				)
			if (this.getAdapterDescriptorFactoryByType(n))
				throw new Error("a DebugAdapterDescriptorFactory can only be registered once per a type.")
			let i = this._adapterFactoryHandleCounter++
			return (
				this._adapterFactories.push({ type: n, handle: i, factory: r }),
				this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(n, i),
				new ye(() => {
					;(this._adapterFactories = this._adapterFactories.filter((s) => s.factory !== r)),
						this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(i)
				})
			)
		}
		registerDebugAdapterTrackerFactory(t, n) {
			if (!n) return new ye(() => {})
			let r = this._trackerFactoryHandleCounter++
			return (
				this._trackerFactories.push({ type: t, handle: r, factory: n }),
				new ye(() => {
					this._trackerFactories = this._trackerFactories.filter((i) => i.factory !== n)
				})
			)
		}
		async $runInTerminal(t, n) {
			return Promise.resolve(void 0)
		}
		async $substituteVariables(t, n) {
			let r,
				i = await this.getFolder(t)
			return (
				i &&
					(r = {
						uri: i.uri,
						name: i.name,
						index: i.index,
						toResource: () => {
							throw new Error("Not implemented")
						},
					}),
				(await this._variableResolver.getResolver()).resolveAsync(r, n)
			)
		}
		createDebugAdapter(t, n) {
			if (t instanceof ys) return new xR(t.implementation)
		}
		createSignService() {}
		async $startDASession(t, n) {
			let r = this,
				i = await this.getSession(n)
			return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(i.type), i).then((s) => {
				if (!s)
					throw new Error(
						`Couldn't find a debug adapter descriptor for debug type '${i.type}' (extension might have failed to activate)`,
					)
				let a = this.createDebugAdapter(s, i)
				if (!a) throw new Error(`Couldn't create a debug adapter for type '${i.type}'.`)
				let l = a
				return (
					this._debugAdapters.set(t, l),
					this.getDebugAdapterTrackers(i).then(
						(d) => (
							d && this._debugAdaptersTrackers.set(t, d),
							l.onMessage(async (c) => {
								if (c.type === "request" && c.command === "handshake") {
									let u = c,
										m = {
											type: "response",
											seq: 0,
											command: u.command,
											request_seq: u.seq,
											success: !0,
										}
									this._signService || (this._signService = this.createSignService())
									try {
										if (this._signService) {
											let f = await this._signService.sign(u.arguments.value)
											;(m.body = { signature: f }), l.sendResponse(m)
										} else throw new Error("no signer")
									} catch (f) {
										;(m.success = !1), (m.message = f.message), l.sendResponse(m)
									}
								} else {
									d && d.onDidSendMessage && d.onDidSendMessage(c)
									try {
										c = R2(c, !0)
									} catch (u) {
										let m = c.type + "_" + (c.command ?? c.event ?? "")
										throw (
											(this._telemetryProxy.$publicLog2("debugProtocolMessageError", {
												type: m,
												from: i.type,
											}),
											u)
										)
									}
									r._debugServiceProxy.$acceptDAMessage(t, c)
								}
							}),
							l.onError((c) => {
								d && d.onError && d.onError(c),
									this._debugServiceProxy.$acceptDAError(t, c.name, c.message, c.stack)
							}),
							l.onExit((c) => {
								d && d.onExit && d.onExit(c ?? void 0, void 0),
									this._debugServiceProxy.$acceptDAExit(t, c ?? void 0, void 0)
							}),
							d && d.onWillStartSession && d.onWillStartSession(),
							l.startSession()
						),
					)
				)
			})
		}
		$sendDAMessage(t, n) {
			n = k2(n, !1)
			let r = this._debugAdaptersTrackers.get(t)
			r && r.onWillReceiveMessage && r.onWillReceiveMessage(n), this._debugAdapters.get(t)?.sendMessage(n)
		}
		$stopDASession(t) {
			let n = this._debugAdaptersTrackers.get(t)
			this._debugAdaptersTrackers.delete(t), n && n.onWillStopSession && n.onWillStopSession()
			let r = this._debugAdapters.get(t)
			return this._debugAdapters.delete(t), r ? r.stopSession() : Promise.resolve(void 0)
		}
		$acceptBreakpointsDelta(t) {
			let n = [],
				r = [],
				i = []
			if (t.added)
				for (let s of t.added) {
					let a = s.id
					if (a && !this._breakpoints.has(a)) {
						let l
						if (s.type === "function")
							l = new Ko(s.functionName, s.enabled, s.condition, s.hitCondition, s.logMessage, s.mode)
						else if (s.type === "data")
							l = new cd(
								s.label,
								s.dataId,
								s.canPersist,
								s.enabled,
								s.hitCondition,
								s.condition,
								s.logMessage,
								s.mode,
							)
						else {
							let d = y.revive(s.uri)
							l = new qo(
								new rn(d, new Pe(s.line, s.character)),
								s.enabled,
								s.condition,
								s.hitCondition,
								s.logMessage,
								s.mode,
							)
						}
						yF(l, a), this._breakpoints.set(a, l), n.push(l)
					}
				}
			if (t.removed)
				for (let s of t.removed) {
					let a = this._breakpoints.get(s)
					a && (this._breakpoints.delete(s), r.push(a))
				}
			if (t.changed) {
				for (let s of t.changed)
					if (s.id) {
						let a = this._breakpoints.get(s.id)
						if (a) {
							if (a instanceof Ko && s.type === "function") {
								let l = a
								;(l.enabled = s.enabled),
									(l.condition = s.condition),
									(l.hitCondition = s.hitCondition),
									(l.logMessage = s.logMessage),
									(l.functionName = s.functionName)
							} else if (a instanceof qo && s.type === "source") {
								let l = a
								;(l.enabled = s.enabled),
									(l.condition = s.condition),
									(l.hitCondition = s.hitCondition),
									(l.logMessage = s.logMessage),
									(l.location = new rn(y.revive(s.uri), new Pe(s.line, s.character)))
							}
							i.push(a)
						}
					}
			}
			this.fireBreakpointChanges(n, r, i)
		}
		async $acceptStackFrameFocus(t) {
			let n
			if (t) {
				let r = await this.getSession(t.sessionId)
				t.kind === "thread" ? (n = new Cu(r.api, t.threadId)) : (n = new xu(r.api, t.threadId, t.frameId))
			}
			;(this._activeStackItem = n), this._onDidChangeActiveStackItem.fire(this._activeStackItem)
		}
		$provideDebugConfigurations(t, n, r) {
			return Jt(async () => {
				let i = this.getConfigProviderByHandle(t)
				if (!i) throw new Error("no DebugConfigurationProvider found")
				if (!i.provideDebugConfigurations)
					throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations")
				let s = await this.getFolder(n)
				return i.provideDebugConfigurations(s, r)
			}).then((i) => {
				if (!i) throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations")
				return i
			})
		}
		$resolveDebugConfiguration(t, n, r, i) {
			return Jt(async () => {
				let s = this.getConfigProviderByHandle(t)
				if (!s) throw new Error("no DebugConfigurationProvider found")
				if (!s.resolveDebugConfiguration)
					throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration")
				let a = await this.getFolder(n)
				return s.resolveDebugConfiguration(a, r, i)
			})
		}
		$resolveDebugConfigurationWithSubstitutedVariables(t, n, r, i) {
			return Jt(async () => {
				let s = this.getConfigProviderByHandle(t)
				if (!s) throw new Error("no DebugConfigurationProvider found")
				if (!s.resolveDebugConfigurationWithSubstitutedVariables)
					throw new Error(
						"DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables",
					)
				let a = await this.getFolder(n)
				return s.resolveDebugConfigurationWithSubstitutedVariables(a, r, i)
			})
		}
		async $provideDebugAdapter(t, n) {
			let r = this.getAdapterDescriptorFactoryByHandle(t)
			if (!r) return Promise.reject(new Error("no adapter descriptor factory found for handle"))
			let i = await this.getSession(n)
			return this.getAdapterDescriptor(r, i).then((s) => {
				if (!s) throw new Error(`Couldn't find a debug adapter descriptor for debug type '${i.type}'`)
				return this.convertToDto(s)
			})
		}
		async $acceptDebugSessionStarted(t) {
			let n = await this.getSession(t)
			this._onDidStartDebugSession.fire(n.api)
		}
		async $acceptDebugSessionTerminated(t) {
			let n = await this.getSession(t)
			n && (this._onDidTerminateDebugSession.fire(n.api), this._debugSessions.delete(n.id))
		}
		async $acceptDebugSessionActiveChanged(t) {
			;(this._activeDebugSession = t ? await this.getSession(t) : void 0),
				this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api)
		}
		async $acceptDebugSessionNameChanged(t, n) {
			;(await this.getSession(t))?._acceptNameChanged(n)
		}
		async $acceptDebugSessionCustomEvent(t, n) {
			let i = { session: (await this.getSession(t)).api, event: n.event, body: n.body }
			this._onDidReceiveDebugSessionCustomEvent.fire(i)
		}
		convertToDto(t) {
			if (t instanceof jo) return this.convertExecutableToDto(t)
			if (t instanceof Go) return this.convertServerToDto(t)
			if (t instanceof Ti) return this.convertPipeServerToDto(t)
			if (t instanceof ys) return this.convertImplementationToDto(t)
			throw new Error("convertToDto unexpected type")
		}
		convertExecutableToDto(t) {
			return { type: "executable", command: t.command, args: t.args, options: t.options }
		}
		convertServerToDto(t) {
			return { type: "server", port: t.port, host: t.host }
		}
		convertPipeServerToDto(t) {
			return { type: "pipeServer", path: t.path }
		}
		convertImplementationToDto(t) {
			return { type: "implementation" }
		}
		getAdapterDescriptorFactoryByType(t) {
			let n = this._adapterFactories.filter((r) => r.type === t)
			if (n.length > 0) return n[0].factory
		}
		getAdapterDescriptorFactoryByHandle(t) {
			let n = this._adapterFactories.filter((r) => r.handle === t)
			if (n.length > 0) return n[0].factory
		}
		getConfigProviderByHandle(t) {
			let n = this._configProviders.filter((r) => r.handle === t)
			if (n.length > 0) return n[0].provider
		}
		definesDebugType(t, n) {
			if (t.contributes) {
				let r = t.contributes.debuggers
				if (r && r.length > 0) {
					for (let i of r) if (i.label && i.type && i.type === n) return !0
				}
			}
			return !1
		}
		getDebugAdapterTrackers(t) {
			let r = t.configuration.type,
				i = this._trackerFactories
					.filter((s) => s.type === r || s.type === "*")
					.map((s) =>
						Jt(() => s.factory.createDebugAdapterTracker(t.api)).then(
							(a) => a,
							(a) => null,
						),
					)
			return Promise.race([
				Promise.all(i).then((s) => {
					let a = Ye(s)
					if (a.length > 0) return new IR(a)
				}),
				new Promise((s) => setTimeout(() => s(void 0), 1e3)),
			]).catch((s) => {})
		}
		async getAdapterDescriptor(t, n) {
			let r = n.configuration.debugServer
			if (typeof r == "number") return Promise.resolve(new Go(r))
			if (t) {
				let s = await this._extensionService.getExtensionRegistry()
				return Jt(() => t.createDebugAdapterDescriptor(n.api, this.daExecutableFromPackage(n, s))).then((a) => {
					if (a) return a
				})
			}
			let i = await this._extensionService.getExtensionRegistry()
			return Promise.resolve(this.daExecutableFromPackage(n, i))
		}
		daExecutableFromPackage(t, n) {}
		fireBreakpointChanges(t, n, r) {
			;(t.length > 0 || n.length > 0 || r.length > 0) &&
				this._onDidChangeBreakpoints.fire(Object.freeze({ added: t, removed: n, changed: r }))
		}
		async getSession(t) {
			if (t)
				if (typeof t == "string") {
					let n = this._debugSessions.get(t)
					if (n) return n
				} else {
					let n = this._debugSessions.get(t.id)
					if (!n) {
						let r = await this.getFolder(t.folderUri),
							i = t.parent ? this._debugSessions.get(t.parent) : void 0
						;(n = new bR(this._debugServiceProxy, t.id, t.type, t.name, r, t.configuration, i?.api)),
							this._debugSessions.set(n.id, n),
							this._debugServiceProxy.$sessionCached(n.id)
					}
					return n
				}
			throw new Error("cannot find session")
		}
		getFolder(t) {
			if (t) {
				let n = y.revive(t)
				return this._workspaceService.resolveWorkspaceFolder(n)
			}
			return Promise.resolve(void 0)
		}
		extensionVisKey(t, n) {
			return `${t}\0${n}`
		}
		serializeVisualization(t, n) {
			if (n) {
				if ("title" in n && "command" in n) return { type: 0 }
				if ("treeId" in n) return { type: 1, id: `${t}\0${n.treeId}` }
				throw new Error("Unsupported debug visualization type")
			}
		}
		getIconPathOrClass(t) {
			let n = this.getIconUris(t),
				r,
				i
			return "id" in n ? (i = Yt.asClassName(n)) : (r = n), { iconPath: r, iconClass: i }
		}
		getIconUris(t) {
			if (t instanceof Vt) return { id: t.id }
			let n = typeof t == "object" && "dark" in t ? t.dark : t,
				r = typeof t == "object" && "light" in t ? t.light : t
			return { dark: typeof n == "string" ? y.file(n) : n, light: typeof r == "string" ? y.file(r) : r }
		}
	}
Nd = R([S(0, ie), S(1, Sn), S(2, ur), S(3, pn), S(4, Xo), S(5, Yo), S(6, Tn), S(7, zs)], Nd)
var bR = class {
		constructor(e, t, n, r, i, s, a) {
			this._debugServiceProxy = e
			this._id = t
			this._type = n
			this._name = r
			this._workspaceFolder = i
			this._configuration = s
			this._parentSession = a
		}
		get api() {
			let e = this
			return (this.apiSession ??= Object.freeze({
				id: e._id,
				type: e._type,
				get name() {
					return e._name
				},
				set name(t) {
					;(e._name = t), e._debugServiceProxy.$setDebugSessionName(e._id, t)
				},
				parentSession: e._parentSession,
				workspaceFolder: e._workspaceFolder,
				configuration: e._configuration,
				customRequest(t, n) {
					return e._debugServiceProxy.$customDebugAdapterRequest(e._id, t, n)
				},
				getDebugProtocolBreakpoint(t) {
					return e._debugServiceProxy.$getDebugProtocolBreakpoint(e._id, t.id)
				},
			}))
		}
		get id() {
			return this._id
		}
		get type() {
			return this._type
		}
		_acceptNameChanged(e) {
			this._name = e
		}
		get configuration() {
			return this._configuration
		}
	},
	yR = class {
		constructor(e) {
			this.value = Object.freeze({
				append(t) {
					e.$appendDebugConsole(t)
				},
				appendLine(t) {
					this.append(
						t +
							`
`,
					)
				},
			})
		}
	},
	IR = class {
		constructor(e) {
			this.trackers = e
		}
		onWillStartSession() {
			this.trackers.forEach((e) => (e.onWillStartSession ? e.onWillStartSession() : void 0))
		}
		onWillReceiveMessage(e) {
			this.trackers.forEach((t) => (t.onWillReceiveMessage ? t.onWillReceiveMessage(e) : void 0))
		}
		onDidSendMessage(e) {
			this.trackers.forEach((t) => (t.onDidSendMessage ? t.onDidSendMessage(e) : void 0))
		}
		onWillStopSession() {
			this.trackers.forEach((e) => (e.onWillStopSession ? e.onWillStopSession() : void 0))
		}
		onError(e) {
			this.trackers.forEach((t) => (t.onError ? t.onError(e) : void 0))
		}
		onExit(e, t) {
			this.trackers.forEach((n) => (n.onExit ? n.onExit(e, t) : void 0))
		}
	},
	xR = class extends qp {
		constructor(t) {
			super()
			this.implementation = t
			t.onDidSendMessage((n) => {
				this.acceptMessage(n)
			})
		}
		startSession() {
			return Promise.resolve(void 0)
		}
		sendMessage(t) {
			this.implementation.handleMessage(t)
		}
		stopSession() {
			return this.implementation.dispose(), Promise.resolve(void 0)
		}
	},
	Gp = class extends Nd {
		constructor(e, t, n, r, i, s, a, l) {
			super(e, t, n, r, i, s, a, l)
		}
	}
Gp = R([S(0, ie), S(1, Sn), S(2, ur), S(3, pn), S(4, Xo), S(5, Yo), S(6, Tn), S(7, zs)], Gp)
function j8(o) {
	return "uri" in o && "ranges" in o && "preview" in o
}
function G8(o) {
	return o.folderOptions.map((e) => ({
		folder: e.folder,
		excludes: e.excludes.map((t) => (typeof t == "string" ? t : t.pattern)),
		includes: e.includes,
		useGlobalIgnoreFiles: e.useIgnoreFiles.global,
		useIgnoreFiles: e.useIgnoreFiles.local,
		useParentIgnoreFiles: e.useIgnoreFiles.parent,
		followSymlinks: e.followSymlinks,
		maxResults: o.maxResults,
		session: o.session,
	}))
}
var Jp = class {
	constructor(e) {
		this.provider = e
	}
	provideFileSearchResults(e, t, n) {
		return (async () => {
			let i = G8(t)
			return Promise.all(i.map((s) => this.provider.provideFileSearchResults({ pattern: e }, s, n)))
		})().then((i) => Ye(i).flat())
	}
}
function Q8(o) {
	return o.folderOptions.map((e) => ({
		folder: e.folder,
		excludes: e.excludes.map((t) => (typeof t == "string" ? t : t.pattern)),
		includes: e.includes,
		useGlobalIgnoreFiles: e.useIgnoreFiles.global,
		useIgnoreFiles: e.useIgnoreFiles.local,
		useParentIgnoreFiles: e.useIgnoreFiles.parent,
		followSymlinks: e.followSymlinks,
		maxResults: o.maxResults,
		previewOptions: CR(o.previewOptions),
		maxFileSize: o.maxFileSize,
		encoding: e.encoding,
		afterContext: o.surroundingContext,
		beforeContext: o.surroundingContext,
	}))
}
function CR(o) {
	return { matchLines: o?.matchLines ?? Fg.matchLines, charsPerLine: o?.charsPerLine ?? Fg.charsPerLine }
}
function J8(o) {
	if (j8(o)) {
		let e = an(o.ranges).map((t, n) => {
			let i = an(o.preview.matches)[n]
			return { sourceRange: t, previewRange: i }
		})
		return new cr(o.uri, e, o.preview.text)
	} else return new Ai(o.uri, o.text, o.lineNumber)
}
var dC = class {
	constructor(e) {
		this.provider = e
	}
	provideTextSearchResults(e, t, n, r) {
		let i = (l) => {
			X8(l) && n.report(J8(l))
		}
		return (async () =>
			Ye(
				await Promise.all(
					Q8(t).map((l) => this.provider.provideTextSearchResults(e, l, { report: (d) => i(d) }, r)),
				),
			).reduce((l, d) => ({ limitHit: l.limitHit || d.limitHit }), { limitHit: !1 }))().then((l) => ({
			limitHit: l.limitHit,
			message: Ye(an(l.message)),
		}))
	}
}
function X8(o) {
	if (Y8(o)) {
		if (Array.isArray(o.ranges)) {
			if (!Array.isArray(o.preview.matches))
				return (
					console.warn(
						"INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.",
					),
					!1
				)
			if (o.preview.matches.length !== o.ranges.length)
				return (
					console.warn(
						"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
					),
					!1
				)
		} else if (Array.isArray(o.preview.matches))
			return (
				console.warn(
					"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
				),
				!1
			)
	}
	return !0
}
function Y8(o) {
	return !!o.preview
}
var Xp = class extends hr {
	constructor(e, t, n = () => !1) {
		let r = new Ff(n, () => !1)
		super(r)
		let i = new ft()
		e.forEach((s, a) => {
			let l = s.folder.with({ query: "", fragment: "" })
			i.has(l) ? i.get(l).push({ fq: s, i: a }) : i.set(l, [{ fq: s, i: a }])
		}),
			i.forEach((s, a) => {
				let l = new Map()
				for (let d of s) {
					let c = t(d.fq, d.i)
					l.set(this.encodeKey(d.fq.folder), c)
				}
				super.set(a, l)
			})
	}
	findQueryFragmentAwareSubstr(e) {
		let t = super.findSubstr(e.with({ query: "", fragment: "" }))
		if (!t) return
		let n = this.encodeKey(e)
		return t.get(n)
	}
	forEachFolderQueryInfo(e) {
		return this.forEach((t) => t.forEach((n) => e(n)))
	}
	encodeKey(e) {
		let t = ""
		return e.query && (t += e.query), e.fragment && (t += "#" + e.fragment), t
	}
}
var SR = class {
		constructor(e, t, n) {
			this.config = e
			this.provider = t
			this.sessionLifecycle = n
			this.isLimitHit = !1
			this.resultCount = 0
			this.isCanceled = !1
			;(this.filePattern = e.filePattern),
				(this.includePattern = e.includePattern && Xn(e.includePattern)),
				(this.maxResults = e.maxResults || void 0),
				(this.exists = e.exists),
				(this.activeCancellationTokens = new Set()),
				(this.globalExcludePattern = e.excludePattern && Xn(e.excludePattern))
		}
		cancel() {
			;(this.isCanceled = !0),
				this.activeCancellationTokens.forEach((e) => e.cancel()),
				(this.activeCancellationTokens = new Set())
		}
		search(e) {
			let t = this.config.folderQueries || []
			return new Promise((n, r) => {
				let i = (s) => {
					this.resultCount++, e(s)
				}
				if (this.isCanceled) return n({ limitHit: this.isLimitHit })
				this.config.extraFileResources &&
					this.config.extraFileResources.forEach((s) => {
						let a = s.toString(),
							l = Ze(a)
						;(this.globalExcludePattern && this.globalExcludePattern(a, l)) ||
							this.matchFile(i, { base: s, basename: l })
					}),
					this.doSearch(t, i).then(
						(s) => {
							n({ limitHit: this.isLimitHit, stats: s || void 0 })
						},
						(s) => {
							r(new Error(Jn(s)))
						},
					)
			})
		}
		async doSearch(e, t) {
			let n = new _e(),
				r = e.map((c) => this.getSearchOptionsForFolder(c)),
				i = this.provider instanceof Jp ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj,
				s = { folderOptions: r, maxResults: this.config.maxResults ?? Za, session: i },
				a = (c) => {
					let u = new op(this.config, c),
						m = !u.hasSiblingExcludeClauses()
					return { queryTester: u, noSiblingsClauses: m, folder: c.folder, tree: this.initDirectoryTree() }
				},
				l = new Xp(e, a),
				d
			try {
				this.activeCancellationTokens.add(n), (d = zt.create())
				let c = await this.provider.provideFileSearchResults(this.config.filePattern || "", s, n.token),
					u = d.elapsed(),
					m = zt.create()
				return (this.isCanceled && !this.isLimitHit) ||
					(c &&
						c.forEach((f) => {
							let h = l.findQueryFragmentAwareSubstr(f),
								g = Ue.relative(h.folder.path, f.path)
							if (h.noSiblingsClauses) {
								let I = Ze(f.path)
								this.matchFile(t, { base: h.folder, relativePath: g, basename: I })
								return
							}
							this.addDirectoryEntries(h.tree, h.folder, g, t)
						}),
					this.isCanceled && !this.isLimitHit)
					? null
					: (l.forEachFolderQueryInfo((f) => {
							this.matchDirectoryTree(f.tree, f.queryTester, t)
						}),
						{ providerTime: u, postProcessTime: m.elapsed() })
			} finally {
				n.dispose(), this.activeCancellationTokens.delete(n)
			}
		}
		getSearchOptionsForFolder(e) {
			let t = el(this.config.includePattern, e.includePattern),
				n = e.excludePattern?.map((i) => ({
					folder: i.folder,
					patterns: el(this.config.excludePattern, i.pattern),
				}))
			n?.length || (n = [{ folder: void 0, patterns: el(this.config.excludePattern, void 0) }])
			let r = Sx(n)
			return {
				folder: e.folder,
				excludes: r,
				includes: t,
				useIgnoreFiles: {
					local: !e.disregardIgnoreFiles,
					parent: !e.disregardParentIgnoreFiles,
					global: !e.disregardGlobalIgnoreFiles,
				},
				followSymlinks: !e.ignoreSymlinks,
			}
		}
		initDirectoryTree() {
			let e = { rootEntries: [], pathToEntries: Object.create(null) }
			return (e.pathToEntries["."] = e.rootEntries), e
		}
		addDirectoryEntries({ pathToEntries: e }, t, n, r) {
			if (n === this.filePattern) {
				let s = Ze(this.filePattern)
				this.matchFile(r, { base: t, relativePath: this.filePattern, basename: s })
			}
			function i(s) {
				let a = Ze(s),
					l = Qt(s),
					d = e[l]
				d || ((d = e[l] = []), i(l)), d.push({ base: t, relativePath: s, basename: a })
			}
			i(n)
		}
		matchDirectoryTree({ rootEntries: e, pathToEntries: t }, n, r) {
			let i = this,
				s = this.filePattern
			function a(l) {
				let d = Mg(() => l.map((c) => c.basename))
				for (let c = 0, u = l.length; c < u; c++) {
					let m = l[c],
						{ relativePath: f, basename: h } = m
					if (n.matchesExcludesSync(f, h, s !== h ? d : void 0)) continue
					let g = t[f]
					if (g) a(g)
					else {
						if (f === s) continue
						i.matchFile(r, m)
					}
					if (i.isLimitHit) break
				}
			}
			a(e)
		}
		matchFile(e, t) {
			;(!this.includePattern || (t.relativePath && this.includePattern(t.relativePath, t.basename))) &&
				((this.exists || (this.maxResults && this.resultCount >= this.maxResults)) &&
					((this.isLimitHit = !0), this.cancel()),
				this.isLimitHit || e(t))
		}
	},
	TR = class {
		constructor() {
			;(this._obj = new Object()), (this.tokenSource = new _e())
		}
		get obj() {
			if (this._obj) return this._obj
			throw new Error("Session object has been dereferenced.")
		}
		cancel() {
			this.tokenSource.cancel(), (this._obj = void 0)
		}
	},
	cC = class o {
		constructor() {
			this.sessions = new Map()
		}
		static {
			this.BATCH_SIZE = 512
		}
		fileSearch(e, t, n, r) {
			let i = this.getSessionTokenSource(e.cacheKey),
				s = new SR(e, t, i),
				a = 0,
				l = (d) => {
					;(a += d.length), n(d.map((c) => this.rawMatchToSearchItem(c)))
				}
			return this.doSearch(s, o.BATCH_SIZE, l, r).then((d) => ({
				limitHit: d.limitHit,
				stats: d.stats
					? { fromCache: !1, type: "fileSearchProvider", resultCount: a, detailStats: d.stats }
					: void 0,
				messages: [],
			}))
		}
		clearCache(e) {
			this.sessions.get(e)?.cancel(), this.sessions.delete(e)
		}
		getSessionTokenSource(e) {
			if (e) return this.sessions.has(e) || this.sessions.set(e, new TR()), this.sessions.get(e)
		}
		rawMatchToSearchItem(e) {
			return e.relativePath ? { resource: ct(e.base, e.relativePath) } : { resource: e.base }
		}
		doSearch(e, t, n, r) {
			let i = r.onCancellationRequested(() => {
					e.cancel()
				}),
				s = (l) => {
					l && (a.push(l), t > 0 && a.length >= t && (n(a), (a = [])))
				},
				a = []
			return e.search(s).then(
				(l) => (a.length && n(a), i.dispose(), l),
				(l) => (a.length && n(a), i.dispose(), Promise.reject(l)),
			)
		}
	}
var Ud = class {
	constructor(e, t, n) {
		this.queryProviderPair = e
		this.fileUtils = t
		this.processType = n
		this.collector = null
		this.isLimitHit = !1
		this.resultCount = 0
	}
	get query() {
		return this.queryProviderPair.query
	}
	search(e, t) {
		let n = this.query.folderQueries || [],
			r = new _e(t)
		return new Promise((i, s) => {
			this.collector = new ER(e)
			let a = !1,
				l = (d, c) => {
					if (!a && !this.isLimitHit) {
						let u = this.resultSize(d)
						d instanceof cr &&
							typeof this.query.maxResults == "number" &&
							this.resultCount + u > this.query.maxResults &&
							((this.isLimitHit = !0),
							(a = !0),
							r.cancel(),
							(d = this.trimResultToSize(d, this.query.maxResults - this.resultCount)))
						let m = this.resultSize(d)
						this.resultCount += m
						let f = d instanceof cr
						;(m > 0 || !f) && this.collector.add(d, c)
					}
				}
			this.doSearch(n, l, r.token).then(
				(d) => {
					r.dispose(),
						this.collector.flush(),
						i({
							limitHit: this.isLimitHit || d?.limitHit,
							messages: this.getMessagesFromResults(d),
							stats: { type: this.processType },
						})
				},
				(d) => {
					r.dispose()
					let c = Jn(d)
					s(new Error(c))
				},
			)
		})
	}
	getMessagesFromResults(e) {
		return e?.message ? (Array.isArray(e.message) ? e.message : [e.message]) : []
	}
	resultSize(e) {
		return e instanceof cr ? (Array.isArray(e.ranges) ? e.ranges.length : 1) : 0
	}
	trimResultToSize(e, t) {
		return new cr(e.uri, e.ranges.slice(0, t), e.previewText)
	}
	async doSearch(e, t, n) {
		let r = new Xp(
				e,
				(c, u) => ({ queryTester: new op(this.query, c), folder: c.folder, folderIdx: u }),
				() => !0,
			),
			i = [],
			s = {
				report: (c) => {
					if (c.uri === void 0)
						throw Error("Text search result URI is undefined. Please check provider implementation.")
					let u = r.findQueryFragmentAwareSubstr(c.uri),
						m = u.folder.scheme === W.file ? RF(() => this.fileUtils.readdir(Yi(c.uri))) : void 0,
						f = uf(u.folder, c.uri)
					if (f) {
						let h = u.queryTester.includedInQuery(f, Ze(f), m)
						io(h)
							? i.push(
									h.then((g) => {
										g && t(c, u.folderIdx)
									}),
								)
							: h && t(c, u.folderIdx)
					}
				},
			},
			l = {
				folderOptions: e.map((c) => this.getSearchOptionsForFolder(c)),
				maxFileSize: this.query.maxFileSize,
				maxResults: this.query.maxResults ?? Za,
				previewOptions: this.query.previewOptions ?? Fg,
				surroundingContext: this.query.surroundingContext ?? 0,
			}
		"usePCRE2" in this.query && (l.usePCRE2 = this.query.usePCRE2)
		let d
		return (
			this.queryProviderPair.query.type === 3
				? (d = await this.queryProviderPair.provider.provideAITextSearchResults(
						this.queryProviderPair.query.contentPattern,
						l,
						s,
						n,
					))
				: (d = await this.queryProviderPair.provider.provideTextSearchResults(
						Z8(this.queryProviderPair.query.contentPattern),
						l,
						s,
						n,
					)),
			i.length && (await Promise.all(i)),
			d
		)
	}
	getSearchOptionsForFolder(e) {
		let t = el(this.query.includePattern, e.includePattern),
			n = e.excludePattern?.map((s) => ({ folder: s.folder, patterns: el(this.query.excludePattern, s.pattern) }))
		;(!n || n.length === 0) && (n = [{ folder: void 0, patterns: el(this.query.excludePattern, void 0) }])
		let r = Sx(n)
		return {
			folder: y.from(e.folder),
			excludes: r,
			includes: t,
			useIgnoreFiles: {
				local: !e.disregardIgnoreFiles,
				parent: !e.disregardParentIgnoreFiles,
				global: !e.disregardGlobalIgnoreFiles,
			},
			followSymlinks: !e.ignoreSymlinks,
			encoding: (e.fileEncoding && this.fileUtils.toCanonicalName(e.fileEncoding)) ?? "",
		}
	}
}
function Z8(o) {
	return {
		isCaseSensitive: o.isCaseSensitive || !1,
		isRegExp: o.isRegExp || !1,
		isWordMatch: o.isWordMatch || !1,
		isMultiline: o.isMultiline || !1,
		pattern: o.pattern,
	}
}
var ER = class {
	constructor(e) {
		this._onResult = e
		this._currentFolderIdx = -1
		this._currentFileMatch = null
		this._batchedCollector = new wR(512, (t) => this.sendItems(t))
	}
	add(e, t) {
		this._currentFileMatch &&
			(this._currentFolderIdx !== t || !qr(this._currentUri, e.uri)) &&
			(this.pushToCollector(), (this._currentFileMatch = null)),
			this._currentFileMatch ||
				((this._currentFolderIdx = t), (this._currentFileMatch = { resource: e.uri, results: [] })),
			this._currentFileMatch.results.push(e9(e))
	}
	pushToCollector() {
		let e = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0
		this._batchedCollector.addItem(this._currentFileMatch, e)
	}
	flush() {
		this.pushToCollector(), this._batchedCollector.flush()
	}
	sendItems(e) {
		this._onResult(e)
	}
}
function e9(o) {
	return o instanceof cr
		? {
				previewText: o.previewText,
				rangeLocations: o.ranges.map((e) => ({
					preview: {
						startLineNumber: e.previewRange.start.line,
						startColumn: e.previewRange.start.character,
						endLineNumber: e.previewRange.end.line,
						endColumn: e.previewRange.end.character,
					},
					source: {
						startLineNumber: e.sourceRange.start.line,
						startColumn: e.sourceRange.start.character,
						endLineNumber: e.sourceRange.end.line,
						endColumn: e.sourceRange.end.character,
					},
				})),
			}
		: { text: o.text, lineNumber: o.lineNumber }
}
var wR = class o {
	constructor(e, t) {
		this.maxBatchSize = e
		this.cb = t
		this.totalNumberCompleted = 0
		this.batch = []
		this.batchSize = 0
	}
	static {
		this.TIMEOUT = 4e3
	}
	static {
		this.START_BATCH_AFTER_COUNT = 50
	}
	addItem(e, t) {
		e && this.addItemToBatch(e, t)
	}
	addItems(e, t) {
		e && this.addItemsToBatch(e, t)
	}
	addItemToBatch(e, t) {
		this.batch.push(e), (this.batchSize += t), this.onUpdate()
	}
	addItemsToBatch(e, t) {
		;(this.batch = this.batch.concat(e)), (this.batchSize += t), this.onUpdate()
	}
	onUpdate() {
		this.totalNumberCompleted < o.START_BATCH_AFTER_COUNT
			? this.flush()
			: this.batchSize >= this.maxBatchSize
				? this.flush()
				: this.timeoutHandle ||
					(this.timeoutHandle = setTimeout(() => {
						this.flush()
					}, o.TIMEOUT))
	}
	flush() {
		this.batchSize &&
			((this.totalNumberCompleted += this.batchSize),
			this.cb(this.batch),
			(this.batch = []),
			(this.batchSize = 0),
			this.timeoutHandle && (clearTimeout(this.timeoutHandle), (this.timeoutHandle = 0)))
	}
}
var Yp = O("IExtHostSearch"),
	ul = class {
		constructor(e, t, n) {
			this.extHostRpc = e
			this._uriTransformer = t
			this._logService = n
			this._proxy = this.extHostRpc.getProxy(N.MainThreadSearch)
			this._handlePool = 0
			this._textSearchProvider = new Map()
			this._textSearchUsedSchemes = new Set()
			this._aiTextSearchProvider = new Map()
			this._aiTextSearchUsedSchemes = new Set()
			this._fileSearchProvider = new Map()
			this._fileSearchUsedSchemes = new Set()
			this._fileSearchManager = new cC()
		}
		_transformScheme(e) {
			return this._uriTransformer.transformOutgoingScheme(e)
		}
		registerTextSearchProviderOld(e, t) {
			if (this._textSearchUsedSchemes.has(e))
				throw new Error(`a text search provider for the scheme '${e}' is already registered`)
			this._textSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._textSearchProvider.set(n, new dC(t)),
				this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._textSearchUsedSchemes.delete(e),
						this._textSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerTextSearchProvider(e, t) {
			if (this._textSearchUsedSchemes.has(e))
				throw new Error(`a text search provider for the scheme '${e}' is already registered`)
			this._textSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._textSearchProvider.set(n, t),
				this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._textSearchUsedSchemes.delete(e),
						this._textSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerAITextSearchProvider(e, t) {
			if (this._aiTextSearchUsedSchemes.has(e))
				throw new Error(`an AI text search provider for the scheme '${e}'is already registered`)
			this._aiTextSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._aiTextSearchProvider.set(n, t),
				this._proxy.$registerAITextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._aiTextSearchUsedSchemes.delete(e),
						this._aiTextSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerFileSearchProviderOld(e, t) {
			if (this._fileSearchUsedSchemes.has(e))
				throw new Error(`a file search provider for the scheme '${e}' is already registered`)
			this._fileSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._fileSearchProvider.set(n, new Jp(t)),
				this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._fileSearchUsedSchemes.delete(e),
						this._fileSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerFileSearchProvider(e, t) {
			if (this._fileSearchUsedSchemes.has(e))
				throw new Error(`a file search provider for the scheme '${e}' is already registered`)
			this._fileSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._fileSearchProvider.set(n, t),
				this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._fileSearchUsedSchemes.delete(e),
						this._fileSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		$provideFileSearchResults(e, t, n, r) {
			let i = eh(n),
				s = this._fileSearchProvider.get(e)
			if (s)
				return this._fileSearchManager.fileSearch(
					i,
					s,
					(a) => {
						this._proxy.$handleFileMatch(
							e,
							t,
							a.map((l) => l.resource),
						)
					},
					r,
				)
			throw new Error("unknown provider: " + e)
		}
		async doInternalFileSearchWithCustomCallback(e, t, n) {
			return { messages: [] }
		}
		$clearCache(e) {
			return this._fileSearchManager.clearCache(e), Promise.resolve(void 0)
		}
		$provideTextSearchResults(e, t, n, r) {
			let i = this._textSearchProvider.get(e)
			if (!i || !i.provideTextSearchResults) throw new Error(`Unknown Text Search Provider ${e}`)
			let s = eh(n)
			return this.createTextSearchManager(s, i).search((l) => this._proxy.$handleTextMatch(e, t, l), r)
		}
		$provideAITextSearchResults(e, t, n, r) {
			let i = this._aiTextSearchProvider.get(e)
			if (!i || !i.provideAITextSearchResults) throw new Error(`Unknown AI Text Search Provider ${e}`)
			let s = eh(n)
			return this.createAITextSearchManager(s, i).search((l) => this._proxy.$handleTextMatch(e, t, l), r)
		}
		$enableExtensionHostSearch() {}
		async $getAIName(e) {
			let t = this._aiTextSearchProvider.get(e)
			if (!(!t || !t.provideAITextSearchResults)) return t.name ?? "AI"
		}
		createTextSearchManager(e, t) {
			return new Ud(
				{ query: e, provider: t },
				{ readdir: (n) => Promise.resolve([]), toCanonicalName: (n) => n },
				"textSearchProvider",
			)
		}
		createAITextSearchManager(e, t) {
			return new Ud(
				{ query: e, provider: t },
				{ readdir: (n) => Promise.resolve([]), toCanonicalName: (n) => n },
				"aiTextSearchProvider",
			)
		}
	}
ul = R([S(0, ie), S(1, pi), S(2, te)], ul)
function eh(o) {
	return {
		...o,
		folderQueries: o.folderQueries && o.folderQueries.map(t9),
		extraFileResources: o.extraFileResources && o.extraFileResources.map((e) => y.revive(e)),
	}
}
function t9(o) {
	return ut(o)
}
var pl = class {
	constructor(e, t) {
		this._onDidChangeWindowState = new E()
		this.onDidChangeWindowState = this._onDidChangeWindowState.event
		this._state = pl.InitialState
		e.handle && (this._nativeHandle = wc(e.handle).buffer),
			(this._proxy = t.getProxy(N.MainThreadWindow)),
			this._proxy.$getInitialState().then(({ isFocused: n, isActive: r }) => {
				this.onDidChangeWindowProperty("focused", n), this.onDidChangeWindowProperty("active", r)
			})
	}
	static {
		this.InitialState = { focused: !0, active: !0 }
	}
	getState() {
		let e = this._state
		return {
			get focused() {
				return e.focused
			},
			get active() {
				return e.active
			},
		}
	}
	get nativeHandle() {
		return this._nativeHandle
	}
	$onDidChangeActiveNativeWindowHandle(e) {
		this._nativeHandle = e ? wc(e).buffer : void 0
	}
	$onDidChangeWindowFocus(e) {
		this.onDidChangeWindowProperty("focused", e)
	}
	$onDidChangeWindowActive(e) {
		this.onDidChangeWindowProperty("active", e)
	}
	onDidChangeWindowProperty(e, t) {
		t !== this._state[e] &&
			((this._state = { ...this._state, [e]: t }), this._onDidChangeWindowState.fire(this._state))
	}
	openUri(e, t) {
		let n
		if (typeof e == "string") {
			n = e
			try {
				e = y.parse(e)
			} catch {
				return Promise.reject(`Invalid uri - '${e}'`)
			}
		}
		return Qi(e.scheme)
			? Promise.reject("Invalid scheme - cannot be empty")
			: e.scheme === W.command
				? Promise.reject(`Invalid scheme '${e.scheme}'`)
				: this._proxy.$openUri(e, n, t)
	}
	async asExternalUri(e, t) {
		if (Qi(e.scheme)) return Promise.reject("Invalid scheme - cannot be empty")
		let n = await this._proxy.$asExternalUri(e, t)
		return y.from(n)
	}
}
pl = R([S(0, Xe), S(1, ie)], pl)
var uC = O("IExtHostWindow")
var ml = class extends sb {
	constructor(e, t) {
		super(
			t.logLevel,
			t.logsLocation,
			t.loggers.map((n) => ut(n)),
		),
			(this._proxy = e.getProxy(N.MainThreadLogger))
	}
	$setLogLevel(e, t) {
		t ? this.setLogLevel(y.revive(t), e) : this.setLogLevel(e)
	}
	setVisibility(e, t) {
		super.setVisibility(e, t), this._proxy.$setVisibility(e, t)
	}
	doCreateLogger(e, t, n) {
		return new PR(this._proxy, e, t, n)
	}
}
ml = R([S(0, ie), S(1, Xe)], ml)
var PR = class extends pa {
	constructor(t, n, r, i) {
		super(i?.logLevel === "always")
		this.proxy = t
		this.file = n
		this.isLoggerCreated = !1
		this.buffer = []
		this.setLevel(r),
			this.proxy.$createLogger(n, i).then(() => {
				this.doLog(this.buffer), (this.isLoggerCreated = !0)
			})
	}
	log(t, n) {
		let r = [[t, n]]
		this.isLoggerCreated ? this.doLog(r) : this.buffer.push(...r)
	}
	doLog(t) {
		this.proxy.$log(this.file, t)
	}
	flush() {
		this.proxy.$flush(this.file)
	}
}
var em = O("IExtHostTerminalShellIntegration"),
	Zp = class extends $ {
		constructor(t, n) {
			super()
			this._extHostTerminalService = n
			this._activeShellIntegrations = new Map()
			this._onDidChangeTerminalShellIntegration = new E()
			this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event
			this._onDidStartTerminalShellExecution = new E()
			this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event
			this._onDidEndTerminalShellExecution = new E()
			this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event
			;(this._proxy = t.getProxy(N.MainThreadTerminalShellIntegration)),
				this._register(
					q(() => {
						for (let [r, i] of this._activeShellIntegrations) i.dispose()
						this._activeShellIntegrations.clear()
					}),
				)
		}
		$shellIntegrationChange(t) {
			let n = this._extHostTerminalService.getTerminalById(t)
			if (!n) return
			let r = n.value,
				i = this._activeShellIntegrations.get(t)
			i ||
				((i = new _R(n.value, this._onDidStartTerminalShellExecution)),
				this._activeShellIntegrations.set(t, i),
				i.store.add(n.onWillDispose(() => this._activeShellIntegrations.get(t)?.dispose())),
				i.store.add(i.onDidRequestShellExecution((s) => this._proxy.$executeCommand(t, s))),
				i.store.add(i.onDidRequestEndExecution((s) => this._onDidEndTerminalShellExecution.fire(s))),
				i.store.add(
					i.onDidRequestChangeShellIntegration((s) => this._onDidChangeTerminalShellIntegration.fire(s)),
				),
				(n.shellIntegration = i.value)),
				this._onDidChangeTerminalShellIntegration.fire({ terminal: r, shellIntegration: i.value })
		}
		$shellExecutionStart(t, n, r, i, s) {
			this._activeShellIntegrations.has(t) || this.$shellIntegrationChange(t)
			let a = { value: n, confidence: r, isTrusted: i }
			this._activeShellIntegrations.get(t)?.startShellExecution(a, y.revive(s))
		}
		$shellExecutionEnd(t, n, r, i, s) {
			let a = { value: n, confidence: r, isTrusted: i }
			this._activeShellIntegrations.get(t)?.endShellExecution(a, s)
		}
		$shellExecutionData(t, n) {
			this._activeShellIntegrations.get(t)?.emitData(n)
		}
		$shellEnvChange(t, n, r, i) {
			this._activeShellIntegrations.get(t)?.setEnv(n, r, i)
		}
		$cwdChange(t, n) {
			this._activeShellIntegrations.get(t)?.setCwd(y.revive(n))
		}
		$closeTerminal(t) {
			this._activeShellIntegrations.get(t)?.dispose(), this._activeShellIntegrations.delete(t)
		}
	}
Zp = R([S(0, ie), S(1, er)], Zp)
var _R = class extends $ {
		constructor(t, n) {
			super()
			this._terminal = t
			this._onDidStartTerminalShellExecution = n
			this._pendingExecutions = []
			this.store = this._register(new Q())
			this._onDidRequestChangeShellIntegration = this._register(new E())
			this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event
			this._onDidRequestShellExecution = this._register(new E())
			this.onDidRequestShellExecution = this._onDidRequestShellExecution.event
			this._onDidRequestEndExecution = this._register(new E())
			this.onDidRequestEndExecution = this._onDidRequestEndExecution.event
			this._onDidRequestNewExecution = this._register(new E())
			this.onDidRequestNewExecution = this._onDidRequestNewExecution.event
			let r = this
			this.value = {
				get cwd() {
					return r._cwd
				},
				get env() {
					if (r._env)
						return Object.freeze({ isTrusted: r._env.isTrusted, value: Object.freeze({ ...r._env.value }) })
				},
				executeCommand(i, s) {
					let a = i
					if (s) for (let c of s) !c.match(/["'`]/) && c.match(/\s/) ? (a += ` "${c}"`) : (a += ` ${c}`)
					r._onDidRequestShellExecution.fire(a)
					let l = { value: a, confidence: 2, isTrusted: !0 }
					return r.requestNewShellExecution(l, r._cwd).value
				},
			}
		}
		get currentExecution() {
			return this._currentExecution
		}
		requestNewShellExecution(t, n) {
			let r = new mC(t, n ?? this._cwd)
			return (
				pC(t.value).length > 1 &&
					(this._currentExecutionProperties = { isMultiLine: !0, unresolvedCommandLines: pC(t.value) }),
				this._pendingExecutions.push(r),
				this._onDidRequestNewExecution.fire(t.value),
				r
			)
		}
		startShellExecution(t, n) {
			if (
				(this._pendingEndingExecution &&
					(this._onDidRequestEndExecution.fire({
						terminal: this._terminal,
						shellIntegration: this.value,
						execution: this._pendingEndingExecution.value,
						exitCode: void 0,
					}),
					(this._pendingEndingExecution = void 0)),
				this._currentExecution)
			) {
				if (
					this._currentExecutionProperties?.isMultiLine &&
					this._currentExecutionProperties.unresolvedCommandLines
				) {
					let i = F2(this._currentExecutionProperties.unresolvedCommandLines, t)
					if (i) {
						this._currentExecutionProperties.unresolvedCommandLines = i.unresolvedCommandLines
						return
					}
				}
				this._currentExecution.endExecution(void 0),
					this._currentExecution.flush(),
					this._onDidRequestEndExecution.fire({
						terminal: this._terminal,
						shellIntegration: this.value,
						execution: this._currentExecution.value,
						exitCode: void 0,
					})
			}
			let r
			if (t.confidence === 2)
				for (let [i, s] of this._pendingExecutions.entries())
					if (s.value.commandLine.value === t.value) {
						;(r = s),
							(this._currentExecutionProperties = { isMultiLine: !1, unresolvedCommandLines: void 0 }),
							(r = s),
							this._pendingExecutions.splice(i, 1)
						break
					} else {
						let a = F2(pC(s.value.commandLine.value), t)
						if (a) {
							;(this._currentExecutionProperties = {
								isMultiLine: !0,
								unresolvedCommandLines: a.unresolvedCommandLines,
							}),
								(r = s),
								this._pendingExecutions.splice(i, 1)
							break
						}
					}
			else r = this._pendingExecutions.shift()
			r || (r = new mC(t, n ?? this._cwd)),
				(this._currentExecution = r),
				this._onDidStartTerminalShellExecution.fire({
					terminal: this._terminal,
					shellIntegration: this.value,
					execution: this._currentExecution.value,
				})
		}
		emitData(t) {
			this.currentExecution?.emitData(t)
		}
		endShellExecution(t, n) {
			if (
				!(
					this._currentExecutionProperties?.isMultiLine &&
					this._currentExecutionProperties.unresolvedCommandLines &&
					this._currentExecutionProperties.unresolvedCommandLines.length > 0
				) &&
				this._currentExecution
			) {
				let r = this._currentExecutionProperties?.isMultiLine ? this._currentExecution.value.commandLine : t
				this._currentExecution.endExecution(r)
				let i = this._currentExecution
				;(this._pendingEndingExecution = i),
					(this._currentExecution = void 0),
					i.flush().then(() => {
						this._pendingEndingExecution === i &&
							(this._onDidRequestEndExecution.fire({
								terminal: this._terminal,
								shellIntegration: this.value,
								execution: i.value,
								exitCode: n,
							}),
							(this._pendingEndingExecution = void 0))
					})
			}
		}
		setEnv(t, n, r) {
			let i = {}
			for (let s = 0; s < t.length; s++) i[t[s]] = n[s]
			;(this._env = { value: i, isTrusted: r }), this._fireChangeEvent()
		}
		setCwd(t) {
			let n = !1
			y.isUri(this._cwd)
				? (n = !y.isUri(t) || this._cwd.toString() !== t.toString())
				: this._cwd !== t && (n = !0),
				n && ((this._cwd = t), this._fireChangeEvent())
		}
		_fireChangeEvent() {
			this._onDidRequestChangeShellIntegration.fire({ terminal: this._terminal, shellIntegration: this.value })
		}
	},
	mC = class {
		constructor(e, t) {
			this._commandLine = e
			this.cwd = t
			this._isEnded = !1
			let n = this
			this.value = {
				get commandLine() {
					return n._commandLine
				},
				get cwd() {
					return n.cwd
				},
				read() {
					return n._createDataStream()
				},
			}
		}
		_createDataStream() {
			if (!this._dataStream) {
				if (this._isEnded) return ci.EMPTY
				this._dataStream = new DR()
			}
			return this._dataStream.createIterable()
		}
		emitData(e) {
			this._isEnded || this._dataStream?.emitData(e)
		}
		endExecution(e) {
			e && (this._commandLine = e), this._dataStream?.endExecution(), (this._isEnded = !0)
		}
		async flush() {
			this._dataStream &&
				(await this._dataStream.flush(), this._dataStream.dispose(), (this._dataStream = void 0))
		}
	},
	DR = class extends $ {
		constructor() {
			super(...arguments)
			this._iterables = []
			this._emitters = []
		}
		createIterable() {
			this._barrier || (this._barrier = new dn())
			let t = this._barrier,
				n = new ci(async (r) => {
					this._emitters.push(r), await t.wait()
				})
			return this._iterables.push(n), n
		}
		emitData(t) {
			for (let n of this._emitters) n.emitOne(t)
		}
		endExecution() {
			this._barrier?.open()
		}
		async flush() {
			await Promise.all(this._iterables.map((t) => t.toPromise()))
		}
	}
function pC(o) {
	return o
		.split(
			`
`,
		)
		.map((e) => e.trim())
		.filter((e) => e.length > 0)
}
function F2(o, e) {
	if (o.length === 0) return !1
	let t = [...o],
		n = pC(e.value)
	if (t && t.length > 0) {
		for (; t.length > 0 && t[0] === n[0]; ) t.shift(), n.shift()
		if (n.length === 0) return { unresolvedCommandLines: t }
	}
	return !1
}
function N2(o, e) {
	return we.toKey(o) + "/" + e
}
var n9
;((e) => {
	function o(t, n) {
		return (
			t.id === n.id &&
			t.remoteAuthority === n.remoteAuthority &&
			t.label === n.label &&
			t.isTrustedByDefault === n.isTrustedByDefault
		)
	}
	e.equals = o
})((n9 ||= {}))
var r9
;((n) => {
	function o(r) {
		return r
	}
	n.toSerialized = o
	function e(r) {
		return {
			id: r.id,
			label: r.label,
			launch: fC.fromSerialized(r.launch),
			variableReplacement: r.variableReplacement ? U2.fromSerialized(r.variableReplacement) : void 0,
		}
	}
	n.fromSerialized = e
	function t(r, i) {
		return (
			r.id === i.id &&
			r.label === i.label &&
			mn(r.roots, i.roots, (s, a) => s.toString() === a.toString()) &&
			nn(r.launch, i.launch) &&
			nn(r.presentation, i.presentation) &&
			nn(r.variableReplacement, i.variableReplacement)
		)
	}
	n.equals = t
})((r9 ||= {}))
var U2
;((t) => {
	function o(n) {
		return n
	}
	t.toSerialized = o
	function e(n) {
		return {
			section: n.section,
			folder: n.folder ? { ...n.folder, uri: y.revive(n.folder.uri) } : void 0,
			target: n.target,
		}
	}
	t.fromSerialized = e
})((U2 ||= {}))
var XRe = O("IMcpService")
var fC
;((t) => {
	function o(n) {
		return n
	}
	t.toSerialized = o
	function e(n) {
		switch (n.type) {
			case 2:
				return { type: n.type, uri: y.revive(n.uri), headers: n.headers }
			case 1:
				return {
					type: n.type,
					cwd: n.cwd ? y.revive(n.cwd) : void 0,
					command: n.command,
					args: n.args,
					env: n.env,
					envFile: n.envFile,
				}
		}
	}
	t.fromSerialized = e
})((fC ||= {}))
var Ur
;((i) => {
	let o
	;((c) => (
		(c[(c.Stopped = 0)] = "Stopped"),
		(c[(c.Starting = 1)] = "Starting"),
		(c[(c.Running = 2)] = "Running"),
		(c[(c.Error = 3)] = "Error")
	))((o = i.Kind ||= {})),
		(i.toString = (s) => {
			switch (s.state) {
				case 0:
					return p("mcpstate.stopped", "Stopped")
				case 1:
					return p("mcpstate.starting", "Starting")
				case 2:
					return p("mcpstate.running", "Running")
				case 3:
					return p("mcpstate.error", "Error {0}", s.message)
				default:
					uc(s)
			}
		}),
		(i.toKindString = (s) => {
			switch (s) {
				case 0:
					return "stopped"
				case 1:
					return "starting"
				case 2:
					return "running"
				case 3:
					return "error"
				default:
					uc(s)
			}
		}),
		(i.canBeStarted = (s) => s === 3 || s === 0),
		(i.isRunning = (s) => !(0, i.canBeStarted)(s.state))
})((Ur ||= {}))
var Hd = O("IExtHostMpcService"),
	fl = class extends $ {
		constructor(t) {
			super()
			this._initialProviderPromises = new Set()
			this._sseEventSources = this._register(new Wr())
			this._eventSource = new Rt(
				async () => (await ip("@c4312/eventsource-umd", "dist/index.umd.js")).EventSource,
			)
			this._proxy = t.getProxy(N.MainThreadMcp)
		}
		$startMcp(t, n) {
			this._startMcp(t, fC.fromSerialized(n))
		}
		_startMcp(t, n) {
			if (n.type === 2) {
				this._sseEventSources.set(t, new kR(this._eventSource.value, t, n, this._proxy))
				return
			}
			throw new Error("not implemented")
		}
		$stopMcp(t) {
			this._sseEventSources.has(t) &&
				(this._sseEventSources.deleteAndDispose(t),
				this._proxy.$onDidChangeState(t, { state: Ur.Kind.Stopped }))
		}
		$sendMessage(t, n) {
			this._sseEventSources.get(t)?.send(n)
		}
		async $waitForInitialCollectionProviders() {
			await Promise.all(this._initialProviderPromises)
		}
		registerMcpConfigurationProvider(t, n, r) {
			let i = new Q(),
				s = t.contributes?.modelContextServerCollections?.find((c) => c.id === n)
			if (!s)
				throw new Error(
					`MCP configuration providers must be registered in the contributes.modelContextServerCollections array within your package.json, but "${n}" was not`,
				)
			let a = {
					id: N2(t.identifier, n),
					isTrustedByDefault: !0,
					label: s?.label ?? t.displayName ?? t.name,
					scope: 1,
				},
				l = async () => {
					let c = await r.provideMcpServerDefinitions(De.None)
					function u(f) {
						return !!f.uri
					}
					let m = []
					for (let f of c ?? [])
						m.push({
							id: we.toKey(t.identifier),
							label: f.label,
							launch: u(f)
								? { type: 2, uri: f.uri, headers: f.headers }
								: {
										type: 1,
										cwd: f.cwd,
										args: f.args,
										command: f.command,
										env: f.env,
										envFile: void 0,
									},
						})
					this._proxy.$upsertMcpCollection(a, m)
				}
			i.add(
				q(() => {
					this._proxy.$deleteMcpCollection(a.id)
				}),
			),
				r.onDidChange && i.add(r.onDidChange(l))
			let d = new Promise((c) => {
				setTimeout(
					() =>
						l().finally(() => {
							this._initialProviderPromises.delete(d), c()
						}),
					0,
				)
			})
			return this._initialProviderPromises.add(d), i
		}
	}
fl = R([S(0, ie)], fl)
var kR = class extends $ {
	constructor(t, n, r, i) {
		super()
		this._id = n
		this._proxy = i
		this._requestSequencer = new Ov()
		this._postEndpoint = new Cn()
		t.then((s) => this._attach(s, r))
	}
	_attach(t, n) {
		if (this._store.isDisposed) return
		let r = new t(n.uri.toString(), {
			fetch: (i, s) =>
				fetch(i, { ...s, headers: { ...Object.fromEntries(n.headers), ...s?.headers } }).then(
					async (a) => (
						a.status >= 300 &&
							(this._proxy.$onDidChangeState(this._id, {
								state: Ur.Kind.Error,
								message: `${a.status} status connecting to ${n.uri}: ${await this._getErrText(a)}`,
							}),
							r.close()),
						a
					),
					(a) => (
						this._proxy.$onDidChangeState(this._id, {
							state: Ur.Kind.Error,
							message: `Error connecting to ${n.uri}: ${String(a)}`,
						}),
						r.close(),
						Promise.reject(a)
					),
				),
		})
		this._register(q(() => r.close())),
			r.addEventListener("endpoint", (i) => {
				this._postEndpoint.complete(new URL(i.data, n.uri.toString()).toString())
			}),
			r.addEventListener("message", (i) => {
				this._proxy.$onDidReceiveMessage(this._id, i.data)
			}),
			r.addEventListener("open", () => {
				this._proxy.$onDidChangeState(this._id, { state: Ur.Kind.Running })
			}),
			r.addEventListener("error", (i) => {
				this._postEndpoint.cancel(),
					this._proxy.$onDidChangeState(this._id, {
						state: Ur.Kind.Error,
						message: `Error connecting to ${n.uri}: ${i.code || 0} ${i.message || JSON.stringify(i)}`,
					}),
					r.close()
			})
	}
	async send(t) {
		try {
			let n = await this._requestSequencer.queue(async () => {
				let r = await this._postEndpoint.p,
					i = new TextEncoder().encode(t)
				return fetch(r, {
					method: "POST",
					headers: { "Content-Type": "application/json", "Content-Length": String(i.length) },
					body: i,
				})
			})
			n.status >= 300 &&
				this._proxy.$onDidPublishLog(
					this._id,
					4,
					`${n.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(n)}`,
				)
		} catch {}
	}
	async _getErrText(t) {
		try {
			return await t.text()
		} catch {
			return t.statusText
		}
	}
}
Ke(Mp, Lp, 1)
Ke(co, ml, 1)
Ke($s, Bp, 1)
Ke(Tn, Sp, 0)
Ke(Pp, wp, 0)
Ke(_p, Bs, 0)
Ke(pn, dp, 0)
Ke(Li, Ir, 0)
Ke(zs, jp, 0)
Ke(Qp, Gp, 0)
Ke(Xx, Fi, 0)
Ke(eo, Vp, 0)
Ke(Np, Fp, 0)
Ke(uo, bb, 0)
Ke(Jx, Wp, 1)
Ke(Yp, ul, 0)
Ke(fp, mp, 0)
Ke(zp, $p, 0)
Ke(er, Tp, 0)
Ke(em, Zp, 0)
Ke(ol, rl, 0)
Ke(uC, pl, 0)
Ke(Sn, sp, 0)
Ke(Op, Ap, 0)
Ke(Xo, Kp, 0)
Ke(Yo, cl, 0)
Ke(Hd, fl, 0)
var tm = class extends Md {
	constructor(e, t) {
		super(!0, e, t)
	}
	createTerminal(e, t, n) {
		return this.createTerminalFromOptions({ name: e, shellPath: t, shellArgs: n })
	}
	createTerminalFromOptions(e, t) {
		let n = new Ep(this._proxy, He(), e, e.name)
		return this._terminals.push(n), n.create(e, this._serializeParentTerminal(e, t)), n.value
	}
}
tm = R([S(0, Tn), S(1, ie)], tm)
import { promises as V2 } from "fs"
function H2(o, ...e) {
	let t = e.reduce((i, s) => ((i[s] = !0), i), {}),
		n = [
			/^ELECTRON_.+$/,
			/^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/,
			/^SNAP(|_.*)$/,
			/^GDK_PIXBUF_.+$/,
		]
	Object.keys(o)
		.filter((i) => !t[i])
		.forEach((i) => {
			for (let s = 0; s < n.length; s++)
				if (i.search(n[s]) !== -1) {
					delete o[i]
					break
				}
		})
}
function W2(o) {
	o && (delete o.DEBUG, Ve && delete o.LD_PRELOAD)
}
function gC(o = Er) {
	return o.comspec || "cmd.exe"
}
function B2(o) {
	let e = [],
		t = !1,
		n = function (r) {
			if (t) {
				e.push(r)
				return
			}
			;(!o.send(r, (s) => {
				if ((s && console.error(s), (t = !1), e.length > 0)) {
					let a = e.slice(0)
					;(e = []), a.forEach((l) => n(l))
				}
			}) ||
				Ie) &&
				(t = !0)
		}
	return { send: n }
}
async function i9(o) {
	if (await Qe.exists(o)) {
		let e
		try {
			e = await V2.stat(o)
		} catch (t) {
			t.message.startsWith("EACCES") && (e = await V2.lstat(o))
		}
		return e ? !e.isDirectory() : !1
	}
	return !1
}
async function Wd(o, e, t, n = Er, r = i9) {
	if (In(o)) return (await r(o)) ? o : void 0
	if ((e === void 0 && (e = Ao()), Qt(o) !== ".")) {
		let l = Fe(e, o)
		return (await r(l)) ? l : void 0
	}
	let s = ow(n, "PATH")
	if ((t === void 0 && Ee(s) && (t = s.split(gv)), t === void 0 || t.length === 0)) {
		let l = Fe(e, o)
		return (await r(l)) ? l : void 0
	}
	for (let l of t) {
		let d
		if ((In(l) ? (d = Fe(l, o)) : (d = Fe(e, l, o)), Ie)) {
			let u = (ow(n, "PATHEXT") || ".COM;.EXE;.BAT;.CMD").split(";").map(async (m) => {
				let f = d + m
				return (await r(f)) ? f : void 0
			})
			for (let m of u) {
				let f = await m
				if (f) return f
			}
		}
		if (await r(d)) return d
	}
	let a = Fe(e, o)
	return (await r(a)) ? a : void 0
}
import { homedir as s9 } from "os"
var nm = class extends Fd {
	constructor(t, n, r, i, s, a, l, d, c) {
		super(t, n, r, i, s, a, l, d)
		this.workspaceService = r
		this.variableResolver = c
		n.remote.isRemote && n.remote.authority
			? this.registerTaskSystem(W.vscodeRemote, {
					scheme: W.vscodeRemote,
					authority: n.remote.authority,
					platform: process.platform,
				})
			: this.registerTaskSystem(W.file, { scheme: W.file, authority: "", platform: process.platform }),
			this._proxy.$registerSupportedExecutions(!0, !0, !0)
	}
	async executeTask(t, n) {
		let r = n
		if (!n.execution && r._id === void 0) throw new Error("Tasks to execute must include an execution")
		if (r._id !== void 0) {
			let i = dR.from(r, this.workspaceService),
				s = await this._proxy.$getTaskExecution(i)
			if (s.task === void 0) throw new Error("Task from execution DTO is undefined")
			let a = await this.getTaskExecution(s, n)
			return this._proxy.$executeTask(i).catch(() => {}), a
		} else {
			let i = Ni.from(n, t)
			if (i === void 0) return Promise.reject(new Error("Task is not valid"))
			Jo.is(i.execution) && (await this.addCustomExecution(i, n, !1))
			let s = await this.getTaskExecution(await this._proxy.$getTaskExecution(i), n)
			return this._proxy.$executeTask(i).catch(() => {}), s
		}
	}
	provideTasksInternal(t, n, r, i) {
		let s = []
		if (i)
			for (let a of i) {
				this.checkDeprecation(a, r),
					(!a.definition || !t[a.definition.type]) &&
						this._logService.warn(
							`The task [${a.source}, ${a.name}] uses an undefined task type. The task will be ignored in the future.`,
						)
				let l = Ni.from(a, r.extension)
				l && (s.push(l), Jo.is(l.execution) && n.push(this.addCustomExecution(l, a, !0)))
			}
		return { tasks: s, extension: r.extension }
	}
	async resolveTaskInternal(t) {
		return t
	}
	async getAFolder(t) {
		let n = t && t.length > 0 ? t[0] : void 0
		if (!n) {
			let r = y.file(s9())
			n = new Ql({ uri: r, name: Ht(r), index: 0 })
		}
		return {
			uri: n.uri,
			name: n.name,
			index: n.index,
			toResource: () => {
				throw new Error("Not implemented")
			},
		}
	}
	async $resolveVariables(t, n) {
		let r = y.revive(t),
			i = { process: void 0, variables: Object.create(null) },
			s = await this._workspaceProvider.resolveWorkspaceFolder(r),
			a = (await this._workspaceProvider.getWorkspaceFolders2()) ?? [],
			l = await this.variableResolver.getResolver(),
			d = s
				? {
						uri: s.uri,
						name: s.name,
						index: s.index,
						toResource: () => {
							throw new Error("Not implemented")
						},
					}
				: await this.getAFolder(a)
		for (let c of n.variables) i.variables[c] = await l.resolveAsync(d, c)
		if (n.process !== void 0) {
			let c
			if (n.process.path !== void 0) {
				c = n.process.path.split(gv)
				for (let h = 0; h < c.length; h++) c[h] = await l.resolveAsync(d, c[h])
			}
			let u = await l.resolveAsync(d, n.process.name),
				m = n.process.cwd !== void 0 ? await l.resolveAsync(d, n.process.cwd) : void 0,
				f = await Wd(u, m, c)
			f ? (i.process = f) : In(u) ? (i.process = u) : (i.process = Fe(m ?? "", u))
		}
		return i
	}
	async $jsonTasksSupported() {
		return !0
	}
	async $findExecutable(t, n, r) {
		return Wd(t, n, r)
	}
}
nm = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, eo), S(4, pn), S(5, er), S(6, te), S(7, $s), S(8, Yo)], nm)
import * as Vd from "child_process"
var F0e = O("externalTerminal"),
	th = "Terminal.app"
var z2 = p("console.title", "VS Code Console"),
	nh = class {
		async getDefaultTerminalForPlatforms() {
			return {
				windows: rh.getDefaultTerminalWindows(),
				linux: await oh.getDefaultTerminalLinuxReady(),
				osx: "xterm",
			}
		}
	},
	Zo = class Zo extends nh {
		static {
			this.CMD = "cmd.exe"
		}
		openTerminal(e, t) {
			return this.spawnTerminal(Vd, e, gC(), t)
		}
		spawnTerminal(e, t, n, r) {
			let i = t.windowsExec || Zo.getDefaultTerminalWindows()
			r && r[1] === ":" && (r = r[0].toUpperCase() + r.substr(1))
			let s = Ze(i, ".exe").toLowerCase()
			if (s === "cmder") return e.spawn(i, r ? [r] : void 0), Promise.resolve(void 0)
			let a = ["/c", "start", "/wait"]
			return (
				i.indexOf(" ") >= 0 && a.push(i),
				a.push(i),
				s === "wt" && a.push("-d ."),
				new Promise((l, d) => {
					let c = rm(process),
						u = e.spawn(n, a, { cwd: r, env: c, detached: !0 })
					u.on("error", d), u.on("exit", () => l())
				})
			)
		}
		async runInTerminal(e, t, n, r, i) {
			let s = "windowsExec" in i && i.windowsExec ? i.windowsExec : Zo.getDefaultTerminalWindows(),
				a = await Zo.getWtExePath()
			return new Promise((l, d) => {
				let c = `"${t} - ${z2}"`,
					u = `"${n.join('" "')}" & pause`,
					m = Object.assign({}, rm(process), r)
				Object.keys(m)
					.filter((C) => m[C] === null)
					.forEach((C) => delete m[C])
				let f = { cwd: t, env: m, windowsVerbatimArguments: !0 },
					h,
					g
				Ze(s, ".exe") === "wt"
					? ((h = s), (g = ["-d", ".", Zo.CMD, "/c", u]))
					: a
						? ((h = a), (g = ["-d", ".", s, "/c", u]))
						: ((h = Zo.CMD), (g = ["/c", "start", c, "/wait", s, "/c", `"${u}"`])),
					Vd.spawn(h, g, f).on("error", (C) => {
						d(RR(C))
					}),
					l(void 0)
			})
		}
		static getDefaultTerminalWindows() {
			if (!Zo._DEFAULT_TERMINAL_WINDOWS) {
				let e = !!process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
				Zo._DEFAULT_TERMINAL_WINDOWS = `${process.env.windir ? process.env.windir : "C:\\Windows"}\\${e ? "Sysnative" : "System32"}\\cmd.exe`
			}
			return Zo._DEFAULT_TERMINAL_WINDOWS
		}
		static async getWtExePath() {
			try {
				return await Wd("wt")
			} catch {
				return
			}
		}
	}
R([qv], Zo, "getWtExePath", 1)
var rh = Zo,
	hC = class o extends nh {
		static {
			this.OSASCRIPT = "/usr/bin/osascript"
		}
		openTerminal(e, t) {
			return this.spawnTerminal(Vd, e, t)
		}
		runInTerminal(e, t, n, r, i) {
			let s = i.osxExec || th
			return new Promise((a, l) => {
				if (s === th || s === "iTerm.app") {
					let d = s === th ? "TerminalHelper" : "iTermHelper",
						u = [
							Ic.asFileUri(`vs/workbench/contrib/externalTerminal/node/${d}.scpt`).fsPath,
							"-t",
							e || z2,
							"-w",
							t,
						]
					for (let h of n) u.push("-a"), u.push(h)
					if (r) {
						let h = Object.assign({}, rm(process), r)
						for (let g in h) {
							let I = h[g]
							I === null ? (u.push("-u"), u.push(g)) : (u.push("-e"), u.push(`${g}=${I}`))
						}
					}
					let m = "",
						f = Vd.spawn(o.OSASCRIPT, u)
					f.on("error", (h) => {
						l(RR(h))
					}),
						f.stderr.on("data", (h) => {
							m += h.toString()
						}),
						f.on("exit", (h) => {
							if (h === 0) a(void 0)
							else if (m) {
								let g = m.split(
									`
`,
									1,
								)
								l(new Error(g[0]))
							} else
								l(
									new Error(
										p("mac.terminal.script.failed", "Script '{0}' failed with exit code {1}", d, h),
									),
								)
						})
				} else l(new Error(p("mac.terminal.type.not.supported", "'{0}' not supported", s)))
			})
		}
		spawnTerminal(e, t, n) {
			let r = t.osxExec || th
			return new Promise((i, s) => {
				let a = ["-a", r]
				n && a.push(n)
				let l = rm(process),
					d = e.spawn("/usr/bin/open", a, { cwd: n, env: l })
				d.on("error", s), d.on("exit", () => i())
			})
		}
	},
	oh = class o extends nh {
		static {
			this.WAIT_MESSAGE = p("press.any.key", "Press any key to continue...")
		}
		openTerminal(e, t) {
			return this.spawnTerminal(Vd, e, t)
		}
		runInTerminal(e, t, n, r, i) {
			let s = i.linuxExec ? Promise.resolve(i.linuxExec) : o.getDefaultTerminalLinuxReady()
			return new Promise((a, l) => {
				let d = []
				s.then((c) => {
					c.indexOf("gnome-terminal") >= 0 ? d.push("-x") : d.push("-e"), d.push("bash"), d.push("-c")
					let u = `${a9(n)}; echo; read -p "${o.WAIT_MESSAGE}" -n1;`
					d.push(`''${u}''`)
					let m = Object.assign({}, rm(process), r)
					Object.keys(m)
						.filter((I) => m[I] === null)
						.forEach((I) => delete m[I])
					let f = { cwd: t, env: m },
						h = "",
						g = Vd.spawn(c, d, f)
					g.on("error", (I) => {
						l(RR(I))
					}),
						g.stderr.on("data", (I) => {
							h += I.toString()
						}),
						g.on("exit", (I) => {
							if (I === 0) a(void 0)
							else if (h) {
								let C = h.split(
									`
`,
									1,
								)
								l(new Error(C[0]))
							} else l(new Error(p("linux.term.failed", "'{0}' failed with exit code {1}", c, I)))
						})
				})
			})
		}
		static async getDefaultTerminalLinuxReady() {
			if (!o._DEFAULT_TERMINAL_LINUX_READY)
				if (!Ve) o._DEFAULT_TERMINAL_LINUX_READY = Promise.resolve("xterm")
				else {
					let e = await Qe.exists("/etc/debian_version")
					o._DEFAULT_TERMINAL_LINUX_READY = new Promise((t) => {
						e
							? t("x-terminal-emulator")
							: process.env.DESKTOP_SESSION === "gnome" || process.env.DESKTOP_SESSION === "gnome-classic"
								? t("gnome-terminal")
								: process.env.DESKTOP_SESSION === "kde-plasma"
									? t("konsole")
									: process.env.COLORTERM
										? t(process.env.COLORTERM)
										: process.env.TERM
											? t(process.env.TERM)
											: t("xterm")
					})
				}
			return o._DEFAULT_TERMINAL_LINUX_READY
		}
		spawnTerminal(e, t, n) {
			let r = t.linuxExec ? Promise.resolve(t.linuxExec) : o.getDefaultTerminalLinuxReady()
			return new Promise((i, s) => {
				r.then((a) => {
					let l = rm(process),
						d = e.spawn(a, [], { cwd: n, env: l })
					d.on("error", s), d.on("exit", () => i())
				})
			})
		}
	}
function rm(o) {
	let e = { ...o.env }
	return H2(e), e
}
function RR(o) {
	return "errno" in o && o.errno === "ENOENT" && "path" in o && typeof o.path == "string"
		? new Error(p("ext.term.app.not.found", "can't find terminal application '{0}'", o.path))
		: o
}
function a9(o) {
	let e = ""
	for (let t of o) t.indexOf(" ") >= 0 ? (e += '"' + t + '"') : (e += t), (e += " ")
	return e
}
var vC = class o {
	constructor() {
		this.validators = new Map()
	}
	static {
		this._nextId = 1
	}
	async createNewMessage(e) {
		try {
			let t = await this.getValidator()
			if (t) {
				let n = String(o._nextId++)
				return this.validators.set(n, t), { id: n, data: t.createNewMessage(e) }
			}
		} catch {}
		return { id: "", data: e }
	}
	async validate(e, t) {
		if (!e.id) return !0
		let n = this.validators.get(e.id)
		if (!n) return !1
		this.validators.delete(e.id)
		try {
			return n.validate(t) === "ok"
		} catch {
			return !1
		} finally {
			n.dispose?.()
		}
	}
	async sign(e) {
		try {
			return await this.signValue(e)
		} catch {}
		return e
	}
}
var om = class extends vC {
	getValidator() {
		return this.vsda().then((e) => new e.validator())
	}
	signValue(e) {
		return this.vsda().then((t) => new t.signer().sign(e))
	}
	async vsda() {
		let e = "vsda",
			{ default: t } = await import(e)
		return t
	}
}
import * as im from "child_process"
import * as AR from "net"
var bC = class o extends qp {
		constructor() {
			super()
			this.rawData = Buffer.allocUnsafe(0)
			this.contentLength = -1
		}
		static {
			this.TWO_CRLF = `\r
\r
`
		}
		static {
			this.HEADER_LINESEPARATOR = /\r?\n/
		}
		static {
			this.HEADER_FIELDSEPARATOR = /: */
		}
		connect(t, n) {
			;(this.outputStream = n),
				(this.rawData = Buffer.allocUnsafe(0)),
				(this.contentLength = -1),
				t.on("data", (r) => this.handleData(r))
		}
		sendMessage(t) {
			if (this.outputStream) {
				let n = JSON.stringify(t)
				this.outputStream.write(`Content-Length: ${Buffer.byteLength(n, "utf8")}${o.TWO_CRLF}${n}`, "utf8")
			}
		}
		handleData(t) {
			for (this.rawData = Buffer.concat([this.rawData, t]); ; ) {
				if (this.contentLength >= 0) {
					if (this.rawData.length >= this.contentLength) {
						let n = this.rawData.toString("utf8", 0, this.contentLength)
						if (
							((this.rawData = this.rawData.slice(this.contentLength)),
							(this.contentLength = -1),
							n.length > 0)
						)
							try {
								this.acceptMessage(JSON.parse(n))
							} catch (r) {
								this._onError.fire(
									new Error(
										(r.message || r) +
											`
` +
											n,
									),
								)
							}
						continue
					}
				} else {
					let n = this.rawData.indexOf(o.TWO_CRLF)
					if (n !== -1) {
						let i = this.rawData.toString("utf8", 0, n).split(o.HEADER_LINESEPARATOR)
						for (let s of i) {
							let a = s.split(o.HEADER_FIELDSEPARATOR)
							a[0] === "Content-Length" && (this.contentLength = Number(a[1]))
						}
						this.rawData = this.rawData.slice(n + o.TWO_CRLF.length)
						continue
					}
				}
				break
			}
		}
	},
	yC = class extends bC {
		startSession() {
			return new Promise((e, t) => {
				let n = !1
				;(this.socket = this.createConnection(() => {
					this.connect(this.socket, this.socket), e(), (n = !0)
				})),
					this.socket.on("close", () => {
						n ? this._onError.fire(new Error("connection closed")) : t(new Error("connection closed"))
					}),
					this.socket.on("error", (r) => {
						r instanceof AggregateError && (r = r.errors[0]), n ? this._onError.fire(r) : t(r)
					})
			})
		}
		async stopSession() {
			await this.cancelPendingRequests(), this.socket && (this.socket.end(), (this.socket = void 0))
		}
	},
	IC = class extends yC {
		constructor(t) {
			super()
			this.adapterServer = t
		}
		createConnection(t) {
			return AR.createConnection(this.adapterServer.port, this.adapterServer.host || "127.0.0.1", t)
		}
	},
	xC = class extends yC {
		constructor(t) {
			super()
			this.adapterServer = t
		}
		createConnection(t) {
			return AR.createConnection(this.adapterServer.path, t)
		}
	},
	ih = class o extends bC {
		constructor(t, n) {
			super()
			this.adapterExecutable = t
			this.debugType = n
		}
		async startSession() {
			let t = this.adapterExecutable.command,
				n = this.adapterExecutable.args,
				r = this.adapterExecutable.options || {}
			try {
				if (t)
					if (In(t)) {
						if (!(await Qe.exists(t)))
							throw new Error(
								p("debugAdapterBinNotFound", "Debug adapter executable '{0}' does not exist.", t),
							)
					} else t.indexOf("/") < 0 && t.indexOf("\\") < 0
				else
					throw new Error(
						p(
							{
								key: "debugAdapterCannotDetermineExecutable",
								comment: ["Adapter executable file not found"],
							},
							"Cannot determine executable for debug adapter '{0}'.",
							this.debugType,
						),
					)
				let i = process.env
				if ((r.env && Object.keys(r.env).length > 0 && (i = fr(je(process.env), r.env)), t === "node"))
					if (Array.isArray(n) && n.length > 0) {
						let s = !!process.env.ELECTRON_RUN_AS_NODE || !!process.versions.electron,
							a = {
								env: i,
								execArgv: s
									? ["-e", "delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])"]
									: [],
								silent: !0,
							}
						r.cwd && (a.cwd = r.cwd)
						let l = im.fork(n[0], n.slice(1), a)
						if (!l.pid)
							throw new Error(
								p("unableToLaunchDebugAdapter", "Unable to launch debug adapter from '{0}'.", n[0]),
							)
						this.serverProcess = l
					} else throw new Error(p("unableToLaunchDebugAdapterNoArgs", "Unable to launch debug adapter."))
				else {
					let s = t,
						a = n,
						l = { env: i }
					r.cwd && (l.cwd = r.cwd),
						Ie &&
							(t.endsWith(".bat") || t.endsWith(".cmd")) &&
							((l.shell = !0),
							(s = `"${t}"`),
							(a = n.map((d) => ((d = d.replace(/"/g, '\\"')), `"${d}"`)))),
						(this.serverProcess = im.spawn(s, a, l))
				}
				this.serverProcess.on("error", (s) => {
					this._onError.fire(s)
				}),
					this.serverProcess.on("exit", (s, a) => {
						this._onExit.fire(s)
					}),
					this.serverProcess.stdout.on("close", () => {
						this._onError.fire(new Error("read error"))
					}),
					this.serverProcess.stdout.on("error", (s) => {
						this._onError.fire(s)
					}),
					this.serverProcess.stdin.on("error", (s) => {
						this._onError.fire(s)
					}),
					this.serverProcess.stderr.resume(),
					this.connect(this.serverProcess.stdout, this.serverProcess.stdin)
			} catch (i) {
				this._onError.fire(i)
			}
		}
		async stopSession() {
			return this.serverProcess
				? (await this.cancelPendingRequests(),
					Ie
						? new Promise((t, n) => {
								let r = im.exec(`taskkill /F /T /PID ${this.serverProcess.pid}`, function (i, s, a) {
									if (i) return n(i)
								})
								r.on("exit", t), r.on("error", n)
							})
						: (this.serverProcess.kill("SIGTERM"), Promise.resolve(void 0)))
				: Promise.resolve(void 0)
		}
		static extract(t, n) {
			if (!t) return
			let r = Object.create(null)
			t.runtime && (t.runtime.indexOf("./") === 0 ? (r.runtime = Fe(n, t.runtime)) : (r.runtime = t.runtime)),
				t.runtimeArgs && (r.runtimeArgs = t.runtimeArgs),
				t.program && (In(t.program) ? (r.program = t.program) : (r.program = Fe(n, t.program))),
				t.args && (r.args = t.args)
			let i = t
			return (
				i.win && (r.win = o.extract(i.win, n)),
				i.winx86 && (r.winx86 = o.extract(i.winx86, n)),
				i.windows && (r.windows = o.extract(i.windows, n)),
				i.osx && (r.osx = o.extract(i.osx, n)),
				i.linux && (r.linux = o.extract(i.linux, n)),
				r
			)
		}
		static platformAdapterExecutable(t, n) {
			let r = Object.create(null)
			n = n.toLowerCase()
			for (let c of t)
				if (c.contributes) {
					let u = c.contributes.debuggers
					u &&
						u.length > 0 &&
						u
							.filter((m) => typeof m.type == "string" && xn(m.type, n))
							.forEach((m) => {
								let f = o.extract(m, c.extensionLocation.fsPath)
								r = fr(r, f, c.isBuiltin)
							})
				}
			let i
			Ie && !process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
				? (i = r.winx86 || r.win || r.windows)
				: Ie
					? (i = r.win || r.windows)
					: st
						? (i = r.osx)
						: Ve && (i = r.linux),
				(i = i || r)
			let s = i.program || r.program,
				a = i.args || r.args,
				l = i.runtime || r.runtime,
				d = i.runtimeArgs || r.runtimeArgs
			if (l)
				return {
					type: "executable",
					command: l,
					args: (d || []).concat(typeof s == "string" ? [s] : []).concat(a || []),
				}
			if (s) return { type: "executable", command: s, args: a || [] }
		}
	}
import * as q2 from "child_process"
function l9(o, e) {
	return new Promise((t, n) => {
		let r = "",
			i = q2.spawn(o, e)
		i.pid &&
			i.stdout.on("data", (s) => {
				r += s.toString()
			}),
			i.on("error", (s) => {
				n(s)
			}),
			i.on("close", (s) => {
				t(r)
			})
	})
}
async function K2(o) {
	if (o)
		if (Ie) {
			let e = await import("@vscode/windows-process-tree")
			return new Promise((t) => {
				e.getProcessTree(o, (n) => {
					t(!!n && n.children.length > 0)
				})
			})
		} else
			return l9("/usr/bin/pgrep", ["-lP", String(o)]).then(
				(e) => {
					let t = e.trim()
					return !(t.length === 0 || t.indexOf(" tmux") >= 0)
				},
				(e) => !0,
			)
	return Promise.resolve(!0)
}
function j2(o, e, t, n, r) {
	o = o.trim().toLowerCase()
	let i
	o.indexOf("powershell") >= 0 || o.indexOf("pwsh") >= 0
		? (i = 1)
		: o.indexOf("cmd.exe") >= 0
			? (i = 0)
			: o.indexOf("bash") >= 0
				? (i = 2)
				: Ie
					? (i = 0)
					: (i = 2)
	let s,
		a = " "
	switch (i) {
		case 1:
			if (
				((s = (l) => (
					(l = l.replace(/\'/g, "''")),
					l.length > 0 && l.charAt(l.length - 1) === "\\" ? `'${l}\\'` : `'${l}'`
				)),
				n)
			) {
				let l = hE(n)
				l && (a += `${l}:; `), (a += `cd ${s(n)}; `)
			}
			if (r)
				for (let l in r) {
					let d = r[l]
					d === null ? (a += `Remove-Item env:${l}; `) : (a += `\${env:${l}}='${d}'; `)
				}
			if (e.length > 0) {
				let l = e.shift(),
					d = t ? l : s(l)
				a += d[0] === "'" ? `& ${d} ` : `${d} `
				for (let c of e) (a += c === "<" || c === ">" || t ? c : s(c)), (a += " ")
			}
			break
		case 0:
			if (
				((s = (l) => (
					(l = l.replace(/\"/g, '""')),
					(l = l.replace(/([><!^&|])/g, "^$1")),
					' "'.split("").some((d) => l.includes(d)) || l.length === 0 ? `"${l}"` : l
				)),
				n)
			) {
				let l = hE(n)
				l && (a += `${l}: && `), (a += `cd ${s(n)} && `)
			}
			if (r) {
				a += 'cmd /C "'
				for (let l in r) {
					let d = r[l]
					d === null
						? (a += `set "${l}=" && `)
						: ((d = d.replace(/[&^|<>]/g, (c) => `^${c}`)), (a += `set "${l}=${d}" && `))
				}
			}
			for (let l of e) (a += l === "<" || l === ">" || t ? l : s(l)), (a += " ")
			r && (a += '"')
			break
		case 2: {
			s = (d) => ((d = d.replace(/(["'\\\$!><#()\[\]*&^| ;{}?`])/g, "\\$1")), d.length === 0 ? '""' : d)
			let l = (d) => (/[^\w@%\/+=,.:^-]/.test(d) ? `'${d.replace(/'/g, "'\\''")}'` : d)
			if ((n && (a += `cd ${s(n)} ; `), r)) {
				a += "/usr/bin/env"
				for (let d in r) {
					let c = r[d]
					c === null ? (a += ` -u ${l(d)}`) : (a += ` ${l(`${d}=${c}`)}`)
				}
				a += " "
			}
			for (let d of e) (a += d === "<" || d === ">" || t ? d : s(d)), (a += " ")
			break
		}
	}
	return a
}
var sm = class extends Nd {
	constructor(t, n, r, i, s, a, l, d, c, u) {
		super(t, n, r, i, l, d, c, u)
		this._terminalService = s
		this._terminalShellIntegrationService = a
		this._integratedTerminalInstances = new OR()
	}
	createDebugAdapter(t, n) {
		return t instanceof jo
			? new ih(this.convertExecutableToDto(t), n.type)
			: t instanceof Go
				? new IC(this.convertServerToDto(t))
				: t instanceof Ti
					? new xC(this.convertPipeServerToDto(t))
					: super.createDebugAdapter(t, n)
	}
	daExecutableFromPackage(t, n) {
		let r = ih.platformAdapterExecutable(n.getAllExtensionDescriptions(), t.type)
		if (r) return new jo(r.command, r.args, r.options)
	}
	createSignService() {
		return new om()
	}
	async $runInTerminal(t, n) {
		if (t.kind === "integrated") {
			this._terminalDisposedListener ||
				(this._terminalDisposedListener = this._register(
					this._terminalService.onDidCloseTerminal((g) => {
						this._integratedTerminalInstances.onTerminalClosed(g)
					}),
				))
			let r = await this._configurationService.getConfigProvider(),
				i = this._terminalService.getDefaultShell(!0),
				s = this._terminalService.getDefaultShellArgs(!0),
				a = t.title || p("debug.terminal.title", "Debug Process"),
				l = JSON.stringify({ shell: i, shellArgs: s }),
				d = await this._integratedTerminalInstances.checkout(l, a),
				c,
				u = !1
			if (d) c = t.cwd
			else {
				let g = { shellPath: i, shellArgs: s, cwd: t.cwd, name: a, iconPath: new Vt("debug") }
				;(u = !0),
					(d = this._terminalService.createTerminalFromOptions(g, {
						isFeatureTerminal: !0,
						forceShellIntegration: !0,
						useShellEnvironment: !0,
					})),
					this._integratedTerminalInstances.insert(d, l)
			}
			d.show(!0)
			let m = await d.processId
			if (u) {
				let g
				;((w) => ((w[(w.DataDebounce = 500)] = "DataDebounce"), (w[(w.MaxDelay = 5e3)] = "MaxDelay")))(
					(g ||= {}),
				)
				let I = new Q()
				await new Promise((C) => {
					let T = I.add(new Hn(C, 500))
					I.add(
						this._terminalService.onDidWriteTerminalData((w) => {
							w.terminal === d && T.schedule()
						}),
					),
						I.add(
							this._terminalShellIntegrationService.onDidChangeTerminalShellIntegration((w) => {
								w.terminal === d && C()
							}),
						),
						I.add(gf(C, 5e3))
				}),
					I.dispose()
			} else if (
				(d.state.isInteractedWith && !d.shellIntegration && (d.sendText(""), await Wt(200)),
				r.getConfiguration("debug.terminal").get("clearBeforeReusing"))
			) {
				let g
				if (
					(i.indexOf("powershell") >= 0 || i.indexOf("pwsh") >= 0 || i.indexOf("cmd.exe") >= 0
						? (g = "cls")
						: i.indexOf("bash") >= 0
							? (g = "clear")
							: Ie
								? (g = "cls")
								: (g = "clear"),
					d.shellIntegration)
				) {
					let I = new Q(),
						C = d.shellIntegration.executeCommand(g)
					await new Promise((T) => {
						I.add(
							this._terminalShellIntegrationService.onDidEndTerminalShellExecution((w) => {
								w.execution === C && T()
							}),
						),
							I.add(gf(T, 500))
					}),
						I.dispose()
				} else d.sendText(g), await Wt(200)
			}
			let f = j2(i, t.args, !!t.argsCanBeInterpretedByShell, c, t.env)
			d.shellIntegration ? d.shellIntegration.executeCommand(f) : d.sendText(f)
			let h = this.onDidTerminateDebugSession((g) => {
				g.id === n && (this._integratedTerminalInstances.free(d), h.dispose())
			})
			return m
		} else if (t.kind === "external") return d9(t, await this._configurationService.getConfigProvider())
		return super.$runInTerminal(t, n)
	}
}
sm = R([S(0, ie), S(1, Sn), S(2, ur), S(3, pn), S(4, er), S(5, em), S(6, Xo), S(7, Yo), S(8, Tn), S(9, zs)], sm)
var sh
function d9(o, e) {
	if (!sh)
		if (Ie) sh = new rh()
		else if (st) sh = new hC()
		else if (Ve) sh = new oh()
		else throw new Error("external terminals not supported on this platform")
	let t = e.getConfiguration("terminal")
	return sh.runInTerminal(o.title, o.cwd, o.args, o.env || {}, t.external || {})
}
var OR = class o {
	constructor() {
		this._terminalInstances = new Map()
	}
	static {
		this.minUseDelay = 1e3
	}
	async checkout(e, t, n = !1) {
		let i = [...this._terminalInstances.entries()].map(([s, a]) =>
			kr(async (l) => {
				if (s.name !== t || (a.lastUsedAt !== -1 && (await K2(await s.processId)))) return null
				let d = Date.now()
				return a.lastUsedAt + o.minUseDelay > d || l.isCancellationRequested
					? null
					: a.config !== e
						? (n && s.dispose(), null)
						: ((a.lastUsedAt = d), s)
			}),
		)
		return await $A(i, (s) => !!s)
	}
	insert(e, t) {
		this._terminalInstances.set(e, { lastUsedAt: Date.now(), config: t })
	}
	free(e) {
		let t = this._terminalInstances.get(e)
		t && (t.lastUsedAt = -1)
	}
	onTerminalClosed(e) {
		this._terminalInstances.delete(e)
	}
}
var G2 = new Rt(() => {
		let o = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" })
		return { collator: o, collatorIsNumeric: o.resolvedOptions().numeric }
	}),
	PAe = new Rt(() => ({ collator: new Intl.Collator(void 0, { numeric: !0 }) })),
	_Ae = new Rt(() => ({ collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" }) }))
function Q2(o, e, t = !1) {
	let n = o || "",
		r = e || "",
		i = G2.value.collator.compare(n, r)
	return G2.value.collatorIsNumeric && i === 0 && n !== r ? (n < r ? -1 : 1) : i
}
function c9(o, e, t = !1) {
	return t || ((o = o && o.toLowerCase()), (e = e && e.toLowerCase())), o === e ? 0 : o < e ? -1 : 1
}
function ah(o, e, t = !1) {
	let n = o.split(at),
		r = e.split(at),
		i = n.length - 1,
		s = r.length - 1,
		a,
		l
	for (let d = 0; ; d++) {
		if (((a = i === d), (l = s === d), a && l)) return Q2(n[d], r[d], t)
		if (a) return -1
		if (l) return 1
		let c = c9(n[d], r[d], t)
		if (c !== 0) return c
	}
}
function CC(o, e, t) {
	let n = o.toLowerCase(),
		r = e.toLowerCase(),
		i = u9(o, e, t)
	if (i) return i
	let s = n.endsWith(t),
		a = r.endsWith(t)
	if (s !== a) return s ? -1 : 1
	let l = Q2(n, r)
	return l !== 0 ? l : n.localeCompare(r)
}
function u9(o, e, t) {
	let n = o.toLowerCase(),
		r = e.toLowerCase(),
		i = n.startsWith(t),
		s = r.startsWith(t)
	if (i !== s) return i ? -1 : 1
	if (i && s) {
		if (n.length < r.length) return -1
		if (n.length > r.length) return 1
	}
	return 0
}
var TC = 0,
	J2 = [TC, []]
function X2(o, e, t, n) {
	if (!o || !e) return J2
	let r = o.length,
		i = e.length
	if (r < i) return J2
	let s = o.toLowerCase()
	return p9(e, t, i, o, s, r, n)
}
function p9(o, e, t, n, r, i, s) {
	let a = [],
		l = []
	for (let m = 0; m < t; m++) {
		let f = m * i,
			h = f - i,
			g = m > 0,
			I = o[m],
			C = e[m]
		for (let T = 0; T < i; T++) {
			let w = T > 0,
				L = f + T,
				A = L - 1,
				J = h + T - 1,
				ne = w ? a[A] : 0,
				oe = g && w ? a[J] : 0,
				Y = g && w ? l[J] : 0,
				j
			!oe && g ? (j = 0) : (j = m9(I, C, n, r, T, Y)),
				j && oe + j >= ne && (s || g || r.startsWith(e, T))
					? ((l[L] = Y + 1), (a[L] = oe + j))
					: ((l[L] = TC), (a[L] = ne))
		}
	}
	let d = [],
		c = t - 1,
		u = i - 1
	for (; c >= 0 && u >= 0; ) {
		let m = c * i + u
		l[m] === TC || (d.push(u), c--), u--
	}
	return [a[t * i - 1], d.reverse()]
}
function m9(o, e, t, n, r, i) {
	let s = 0
	if (!f9(e, n[r])) return s
	if (((s += 1), i > 0 && (s += i * 5), o === t[r] && (s += 1), r === 0)) s += 8
	else {
		let a = g9(t.charCodeAt(r - 1))
		a ? (s += a) : Vc(t.charCodeAt(r)) && i === 0 && (s += 2)
	}
	return s
}
function f9(o, e) {
	return o === e ? !0 : o === "/" || o === "\\" ? e === "/" || e === "\\" : !1
}
function g9(o) {
	switch (o) {
		case 47:
		case 92:
			return 5
		case 95:
		case 45:
		case 46:
		case 32:
		case 39:
		case 34:
		case 58:
			return 4
		default:
			return 0
	}
}
var EC = Object.freeze({ score: 0 }),
	SC = 1 << 18,
	LR = 1 << 17,
	MR = 65536
function h9(o, e, t, n) {
	let r = n.values ? n.values : [n]
	return ar({
		[n.normalized]: {
			values: r.map((s) => ({ value: s.normalized, expectContiguousMatch: s.expectContiguousMatch })),
			label: o,
			description: e,
			allowNonContiguousMatches: t,
		},
	})
}
function Y2(o, e, t, n, r) {
	if (!o || !e.normalized) return EC
	let i = n.getItemLabel(o)
	if (!i) return EC
	let s = n.getItemDescription(o),
		a = h9(i, s, t, e),
		l = r[a]
	if (l) return l
	let d = v9(i, s, n.getItemPath(o), e, t)
	return (r[a] = d), d
}
function v9(o, e, t, n, r) {
	let i = !t || !n.containsPathSeparator
	return t && (Ve ? n.pathNormalized === t : xn(n.pathNormalized, t))
		? {
				score: SC,
				labelMatch: [{ start: 0, end: o.length }],
				descriptionMatch: e ? [{ start: 0, end: e.length }] : void 0,
			}
		: n.values && n.values.length > 1
			? b9(o, e, t, n.values, i, r)
			: oN(o, e, t, n, i, r)
}
function b9(o, e, t, n, r, i) {
	let s = 0,
		a = [],
		l = []
	for (let d of n) {
		let { score: c, labelMatch: u, descriptionMatch: m } = oN(o, e, t, d, r, i)
		if (c === TC) return EC
		;(s += c), u && a.push(...u), m && l.push(...m)
	}
	return { score: s, labelMatch: eN(a), descriptionMatch: eN(l) }
}
function oN(o, e, t, n, r, i) {
	if (r || !e) {
		let [s, a] = X2(o, n.normalized, n.normalizedLowercase, i && !n.expectContiguousMatch)
		if (s) {
			let l = Cb(n.normalized, o),
				d
			if (l) {
				d = LR
				let c = Math.round((n.normalized.length / o.length) * 100)
				d += c
			} else d = MR
			return { score: d + s, labelMatch: l || Z2(a) }
		}
	}
	if (e) {
		let s = e
		t && (s = `${e}${at}`)
		let a = s.length,
			l = `${s}${o}`,
			[d, c] = X2(l, n.normalized, n.normalizedLowercase, i && !n.expectContiguousMatch)
		if (d) {
			let u = Z2(c),
				m = [],
				f = []
			return (
				u.forEach((h) => {
					h.start < a && h.end > a
						? (m.push({ start: 0, end: h.end - a }), f.push({ start: h.start, end: a }))
						: h.start >= a
							? m.push({ start: h.start - a, end: h.end - a })
							: f.push(h)
				}),
				{ score: d, labelMatch: m, descriptionMatch: f }
			)
		}
	}
	return EC
}
function Z2(o) {
	let e = []
	if (!o) return e
	let t
	for (let n of o) t && t.end === n ? (t.end += 1) : ((t = { start: n, end: n + 1 }), e.push(t))
	return e
}
function eN(o) {
	let e = o.sort((r, i) => r.start - i.start),
		t = [],
		n
	for (let r of e)
		!n || !y9(n, r)
			? ((n = r), t.push(r))
			: ((n.start = Math.min(n.start, r.start)), (n.end = Math.max(n.end, r.end)))
	return t
}
function y9(o, e) {
	return !(o.end < e.start || e.end < o.start)
}
function iN(o, e, t, n, r, i) {
	let s = Y2(o, t, n, r, i),
		a = Y2(e, t, n, r, i),
		l = s.score,
		d = a.score
	if ((l === SC || d === SC) && l !== d) return l === SC ? -1 : 1
	if (l > MR || d > MR) {
		if (l !== d) return l > d ? -1 : 1
		if (l < LR && d < LR) {
			let I = I9(s.labelMatch, a.labelMatch)
			if (I !== 0) return I
		}
		let h = r.getItemLabel(o) || "",
			g = r.getItemLabel(e) || ""
		if (h.length !== g.length) return h.length - g.length
	}
	if (l !== d) return l > d ? -1 : 1
	let c = Array.isArray(s.labelMatch) && s.labelMatch.length > 0,
		u = Array.isArray(a.labelMatch) && a.labelMatch.length > 0
	if (c && !u) return -1
	if (u && !c) return 1
	let m = tN(o, s, r),
		f = tN(e, a, r)
	return m && f && m !== f ? (f > m ? -1 : 1) : x9(o, e, t, r)
}
function tN(o, e, t) {
	let n = -1,
		r = -1
	if (
		(e.descriptionMatch && e.descriptionMatch.length
			? (n = e.descriptionMatch[0].start)
			: e.labelMatch && e.labelMatch.length && (n = e.labelMatch[0].start),
		e.labelMatch && e.labelMatch.length)
	) {
		if (((r = e.labelMatch[e.labelMatch.length - 1].end), e.descriptionMatch && e.descriptionMatch.length)) {
			let i = t.getItemDescription(o)
			i && (r += i.length)
		}
	} else
		e.descriptionMatch && e.descriptionMatch.length && (r = e.descriptionMatch[e.descriptionMatch.length - 1].end)
	return r - n
}
function I9(o, e) {
	if ((!o && !e) || ((!o || !o.length) && (!e || !e.length))) return 0
	if (!e || !e.length) return -1
	if (!o || !o.length) return 1
	let t = o[0].start,
		r = o[o.length - 1].end - t,
		i = e[0].start,
		a = e[e.length - 1].end - i
	return r === a ? 0 : a < r ? 1 : -1
}
function x9(o, e, t, n) {
	let r = n.getItemLabel(o) || "",
		i = n.getItemLabel(e) || "",
		s = n.getItemDescription(o),
		a = n.getItemDescription(e),
		l = r.length + (s ? s.length : 0),
		d = i.length + (a ? a.length : 0)
	if (l !== d) return l - d
	let c = n.getItemPath(o),
		u = n.getItemPath(e)
	return c && u && c.length !== u.length
		? c.length - u.length
		: r !== i
			? CC(r, i, t.normalized)
			: s && a && s !== a
				? CC(s, a, t.normalized)
				: c && u && c !== u
					? CC(c, u, t.normalized)
					: 0
}
function nN(o) {
	return o.startsWith('"') && o.endsWith('"')
}
var C9 = " "
function lh(o) {
	typeof o != "string" && (o = "")
	let e = o.toLowerCase(),
		{ pathNormalized: t, normalized: n, normalizedLowercase: r } = rN(o),
		i = t.indexOf(at) >= 0,
		s = nN(o),
		a,
		l = o.split(C9)
	if (l.length > 1)
		for (let d of l) {
			let c = nN(d),
				{ pathNormalized: u, normalized: m, normalizedLowercase: f } = rN(d)
			m &&
				(a || (a = []),
				a.push({
					original: d,
					originalLowercase: d.toLowerCase(),
					pathNormalized: u,
					normalized: m,
					normalizedLowercase: f,
					expectContiguousMatch: c,
				}))
		}
	return {
		original: o,
		originalLowercase: e,
		pathNormalized: t,
		normalized: n,
		normalizedLowercase: r,
		values: a,
		containsPathSeparator: i,
		expectContiguousMatch: s,
	}
}
function rN(o) {
	let e
	Ie ? (e = o.replace(/\//g, at)) : (e = o.replace(/\\/g, at))
	let t = hA(e).replace(/\s|"/g, "")
	return { pathNormalized: e, normalized: t, normalizedLowercase: t.toLowerCase() }
}
import * as pN from "child_process"
import * as lm from "fs"
import { StringDecoder as uN } from "string_decoder"
import * as lN from "child_process"
function am(o) {
	return o.startsWith("**") || o.startsWith("/") ? o : `/${o}`
}
function sN(o) {
	return new rp(o.start.line, o.start.character, o.end.line, o.end.character)
}
function FR(o) {
	return new tp(o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn)
}
var Bd = class {
	constructor(e, t) {
		this.prefix = e
		this.logService = t
	}
	appendLine(e) {
		this.logService.debug(`${this.prefix}#search`, e)
	}
}
Bd = R([S(1, te)], Bd)
import { rgPath as S9 } from "@vscode/ripgrep"
var aN = S9.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked")
function dN(o, e, t, n, r) {
	let i = T9(o, e, t, n, r),
		s = e.folder.fsPath
	return {
		cmd: lN.spawn(aN, i.args, { cwd: s }),
		rgDiskPath: aN,
		siblingClauses: i.siblingClauses,
		rgArgs: i,
		cwd: s,
	}
}
function T9(o, e, t, n, r) {
	let i = ["--files", "--hidden", "--case-sensitive", "--no-require-git"]
	w9([e], t, !1).forEach((a) => {
		let l = am(a)
		if ((i.push("-g", l), st)) {
			let d = LE(l)
			d !== l && i.push("-g", d)
		}
	})
	let s = E9([e], n, void 0, !1)
	return (
		s.globArgs.forEach((a) => {
			let l = `!${am(a)}`
			if ((i.push("-g", l), st)) {
				let d = LE(l)
				d !== l && i.push("-g", d)
			}
		}),
		e.disregardIgnoreFiles !== !1
			? i.push("--no-ignore")
			: e.disregardParentIgnoreFiles !== !1 && i.push("--no-ignore-parent"),
		e.ignoreSymlinks || i.push("--follow"),
		o.exists && i.push("--quiet"),
		r && i.push("--threads", `${r}`),
		i.push("--no-config"),
		e.disregardGlobalIgnoreFiles && i.push("--no-ignore-global"),
		{ args: i, siblingClauses: s.siblingClauses }
	)
}
function E9(o, e, t, n = !0) {
	let r = [],
		i = {}
	return (
		o.forEach((s) => {
			let a = Object.assign({}, s.excludePattern || {}, e || {}),
				l = cN(a, n ? s.folder.fsPath : void 0, t)
			r.push(...l.globArgs), l.siblingClauses && (i = Object.assign(i, l.siblingClauses))
		}),
		{ globArgs: r, siblingClauses: i }
	)
}
function w9(o, e, t = !0) {
	let n = []
	return (
		o.forEach((r) => {
			let i = Object.assign({}, e || {}, r.includePattern || {}),
				s = cN(i, t ? r.folder.fsPath : void 0)
			n.push(...s.globArgs)
		}),
		n
	)
}
function cN(o, e, t) {
	let n = [],
		r = {}
	return (
		Object.keys(o).forEach((i) => {
			if ((t && t.has(i)) || !i) return
			let s = o[i]
			;(i = _9(e ? P9(e, i) : i)),
				i.startsWith("\\\\") ? (i = "\\\\" + i.substr(2).replace(/\\/g, "/")) : (i = i.replace(/\\/g, "/")),
				typeof s == "boolean" && s
					? (i.startsWith("\\\\") && (i += "**"), n.push(D9(i)))
					: s && s.when && (r[i] = s)
		}),
		{ globArgs: n, siblingClauses: r }
	)
}
function P9(o, e) {
	return In(e) ? e : Fe(o, e)
}
function _9(o) {
	return (o = Dr(o, "\\")), Dr(o, "/")
}
function D9(o) {
	return af(o).toLowerCase() === "c:/" ? o.replace(/^c:[/\\]/i, "/") : o
}
var wC = new Set()
process.on("exit", () => {
	wC.forEach((o) => o())
})
var NR = class {
		constructor(e) {
			this.normalizedFilePatternLowercase = null
			this.maxFilesize = null
			this.isCanceled = !1
			this.fileWalkSW = null
			this.cmdSW = null
			this.cmdResultCount = 0
			;(this.config = e),
				(this.filePattern = e.filePattern || ""),
				(this.includePattern = e.includePattern && Xn(e.includePattern)),
				(this.maxResults = e.maxResults || null),
				(this.exists = !!e.exists),
				(this.walkedPaths = Object.create(null)),
				(this.resultCount = 0),
				(this.isLimitHit = !1),
				(this.directoriesWalked = 0),
				(this.filesWalked = 0),
				(this.errors = []),
				this.filePattern &&
					(this.normalizedFilePatternLowercase = e.shouldGlobMatchFilePattern
						? null
						: lh(this.filePattern).normalizedLowercase),
				(this.globalExcludePattern = e.excludePattern && Xn(e.excludePattern)),
				(this.folderExcludePatterns = new Map()),
				e.folderQueries.forEach((t) => {
					let n = {}
					t.excludePattern?.forEach((i) => {
						Object.assign(n, i.pattern || {}, this.config.excludePattern || {})
					}),
						t.excludePattern?.length || Object.assign(n, this.config.excludePattern || {})
					let r = t.folder.fsPath
					e.folderQueries
						.map((i) => i.folder.fsPath)
						.filter((i) => i !== r)
						.forEach((i) => {
							zr(i, r) && (n[Oo(r, i)] = !0)
						}),
						this.folderExcludePatterns.set(r, new UR(n, r))
				})
		}
		cancel() {
			;(this.isCanceled = !0), wC.forEach((e) => e())
		}
		walk(e, t, n, r, i, s) {
			if (((this.fileWalkSW = zt.create(!1)), this.isCanceled)) return s(null, this.isLimitHit)
			t.forEach((a) => {
				let l = Ze(a.fsPath)
				;(this.globalExcludePattern && this.globalExcludePattern(a.fsPath, l)) ||
					this.matchFile(r, { relativePath: a.fsPath, searchPath: void 0 })
			}),
				(this.cmdSW = zt.create(!1)),
				this.parallel(
					e,
					(a, l) => {
						this.call(this.cmdTraversal, this, a, n, r, i, (d) => {
							if (d) {
								let c = Jn(d)
								console.error(c), this.errors.push(c), l(d, void 0)
							} else l(null, void 0)
						})
					},
					(a, l) => {
						this.fileWalkSW.stop()
						let d = a ? Ye(a)[0] : null
						s(d, this.isLimitHit)
					},
				)
		}
		parallel(e, t, n) {
			let r = new Array(e.length),
				i = new Array(e.length),
				s = !1,
				a = 0
			if (e.length === 0) return n(null, [])
			e.forEach((l, d) => {
				t(l, (c, u) => {
					if ((c ? ((s = !0), (r[d] = null), (i[d] = c)) : ((r[d] = u), (i[d] = null)), ++a === e.length))
						return n(s ? i : null, r)
				})
			})
		}
		call(e, t, ...n) {
			try {
				e.apply(t, n)
			} catch (r) {
				n[n.length - 1](r)
			}
		}
		cmdTraversal(e, t, n, r, i) {
			let s = e.folder.fsPath,
				a = st,
				l = () => f && f.kill()
			wC.add(l)
			let d = (C) => {
					wC.delete(l), (d = () => {}), i(C)
				},
				c = "",
				u = this.initDirectoryTree(),
				m = dN(
					this.config,
					e,
					this.config.includePattern,
					this.folderExcludePatterns.get(e.folder.fsPath).expression,
					t,
				),
				f = m.cmd,
				h = !Object.keys(m.siblingClauses).length,
				g = m.rgArgs.args.map((C) => (C.match(/^-/) ? C : `'${C}'`)).join(" "),
				I = `${m.rgDiskPath} ${g}
 - cwd: ${m.cwd}`
			m.rgArgs.siblingClauses &&
				(I += `
 - Sibling clauses: ${JSON.stringify(m.rgArgs.siblingClauses)}`),
				r({ message: I }),
				(this.cmdResultCount = 0),
				this.collectStdout(f, "utf8", r, (C, T, w) => {
					if (C) {
						d(C)
						return
					}
					if (this.isLimitHit) {
						d()
						return
					}
					let A = (c + (a ? Ll(T || "") : T)).split(`
`)
					if (w) {
						let J = A.length
						;(A[J - 1] = A[J - 1].trim()), A[J - 1] || A.pop()
					} else c = A.pop() || ""
					if (
						A.length &&
						A[0].indexOf(`
`) !== -1
					) {
						d(new Error("Splitting up files failed"))
						return
					}
					if (((this.cmdResultCount += A.length), h)) {
						for (let J of A)
							if (
								(this.matchFile(n, { base: s, relativePath: J, searchPath: this.getSearchPath(e, J) }),
								this.isLimitHit)
							) {
								l()
								break
							}
						;(w || this.isLimitHit) && d()
						return
					}
					this.addDirectoryEntries(e, u, s, A, n), w && (this.matchDirectoryTree(u, s, n), d())
				})
		}
		spawnFindCmd(e) {
			let t = this.folderExcludePatterns.get(e.folder.fsPath),
				n = t.getBasenameTerms(),
				r = t.getPathTerms(),
				i = ["-L", "."]
			if (n.length || r.length) {
				i.push("-not", "(", "(")
				for (let s of n) i.push("-name", s), i.push("-o")
				for (let s of r) i.push("-path", s), i.push("-o")
				i.pop(), i.push(")", "-prune", ")")
			}
			return i.push("-type", "f"), pN.spawn("find", i, { cwd: e.folder.fsPath })
		}
		readStdout(e, t, n) {
			let r = ""
			this.collectStdout(
				e,
				t,
				() => {},
				(i, s, a) => {
					if (i) {
						n(i)
						return
					}
					;(r += s), a && n(null, r)
				},
			)
		}
		collectStdout(e, t, n, r) {
			let i = (l, d, c) => {
					;(l || c) && ((i = () => {}), this.cmdSW?.stop()), r(l, d, c)
				},
				s = !1
			e.stdout
				? (this.forwardData(e.stdout, t, i), e.stdout.once("data", () => (s = !0)))
				: n({ message: "stdout is null" })
			let a
			e.stderr ? (a = this.collectData(e.stderr)) : n({ message: "stderr is null" }),
				e.on("error", (l) => {
					i(l)
				}),
				e.on("close", (l) => {
					let d
					!s && (d = this.decodeData(a, t)) && k9(d)
						? i(new Error(`command failed with error code ${l}: ${this.decodeData(a, t)}`))
						: (this.exists && l === 0 && (this.isLimitHit = !0), i(null, "", !0))
				})
		}
		forwardData(e, t, n) {
			let r = new uN(t)
			return (
				e.on("data", (i) => {
					n(null, r.write(i))
				}),
				r
			)
		}
		collectData(e) {
			let t = []
			return (
				e.on("data", (n) => {
					t.push(n)
				}),
				t
			)
		}
		decodeData(e, t) {
			let n = new uN(t)
			return e.map((r) => n.write(r)).join("")
		}
		initDirectoryTree() {
			let e = { rootEntries: [], pathToEntries: Object.create(null) }
			return (e.pathToEntries["."] = e.rootEntries), e
		}
		addDirectoryEntries(e, { pathToEntries: t }, n, r, i) {
			r.indexOf(this.filePattern) !== -1 &&
				this.matchFile(i, {
					base: n,
					relativePath: this.filePattern,
					searchPath: this.getSearchPath(e, this.filePattern),
				})
			let s = (a) => {
				let l = Ze(a),
					d = Qt(a),
					c = t[d]
				c || ((c = t[d] = []), s(d)),
					c.push({ base: n, relativePath: a, basename: l, searchPath: this.getSearchPath(e, a) })
			}
			r.forEach(s)
		}
		matchDirectoryTree({ rootEntries: e, pathToEntries: t }, n, r) {
			let i = this,
				s = this.folderExcludePatterns.get(n),
				a = this.filePattern
			function l(d) {
				i.directoriesWalked++
				let c = Mg(() => d.map((u) => u.basename))
				for (let u = 0, m = d.length; u < m; u++) {
					let f = d[u],
						{ relativePath: h, basename: g } = f
					if (s.test(h, g, a !== g ? c : void 0)) continue
					let I = t[h]
					if (I) l(I)
					else {
						if ((i.filesWalked++, h === a)) continue
						i.matchFile(r, f)
					}
					if (i.isLimitHit) break
				}
			}
			l(e)
		}
		getStats() {
			return {
				cmdTime: this.cmdSW.elapsed(),
				fileWalkTime: this.fileWalkSW.elapsed(),
				directoriesWalked: this.directoriesWalked,
				filesWalked: this.filesWalked,
				cmdResultCount: this.cmdResultCount,
			}
		}
		doWalk(e, t, n, r, i) {
			let s = e.folder,
				a = Mg(() => n)
			this.parallel(
				n,
				(l, d) => {
					if (this.isCanceled || this.isLimitHit) return d(null)
					let c = t ? [t, l].join(at) : l
					if (
						this.folderExcludePatterns
							.get(e.folder.fsPath)
							.test(c, l, this.config.filePattern !== l ? a : void 0)
					)
						return d(null)
					let u = [s.fsPath, c].join(at)
					lm.lstat(u, (m, f) => {
						if (m || this.isCanceled || this.isLimitHit) return d(null)
						this.statLinkIfNeeded(u, f, (h, g) =>
							h || this.isCanceled || this.isLimitHit
								? d(null)
								: g.isDirectory()
									? (this.directoriesWalked++,
										this.realPathIfNeeded(u, f, (I, C) =>
											I ||
											this.isCanceled ||
											this.isLimitHit ||
											((C = C || ""), this.walkedPaths[C])
												? d(null)
												: ((this.walkedPaths[C] = !0),
													Qe.readdir(u).then(
														(T) => {
															if (this.isCanceled || this.isLimitHit) return d(null)
															this.doWalk(e, c, T, r, (w) => d(w || null))
														},
														(T) => {
															d(null)
														},
													)),
										))
									: (this.filesWalked++,
										c === this.filePattern ||
											(this.maxFilesize && fn(g.size) && g.size > this.maxFilesize) ||
											this.matchFile(r, {
												base: s.fsPath,
												relativePath: c,
												searchPath: this.getSearchPath(e, c),
											}),
										d(null, void 0)),
						)
					})
				},
				(l) => {
					let d = l && Ye(l)
					return i(d && d.length > 0 ? d[0] : void 0)
				},
			)
		}
		matchFile(e, t) {
			this.isFileMatch(t) &&
				(!this.includePattern || this.includePattern(t.relativePath, Ze(t.relativePath))) &&
				(this.resultCount++,
				(this.exists || (this.maxResults && this.resultCount > this.maxResults)) && (this.isLimitHit = !0),
				this.isLimitHit || e(t))
		}
		isFileMatch(e) {
			if (this.filePattern) {
				if (this.filePattern === "*") return !0
				if (this.normalizedFilePatternLowercase) return Lg(e, this.normalizedFilePatternLowercase)
				if (this.filePattern) return Lg(e, this.filePattern, !1)
			}
			return !0
		}
		statLinkIfNeeded(e, t, n) {
			return t.isSymbolicLink() ? lm.stat(e, n) : n(null, t)
		}
		realPathIfNeeded(e, t, n) {
			return t.isSymbolicLink() ? lm.realpath(e, (r, i) => (r ? n(r) : n(null, i))) : n(null, e)
		}
		getSearchPath(e, t) {
			return e.folderName ? Fe(e.folderName, t) : t
		}
	},
	dh = class {
		constructor(e, t) {
			;(this.folderQueries = e.folderQueries),
				(this.extraFiles = e.extraFileResources || []),
				(this.numThreads = t),
				(this.walker = new NR(e))
		}
		search(e, t, n) {
			this.walker.walk(this.folderQueries, this.extraFiles, this.numThreads, e, t, (r, i) => {
				n(r, { limitHit: i, stats: this.walker.getStats(), messages: [] })
			})
		}
		cancel() {
			this.walker.cancel()
		}
	},
	UR = class {
		constructor(e, t) {
			this.expression = e
			this.root = t
			this.init(e)
		}
		init(e) {
			let t, n
			Object.keys(e)
				.filter((r) => e[r])
				.forEach((r) => {
					In(r) ? ((t = t || JP()), (t[r] = e[r])) : ((n = n || JP()), (n[r] = e[r]))
				}),
				(this.absoluteParsedExpr = t && Xn(t, { trimForExclusions: !0 })),
				(this.relativeParsedExpr = n && Xn(n, { trimForExclusions: !0 }))
		}
		test(e, t, n) {
			return (
				(this.relativeParsedExpr && this.relativeParsedExpr(e, t, n)) ||
				(this.absoluteParsedExpr && this.absoluteParsedExpr(Fe(this.root, e), t, n))
			)
		}
		getBasenameTerms() {
			let e = []
			return (
				this.absoluteParsedExpr && e.push(...YP(this.absoluteParsedExpr)),
				this.relativeParsedExpr && e.push(...YP(this.relativeParsedExpr)),
				e
			)
		}
		getPathTerms() {
			let e = []
			return (
				this.absoluteParsedExpr && e.push(...ZP(this.absoluteParsedExpr)),
				this.relativeParsedExpr && e.push(...ZP(this.relativeParsedExpr)),
				e
			)
		}
	}
function k9(o) {
	let e = o.trim().split(`
`),
		t = e[0].trim()
	if (t.startsWith("Error parsing regex")) return t
	if (t.startsWith("regex parse error")) return SA(e[e.length - 1].trim())
	if (t.startsWith("error parsing glob") || t.startsWith("unsupported encoding"))
		return t.charAt(0).toUpperCase() + t.substr(1)
	if (t === "Literal '\\n' not allowed.") return "Literal '\\n' currently not supported"
	if (t.startsWith("Literal ")) return t
}
import * as hN from "child_process"
import { EventEmitter as R9 } from "events"
import { StringDecoder as A9 } from "string_decoder"
import { RegExpParser as O9, RegExpVisitor as L9 } from "vscode-regexpp"
import { rgPath as M9 } from "@vscode/ripgrep"
var mN = M9.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked"),
	dm = class {
		constructor(e, t) {
			this.outputChannel = e
			this._numThreads = t
		}
		provideTextSearchResults(e, t, n, r) {
			return Promise.all(
				t.folderOptions.map((i) => {
					let s = {
						folderOptions: i,
						numThreads: this._numThreads,
						maxResults: t.maxResults,
						previewOptions: t.previewOptions,
						maxFileSize: t.maxFileSize,
						surroundingContext: t.surroundingContext,
					}
					return this.provideTextSearchResultsWithRgOptions(e, s, n, r)
				}),
			).then((i) => ({ limitHit: i.some((a) => !!a && a.limitHit) }))
		}
		provideTextSearchResultsWithRgOptions(e, t, n, r) {
			return (
				this.outputChannel.appendLine(
					`provideTextSearchResults ${e.pattern}, ${JSON.stringify({ ...t, folder: t.folderOptions.folder.toString() })}`,
				),
				new Promise((i, s) => {
					r.onCancellationRequested(() => g())
					let a = { ...t, numThreads: this._numThreads },
						l = U9(e, a),
						d = t.folderOptions.folder.fsPath,
						c = l.map((L) => (L.match(/^-/) ? L : `'${L}'`)).join(" ")
					this.outputChannel.appendLine(`${mN} ${c}
 - cwd: ${d}`)
					let u = hN.spawn(mN, l, { cwd: d })
					u.on("error", (L) => {
						console.error(L),
							this.outputChannel.appendLine("Error: " + (L && L.message)),
							s(ak(new Oi(L && L.message, 5)))
					})
					let m = !1,
						f = new HR(t.maxResults ?? Za, t.folderOptions.folder, CR(t.previewOptions))
					f.on("result", (L) => {
						;(m = !0), (C = ""), n.report(L)
					})
					let h = !1,
						g = () => {
							;(h = !0), u?.kill(), f?.cancel()
						},
						I = !1
					f.on("hitLimit", () => {
						;(I = !0), g()
					})
					let C = ""
					u.stdout.on("data", (L) => {
						f.handleData(L), m || (C += L)
					})
					let T = !1
					u.stdout.once("data", () => (T = !0))
					let w = ""
					u.stderr.on("data", (L) => {
						let A = L.toString()
						this.outputChannel.appendLine(A), w.length + A.length < 1e6 && (w += A)
					}),
						u.on("close", () => {
							if (
								(this.outputChannel.appendLine(T ? "Got data from stdout" : "No data from stdout"),
								this.outputChannel.appendLine(m ? "Got result from parser" : "No result from parser"),
								C && this.outputChannel.appendLine(`Got data without result: ${C}`),
								this.outputChannel.appendLine(""),
								h)
							)
								i({ limitHit: I })
							else {
								f.flush(), (u = null)
								let L
								w && !T && (L = F9(w)) ? s(ak(new Oi(L.message, L.code))) : i({ limitHit: I })
							}
						})
				})
			)
		}
	}
function F9(o) {
	let e = o.split(`
`),
		t = e[0].trim()
	if (e.some((r) => r.startsWith("regex parse error"))) return new Oi(N9(e), 2)
	let n = t.match(/grep config error: unknown encoding: (.*)/)
	if (n) return new Oi(`Unknown encoding: ${n[1]}`, 1)
	if (t.startsWith("error parsing glob")) return new Oi(t.charAt(0).toUpperCase() + t.substr(1), 3)
	if (t.startsWith("the literal")) return new Oi(t.charAt(0).toUpperCase() + t.substr(1), 4)
	if (t.startsWith("PCRE2: error compiling pattern")) return new Oi(t, 2)
}
function N9(o) {
	let e = ["Regex parse error"],
		t = o.filter((n) => n.startsWith("PCRE2:"))
	if (t.length >= 1) {
		let n = t[0].replace("PCRE2:", "")
		if (n.indexOf(":") !== -1 && n.split(":").length >= 2) {
			let r = n.split(":")[1]
			e.push(":" + r)
		}
	}
	return e.join("")
}
var HR = class extends R9 {
	constructor(t, n, r) {
		super()
		this.maxResults = t
		this.root = n
		this.previewOptions = r
		this.remainder = ""
		this.isDone = !1
		this.hitLimit = !1
		this.numResults = 0
		this.stringDecoder = new A9()
	}
	cancel() {
		this.isDone = !0
	}
	flush() {
		this.handleDecodedData(this.stringDecoder.end())
	}
	on(t, n) {
		return super.on(t, n), this
	}
	handleData(t) {
		if (this.isDone) return
		let n = typeof t == "string" ? t : this.stringDecoder.write(t)
		this.handleDecodedData(n)
	}
	handleDecodedData(t) {
		let n = t.indexOf(`
`),
			r = this.remainder + t
		if (n >= 0) n += this.remainder.length
		else {
			this.remainder = r
			return
		}
		let i = 0
		for (; n >= 0; )
			this.handleLine(r.substring(i, n).trim()),
				(i = n + 1),
				(n = r.indexOf(
					`
`,
					i,
				))
		this.remainder = r.substring(i)
	}
	handleLine(t) {
		if (this.isDone || !t) return
		let n
		try {
			n = JSON.parse(t)
		} catch {
			throw new Error(`malformed line from rg: ${t}`)
		}
		if (n.type === "match") {
			let r = ch(n.data.path),
				i = y.joinPath(this.root, r),
				s = this.createTextSearchMatch(n.data, i)
			this.onResult(s), this.hitLimit && (this.cancel(), this.emit("hitLimit"))
		} else if (n.type === "context") {
			let r = ch(n.data.path),
				i = y.joinPath(this.root, r)
			this.createTextSearchContexts(n.data, i).forEach((a) => this.onResult(a))
		}
	}
	createTextSearchMatch(t, n) {
		let r = t.line_number - 1,
			i = ch(t.lines),
			s = Buffer.from(i),
			a = 0,
			l = 0,
			d = r
		t.submatches.length === 0 &&
			t.submatches.push(
				i.length ? { start: 0, end: 1, match: { text: i[0] } } : { start: 0, end: 0, match: { text: "" } },
			)
		let c = Ye(
				t.submatches.map((f, h) => {
					if (this.hitLimit) return null
					this.numResults++, this.numResults >= this.maxResults && (this.hitLimit = !0)
					let g = ch(f.match),
						I = s.slice(a, f.start).toString(),
						C = fN(I),
						T = C.numLines > 0 ? C.lastLineLength : C.lastLineLength + l,
						w = fN(g),
						L = C.numLines + d,
						A = w.numLines + L,
						J = w.numLines > 0 ? w.lastLineLength : w.lastLineLength + T
					return (a = f.end), (l = J), (d = A), new tp(L, T, A, J)
				}),
			),
			u = El(c, sN),
			m = new np(i, u, this.previewOptions)
		return new cr(
			n,
			m.rangeLocations.map((f) => ({ sourceRange: FR(f.source), previewRange: FR(f.preview) })),
			m.previewText,
		)
	}
	createTextSearchContexts(t, n) {
		let r = ch(t.lines),
			i = t.line_number
		return r
			.replace(/\r?\n$/, "")
			.split(
				`
`,
			)
			.map((s, a) => new Ai(n, s, i + a))
	}
	onResult(t) {
		this.emit("result", t)
	}
}
function ch(o) {
	return o.bytes ? Buffer.from(o.bytes, "base64").toString() : o.text
}
function fN(o) {
	let e = /\n/g,
		t = 0,
		n = -1,
		r
	for (; (r = e.exec(o)); ) t++, (n = r.index)
	let i = n >= 0 ? o.length - n - 1 : o.length
	return { numLines: t, lastLineLength: i }
}
function U9(o, e) {
	let t = ["--hidden", "--no-require-git"]
	t.push(o.isCaseSensitive ? "--case-sensitive" : "--ignore-case")
	let { doubleStarIncludes: n, otherIncludes: r } = sc(e.folderOptions.includes, (s) =>
		s.startsWith("**") ? "doubleStarIncludes" : "otherIncludes",
	)
	if (r && r.length) {
		let s = new Set()
		r.forEach((a) => {
			s.add(a)
		}),
			t.push("-g", "!*"),
			s.forEach((a) => {
				H9(a)
					.map(am)
					.forEach((l) => {
						t.push("-g", l)
					})
			})
	}
	n &&
		n.length &&
		n.forEach((s) => {
			t.push("-g", s)
		}),
		e.folderOptions.excludes
			.map((s) => (typeof s == "string" ? s : s.pattern))
			.map(am)
			.forEach((s) => t.push("-g", `!${s}`)),
		e.maxFileSize && t.push("--max-filesize", e.maxFileSize + ""),
		e.folderOptions.useIgnoreFiles.local
			? e.folderOptions.useIgnoreFiles.parent || t.push("--no-ignore-parent")
			: t.push("--no-ignore"),
		e.folderOptions.followSymlinks && t.push("--follow"),
		e.folderOptions.encoding &&
			e.folderOptions.encoding !== "utf8" &&
			t.push("--encoding", e.folderOptions.encoding),
		e.numThreads && t.push("--threads", `${e.numThreads}`),
		o.pattern === "--" && ((o.isRegExp = !0), (o.pattern = "\\-\\-")),
		o.isMultiline && !o.isRegExp && ((o.pattern = _r(o.pattern)), (o.isRegExp = !0)),
		e.usePCRE2 && t.push("--pcre2"),
		t.push("--crlf"),
		o.isRegExp && ((o.pattern = W9(o.pattern)), t.push("--engine", "auto"))
	let i
	if (o.isWordMatch) {
		let a = bv(o.pattern, !!o.isRegExp, { wholeWord: o.isWordMatch }).source.replace(/\\\//g, "/")
		t.push("--regexp", a)
	} else if (o.isRegExp) {
		let s = V9(o.pattern)
		;(s = B9(s)), t.push("--regexp", s)
	} else (i = o.pattern), t.push("--fixed-strings")
	return (
		t.push("--no-config"),
		e.folderOptions.useIgnoreFiles.global || t.push("--no-ignore-global"),
		t.push("--json"),
		o.isMultiline && t.push("--multiline"),
		e.surroundingContext &&
			(t.push("--before-context", e.surroundingContext + ""),
			t.push("--after-context", e.surroundingContext + "")),
		t.push("--"),
		i && t.push(i),
		t.push("."),
		t
	)
}
function H9(o) {
	return vN(o).flatMap((t) => {
		let n = rd(t, "/")
		return n.map((r, i) => n.slice(0, i + 1).join("/"))
	})
}
function W9(o) {
	let e = /((?:[^\\]|^)(?:\\\\)*)\\u([a-z0-9]{4})/gi
	for (; o.match(e); ) o = o.replace(e, "$1\\x{$2}")
	let t = /((?:[^\\]|^)(?:\\\\)*)\\u\{([a-z0-9]{4})\}/gi
	for (; o.match(t); ) o = o.replace(t, "$1\\x{$2}")
	return o
}
var gN = (o) => o.type === "Assertion" && o.kind === "lookbehind"
function V9(o) {
	let e
	try {
		e = new O9().parsePattern(o)
	} catch {
		return o
	}
	let t = "",
		n = 0,
		r = (a, l, d) => {
			;(t += o.slice(n, a) + d), (n = l)
		},
		i = []
	return (
		new L9({
			onCharacterEnter(a) {
				if (a.raw !== "\\n") return
				let l = i[0]
				if (!l) r(a.start, a.end, "\\r?\\n")
				else if (!i.some(gN))
					if (l.type === "CharacterClass")
						if (l.negate) {
							let d = o.slice(l.start + 2, a.start) + o.slice(a.end, l.end - 1)
							l.parent?.type === "Quantifier"
								? r(l.start, l.end, d ? `[^${d}]` : ".")
								: r(l.start, l.end, "(?!\\r?\\n" + (d ? `|[${d}]` : "") + ")")
						} else {
							let d = o.slice(l.start + 1, a.start) + o.slice(a.end, l.end - 1)
							r(l.start, l.end, d === "" ? "\\r?\\n" : `(?:[${d}]|\\r?\\n)`)
						}
					else l.type === "Quantifier" && r(a.start, a.end, "(?:\\r?\\n)")
			},
			onQuantifierEnter(a) {
				i.unshift(a)
			},
			onQuantifierLeave() {
				i.shift()
			},
			onCharacterClassRangeEnter(a) {
				i.unshift(a)
			},
			onCharacterClassRangeLeave() {
				i.shift()
			},
			onCharacterClassEnter(a) {
				i.unshift(a)
			},
			onCharacterClassLeave() {
				i.shift()
			},
			onAssertionEnter(a) {
				gN(a) && i.push(a)
			},
			onAssertionLeave(a) {
				i[0] === a && i.shift()
			},
		}).visit(e),
		(t += o.slice(n)),
		t
	)
}
function B9(o) {
	return o.replace(/\n/g, "\\r?\\n")
}
function $9(o) {
	let e = !1,
		t = !1,
		n = "",
		r = ""
	for (let i = 0; i < o.length; i++) {
		let s = o[i]
		switch (s) {
			case "\\":
				t ? (e ? (r += "\\" + s) : (n += "\\" + s), (t = !1)) : (t = !0)
				break
			case "{":
				if (t) e ? (r += s) : (n += s), (t = !1)
				else {
					if (e) return { strInBraces: n + "{" + r + "{" + o.substring(i + 1) }
					e = !0
				}
				break
			case "}":
				if (t) e ? (r += s) : (n += s), (t = !1)
				else {
					if (e) return { fixedStart: n, strInBraces: r, fixedEnd: o.substring(i + 1) }
					n += s
				}
				break
			default:
				e ? (r += (t ? "\\" : "") + s) : (n += (t ? "\\" : "") + s), (t = !1)
				break
		}
	}
	return { strInBraces: n + (e ? "{" + r : "") }
}
function vN(o) {
	let { fixedStart: e, strInBraces: t, fixedEnd: n } = $9(o)
	if (e === void 0 || n === void 0) return [t]
	let r = rd(t, ",")
	r.length || (r = [""])
	let i = vN(n)
	return r.flatMap((s) => {
		let a = e + s
		return i.map((l) => a + l)
	})
}
var cm = class extends Ud {
	constructor(e, t, n = Fo, r = "searchProcess") {
		super(
			{ query: e, provider: t },
			{ readdir: (i) => n.Promises.readdir(i.fsPath), toCanonicalName: (i) => NF(i) },
			r,
		)
	}
}
var PC = class {
	constructor(e, t) {
		this.query = e
		this.numThreads = t
	}
	search(e, t, n) {
		if (
			(!this.query.folderQueries || !this.query.folderQueries.length) &&
			(!this.query.extraFileResources || !this.query.extraFileResources.length)
		)
			return Promise.resolve({ type: "success", limitHit: !1, stats: { type: "searchProcess" }, messages: [] })
		let r = {
				appendLine(s) {
					n({ message: s })
				},
			},
			i = new cm(this.query, new dm(r, this.numThreads), Fo)
		return new Promise((s, a) =>
			i
				.search((l) => {
					t(l.map(z9))
				}, e)
				.then((l) => s({ limitHit: l.limitHit ?? !1, type: "success", stats: l.stats, messages: [] }), a),
		)
	}
}
function z9(o) {
	return {
		path: o.resource && o.resource.fsPath,
		results: o.results,
		numMatches: (o.results || []).reduce((e, t) => (Og(t) ? e + t.rangeLocations.length : e + 1), 0),
	}
}
var _C = class o {
		constructor(e = "searchProcess", t) {
			this.processType = e
			this.getNumThreads = t
			this.caches = Object.create(null)
		}
		static {
			this.BATCH_SIZE = 512
		}
		fileSearch(e) {
			let t,
				n = bN(e),
				r = new E({
					onDidAddFirstListener: () => {
						;(t = kr(async (i) => {
							let s = await this.getNumThreads?.()
							return this.doFileSearchWithEngine(dh, n, (a) => r.fire(a), i, o.BATCH_SIZE, s)
						})),
							t.then(
								(i) => r.fire(i),
								(i) => r.fire({ type: "error", error: { message: i.message, stack: i.stack } }),
							)
					},
					onDidRemoveLastListener: () => {
						t.cancel()
					},
				})
			return r.event
		}
		textSearch(e) {
			let t,
				n = bN(e),
				r = new E({
					onDidAddFirstListener: () => {
						;(t = kr((i) => this.ripgrepTextSearch(n, (s) => r.fire(s), i))),
							t.then(
								(i) => r.fire(i),
								(i) => r.fire({ type: "error", error: { message: i.message, stack: i.stack } }),
							)
					},
					onDidRemoveLastListener: () => {
						t.cancel()
					},
				})
			return r.event
		}
		async ripgrepTextSearch(e, t, n) {
			e.maxFileSize = this.getPlatformFileLimits().maxFileSize
			let r = await this.getNumThreads?.()
			return new PC(e, r).search(n, t, t)
		}
		getPlatformFileLimits() {
			return { maxFileSize: 16 * Hc.GB }
		}
		doFileSearch(e, t, n, r) {
			return this.doFileSearchWithEngine(dh, e, n, r, o.BATCH_SIZE, t)
		}
		doFileSearchWithEngine(e, t, n, r, i = o.BATCH_SIZE, s) {
			let a = 0,
				l = (c) => {
					Array.isArray(c)
						? ((a += c.length), n(c.map((u) => this.rawMatchToSearchItem(u))))
						: c.relativePath
							? (a++, n(this.rawMatchToSearchItem(c)))
							: n(c)
				}
			if (t.sortByScore) {
				let c = this.trySortedSearchFromCache(t, l, r)
				if (!c) {
					let u = t.maxResults ? Object.assign({}, t, { maxResults: null }) : t,
						m = new e(u, s)
					c = this.doSortedSearch(m, t, n, l, r)
				}
				return new Promise((u, m) => {
					c.then(([f, h]) => {
						let g = h.map((I) => this.rawMatchToSearchItem(I))
						this.sendProgress(g, n, i), u(f)
					}, m)
				})
			}
			let d = new e(t, s)
			return this.doSearch(d, l, i, r).then((c) => ({
				limitHit: c.limitHit,
				type: "success",
				stats: {
					detailStats: c.stats,
					type: this.processType,
					fromCache: !1,
					resultCount: a,
					sortingTime: void 0,
				},
				messages: [],
			}))
		}
		rawMatchToSearchItem(e) {
			return { path: e.base ? Fe(e.base, e.relativePath) : e.relativePath }
		}
		doSortedSearch(e, t, n, r, i) {
			let s = new E(),
				a = kr((d) => {
					let c = [],
						u = (m) => {
							Array.isArray(m) ? (c = m) : (r(m), s.fire(m))
						}
					return this.doSearch(e, u, -1, d).then((m) => [m, c])
				}),
				l
			if (t.cacheKey) {
				l = this.getOrCreateCache(t.cacheKey)
				let d = { promise: a, event: s.event, resolved: !1 }
				;(l.resultsToSearchCache[t.filePattern || ""] = d),
					a.then(
						() => {
							d.resolved = !0
						},
						(c) => {
							delete l.resultsToSearchCache[t.filePattern || ""]
						},
					),
					(a = this.preventCancellation(a))
			}
			return a.then(([d, c]) => {
				let u = l ? l.scorerCache : Object.create(null),
					m = (typeof t.maxResults != "number" || t.maxResults > 0) && zt.create(!1)
				return this.sortResults(t, c, u, i).then((f) => {
					let h = m ? m.elapsed() : -1
					return [
						{
							type: "success",
							stats: {
								detailStats: d.stats,
								sortingTime: h,
								fromCache: !1,
								type: this.processType,
								resultCount: f.length,
							},
							messages: d.messages,
							limitHit: d.limitHit || (typeof t.maxResults == "number" && c.length > t.maxResults),
						},
						f,
					]
				})
			})
		}
		getOrCreateCache(e) {
			let t = this.caches[e]
			return t || (this.caches[e] = new WR())
		}
		trySortedSearchFromCache(e, t, n) {
			let r = e.cacheKey && this.caches[e.cacheKey]
			if (!r) return
			let i = this.getResultsFromCache(r, e.filePattern || "", t, n)
			if (i)
				return i.then(([s, a, l]) => {
					let d = zt.create(!1)
					return this.sortResults(e, a, r.scorerCache, n).then((c) => {
						let u = d.elapsed(),
							m = {
								fromCache: !0,
								detailStats: l,
								type: this.processType,
								resultCount: a.length,
								sortingTime: u,
							}
						return [
							{
								type: "success",
								limitHit: s.limitHit || (typeof e.maxResults == "number" && a.length > e.maxResults),
								stats: m,
								messages: [],
							},
							c,
						]
					})
				})
		}
		sortResults(e, t, n, r) {
			let i = lh(e.filePattern || ""),
				s = (l, d) => iN(l, d, i, !0, q9, n),
				a = typeof e.maxResults == "number" ? e.maxResults : Za
			return R0(t, s, a, 1e4, r)
		}
		sendProgress(e, t, n) {
			if (n && n > 0) for (let r = 0; r < e.length; r += n) t(e.slice(r, r + n))
			else t(e)
		}
		getResultsFromCache(e, t, n, r) {
			let i = zt.create(!1),
				s = t.indexOf(at) >= 0,
				a
			for (let u in e.resultsToSearchCache)
				if (t.startsWith(u)) {
					if (s && u.indexOf(at) < 0 && u !== "") continue
					let m = e.resultsToSearchCache[u]
					a = { promise: this.preventCancellation(m.promise), event: m.event, resolved: m.resolved }
					break
				}
			if (!a) return null
			let l = i.elapsed(),
				d = zt.create(!1),
				c = a.event(n)
			return (
				r &&
					r.onCancellationRequested(() => {
						c.dispose()
					}),
				a.promise.then(([u, m]) => {
					if (r && r.isCancellationRequested) throw $i()
					let f = [],
						h = lh(t).normalizedLowercase
					for (let g of m) Lg(g, h) && f.push(g)
					return [
						u,
						f,
						{
							cacheWasResolved: a.resolved,
							cacheLookupTime: l,
							cacheFilterTime: d.elapsed(),
							cacheEntryCount: m.length,
						},
					]
				})
			)
		}
		doSearch(e, t, n, r) {
			return new Promise((i, s) => {
				let a = []
				r?.onCancellationRequested(() => e.cancel()),
					e.search(
						(l) => {
							l && (n ? (a.push(l), n > 0 && a.length >= n && (t(a), (a = []))) : t(l))
						},
						(l) => {
							t(l)
						},
						(l, d) => {
							a.length && t(a),
								l
									? (t({ message: "Search finished. Error: " + l.message }), s(l))
									: (t({ message: "Search finished. Stats: " + JSON.stringify(d.stats) }), i(d))
						},
					)
			})
		}
		clearCache(e) {
			return delete this.caches[e], Promise.resolve(void 0)
		}
		preventCancellation(e) {
			return new (class {
				get [Symbol.toStringTag]() {
					return this.toString()
				}
				cancel() {}
				then(t, n) {
					return e.then(t, n)
				}
				catch(t) {
					return this.then(void 0, t)
				}
				finally(t) {
					return e.finally(t)
				}
			})()
		}
	},
	WR = class {
		constructor() {
			this.resultsToSearchCache = Object.create(null)
			this.scorerCache = Object.create(null)
		}
	},
	q9 = new (class {
		getItemLabel(o) {
			return Ze(o.relativePath)
		}
		getItemDescription(o) {
			return Qt(o.relativePath)
		}
		getItemPath(o) {
			return o.relativePath
		}
	})()
function bN(o) {
	return {
		...o,
		folderQueries: o.folderQueries && o.folderQueries.map(K9),
		extraFileResources: o.extraFileResources && o.extraFileResources.map((e) => y.revive(e)),
	}
}
function K9(o) {
	return ut(o)
}
var uh = class {
	constructor(e, t) {
		this.outputChannel = e
		this.getNumThreads = t
		this.inProgress = new Set()
		process.once("exit", () => this.dispose())
	}
	async provideTextSearchResults(e, t, n, r) {
		let i = await this.getNumThreads(),
			s = new dm(this.outputChannel, i)
		return Promise.all(
			t.folderOptions.map((a) => {
				let l = {
					folderOptions: a,
					numThreads: i,
					maxResults: t.maxResults,
					previewOptions: t.previewOptions,
					maxFileSize: t.maxFileSize,
					surroundingContext: t.surroundingContext,
				}
				if (a.folder.scheme === W.vscodeUserData) {
					let d = { ...l, folder: a.folder.with({ scheme: W.file }) },
						c = new ha((u) => n.report({ ...u, uri: u.uri.with({ scheme: a.folder.scheme }) }))
					return this.withToken(r, (u) => s.provideTextSearchResultsWithRgOptions(e, d, c, u))
				} else return this.withToken(r, (d) => s.provideTextSearchResultsWithRgOptions(e, l, n, d))
			}),
		).then((a) => ({ limitHit: a.some((d) => !!d && d.limitHit) }))
	}
	async withToken(e, t) {
		let n = j9(e)
		this.inProgress.add(n)
		let r = await t(n.token)
		return this.inProgress.delete(n), r
	}
	dispose() {
		this.inProgress.forEach((e) => e.cancel())
	}
}
function j9(o) {
	let e = new _e()
	return o.onCancellationRequested(() => e.cancel()), e
}
var um = class extends ul {
	constructor(t, n, r, i, s) {
		super(t, r, s)
		this.configurationService = i
		this._pfs = Fo
		this._internalFileSearchHandle = -1
		this._internalFileSearchProvider = null
		this._registeredEHSearchProvider = !1
		this._disposables = new Q()
		this.isDisposed = !1
		;(this.getNumThreads = this.getNumThreads.bind(this)),
			(this.getNumThreadsCached = this.getNumThreadsCached.bind(this)),
			(this.handleConfigurationChanged = this.handleConfigurationChanged.bind(this))
		let a = new Bd("RipgrepSearchUD", this._logService)
		this._disposables.add(this.registerTextSearchProvider(W.vscodeUserData, new uh(a, this.getNumThreadsCached))),
			n.remote.isRemote && n.remote.authority && this._registerEHSearchProviders(),
			i.getConfigProvider().then((l) => {
				this.isDisposed || this._disposables.add(l.onDidChangeConfiguration(this.handleConfigurationChanged))
			})
	}
	handleConfigurationChanged(t) {
		t.affectsConfiguration("search") && (this._numThreadsPromise = void 0)
	}
	async getNumThreads() {
		return (await this.configurationService.getConfigProvider())
			.getConfiguration("search")
			.get("ripgrep.maxThreads")
	}
	async getNumThreadsCached() {
		return this._numThreadsPromise || (this._numThreadsPromise = this.getNumThreads()), this._numThreadsPromise
	}
	dispose() {
		;(this.isDisposed = !0), this._disposables.dispose()
	}
	$enableExtensionHostSearch() {
		this._registerEHSearchProviders()
	}
	_registerEHSearchProviders() {
		if (this._registeredEHSearchProvider) return
		this._registeredEHSearchProvider = !0
		let t = new Bd("RipgrepSearchEH", this._logService)
		this._disposables.add(this.registerTextSearchProvider(W.file, new uh(t, this.getNumThreadsCached))),
			this._disposables.add(
				this.registerInternalFileSearchProvider(W.file, new _C("fileSearchProvider", this.getNumThreadsCached)),
			)
	}
	registerInternalFileSearchProvider(t, n) {
		let r = this._handlePool++
		return (
			(this._internalFileSearchProvider = n),
			(this._internalFileSearchHandle = r),
			this._proxy.$registerFileSearchProvider(r, this._transformScheme(t)),
			q(() => {
				;(this._internalFileSearchProvider = null), this._proxy.$unregisterProvider(r)
			})
		)
	}
	$provideFileSearchResults(t, n, r, i) {
		let s = eh(r)
		if (t === this._internalFileSearchHandle) {
			let a = Date.now()
			return this.doInternalFileSearch(t, n, s, i).then((l) => {
				let d = Date.now() - a
				return this._logService.debug(`Ext host file search time: ${d}ms`), l
			})
		}
		return super.$provideFileSearchResults(t, n, r, i)
	}
	async doInternalFileSearchWithCustomCallback(t, n, r) {
		let i = (a) => {
			if ((kF(a) && (a = [a]), Array.isArray(a))) {
				r(a.map((l) => y.file(l.path)))
				return
			}
			a.message && this._logService.debug("ExtHostSearch", a.message)
		}
		if (!this._internalFileSearchProvider) throw new Error("No internal file search handler")
		let s = await this.getNumThreadsCached()
		return this._internalFileSearchProvider.doFileSearch(t, s, i, n)
	}
	async doInternalFileSearch(t, n, r, i) {
		return this.doInternalFileSearchWithCustomCallback(r, i, (s) => {
			this._proxy.$handleFileMatch(t, n, s)
		})
	}
	$clearCache(t) {
		return this._internalFileSearchProvider?.clearCache(t), super.$clearCache(t)
	}
	createTextSearchManager(t, n) {
		return new cm(t, n, void 0, "textSearchProvider")
	}
}
um = R([S(0, ie), S(1, Xe), S(2, pi), S(3, pn), S(4, te)], um)
function VR(o, e, t, n, r, i) {
	if (Array.isArray(o)) {
		let s = 0
		for (let a of o) {
			let l = VR(a, e, t, n, r, i)
			if (l === 10) return l
			l > s && (s = l)
		}
		return s
	} else {
		if (typeof o == "string") return n ? (o === "*" ? 5 : o === t ? 10 : 0) : 0
		if (o) {
			let { language: s, pattern: a, scheme: l, hasAccessToAllModels: d, notebookType: c } = o
			if (!n && !d) return 0
			c && r && (e = r)
			let u = 0
			if (l)
				if (l === e.scheme) u = 10
				else if (l === "*") u = 5
				else return 0
			if (s)
				if (s === t) u = 10
				else if (s === "*") u = Math.max(u, 5)
				else return 0
			if (c)
				if (c === i) u = 10
				else if (c === "*" && i !== void 0) u = Math.max(u, 5)
				else return 0
			if (a) {
				let m
				if (
					(typeof a == "string" ? (m = a) : (m = { ...a, base: jn(a.base) }),
					m === e.fsPath || vi(m, e.fsPath))
				)
					u = 10
				else return 0
			}
			return u
		} else return 0
	}
}
function BR(o) {
	return typeof o == "string" ? !1 : Array.isArray(o) ? o.some(BR) : !!o.notebookType
}
var $R = ((r) => (
	(r[(r.None = 0)] = "None"),
	(r[(r.Indent = 1)] = "Indent"),
	(r[(r.IndentOutdent = 2)] = "IndentOutdent"),
	(r[(r.Outdent = 3)] = "Outdent"),
	r
))($R || {})
var fMe = O("editSessionIdentityService"),
	zR = ((n) => (
		(n[(n.Complete = 100)] = "Complete"), (n[(n.Partial = 50)] = "Partial"), (n[(n.None = 0)] = "None"), n
	))(zR || {})
var DC = class {
	constructor(e) {
		this._relatedInformationProviders = new Map()
		this._nextHandle = 0
		this._proxy = e.getProxy(N.MainThreadAiRelatedInformation)
	}
	async $provideAiRelatedInformation(e, t, n) {
		if (this._relatedInformationProviders.size === 0) throw new Error("No related information providers registered")
		let r = this._relatedInformationProviders.get(e)
		if (!r) throw new Error("related information provider not found")
		return (await r.provideRelatedInformation(t, n)) ?? []
	}
	getRelatedInformation(e, t, n) {
		return this._proxy.$getAiRelatedInformation(t, n)
	}
	registerRelatedInformationProvider(e, t, n) {
		let r = this._nextHandle
		return (
			this._nextHandle++,
			this._relatedInformationProviders.set(r, n),
			this._proxy.$registerAiRelatedInformationProvider(r, t),
			new ye(() => {
				this._proxy.$unregisterAiRelatedInformationProvider(r), this._relatedInformationProviders.delete(r)
			})
		)
	}
}
function yN(o) {
	for (let e = 0, t = o.length; e < t; e += 4) {
		let n = o[e + 0],
			r = o[e + 1],
			i = o[e + 2],
			s = o[e + 3]
		;(o[e + 0] = s), (o[e + 1] = i), (o[e + 2] = r), (o[e + 3] = n)
	}
}
function Q9(o) {
	let e = new Uint8Array(o.buffer, o.byteOffset, o.length * 4)
	return cv() || yN(e), z.wrap(e)
}
function J9(o) {
	let e = o.buffer
	if ((cv() || yN(e), e.byteOffset % 4 === 0)) return new Uint32Array(e.buffer, e.byteOffset, e.length / 4)
	{
		let t = new Uint8Array(e.byteLength)
		return t.set(e), new Uint32Array(t.buffer, t.byteOffset, t.length / 4)
	}
}
function kC(o) {
	let e = new Uint32Array(X9(o)),
		t = 0
	if (((e[t++] = o.id), o.type === "full"))
		(e[t++] = 1), (e[t++] = o.data.length), e.set(o.data, t), (t += o.data.length)
	else {
		;(e[t++] = 2), (e[t++] = o.deltas.length)
		for (let n of o.deltas)
			(e[t++] = n.start),
				(e[t++] = n.deleteCount),
				n.data ? ((e[t++] = n.data.length), e.set(n.data, t), (t += n.data.length)) : (e[t++] = 0)
	}
	return Q9(e)
}
function X9(o) {
	let e = 0
	if (((e += 2), o.type === "full")) e += 1 + o.data.length
	else {
		;(e += 1), (e += 3 * o.deltas.length)
		for (let t of o.deltas) t.data && (e += t.data.length)
	}
	return e
}
function qR(o) {
	let e = J9(o),
		t = 0,
		n = e[t++]
	if (e[t++] === 1) {
		let a = e[t++],
			l = e.subarray(t, t + a)
		return (t += a), { id: n, type: "full", data: l }
	}
	let i = e[t++],
		s = []
	for (let a = 0; a < i; a++) {
		let l = e[t++],
			d = e[t++],
			c = e[t++],
			u
		c > 0 && ((u = e.subarray(t, t + c)), (t += c)), (s[a] = { start: l, deleteCount: d, data: u })
	}
	return { id: n, type: "delta", deltas: s }
}
var Y9 = [
		new be(
			"vscode.executeDocumentHighlights",
			"_executeDocumentHighlights",
			"Execute document highlight provider.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of DocumentHighlight-instances.", ei(Td.to)),
		),
		new be(
			"vscode.executeDocumentSymbolProvider",
			"_executeDocumentSymbolProvider",
			"Execute document symbol provider.",
			[G.Uri],
			new ge("A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.", (o, e) => {
				if (Qm(o)) return
				class t extends ho {
					static to(r) {
						let i = new t(r.name, Yr.to(r.kind), r.containerName || "", new rn(e[0], H.to(r.range)))
						return (
							(i.detail = r.detail),
							(i.range = i.location.range),
							(i.selectionRange = H.to(r.selectionRange)),
							(i.children = r.children ? r.children.map(t.to) : []),
							i
						)
					}
				}
				return o.map(t.to)
			}),
		),
		new be(
			"vscode.executeFormatDocumentProvider",
			"_executeFormatDocumentProvider",
			"Execute document format provider.",
			[
				G.Uri,
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ei(on.to)),
		),
		new be(
			"vscode.executeFormatRangeProvider",
			"_executeFormatRangeProvider",
			"Execute range format provider.",
			[
				G.Uri,
				G.Range,
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ei(on.to)),
		),
		new be(
			"vscode.executeFormatOnTypeProvider",
			"_executeFormatOnTypeProvider",
			"Execute format on type provider.",
			[
				G.Uri,
				G.Position,
				new G(
					"ch",
					"Trigger character",
					(o) => typeof o == "string",
					(o) => o,
				),
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ei(on.to)),
		),
		new be(
			"vscode.executeDefinitionProvider",
			"_executeDefinitionProvider",
			"Execute all definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.experimental.executeDefinitionProvider_recursive",
			"_executeDefinitionProvider_recursive",
			"Execute all definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.executeTypeDefinitionProvider",
			"_executeTypeDefinitionProvider",
			"Execute all type definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.experimental.executeTypeDefinitionProvider_recursive",
			"_executeTypeDefinitionProvider_recursive",
			"Execute all type definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.executeDeclarationProvider",
			"_executeDeclarationProvider",
			"Execute all declaration providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.experimental.executeDeclarationProvider_recursive",
			"_executeDeclarationProvider_recursive",
			"Execute all declaration providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.executeImplementationProvider",
			"_executeImplementationProvider",
			"Execute all implementation providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.experimental.executeImplementationProvider_recursive",
			"_executeImplementationProvider_recursive",
			"Execute all implementation providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", gl),
		),
		new be(
			"vscode.executeReferenceProvider",
			"_executeReferenceProvider",
			"Execute all reference providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location-instances.", ei(Bn.to)),
		),
		new be(
			"vscode.experimental.executeReferenceProvider",
			"_executeReferenceProvider_recursive",
			"Execute all reference providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location-instances.", ei(Bn.to)),
		),
		new be(
			"vscode.executeHoverProvider",
			"_executeHoverProvider",
			"Execute all hover providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Hover-instances.", ei(Ju.to)),
		),
		new be(
			"vscode.experimental.executeHoverProvider_recursive",
			"_executeHoverProvider_recursive",
			"Execute all hover providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Hover-instances.", ei(Ju.to)),
		),
		new be(
			"vscode.executeSelectionRangeProvider",
			"_executeSelectionRangeProvider",
			"Execute selection range provider.",
			[
				G.Uri,
				new G(
					"position",
					"A position in a text document",
					(o) => Array.isArray(o) && o.every((e) => Pe.isPosition(e)),
					(o) => o.map(Je.from),
				),
			],
			new ge("A promise that resolves to an array of ranges.", (o) =>
				o.map((e) => {
					let t
					for (let n of e.reverse()) t = new Ii(H.to(n), t)
					return t
				}),
			),
		),
		new be(
			"vscode.executeWorkspaceSymbolProvider",
			"_executeWorkspaceSymbolProvider",
			"Execute all workspace symbol providers.",
			[G.String.with("query", "Search string")],
			new ge("A promise that resolves to an array of SymbolInformation-instances.", (o) => o.map(Xa.to)),
		),
		new be(
			"vscode.prepareCallHierarchy",
			"_executePrepareCallHierarchy",
			"Prepare call hierarchy at a position inside a document",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of CallHierarchyItem-instances", (o) => o.map(Ns.to)),
		),
		new be(
			"vscode.provideIncomingCalls",
			"_executeProvideIncomingCalls",
			"Compute incoming calls for an item",
			[G.CallHierarchyItem],
			new ge("A promise that resolves to an array of CallHierarchyIncomingCall-instances", (o) => o.map(OD.to)),
		),
		new be(
			"vscode.provideOutgoingCalls",
			"_executeProvideOutgoingCalls",
			"Compute outgoing calls for an item",
			[G.CallHierarchyItem],
			new ge("A promise that resolves to an array of CallHierarchyOutgoingCall-instances", (o) => o.map(LD.to)),
		),
		new be(
			"vscode.prepareRename",
			"_executePrepareRename",
			"Execute the prepareRename of rename provider.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to a range and placeholder text.", (o) => {
				if (o) return { range: H.to(o.range), placeholder: o.text }
			}),
		),
		new be(
			"vscode.executeDocumentRenameProvider",
			"_executeDocumentRenameProvider",
			"Execute rename provider.",
			[G.Uri, G.Position, G.String.with("newName", "The new symbol name")],
			new ge("A promise that resolves to a WorkspaceEdit.", (o) => {
				if (o) {
					if (o.rejectReason) throw new Error(o.rejectReason)
					return $n.to(o)
				}
			}),
		),
		new be(
			"vscode.executeLinkProvider",
			"_executeLinkProvider",
			"Execute document link provider.",
			[
				G.Uri,
				G.Number.with(
					"linkResolveCount",
					"Number of links that should be resolved, only when links are unresolved.",
				).optional(),
			],
			new ge("A promise that resolves to an array of DocumentLink-instances.", (o) => o.map(Us.to)),
		),
		new be(
			"vscode.provideDocumentSemanticTokensLegend",
			"_provideDocumentSemanticTokensLegend",
			"Provide semantic tokens legend for a document",
			[G.Uri],
			new ge("A promise that resolves to SemanticTokensLegend.", (o) => {
				if (o) return new vd(o.tokenTypes, o.tokenModifiers)
			}),
		),
		new be(
			"vscode.provideDocumentSemanticTokens",
			"_provideDocumentSemanticTokens",
			"Provide semantic tokens for a document",
			[G.Uri],
			new ge("A promise that resolves to SemanticTokens.", (o) => {
				if (!o) return
				let e = qR(o)
				if (e.type === "full") return new Qo(e.data, void 0)
			}),
		),
		new be(
			"vscode.provideDocumentRangeSemanticTokensLegend",
			"_provideDocumentRangeSemanticTokensLegend",
			"Provide semantic tokens legend for a document range",
			[G.Uri, G.Range.optional()],
			new ge("A promise that resolves to SemanticTokensLegend.", (o) => {
				if (o) return new vd(o.tokenTypes, o.tokenModifiers)
			}),
		),
		new be(
			"vscode.provideDocumentRangeSemanticTokens",
			"_provideDocumentRangeSemanticTokens",
			"Provide semantic tokens for a document range",
			[G.Uri, G.Range],
			new ge("A promise that resolves to SemanticTokens.", (o) => {
				if (!o) return
				let e = qR(o)
				if (e.type === "full") return new Qo(e.data, void 0)
			}),
		),
		new be(
			"vscode.executeCompletionItemProvider",
			"_executeCompletionItemProvider",
			"Execute completion item provider.",
			[
				G.Uri,
				G.Position,
				G.String.with(
					"triggerCharacter",
					"Trigger completion when the user types the character, like `,` or `(`",
				).optional(),
				G.Number.with(
					"itemResolveCount",
					"Number of completions to resolve (too large numbers slow down completions)",
				).optional(),
			],
			new ge("A promise that resolves to a CompletionList-instance.", (o, e, t) => {
				if (!o) return new Bo([])
				let n = o.suggestions.map((r) => UD.to(r, t))
				return new Bo(n, o.incomplete)
			}),
		),
		new be(
			"vscode.executeSignatureHelpProvider",
			"_executeSignatureHelpProvider",
			"Execute signature help provider.",
			[
				G.Uri,
				G.Position,
				G.String.with(
					"triggerCharacter",
					"Trigger signature help when the user types the character, like `,` or `(`",
				).optional(),
			],
			new ge("A promise that resolves to SignatureHelp.", (o) => {
				if (o) return Xu.to(o)
			}),
		),
		new be(
			"vscode.executeCodeLensProvider",
			"_executeCodeLensProvider",
			"Execute code lens provider.",
			[
				G.Uri,
				G.Number.with(
					"itemResolveCount",
					"Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)",
				).optional(),
			],
			new ge("A promise that resolves to an array of CodeLens-instances.", (o, e, t) =>
				ei((n) => new Pa(H.to(n.range), n.command && t.fromInternal(n.command)))(o),
			),
		),
		new be(
			"vscode.executeCodeActionProvider",
			"_executeCodeActionProvider",
			"Execute code action provider.",
			[
				G.Uri,
				new G(
					"rangeOrSelection",
					"Range in a text document. Some refactoring provider requires Selection object.",
					(o) => pe.isRange(o),
					(o) => (Vn.isSelection(o) ? Zn.from(o) : H.from(o)),
				),
				G.String.with("kind", "Code action kind to return code actions for").optional(),
				G.Number.with(
					"itemResolveCount",
					"Number of code actions to resolve (too large numbers slow down code actions)",
				).optional(),
			],
			new ge("A promise that resolves to an array of Command-instances.", (o, e, t) =>
				ei((n) => {
					if (n._isSynthetic) {
						if (!n.command) throw new Error("Synthetic code actions must have a command")
						return t.fromInternal(n.command)
					} else {
						let r = new yi(n.title, n.kind ? new lt(n.kind) : void 0)
						return (
							n.edit && (r.edit = $n.to(n.edit)),
							n.command && (r.command = t.fromInternal(n.command)),
							(r.isPreferred = n.isPreferred),
							r
						)
					}
				})(o),
			),
		),
		new be(
			"vscode.executeDocumentColorProvider",
			"_executeDocumentColorProvider",
			"Execute document color provider.",
			[G.Uri],
			new ge("A promise that resolves to an array of ColorInformation objects.", (o) =>
				o ? o.map((e) => new Aa(H.to(e.range), Dd.to(e.color))) : [],
			),
		),
		new be(
			"vscode.executeColorPresentationProvider",
			"_executeColorPresentationProvider",
			"Execute color presentation provider.",
			[
				new G("color", "The color to show and insert", (o) => o instanceof $o, Dd.from),
				new G(
					"context",
					"Context object with uri and range",
					(o) => !0,
					(o) => ({ uri: o.uri, range: H.from(o.range) }),
				),
			],
			new ge("A promise that resolves to an array of ColorPresentation objects.", (o) => (o ? o.map(Ig.to) : [])),
		),
		new be(
			"vscode.executeInlayHintProvider",
			"_executeInlayHintProvider",
			"Execute inlay hints provider",
			[G.Uri, G.Range],
			new ge("A promise that resolves to an array of Inlay objects", (o, e, t) => o.map(HD.to.bind(void 0, t))),
		),
		new be(
			"vscode.executeFoldingRangeProvider",
			"_executeFoldingRangeProvider",
			"Execute folding range provider",
			[G.Uri],
			new ge("A promise that resolves to an array of FoldingRange objects", (o, e) => {
				if (o) return o.map(Cg.to)
			}),
		),
		new be(
			"vscode.resolveNotebookContentProviders",
			"_resolveNotebookContentProvider",
			"Resolve Notebook Content Providers",
			[],
			new ge(
				"A promise that resolves to an array of NotebookContentProvider static info objects.",
				ei((o) => ({
					viewType: o.viewType,
					displayName: o.displayName,
					options: {
						transientOutputs: o.options.transientOutputs,
						transientCellMetadata: o.options.transientCellMetadata,
						transientDocumentMetadata: o.options.transientDocumentMetadata,
					},
					filenamePattern: o.filenamePattern.map((e) => Tg.to(e)),
				})),
			),
		),
		new be(
			"vscode.executeInlineValueProvider",
			"_executeInlineValueProvider",
			"Execute inline value provider",
			[
				G.Uri,
				G.Range,
				new G(
					"context",
					"An InlineValueContext",
					(o) => o && typeof o.frameId == "number" && o.stoppedLocation instanceof pe,
					(o) => yg.from(o),
				),
			],
			new ge("A promise that resolves to an array of InlineValue objects", (o) => o.map(bg.to)),
		),
		new be(
			"vscode.open",
			"_workbench.open",
			"Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
			[
				new G(
					"uriOrString",
					"Uri-instance or string (only http/https)",
					(o) => y.isUri(o) || (typeof o == "string" && MA(o, W.http, W.https)),
					(o) => o,
				),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "number" || typeof o == "object",
					(o) => o && (typeof o == "number" ? [wt.from(o), void 0] : [wt.from(o.viewColumn), Sg.from(o)]),
				).optional(),
				G.String.with("label", "").optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.openWith",
			"_workbench.openWith",
			"Opens the provided resource with a specific editor.",
			[
				G.Uri.with("resource", "Resource to open"),
				G.String.with(
					"viewId",
					"Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor",
				),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "number" || typeof o == "object",
					(o) => o && (typeof o == "number" ? [wt.from(o), void 0] : [wt.from(o.viewColumn), Sg.from(o)]),
				).optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.diff",
			"_workbench.diff",
			"Opens the provided resources in the diff editor to compare their contents.",
			[
				G.Uri.with("left", "Left-hand side resource of the diff editor"),
				G.Uri.with("right", "Right-hand side resource of the diff editor"),
				G.String.with("title", "Human readable title for the diff editor").optional(),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "object",
					(o) => o && [wt.from(o.viewColumn), Sg.from(o)],
				).optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.changes",
			"_workbench.changes",
			"Opens a list of resources in the changes editor to compare their contents.",
			[
				G.String.with("title", "Human readable title for the changes editor"),
				new G(
					"resourceList",
					"List of resources to compare",
					(o) => {
						for (let e of o) {
							if (e.length !== 3) return !1
							let [t, n, r] = e
							if (
								!y.isUri(t) ||
								(!y.isUri(n) && n !== void 0 && n !== null) ||
								(!y.isUri(r) && r !== void 0 && r !== null)
							)
								return !1
						}
						return !0
					},
					(o) => o,
				),
			],
			ge.Void,
		),
		new be(
			"vscode.prepareTypeHierarchy",
			"_executePrepareTypeHierarchy",
			"Prepare type hierarchy at a position inside a document",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Hs.to)),
		),
		new be(
			"vscode.provideSupertypes",
			"_executeProvideSupertypes",
			"Compute supertypes for an item",
			[G.TypeHierarchyItem],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Hs.to)),
		),
		new be(
			"vscode.provideSubtypes",
			"_executeProvideSubtypes",
			"Compute subtypes for an item",
			[G.TypeHierarchyItem],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Hs.to)),
		),
		new be(
			"vscode.revealTestInExplorer",
			"_revealTestInExplorer",
			"Reveals a test instance in the explorer",
			[G.TestItem],
			ge.Void,
		),
		new be(
			"vscode.startContinuousTestRun",
			"testing.startContinuousRunFromExtension",
			"Starts running the given tests with continuous run mode.",
			[G.TestProfile, G.Arr(G.TestItem)],
			ge.Void,
		),
		new be(
			"vscode.stopContinuousTestRun",
			"testing.stopContinuousRunFromExtension",
			"Stops running the given tests with continuous run mode.",
			[G.Arr(G.TestItem)],
			ge.Void,
		),
		new be(
			"vscode.experimental.editSession.continue",
			"_workbench.editSessions.actions.continueEditSession",
			"Continue the current edit session in a different workspace",
			[G.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")],
			ge.Void,
		),
		new be(
			"setContext",
			"_setContext",
			"Set a custom context key value that can be used in when clauses.",
			[
				G.String.with("name", "The context key name"),
				new G(
					"value",
					"The context key value",
					() => !0,
					(o) => o,
				),
			],
			ge.Void,
		),
		new be(
			"vscode.editorChat.start",
			"inlineChat.start",
			"Invoke a new editor chat session",
			[
				new G(
					"Run arguments",
					"",
					(o) => !0,
					(o) => {
						if (o)
							return {
								initialRange: o.initialRange ? H.from(o.initialRange) : void 0,
								initialSelection: Vn.isSelection(o.initialSelection)
									? Zn.from(o.initialSelection)
									: void 0,
								message: o.message,
								autoSend: o.autoSend,
								position: o.position ? Je.from(o.position) : void 0,
							}
					},
				),
			],
			ge.Void,
		),
	],
	RC = class {
		static register(e) {
			Y9.forEach(e.registerApiCommand, e), this._registerValidateWhenClausesCommand(e)
		}
		static _registerValidateWhenClausesCommand(e) {
			e.registerCommand(!1, "_validateWhenClauses", FO)
		}
	}
function ei(o) {
	return (e) => {
		if (Array.isArray(e)) return e.map(o)
	}
}
function gl(o) {
	if (!Array.isArray(o)) return
	let e = []
	for (let t of o) NL(t) ? e.push(Qu.to(t)) : e.push(Bn.to(t))
	return e
}
var pm = class {
	constructor(e, t) {
		;(this._proxy = e.getProxy(N.MainThreadBulkEdits)),
			(this._versionInformationProvider = {
				getTextDocumentVersion: (n) => t.getDocument(n)?.version,
				getNotebookDocumentVersion: () => {},
			})
	}
	applyWorkspaceEdit(e, t, n) {
		let r = new Xt($n.from(e, this._versionInformationProvider))
		return this._proxy.$tryApplyWorkspaceEdit(r, void 0, n?.isRefactoring ?? !1)
	}
}
pm = R([S(0, ie)], pm)
function IN(o) {
	return !!o && typeof o.sessionId == "string" && o.$mid === 19
}
var KR = class {
		constructor(e, t, n, r, i) {
			this._extension = e
			this._request = t
			this._proxy = n
			this._commandsConverter = r
			this._sessionDisposables = i
			this._stopWatch = zt.create(!1)
			this._isClosed = !1
		}
		close() {
			this._isClosed = !0
		}
		get timings() {
			return { firstProgress: this._firstProgress, totalElapsed: this._stopWatch.elapsed() }
		}
		get apiObject() {
			if (!this._apiObject) {
				let t = function (r) {
						if (e._isClosed) {
							let i = new Error("Response stream has been closed")
							throw (Error.captureStackTrace(i, r), i)
						}
					},
					e = this
				this._stopWatch.reset()
				let n = (r, i) => {
					if (
						(typeof this._firstProgress > "u" &&
							(r.kind === "markdownContent" || r.kind === "markdownVuln") &&
							(this._firstProgress = this._stopWatch.elapsed()),
						i)
					) {
						let s = this._proxy.$handleProgressChunk(this._request.requestId, r),
							a = {
								report: (l) => {
									s?.then((d) => {
										d &&
											(en.isMarkdownString(l.value)
												? this._proxy.$handleProgressChunk(
														this._request.requestId,
														kg.from(l),
														d,
													)
												: this._proxy.$handleProgressChunk(
														this._request.requestId,
														Pd.from(l),
														d,
													))
									})
								},
							}
						Promise.all([s, i?.(a)]).then(([l, d]) => {
							l !== void 0 && this._proxy.$handleProgressChunk(this._request.requestId, JD.from(d), l)
						})
					} else this._proxy.$handleProgressChunk(this._request.requestId, r)
				}
				this._apiObject = Object.freeze({
					markdown(r) {
						t(this.markdown)
						let i = new Es(r),
							s = fg.from(i)
						return n(s), this
					},
					markdownWithVulnerabilities(r, i) {
						t(this.markdown), i && M(e._extension, "chatParticipantAdditions")
						let s = new Pi(r, i),
							a = lx.from(s)
						return n(a), this
					},
					codeblockUri(r, i) {
						t(this.codeblockUri), M(e._extension, "chatParticipantAdditions")
						let s = new Ds(r, i),
							a = ax.from(s)
						return n(a), this
					},
					filetree(r, i) {
						t(this.filetree)
						let s = new Ps(r, i),
							a = gg.from(s)
						return n(a), this
					},
					anchor(r, i) {
						let s = new _i(r, i)
						return this.push(s)
					},
					button(r) {
						t(this.anchor)
						let i = new _s(r),
							s = hg.from(i, e._commandsConverter, e._sessionDisposables)
						return n(s), this
					},
					progress(r, i) {
						t(this.progress)
						let s = new Ga(r, i),
							a = i ? cx.from(s) : Dg.from(s)
						return n(a, i), this
					},
					warning(r) {
						t(this.progress), M(e._extension, "chatParticipantAdditions")
						let i = new Di(r),
							s = kg.from(i)
						return n(s), this
					},
					reference(r, i) {
						return this.reference2(r, i)
					},
					reference2(r, i, s) {
						if (
							(t(this.reference),
							typeof r == "object" && "variableName" in r && M(e._extension, "chatParticipantAdditions"),
							typeof r == "object" && "variableName" in r && !r.value)
						) {
							let a = e._request.variables.variables.find((l) => l.name === r.variableName)
							if (a) {
								let l
								if (a.references?.length)
									l = a.references.map((d) => ({
										kind: "reference",
										reference: { variableName: r.variableName, value: d.reference },
									}))
								else {
									let d = new yo(r, i, s)
									l = [Pd.from(d)]
								}
								return l.forEach((d) => n(d)), this
							}
						} else {
							let a = new yo(r, i, s),
								l = Pd.from(a)
							n(l)
						}
						return this
					},
					codeCitation(r, i, s) {
						t(this.codeCitation), M(e._extension, "chatParticipantAdditions")
						let a = new ks(r, i, s),
							l = fx.from(a)
						n(l)
					},
					textEdit(r, i) {
						t(this.textEdit), M(e._extension, "chatParticipantAdditions")
						let s = new ki(r, i)
						s.isDone = i === !0 ? !0 : void 0
						let a = ux.from(s)
						return n(a), this
					},
					notebookEdit(r, i) {
						t(this.notebookEdit), M(e._extension, "chatParticipantAdditions")
						let s = new As(r, i),
							a = mx.from(s)
						return n(a), this
					},
					confirmation(r, i, s, a) {
						t(this.confirmation), M(e._extension, "chatParticipantAdditions")
						let l = new ws(r, i, s, a),
							d = dx.from(l)
						return n(d), this
					},
					push(r) {
						if (
							(t(this.push),
							(r instanceof ki ||
								r instanceof As ||
								r instanceof Pi ||
								r instanceof Di ||
								r instanceof ws ||
								r instanceof ks ||
								r instanceof Rs ||
								r instanceof Ga) &&
								M(e._extension, "chatParticipantAdditions"),
							r instanceof yo)
						)
							this.reference2(r.value, r.iconPath, r.options)
						else if (r instanceof Ga) {
							let i = r.task ? cx.from(r) : Dg.from(r)
							n(i, r.task)
						} else if (r instanceof _i) {
							let i = Gu.from(r)
							if (r.resolve) {
								M(e._extension, "chatParticipantAdditions"), (i.resolveId = He())
								let s = new _e()
								r
									.resolve(s.token)
									.then(() => {
										let a = Gu.from(r)
										e._proxy.$handleAnchorResolve(e._request.requestId, i.resolveId, a)
									})
									.then(
										() => s.dispose(),
										() => s.dispose(),
									),
									e._sessionDisposables.add(q(() => s.dispose(!0)))
							}
							n(i)
						} else {
							let i = gx.from(r, e._commandsConverter, e._sessionDisposables)
							n(i)
						}
						return this
					},
				})
			}
			return this._apiObject
		}
	},
	AC = class o extends $ {
		constructor(t, n, r, i, s, a, l) {
			super()
			this._logService = n
			this._commands = r
			this._documents = i
			this._languageModels = s
			this._diagnostics = a
			this._tools = l
			this._agents = new Map()
			this._participantDetectionProviders = new Map()
			this._relatedFilesProviders = new Map()
			this._sessionDisposables = this._register(new Wr())
			this._completionDisposables = this._register(new Wr())
			this._inFlightRequests = new Set()
			this._onDidDisposeChatSession = this._register(new E())
			this.onDidDisposeChatSession = this._onDidDisposeChatSession.event
			;(this._proxy = t.getProxy(N.MainThreadChatAgents2)),
				r.registerArgumentProcessor({ processArgument: (d) => (IN(d) ? null : d) })
		}
		static {
			this._idPool = 0
		}
		static {
			this._participantDetectionProviderIdPool = 0
		}
		static {
			this._relatedFilesProviderIdPool = 0
		}
		transferActiveChat(t) {
			this._proxy.$transferActiveChatSession(t)
		}
		createChatAgent(t, n, r) {
			let i = o._idPool++,
				s = new OC(t, n, this._proxy, i, r)
			return this._agents.set(i, s), this._proxy.$registerAgent(i, t.identifier, n, {}, void 0), s.apiAgent
		}
		createDynamicChatAgent(t, n, r, i) {
			let s = o._idPool++,
				a = new OC(t, n, this._proxy, s, i)
			return (
				this._agents.set(s, a), this._proxy.$registerAgent(s, t.identifier, n, { isSticky: !0 }, r), a.apiAgent
			)
		}
		registerChatParticipantDetectionProvider(t, n) {
			let r = o._participantDetectionProviderIdPool++
			return (
				this._participantDetectionProviders.set(r, new jR(t, n)),
				this._proxy.$registerChatParticipantDetectionProvider(r),
				q(() => {
					this._participantDetectionProviders.delete(r),
						this._proxy.$unregisterChatParticipantDetectionProvider(r)
				})
			)
		}
		registerRelatedFilesProvider(t, n, r) {
			let i = o._relatedFilesProviderIdPool++
			return (
				this._relatedFilesProviders.set(i, new GR(t, n)),
				this._proxy.$registerRelatedFilesProvider(i, r),
				q(() => {
					this._relatedFilesProviders.delete(i), this._proxy.$unregisterRelatedFilesProvider(i)
				})
			)
		}
		async $provideRelatedFiles(t, n, r) {
			let i = this._relatedFilesProviders.get(t)
			if (!i) return Promise.resolve([])
			let s = XD.to(n)
			return (await i.provider.provideRelatedFiles(s, r)) ?? void 0
		}
		async $detectChatParticipant(t, n, r, i, s) {
			let a = this._participantDetectionProviders.get(t)
			if (!a) return
			let { request: l, location: d, history: c } = await this._createRequest(n, r, a.extension),
				u = await this.getModelForRequest(l, a.extension),
				m = nt(a.extension, "chatParticipantPrivate"),
				f = hx.to(
					m ? l : { ...l, requestId: "" },
					d,
					u,
					this.getDiagnosticsWhenEnabled(a.extension),
					this.getToolsForRequest(a.extension, l),
				)
			return a.provider.provideParticipantDetection(
				f,
				{ history: c },
				{ participants: i.participants, location: Rg.to(i.location) },
				s,
			)
		}
		async _createRequest(t, n, r) {
			let i = ut(t),
				s = await this.prepareHistoryTurns(r, i.agentId, n),
				a
			if (i.locationData?.type === "editor") {
				let l = this._documents.getDocument(i.locationData.document)
				a = new Hu(l, Zn.to(i.locationData.selection), H.to(i.locationData.wholeRange))
			} else if (i.locationData?.type === "notebook") {
				let l = this._documents.getDocument(i.locationData.sessionInputUri)
				a = new Wu(l)
			} else i.locationData?.type, "terminal"
			return { request: i, location: a, history: s }
		}
		async getModelForRequest(t, n) {
			let r
			if (
				(t.userSelectedModelId &&
					(r = await this._languageModels.getLanguageModelByIdentifier(n, t.userSelectedModelId)),
				!r && ((r = await this._languageModels.getDefaultLanguageModel(n)), !r))
			)
				throw new Error("Language model unavailable")
			return r
		}
		async $setRequestPaused(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = kt.find(this._inFlightRequests, (a) => a.requestId === n)
			s && i.setChatRequestPauseState({ request: s.extRequest, isPaused: r })
		}
		async $invokeAgent(t, n, r, i) {
			let s = this._agents.get(t)
			if (!s) throw new Error(`[CHAT](${t}) CANNOT invoke agent because the agent is not registered`)
			let a, l
			try {
				let { request: d, location: c, history: u } = await this._createRequest(n, r, s.extension),
					m = this._sessionDisposables.get(d.sessionId)
				m || ((m = new Q()), this._sessionDisposables.set(d.sessionId, m)),
					(a = new KR(s.extension, d, this._proxy, this._commands.converter, m))
				let f = await this.getModelForRequest(d, s.extension),
					h = nt(s.extension, "chatParticipantPrivate"),
					g = hx.to(
						h ? d : { ...d, requestId: "" },
						c,
						f,
						this.getDiagnosticsWhenEnabled(s.extension),
						this.getToolsForRequest(s.extension, d),
					)
				;(l = { requestId: n.requestId, extRequest: g }), this._inFlightRequests.add(l)
				let I = s.invoke(g, { history: u }, a.apiObject, i)
				return await Fv(
					Promise.resolve(I).then((C) => {
						if (C?.metadata)
							try {
								JSON.stringify(C.metadata)
							} catch (w) {
								let L = `result.metadata MUST be JSON.stringify-able. Got error: ${w.message}`
								return (
									this._logService.error(
										`[${s.extension.identifier.value}] [@${s.id}] ${L}`,
										s.extension,
									),
									{ errorDetails: { message: L }, timings: a?.timings, nextQuestion: C.nextQuestion }
								)
							}
						let T
						return (
							C?.errorDetails && (T = { ...C.errorDetails, responseIsIncomplete: !0 }),
							(T?.responseIsRedacted || T?.isQuotaExceeded) && M(s.extension, "chatParticipantPrivate"),
							{
								errorDetails: T,
								timings: a?.timings,
								metadata: C?.metadata,
								nextQuestion: C?.nextQuestion,
							}
						)
					}),
					i,
				)
			} catch (d) {
				this._logService.error(d, s.extension), d instanceof Nr && d.cause && (d = d.cause)
				let c = d instanceof Error && d.name === "ChatQuotaExceeded"
				return { errorDetails: { message: Jn(d), responseIsIncomplete: !0, isQuotaExceeded: c } }
			} finally {
				l && this._inFlightRequests.delete(l), a?.close()
			}
		}
		getDiagnosticsWhenEnabled(t) {
			return nt(t, "chatReferenceDiagnostic") ? this._diagnostics.getDiagnostics() : []
		}
		getToolsForRequest(t, n) {
			if (!ri(n.userSelectedTools)) return
			let r = new Set(n.userSelectedTools)
			return this._tools.getTools(t).filter((i) => r.has(i.name))
		}
		async prepareHistoryTurns(t, n, r) {
			let i = []
			for (let s of r.history) {
				let a = ep.to(s.result),
					l = n === s.request.agentId ? a : { ...a, metadata: void 0 },
					d = s.request.variables.variables
						.filter((f) => !f.isTool)
						.map((f) => vx.to(f, this.getDiagnosticsWhenEnabled(t))),
					c = s.request.variables.variables.filter((f) => f.isTool).map(bx.to),
					u = new Nu(s.request.message, s.request.command, d, s.request.agentId, c)
				i.push(u)
				let m = Ye(s.response.map((f) => gx.toContent(f, this._commands.converter)))
				i.push(new Uu(m, l, s.request.agentId, s.request.command))
			}
			return i
		}
		$releaseSession(t) {
			this._sessionDisposables.deleteAndDispose(t), this._onDidDisposeChatSession.fire(t)
		}
		async $provideFollowups(t, n, r, i, s) {
			let a = this._agents.get(n)
			if (!a) return Promise.resolve([])
			let l = ut(t),
				d = await this.prepareHistoryTurns(a.extension, a.id, i),
				c = ep.to(r)
			return (await a.provideFollowups(c, { history: d }, s))
				.filter((u) => {
					let m =
						!u.participant ||
						kt.some(
							this._agents.values(),
							(f) => f.id === u.participant && we.equals(f.extension.identifier, a.extension.identifier),
						)
					return (
						m ||
							this._logService.warn(
								`[@${a.id}] ChatFollowup refers to an unknown participant: ${u.participant}`,
							),
						m
					)
				})
				.map((u) => Pg.from(u, l))
		}
		$acceptFeedback(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = ep.to(n),
				a
			switch (r.direction) {
				case 0:
					a = 0
					break
				case 1:
					a = 1
					break
			}
			let l = {
				result: s,
				kind: a,
				unhelpfulReason: nt(i.extension, "chatParticipantAdditions") ? r.reason : void 0,
			}
			i.acceptFeedback(Object.freeze(l))
		}
		$acceptAction(t, n, r) {
			let i = this._agents.get(t)
			if (!i || r.action.kind === "vote") return
			let s = ZD.to(n, r, this._commands.converter)
			s && i.acceptAction(Object.freeze(s))
		}
		async $invokeCompletionProvider(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return []
			let s = this._completionDisposables.get(t)
			return (
				s ? s.clear() : ((s = new Q()), this._completionDisposables.set(t, s)),
				(await i.invokeCompletionProvider(n, r)).map((l) => YD.from(l, this._commands.converter, s))
			)
		}
		async $provideChatTitle(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = await this.prepareHistoryTurns(i.extension, i.id, { history: n })
			return await i.provideTitle({ history: s }, r)
		}
		async $provideSampleQuestions(t, n, r) {
			let i = this._agents.get(t)
			if (i) return (await i.provideSampleQuestions(Rg.to(n), r)).map((s) => Pg.from(s, void 0))
		}
	},
	jR = class {
		constructor(e, t) {
			this.extension = e
			this.provider = t
		}
	},
	GR = class {
		constructor(e, t) {
			this.extension = e
			this.provider = t
		}
	},
	OC = class {
		constructor(e, t, n, r, i) {
			this.extension = e
			this.id = t
			this._proxy = n
			this._handle = r
			this._requestHandler = i
			this._onDidReceiveFeedback = new E()
			this._onDidPerformAction = new E()
			this._pauseStateEmitter = new E()
		}
		acceptFeedback(e) {
			this._onDidReceiveFeedback.fire(e)
		}
		acceptAction(e) {
			this._onDidPerformAction.fire(e)
		}
		setChatRequestPauseState(e) {
			this._pauseStateEmitter.fire(e)
		}
		async invokeCompletionProvider(e, t) {
			return this._agentVariableProvider
				? ((await this._agentVariableProvider.provider.provideCompletionItems(e, t)) ?? [])
				: []
		}
		async provideFollowups(e, t, n) {
			if (!this._followupProvider) return []
			let r = await this._followupProvider.provideFollowups(e, t, n)
			return r ? r.filter((i) => !(i && "commandId" in i)).filter((i) => !(i && "message" in i)) : []
		}
		async provideTitle(e, t) {
			if (this._titleProvider) return (await this._titleProvider.provideChatTitle(e, t)) ?? void 0
		}
		async provideSampleQuestions(e, t) {
			if (!this._welcomeMessageProvider || !this._welcomeMessageProvider.provideSampleQuestions) return []
			let n = await this._welcomeMessageProvider.provideSampleQuestions(e, t)
			return n || []
		}
		get apiAgent() {
			let e = !1,
				t = !1,
				n = () => {
					e ||
						t ||
						((t = !0),
						queueMicrotask(() => {
							this._proxy.$updateAgent(this._handle, {
								icon: this._iconPath
									? this._iconPath instanceof y
										? this._iconPath
										: "light" in this._iconPath
											? this._iconPath.light
											: void 0
									: void 0,
								iconDark: this._iconPath && "dark" in this._iconPath ? this._iconPath.dark : void 0,
								themeIcon: this._iconPath instanceof Vt ? this._iconPath : void 0,
								hasFollowups: this._followupProvider !== void 0,
								helpTextPrefix:
									!this._helpTextPrefix || typeof this._helpTextPrefix == "string"
										? this._helpTextPrefix
										: Ce.from(this._helpTextPrefix),
								helpTextVariablesPrefix:
									!this._helpTextVariablesPrefix || typeof this._helpTextVariablesPrefix == "string"
										? this._helpTextVariablesPrefix
										: Ce.from(this._helpTextVariablesPrefix),
								helpTextPostfix:
									!this._helpTextPostfix || typeof this._helpTextPostfix == "string"
										? this._helpTextPostfix
										: Ce.from(this._helpTextPostfix),
								supportIssueReporting: this._supportIssueReporting,
								requester: this._requester,
								additionalWelcomeMessage:
									!this._additionalWelcomeMessage || typeof this._additionalWelcomeMessage == "string"
										? this._additionalWelcomeMessage
										: Ce.from(this._additionalWelcomeMessage),
							}),
								(t = !1)
						}))
				},
				r = this
			return {
				get id() {
					return r.id
				},
				get iconPath() {
					return r._iconPath
				},
				set iconPath(i) {
					;(r._iconPath = i), n()
				},
				get requestHandler() {
					return r._requestHandler
				},
				set requestHandler(i) {
					fc(typeof i == "function", "Invalid request handler"), (r._requestHandler = i)
				},
				get followupProvider() {
					return r._followupProvider
				},
				set followupProvider(i) {
					;(r._followupProvider = i), n()
				},
				get helpTextPrefix() {
					return M(r.extension, "defaultChatParticipant"), r._helpTextPrefix
				},
				set helpTextPrefix(i) {
					M(r.extension, "defaultChatParticipant"), (r._helpTextPrefix = i), n()
				},
				get helpTextVariablesPrefix() {
					return M(r.extension, "defaultChatParticipant"), r._helpTextVariablesPrefix
				},
				set helpTextVariablesPrefix(i) {
					M(r.extension, "defaultChatParticipant"), (r._helpTextVariablesPrefix = i), n()
				},
				get helpTextPostfix() {
					return M(r.extension, "defaultChatParticipant"), r._helpTextPostfix
				},
				set helpTextPostfix(i) {
					M(r.extension, "defaultChatParticipant"), (r._helpTextPostfix = i), n()
				},
				get supportIssueReporting() {
					return M(r.extension, "chatParticipantPrivate"), r._supportIssueReporting
				},
				set supportIssueReporting(i) {
					M(r.extension, "chatParticipantPrivate"), (r._supportIssueReporting = i), n()
				},
				get onDidReceiveFeedback() {
					return r._onDidReceiveFeedback.event
				},
				set participantVariableProvider(i) {
					if ((M(r.extension, "chatParticipantAdditions"), (r._agentVariableProvider = i), i)) {
						if (!i.triggerCharacters.length) throw new Error("triggerCharacters are required")
						r._proxy.$registerAgentCompletionsProvider(r._handle, r.id, i.triggerCharacters)
					} else r._proxy.$unregisterAgentCompletionsProvider(r._handle, r.id)
				},
				get participantVariableProvider() {
					return M(r.extension, "chatParticipantAdditions"), r._agentVariableProvider
				},
				set welcomeMessageProvider(i) {
					M(r.extension, "defaultChatParticipant"), (r._welcomeMessageProvider = i), n()
				},
				get welcomeMessageProvider() {
					return M(r.extension, "defaultChatParticipant"), r._welcomeMessageProvider
				},
				set additionalWelcomeMessage(i) {
					M(r.extension, "defaultChatParticipant"), (r._additionalWelcomeMessage = i), n()
				},
				get additionalWelcomeMessage() {
					return M(r.extension, "defaultChatParticipant"), r._additionalWelcomeMessage
				},
				set titleProvider(i) {
					M(r.extension, "defaultChatParticipant"), (r._titleProvider = i), n()
				},
				get titleProvider() {
					return M(r.extension, "defaultChatParticipant"), r._titleProvider
				},
				get onDidChangePauseState() {
					return M(r.extension, "chatParticipantAdditions"), r._pauseStateEmitter.event
				},
				onDidPerformAction: nt(this.extension, "chatParticipantAdditions")
					? this._onDidPerformAction.event
					: void 0,
				set requester(i) {
					;(r._requester = i), n()
				},
				get requester() {
					return r._requester
				},
				dispose() {
					;(e = !0),
						(r._followupProvider = void 0),
						r._onDidReceiveFeedback.dispose(),
						r._proxy.$unregisterAgent(r._handle)
				},
			}
		}
		invoke(e, t, n, r) {
			return this._requestHandler(e, t, n, r)
		}
	}
var LC = class {
	constructor(e) {
		this._items = new Map()
		this._proxy = e.getProxy(N.MainThreadChatStatus)
	}
	createChatStatusItem(e, t) {
		let n = Z9(e.identifier, t)
		if (this._items.has(n)) throw new Error(`Chat status item '${t}' already exists`)
		let r = { id: n, title: "", description: "", detail: "" },
			i = !1,
			s = !1,
			a = () => {
				if (i) throw new Error("Chat status item is disposed")
				s && this._proxy.$setEntry(t, r)
			},
			l = Object.freeze({
				id: t,
				get title() {
					return r.title
				},
				set title(d) {
					;(r.title = d), a()
				},
				get description() {
					return r.description
				},
				set description(d) {
					;(r.description = d), a()
				},
				get detail() {
					return r.detail
				},
				set detail(d) {
					;(r.detail = d), a()
				},
				show: () => {
					;(s = !0), a()
				},
				hide: () => {
					;(s = !1), this._proxy.$disposeEntry(t)
				},
				dispose: () => {
					;(i = !0), this._proxy.$disposeEntry(t), this._items.delete(n)
				},
			})
		return this._items.set(n, l), l
	}
}
function Z9(o, e) {
	return `${we.toKey(o)}.${e}`
}
var MC = class {
	constructor(e) {
		let t = e.getProxy(N.MainThreadClipboard)
		this.value = Object.freeze({
			readText() {
				return t.$readText()
			},
			writeText(n) {
				return t.$writeText(n)
			},
		})
	}
}
var xN = "vscode-cdn.net",
	eB = `vscode-resource.${xN}`,
	ph = `'self' https://*.${xN} vscode-file://*`
function hl(o, e) {
	return o.scheme === W.http || o.scheme === W.https
		? o
		: o.scheme === W.file
			? y.from({ scheme: "vscode-file", path: o.path, fragment: o.fragment, query: o.query })
			: (e &&
					e.authority &&
					e.isRemote &&
					o.scheme === W.file &&
					(o = y.from({ scheme: W.vscodeRemote, authority: e.authority, path: o.path })),
				y.from({
					scheme: W.https,
					authority: `${o.scheme}+${tB(o.authority)}.${eB}`,
					path: o.path,
					fragment: o.fragment,
					query: o.query,
				}))
}
function tB(o) {
	return o.replace(/./g, (e) => {
		let t = e.charCodeAt(0)
		return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || (t >= 48 && t <= 57)
			? e
			: "-" + t.toString(16).padStart(4, "0")
	})
}
var FC = class {
	constructor(e, t, n) {
		this._proxy = e
		this._editors = t
		this._remoteInfo = n
		this._handlePool = 0
		this._disposables = new Q()
		this._insets = new Map()
		this._disposables.add(
			t.onDidChangeVisibleTextEditors(() => {
				let r = t.getVisibleTextEditors()
				for (let i of this._insets.values()) r.indexOf(i.editor) < 0 && i.inset.dispose()
			}),
		)
	}
	dispose() {
		this._insets.forEach((e) => e.inset.dispose()), this._disposables.dispose()
	}
	createWebviewEditorInset(e, t, n, r, i) {
		let s
		for (let f of this._editors.getVisibleTextEditors(!0))
			if (f.value === e) {
				s = f
				break
			}
		if (!s) throw new Error("not a visible editor")
		let a = this,
			l = this._handlePool++,
			d = new E(),
			c = new E(),
			u = new (class {
				constructor() {
					this._html = ""
					this._options = Object.create(null)
				}
				asWebviewUri(f) {
					return hl(f, a._remoteInfo)
				}
				get cspSource() {
					return ph
				}
				set options(f) {
					;(this._options = f), a._proxy.$setOptions(l, f)
				}
				get options() {
					return this._options
				}
				set html(f) {
					;(this._html = f), a._proxy.$setHtml(l, f)
				}
				get html() {
					return this._html
				}
				get onDidReceiveMessage() {
					return d.event
				}
				postMessage(f) {
					return a._proxy.$postMessage(l, f)
				}
			})(),
			m = new (class {
				constructor() {
					this.editor = e
					this.line = t
					this.height = n
					this.webview = u
					this.onDidDispose = c.event
				}
				dispose() {
					a._insets.has(l) &&
						(a._insets.delete(l), a._proxy.$disposeEditorInset(l), c.fire(), c.dispose(), d.dispose())
				}
			})()
		return (
			this._proxy.$createEditorInset(
				l,
				s.id,
				s.value.document.uri,
				t + 1,
				n,
				r || {},
				i.identifier,
				i.extensionLocation,
			),
			this._insets.set(l, { editor: e, inset: m, onDidReceiveMessage: d }),
			m
		)
	}
	$onDidDispose(e) {
		let t = this._insets.get(e)
		t && t.inset.dispose()
	}
	$onDidReceiveMessage(e, t) {
		this._insets.get(e)?.onDidReceiveMessage.fire(t)
	}
}
var NC = class o {
	constructor(e) {
		this.providers = new Map()
		this._proxy = e.getProxy(N.MainThreadCodeMapper)
	}
	static {
		this._providerHandlePool = 0
	}
	async $mapCode(e, t, n) {
		let r = this.providers.get(e)
		if (!r) throw new Error(`Received request to map code for unknown provider handle ${e}`)
		let i = {
				textEdit: (l, d) => {
					;(d = an(d)), this._proxy.$handleProgress(t.requestId, { uri: l, edits: d.map(on.from) })
				},
				notebookEdit: (l, d) => {
					;(d = an(d)), this._proxy.$handleProgress(t.requestId, { uri: l, edits: d.map(px.from) })
				},
			},
			s = {
				location: t.location,
				chatRequestId: t.chatRequestId,
				codeBlocks: t.codeBlocks.map((l) => ({
					code: l.code,
					resource: y.revive(l.resource),
					markdownBeforeBlock: l.markdownBeforeBlock,
				})),
			}
		return (await r.provideMappedEdits(s, i, n)) ?? null
	}
	registerMappedEditsProvider(e, t) {
		let n = o._providerHandlePool++
		return (
			this._proxy.$registerCodeMapperProvider(n, e.displayName ?? e.name),
			this.providers.set(n, t),
			{ dispose: () => this._proxy.$unregisterCodeMapperProvider(n) }
		)
	}
}
function CN(o, e, t) {
	let n = o.getProxy(N.MainThreadComments)
	class r {
		constructor() {
			this._commentControllers = new Map()
			this._commentControllersByExtension = new On()
			e.registerArgumentProcessor({
				processArgument: (g) => {
					if (g && g.$mid === 6) {
						let I = this._commentControllers.get(g.handle)
						return I ? I.value : g
					} else if (g && g.$mid === 7) {
						let I = g,
							C = this._commentControllers.get(I.commentControlHandle)
						if (!C) return I
						let T = C.getCommentThread(I.commentThreadHandle)
						return T ? T.value : I
					} else if (g && (g.$mid === 9 || g.$mid === 8)) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						return C ? (g.$mid === 8 ? C.value : { thread: C.value, text: g.text }) : g
					} else if (g && g.$mid === 10) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						if (!C) return g
						let T = g.commentUniqueId,
							w = C.getCommentByUniqueId(T)
						return w || g
					} else if (g && g.$mid === 11) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						if (!C) return g
						let T = g.text,
							w = g.commentUniqueId,
							L = C.getCommentByUniqueId(w)
						return L ? (typeof L.body == "string" ? (L.body = T) : (L.body = new en(T)), L) : g
					}
					return g
				},
			})
		}
		static {
			this.handlePool = 0
		}
		createCommentController(g, I, C) {
			let T = r.handlePool++,
				w = new s(g, T, I, C)
			this._commentControllers.set(w.handle, w)
			let L = this._commentControllersByExtension.get(g.identifier) || []
			return L.push(w), this._commentControllersByExtension.set(g.identifier, L), w.value
		}
		async $createCommentThreadTemplate(g, I, C, T) {
			let w = this._commentControllers.get(g)
			w && w.$createCommentThreadTemplate(I, C, T)
		}
		async $setActiveComment(g, I) {
			let C = this._commentControllers.get(g)
			C && C.$setActiveComment(I ?? void 0)
		}
		async $updateCommentThreadTemplate(g, I, C) {
			let T = this._commentControllers.get(g)
			T && T.$updateCommentThreadTemplate(I, C)
		}
		$deleteCommentThread(g, I) {
			this._commentControllers.get(g)?.$deleteCommentThread(I)
		}
		async $updateCommentThread(g, I, C) {
			this._commentControllers.get(g)?.$updateCommentThread(I, C)
		}
		async $provideCommentingRanges(g, I, C) {
			let T = this._commentControllers.get(g)
			if (!T || !T.commentingRangeProvider) return Promise.resolve(void 0)
			let w = await t.ensureDocumentData(y.revive(I))
			return Jt(async () => {
				let L = await T.commentingRangeProvider?.provideCommentingRanges(w.document, C),
					A
				return (
					Array.isArray(L)
						? (A = { ranges: L, fileComments: !1 })
						: L
							? (A = { ranges: L.ranges || [], fileComments: L.enableFileComments || !1 })
							: (A = L ?? void 0),
					A
				)
			}).then((L) => {
				let A
				return L && (A = { ranges: L.ranges.map((J) => H.from(J)), fileComments: L.fileComments }), A
			})
		}
		$toggleReaction(g, I, C, T, w) {
			let L = this._commentControllers.get(g)
			return !L || !L.reactionHandler
				? Promise.resolve(void 0)
				: Jt(() => {
						let A = L.getCommentThread(I)
						if (A) {
							let J = A.getCommentByUniqueId(T.uniqueIdInThread)
							if (L !== void 0 && J && L.reactionHandler) return L.reactionHandler(J, d(w))
						}
						return Promise.resolve(void 0)
					})
		}
	}
	let f = class f {
		constructor(g, I, C, T, w, L, A, J, ne) {
			this._commentControllerHandle = I
			this._id = C
			this._uri = T
			this._range = w
			this._comments = L
			this.extensionDescription = A
			this._isTemplate = J
			this.handle = f._handlePool++
			this.commentHandle = 0
			this.modifications = Object.create(null)
			this._onDidUpdateCommentThread = new E()
			this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event
			this._canReply = !0
			this._commentsMap = new Map()
			this._acceptInputDisposables = new Dn()
			;(this._acceptInputDisposables.value = new Q()),
				this._id === void 0 && (this._id = `${g}.${this.handle}`),
				n.$createCommentThread(
					I,
					this.handle,
					this._id,
					this._uri,
					H.from(this._range),
					this._comments.map((Y) => a(this, Y, this._commentsMap, this.extensionDescription)),
					A.identifier,
					this._isTemplate,
					ne,
				),
				(this._localDisposables = []),
				(this._isDiposed = !1),
				this._localDisposables.push(
					this.onDidUpdateCommentThread(() => {
						this.eventuallyUpdateCommentThread()
					}),
				),
				this._localDisposables.push({
					dispose: () => {
						n.$deleteCommentThread(I, this.handle)
					},
				})
			let oe = this
			this.value = {
				get uri() {
					return oe.uri
				},
				get range() {
					return oe.range
				},
				set range(Y) {
					oe.range = Y
				},
				get comments() {
					return oe.comments
				},
				set comments(Y) {
					oe.comments = Y
				},
				get collapsibleState() {
					return oe.collapsibleState
				},
				set collapsibleState(Y) {
					oe.collapsibleState = Y
				},
				get canReply() {
					return oe.canReply
				},
				set canReply(Y) {
					oe.canReply = Y
				},
				get contextValue() {
					return oe.contextValue
				},
				set contextValue(Y) {
					oe.contextValue = Y
				},
				get label() {
					return oe.label
				},
				set label(Y) {
					oe.label = Y
				},
				get state() {
					return oe.state
				},
				set state(Y) {
					oe.state = Y
				},
				reveal: (Y, j) => oe.reveal(Y, j),
				hide: () => oe.hide(),
				dispose: () => {
					oe.dispose()
				},
			}
		}
		static {
			this._handlePool = 0
		}
		set threadId(g) {
			this._id = g
		}
		get threadId() {
			return this._id
		}
		get id() {
			return this._id
		}
		get resource() {
			return this._uri
		}
		get uri() {
			return this._uri
		}
		set range(g) {
			;((g === void 0) != (this._range === void 0) || !g || !this._range || !g.isEqual(this._range)) &&
				((this._range = g), (this.modifications.range = g), this._onDidUpdateCommentThread.fire())
		}
		get range() {
			return this._range
		}
		set canReply(g) {
			this._canReply !== g &&
				((this._canReply = g), (this.modifications.canReply = g), this._onDidUpdateCommentThread.fire())
		}
		get canReply() {
			return this._canReply
		}
		get label() {
			return this._label
		}
		set label(g) {
			;(this._label = g), (this.modifications.label = g), this._onDidUpdateCommentThread.fire()
		}
		get contextValue() {
			return this._contextValue
		}
		set contextValue(g) {
			;(this._contextValue = g), (this.modifications.contextValue = g), this._onDidUpdateCommentThread.fire()
		}
		get comments() {
			return this._comments
		}
		set comments(g) {
			;(this._comments = g), (this.modifications.comments = g), this._onDidUpdateCommentThread.fire()
		}
		get collapsibleState() {
			return this._collapseState
		}
		set collapsibleState(g) {
			this._collapseState !== g &&
				((this._collapseState = g),
				(this.modifications.collapsibleState = g),
				this._onDidUpdateCommentThread.fire())
		}
		get state() {
			return this._state
		}
		set state(g) {
			;(this._state = g),
				typeof g == "object"
					? (M(this.extensionDescription, "commentThreadApplicability"),
						(this.modifications.state = g.resolved),
						(this.modifications.applicability = g.applicability))
					: (this.modifications.state = g),
				this._onDidUpdateCommentThread.fire()
		}
		get isDisposed() {
			return this._isDiposed
		}
		updateIsTemplate() {
			this._isTemplate && ((this._isTemplate = !1), (this.modifications.isTemplate = !1))
		}
		eventuallyUpdateCommentThread() {
			if (this._isDiposed) return
			this.updateIsTemplate(),
				this._acceptInputDisposables.value || (this._acceptInputDisposables.value = new Q())
			let g = (C) => Object.prototype.hasOwnProperty.call(this.modifications, C),
				I = {}
			g("range") && (I.range = H.from(this._range)),
				g("label") && (I.label = this.label),
				g("contextValue") && (I.contextValue = this.contextValue ?? null),
				g("comments") &&
					(I.comments = this._comments.map((C) => a(this, C, this._commentsMap, this.extensionDescription))),
				g("collapsibleState") && (I.collapseState = c(this._collapseState)),
				g("canReply") && (I.canReply = this.canReply),
				g("state") && (I.state = u(this._state)),
				g("applicability") && (I.applicability = m(this._state)),
				g("isTemplate") && (I.isTemplate = this._isTemplate),
				(this.modifications = {}),
				n.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, I)
		}
		getCommentByUniqueId(g) {
			for (let I of this._commentsMap) {
				let C = I[0],
					T = I[1]
				if (g === T) return C
			}
		}
		async reveal(g, I) {
			M(this.extensionDescription, "commentReveal")
			let C
			g && g.body !== void 0 ? (C = g) : (I = I ?? g)
			let T = C ? this._commentsMap.get(C) : void 0
			T ??= this._commentsMap.get(this._comments[0])
			let w = !0,
				L = !1
			return (
				I?.focus === 1 ? ((L = !0), (w = !1)) : I?.focus === 2 && (w = !1),
				n.$revealCommentThread(this._commentControllerHandle, this.handle, T, {
					preserveFocus: w,
					focusReply: L,
				})
			)
		}
		async hide() {
			return n.$hideCommentThread(this._commentControllerHandle, this.handle)
		}
		dispose() {
			;(this._isDiposed = !0),
				this._acceptInputDisposables.dispose(),
				this._localDisposables.forEach((g) => g.dispose())
		}
	}
	R([Ml(100)], f.prototype, "eventuallyUpdateCommentThread", 1)
	let i = f
	class s {
		constructor(g, I, C, T) {
			this._extension = g
			this._handle = I
			this._id = C
			this._label = T
			this._threads = new Map()
			n.$registerCommentController(this.handle, C, T, this._extension.identifier.value)
			let w = this
			;(this.value = Object.freeze({
				id: w.id,
				label: w.label,
				get options() {
					return w.options
				},
				set options(L) {
					w.options = L
				},
				get commentingRangeProvider() {
					return w.commentingRangeProvider
				},
				set commentingRangeProvider(L) {
					w.commentingRangeProvider = L
				},
				get reactionHandler() {
					return w.reactionHandler
				},
				set reactionHandler(L) {
					w.reactionHandler = L
				},
				get activeCommentThread() {
					return w.activeCommentThread
				},
				createCommentThread(L, A, J) {
					return w.createCommentThread(L, A, J).value
				},
				dispose: () => {
					w.dispose()
				},
			})),
				(this._localDisposables = []),
				this._localDisposables.push({
					dispose: () => {
						n.$unregisterCommentController(this.handle)
					},
				})
		}
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		get handle() {
			return this._handle
		}
		get commentingRangeProvider() {
			return this._commentingRangeProvider
		}
		set commentingRangeProvider(g) {
			;(this._commentingRangeProvider = g),
				g?.resourceHints && M(this._extension, "commentingRangeHint"),
				n.$updateCommentingRanges(this.handle, g?.resourceHints)
		}
		get reactionHandler() {
			return this._reactionHandler
		}
		set reactionHandler(g) {
			;(this._reactionHandler = g), n.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!g })
		}
		get options() {
			return this._options
		}
		set options(g) {
			;(this._options = g), n.$updateCommentControllerFeatures(this.handle, { options: this._options })
		}
		get activeComment() {
			return M(this._extension, "activeComment"), this._activeComment
		}
		get activeCommentThread() {
			return M(this._extension, "activeComment"), this._activeThread?.value
		}
		createCommentThread(g, I, C) {
			let T = new i(this.id, this.handle, void 0, g, I, C, this._extension, !1)
			return this._threads.set(T.handle, T), T
		}
		$setActiveComment(g) {
			if (!g) {
				;(this._activeComment = void 0), (this._activeThread = void 0)
				return
			}
			let I = this._threads.get(g.commentThreadHandle)
			I &&
				((this._activeComment = g.uniqueIdInThread ? I.getCommentByUniqueId(g.uniqueIdInThread) : void 0),
				(this._activeThread = I))
		}
		$createCommentThreadTemplate(g, I, C) {
			let T = new i(this.id, this.handle, void 0, y.revive(g), H.to(I), [], this._extension, !0, C)
			return (T.collapsibleState = 1), this._threads.set(T.handle, T), T
		}
		$updateCommentThreadTemplate(g, I) {
			let C = this._threads.get(g)
			C && (C.range = H.to(I))
		}
		$updateCommentThread(g, I) {
			let C = this._threads.get(g)
			if (!C) return
			;((w) => Object.prototype.hasOwnProperty.call(I, w))("collapseState") &&
				(C.collapsibleState = c(I.collapseState))
		}
		$deleteCommentThread(g) {
			this._threads.get(g)?.dispose(), this._threads.delete(g)
		}
		getCommentThread(g) {
			return this._threads.get(g)
		}
		dispose() {
			this._threads.forEach((g) => {
				g.dispose()
			}),
				this._localDisposables.forEach((g) => g.dispose())
		}
	}
	function a(h, g, I, C) {
		let T = I.get(g)
		return (
			T || ((T = ++h.commentHandle), I.set(g, T)),
			g.state !== void 0 && M(C, "commentsDraftState"),
			g.reactions?.some((w) => w.reactors !== void 0) && M(C, "commentReactor"),
			{
				mode: g.mode,
				contextValue: g.contextValue,
				uniqueIdInThread: T,
				body: typeof g.body == "string" ? g.body : Ce.from(g.body),
				userName: g.author.name,
				userIconPath: g.author.iconPath,
				label: g.label,
				commentReactions: g.reactions ? g.reactions.map((w) => l(w)) : void 0,
				state: g.state,
				timestamp: g.timestamp?.toJSON(),
			}
		)
	}
	function l(h) {
		return {
			label: h.label,
			iconPath: h.iconPath ? vg(h.iconPath) : void 0,
			count: h.count,
			hasReacted: h.authorHasReacted,
			reactors:
				h.reactors && h.reactors.length > 0 && typeof h.reactors[0] != "string"
					? h.reactors.map((g) => g.name)
					: h.reactors,
		}
	}
	function d(h) {
		return {
			label: h.label || "",
			count: h.count || 0,
			iconPath: h.iconPath ? y.revive(h.iconPath) : "",
			authorHasReacted: h.hasReacted || !1,
			reactors: h.reactors?.map((g) => ({ name: g })),
		}
	}
	function c(h) {
		if (h !== void 0)
			switch (h) {
				case 1:
					return 1
				case 0:
					return 0
			}
		return 0
	}
	function u(h) {
		let g
		if ((typeof h == "object" ? (g = h.resolved) : (g = h), g !== void 0))
			switch (g) {
				case 0:
					return 0
				case 1:
					return 1
			}
		return 0
	}
	function m(h) {
		let g
		if ((typeof h == "object" && (g = h.applicability), g !== void 0))
			switch (g) {
				case 0:
					return 0
				case 1:
					return 1
			}
		return 0
	}
	return new r()
}
var UC = {},
	ot = { exports: UC }
;(function (o, e) {
	if (typeof UC == "object" && typeof ot == "object") ot.exports = e()
	else if (typeof define == "function" && define.amd) define([], e)
	else {
		var t = e()
		for (var n in t) (typeof UC == "object" ? UC : o)[n] = t[n]
	}
})(typeof self < "u" ? self : void 0, function () {
	return (function (o) {
		var e = {}
		function t(n) {
			if (e[n]) return e[n].exports
			var r = (e[n] = { i: n, l: !1, exports: {} })
			return o[n].call(r.exports, r, r.exports, t), (r.l = !0), r.exports
		}
		return (
			(t.m = o),
			(t.c = e),
			(t.d = function (n, r, i) {
				t.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: i })
			}),
			(t.r = function (n) {
				typeof Symbol < "u" &&
					Symbol.toStringTag &&
					Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }),
					Object.defineProperty(n, "__esModule", { value: !0 })
			}),
			(t.t = function (n, r) {
				if ((1 & r && (n = t(n)), 8 & r || (4 & r && typeof n == "object" && n && n.__esModule))) return n
				var i = Object.create(null)
				if (
					(t.r(i),
					Object.defineProperty(i, "default", { enumerable: !0, value: n }),
					2 & r && typeof n != "string")
				)
					for (var s in n)
						t.d(
							i,
							s,
							function (a) {
								return n[a]
							}.bind(null, s),
						)
				return i
			}),
			(t.n = function (n) {
				var r =
					n && n.__esModule
						? function () {
								return n.default
							}
						: function () {
								return n
							}
				return t.d(r, "a", r), r
			}),
			(t.o = function (n, r) {
				return Object.prototype.hasOwnProperty.call(n, r)
			}),
			(t.p = ""),
			t((t.s = 0))
		)
	})([
		function (o, e, t) {
			;(function (n) {
				var r
				;(e = o.exports = mt),
					(r =
						typeof n == "object" && n.env && n.env.NODE_DEBUG && /\bsemver\b/i.test(n.env.NODE_DEBUG)
							? function () {
									var k = Array.prototype.slice.call(arguments, 0)
									k.unshift("SEMVER"), console.log.apply(console, k)
								}
							: function () {}),
					(e.SEMVER_SPEC_VERSION = "2.0.0")
				var i = 256,
					s = Number.MAX_SAFE_INTEGER || 9007199254740991,
					a = (e.re = []),
					l = (e.src = []),
					d = 0,
					c = d++
				l[c] = "0|[1-9]\\d*"
				var u = d++
				l[u] = "[0-9]+"
				var m = d++
				l[m] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
				var f = d++
				l[f] = "(" + l[c] + ")\\.(" + l[c] + ")\\.(" + l[c] + ")"
				var h = d++
				l[h] = "(" + l[u] + ")\\.(" + l[u] + ")\\.(" + l[u] + ")"
				var g = d++
				l[g] = "(?:" + l[c] + "|" + l[m] + ")"
				var I = d++
				l[I] = "(?:" + l[u] + "|" + l[m] + ")"
				var C = d++
				l[C] = "(?:-(" + l[g] + "(?:\\." + l[g] + ")*))"
				var T = d++
				l[T] = "(?:-?(" + l[I] + "(?:\\." + l[I] + ")*))"
				var w = d++
				l[w] = "[0-9A-Za-z-]+"
				var L = d++
				l[L] = "(?:\\+(" + l[w] + "(?:\\." + l[w] + ")*))"
				var A = d++,
					J = "v?" + l[f] + l[C] + "?" + l[L] + "?"
				l[A] = "^" + J + "$"
				var ne = "[v=\\s]*" + l[h] + l[T] + "?" + l[L] + "?",
					oe = d++
				l[oe] = "^" + ne + "$"
				var Y = d++
				l[Y] = "((?:<|>)?=?)"
				var j = d++
				l[j] = l[u] + "|x|X|\\*"
				var K = d++
				l[K] = l[c] + "|x|X|\\*"
				var qe = d++
				l[qe] =
					"[v=\\s]*(" + l[K] + ")(?:\\.(" + l[K] + ")(?:\\.(" + l[K] + ")(?:" + l[C] + ")?" + l[L] + "?)?)?"
				var Bt = d++
				l[Bt] =
					"[v=\\s]*(" + l[j] + ")(?:\\.(" + l[j] + ")(?:\\.(" + l[j] + ")(?:" + l[T] + ")?" + l[L] + "?)?)?"
				var vt = d++
				l[vt] = "^" + l[Y] + "\\s*" + l[qe] + "$"
				var ae = d++
				l[ae] = "^" + l[Y] + "\\s*" + l[Bt] + "$"
				var Z = d++
				l[Z] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])"
				var se = d++
				l[se] = "(?:~>?)"
				var ee = d++
				;(l[ee] = "(\\s*)" + l[se] + "\\s+"), (a[ee] = new RegExp(l[ee], "g"))
				var fe = d++
				l[fe] = "^" + l[se] + l[qe] + "$"
				var Ae = d++
				l[Ae] = "^" + l[se] + l[Bt] + "$"
				var he = d++
				l[he] = "(?:\\^)"
				var le = d++
				;(l[le] = "(\\s*)" + l[he] + "\\s+"), (a[le] = new RegExp(l[le], "g"))
				var Et = d++
				l[Et] = "^" + l[he] + l[qe] + "$"
				var _t = d++
				l[_t] = "^" + l[he] + l[Bt] + "$"
				var Se = d++
				l[Se] = "^" + l[Y] + "\\s*(" + ne + ")$|^$"
				var En = d++
				l[En] = "^" + l[Y] + "\\s*(" + J + ")$|^$"
				var Ft = d++
				;(l[Ft] = "(\\s*)" + l[Y] + "\\s*(" + ne + "|" + l[qe] + ")"), (a[Ft] = new RegExp(l[Ft], "g"))
				var to = d++
				l[to] = "^\\s*(" + l[qe] + ")\\s+-\\s+(" + l[qe] + ")\\s*$"
				var nc = d++
				l[nc] = "^\\s*(" + l[Bt] + ")\\s+-\\s+(" + l[Bt] + ")\\s*$"
				var ti = d++
				l[ti] = "(<|>)?=?\\s*\\*"
				for (var no = 0; no < 35; no++) r(no, l[no]), a[no] || (a[no] = new RegExp(l[no]))
				function $e(k, U) {
					if (k instanceof mt) return k
					if (typeof k != "string" || k.length > i || !(U ? a[oe] : a[A]).test(k)) return null
					try {
						return new mt(k, U)
					} catch {
						return null
					}
				}
				function mt(k, U) {
					if (k instanceof mt) {
						if (k.loose === U) return k
						k = k.version
					} else if (typeof k != "string") throw new TypeError("Invalid Version: " + k)
					if (k.length > i) throw new TypeError("version is longer than " + i + " characters")
					if (!(this instanceof mt)) return new mt(k, U)
					r("SemVer", k, U), (this.loose = U)
					var B = k.trim().match(U ? a[oe] : a[A])
					if (!B) throw new TypeError("Invalid Version: " + k)
					if (
						((this.raw = k),
						(this.major = +B[1]),
						(this.minor = +B[2]),
						(this.patch = +B[3]),
						this.major > s || this.major < 0)
					)
						throw new TypeError("Invalid major version")
					if (this.minor > s || this.minor < 0) throw new TypeError("Invalid minor version")
					if (this.patch > s || this.patch < 0) throw new TypeError("Invalid patch version")
					B[4]
						? (this.prerelease = B[4].split(".").map(function (ve) {
								if (/^[0-9]+$/.test(ve)) {
									var Me = +ve
									if (Me >= 0 && Me < s) return Me
								}
								return ve
							}))
						: (this.prerelease = []),
						(this.build = B[5] ? B[5].split(".") : []),
						this.format()
				}
				;(e.parse = $e),
					(e.valid = function (k, U) {
						var B = $e(k, U)
						return B ? B.version : null
					}),
					(e.clean = function (k, U) {
						var B = $e(k.trim().replace(/^[=v]+/, ""), U)
						return B ? B.version : null
					}),
					(e.SemVer = mt),
					(mt.prototype.format = function () {
						return (
							(this.version = this.major + "." + this.minor + "." + this.patch),
							this.prerelease.length && (this.version += "-" + this.prerelease.join(".")),
							this.version
						)
					}),
					(mt.prototype.toString = function () {
						return this.version
					}),
					(mt.prototype.compare = function (k) {
						return (
							r("SemVer.compare", this.version, this.loose, k),
							k instanceof mt || (k = new mt(k, this.loose)),
							this.compareMain(k) || this.comparePre(k)
						)
					}),
					(mt.prototype.compareMain = function (k) {
						return (
							k instanceof mt || (k = new mt(k, this.loose)),
							Cr(this.major, k.major) || Cr(this.minor, k.minor) || Cr(this.patch, k.patch)
						)
					}),
					(mt.prototype.comparePre = function (k) {
						if (
							(k instanceof mt || (k = new mt(k, this.loose)),
							this.prerelease.length && !k.prerelease.length)
						)
							return -1
						if (!this.prerelease.length && k.prerelease.length) return 1
						if (!this.prerelease.length && !k.prerelease.length) return 0
						var U = 0
						do {
							var B = this.prerelease[U],
								ve = k.prerelease[U]
							if ((r("prerelease compare", U, B, ve), B === void 0 && ve === void 0)) return 0
							if (ve === void 0) return 1
							if (B === void 0) return -1
							if (B !== ve) return Cr(B, ve)
						} while (++U)
					}),
					(mt.prototype.inc = function (k, U) {
						switch (k) {
							case "premajor":
								;(this.prerelease.length = 0),
									(this.patch = 0),
									(this.minor = 0),
									this.major++,
									this.inc("pre", U)
								break
							case "preminor":
								;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc("pre", U)
								break
							case "prepatch":
								;(this.prerelease.length = 0), this.inc("patch", U), this.inc("pre", U)
								break
							case "prerelease":
								this.prerelease.length === 0 && this.inc("patch", U), this.inc("pre", U)
								break
							case "major":
								;(this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0) || this.major++,
									(this.minor = 0),
									(this.patch = 0),
									(this.prerelease = [])
								break
							case "minor":
								;(this.patch === 0 && this.prerelease.length !== 0) || this.minor++,
									(this.patch = 0),
									(this.prerelease = [])
								break
							case "patch":
								this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
								break
							case "pre":
								if (this.prerelease.length === 0) this.prerelease = [0]
								else {
									for (var B = this.prerelease.length; --B >= 0; )
										typeof this.prerelease[B] == "number" && (this.prerelease[B]++, (B = -2))
									B === -1 && this.prerelease.push(0)
								}
								U &&
									(this.prerelease[0] === U
										? isNaN(this.prerelease[1]) && (this.prerelease = [U, 0])
										: (this.prerelease = [U, 0]))
								break
							default:
								throw new Error("invalid increment argument: " + k)
						}
						return this.format(), (this.raw = this.version), this
					}),
					(e.inc = function (k, U, B, ve) {
						typeof B == "string" && ((ve = B), (B = void 0))
						try {
							return new mt(k, B).inc(U, ve).version
						} catch {
							return null
						}
					}),
					(e.diff = function (k, U) {
						if (Vm(k, U)) return null
						var B = $e(k),
							ve = $e(U)
						if (B.prerelease.length || ve.prerelease.length) {
							for (var Me in B)
								if ((Me === "major" || Me === "minor" || Me === "patch") && B[Me] !== ve[Me])
									return "pre" + Me
							return "prerelease"
						}
						for (var Me in B)
							if ((Me === "major" || Me === "minor" || Me === "patch") && B[Me] !== ve[Me]) return Me
					}),
					(e.compareIdentifiers = Cr)
				var zh = /^[0-9]+$/
				function Cr(k, U) {
					var B = zh.test(k),
						ve = zh.test(U)
					return B && ve && ((k = +k), (U = +U)), B && !ve ? -1 : ve && !B ? 1 : k < U ? -1 : k > U ? 1 : 0
				}
				function mr(k, U, B) {
					return new mt(k, B).compare(new mt(U, B))
				}
				function Il(k, U, B) {
					return mr(k, U, B) > 0
				}
				function rc(k, U, B) {
					return mr(k, U, B) < 0
				}
				function Vm(k, U, B) {
					return mr(k, U, B) === 0
				}
				function qh(k, U, B) {
					return mr(k, U, B) !== 0
				}
				function oc(k, U, B) {
					return mr(k, U, B) >= 0
				}
				function Bm(k, U, B) {
					return mr(k, U, B) <= 0
				}
				function xl(k, U, B, ve) {
					var Me
					switch (U) {
						case "===":
							typeof k == "object" && (k = k.version),
								typeof B == "object" && (B = B.version),
								(Me = k === B)
							break
						case "!==":
							typeof k == "object" && (k = k.version),
								typeof B == "object" && (B = B.version),
								(Me = k !== B)
							break
						case "":
						case "=":
						case "==":
							Me = Vm(k, B, ve)
							break
						case "!=":
							Me = qh(k, B, ve)
							break
						case ">":
							Me = Il(k, B, ve)
							break
						case ">=":
							Me = oc(k, B, ve)
							break
						case "<":
							Me = rc(k, B, ve)
							break
						case "<=":
							Me = Bm(k, B, ve)
							break
						default:
							throw new TypeError("Invalid operator: " + U)
					}
					return Me
				}
				function Sr(k, U) {
					if (k instanceof Sr) {
						if (k.loose === U) return k
						k = k.value
					}
					if (!(this instanceof Sr)) return new Sr(k, U)
					r("comparator", k, U),
						(this.loose = U),
						this.parse(k),
						this.semver === Bi ? (this.value = "") : (this.value = this.operator + this.semver.version),
						r("comp", this)
				}
				;(e.rcompareIdentifiers = function (k, U) {
					return Cr(U, k)
				}),
					(e.major = function (k, U) {
						return new mt(k, U).major
					}),
					(e.minor = function (k, U) {
						return new mt(k, U).minor
					}),
					(e.patch = function (k, U) {
						return new mt(k, U).patch
					}),
					(e.compare = mr),
					(e.compareLoose = function (k, U) {
						return mr(k, U, !0)
					}),
					(e.rcompare = function (k, U, B) {
						return mr(U, k, B)
					}),
					(e.sort = function (k, U) {
						return k.sort(function (B, ve) {
							return e.compare(B, ve, U)
						})
					}),
					(e.rsort = function (k, U) {
						return k.sort(function (B, ve) {
							return e.rcompare(B, ve, U)
						})
					}),
					(e.gt = Il),
					(e.lt = rc),
					(e.eq = Vm),
					(e.neq = qh),
					(e.gte = oc),
					(e.lte = Bm),
					(e.cmp = xl),
					(e.Comparator = Sr)
				var Bi = {}
				function Nt(k, U) {
					if (k instanceof Nt) return k.loose === U ? k : new Nt(k.raw, U)
					if (k instanceof Sr) return new Nt(k.value, U)
					if (!(this instanceof Nt)) return new Nt(k, U)
					if (
						((this.loose = U),
						(this.raw = k),
						(this.set = k
							.split(/\s*\|\|\s*/)
							.map(function (B) {
								return this.parseRange(B.trim())
							}, this)
							.filter(function (B) {
								return B.length
							})),
						!this.set.length)
					)
						throw new TypeError("Invalid SemVer Range: " + k)
					this.format()
				}
				function qn(k) {
					return !k || k.toLowerCase() === "x" || k === "*"
				}
				function MT(k, U, B, ve, Me, hn, it, nr, tn, Mn, Tr, jt, wn) {
					return (
						(U = qn(B) ? "" : qn(ve) ? ">=" + B + ".0.0" : qn(Me) ? ">=" + B + "." + ve + ".0" : ">=" + U) +
						" " +
						(nr = qn(tn)
							? ""
							: qn(Mn)
								? "<" + (+tn + 1) + ".0.0"
								: qn(Tr)
									? "<" + tn + "." + (+Mn + 1) + ".0"
									: jt
										? "<=" + tn + "." + Mn + "." + Tr + "-" + jt
										: "<=" + nr)
					).trim()
				}
				function Js(k, U) {
					for (var B = 0; B < k.length; B++) if (!k[B].test(U)) return !1
					if (U.prerelease.length) {
						for (B = 0; B < k.length; B++)
							if ((r(k[B].semver), k[B].semver !== Bi && k[B].semver.prerelease.length > 0)) {
								var ve = k[B].semver
								if (ve.major === U.major && ve.minor === U.minor && ve.patch === U.patch) return !0
							}
						return !1
					}
					return !0
				}
				function ic(k, U, B) {
					try {
						U = new Nt(U, B)
					} catch {
						return !1
					}
					return U.test(k)
				}
				function $m(k, U, B, ve) {
					var Me, hn, it, nr, tn
					switch (((k = new mt(k, ve)), (U = new Nt(U, ve)), B)) {
						case ">":
							;(Me = Il), (hn = Bm), (it = rc), (nr = ">"), (tn = ">=")
							break
						case "<":
							;(Me = rc), (hn = oc), (it = Il), (nr = "<"), (tn = "<=")
							break
						default:
							throw new TypeError('Must provide a hilo val of "<" or ">"')
					}
					if (ic(k, U, ve)) return !1
					for (var Mn = 0; Mn < U.set.length; ++Mn) {
						var Tr = U.set[Mn],
							jt = null,
							wn = null
						if (
							(Tr.forEach(function (P) {
								P.semver === Bi && (P = new Sr(">=0.0.0")),
									(jt = jt || P),
									(wn = wn || P),
									Me(P.semver, jt.semver, ve) ? (jt = P) : it(P.semver, wn.semver, ve) && (wn = P)
							}),
							jt.operator === nr ||
								jt.operator === tn ||
								((!wn.operator || wn.operator === nr) && hn(k, wn.semver)) ||
								(wn.operator === tn && it(k, wn.semver)))
						)
							return !1
					}
					return !0
				}
				;(Sr.prototype.parse = function (k) {
					var U = this.loose ? a[Se] : a[En],
						B = k.match(U)
					if (!B) throw new TypeError("Invalid comparator: " + k)
					;(this.operator = B[1]),
						this.operator === "=" && (this.operator = ""),
						B[2] ? (this.semver = new mt(B[2], this.loose)) : (this.semver = Bi)
				}),
					(Sr.prototype.toString = function () {
						return this.value
					}),
					(Sr.prototype.test = function (k) {
						return (
							r("Comparator.test", k, this.loose),
							this.semver === Bi ||
								(typeof k == "string" && (k = new mt(k, this.loose)),
								xl(k, this.operator, this.semver, this.loose))
						)
					}),
					(Sr.prototype.intersects = function (k, U) {
						if (!(k instanceof Sr)) throw new TypeError("a Comparator is required")
						var B
						if (this.operator === "") return (B = new Nt(k.value, U)), ic(this.value, B, U)
						if (k.operator === "") return (B = new Nt(this.value, U)), ic(k.semver, B, U)
						var ve = !(
								(this.operator !== ">=" && this.operator !== ">") ||
								(k.operator !== ">=" && k.operator !== ">")
							),
							Me = !(
								(this.operator !== "<=" && this.operator !== "<") ||
								(k.operator !== "<=" && k.operator !== "<")
							),
							hn = this.semver.version === k.semver.version,
							it = !(
								(this.operator !== ">=" && this.operator !== "<=") ||
								(k.operator !== ">=" && k.operator !== "<=")
							),
							nr =
								xl(this.semver, "<", k.semver, U) &&
								(this.operator === ">=" || this.operator === ">") &&
								(k.operator === "<=" || k.operator === "<"),
							tn =
								xl(this.semver, ">", k.semver, U) &&
								(this.operator === "<=" || this.operator === "<") &&
								(k.operator === ">=" || k.operator === ">")
						return ve || Me || (hn && it) || nr || tn
					}),
					(e.Range = Nt),
					(Nt.prototype.format = function () {
						return (
							(this.range = this.set
								.map(function (k) {
									return k.join(" ").trim()
								})
								.join("||")
								.trim()),
							this.range
						)
					}),
					(Nt.prototype.toString = function () {
						return this.range
					}),
					(Nt.prototype.parseRange = function (k) {
						var U = this.loose
						;(k = k.trim()), r("range", k, U)
						var B = U ? a[nc] : a[to]
						;(k = k.replace(B, MT)),
							r("hyphen replace", k),
							(k = k.replace(a[Ft], "$1$2$3")),
							r("comparator trim", k, a[Ft]),
							(k = (k = (k = k.replace(a[ee], "$1~")).replace(a[le], "$1^")).split(/\s+/).join(" "))
						var ve = U ? a[Se] : a[En],
							Me = k
								.split(" ")
								.map(function (hn) {
									return (function (it, nr) {
										return (
											r("comp", it),
											(it = (function (tn, Mn) {
												return tn
													.trim()
													.split(/\s+/)
													.map(function (Tr) {
														return (function (jt, wn) {
															r("caret", jt, wn)
															var P = wn ? a[_t] : a[Et]
															return jt.replace(P, function (vn, Ne, X, xe, Ut) {
																var Pn
																return (
																	r("caret", jt, vn, Ne, X, xe, Ut),
																	qn(Ne)
																		? (Pn = "")
																		: qn(X)
																			? (Pn =
																					">=" +
																					Ne +
																					".0.0 <" +
																					(+Ne + 1) +
																					".0.0")
																			: qn(xe)
																				? (Pn =
																						Ne === "0"
																							? ">=" +
																								Ne +
																								"." +
																								X +
																								".0 <" +
																								Ne +
																								"." +
																								(+X + 1) +
																								".0"
																							: ">=" +
																								Ne +
																								"." +
																								X +
																								".0 <" +
																								(+Ne + 1) +
																								".0.0")
																				: Ut
																					? (r("replaceCaret pr", Ut),
																						Ut.charAt(0) !== "-" &&
																							(Ut = "-" + Ut),
																						(Pn =
																							Ne === "0"
																								? X === "0"
																									? ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										Ut +
																										" <" +
																										Ne +
																										"." +
																										X +
																										"." +
																										(+xe + 1)
																									: ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										Ut +
																										" <" +
																										Ne +
																										"." +
																										(+X + 1) +
																										".0"
																								: ">=" +
																									Ne +
																									"." +
																									X +
																									"." +
																									xe +
																									Ut +
																									" <" +
																									(+Ne + 1) +
																									".0.0"))
																					: (r("no pr"),
																						(Pn =
																							Ne === "0"
																								? X === "0"
																									? ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										" <" +
																										Ne +
																										"." +
																										X +
																										"." +
																										(+xe + 1)
																									: ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										" <" +
																										Ne +
																										"." +
																										(+X + 1) +
																										".0"
																								: ">=" +
																									Ne +
																									"." +
																									X +
																									"." +
																									xe +
																									" <" +
																									(+Ne + 1) +
																									".0.0")),
																	r("caret return", Pn),
																	Pn
																)
															})
														})(Tr, Mn)
													})
													.join(" ")
											})(it, nr)),
											r("caret", it),
											(it = (function (tn, Mn) {
												return tn
													.trim()
													.split(/\s+/)
													.map(function (Tr) {
														return (function (jt, wn) {
															var P = wn ? a[Ae] : a[fe]
															return jt.replace(P, function (vn, Ne, X, xe, Ut) {
																var Pn
																return (
																	r("tilde", jt, vn, Ne, X, xe, Ut),
																	qn(Ne)
																		? (Pn = "")
																		: qn(X)
																			? (Pn =
																					">=" +
																					Ne +
																					".0.0 <" +
																					(+Ne + 1) +
																					".0.0")
																			: qn(xe)
																				? (Pn =
																						">=" +
																						Ne +
																						"." +
																						X +
																						".0 <" +
																						Ne +
																						"." +
																						(+X + 1) +
																						".0")
																				: Ut
																					? (r("replaceTilde pr", Ut),
																						Ut.charAt(0) !== "-" &&
																							(Ut = "-" + Ut),
																						(Pn =
																							">=" +
																							Ne +
																							"." +
																							X +
																							"." +
																							xe +
																							Ut +
																							" <" +
																							Ne +
																							"." +
																							(+X + 1) +
																							".0"))
																					: (Pn =
																							">=" +
																							Ne +
																							"." +
																							X +
																							"." +
																							xe +
																							" <" +
																							Ne +
																							"." +
																							(+X + 1) +
																							".0"),
																	r("tilde return", Pn),
																	Pn
																)
															})
														})(Tr, Mn)
													})
													.join(" ")
											})(it, nr)),
											r("tildes", it),
											(it = (function (tn, Mn) {
												return (
													r("replaceXRanges", tn, Mn),
													tn
														.split(/\s+/)
														.map(function (Tr) {
															return (function (jt, wn) {
																jt = jt.trim()
																var P = wn ? a[ae] : a[vt]
																return jt.replace(P, function (vn, Ne, X, xe, Ut, Pn) {
																	r("xRange", jt, vn, Ne, X, xe, Ut, Pn)
																	var zm = qn(X),
																		Cl = zm || qn(xe),
																		ni = Cl || qn(Ut)
																	return (
																		Ne === "=" && ni && (Ne = ""),
																		zm
																			? (vn =
																					Ne === ">" || Ne === "<"
																						? "<0.0.0"
																						: "*")
																			: Ne && ni
																				? (Cl && (xe = 0),
																					ni && (Ut = 0),
																					Ne === ">"
																						? ((Ne = ">="),
																							Cl
																								? ((X = +X + 1),
																									(xe = 0),
																									(Ut = 0))
																								: ni &&
																									((xe = +xe + 1),
																									(Ut = 0)))
																						: Ne === "<=" &&
																							((Ne = "<"),
																							Cl
																								? (X = +X + 1)
																								: (xe = +xe + 1)),
																					(vn = Ne + X + "." + xe + "." + Ut))
																				: Cl
																					? (vn =
																							">=" +
																							X +
																							".0.0 <" +
																							(+X + 1) +
																							".0.0")
																					: ni &&
																						(vn =
																							">=" +
																							X +
																							"." +
																							xe +
																							".0 <" +
																							X +
																							"." +
																							(+xe + 1) +
																							".0"),
																		r("xRange return", vn),
																		vn
																	)
																})
															})(Tr, Mn)
														})
														.join(" ")
												)
											})(it, nr)),
											r("xrange", it),
											(it = (function (tn, Mn) {
												return r("replaceStars", tn, Mn), tn.trim().replace(a[ti], "")
											})(it, nr)),
											r("stars", it),
											it
										)
									})(hn, U)
								})
								.join(" ")
								.split(/\s+/)
						return (
							this.loose &&
								(Me = Me.filter(function (hn) {
									return !!hn.match(ve)
								})),
							(Me = Me.map(function (hn) {
								return new Sr(hn, U)
							}))
						)
					}),
					(Nt.prototype.intersects = function (k, U) {
						if (!(k instanceof Nt)) throw new TypeError("a Range is required")
						return this.set.some(function (B) {
							return B.every(function (ve) {
								return k.set.some(function (Me) {
									return Me.every(function (hn) {
										return ve.intersects(hn, U)
									})
								})
							})
						})
					}),
					(e.toComparators = function (k, U) {
						return new Nt(k, U).set.map(function (B) {
							return B.map(function (ve) {
								return ve.value
							})
								.join(" ")
								.trim()
								.split(" ")
						})
					}),
					(Nt.prototype.test = function (k) {
						if (!k) return !1
						typeof k == "string" && (k = new mt(k, this.loose))
						for (var U = 0; U < this.set.length; U++) if (Js(this.set[U], k)) return !0
						return !1
					}),
					(e.satisfies = ic),
					(e.maxSatisfying = function (k, U, B) {
						var ve = null,
							Me = null
						try {
							var hn = new Nt(U, B)
						} catch {
							return null
						}
						return (
							k.forEach(function (it) {
								hn.test(it) && ((ve && Me.compare(it) !== -1) || (Me = new mt((ve = it), B)))
							}),
							ve
						)
					}),
					(e.minSatisfying = function (k, U, B) {
						var ve = null,
							Me = null
						try {
							var hn = new Nt(U, B)
						} catch {
							return null
						}
						return (
							k.forEach(function (it) {
								hn.test(it) && ((ve && Me.compare(it) !== 1) || (Me = new mt((ve = it), B)))
							}),
							ve
						)
					}),
					(e.validRange = function (k, U) {
						try {
							return new Nt(k, U).range || "*"
						} catch {
							return null
						}
					}),
					(e.ltr = function (k, U, B) {
						return $m(k, U, "<", B)
					}),
					(e.gtr = function (k, U, B) {
						return $m(k, U, ">", B)
					}),
					(e.outside = $m),
					(e.prerelease = function (k, U) {
						var B = $e(k, U)
						return B && B.prerelease.length ? B.prerelease : null
					}),
					(e.intersects = function (k, U, B) {
						return (k = new Nt(k, B)), (U = new Nt(U, B)), k.intersects(U)
					}),
					(e.coerce = function (k) {
						if (k instanceof mt) return k
						if (typeof k != "string") return null
						var U = k.match(a[Z])
						return U == null ? null : $e((U[1] || "0") + "." + (U[2] || "0") + "." + (U[3] || "0"))
					})
			}).call(this, t(1))
		},
		function (o, e) {
			var t,
				n,
				r = (o.exports = {})
			function i() {
				throw new Error("setTimeout has not been defined")
			}
			function s() {
				throw new Error("clearTimeout has not been defined")
			}
			function a(I) {
				if (t === setTimeout) return setTimeout(I, 0)
				if ((t === i || !t) && setTimeout) return (t = setTimeout), setTimeout(I, 0)
				try {
					return t(I, 0)
				} catch {
					try {
						return t.call(null, I, 0)
					} catch {
						return t.call(this, I, 0)
					}
				}
			}
			;(function () {
				try {
					t = typeof setTimeout == "function" ? setTimeout : i
				} catch {
					t = i
				}
				try {
					n = typeof clearTimeout == "function" ? clearTimeout : s
				} catch {
					n = s
				}
			})()
			var l,
				d = [],
				c = !1,
				u = -1
			function m() {
				c && l && ((c = !1), l.length ? (d = l.concat(d)) : (u = -1), d.length && f())
			}
			function f() {
				if (!c) {
					var I = a(m)
					c = !0
					for (var C = d.length; C; ) {
						for (l = d, d = []; ++u < C; ) l && l[u].run()
						;(u = -1), (C = d.length)
					}
					;(l = null),
						(c = !1),
						(function (T) {
							if (n === clearTimeout) return clearTimeout(T)
							if ((n === s || !n) && clearTimeout) return (n = clearTimeout), clearTimeout(T)
							try {
								n(T)
							} catch {
								try {
									return n.call(null, T)
								} catch {
									return n.call(this, T)
								}
							}
						})(I)
				}
			}
			function h(I, C) {
				;(this.fun = I), (this.array = C)
			}
			function g() {}
			;(r.nextTick = function (I) {
				var C = new Array(arguments.length - 1)
				if (arguments.length > 1) for (var T = 1; T < arguments.length; T++) C[T - 1] = arguments[T]
				d.push(new h(I, C)), d.length !== 1 || c || a(f)
			}),
				(h.prototype.run = function () {
					this.fun.apply(null, this.array)
				}),
				(r.title = "browser"),
				(r.browser = !0),
				(r.env = {}),
				(r.argv = []),
				(r.version = ""),
				(r.versions = {}),
				(r.on = g),
				(r.addListener = g),
				(r.once = g),
				(r.off = g),
				(r.removeListener = g),
				(r.removeAllListeners = g),
				(r.emit = g),
				(r.prependListener = g),
				(r.prependOnceListener = g),
				(r.listeners = function (I) {
					return []
				}),
				(r.binding = function (I) {
					throw new Error("process.binding is not supported")
				}),
				(r.cwd = function () {
					return "/"
				}),
				(r.chdir = function (I) {
					throw new Error("process.chdir is not supported")
				}),
				(r.umask = function () {
					return 0
				})
		},
	])
})
var d2e = ot.exports.SEMVER_SPEC_VERSION,
	c2e = ot.exports.parse,
	nB = ot.exports.valid,
	u2e = ot.exports.coerce,
	p2e = ot.exports.clean,
	m2e = ot.exports.inc,
	f2e = ot.exports.major,
	g2e = ot.exports.minor,
	h2e = ot.exports.patch,
	v2e = ot.exports.prerelease,
	b2e = ot.exports.gt,
	y2e = ot.exports.gte,
	I2e = ot.exports.lt,
	x2e = ot.exports.lte,
	C2e = ot.exports.eq,
	S2e = ot.exports.neq,
	T2e = ot.exports.cmp,
	E2e = ot.exports.compare,
	w2e = ot.exports.rcompare,
	P2e = ot.exports.compareIdentifiers,
	_2e = ot.exports.rcompareIdentifiers,
	D2e = ot.exports.compareBuild,
	k2e = ot.exports.sort,
	R2e = ot.exports.rsort,
	A2e = ot.exports.diff,
	O2e = ot.exports.validRange,
	L2e = ot.exports.satisfies,
	M2e = ot.exports.maxSatisfying,
	F2e = ot.exports.minSatisfying,
	N2e = ot.exports.minVersion,
	U2e = ot.exports.gtr,
	H2e = ot.exports.ltr,
	W2e = ot.exports.outside,
	V2e = ot.exports.intersects,
	B2e = ot.exports.SemVer,
	$2e = ot.exports.Comparator,
	z2e = ot.exports.Range
var SN = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/,
	oB = /^-(\d{4})(\d{2})(\d{2})$/
function iB(o) {
	return (o = o.trim()), o === "*" || SN.test(o)
}
function QR(o) {
	if (!iB(o)) return null
	if (((o = o.trim()), o === "*"))
		return {
			hasCaret: !1,
			hasGreaterEquals: !1,
			majorBase: 0,
			majorMustEqual: !1,
			minorBase: 0,
			minorMustEqual: !1,
			patchBase: 0,
			patchMustEqual: !1,
			preRelease: null,
		}
	let e = o.match(SN)
	return e
		? {
				hasCaret: e[1] === "^",
				hasGreaterEquals: e[1] === ">=",
				majorBase: e[2] === "x" ? 0 : parseInt(e[2], 10),
				majorMustEqual: e[2] !== "x",
				minorBase: e[4] === "x" ? 0 : parseInt(e[4], 10),
				minorMustEqual: e[4] !== "x",
				patchBase: e[6] === "x" ? 0 : parseInt(e[6], 10),
				patchMustEqual: e[6] !== "x",
				preRelease: e[8] || null,
			}
		: null
}
function JR(o) {
	if (!o) return null
	let e = o.majorBase,
		t = o.majorMustEqual,
		n = o.minorBase,
		r = o.minorMustEqual,
		i = o.patchBase,
		s = o.patchMustEqual
	o.hasCaret && (e === 0 || (r = !1), (s = !1))
	let a = 0
	if (o.preRelease) {
		let l = oB.exec(o.preRelease)
		if (l) {
			let [, d, c, u] = l
			a = Date.UTC(Number(d), Number(c) - 1, Number(u))
		}
	}
	return {
		majorBase: e,
		majorMustEqual: t,
		minorBase: n,
		minorMustEqual: r,
		patchBase: i,
		patchMustEqual: s,
		isMinimum: o.hasGreaterEquals,
		notBefore: a,
	}
}
var XR = class {
	constructor() {
		this.buffers = []
	}
	add(e) {
		let t = this.buffers.indexOf(e)
		return t < 0 && ((t = this.buffers.length), this.buffers.push(e)), t
	}
}
function TN(o, e) {
	if (e.serializeBuffersForPostMessage) {
		let t = new XR(),
			r = JSON.stringify(o, (s, a) => {
				if (a instanceof ArrayBuffer) return { $$vscode_array_buffer_reference$$: !0, index: t.add(a) }
				if (ArrayBuffer.isView(a)) {
					let l = sB(a)
					if (l)
						return {
							$$vscode_array_buffer_reference$$: !0,
							index: t.add(a.buffer),
							view: { type: l, byteLength: a.byteLength, byteOffset: a.byteOffset },
						}
				}
				return a
			}),
			i = t.buffers.map((s) => {
				let a = new Uint8Array(s)
				return z.wrap(a)
			})
		return { message: r, buffers: i }
	} else return { message: JSON.stringify(o), buffers: [] }
}
function sB(o) {
	switch (o.constructor.name) {
		case "Int8Array":
			return 1
		case "Uint8Array":
			return 2
		case "Uint8ClampedArray":
			return 3
		case "Int16Array":
			return 4
		case "Uint16Array":
			return 5
		case "Int32Array":
			return 6
		case "Uint32Array":
			return 7
		case "Float32Array":
			return 8
		case "Float64Array":
			return 9
		case "BigInt64Array":
			return 10
		case "BigUint64Array":
			return 11
	}
}
function EN(o, e) {
	let t = e.map((i) => {
			let s = new ArrayBuffer(i.byteLength)
			return new Uint8Array(s).set(i.buffer), s
		}),
		n = e.length
			? (i, s) => {
					if (s && typeof s == "object" && s.$$vscode_array_buffer_reference$$) {
						let a = s,
							{ index: l } = a,
							d = t[l]
						if (a.view)
							switch (a.view.type) {
								case 1:
									return new Int8Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int8Array.BYTES_PER_ELEMENT,
									)
								case 2:
									return new Uint8Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint8Array.BYTES_PER_ELEMENT,
									)
								case 3:
									return new Uint8ClampedArray(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT,
									)
								case 4:
									return new Int16Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int16Array.BYTES_PER_ELEMENT,
									)
								case 5:
									return new Uint16Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint16Array.BYTES_PER_ELEMENT,
									)
								case 6:
									return new Int32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int32Array.BYTES_PER_ELEMENT,
									)
								case 7:
									return new Uint32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint32Array.BYTES_PER_ELEMENT,
									)
								case 8:
									return new Float32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Float32Array.BYTES_PER_ELEMENT,
									)
								case 9:
									return new Float64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Float64Array.BYTES_PER_ELEMENT,
									)
								case 10:
									return new BigInt64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT,
									)
								case 11:
									return new BigUint64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT,
									)
								default:
									throw new Error("Unknown array buffer view type")
							}
						return d
					}
					return s
				}
			: void 0
	return { message: JSON.parse(o, n), arrayBuffers: t }
}
var YR = class {
	constructor(e, t, n, r, i, s, a) {
		this.#a = ""
		this.#l = !1
		this.#d = !1
		this._onMessageEmitter = new E()
		this.onDidReceiveMessage = this._onMessageEmitter.event
		this.#p = new E()
		this._onDidDispose = this.#p.event
		;(this.#e = e),
			(this.#t = t),
			(this.#s = n),
			(this.#r = r),
			(this.#i = i),
			(this.#o = s),
			(this.#c = qs(s)),
			(this.#u = aB(s)),
			(this.#n = a)
	}
	#e
	#t
	#n
	#r
	#i
	#o
	#a
	#s
	#l
	#d
	#c
	#u
	#p
	dispose() {
		;(this.#l = !0), this.#p.fire(), this.#p.dispose(), this._onMessageEmitter.dispose()
	}
	asWebviewUri(e) {
		return (this.#d = !0), hl(e, this.#r)
	}
	get cspSource() {
		let e = this.#o.extensionLocation
		if (e.scheme === W.https || e.scheme === W.http) {
			let t = e.toString()
			return t.endsWith("/") || (t += "/"), t + " " + ph
		}
		return ph
	}
	get html() {
		return this.assertNotDisposed(), this.#a
	}
	set html(e) {
		this.assertNotDisposed(),
			this.#a !== e &&
				((this.#a = e),
				this.#u &&
					!this.#d &&
					/(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(e) &&
					((this.#d = !0),
					this.#n.report(
						"Webview vscode-resource: uris",
						this.#o,
						"Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri",
					)),
				this.#t.$setHtml(this.#e, this.rewriteOldResourceUrlsIfNeeded(e)))
	}
	get options() {
		return this.assertNotDisposed(), this.#s
	}
	set options(e) {
		this.assertNotDisposed(), nn(this.#s, e) || this.#t.$setOptions(this.#e, ZR(this.#o, this.#i, e)), (this.#s = e)
	}
	async postMessage(e) {
		if (this.#l) return !1
		let t = TN(e, { serializeBuffersForPostMessage: this.#c })
		return this.#t.$postMessage(this.#e, t.message, ...t.buffers)
	}
	assertNotDisposed() {
		if (this.#l) throw new Error("Webview is disposed")
	}
	rewriteOldResourceUrlsIfNeeded(e) {
		if (!this.#u) return e
		let t = this.#o.extensionLocation?.scheme === W.vscodeRemote,
			n = this.#o.extensionLocation.scheme === W.vscodeRemote ? this.#o.extensionLocation.authority : void 0
		return e
			.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (r, i, s, a, l, d) => {
				let c = y.from({ scheme: a || "file", path: decodeURIComponent(l) }),
					u = hl(c, { isRemote: t, authority: n }).toString()
				return `${i}${u}${d}`
			})
			.replace(
				/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
				(r, i, s, a, l, d) => {
					let c = y.from({ scheme: a || "file", path: decodeURIComponent(l) }),
						u = hl(c, { isRemote: t, authority: n }).toString()
					return `${i}${u}${d}`
				},
			)
	}
}
function qs(o) {
	try {
		let e = JR(QR(o.engines.vscode))
		return !!e && e.majorBase >= 1 && e.minorBase >= 57
	} catch {
		return !1
	}
}
function aB(o) {
	try {
		let e = JR(QR(o.engines.vscode))
		return e ? e.majorBase < 1 || (e.majorBase === 1 && e.minorBase < 60) : !1
	} catch {
		return !1
	}
}
var HC = class extends $ {
	constructor(t, n, r, i, s) {
		super()
		this.remoteInfo = n
		this.workspace = r
		this._logService = i
		this._deprecationService = s
		this._webviews = new Map()
		this._webviewProxy = t.getProxy(N.MainThreadWebviews)
	}
	dispose() {
		super.dispose()
		for (let t of this._webviews.values()) t.dispose()
		this._webviews.clear()
	}
	$onMessage(t, n, r) {
		console.log("onMessage", t, n, r)
		let i = this.getWebview(t)
		if (i) {
			let { message: s } = EN(n, r.value)
			i._onMessageEmitter.fire(s)
		}
	}
	$onMissingCsp(t, n) {
		this._logService.warn(
			`${n} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`,
		)
	}
	createNewWebview(t, n, r) {
		let i = new YR(t, this._webviewProxy, lB(n), this.remoteInfo, this.workspace, r, this._deprecationService)
		this._webviews.set(t, i)
		let s = i._onDidDispose(() => {
			s.dispose(), this.deleteWebview(t)
		})
		return i
	}
	deleteWebview(t) {
		this._webviews.delete(t)
	}
	getWebview(t) {
		return this._webviews.get(t)
	}
}
function $d(o) {
	return { id: o.identifier, location: o.extensionLocation }
}
function ZR(o, e, t) {
	return {
		enableCommandUris: t.enableCommandUris,
		enableScripts: t.enableScripts,
		enableForms: t.enableForms,
		portMapping: t.portMapping,
		localResourceRoots: t.localResourceRoots || dB(o, e),
	}
}
function lB(o) {
	return {
		enableCommandUris: o.enableCommandUris,
		enableScripts: o.enableScripts,
		enableForms: o.enableForms,
		portMapping: o.portMapping,
		localResourceRoots: o.localResourceRoots?.map((e) => y.from(e)),
	}
}
function dB(o, e) {
	return [...(e?.getWorkspaceFolders() || []).map((t) => t.uri), o.extensionLocation]
}
var pr = class o {
	constructor(e) {
		this.id = e
		this._data = new Map()
		this._idPool = 1
	}
	static {
		this.enableDebugLogging = !1
	}
	add(e) {
		let t = this._idPool++
		return this._data.set(t, e), this.logDebugInfo(), t
	}
	get(e, t) {
		return this._data.has(e) ? this._data.get(e)[t] : void 0
	}
	delete(e) {
		this._data.delete(e), this.logDebugInfo()
	}
	logDebugInfo() {
		o.enableDebugLogging && console.log(`${this.id} cache size - ${this._data.size}`)
	}
}
var e1 = class {
		constructor(e, t) {
			this.document = e
			this._storagePath = t
			this._backupCounter = 1
			this._edits = new pr("custom documents")
		}
		addEdit(e) {
			return this._edits.add([e])
		}
		async undo(e, t) {
			await this.getEdit(e).undo(), t || this.disposeBackup()
		}
		async redo(e, t) {
			await this.getEdit(e).redo(), t || this.disposeBackup()
		}
		disposeEdits(e) {
			for (let t of e) this._edits.delete(t)
		}
		getNewBackupUri() {
			if (!this._storagePath) throw new Error("Backup requires a valid storage path")
			let e = pB(this.document.uri) + this._backupCounter++
			return ct(this._storagePath, e)
		}
		updateBackup(e) {
			this._backup?.delete(), (this._backup = e)
		}
		disposeBackup() {
			this._backup?.delete(), (this._backup = void 0)
		}
		getEdit(e) {
			let t = this._edits.get(e, 0)
			if (!t) throw new Error("No edit found")
			return t
		}
	},
	t1 = class {
		constructor() {
			this._documents = new Map()
		}
		get(e, t) {
			return this._documents.get(this.key(e, t))
		}
		add(e, t, n) {
			let r = this.key(e, t.uri)
			if (this._documents.has(r)) throw new Error(`Document already exists for viewType:${e} resource:${t.uri}`)
			let i = new e1(t, n)
			return this._documents.set(r, i), i
		}
		delete(e, t) {
			let n = this.key(e, t.uri)
			this._documents.delete(n)
		}
		key(e, t) {
			return `${e}@@@${t}`
		}
	}
var n1 = class {
		constructor() {
			this._providers = new Map()
		}
		addTextProvider(e, t, n) {
			return this.add(e, { type: 0, extension: t, provider: n })
		}
		addCustomProvider(e, t, n) {
			return this.add(e, { type: 1, extension: t, provider: n })
		}
		get(e) {
			return this._providers.get(e)
		}
		add(e, t) {
			if (this._providers.has(e)) throw new Error(`Provider for viewType:${e} already registered`)
			return this._providers.set(e, t), new ye(() => this._providers.delete(e))
		}
	},
	VC = class {
		constructor(e, t, n, r, i) {
			this._extHostDocuments = t
			this._extensionStoragePaths = n
			this._extHostWebview = r
			this._extHostWebviewPanels = i
			this._editorProviders = new n1()
			this._documents = new t1()
			this._proxy = e.getProxy(N.MainThreadCustomEditors)
		}
		registerCustomEditorProvider(e, t, n, r) {
			let i = new Q()
			return (
				cB(n)
					? (i.add(this._editorProviders.addTextProvider(t, e, n)),
						this._proxy.$registerTextEditorProvider(
							$d(e),
							t,
							r.webviewOptions || {},
							{ supportsMove: !!n.moveCustomTextEditor },
							qs(e),
						))
					: (i.add(this._editorProviders.addCustomProvider(t, e, n)),
						WC(n) &&
							i.add(
								n.onDidChangeCustomDocument((s) => {
									let a = this.getCustomDocumentEntry(t, s.document.uri)
									if (uB(s)) {
										let l = a.addEdit(s)
										this._proxy.$onDidEdit(s.document.uri, t, l, s.label)
									} else this._proxy.$onContentChange(s.document.uri, t)
								}),
							),
						this._proxy.$registerCustomEditorProvider(
							$d(e),
							t,
							r.webviewOptions || {},
							!!r.supportsMultipleEditorsPerDocument,
							qs(e),
						)),
				ye.from(
					i,
					new ye(() => {
						this._proxy.$unregisterEditorProvider(t)
					}),
				)
			)
		}
		async $createCustomDocument(e, t, n, r, i) {
			let s = this._editorProviders.get(t)
			if (!s) throw new Error(`No provider found for '${t}'`)
			if (s.type !== 1) throw new Error(`Invalid provide type for '${t}'`)
			let a = y.revive(e),
				l = await s.provider.openCustomDocument(a, { backupId: n, untitledDocumentData: r?.buffer }, i),
				d
			return (
				WC(s.provider) &&
					this._extensionStoragePaths &&
					(d =
						this._extensionStoragePaths.workspaceValue(s.extension) ??
						this._extensionStoragePaths.globalValue(s.extension)),
				this._documents.add(t, l, d),
				{ editable: WC(s.provider) }
			)
		}
		async $disposeCustomDocument(e, t) {
			let n = this._editorProviders.get(t)
			if (!n) throw new Error(`No provider found for '${t}'`)
			if (n.type !== 1) throw new Error(`Invalid provider type for '${t}'`)
			let r = y.revive(e),
				{ document: i } = this.getCustomDocumentEntry(t, r)
			this._documents.delete(t, i), i.dispose()
		}
		async $resolveCustomEditor(e, t, n, r, i, s) {
			let a = this._editorProviders.get(n)
			if (!a) throw new Error(`No provider found for '${n}'`)
			let l = wt.to(i),
				d = this._extHostWebview.createNewWebview(t, r.contentOptions, a.extension),
				c = this._extHostWebviewPanels.createNewWebviewPanel(t, n, r.title, l, r.options, d, r.active),
				u = y.revive(e)
			switch (a.type) {
				case 1: {
					let { document: m } = this.getCustomDocumentEntry(n, u)
					return a.provider.resolveCustomEditor(m, c, s)
				}
				case 0: {
					let m = this._extHostDocuments.getDocument(u)
					return a.provider.resolveCustomTextEditor(m, c, s)
				}
				default:
					throw new Error("Unknown webview provider type")
			}
		}
		$disposeEdits(e, t, n) {
			this.getCustomDocumentEntry(t, e).disposeEdits(n)
		}
		async $onMoveCustomEditor(e, t, n) {
			let r = this._editorProviders.get(n)
			if (!r) throw new Error(`No provider found for '${n}'`)
			if (!r.provider.moveCustomTextEditor) throw new Error(`Provider does not implement move '${n}'`)
			let i = this._extHostWebviewPanels.getWebviewPanel(e)
			if (!i) throw new Error("No webview found")
			let s = y.revive(t),
				a = this._extHostDocuments.getDocument(s)
			await r.provider.moveCustomTextEditor(a, i, De.None)
		}
		async $undo(e, t, n, r) {
			return this.getCustomDocumentEntry(t, e).undo(n, r)
		}
		async $redo(e, t, n, r) {
			return this.getCustomDocumentEntry(t, e).redo(n, r)
		}
		async $revert(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e)
			await this.getCustomEditorProvider(t).revertCustomDocument(r.document, n), r.disposeBackup()
		}
		async $onSave(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e)
			await this.getCustomEditorProvider(t).saveCustomDocument(r.document, n), r.disposeBackup()
		}
		async $onSaveAs(e, t, n, r) {
			let i = this.getCustomDocumentEntry(t, e)
			return this.getCustomEditorProvider(t).saveCustomDocumentAs(i.document, y.revive(n), r)
		}
		async $backup(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e),
				s = await this.getCustomEditorProvider(t).backupCustomDocument(
					r.document,
					{ destination: r.getNewBackupUri() },
					n,
				)
			return r.updateBackup(s), s.id
		}
		getCustomDocumentEntry(e, t) {
			let n = this._documents.get(e, y.revive(t))
			if (!n) throw new Error("No custom document found")
			return n
		}
		getCustomEditorProvider(e) {
			let n = this._editorProviders.get(e)?.provider
			if (!n || !WC(n)) throw new Error("Custom document is not editable")
			return n
		}
	}
function WC(o) {
	return !!o.onDidChangeCustomDocument
}
function cB(o) {
	return typeof o.resolveCustomTextEditor == "function"
}
function uB(o) {
	return typeof o.undo == "function" && typeof o.redo == "function"
}
function pB(o) {
	let e = o.scheme === W.file || o.scheme === W.untitled ? o.fsPath : o.toString()
	return ar(e) + ""
}
var BC = class o {
		constructor(e, t, n, r, i, s, a, l) {
			this._name = e
			this._owner = t
			this._maxDiagnosticsTotal = n
			this._maxDiagnosticsPerFile = r
			this._modelVersionIdProvider = i
			this._isDisposed = !1
			;(this._maxDiagnosticsTotal = Math.max(r, n)),
				(this.#n = new ft((d) => s.getComparisonKey(d))),
				(this.#e = a),
				(this.#t = l)
		}
		#e
		#t
		#n
		dispose() {
			this._isDisposed ||
				(this.#t.fire([...this.#n.keys()]),
				this.#e?.$clear(this._owner),
				this.#n.clear(),
				(this._isDisposed = !0))
		}
		get name() {
			return this._checkDisposed(), this._name
		}
		set(e, t) {
			if (!e) {
				this.clear()
				return
			}
			this._checkDisposed()
			let n = []
			if (y.isUri(e)) {
				if (!t) {
					this.delete(e)
					return
				}
				this.#n.set(e, t.slice()), (n = [e])
			} else if (Array.isArray(e)) {
				n = []
				let s
				e = [...e].sort(o._compareIndexedTuplesByUri)
				for (let a of e) {
					let [l, d] = a
					if (
						((!s || l.toString() !== s.toString()) &&
							(s && this.#n.get(s).length === 0 && this.#n.delete(s),
							(s = l),
							n.push(l),
							this.#n.set(l, [])),
						d)
					)
						this.#n.get(l)?.push(...d)
					else {
						let c = this.#n.get(l)
						c && (c.length = 0)
					}
				}
			}
			if ((this.#t.fire(n), !this.#e)) return
			let r = [],
				i = 0
			for (let s of n) {
				let a = [],
					l = this.#n.get(s)
				if (l)
					if (l.length > this._maxDiagnosticsPerFile) {
						a = []
						let d = [0, 1, 2, 3]
						e: for (let c = 0; c < 4; c++)
							for (let u of l)
								if (
									u.severity === d[c] &&
									a.push({ ..._d.from(u), modelVersionId: this._modelVersionIdProvider(s) }) ===
										this._maxDiagnosticsPerFile
								)
									break e
						a.push({
							severity: 2,
							message: p(
								{ key: "limitHit", comment: ["amount of errors/warning skipped due to limits"] },
								"Not showing {0} further errors and warnings.",
								l.length - this._maxDiagnosticsPerFile,
							),
							startLineNumber: a[a.length - 1].startLineNumber,
							startColumn: a[a.length - 1].startColumn,
							endLineNumber: a[a.length - 1].endLineNumber,
							endColumn: a[a.length - 1].endColumn,
						})
					} else a = l.map((d) => ({ ..._d.from(d), modelVersionId: this._modelVersionIdProvider(s) }))
				if ((r.push([s, a]), (i += a.length), i > this._maxDiagnosticsTotal)) break
			}
			this.#e.$changeMany(this._owner, r)
		}
		delete(e) {
			this._checkDisposed(),
				this.#t.fire([e]),
				this.#n.delete(e),
				this.#e?.$changeMany(this._owner, [[e, void 0]])
		}
		clear() {
			this._checkDisposed(), this.#t.fire([...this.#n.keys()]), this.#n.clear(), this.#e?.$clear(this._owner)
		}
		forEach(e, t) {
			this._checkDisposed()
			for (let [n, r] of this) e.call(t, n, r, this)
		}
		*[Symbol.iterator]() {
			this._checkDisposed()
			for (let e of this.#n.keys()) yield [e, this.get(e)]
		}
		get(e) {
			this._checkDisposed()
			let t = this.#n.get(e)
			return Array.isArray(t) ? Object.freeze(t.slice(0)) : []
		}
		has(e) {
			return this._checkDisposed(), Array.isArray(this.#n.get(e))
		}
		_checkDisposed() {
			if (this._isDisposed) throw new Error("illegal state - object is disposed")
		}
		static _compareIndexedTuplesByUri(e, t) {
			return e[0].toString() < t[0].toString() ? -1 : e[0].toString() > t[0].toString() ? 1 : 0
		}
	},
	To = class {
		constructor(e, t, n, r) {
			this._logService = t
			this._fileSystemInfoService = n
			this._extHostDocumentsAndEditors = r
			this._collections = new Map()
			this._onDidChangeDiagnostics = new tv({ merge: (e) => e.flat(), delay: 50 })
			this.onDidChangeDiagnostics = Te.map(this._onDidChangeDiagnostics.event, To._mapper)
			this._proxy = e.getProxy(N.MainThreadDiagnostics)
		}
		static {
			this._idPool = 0
		}
		static {
			this._maxDiagnosticsPerFile = 1e3
		}
		static {
			this._maxDiagnosticsTotal = 1.1 * this._maxDiagnosticsPerFile
		}
		static _mapper(e) {
			let t = new ft()
			for (let n of e) t.set(n, n)
			return { uris: Object.freeze(Array.from(t.values())) }
		}
		createDiagnosticCollection(e, t) {
			let {
					_collections: n,
					_proxy: r,
					_onDidChangeDiagnostics: i,
					_logService: s,
					_fileSystemInfoService: a,
					_extHostDocumentsAndEditors: l,
				} = this,
				d = new (class {
					$changeMany(m, f) {
						r.$changeMany(m, f),
							s.trace(
								"[DiagnosticCollection] change many (extension, owner, uris)",
								e.value,
								m,
								f.length === 0 ? "CLEARING" : f,
							)
					}
					$clear(m) {
						r.$clear(m), s.trace("[DiagnosticCollection] remove all (extension, owner)", e.value, m)
					}
					dispose() {
						r.dispose()
					}
				})(),
				c
			if (!t) (t = "_generated_diagnostic_collection_name_#" + To._idPool++), (c = t)
			else if (!n.has(t)) c = t
			else {
				this._logService.warn(`DiagnosticCollection with name '${t}' does already exist.`)
				do c = t + To._idPool++
				while (n.has(c))
			}
			return new (class extends BC {
				constructor() {
					super(
						t,
						c,
						To._maxDiagnosticsTotal,
						To._maxDiagnosticsPerFile,
						(m) => l.getDocument(m)?.version,
						a.extUri,
						d,
						i,
					),
						n.set(c, this)
				}
				dispose() {
					super.dispose(), n.delete(c)
				}
			})()
		}
		getDiagnostics(e) {
			if (e) return this._getDiagnostics(e)
			{
				let t = new Map(),
					n = []
				for (let r of this._collections.values())
					r.forEach((i, s) => {
						let a = t.get(i.toString())
						typeof a > "u" && ((a = n.length), t.set(i.toString(), a), n.push([i, []])),
							(n[a][1] = n[a][1].concat(...s))
					})
				return n
			}
		}
		_getDiagnostics(e) {
			let t = []
			for (let n of this._collections.values()) n.has(e) && (t = t.concat(n.get(e)))
			return t
		}
		$acceptMarkersChange(e) {
			if (!this._mirrorCollection) {
				let t = "_generated_mirror",
					n = new BC(
						t,
						t,
						Number.MAX_SAFE_INTEGER,
						Number.MAX_SAFE_INTEGER,
						(r) => {},
						this._fileSystemInfoService.extUri,
						void 0,
						this._onDidChangeDiagnostics,
					)
				this._collections.set(t, n), (this._mirrorCollection = n)
			}
			for (let [t, n] of e) this._mirrorCollection.set(y.revive(t), n.map(_d.to))
		}
	}
To = R([S(1, te), S(2, uo)], To)
var $C = class {
	constructor(e) {
		this._proxy = e.getProxy(N.MainThreadDialogs)
	}
	showOpenDialog(e) {
		return this._proxy.$showOpenDialog(e).then((t) => (t ? t.map((n) => y.revive(n)) : void 0))
	}
	showSaveDialog(e) {
		return this._proxy.$showSaveDialog(e).then((t) => (t ? y.revive(t) : void 0))
	}
}
var zC = class o {
	constructor(e, t, n) {
		this._documentsAndEditors = t
		this._logService = n
		this._documentContentProviders = new Map()
		this._proxy = e.getProxy(N.MainThreadDocumentContentProviders)
	}
	static {
		this._handlePool = 0
	}
	registerTextDocumentContentProvider(e, t) {
		if (Object.keys(W).indexOf(e) >= 0) throw new Error(`scheme '${e}' already registered`)
		let n = o._handlePool++
		this._documentContentProviders.set(n, t), this._proxy.$registerTextContentProvider(n, e)
		let r
		if (typeof t.onDidChange == "function") {
			let i
			r = t.onDidChange(async (s) => {
				if (s.scheme !== e) {
					this._logService.warn(
						`Provider for scheme '${e}' is firing event for schema '${s.scheme}' which will be IGNORED`,
					)
					return
				}
				if (!this._documentsAndEditors.getDocument(s)) return
				i && (await i)
				let a = this.$provideTextDocumentContent(n, s)
					.then(async (l) => {
						if (!l && typeof l != "string") return
						let d = this._documentsAndEditors.getDocument(s)
						if (!d) return
						let c = Iv(l)
						if (!d.equalLines(c)) return this._proxy.$onVirtualDocumentChange(s, l)
					})
					.catch(Be)
					.finally(() => {
						i === a && (i = void 0)
					})
				i = a
			})
		}
		return new ye(() => {
			this._documentContentProviders.delete(n) && this._proxy.$unregisterTextContentProvider(n),
				r && (r.dispose(), (r = void 0))
		})
	}
	$provideTextDocumentContent(e, t) {
		let n = this._documentContentProviders.get(e)
		return n
			? Promise.resolve(n.provideTextDocumentContent(y.revive(t), De.None))
			: Promise.reject(new Error(`unsupported uri-scheme: ${t.scheme}`))
	}
}
var qC = class {
	constructor(e, t, n, r = { timeout: 1500, errors: 3 }) {
		this._logService = e
		this._documents = t
		this._mainThreadBulkEdits = n
		this._thresholds = r
		this._callbacks = new ko()
		this._badListeners = new WeakMap()
	}
	dispose() {
		this._callbacks.clear()
	}
	getOnWillSaveTextDocumentEvent(e) {
		return (t, n, r) => {
			let s = { dispose: this._callbacks.push([t, n, e]) }
			return Array.isArray(r) && r.push(s), s
		}
	}
	async $participateInSave(e, t) {
		let n = y.revive(e),
			r = !1,
			i = setTimeout(() => (r = !0), this._thresholds.timeout),
			s = []
		try {
			for (let a of [...this._callbacks]) {
				if (r) break
				let l = this._documents.getDocument(n),
					d = await this._deliverEventAsyncAndBlameBadListeners(a, { document: l, reason: xg.to(t) })
				s.push(d)
			}
		} finally {
			clearTimeout(i)
		}
		return s
	}
	_deliverEventAsyncAndBlameBadListeners([e, t, n], r) {
		let i = this._badListeners.get(e)
		return typeof i == "number" && i > this._thresholds.errors
			? Promise.resolve(!1)
			: this._deliverEventAsync(n, e, t, r).then(
					() => !0,
					(s) => {
						if (
							(this._logService.error(
								`onWillSaveTextDocument-listener from extension '${n.identifier.value}' threw ERROR`,
							),
							this._logService.error(s),
							!(s instanceof Error) || s.message !== "concurrent_edits")
						) {
							let a = this._badListeners.get(e)
							this._badListeners.set(e, a ? a + 1 : 1),
								typeof a == "number" &&
									a > this._thresholds.errors &&
									this._logService.info(
										`onWillSaveTextDocument-listener from extension '${n.identifier.value}' will now be IGNORED because of timeouts and/or errors`,
									)
						}
						return !1
					},
				)
	}
	_deliverEventAsync(e, t, n, r) {
		let i = [],
			s = Date.now(),
			{ document: a, reason: l } = r,
			{ version: d } = a,
			c = Object.freeze({
				document: a,
				reason: l,
				waitUntil(u) {
					if (Object.isFrozen(i)) throw lc("waitUntil can not be called async")
					i.push(Promise.resolve(u))
				},
			})
		try {
			t.apply(n, [c])
		} catch (u) {
			return Promise.reject(u)
		}
		return (
			Object.freeze(i),
			new Promise((u, m) => {
				let f = setTimeout(() => m(new Error("timeout")), this._thresholds.timeout)
				return Promise.all(i)
					.then((h) => {
						this._logService.debug(
							`onWillSaveTextDocument-listener from extension '${e.identifier.value}' finished after ${Date.now() - s}ms`,
						),
							clearTimeout(f),
							u(h)
					})
					.catch((h) => {
						clearTimeout(f), m(h)
					})
			}).then((u) => {
				let m = { edits: [] }
				for (let f of u)
					if (Array.isArray(f) && f.every((h) => h instanceof Ln))
						for (let { newText: h, newEol: g, range: I } of f)
							m.edits.push({
								resource: a.uri,
								versionId: void 0,
								textEdit: { range: I && H.from(I), text: h, eol: g && Ed.from(g) },
							})
				if (m.edits.length !== 0)
					return d === a.version
						? this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new Xt(m))
						: Promise.reject(new Error("concurrent_edits"))
			})
		)
	}
}
var KC = class {
	constructor(e, t) {
		this._onDidAddDocument = new E()
		this._onDidRemoveDocument = new E()
		this._onDidChangeDocument = new E()
		this._onDidSaveDocument = new E()
		this.onDidAddDocument = this._onDidAddDocument.event
		this.onDidRemoveDocument = this._onDidRemoveDocument.event
		this.onDidChangeDocument = this._onDidChangeDocument.event
		this.onDidSaveDocument = this._onDidSaveDocument.event
		this._toDispose = new Q()
		this._documentLoader = new Map()
		;(this._proxy = e.getProxy(N.MainThreadDocuments)),
			(this._documentsAndEditors = t),
			this._documentsAndEditors.onDidRemoveDocuments(
				(n) => {
					for (let r of n) this._onDidRemoveDocument.fire(r.document)
				},
				void 0,
				this._toDispose,
			),
			this._documentsAndEditors.onDidAddDocuments(
				(n) => {
					for (let r of n) this._onDidAddDocument.fire(r.document)
				},
				void 0,
				this._toDispose,
			)
	}
	dispose() {
		this._toDispose.dispose()
	}
	getAllDocumentData() {
		return [...this._documentsAndEditors.allDocuments()]
	}
	getDocumentData(e) {
		if (!e) return
		let t = this._documentsAndEditors.getDocument(e)
		if (t) return t
	}
	getDocument(e) {
		let t = this.getDocumentData(e)
		if (!t?.document) throw new Error(`Unable to retrieve document from URI '${e}'`)
		return t.document
	}
	ensureDocumentData(e, t) {
		let n = this._documentsAndEditors.getDocument(e)
		if (n && (!t?.encoding || n.document.encoding === t.encoding)) return Promise.resolve(n)
		let r = this._documentLoader.get(e.toString())
		return (
			r
				? t?.encoding &&
					(r = r.then((i) => (i.document.encoding !== t.encoding ? this.ensureDocumentData(e, t) : i)))
				: ((r = this._proxy.$tryOpenDocument(e, t).then(
						(i) => {
							this._documentLoader.delete(e.toString())
							let s = y.revive(i)
							return Do(this._documentsAndEditors.getDocument(s))
						},
						(i) => (this._documentLoader.delete(e.toString()), Promise.reject(i)),
					)),
					this._documentLoader.set(e.toString(), r)),
			r
		)
	}
	createDocumentData(e) {
		return this._proxy.$tryCreateDocument(e).then((t) => y.revive(t))
	}
	$acceptModelLanguageChanged(e, t) {
		let n = y.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		this._onDidRemoveDocument.fire(r.document), r._acceptLanguageId(t), this._onDidAddDocument.fire(r.document)
	}
	$acceptModelSaved(e) {
		let t = y.revive(e),
			n = this._documentsAndEditors.getDocument(t)
		if (!n) throw new Error("unknown document")
		this.$acceptDirtyStateChanged(e, !1), this._onDidSaveDocument.fire(n.document)
	}
	$acceptDirtyStateChanged(e, t) {
		let n = y.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		r._acceptIsDirty(t),
			this._onDidChangeDocument.fire({ document: r.document, contentChanges: [], reason: void 0 })
	}
	$acceptEncodingChanged(e, t) {
		let n = y.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		r._acceptEncoding(t),
			this._onDidChangeDocument.fire({ document: r.document, contentChanges: [], reason: void 0 })
	}
	$acceptModelChanged(e, t, n) {
		let r = y.revive(e),
			i = this._documentsAndEditors.getDocument(r)
		if (!i) throw new Error("unknown document")
		i._acceptIsDirty(n), i.onEvents(t)
		let s
		t.isUndoing ? (s = 1) : t.isRedoing && (s = 2),
			this._onDidChangeDocument.fire(
				Jv({
					document: i.document,
					contentChanges: t.changes.map((a) => ({
						range: H.to(a.range),
						rangeOffset: a.rangeOffset,
						rangeLength: a.rangeLength,
						text: a.text,
					})),
					reason: s,
				}),
			)
	}
	setWordDefinitionFor(e, t) {
		y2(e, t)
	}
}
var jC = class {
	constructor(e) {
		this._provider = new Map()
		this._onDidChange = new E()
		this.onDidChange = this._onDidChange.event
		this._allKnownModels = new Set()
		this._handlePool = 0
		this._proxy = e.getProxy(N.MainThreadEmbeddings)
	}
	registerEmbeddingsProvider(e, t, n) {
		if (this._allKnownModels.has(t)) throw new Error("An embeddings provider for this model is already registered")
		let r = this._handlePool++
		return (
			this._proxy.$registerEmbeddingProvider(r, t),
			this._provider.set(r, { id: t, provider: n }),
			q(() => {
				this._allKnownModels.delete(t), this._proxy.$unregisterEmbeddingProvider(r), this._provider.delete(r)
			})
		)
	}
	async computeEmbeddings(e, t, n) {
		n ??= De.None
		let r = !1
		typeof t == "string" && ((t = [t]), (r = !0))
		let i = await this._proxy.$computeEmbeddings(e, t, n)
		if (i.length !== t.length) throw new Error()
		if (r) {
			if (i.length !== 1) throw new Error()
			return i[0]
		}
		return i
	}
	async $provideEmbeddings(e, t, n) {
		let r = this._provider.get(e)
		if (!r) return []
		let i = await r.provider.provideEmbeddings(t, n)
		return i || []
	}
	get embeddingsModels() {
		return Array.from(this._allKnownModels)
	}
	$acceptEmbeddingModels(e) {
		;(this._allKnownModels = new Set(e)), this._onDidChange.fire()
	}
}
var GC = class {
	constructor(e) {
		this._AiEmbeddingVectorProviders = new Map()
		this._nextHandle = 0
		this._proxy = e.getProxy(N.MainThreadAiEmbeddingVector)
	}
	async $provideAiEmbeddingVector(e, t, n) {
		if (this._AiEmbeddingVectorProviders.size === 0) throw new Error("No embedding vector providers registered")
		let r = this._AiEmbeddingVectorProviders.get(e)
		if (!r) throw new Error("Embedding vector provider not found")
		let i = await r.provideEmbeddingVector(t, n)
		if (!i) throw new Error("Embedding vector provider returned undefined")
		return i
	}
	registerEmbeddingVectorProvider(e, t, n) {
		let r = this._nextHandle
		return (
			this._nextHandle++,
			this._AiEmbeddingVectorProviders.set(r, n),
			this._proxy.$registerAiEmbeddingVectorProvider(t, r),
			new ye(() => {
				this._proxy.$unregisterAiEmbeddingVectorProvider(r), this._AiEmbeddingVectorProviders.delete(r)
			})
		)
	}
}
var o1 = class {
		constructor(e, t, n) {
			let r = new Uint8Array(e * t)
			for (let i = 0, s = e * t; i < s; i++) r[i] = n
			;(this._data = r), (this.rows = e), (this.cols = t)
		}
		get(e, t) {
			return this._data[e * this.cols + t]
		}
		set(e, t, n) {
			this._data[e * this.cols + t] = n
		}
	},
	fh = class {
		constructor(e) {
			let t = 0,
				n = 0
			for (let i = 0, s = e.length; i < s; i++) {
				let [a, l, d] = e[i]
				l > t && (t = l), a > n && (n = a), d > n && (n = d)
			}
			t++, n++
			let r = new o1(n, t, 0)
			for (let i = 0, s = e.length; i < s; i++) {
				let [a, l, d] = e[i]
				r.set(a, l, d)
			}
			;(this._states = r), (this._maxCharCode = t)
		}
		nextState(e, t) {
			return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t)
		}
	},
	r1 = null
function mB() {
	return (
		r1 === null &&
			(r1 = new fh([
				[1, 104, 2],
				[1, 72, 2],
				[1, 102, 6],
				[1, 70, 6],
				[2, 116, 3],
				[2, 84, 3],
				[3, 116, 4],
				[3, 84, 4],
				[4, 112, 5],
				[4, 80, 5],
				[5, 115, 9],
				[5, 83, 9],
				[5, 58, 10],
				[6, 105, 7],
				[6, 73, 7],
				[7, 108, 8],
				[7, 76, 8],
				[8, 101, 9],
				[8, 69, 9],
				[9, 58, 10],
				[10, 47, 11],
				[11, 47, 12],
			])),
		r1
	)
}
var mh = null
function fB() {
	if (mh === null) {
		mh = new kp(0)
		let o = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`
		for (let t = 0; t < o.length; t++) mh.set(o.charCodeAt(t), 1)
		let e = ".,;:"
		for (let t = 0; t < e.length; t++) mh.set(e.charCodeAt(t), 2)
	}
	return mh
}
var QC = class o {
	static _createLink(e, t, n, r, i) {
		let s = i - 1
		do {
			let a = t.charCodeAt(s)
			if (e.get(a) !== 2) break
			s--
		} while (s > r)
		if (r > 0) {
			let a = t.charCodeAt(r - 1),
				l = t.charCodeAt(s)
			;((a === 40 && l === 41) || (a === 91 && l === 93) || (a === 123 && l === 125)) && s--
		}
		return {
			range: { startLineNumber: n, startColumn: r + 1, endLineNumber: n, endColumn: s + 2 },
			url: t.substring(r, s + 1),
		}
	}
	static computeLinks(e, t = mB()) {
		let n = fB(),
			r = []
		for (let i = 1, s = e.getLineCount(); i <= s; i++) {
			let a = e.getLineContent(i),
				l = a.length,
				d = 0,
				c = 0,
				u = 0,
				m = 1,
				f = !1,
				h = !1,
				g = !1,
				I = !1
			for (; d < l; ) {
				let C = !1,
					T = a.charCodeAt(d)
				if (m === 13) {
					let w
					switch (T) {
						case 40:
							;(f = !0), (w = 0)
							break
						case 41:
							w = f ? 0 : 1
							break
						case 91:
							;(g = !0), (h = !0), (w = 0)
							break
						case 93:
							;(g = !1), (w = h ? 0 : 1)
							break
						case 123:
							;(I = !0), (w = 0)
							break
						case 125:
							w = I ? 0 : 1
							break
						case 39:
						case 34:
						case 96:
							u === T ? (w = 1) : u === 39 || u === 34 || u === 96 ? (w = 0) : (w = 1)
							break
						case 42:
							w = u === 42 ? 1 : 0
							break
						case 124:
							w = u === 124 ? 1 : 0
							break
						case 32:
							w = g ? 0 : 1
							break
						default:
							w = n.get(T)
					}
					w === 1 && (r.push(o._createLink(n, a, i, c, d)), (C = !0))
				} else if (m === 12) {
					let w
					T === 91 ? ((h = !0), (w = 0)) : (w = n.get(T)), w === 1 ? (C = !0) : (m = 13)
				} else (m = t.nextState(m, T)), m === 0 && (C = !0)
				C && ((m = 1), (f = !1), (h = !1), (I = !1), (c = d + 1), (u = T)), d++
			}
			m === 13 && r.push(o._createLink(n, a, i, c, l))
		}
		return r
	}
}
var i1 = class {
		constructor() {
			this._schemes = []
		}
		add(e) {
			;(this._stateMachine = void 0), this._schemes.push(e)
		}
		delete(e) {
			let t = this._schemes.indexOf(e)
			t >= 0 && (this._schemes.splice(t, 1), (this._stateMachine = void 0))
		}
		_initStateMachine() {
			if (!this._stateMachine) {
				let e = this._schemes.sort(),
					t = [],
					n,
					r,
					i = 14,
					s = 14
				for (let a of e) {
					let l = n ? bA(n, a) : 0
					for (l === 0 ? (r = 1) : (r = s); l < a.length; l++)
						l + 1 === a.length ? ((i = s), (s = 9)) : (s += 1),
							t.push([r, a.toUpperCase().charCodeAt(l), s]),
							t.push([r, a.toLowerCase().charCodeAt(l), s]),
							(r = s)
					;(n = a), (s = i)
				}
				t.push([9, 58, 10]), t.push([10, 47, 12]), (this._stateMachine = new fh(t))
			}
		}
		provideDocumentLinks(e) {
			this._initStateMachine()
			let t = [],
				n = QC.computeLinks(
					{
						getLineContent(r) {
							return e.lineAt(r - 1).text
						},
						getLineCount() {
							return e.lineCount
						},
					},
					this._stateMachine,
				)
			for (let r of n) {
				let i = Us.to(r)
				i.target && t.push(i)
			}
			return t
		}
	},
	JC = class o {
		constructor(e, t) {
			this._extHostLanguageFeatures = t
			this._linkProvider = new i1()
			this._fsProvider = new Map()
			this._registeredSchemes = new Set()
			this._watches = new Map()
			this._handlePool = 0
			this._proxy = e.getProxy(N.MainThreadFileSystem)
		}
		dispose() {
			this._linkProviderRegistration?.dispose()
		}
		registerFileSystemProvider(e, t, n, r = {}) {
			if ((o._validateFileSystemProvider(n), this._registeredSchemes.has(t)))
				throw new Error(`a provider for the scheme '${t}' is already registered`)
			this._linkProviderRegistration ||
				(this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(
					e,
					"*",
					this._linkProvider,
				))
			let i = this._handlePool++
			this._linkProvider.add(t), this._registeredSchemes.add(t), this._fsProvider.set(i, n)
			let s = 2
			r.isCaseSensitive && (s += 1024),
				r.isReadonly && (s += 2048),
				typeof n.copy == "function" && (s += 8),
				typeof n.open == "function" &&
					typeof n.close == "function" &&
					typeof n.read == "function" &&
					typeof n.write == "function" &&
					(M(e, "fsChunks"), (s += 4))
			let a
			r.isReadonly &&
				Kr(r.isReadonly) &&
				r.isReadonly.value !== "" &&
				(a = {
					value: r.isReadonly.value,
					isTrusted: r.isReadonly.isTrusted,
					supportThemeIcons: r.isReadonly.supportThemeIcons,
					supportHtml: r.isReadonly.supportHtml,
					baseUri: r.isReadonly.baseUri,
					uris: r.isReadonly.uris,
				}),
				this._proxy.$registerFileSystemProvider(i, t, s, a).catch((d) => {
					console.error(
						`FAILED to register filesystem provider of ${e.identifier.value}-extension for the scheme ${t}`,
					),
						console.error(d)
				})
			let l = n.onDidChangeFile((d) => {
				let c = []
				for (let u of d) {
					let { uri: m, type: f } = u
					if (m.scheme !== t) continue
					let h
					switch (f) {
						case 1:
							h = 0
							break
						case 2:
							h = 1
							break
						case 3:
							h = 2
							break
						default:
							throw new Error("Unknown FileChangeType")
					}
					c.push({ resource: m, type: h })
				}
				this._proxy.$onFileSystemChange(i, c)
			})
			return q(() => {
				l.dispose(),
					this._linkProvider.delete(t),
					this._registeredSchemes.delete(t),
					this._fsProvider.delete(i),
					this._proxy.$unregisterProvider(i)
			})
		}
		static _validateFileSystemProvider(e) {
			if (!e) throw new Error("MISSING provider")
			if (typeof e.watch != "function") throw new Error("Provider does NOT implement watch")
			if (typeof e.stat != "function") throw new Error("Provider does NOT implement stat")
			if (typeof e.readDirectory != "function") throw new Error("Provider does NOT implement readDirectory")
			if (typeof e.createDirectory != "function") throw new Error("Provider does NOT implement createDirectory")
			if (typeof e.readFile != "function") throw new Error("Provider does NOT implement readFile")
			if (typeof e.writeFile != "function") throw new Error("Provider does NOT implement writeFile")
			if (typeof e.delete != "function") throw new Error("Provider does NOT implement delete")
			if (typeof e.rename != "function") throw new Error("Provider does NOT implement rename")
		}
		static _asIStat(e) {
			let { type: t, ctime: n, mtime: r, size: i, permissions: s } = e
			return { type: t, ctime: n, mtime: r, size: i, permissions: s }
		}
		$stat(e, t) {
			return Promise.resolve(this._getFsProvider(e).stat(y.revive(t))).then((n) => o._asIStat(n))
		}
		$readdir(e, t) {
			return Promise.resolve(this._getFsProvider(e).readDirectory(y.revive(t)))
		}
		$readFile(e, t) {
			return Promise.resolve(this._getFsProvider(e).readFile(y.revive(t))).then((n) => z.wrap(n))
		}
		$writeFile(e, t, n, r) {
			return Promise.resolve(this._getFsProvider(e).writeFile(y.revive(t), n.buffer, r))
		}
		$delete(e, t, n) {
			return Promise.resolve(this._getFsProvider(e).delete(y.revive(t), n))
		}
		$rename(e, t, n, r) {
			return Promise.resolve(this._getFsProvider(e).rename(y.revive(t), y.revive(n), r))
		}
		$copy(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.copy) throw new Error('FileSystemProvider does not implement "copy"')
			return Promise.resolve(i.copy(y.revive(t), y.revive(n), r))
		}
		$mkdir(e, t) {
			return Promise.resolve(this._getFsProvider(e).createDirectory(y.revive(t)))
		}
		$watch(e, t, n, r) {
			let i = this._getFsProvider(e).watch(y.revive(n), r)
			this._watches.set(t, i)
		}
		$unwatch(e, t) {
			let n = this._watches.get(t)
			n && (n.dispose(), this._watches.delete(t))
		}
		$open(e, t, n) {
			let r = this._getFsProvider(e)
			if (!r.open) throw new Error('FileSystemProvider does not implement "open"')
			return Promise.resolve(r.open(y.revive(t), n))
		}
		$close(e, t) {
			let n = this._getFsProvider(e)
			if (!n.close) throw new Error('FileSystemProvider does not implement "close"')
			return Promise.resolve(n.close(t))
		}
		$read(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.read) throw new Error('FileSystemProvider does not implement "read"')
			let s = z.alloc(r)
			return Promise.resolve(i.read(t, n, s.buffer, 0, r)).then((a) => s.slice(0, a))
		}
		$write(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.write) throw new Error('FileSystemProvider does not implement "write"')
			return Promise.resolve(i.write(t, n, r.buffer, 0, r.byteLength))
		}
		_getFsProvider(e) {
			let t = this._fsProvider.get(e)
			if (!t) {
				let n = new Error()
				throw ((n.name = "ENOPRO"), (n.message = "no provider"), n)
			}
			return t
		}
	}
function eS(o) {
	return typeof o.correlationId == "number"
}
function wN(o) {
	return o.recursive === !0
}
var XC = class o extends $ {
		constructor(t, n, r, i) {
			super()
			this.onFileChanges = t
			this.onLogMessage = n
			this.verboseLogging = r
			this.options = i
			this.watcherDisposables = this._register(new Dn())
			this.requests = void 0
			this.restartCounter = 0
		}
		static {
			this.MAX_RESTARTS = 5
		}
		init() {
			let t = new Q()
			;(this.watcherDisposables.value = t),
				(this.watcher = this.createWatcher(t)),
				this.watcher.setVerboseLogging(this.verboseLogging),
				t.add(this.watcher.onDidChangeFile((n) => this.onFileChanges(n))),
				t.add(this.watcher.onDidLogMessage((n) => this.onLogMessage(n))),
				t.add(this.watcher.onDidError((n) => this.onError(n.error, n.request)))
		}
		onError(t, n) {
			this.canRestart(t, n)
				? this.restartCounter < o.MAX_RESTARTS && this.requests
					? (this.error(`restarting watcher after unexpected error: ${t}`), this.restart(this.requests))
					: this.error(`gave up attempting to restart watcher after unexpected error: ${t}`)
				: this.error(t)
		}
		canRestart(t, n) {
			return !(
				!this.options.restartOnError ||
				n ||
				t.indexOf("No space left on device") !== -1 ||
				t.indexOf("EMFILE") !== -1
			)
		}
		restart(t) {
			this.restartCounter++, this.init(), this.watch(t)
		}
		async watch(t) {
			;(this.requests = t), await this.watcher?.watch(t)
		}
		async setVerboseLogging(t) {
			;(this.verboseLogging = t), await this.watcher?.setVerboseLogging(t)
		}
		error(t) {
			this.onLogMessage({ type: "error", message: `[File Watcher (${this.options.type})] ${t}` })
		}
		trace(t) {
			this.onLogMessage({ type: "trace", message: `[File Watcher (${this.options.type})] ${t}` })
		}
		dispose() {
			return (this.watcher = void 0), super.dispose()
		}
	},
	YC = class extends XC {
		constructor(e, t, n) {
			super(e, t, n, { type: "node.js", restartOnError: !1 })
		}
	},
	ZC = class extends XC {
		constructor(e, t, n) {
			super(e, t, n, { type: "universal", restartOnError: !0 })
		}
	}
function l1(o) {
	return o.map((e) => ({ type: e.type, resource: y.revive(e.resource), cId: e.cId }))
}
function PN(o) {
	let e = new a1()
	for (let t of o) e.processEvent(t)
	return e.coalesce()
}
function d1(o, e) {
	return typeof e == "string" && !e.startsWith(ms) && !In(e) ? { base: o, pattern: e } : e
}
function c1(o, e) {
	let t = []
	for (let n of e) t.push(Xn(d1(o, n)))
	return t
}
var a1 = class {
	constructor() {
		this.coalesced = new Set()
		this.mapPathToChange = new Map()
	}
	toKey(e) {
		return Ve ? e.resource.fsPath : e.resource.fsPath.toLowerCase()
	}
	processEvent(e) {
		let t = this.mapPathToChange.get(this.toKey(e)),
			n = !1
		if (t) {
			let r = t.type,
				i = e.type
			t.resource.fsPath !== e.resource.fsPath && (e.type === 2 || e.type === 1)
				? (n = !0)
				: r === 1 && i === 2
					? (this.mapPathToChange.delete(this.toKey(e)), this.coalesced.delete(t))
					: r === 2 && i === 1
						? (t.type = 0)
						: (r === 1 && i === 0) || (t.type = i)
		} else n = !0
		n && (this.coalesced.add(e), this.mapPathToChange.set(this.toKey(e), e))
	}
	coalesce() {
		let e = [],
			t = []
		return Array.from(this.coalesced)
			.filter((n) => (n.type !== 2 ? (e.push(n), !1) : !0))
			.sort((n, r) => n.resource.fsPath.length - r.resource.fsPath.length)
			.filter((n) => (t.some((r) => tL(n.resource.fsPath, r, !Ve)) ? !1 : (t.push(n.resource.fsPath), !0)))
			.concat(e)
	}
}
function _N(o, e) {
	if (typeof e == "number")
		switch (o.type) {
			case 1:
				return (e & 4) === 0
			case 2:
				return (e & 8) === 0
			case 0:
				return (e & 2) === 0
		}
	return !1
}
function DN(o) {
	if (typeof o == "number") {
		let e = []
		return (
			o & 4 && e.push("Added"),
			o & 8 && e.push("Deleted"),
			o & 2 && e.push("Updated"),
			e.length === 0 ? "<all>" : `[${e.join(", ")}]`
		)
	}
	return "<none>"
}
var u1 = class {
		constructor(e, t, n, r, i, s, a) {
			this.session = Math.random()
			this._onDidCreate = new E()
			this._onDidChange = new E()
			this._onDidDelete = new E()
			;(this._config = 0),
				a.ignoreCreateEvents && (this._config += 1),
				a.ignoreChangeEvents && (this._config += 2),
				a.ignoreDeleteEvents && (this._config += 4)
			let l = Xn(s),
				d = typeof s == "string",
				c = !1,
				u = i((m) => {
					if (
						!(typeof m.session == "number" && m.session !== this.session) &&
						!(c && typeof m.session > "u")
					) {
						if (!a.ignoreCreateEvents)
							for (let f of m.created) {
								let h = y.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidCreate.fire(h)
							}
						if (!a.ignoreChangeEvents)
							for (let f of m.changed) {
								let h = y.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidChange.fire(h)
							}
						if (!a.ignoreDeleteEvents)
							for (let f of m.deleted) {
								let h = y.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidDelete.fire(h)
							}
					}
				})
			this._disposable = ye.from(
				this.ensureWatching(e, n, t, r, s, a, !1),
				this._onDidCreate,
				this._onDidChange,
				this._onDidDelete,
				u,
			)
		}
		get ignoreCreateEvents() {
			return !!(this._config & 1)
		}
		get ignoreChangeEvents() {
			return !!(this._config & 2)
		}
		get ignoreDeleteEvents() {
			return !!(this._config & 4)
		}
		ensureWatching(e, t, n, r, i, s, a) {
			let l = ye.from()
			if (typeof i == "string" || (s.ignoreChangeEvents && s.ignoreCreateEvents && s.ignoreDeleteEvents)) return l
			let d = e.getProxy(N.MainThreadFileSystemEventService),
				c = !1
			;(i.pattern.includes(ms) || i.pattern.includes(Kb)) && (c = !0)
			let u = [],
				m,
				f
			if (a)
				(s.ignoreChangeEvents || s.ignoreCreateEvents || s.ignoreDeleteEvents) &&
					((f = 14),
					s.ignoreChangeEvents && (f &= -3),
					s.ignoreCreateEvents && (f &= -5),
					s.ignoreDeleteEvents && (f &= -9))
			else if (c && u.length === 0) {
				let h = t.getWorkspaceFolder(y.revive(i.baseUri)),
					g = n.getConfiguration("files", h).get("watcherExclude")
				if (g) for (let I in g) I && g[I] === !0 && u.push(I)
			} else if (!c) {
				let h = t.getWorkspaceFolder(y.revive(i.baseUri))
				if (h) {
					let g = n.getConfiguration("files", h).get("watcherExclude")
					if (g) {
						for (let I in g)
							if (I && g[I] === !0) {
								let C = `${Dr(I, "/")}/${ms}`
								m || (m = []), m.push(d1(h.uri.fsPath, C))
							}
					}
					if (!m || m.length === 0) return l
				}
			}
			return (
				d.$watch(
					r.identifier.value,
					this.session,
					i.baseUri,
					{ recursive: c, excludes: u, includes: m, filter: f },
					!!a,
				),
				ye.from({ dispose: () => d.$unwatch(this.session) })
			)
		}
		dispose() {
			this._disposable.dispose()
		}
		get onDidCreate() {
			return this._onDidCreate.event
		}
		get onDidChange() {
			return this._onDidChange.event
		}
		get onDidDelete() {
			return this._onDidDelete.event
		}
	},
	p1 = class {
		constructor(e) {
			this._events = e
			this._created = new Rt(() => this._events.created.map(y.revive))
			this._changed = new Rt(() => this._events.changed.map(y.revive))
			this._deleted = new Rt(() => this._events.deleted.map(y.revive))
			this.session = this._events.session
		}
		get created() {
			return this._created.value
		}
		get changed() {
			return this._changed.value
		}
		get deleted() {
			return this._deleted.value
		}
	},
	tS = class {
		constructor(e, t, n) {
			this._mainContext = e
			this._logService = t
			this._extHostDocumentsAndEditors = n
			this._onFileSystemEvent = new E()
			this._onDidRenameFile = new E()
			this._onDidCreateFile = new E()
			this._onDidDeleteFile = new E()
			this._onWillRenameFile = new si()
			this._onWillCreateFile = new si()
			this._onWillDeleteFile = new si()
			this.onDidRenameFile = this._onDidRenameFile.event
			this.onDidCreateFile = this._onDidCreateFile.event
			this.onDidDeleteFile = this._onDidDeleteFile.event
		}
		createFileSystemWatcher(e, t, n, r, i) {
			return new u1(this._mainContext, t, e, n, this._onFileSystemEvent.event, yr.from(r), i)
		}
		$onFileEvent(e) {
			this._onFileSystemEvent.fire(new p1(e))
		}
		$onDidRunFileOperation(e, t) {
			switch (e) {
				case 2:
					this._onDidRenameFile.fire(
						Object.freeze({
							files: t.map((n) => ({ oldUri: y.revive(n.source), newUri: y.revive(n.target) })),
						}),
					)
					break
				case 1:
					this._onDidDeleteFile.fire(Object.freeze({ files: t.map((n) => y.revive(n.target)) }))
					break
				case 0:
				case 3:
					this._onDidCreateFile.fire(Object.freeze({ files: t.map((n) => y.revive(n.target)) }))
					break
				default:
			}
		}
		getOnWillRenameFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillRenameFile)
		}
		getOnWillCreateFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillCreateFile)
		}
		getOnWillDeleteFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillDeleteFile)
		}
		_createWillExecuteEvent(e, t) {
			return (n, r, i) => {
				let s = function (l) {
					n.call(r, l)
				}
				return (s.extension = e), t.event(s, void 0, i)
			}
		}
		async $onWillRunFileOperation(e, t, n, r) {
			switch (e) {
				case 2:
					return await this._fireWillEvent(
						this._onWillRenameFile,
						{ files: t.map((i) => ({ oldUri: y.revive(i.source), newUri: y.revive(i.target) })) },
						n,
						r,
					)
				case 1:
					return await this._fireWillEvent(
						this._onWillDeleteFile,
						{ files: t.map((i) => y.revive(i.target)) },
						n,
						r,
					)
				case 0:
				case 3:
					return await this._fireWillEvent(
						this._onWillCreateFile,
						{ files: t.map((i) => y.revive(i.target)) },
						n,
						r,
					)
			}
		}
		async _fireWillEvent(e, t, n, r) {
			let i = new Set(),
				s = []
			if (
				(await e.fireAsync(t, r, async (l, d) => {
					let c = Date.now(),
						u = await Promise.resolve(l)
					u instanceof Jr &&
						(s.push([d.extension, u]), i.add(d.extension.displayName ?? d.extension.identifier.value)),
						Date.now() - c > n && this._logService.warn("SLOW file-participant", d.extension.identifier)
				}),
				r.isCancellationRequested || s.length === 0)
			)
				return
			let a = { edits: [] }
			for (let [, l] of s) {
				let { edits: d } = $n.from(l, {
					getTextDocumentVersion: (c) => this._extHostDocumentsAndEditors.getDocument(c)?.version,
					getNotebookDocumentVersion: () => {},
				})
				a.edits = a.edits.concat(d)
			}
			return { edit: a, extensionNames: Array.from(i) }
		}
	}
var nS = class {
	constructor(e, t, n, r, i) {
		this._extHostNotebooks = t
		this._textDocumentsAndEditors = n
		this._commands = r
		let s = new be(
			"interactive.open",
			"_interactive.open",
			"Open interactive window and return notebook editor and input URI",
			[
				new G(
					"showOptions",
					"Show Options",
					(a) => !0,
					(a) => a,
				),
				new G(
					"resource",
					"Interactive resource Uri",
					(a) => !0,
					(a) => a,
				),
				new G(
					"controllerId",
					"Notebook controller Id",
					(a) => !0,
					(a) => a,
				),
				new G(
					"title",
					"Interactive editor title",
					(a) => !0,
					(a) => a,
				),
			],
			new ge("Notebook and input URI", (a) => {
				if (
					(i.debug("[ExtHostInteractive] open iw with notebook editor id", a.notebookEditorId),
					a.notebookEditorId !== void 0)
				) {
					let l = this._extHostNotebooks.getEditorById(a.notebookEditorId)
					return (
						i.debug("[ExtHostInteractive] notebook editor found", l.id),
						{
							notebookUri: y.revive(a.notebookUri),
							inputUri: y.revive(a.inputUri),
							notebookEditor: l.apiEditor,
						}
					)
				}
				return (
					i.debug(
						"[ExtHostInteractive] notebook editor not found, uris for the interactive document",
						a.notebookUri,
						a.inputUri,
					),
					{ notebookUri: y.revive(a.notebookUri), inputUri: y.revive(a.inputUri) }
				)
			}),
		)
		this._commands.registerApiCommand(s)
	}
	$willAddInteractiveDocument(e, t, n, r) {
		this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
			addedDocuments: [
				{ EOL: t, lines: [""], languageId: n, uri: e, isDirty: !1, versionId: 1, encoding: "utf8" },
			],
		})
	}
	$willRemoveInteractiveDocument(e, t) {
		this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({ removedDocuments: [e] })
	}
}
var rS = class {
	constructor(e) {
		this._handlePool = 0
		this._proxy = e.getProxy(N.MainThreadLabelService)
	}
	$registerResourceLabelFormatter(e) {
		let t = this._handlePool++
		return (
			this._proxy.$registerResourceLabelFormatter(t, e),
			q(() => {
				this._proxy.$unregisterResourceLabelFormatter(t)
			})
		)
	}
}
var oS = class o extends Re {
	constructor(e, t, n, r) {
		super(e, t, n, r),
			(this.selectionStartLineNumber = e),
			(this.selectionStartColumn = t),
			(this.positionLineNumber = n),
			(this.positionColumn = r)
	}
	toString() {
		return (
			"[" +
			this.selectionStartLineNumber +
			"," +
			this.selectionStartColumn +
			" -> " +
			this.positionLineNumber +
			"," +
			this.positionColumn +
			"]"
		)
	}
	equalsSelection(e) {
		return o.selectionsEqual(this, e)
	}
	static selectionsEqual(e, t) {
		return (
			e.selectionStartLineNumber === t.selectionStartLineNumber &&
			e.selectionStartColumn === t.selectionStartColumn &&
			e.positionLineNumber === t.positionLineNumber &&
			e.positionColumn === t.positionColumn
		)
	}
	getDirection() {
		return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn
			? 0
			: 1
	}
	setEndPosition(e, t) {
		return this.getDirection() === 0
			? new o(this.startLineNumber, this.startColumn, e, t)
			: new o(e, t, this.startLineNumber, this.startColumn)
	}
	getPosition() {
		return new cn(this.positionLineNumber, this.positionColumn)
	}
	getSelectionStart() {
		return new cn(this.selectionStartLineNumber, this.selectionStartColumn)
	}
	setStartPosition(e, t) {
		return this.getDirection() === 0
			? new o(e, t, this.endLineNumber, this.endColumn)
			: new o(this.endLineNumber, this.endColumn, e, t)
	}
	static fromPositions(e, t = e) {
		return new o(e.lineNumber, e.column, t.lineNumber, t.column)
	}
	static fromRange(e, t) {
		return t === 0
			? new o(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn)
			: new o(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn)
	}
	static liftSelection(e) {
		return new o(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn)
	}
	static selectionsArrEqual(e, t) {
		if ((e && !t) || (!e && t)) return !1
		if (!e && !t) return !0
		if (e.length !== t.length) return !1
		for (let n = 0, r = e.length; n < r; n++) if (!this.selectionsEqual(e[n], t[n])) return !1
		return !0
	}
	static isISelection(e) {
		return (
			e &&
			typeof e.selectionStartLineNumber == "number" &&
			typeof e.selectionStartColumn == "number" &&
			typeof e.positionLineNumber == "number" &&
			typeof e.positionColumn == "number"
		)
	}
	static createWithDirection(e, t, n, r, i) {
		return i === 0 ? new o(e, t, n, r) : new o(n, r, e, t)
	}
}
var iS = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentSymbols(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentSymbols(n, t)
			if (!Qm(r)) return r[0] instanceof Xr ? r.map(AD.from) : o._asDocumentSymbolTree(r)
		}
		static _asDocumentSymbolTree(e) {
			e = e.slice(0).sort((r, i) => {
				let s = r.location.range.start.compareTo(i.location.range.start)
				return s === 0 && (s = i.location.range.end.compareTo(r.location.range.end)), s
			})
			let t = [],
				n = []
			for (let r of e) {
				let i = {
					name: r.name || "!!MISSING: name!!",
					kind: Yr.from(r.kind),
					tags: r.tags?.map(Ls.from) || [],
					detail: "",
					containerName: r.containerName,
					range: H.from(r.location.range),
					selectionRange: H.from(r.location.range),
					children: [],
				}
				for (;;) {
					if (n.length === 0) {
						n.push(i), t.push(i)
						break
					}
					let s = n[n.length - 1]
					if (Re.containsRange(s.range, i.range) && !Re.equalsRange(s.range, i.range)) {
						s.children?.push(i), n.push(i)
						break
					}
					n.pop()
				}
			}
			return t
		}
	},
	mm = class {
		constructor(e, t, n, r, i, s) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._extension = r
			this._extTelemetry = i
			this._logService = s
			this._cache = new pr("CodeLens")
			this._disposables = new Map()
		}
		async provideCodeLenses(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideCodeLenses(n, t)
			if (!r || t.isCancellationRequested) return
			let i = this._cache.add(r),
				s = new Q()
			this._disposables.set(i, s)
			let a = { cacheId: i, lenses: [] }
			for (let l = 0; l < r.length; l++) {
				if (!pe.isRange(r[l].range)) {
					console.warn("INVALID code lens, range is not defined", this._extension.identifier.value)
					continue
				}
				a.lenses.push({
					cacheId: [i, l],
					range: H.from(r[l].range),
					command: this._commands.toInternal(r[l].command, s),
				})
			}
			return a
		}
		async resolveCodeLens(e, t) {
			let n = e.cacheId && this._cache.get(...e.cacheId)
			if (!n) return
			let r
			if (
				(typeof this._provider.resolveCodeLens != "function" || n.isResolved
					? (r = n)
					: (r = await this._provider.resolveCodeLens(n, t)),
				r || (r = n),
				t.isCancellationRequested)
			)
				return
			let i = e.cacheId && this._disposables.get(e.cacheId[0])
			if (i) {
				if (!r.command) {
					let s = new Error("INVALID code lens resolved, lacks command: " + this._extension.identifier.value)
					this._extTelemetry.onExtensionError(this._extension.identifier, s), this._logService.error(s)
					return
				}
				return (e.command = this._commands.toInternal(r.command, i)), e
			}
		}
		releaseCodeLenses(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
	}
function SS(o) {
	return Array.isArray(o) ? o.map(Qu.from) : o ? [Qu.from(o)] : []
}
var sS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDefinition(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDefinition(r, i, n)
			return SS(s)
		}
	},
	aS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDeclaration(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDeclaration(r, i, n)
			return SS(s)
		}
	},
	lS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideImplementation(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideImplementation(r, i, n)
			return SS(s)
		}
	},
	dS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideTypeDefinition(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideTypeDefinition(r, i, n)
			return SS(s)
		}
	},
	gh = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._hoverCounter = 0
			this._hoverMap = new Map()
		}
		static {
			this.HOVER_MAP_MAX_SIZE = 10
		}
		async provideHover(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a
			if (n && n.verbosityRequest) {
				let u = n.verbosityRequest.previousHover.id,
					m = this._hoverMap.get(u)
				if (!m) throw new Error(`Hover with id ${u} not found`)
				let f = { verbosityDelta: n.verbosityRequest.verbosityDelta, previousHover: m }
				a = await this._provider.provideHover(i, s, r, f)
			} else a = await this._provider.provideHover(i, s, r)
			if (!a || Qm(a.contents)) return
			a.range || (a.range = i.getWordRangeAtPosition(s)), a.range || (a.range = new pe(s, s))
			let l = Ju.from(a),
				d = this._hoverCounter
			if (this._hoverMap.size === o.HOVER_MAP_MAX_SIZE) {
				let u = Math.min(...this._hoverMap.keys())
				this._hoverMap.delete(u)
			}
			return this._hoverMap.set(d, a), (this._hoverCounter += 1), { ...l, id: d }
		}
		releaseHover(e) {
			this._hoverMap.delete(e)
		}
	},
	cS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideEvaluatableExpression(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideEvaluatableExpression(r, i, n)
			if (s) return MD.from(s)
		}
	},
	uS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideInlineValues(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = await this._provider.provideInlineValues(i, H.to(t), yg.to(n), r)
			if (Array.isArray(s)) return s.map((a) => bg.from(a))
		}
	},
	pS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentHighlights(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDocumentHighlights(r, i, n)
			if (Array.isArray(s)) return s.map(Td.from)
		}
	},
	mS = class {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		async provideMultiDocumentHighlights(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = n
					.map((d) => {
						try {
							return this._documents.getDocument(d)
						} catch (c) {
							this._logService.error(
								"Error: Unable to retrieve document from URI: " + d + ". Error message: " + c,
							)
							return
						}
					})
					.filter((d) => d !== void 0),
				a = Je.to(t),
				l = await this._provider.provideMultiDocumentHighlights(i, a, s, r)
			if (Array.isArray(l)) return l.map(FD.from)
		}
	},
	fS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideLinkedEditingRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideLinkedEditingRanges(r, i, n)
			if (s && Array.isArray(s.ranges)) return { ranges: Ye(s.ranges.map(H.from)), wordPattern: s.wordPattern }
		}
	},
	gS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideReferences(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = await this._provider.provideReferences(i, s, n, r)
			if (Array.isArray(a)) return a.map(Bn.from)
		}
	},
	fm = class o {
		constructor(e, t, n, r, i, s, a) {
			this._documents = e
			this._commands = t
			this._diagnostics = n
			this._provider = r
			this._logService = i
			this._extension = s
			this._apiDeprecation = a
			this._cache = new pr("CodeAction")
			this._disposables = new Map()
		}
		static {
			this._maxCodeActionsPerFile = 1e3
		}
		async provideCodeActions(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = oS.isISelection(t) ? Zn.to(t) : H.to(t),
				a = []
			for (let f of this._diagnostics.getDiagnostics(e))
				if (s.intersection(f.range) && a.push(f) > o._maxCodeActionsPerFile) break
			let l = { diagnostics: a, only: n.only ? new lt(n.only) : void 0, triggerKind: QD.to(n.trigger) },
				d = await this._provider.provideCodeActions(i, s, l, r)
			if (!ri(d) || r.isCancellationRequested) return
			let c = this._cache.add(d),
				u = new Q()
			this._disposables.set(c, u)
			let m = []
			for (let f = 0; f < d.length; f++) {
				let h = d[f]
				if (h)
					if (o._isCommand(h) && !(h instanceof yi))
						this._apiDeprecation.report(
							"CodeActionProvider.provideCodeActions - return commands",
							this._extension,
							"Return 'CodeAction' instances instead.",
						),
							m.push({ _isSynthetic: !0, title: h.title, command: this._commands.toInternal(h, u) })
					else {
						let g = h
						l.only &&
							(g.kind
								? l.only.contains(g.kind) ||
									this._logService.warn(
										`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action is of kind '${g.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`,
									)
								: this._logService.warn(
										`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`,
									))
						let I = g.ranges ?? []
						m.push({
							cacheId: [c, f],
							title: g.title,
							command: g.command && this._commands.toInternal(g.command, u),
							diagnostics: g.diagnostics && g.diagnostics.map(_d.from),
							edit: g.edit && $n.from(g.edit, void 0),
							kind: g.kind && g.kind.value,
							isPreferred: g.isPreferred,
							isAI: nt(this._extension, "codeActionAI") ? g.isAI : !1,
							ranges: nt(this._extension, "codeActionRanges") ? Ye(I.map(H.from)) : void 0,
							disabled: g.disabled?.reason,
						})
					}
			}
			return { cacheId: c, actions: m }
		}
		async resolveCodeAction(e, t) {
			let [n, r] = e,
				i = this._cache.get(n, r)
			if (!i || o._isCommand(i)) return {}
			if (!this._provider.resolveCodeAction) return {}
			let s = (await this._provider.resolveCodeAction(i, t)) ?? i,
				a
			s.edit && (a = $n.from(s.edit, void 0))
			let l
			if (s.command) {
				let d = this._disposables.get(n)
				d && (l = this._commands.toInternal(s.command, d))
			}
			return { edit: a, command: l }
		}
		releaseCodeActions(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		static _isCommand(e) {
			return typeof e.command == "string" && typeof e.title == "string"
		}
	},
	zd = class {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._documents = t
			this._provider = n
			this._handle = r
			this._extension = i
			this._editsCache = new pr("DocumentPasteEdit.edits")
		}
		async prepareDocumentPaste(e, t, n, r) {
			if (!this._provider.prepareDocumentPaste) return
			this._cachedPrepare = void 0
			let i = this._documents.getDocument(e),
				s = t.map((u) => H.to(u)),
				a = Rd.toDataTransfer(n, () => {
					throw new Gh()
				})
			if ((await this._provider.prepareDocumentPaste(i, s, a, r), r.isCancellationRequested)) return
			let l = Array.from(a).filter(([, u]) => !(u instanceof Va)),
				d = new Map(),
				c = await Promise.all(
					Array.from(l, async ([u, m]) => {
						let f = He()
						return d.set(f, m), [u, await Sd.from(u, m, f)]
					}),
				)
			return (this._cachedPrepare = d), { items: c }
		}
		async providePasteEdits(e, t, n, r, i, s) {
			if (!this._provider.provideDocumentPasteEdits) return []
			let a = this._documents.getDocument(t),
				l = n.map((f) => H.to(f)),
				d = r.items.map(([f, h]) => {
					let g = this._cachedPrepare?.get(h.id)
					return g
						? [f, g]
						: [
								f,
								Sd.to(
									f,
									h,
									async (I) => (await this._proxy.$resolvePasteFileData(this._handle, e, I)).buffer,
								),
							]
				}),
				c = new vo(d),
				u = await this._provider.provideDocumentPasteEdits(
					a,
					l,
					c,
					{ only: i.only ? new bo(i.only) : void 0, triggerKind: i.triggerKind },
					s,
				)
			if (!u || s.isCancellationRequested) return []
			let m = this._editsCache.add(u)
			return u.map((f, h) => ({
				_cacheId: [m, h],
				title:
					f.title ??
					p(
						"defaultPasteLabel",
						"Paste using '{0}' extension",
						this._extension.displayName || this._extension.name,
					),
				kind: f.kind,
				yieldTo: f.yieldTo?.map((g) => g.value),
				insertText: typeof f.insertText == "string" ? f.insertText : { snippet: f.insertText.value },
				additionalEdit: f.additionalEdit ? $n.from(f.additionalEdit, void 0) : void 0,
			}))
		}
		async resolvePasteEdit(e, t) {
			let [n, r] = e,
				i = this._editsCache.get(n, r)
			if (!i || !this._provider.resolveDocumentPasteEdit) return {}
			let s = (await this._provider.resolveDocumentPasteEdit(i, t)) ?? i
			return {
				insertText: s.insertText,
				additionalEdit: s.additionalEdit ? $n.from(s.additionalEdit, void 0) : void 0,
			}
		}
		releasePasteEdits(e) {
			this._editsCache.delete(e)
		}
	},
	hS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentFormattingEdits(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideDocumentFormattingEdits(r, t, n)
			if (Array.isArray(i)) return i.map(on.from)
		}
	},
	hh = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentRangeFormattingEdits(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = H.to(t),
				a = await this._provider.provideDocumentRangeFormattingEdits(i, s, n, r)
			if (Array.isArray(a)) return a.map(on.from)
		}
		async provideDocumentRangesFormattingEdits(e, t, n, r) {
			fc(
				typeof this._provider.provideDocumentRangesFormattingEdits == "function",
				"INVALID invocation of `provideDocumentRangesFormattingEdits`",
			)
			let i = this._documents.getDocument(e),
				s = t.map(H.to),
				a = await this._provider.provideDocumentRangesFormattingEdits(i, s, n, r)
			if (Array.isArray(a)) return a.map(on.from)
		}
	},
	vS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this.autoFormatTriggerCharacters = []
		}
		async provideOnTypeFormattingEdits(e, t, n, r, i) {
			let s = this._documents.getDocument(e),
				a = Je.to(t),
				l = await this._provider.provideOnTypeFormattingEdits(s, a, n, r, i)
			if (Array.isArray(l)) return l.map(on.from)
		}
	},
	gm = class {
		constructor(e, t) {
			this._provider = e
			this._logService = t
			this._cache = new pr("WorkspaceSymbols")
		}
		async provideWorkspaceSymbols(e, t) {
			let n = await this._provider.provideWorkspaceSymbols(e, t)
			if (!ri(n)) return { symbols: [] }
			let r = this._cache.add(n),
				i = { cacheId: r, symbols: [] }
			for (let s = 0; s < n.length; s++) {
				let a = n[s]
				if (!a || !a.name) {
					this._logService.warn("INVALID SymbolInformation", a)
					continue
				}
				i.symbols.push({ ...Xa.from(a), cacheId: [r, s] })
			}
			return i
		}
		async resolveWorkspaceSymbol(e, t) {
			if (typeof this._provider.resolveWorkspaceSymbol != "function" || !e.cacheId) return e
			let n = this._cache.get(...e.cacheId)
			if (n) {
				let r = await this._provider.resolveWorkspaceSymbol(n, t)
				return r && fr(e, Xa.from(r), !0)
			}
		}
		releaseWorkspaceSymbols(e) {
			this._cache.delete(e)
		}
	},
	hm = class o {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		static supportsResolving(e) {
			return typeof e.prepareRename == "function"
		}
		async provideRenameEdits(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t)
			try {
				let a = await this._provider.provideRenameEdits(i, s, n, r)
				return a ? $n.from(a) : void 0
			} catch (a) {
				let l = o._asMessage(a)
				return l ? { rejectReason: l, edits: void 0 } : Promise.reject(a)
			}
		}
		async resolveRenameLocation(e, t, n) {
			if (typeof this._provider.prepareRename != "function") return Promise.resolve(void 0)
			let r = this._documents.getDocument(e),
				i = Je.to(t)
			try {
				let s = await this._provider.prepareRename(r, i, n),
					a,
					l
				if (
					(pe.isRange(s) ? ((a = s), (l = r.getText(s))) : dt(s) && ((a = s.range), (l = s.placeholder)),
					!a || !l)
				)
					return
				if (a.start.line > i.line || a.end.line < i.line) {
					this._logService.warn("INVALID rename location: position line must be within range start/end lines")
					return
				}
				return { range: H.from(a), text: l }
			} catch (s) {
				let a = o._asMessage(s)
				return a ? { rejectReason: a, range: void 0, text: void 0 } : Promise.reject(s)
			}
		}
		static _asMessage(e) {
			return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0
		}
	},
	vh = class o {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		static {
			this.languageTriggerKindToVSCodeTriggerKind = { 0: 0, 1: 1 }
		}
		async supportsAutomaticNewSymbolNamesTriggerKind() {
			return this._provider.supportsAutomaticTriggerKind
		}
		async provideNewSymbolNames(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = H.to(t)
			try {
				let a = o.languageTriggerKindToVSCodeTriggerKind[n],
					l = await this._provider.provideNewSymbolNames(i, s, a, r)
				return l
					? l.map((d) =>
							typeof d == "string"
								? { newSymbolName: d }
								: { newSymbolName: d.newSymbolName, tags: d.tags },
						)
					: void 0
			} catch (a) {
				this._logService.error(o._asMessage(a) ?? JSON.stringify(a, null, "	"))
				return
			}
		}
		static _asMessage(e) {
			return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0
		}
	},
	bh = class {
		constructor(e, t) {
			this.resultId = e
			this.tokens = t
		}
	},
	yh = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._nextResultId = 1
			this._previousResults = new Map()
		}
		async provideDocumentSemanticTokens(e, t, n) {
			let r = this._documents.getDocument(e),
				i = t !== 0 ? this._previousResults.get(t) : null,
				s =
					typeof i?.resultId == "string" &&
					typeof this._provider.provideDocumentSemanticTokensEdits == "function"
						? await this._provider.provideDocumentSemanticTokensEdits(r, i.resultId, n)
						: await this._provider.provideDocumentSemanticTokens(r, n)
			return (
				i && this._previousResults.delete(t),
				s ? ((s = o._fixProvidedSemanticTokens(s)), this._send(o._convertToEdits(i, s), s)) : null
			)
		}
		async releaseDocumentSemanticColoring(e) {
			this._previousResults.delete(e)
		}
		static _fixProvidedSemanticTokens(e) {
			return o._isSemanticTokens(e)
				? o._isCorrectSemanticTokens(e)
					? e
					: new Qo(new Uint32Array(e.data), e.resultId)
				: o._isSemanticTokensEdits(e)
					? o._isCorrectSemanticTokensEdits(e)
						? e
						: new Ba(
								e.edits.map(
									(t) => new Su(t.start, t.deleteCount, t.data ? new Uint32Array(t.data) : t.data),
								),
								e.resultId,
							)
					: e
		}
		static _isSemanticTokens(e) {
			return e && !!e.data
		}
		static _isCorrectSemanticTokens(e) {
			return e.data instanceof Uint32Array
		}
		static _isSemanticTokensEdits(e) {
			return e && Array.isArray(e.edits)
		}
		static _isCorrectSemanticTokensEdits(e) {
			for (let t of e.edits) if (!(t.data instanceof Uint32Array)) return !1
			return !0
		}
		static _convertToEdits(e, t) {
			if (!o._isSemanticTokens(t) || !e || !e.tokens) return t
			let n = e.tokens,
				r = n.length,
				i = t.data,
				s = i.length,
				a = 0,
				l = Math.min(r, s)
			for (; a < l && n[a] === i[a]; ) a++
			if (a === r && a === s) return new Ba([], t.resultId)
			let d = 0,
				c = l - a
			for (; d < c && n[r - d - 1] === i[s - d - 1]; ) d++
			return new Ba([{ start: a, deleteCount: r - a - d, data: i.subarray(a, s - d) }], t.resultId)
		}
		_send(e, t) {
			if (o._isSemanticTokens(e)) {
				let n = this._nextResultId++
				return (
					this._previousResults.set(n, new bh(e.resultId, e.data)), kC({ id: n, type: "full", data: e.data })
				)
			}
			if (o._isSemanticTokensEdits(e)) {
				let n = this._nextResultId++
				return (
					o._isSemanticTokens(t)
						? this._previousResults.set(n, new bh(t.resultId, t.data))
						: this._previousResults.set(n, new bh(e.resultId)),
					kC({
						id: n,
						type: "delta",
						deltas: (e.edits || []).map((r) => ({
							start: r.start,
							deleteCount: r.deleteCount,
							data: r.data,
						})),
					})
				)
			}
			return null
		}
	},
	bS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentRangeSemanticTokens(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideDocumentRangeSemanticTokens(r, H.to(t), n)
			return i ? this._send(i) : null
		}
		_send(e) {
			return kC({ id: 0, type: "full", data: e.data })
		}
	},
	qd = class o {
		constructor(e, t, n, r, i) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._apiDeprecation = r
			this._extension = i
			this._cache = new pr("CompletionItem")
			this._disposables = new Map()
		}
		static supportsResolving(e) {
			return typeof e.resolveCompletionItem == "function"
		}
		async provideCompletionItems(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = i.getWordRangeAtPosition(s) || new pe(s, s),
				l = a.with({ end: s }),
				d = new zt(),
				c = await this._provider.provideCompletionItems(i, s, r, ND.to(n))
			if (!c || r.isCancellationRequested) return
			let u = Array.isArray(c) ? new Bo(c) : c,
				m = o.supportsResolving(this._provider) ? this._cache.add(u.items) : this._cache.add([]),
				f = new Q()
			this._disposables.set(m, f)
			let h = [],
				g = {
					x: m,
					b: h,
					a: { replace: H.from(a), insert: H.from(l) },
					c: u.isIncomplete || void 0,
					d: d.elapsed(),
				}
			for (let I = 0; I < u.items.length; I++) {
				let C = u.items[I],
					T = this._convertCompletionItem(C, [m, I], l, a)
				h.push(T)
			}
			return g
		}
		async resolveCompletionItem(e, t) {
			if (typeof this._provider.resolveCompletionItem != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = this._convertCompletionItem(n, e),
				i = await this._provider.resolveCompletionItem(n, t)
			if (!i) return
			let s = this._convertCompletionItem(i, e)
			return (
				(r.h !== s.h || r.i !== s.i) &&
					this._apiDeprecation.report(
						"CompletionItem.insertText",
						this._extension,
						"extension MAY NOT change 'insertText' of a CompletionItem during resolve",
					),
				(r.n !== s.n || r.o !== s.o || !nn(r.p, s.p)) &&
					this._apiDeprecation.report(
						"CompletionItem.command",
						this._extension,
						"extension MAY NOT change 'command' of a CompletionItem during resolve",
					),
				{ ...r, d: s.d, c: s.c, l: s.l, h: s.h, i: s.i, n: s.n, o: s.o, p: s.p }
			)
		}
		releaseCompletionItems(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		_convertCompletionItem(e, t, n, r) {
			let i = this._disposables.get(t[0])
			if (!i) throw Error("DisposableStore is missing...")
			let s = this._commands.toInternal(e.command, i),
				a = {
					x: t,
					a: e.label,
					b: e.kind !== void 0 ? ox.from(e.kind) : void 0,
					m: e.tags && e.tags.map(rx.from),
					c: e.detail,
					d: typeof e.documentation > "u" ? void 0 : Ce.fromStrict(e.documentation),
					e: e.sortText !== e.label ? e.sortText : void 0,
					f: e.filterText !== e.label ? e.filterText : void 0,
					g: e.preselect || void 0,
					i: e.keepWhitespace ? 1 : 0,
					k: e.commitCharacters?.join(""),
					l: e.additionalTextEdits && e.additionalTextEdits.map(on.from),
					n: s?.$ident,
					o: s?.id,
					p: s?.$ident ? void 0 : s?.arguments,
				}
			e.textEdit
				? (this._apiDeprecation.report(
						"CompletionItem.textEdit",
						this._extension,
						"Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.",
					),
					(a.h = e.textEdit.newText))
				: typeof e.insertText == "string"
					? (a.h = e.insertText)
					: e.insertText instanceof Wn && ((a.h = e.insertText.value), (a.i |= 4))
			let l
			return (
				e.textEdit ? (l = e.textEdit.range) : e.range && (l = e.range),
				pe.isRange(l)
					? (a.j = H.from(l))
					: l &&
						(!n?.isEqual(l.inserting) || !r?.isEqual(l.replacing)) &&
						(a.j = { insert: H.from(l.inserting), replace: H.from(l.replacing) }),
				a
			)
		}
	},
	Ks = class {
		constructor(e, t, n, r) {
			this._extension = e
			this._documents = t
			this._provider = n
			this._commands = r
			this._references = new yS()
			this._isAdditionsProposedApiEnabled = nt(this._extension, "inlineCompletionsAdditions")
			this.languageTriggerKindToVSCodeTriggerKind = { 0: 1, 1: 0 }
		}
		get supportsHandleEvents() {
			return (
				nt(this._extension, "inlineCompletionsAdditions") &&
				(typeof this._provider.handleDidShowCompletionItem == "function" ||
					typeof this._provider.handleDidPartiallyAcceptCompletionItem == "function" ||
					typeof this._provider.handleDidRejectCompletionItem == "function")
			)
		}
		async provideInlineCompletions(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = await this._provider.provideInlineCompletionItems(
					i,
					s,
					{
						selectedCompletionInfo: n.selectedSuggestionInfo
							? { range: H.to(n.selectedSuggestionInfo.range), text: n.selectedSuggestionInfo.text }
							: void 0,
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[n.triggerKind],
						requestUuid: n.requestUuid,
					},
					r,
				)
			if (!a || r.isCancellationRequested) return
			let l = Array.isArray(a) ? a : a.items,
				d = this._isAdditionsProposedApiEnabled ? (Array.isArray(a) ? [] : a.commands || []) : [],
				c = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0,
				u
			return {
				pid: this._references.createReferenceId({
					dispose() {
						u?.dispose()
					},
					items: l,
				}),
				items: l.map((f, h) => {
					let g
					f.command && (u || (u = new Q()), (g = this._commands.toInternal(f.command, u)))
					let I
					f.action && (u || (u = new Q()), (I = this._commands.toInternal(f.action, u)))
					let C = f.insertText
					return {
						insertText: typeof C == "string" ? C : { snippet: C.value },
						filterText: f.filterText,
						range: f.range ? H.from(f.range) : void 0,
						showRange: this._isAdditionsProposedApiEnabled && f.showRange ? H.from(f.showRange) : void 0,
						command: g,
						action: I,
						idx: h,
						completeBracketPairs: this._isAdditionsProposedApiEnabled ? f.completeBracketPairs : !1,
						isInlineEdit: this._isAdditionsProposedApiEnabled ? f.isInlineEdit : !1,
						showInlineEditMenu: this._isAdditionsProposedApiEnabled ? f.showInlineEditMenu : !1,
						warning:
							f.warning && this._isAdditionsProposedApiEnabled
								? {
										message: Ce.from(f.warning.message),
										icon: f.warning.icon ? ok.fromThemeIcon(f.warning.icon) : void 0,
									}
								: void 0,
					}
				}),
				commands: d.map((f) => (u || (u = new Q()), this._commands.toInternal(f, u))),
				suppressSuggestions: !1,
				enableForwardStability: c,
			}
		}
		async provideInlineEditsForRange(e, t, n, r) {
			if (!this._provider.provideInlineEditsForRange) return
			M(this._extension, "inlineCompletionsAdditions")
			let i = this._documents.getDocument(e),
				s = H.to(t),
				a = await this._provider.provideInlineEditsForRange(
					i,
					s,
					{
						selectedCompletionInfo: n.selectedSuggestionInfo
							? { range: H.to(n.selectedSuggestionInfo.range), text: n.selectedSuggestionInfo.text }
							: void 0,
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[n.triggerKind],
						userPrompt: n.userPrompt,
						requestUuid: n.requestUuid,
					},
					r,
				)
			if (!a || r.isCancellationRequested) return
			let l = Array.isArray(a) ? a : a.items,
				d = this._isAdditionsProposedApiEnabled ? (Array.isArray(a) ? [] : a.commands || []) : [],
				c = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0,
				u
			return {
				pid: this._references.createReferenceId({
					dispose() {
						u?.dispose()
					},
					items: l,
				}),
				items: l.map((f, h) => {
					let g
					f.command && (u || (u = new Q()), (g = this._commands.toInternal(f.command, u)))
					let I
					f.action && (u || (u = new Q()), (I = this._commands.toInternal(f.action, u)))
					let C = f.insertText
					return {
						insertText: typeof C == "string" ? C : { snippet: C.value },
						filterText: f.filterText,
						range: f.range ? H.from(f.range) : void 0,
						command: g,
						action: I,
						idx: h,
						completeBracketPairs: this._isAdditionsProposedApiEnabled ? f.completeBracketPairs : !1,
					}
				}),
				commands: d.map((f) => (u || (u = new Q()), this._commands.toInternal(f, u))),
				suppressSuggestions: !1,
				enableForwardStability: c,
			}
		}
		disposeCompletions(e) {
			this._references.disposeReferenceId(e)?.dispose()
		}
		handleDidShowCompletionItem(e, t, n) {
			let r = this._references.get(e)?.items[t]
			r &&
				this._provider.handleDidShowCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				this._provider.handleDidShowCompletionItem(r, n)
		}
		handlePartialAccept(e, t, n, r) {
			let i = this._references.get(e)?.items[t]
			i &&
				this._provider.handleDidPartiallyAcceptCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				(this._provider.handleDidPartiallyAcceptCompletionItem(i, n),
				this._provider.handleDidPartiallyAcceptCompletionItem(i, tk.to(r)))
		}
		handleRejection(e, t) {
			let n = this._references.get(e)?.items[t]
			n &&
				this._provider.handleDidRejectCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				this._provider.handleDidRejectCompletionItem(n)
		}
	},
	Ih = class {
		constructor(e, t, n, r) {
			this._documents = t
			this._provider = n
			this._commands = r
			this._references = new yS()
			this.languageTriggerKindToVSCodeTriggerKind = { 1: 1, 0: 0 }
		}
		async provideInlineEdits(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideInlineEdit(
					r,
					{
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[t.triggerKind],
						requestUuid: t.requestUuid,
					},
					n,
				)
			if (!i || n.isCancellationRequested) return
			let s,
				a = this._references.createReferenceId({
					dispose() {
						s?.dispose()
					},
					item: i,
				}),
				l
			i.accepted && (s || (s = new Q()), (l = this._commands.toInternal(i.accepted, s)))
			let d
			i.rejected && (s || (s = new Q()), (d = this._commands.toInternal(i.rejected, s)))
			let c
			i.shown && (s || (s = new Q()), (c = this._commands.toInternal(i.shown, s)))
			let u
			return (
				i.action && (s || (s = new Q()), (u = this._commands.toInternal(i.action, s))),
				s || (s = new Q()),
				{
					pid: a,
					text: i.text,
					range: H.from(i.range),
					showRange: H.from(i.showRange),
					accepted: l,
					rejected: d,
					shown: c,
					action: u,
					commands: i.commands?.map((f) => this._commands.toInternal(f, s)),
				}
			)
		}
		disposeEdit(e) {
			this._references.disposeReferenceId(e)?.dispose()
		}
	},
	yS = class {
		constructor() {
			this._references = new Map()
			this._idPool = 1
		}
		createReferenceId(e) {
			let t = this._idPool++
			return this._references.set(t, e), t
		}
		disposeReferenceId(e) {
			let t = this._references.get(e)
			return this._references.delete(e), t
		}
		get(e) {
			return this._references.get(e)
		}
	},
	xh = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._cache = new pr("SignatureHelp")
		}
		async provideSignatureHelp(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = this.reviveContext(n),
				l = await this._provider.provideSignatureHelp(i, s, r, a)
			if (l) {
				let d = this._cache.add([l])
				return { ...Xu.from(l), id: d }
			}
		}
		reviveContext(e) {
			let t
			if (e.activeSignatureHelp) {
				let n = Xu.to(e.activeSignatureHelp),
					r = this._cache.get(e.activeSignatureHelp.id, 0)
				r
					? ((t = r), (t.activeSignature = n.activeSignature), (t.activeParameter = n.activeParameter))
					: (t = n)
			}
			return { ...e, activeSignatureHelp: t }
		}
		releaseSignatureHelp(e) {
			this._cache.delete(e)
		}
	},
	vm = class {
		constructor(e, t, n, r, i) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._logService = r
			this._extension = i
			this._cache = new pr("InlayHints")
			this._disposables = new Map()
		}
		async provideInlayHints(e, t, n) {
			let r = this._documents.getDocument(e),
				i = H.to(t),
				s = await this._provider.provideInlayHints(r, i, n)
			if (!Array.isArray(s) || s.length === 0) {
				this._logService.trace(
					`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`,
				)
				return
			}
			if (n.isCancellationRequested) return
			let a = this._cache.add(s)
			this._disposables.set(a, new Q())
			let l = { hints: [], cacheId: a }
			for (let d = 0; d < s.length; d++)
				this._isValidInlayHint(s[d], i) && l.hints.push(this._convertInlayHint(s[d], [a, d]))
			return (
				this._logService.trace(
					`[InlayHints] ${l.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`,
				),
				l
			)
		}
		async resolveInlayHint(e, t) {
			if (typeof this._provider.resolveInlayHint != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = await this._provider.resolveInlayHint(n, t)
			if (r && this._isValidInlayHint(r)) return this._convertInlayHint(r, e)
		}
		releaseHints(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		_isValidInlayHint(e, t) {
			return e.label.length === 0 || (Array.isArray(e.label) && e.label.every((n) => n.value.length === 0))
				? (console.log("INVALID inlay hint, empty label", e), !1)
				: !(t && !t.contains(e.position))
		}
		_convertInlayHint(e, t) {
			let n = this._disposables.get(t[0])
			if (!n) throw Error("DisposableStore is missing...")
			let r = {
				label: "",
				cacheId: t,
				tooltip: Ce.fromStrict(e.tooltip),
				position: Je.from(e.position),
				textEdits: e.textEdits && e.textEdits.map(on.from),
				kind: e.kind && ix.from(e.kind),
				paddingLeft: e.paddingLeft,
				paddingRight: e.paddingRight,
			}
			if (typeof e.label == "string") r.label = e.label
			else {
				let i = []
				r.label = i
				for (let s of e.label) {
					if (!s.value) {
						console.warn("INVALID inlay hint, empty label part", this._extension.identifier.value)
						continue
					}
					let a = { label: s.value, tooltip: Ce.fromStrict(s.tooltip) }
					rn.isLocation(s.location) && (a.location = Bn.from(s.location)),
						s.command && (a.command = this._commands.toInternal(s.command, n)),
						i.push(a)
				}
			}
			return r
		}
	},
	bm = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._cache = new pr("DocumentLink")
		}
		async provideLinks(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentLinks(n, t)
			if (!(!Array.isArray(r) || r.length === 0) && !t.isCancellationRequested) {
				if (typeof this._provider.resolveDocumentLink != "function")
					return { links: r.filter(o._validateLink).map(Us.from) }
				{
					let i = this._cache.add(r),
						s = { links: [], cacheId: i }
					for (let a = 0; a < r.length; a++) {
						if (!o._validateLink(r[a])) continue
						let l = Us.from(r[a])
						;(l.cacheId = [i, a]), s.links.push(l)
					}
					return s
				}
			}
		}
		static _validateLink(e) {
			return e.target && e.target.path.length > 5e4
				? (console.warn("DROPPING link because it is too long"), !1)
				: !0
		}
		async resolveLink(e, t) {
			if (typeof this._provider.resolveDocumentLink != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = await this._provider.resolveDocumentLink(n, t)
			if (!(!r || !o._validateLink(r))) return Us.from(r)
		}
		releaseLinks(e) {
			this._cache.delete(e)
		}
	},
	Ch = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideColors(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentColors(n, t)
			return Array.isArray(r) ? r.map((s) => ({ color: Dd.from(s.color), range: H.from(s.range) })) : []
		}
		async provideColorPresentations(e, t, n) {
			let r = this._documents.getDocument(e),
				i = H.to(t.range),
				s = Dd.to(t.color),
				a = await this._provider.provideColorPresentations(s, { document: r, range: i }, n)
			if (Array.isArray(a)) return a.map(Ig.from)
		}
	},
	IS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideFoldingRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideFoldingRanges(r, t, n)
			if (Array.isArray(i)) return i.map(Cg.from)
		}
	},
	xS = class {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		async provideSelectionRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = t.map(Je.to),
				s = await this._provider.provideSelectionRanges(r, i, n)
			if (!ri(s)) return []
			if (s.length !== i.length)
				return this._logService.warn("BAD selection ranges, provider must return ranges for each position"), []
			let a = []
			for (let l = 0; l < i.length; l++) {
				let d = []
				a.push(d)
				let c = i[l],
					u = s[l]
				for (;;) {
					if (!u.range.contains(c))
						throw new Error("INVALID selection range, must contain the previous range")
					if ((d.push(WD.from(u)), !u.parent)) break
					;(c = u.range), (u = u.parent)
				}
			}
			return a
		}
	},
	Kd = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._idPool = new dl("")
			this._cache = new Map()
		}
		async prepareSession(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.prepareCallHierarchy(r, i, n)
			if (!s) return
			let a = this._idPool.nextId()
			return (
				this._cache.set(a, new Map()),
				Array.isArray(s) ? s.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, s)]
			)
		}
		async provideCallsTo(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing call hierarchy item")
			let i = await this._provider.provideCallHierarchyIncomingCalls(r, n)
			if (i)
				return i.map((s) => ({
					from: this._cacheAndConvertItem(e, s.from),
					fromRanges: s.fromRanges.map((a) => H.from(a)),
				}))
		}
		async provideCallsFrom(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing call hierarchy item")
			let i = await this._provider.provideCallHierarchyOutgoingCalls(r, n)
			if (i)
				return i.map((s) => ({
					to: this._cacheAndConvertItem(e, s.to),
					fromRanges: s.fromRanges.map((a) => H.from(a)),
				}))
		}
		releaseSession(e) {
			this._cache.delete(e)
		}
		_cacheAndConvertItem(e, t) {
			let n = this._cache.get(e),
				r = Ns.from(t, e, n.size.toString(36))
			return n.set(r._itemId, t), r
		}
		_itemFromCache(e, t) {
			return this._cache.get(e)?.get(t)
		}
	},
	jd = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._idPool = new dl("")
			this._cache = new Map()
		}
		async prepareSession(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.prepareTypeHierarchy(r, i, n)
			if (!s) return
			let a = this._idPool.nextId()
			return (
				this._cache.set(a, new Map()),
				Array.isArray(s) ? s.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, s)]
			)
		}
		async provideSupertypes(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing type hierarchy item")
			let i = await this._provider.provideTypeHierarchySupertypes(r, n)
			if (i) return i.map((s) => this._cacheAndConvertItem(e, s))
		}
		async provideSubtypes(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing type hierarchy item")
			let i = await this._provider.provideTypeHierarchySubtypes(r, n)
			if (i) return i.map((s) => this._cacheAndConvertItem(e, s))
		}
		releaseSession(e) {
			this._cache.delete(e)
		}
		_cacheAndConvertItem(e, t) {
			let n = this._cache.get(e),
				r = Hs.from(t, e, n.size.toString(36))
			return n.set(r._itemId, t), r
		}
		_itemFromCache(e, t) {
			return this._cache.get(e)?.get(t)
		}
	},
	ym = class {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._documents = t
			this._provider = n
			this._handle = r
			this._extension = i
			this._cache = new pr("DocumentDropEdit")
		}
		async provideDocumentOnDropEdits(e, t, n, r, i) {
			let s = this._documents.getDocument(t),
				a = Je.to(n),
				l = Rd.toDataTransfer(
					r,
					async (m) => (await this._proxy.$resolveDocumentOnDropFileData(this._handle, e, m)).buffer,
				),
				d = await this._provider.provideDocumentDropEdits(s, a, l, i)
			if (!d) return
			let c = an(d),
				u = this._cache.add(c)
			return c.map((m, f) => ({
				_cacheId: [u, f],
				title:
					m.title ??
					p(
						"defaultDropLabel",
						"Drop using '{0}' extension",
						this._extension.displayName || this._extension.name,
					),
				kind: m.kind?.value,
				yieldTo: m.yieldTo?.map((h) => h.value),
				insertText: typeof m.insertText == "string" ? m.insertText : { snippet: m.insertText.value },
				additionalEdit: m.additionalEdit ? $n.from(m.additionalEdit, void 0) : void 0,
			}))
		}
		async resolveDropEdit(e, t) {
			let [n, r] = e,
				i = this._cache.get(n, r)
			if (!i || !this._provider.resolveDocumentDropEdit) return {}
			let s = (await this._provider.resolveDocumentDropEdit(i, t)) ?? i
			return { additionalEdit: s.additionalEdit ? $n.from(s.additionalEdit, void 0) : void 0 }
		}
		releaseDropEdits(e) {
			this._cache.delete(e)
		}
	},
	Gd = class {
		constructor(e, t) {
			this.adapter = e
			this.extension = t
		}
	},
	CS = class o {
		constructor(e, t, n, r, i, s, a, l) {
			this._uriTransformer = t
			this._documents = n
			this._commands = r
			this._diagnostics = i
			this._logService = s
			this._apiDeprecation = a
			this._extensionTelemetry = l
			this._adapter = new Map()
			this._proxy = e.getProxy(N.MainThreadLanguageFeatures)
		}
		static {
			this._handlePool = 0
		}
		_transformDocumentSelector(e, t) {
			return Fs.from(e, this._uriTransformer, t)
		}
		_createDisposable(e) {
			return new ye(() => {
				this._adapter.delete(e), this._proxy.$unregister(e)
			})
		}
		_nextHandle() {
			return o._handlePool++
		}
		async _withAdapter(e, t, n, r, i, s = !1) {
			let a = this._adapter.get(e)
			if (!a || !(a.adapter instanceof t)) return r
			let l = Date.now()
			s ||
				this._logService.trace(
					`[${a.extension.identifier.value}] INVOKE provider '${n.toString().replace(/[\r\n]/g, "")}'`,
				)
			let d = n(a.adapter, a.extension)
			return (
				Promise.resolve(d)
					.catch((c) => {
						bn(c) ||
							(this._logService.error(`[${a.extension.identifier.value}] provider FAILED`),
							this._logService.error(c),
							this._extensionTelemetry.onExtensionError(a.extension.identifier, c))
					})
					.finally(() => {
						s ||
							this._logService.trace(
								`[${a.extension.identifier.value}] provider DONE after ${Date.now() - l}ms`,
							)
					}),
				De.isCancellationToken(i) ? BA(d, i) : d
			)
		}
		_addNewAdapter(e, t) {
			let n = this._nextHandle()
			return this._adapter.set(n, new Gd(e, t)), n
		}
		static _extLabel(e) {
			return e.displayName || e.name
		}
		static _extId(e) {
			return e.identifier.value
		}
		registerDocumentSymbolProvider(e, t, n, r) {
			let i = this._addNewAdapter(new iS(this._documents, n), e),
				s = (r && r.label) || o._extLabel(e)
			return (
				this._proxy.$registerDocumentSymbolProvider(i, this._transformDocumentSelector(t, e), s),
				this._createDisposable(i)
			)
		}
		$provideDocumentSymbols(e, t, n) {
			return this._withAdapter(e, iS, (r) => r.provideDocumentSymbols(y.revive(t), n), void 0, n)
		}
		registerCodeLensProvider(e, t, n) {
			let r = this._nextHandle(),
				i = typeof n.onDidChangeCodeLenses == "function" ? this._nextHandle() : void 0
			this._adapter.set(
				r,
				new Gd(
					new mm(this._documents, this._commands.converter, n, e, this._extensionTelemetry, this._logService),
					e,
				),
			),
				this._proxy.$registerCodeLensSupport(r, this._transformDocumentSelector(t, e), i)
			let s = this._createDisposable(r)
			if (i !== void 0) {
				let a = n.onDidChangeCodeLenses((l) => this._proxy.$emitCodeLensEvent(i))
				s = ye.from(s, a)
			}
			return s
		}
		$provideCodeLenses(e, t, n) {
			return this._withAdapter(
				e,
				mm,
				(r) => r.provideCodeLenses(y.revive(t), n),
				void 0,
				n,
				t.scheme === "output",
			)
		}
		$resolveCodeLens(e, t, n) {
			return this._withAdapter(e, mm, (r) => r.resolveCodeLens(t, n), void 0, void 0, !0)
		}
		$releaseCodeLenses(e, t) {
			this._withAdapter(e, mm, (n) => Promise.resolve(n.releaseCodeLenses(t)), void 0, void 0, !0)
		}
		registerDefinitionProvider(e, t, n) {
			let r = this._addNewAdapter(new sS(this._documents, n), e)
			return (
				this._proxy.$registerDefinitionSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDefinition(e, t, n, r) {
			return this._withAdapter(e, sS, (i) => i.provideDefinition(y.revive(t), n, r), [], r)
		}
		registerDeclarationProvider(e, t, n) {
			let r = this._addNewAdapter(new aS(this._documents, n), e)
			return (
				this._proxy.$registerDeclarationSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDeclaration(e, t, n, r) {
			return this._withAdapter(e, aS, (i) => i.provideDeclaration(y.revive(t), n, r), [], r)
		}
		registerImplementationProvider(e, t, n) {
			let r = this._addNewAdapter(new lS(this._documents, n), e)
			return (
				this._proxy.$registerImplementationSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideImplementation(e, t, n, r) {
			return this._withAdapter(e, lS, (i) => i.provideImplementation(y.revive(t), n, r), [], r)
		}
		registerTypeDefinitionProvider(e, t, n) {
			let r = this._addNewAdapter(new dS(this._documents, n), e)
			return (
				this._proxy.$registerTypeDefinitionSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideTypeDefinition(e, t, n, r) {
			return this._withAdapter(e, dS, (i) => i.provideTypeDefinition(y.revive(t), n, r), [], r)
		}
		registerHoverProvider(e, t, n, r) {
			let i = this._addNewAdapter(new gh(this._documents, n), e)
			return (
				this._proxy.$registerHoverProvider(i, this._transformDocumentSelector(t, e)), this._createDisposable(i)
			)
		}
		$provideHover(e, t, n, r, i) {
			return this._withAdapter(e, gh, (s) => s.provideHover(y.revive(t), n, r, i), void 0, i)
		}
		$releaseHover(e, t) {
			this._withAdapter(e, gh, (n) => Promise.resolve(n.releaseHover(t)), void 0, void 0)
		}
		registerEvaluatableExpressionProvider(e, t, n, r) {
			let i = this._addNewAdapter(new cS(this._documents, n), e)
			return (
				this._proxy.$registerEvaluatableExpressionProvider(i, this._transformDocumentSelector(t, e)),
				this._createDisposable(i)
			)
		}
		$provideEvaluatableExpression(e, t, n, r) {
			return this._withAdapter(e, cS, (i) => i.provideEvaluatableExpression(y.revive(t), n, r), void 0, r)
		}
		registerInlineValuesProvider(e, t, n, r) {
			let i = typeof n.onDidChangeInlineValues == "function" ? this._nextHandle() : void 0,
				s = this._addNewAdapter(new uS(this._documents, n), e)
			this._proxy.$registerInlineValuesProvider(s, this._transformDocumentSelector(t, e), i)
			let a = this._createDisposable(s)
			if (i !== void 0) {
				let l = n.onDidChangeInlineValues((d) => this._proxy.$emitInlineValuesEvent(i))
				a = ye.from(a, l)
			}
			return a
		}
		$provideInlineValues(e, t, n, r, i) {
			return this._withAdapter(e, uS, (s) => s.provideInlineValues(y.revive(t), n, r, i), void 0, i)
		}
		registerDocumentHighlightProvider(e, t, n) {
			let r = this._addNewAdapter(new pS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentHighlightProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		registerMultiDocumentHighlightProvider(e, t, n) {
			let r = this._addNewAdapter(new mS(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerMultiDocumentHighlightProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDocumentHighlights(e, t, n, r) {
			return this._withAdapter(e, pS, (i) => i.provideDocumentHighlights(y.revive(t), n, r), void 0, r)
		}
		$provideMultiDocumentHighlights(e, t, n, r, i) {
			return this._withAdapter(
				e,
				mS,
				(s) =>
					s.provideMultiDocumentHighlights(
						y.revive(t),
						n,
						r.map((a) => y.revive(a)),
						i,
					),
				void 0,
				i,
			)
		}
		registerLinkedEditingRangeProvider(e, t, n) {
			let r = this._addNewAdapter(new fS(this._documents, n), e)
			return (
				this._proxy.$registerLinkedEditingRangeProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideLinkedEditingRanges(e, t, n, r) {
			return this._withAdapter(
				e,
				fS,
				async (i) => {
					let s = await i.provideLinkedEditingRanges(y.revive(t), n, r)
					if (s)
						return {
							ranges: s.ranges,
							wordPattern: s.wordPattern ? o._serializeRegExp(s.wordPattern) : void 0,
						}
				},
				void 0,
				r,
			)
		}
		registerReferenceProvider(e, t, n) {
			let r = this._addNewAdapter(new gS(this._documents, n), e)
			return (
				this._proxy.$registerReferenceSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideReferences(e, t, n, r, i) {
			return this._withAdapter(e, gS, (s) => s.provideReferences(y.revive(t), n, r, i), void 0, i)
		}
		registerCodeActionProvider(e, t, n, r) {
			let i = new Q(),
				s = this._addNewAdapter(
					new fm(
						this._documents,
						this._commands.converter,
						this._diagnostics,
						n,
						this._logService,
						e,
						this._apiDeprecation,
					),
					e,
				)
			return (
				this._proxy.$registerCodeActionSupport(
					s,
					this._transformDocumentSelector(t, e),
					{
						providedKinds: r?.providedCodeActionKinds?.map((a) => a.value),
						documentation: r?.documentation?.map((a) => ({
							kind: a.kind.value,
							command: this._commands.converter.toInternal(a.command, i),
						})),
					},
					o._extLabel(e),
					o._extId(e),
					!!n.resolveCodeAction,
				),
				i.add(this._createDisposable(s)),
				i
			)
		}
		$provideCodeActions(e, t, n, r, i) {
			return this._withAdapter(e, fm, (s) => s.provideCodeActions(y.revive(t), n, r, i), void 0, i)
		}
		$resolveCodeAction(e, t, n) {
			return this._withAdapter(e, fm, (r) => r.resolveCodeAction(t, n), {}, void 0)
		}
		$releaseCodeActions(e, t) {
			this._withAdapter(e, fm, (n) => Promise.resolve(n.releaseCodeActions(t)), void 0, void 0)
		}
		registerDocumentFormattingEditProvider(e, t, n) {
			let r = this._addNewAdapter(new hS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentFormattingSupport(
					r,
					this._transformDocumentSelector(t, e),
					e.identifier,
					e.displayName || e.name,
				),
				this._createDisposable(r)
			)
		}
		$provideDocumentFormattingEdits(e, t, n, r) {
			return this._withAdapter(e, hS, (i) => i.provideDocumentFormattingEdits(y.revive(t), n, r), void 0, r)
		}
		registerDocumentRangeFormattingEditProvider(e, t, n) {
			let r = typeof n.provideDocumentRangesFormattingEdits == "function",
				i = this._addNewAdapter(new hh(this._documents, n), e)
			return (
				this._proxy.$registerRangeFormattingSupport(
					i,
					this._transformDocumentSelector(t, e),
					e.identifier,
					e.displayName || e.name,
					r,
				),
				this._createDisposable(i)
			)
		}
		$provideDocumentRangeFormattingEdits(e, t, n, r, i) {
			return this._withAdapter(
				e,
				hh,
				(s) => s.provideDocumentRangeFormattingEdits(y.revive(t), n, r, i),
				void 0,
				i,
			)
		}
		$provideDocumentRangesFormattingEdits(e, t, n, r, i) {
			return this._withAdapter(
				e,
				hh,
				(s) => s.provideDocumentRangesFormattingEdits(y.revive(t), n, r, i),
				void 0,
				i,
			)
		}
		registerOnTypeFormattingEditProvider(e, t, n, r) {
			let i = this._addNewAdapter(new vS(this._documents, n), e)
			return (
				this._proxy.$registerOnTypeFormattingSupport(i, this._transformDocumentSelector(t, e), r, e.identifier),
				this._createDisposable(i)
			)
		}
		$provideOnTypeFormattingEdits(e, t, n, r, i, s) {
			return this._withAdapter(e, vS, (a) => a.provideOnTypeFormattingEdits(y.revive(t), n, r, i, s), void 0, s)
		}
		registerWorkspaceSymbolProvider(e, t) {
			let n = this._addNewAdapter(new gm(t, this._logService), e)
			return (
				this._proxy.$registerNavigateTypeSupport(n, typeof t.resolveWorkspaceSymbol == "function"),
				this._createDisposable(n)
			)
		}
		$provideWorkspaceSymbols(e, t, n) {
			return this._withAdapter(e, gm, (r) => r.provideWorkspaceSymbols(t, n), { symbols: [] }, n)
		}
		$resolveWorkspaceSymbol(e, t, n) {
			return this._withAdapter(e, gm, (r) => r.resolveWorkspaceSymbol(t, n), void 0, void 0)
		}
		$releaseWorkspaceSymbols(e, t) {
			this._withAdapter(e, gm, (n) => n.releaseWorkspaceSymbols(t), void 0, void 0)
		}
		registerRenameProvider(e, t, n) {
			let r = this._addNewAdapter(new hm(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerRenameSupport(r, this._transformDocumentSelector(t, e), hm.supportsResolving(n)),
				this._createDisposable(r)
			)
		}
		$provideRenameEdits(e, t, n, r, i) {
			return this._withAdapter(e, hm, (s) => s.provideRenameEdits(y.revive(t), n, r, i), void 0, i)
		}
		$resolveRenameLocation(e, t, n, r) {
			return this._withAdapter(e, hm, (i) => i.resolveRenameLocation(y.revive(t), n, r), void 0, r)
		}
		registerNewSymbolNamesProvider(e, t, n) {
			let r = this._addNewAdapter(new vh(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerNewSymbolNamesProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$supportsAutomaticNewSymbolNamesTriggerKind(e) {
			return this._withAdapter(e, vh, (t) => t.supportsAutomaticNewSymbolNamesTriggerKind(), !1, void 0)
		}
		$provideNewSymbolNames(e, t, n, r, i) {
			return this._withAdapter(e, vh, (s) => s.provideNewSymbolNames(y.revive(t), n, r, i), void 0, i)
		}
		registerDocumentSemanticTokensProvider(e, t, n, r) {
			let i = this._addNewAdapter(new yh(this._documents, n), e),
				s = typeof n.onDidChangeSemanticTokens == "function" ? this._nextHandle() : void 0
			this._proxy.$registerDocumentSemanticTokensProvider(i, this._transformDocumentSelector(t, e), r, s)
			let a = this._createDisposable(i)
			if (s) {
				let l = n.onDidChangeSemanticTokens((d) => this._proxy.$emitDocumentSemanticTokensEvent(s))
				a = ye.from(a, l)
			}
			return a
		}
		$provideDocumentSemanticTokens(e, t, n, r) {
			return this._withAdapter(e, yh, (i) => i.provideDocumentSemanticTokens(y.revive(t), n, r), null, r)
		}
		$releaseDocumentSemanticTokens(e, t) {
			this._withAdapter(e, yh, (n) => n.releaseDocumentSemanticColoring(t), void 0, void 0)
		}
		registerDocumentRangeSemanticTokensProvider(e, t, n, r) {
			let i = this._addNewAdapter(new bS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentRangeSemanticTokensProvider(i, this._transformDocumentSelector(t, e), r),
				this._createDisposable(i)
			)
		}
		$provideDocumentRangeSemanticTokens(e, t, n, r) {
			return this._withAdapter(e, bS, (i) => i.provideDocumentRangeSemanticTokens(y.revive(t), n, r), null, r)
		}
		registerCompletionItemProvider(e, t, n, r) {
			let i = this._addNewAdapter(
				new qd(this._documents, this._commands.converter, n, this._apiDeprecation, e),
				e,
			)
			return (
				this._proxy.$registerCompletionsProvider(
					i,
					this._transformDocumentSelector(t, e),
					r,
					qd.supportsResolving(n),
					e.identifier,
				),
				this._createDisposable(i)
			)
		}
		$provideCompletionItems(e, t, n, r, i) {
			return this._withAdapter(e, qd, (s) => s.provideCompletionItems(y.revive(t), n, r, i), void 0, i)
		}
		$resolveCompletionItem(e, t, n) {
			return this._withAdapter(e, qd, (r) => r.resolveCompletionItem(t, n), void 0, n)
		}
		$releaseCompletionItems(e, t) {
			this._withAdapter(e, qd, (n) => n.releaseCompletionItems(t), void 0, void 0)
		}
		registerInlineCompletionsProvider(e, t, n, r) {
			let i = new Ks(e, this._documents, n, this._commands.converter),
				s = this._addNewAdapter(i, e)
			return (
				this._proxy.$registerInlineCompletionsSupport(
					s,
					this._transformDocumentSelector(t, e),
					i.supportsHandleEvents,
					we.toKey(e.identifier.value),
					r?.yieldTo?.map((a) => we.toKey(a)) || [],
					r?.displayName,
					r?.debounceDelayMs,
				),
				this._createDisposable(s)
			)
		}
		$provideInlineCompletions(e, t, n, r, i) {
			return this._withAdapter(e, Ks, (s) => s.provideInlineCompletions(y.revive(t), n, r, i), void 0, i)
		}
		$provideInlineEditsForRange(e, t, n, r, i) {
			return this._withAdapter(e, Ks, (s) => s.provideInlineEditsForRange(y.revive(t), n, r, i), void 0, i)
		}
		$handleInlineCompletionDidShow(e, t, n, r) {
			this._withAdapter(
				e,
				Ks,
				async (i) => {
					i.handleDidShowCompletionItem(t, n, r)
				},
				void 0,
				void 0,
			)
		}
		$handleInlineCompletionPartialAccept(e, t, n, r, i) {
			this._withAdapter(
				e,
				Ks,
				async (s) => {
					s.handlePartialAccept(t, n, r, i)
				},
				void 0,
				void 0,
			)
		}
		$handleInlineCompletionRejection(e, t, n) {
			this._withAdapter(
				e,
				Ks,
				async (r) => {
					r.handleRejection(t, n)
				},
				void 0,
				void 0,
			)
		}
		$freeInlineCompletionsList(e, t) {
			this._withAdapter(
				e,
				Ks,
				async (n) => {
					n.disposeCompletions(t)
				},
				void 0,
				void 0,
			)
		}
		registerInlineEditProvider(e, t, n) {
			let r = new Ih(e, this._documents, n, this._commands.converter),
				i = this._addNewAdapter(r, e)
			return (
				this._proxy.$registerInlineEditProvider(
					i,
					this._transformDocumentSelector(t, e),
					e.identifier,
					n.displayName || e.name,
				),
				this._createDisposable(i)
			)
		}
		$provideInlineEdit(e, t, n, r) {
			return this._withAdapter(e, Ih, (i) => i.provideInlineEdits(y.revive(t), n, r), void 0, r)
		}
		$freeInlineEdit(e, t) {
			this._withAdapter(
				e,
				Ih,
				async (n) => {
					n.disposeEdit(t)
				},
				void 0,
				void 0,
			)
		}
		registerSignatureHelpProvider(e, t, n, r) {
			let i = Array.isArray(r) ? { triggerCharacters: r, retriggerCharacters: [] } : r,
				s = this._addNewAdapter(new xh(this._documents, n), e)
			return (
				this._proxy.$registerSignatureHelpProvider(s, this._transformDocumentSelector(t, e), i),
				this._createDisposable(s)
			)
		}
		$provideSignatureHelp(e, t, n, r, i) {
			return this._withAdapter(e, xh, (s) => s.provideSignatureHelp(y.revive(t), n, r, i), void 0, i)
		}
		$releaseSignatureHelp(e, t) {
			this._withAdapter(e, xh, (n) => n.releaseSignatureHelp(t), void 0, void 0)
		}
		registerInlayHintsProvider(e, t, n) {
			let r = typeof n.onDidChangeInlayHints == "function" ? this._nextHandle() : void 0,
				i = this._addNewAdapter(new vm(this._documents, this._commands.converter, n, this._logService, e), e)
			this._proxy.$registerInlayHintsProvider(
				i,
				this._transformDocumentSelector(t, e),
				typeof n.resolveInlayHint == "function",
				r,
				o._extLabel(e),
			)
			let s = this._createDisposable(i)
			if (r !== void 0) {
				let a = n.onDidChangeInlayHints((l) => this._proxy.$emitInlayHintsEvent(r))
				s = ye.from(s, a)
			}
			return s
		}
		$provideInlayHints(e, t, n, r) {
			return this._withAdapter(e, vm, (i) => i.provideInlayHints(y.revive(t), n, r), void 0, r)
		}
		$resolveInlayHint(e, t, n) {
			return this._withAdapter(e, vm, (r) => r.resolveInlayHint(t, n), void 0, n)
		}
		$releaseInlayHints(e, t) {
			this._withAdapter(e, vm, (n) => n.releaseHints(t), void 0, void 0)
		}
		registerDocumentLinkProvider(e, t, n) {
			let r = this._addNewAdapter(new bm(this._documents, n), e)
			return (
				this._proxy.$registerDocumentLinkProvider(
					r,
					this._transformDocumentSelector(t, e),
					typeof n.resolveDocumentLink == "function",
				),
				this._createDisposable(r)
			)
		}
		$provideDocumentLinks(e, t, n) {
			return this._withAdapter(e, bm, (r) => r.provideLinks(y.revive(t), n), void 0, n, t.scheme === "output")
		}
		$resolveDocumentLink(e, t, n) {
			return this._withAdapter(e, bm, (r) => r.resolveLink(t, n), void 0, void 0, !0)
		}
		$releaseDocumentLinks(e, t) {
			this._withAdapter(e, bm, (n) => n.releaseLinks(t), void 0, void 0, !0)
		}
		registerColorProvider(e, t, n) {
			let r = this._addNewAdapter(new Ch(this._documents, n), e)
			return (
				this._proxy.$registerDocumentColorProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDocumentColors(e, t, n) {
			return this._withAdapter(e, Ch, (r) => r.provideColors(y.revive(t), n), [], n)
		}
		$provideColorPresentations(e, t, n, r) {
			return this._withAdapter(e, Ch, (i) => i.provideColorPresentations(y.revive(t), n, r), void 0, r)
		}
		registerFoldingRangeProvider(e, t, n) {
			let r = this._nextHandle(),
				i = typeof n.onDidChangeFoldingRanges == "function" ? this._nextHandle() : void 0
			this._adapter.set(r, new Gd(new IS(this._documents, n), e)),
				this._proxy.$registerFoldingRangeProvider(r, this._transformDocumentSelector(t, e), e.identifier, i)
			let s = this._createDisposable(r)
			if (i !== void 0) {
				let a = n.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(i))
				s = ye.from(s, a)
			}
			return s
		}
		$provideFoldingRanges(e, t, n, r) {
			return this._withAdapter(e, IS, (i) => i.provideFoldingRanges(y.revive(t), n, r), void 0, r)
		}
		registerSelectionRangeProvider(e, t, n) {
			let r = this._addNewAdapter(new xS(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerSelectionRangeProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideSelectionRanges(e, t, n, r) {
			return this._withAdapter(e, xS, (i) => i.provideSelectionRanges(y.revive(t), n, r), [], r)
		}
		registerCallHierarchyProvider(e, t, n) {
			let r = this._addNewAdapter(new Kd(this._documents, n), e)
			return (
				this._proxy.$registerCallHierarchyProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$prepareCallHierarchy(e, t, n, r) {
			return this._withAdapter(e, Kd, (i) => Promise.resolve(i.prepareSession(y.revive(t), n, r)), void 0, r)
		}
		$provideCallHierarchyIncomingCalls(e, t, n, r) {
			return this._withAdapter(e, Kd, (i) => i.provideCallsTo(t, n, r), void 0, r)
		}
		$provideCallHierarchyOutgoingCalls(e, t, n, r) {
			return this._withAdapter(e, Kd, (i) => i.provideCallsFrom(t, n, r), void 0, r)
		}
		$releaseCallHierarchy(e, t) {
			this._withAdapter(e, Kd, (n) => Promise.resolve(n.releaseSession(t)), void 0, void 0)
		}
		registerTypeHierarchyProvider(e, t, n) {
			let r = this._addNewAdapter(new jd(this._documents, n), e)
			return (
				this._proxy.$registerTypeHierarchyProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$prepareTypeHierarchy(e, t, n, r) {
			return this._withAdapter(e, jd, (i) => Promise.resolve(i.prepareSession(y.revive(t), n, r)), void 0, r)
		}
		$provideTypeHierarchySupertypes(e, t, n, r) {
			return this._withAdapter(e, jd, (i) => i.provideSupertypes(t, n, r), void 0, r)
		}
		$provideTypeHierarchySubtypes(e, t, n, r) {
			return this._withAdapter(e, jd, (i) => i.provideSubtypes(t, n, r), void 0, r)
		}
		$releaseTypeHierarchy(e, t) {
			this._withAdapter(e, jd, (n) => Promise.resolve(n.releaseSession(t)), void 0, void 0)
		}
		registerDocumentOnDropEditProvider(e, t, n, r) {
			let i = this._nextHandle()
			return (
				this._adapter.set(i, new Gd(new ym(this._proxy, this._documents, n, i, e), e)),
				this._proxy.$registerDocumentOnDropEditProvider(
					i,
					this._transformDocumentSelector(t, e),
					r
						? {
								supportsResolve: !!n.resolveDocumentDropEdit,
								dropMimeTypes: r.dropMimeTypes,
								providedDropKinds: r.providedDropEditKinds?.map((s) => s.value),
							}
						: void 0,
				),
				this._createDisposable(i)
			)
		}
		$provideDocumentOnDropEdits(e, t, n, r, i, s) {
			return this._withAdapter(
				e,
				ym,
				(a) => Promise.resolve(a.provideDocumentOnDropEdits(t, y.revive(n), r, i, s)),
				void 0,
				void 0,
			)
		}
		$resolveDropEdit(e, t, n) {
			return this._withAdapter(e, ym, (r) => r.resolveDropEdit(t, n), {}, void 0)
		}
		$releaseDocumentOnDropEdits(e, t) {
			this._withAdapter(e, ym, (n) => Promise.resolve(n.releaseDropEdits(t)), void 0, void 0)
		}
		registerDocumentPasteEditProvider(e, t, n, r) {
			let i = this._nextHandle()
			return (
				this._adapter.set(i, new Gd(new zd(this._proxy, this._documents, n, i, e), e)),
				this._proxy.$registerPasteEditProvider(i, this._transformDocumentSelector(t, e), {
					supportsCopy: !!n.prepareDocumentPaste,
					supportsPaste: !!n.provideDocumentPasteEdits,
					supportsResolve: !!n.resolveDocumentPasteEdit,
					providedPasteEditKinds: r.providedPasteEditKinds?.map((s) => s.value),
					copyMimeTypes: r.copyMimeTypes,
					pasteMimeTypes: r.pasteMimeTypes,
				}),
				this._createDisposable(i)
			)
		}
		$prepareDocumentPaste(e, t, n, r, i) {
			return this._withAdapter(e, zd, (s) => s.prepareDocumentPaste(y.revive(t), n, r, i), void 0, i)
		}
		$providePasteEdits(e, t, n, r, i, s, a) {
			return this._withAdapter(e, zd, (l) => l.providePasteEdits(t, y.revive(n), r, i, s, a), void 0, a)
		}
		$resolvePasteEdit(e, t, n) {
			return this._withAdapter(e, zd, (r) => r.resolvePasteEdit(t, n), {}, void 0)
		}
		$releasePasteEdits(e, t) {
			this._withAdapter(e, zd, (n) => Promise.resolve(n.releasePasteEdits(t)), void 0, void 0)
		}
		static _serializeRegExp(e) {
			return { pattern: e.source, flags: e.flags }
		}
		static _serializeIndentationRule(e) {
			return {
				decreaseIndentPattern: o._serializeRegExp(e.decreaseIndentPattern),
				increaseIndentPattern: o._serializeRegExp(e.increaseIndentPattern),
				indentNextLinePattern: e.indentNextLinePattern ? o._serializeRegExp(e.indentNextLinePattern) : void 0,
				unIndentedLinePattern: e.unIndentedLinePattern ? o._serializeRegExp(e.unIndentedLinePattern) : void 0,
			}
		}
		static _serializeOnEnterRule(e) {
			return {
				beforeText: o._serializeRegExp(e.beforeText),
				afterText: e.afterText ? o._serializeRegExp(e.afterText) : void 0,
				previousLineText: e.previousLineText ? o._serializeRegExp(e.previousLineText) : void 0,
				action: e.action,
			}
		}
		static _serializeOnEnterRules(e) {
			return e.map(o._serializeOnEnterRule)
		}
		static _serializeAutoClosingPair(e) {
			return { open: e.open, close: e.close, notIn: e.notIn ? e.notIn.map((t) => Cd.toString(t)) : void 0 }
		}
		static _serializeAutoClosingPairs(e) {
			return e.map(o._serializeAutoClosingPair)
		}
		setLanguageConfiguration(e, t, n) {
			let { wordPattern: r } = n
			if (r && yv(r))
				throw new Error(
					`Invalid language configuration: wordPattern '${r}' is not allowed to match the empty string.`,
				)
			r ? this._documents.setWordDefinitionFor(t, r) : this._documents.setWordDefinitionFor(t, void 0),
				n.__electricCharacterSupport &&
					this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", e, "Do not use."),
				n.__characterPairSupport &&
					this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", e, "Do not use.")
			let i = this._nextHandle(),
				s = {
					comments: n.comments,
					brackets: n.brackets,
					wordPattern: n.wordPattern ? o._serializeRegExp(n.wordPattern) : void 0,
					indentationRules: n.indentationRules ? o._serializeIndentationRule(n.indentationRules) : void 0,
					onEnterRules: n.onEnterRules ? o._serializeOnEnterRules(n.onEnterRules) : void 0,
					__electricCharacterSupport: n.__electricCharacterSupport,
					__characterPairSupport: n.__characterPairSupport,
					autoClosingPairs: n.autoClosingPairs ? o._serializeAutoClosingPairs(n.autoClosingPairs) : void 0,
				}
			return this._proxy.$setLanguageConfiguration(i, t, s), this._createDisposable(i)
		}
		$setWordDefinitions(e) {
			for (let t of e) this._documents.setWordDefinitionFor(t.languageId, new RegExp(t.regexSource, t.regexFlags))
		}
	}
var hB
;((e) => {
	function o(t) {
		switch (t.type) {
			case "extension":
				return `extension:${t.extensionId.value}`
			case "mcp":
				return `mcp:${t.collectionId}:${t.definitionId}`
			case "internal":
				return "internal"
		}
	}
	e.toKey = o
})((hB ||= {}))
function kN(o) {
	return typeof o == "object" && typeof o.sessionId == "string"
}
var RN = O("ILanguageModelToolsService")
var AN = O("notebookService")
var ON = O("codeMapperService")
var LN = O("languageModelIgnoredFilesService")
var MN = `
The user is very smart and can understand how to apply your edits to their files, you just need to provide minimal hints.
Avoid repeating existing code, instead use comments to represent regions of unchanged code. The user prefers that you are as concise as possible. For example:
// ...existing code...
{ changed code }
// ...existing code...
{ changed code }
// ...existing code...

Here is an example of how you should use format an edit to an existing Person class:
class Person {
	// ...existing code...
	age: number;
	// ...existing code...
	getAge() {
		return this.age;
	}
}
`,
	m1 = "vscode_editFile",
	ES = "vscode_editFile_internal",
	Sh = {
		id: ES,
		displayName: p("chat.tools.editFile", "Edit File"),
		modelDescription: `Edit a file in the workspace. Use this tool once per file that needs to be modified, even if there are multiple changes for a file. Generate the "explanation" property first. ${MN}`,
		source: { type: "internal" },
		inputSchema: {
			type: "object",
			properties: {
				explanation: {
					type: "string",
					description:
						"A short explanation of the edit being made. Can be the same as the explanation you showed to the user.",
				},
				filePath: {
					type: "string",
					description:
						"An absolute path to the file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.",
				},
				code: { type: "string", description: "The code change to apply to the file. " + MN },
			},
			required: ["explanation", "filePath", "code"],
		},
	},
	Im = class {
		constructor(e, t, n, r, i, s, a) {
			this.chatService = e
			this.codeMapperService = t
			this.workspaceContextService = n
			this.ignoredFilesService = r
			this.textFileService = i
			this.notebookService = s
			this.editorGroupsService = a
		}
		async invoke(e, t, n) {
			if (!e.context) throw new Error("toolInvocationToken is required for this tool")
			let r = e.parameters,
				i = y.revive(r.file),
				s = Jf.parse(i)?.notebook || i
			if (
				!this.workspaceContextService.isInsideWorkspace(s) &&
				!this.notebookService.getNotebookTextModel(s) &&
				!this.editorGroupsService.getGroups(1).some((h) => h.editors.some((g) => qr(g.resource, s)))
			)
				throw new Error(`File ${s.fsPath} can't be edited because it's not inside the current workspace`)
			if (await this.ignoredFilesService.fileIsIgnored(s, n))
				throw new Error(`File ${s.fsPath} can't be edited because it is configured to be ignored by Copilot`)
			let a = this.chatService.getSession(e.context?.sessionId),
				l = a.getRequests().at(-1)
			l.response?.response.getMarkdown().length && a.acceptResponseProgress(l, { kind: "undoStop", id: He() }),
				a.acceptResponseProgress(l, { kind: "markdownContent", content: new Vo("\n````\n") }),
				a.acceptResponseProgress(l, { kind: "codeblockUri", uri: s, isEdit: !0 }),
				a.acceptResponseProgress(l, { kind: "markdownContent", content: new Vo(r.code + "\n````\n") }),
				this.notebookService.hasSupportedNotebooks(s) && this.notebookService.getNotebookTextModel(s)
					? a.acceptResponseProgress(l, { kind: "notebookEdit", edits: [], uri: s })
					: a.acceptResponseProgress(l, { kind: "textEdit", edits: [], uri: s })
			let d = a.editingSession
			if (!d) throw new Error("This tool must be called from within an editing session")
			let c = await this.codeMapperService.mapCode(
				{
					codeBlocks: [{ code: r.code, resource: s, markdownBeforeBlock: r.explanation }],
					location: "tool",
					chatRequestId: e.chatRequestId,
				},
				{
					textEdit: (m, f) => {
						a.acceptResponseProgress(l, { kind: "textEdit", uri: m, edits: f })
					},
					notebookEdit(m, f) {
						a.acceptResponseProgress(l, { kind: "notebookEdit", uri: m, edits: f })
					},
				},
				n,
			)
			if (
				(this.notebookService.hasSupportedNotebooks(s) && this.notebookService.getNotebookTextModel(s)
					? a.acceptResponseProgress(l, { kind: "notebookEdit", uri: s, edits: [], done: !0 })
					: a.acceptResponseProgress(l, { kind: "textEdit", uri: s, edits: [], done: !0 }),
				c?.errorMessage)
			)
				throw new Error(c.errorMessage)
			let u
			return (
				await new Promise((m) => {
					let f = !1
					u = nd((h) => {
						let I = d.entries.read(h)?.find((C) => C.modifiedURI.toString() === s.toString())
						I && (I.isCurrentlyBeingModifiedBy.read(h) ? (f = !0) : f && m(!0))
					})
				}).finally(() => {
					u.dispose()
				}),
				await this.textFileService.save(s, { reason: 2, skipSaveParticipants: !0 }),
				{ content: [{ kind: "text", value: "The file was edited successfully" }] }
			)
		}
		async prepareToolInvocation(e, t) {
			return { presentation: "hidden" }
		}
	}
Im = R([S(0, QM), S(1, ON), S(2, mi), S(3, LN), S(4, UF), S(5, AN), S(6, Oy)], Im)
var TS = class {
	processInput(e) {
		if (!e.filePath) return e
		let t = e.filePath
		return { file: t.startsWith("untitled:") ? y.parse(t) : y.file(t), explanation: e.explanation, code: e.code }
	}
}
var wS = class extends $ {
	static {
		this.ID = "chat.builtinTools"
	}
	constructor(e, t) {
		super()
		let n = t.createInstance(Im)
		this._register(e.registerToolData(Sh)), this._register(e.registerToolImplementation(Sh.id, n))
	}
}
wS = R([S(0, RN), S(1, Uo)], wS)
var FN = "vscode_fetchWebPage_internal"
var PS = class {
	constructor(e, t) {
		this._languageModels = t
		this._registeredTools = new Map()
		this._tokenCountFuncs = new Map()
		this._allTools = new Map()
		this._toolInputProcessors = new Map()
		;(this._proxy = e.getProxy(N.MainThreadLanguageModelTools)),
			this._proxy.$getTools().then((n) => {
				for (let r of n) this._allTools.set(r.id, ut(r))
			}),
			this._toolInputProcessors.set(Sh.id, new TS())
	}
	async $countTokensForInvocation(e, t, n) {
		let r = this._tokenCountFuncs.get(e)
		if (!r) throw new Error(`Tool invocation call ${e} not found`)
		return await r(t, n)
	}
	async invokeTool(e, t, n, r) {
		let i = He()
		n.tokenizationOptions && this._tokenCountFuncs.set(i, n.tokenizationOptions.countTokens)
		try {
			if (n.toolInvocationToken && !kN(n.toolInvocationToken)) throw new Error("Invalid tool invocation token")
			if ((t === ES || t === m1) && !nt(e, "chatParticipantPrivate")) throw new Error(`Invalid tool: ${t}`)
			let s = this._toolInputProcessors.get(t)?.processInput(n.input) ?? n.input,
				a = await this._proxy.$invokeTool(
					{
						toolId: t,
						callId: i,
						parameters: s,
						tokenBudget: n.tokenizationOptions?.tokenBudget,
						context: n.toolInvocationToken,
						chatRequestId: nt(e, "chatParticipantPrivate") ? n.chatRequestId : void 0,
						chatInteractionId: nt(e, "chatParticipantPrivate") ? n.chatInteractionId : void 0,
					},
					r,
				)
			return Ix.to(ut(a))
		} finally {
			this._tokenCountFuncs.delete(i)
		}
	}
	$onDidChangeTools(e) {
		this._allTools.clear()
		for (let t of e) this._allTools.set(t.id, t)
	}
	getTools(e) {
		return Array.from(this._allTools.values())
			.map((t) => rk.to(t))
			.filter((t) => {
				switch (t.name) {
					case ES:
					case m1:
					case FN:
						return nt(e, "chatParticipantPrivate")
					default:
						return !0
				}
			})
	}
	async $invokeTool(e, t) {
		let n = this._registeredTools.get(e.toolId)
		if (!n) throw new Error(`Unknown tool ${e.toolId}`)
		let r = { input: e.parameters, toolInvocationToken: e.context }
		nt(n.extension, "chatParticipantPrivate") &&
			((r.chatRequestId = e.chatRequestId),
			(r.chatInteractionId = e.chatInteractionId),
			(r.chatSessionId = e.context?.sessionId),
			e.toolSpecificData?.kind === "terminal" && (r.terminalCommand = e.toolSpecificData.command)),
			nt(n.extension, "chatParticipantAdditions") &&
				e.modelId &&
				(r.model = await this.getModel(e.modelId, n.extension)),
			e.tokenBudget !== void 0 &&
				(r.tokenizationOptions = {
					tokenBudget: e.tokenBudget,
					countTokens:
						this._tokenCountFuncs.get(e.callId) ||
						((s, a = De.None) => this._proxy.$countTokensForInvocation(e.callId, s, a)),
				})
		let i = await Fv(Promise.resolve(n.tool.invoke(r, t)), t)
		if (!i) throw new xt()
		return Ix.from(i, n.extension)
	}
	async getModel(e, t) {
		let n
		if (
			(e && (n = await this._languageModels.getLanguageModelByIdentifier(t, e)),
			!n && ((n = await this._languageModels.getDefaultLanguageModel(t)), !n))
		)
			throw new Error("Language model unavailable")
		return n
	}
	async $prepareToolInvocation(e, t, n) {
		let r = this._registeredTools.get(e)
		if (!r) throw new Error(`Unknown tool ${e}`)
		let i = { input: t }
		if (nt(r.extension, "chatParticipantPrivate") && r.tool.prepareInvocation2) {
			let s = await r.tool.prepareInvocation2(i, n)
			return s
				? {
						confirmationMessages: s.confirmationMessages
							? {
									title: s.confirmationMessages.title,
									message:
										typeof s.confirmationMessages.message == "string"
											? s.confirmationMessages.message
											: Ce.from(s.confirmationMessages.message),
								}
							: void 0,
						toolSpecificData: { kind: "terminal", language: s.language, command: s.command },
					}
				: void 0
		} else if (r.tool.prepareInvocation) {
			let s = await r.tool.prepareInvocation(i, n)
			return s
				? ((s.pastTenseMessage || s.presentation) && M(r.extension, "chatParticipantPrivate"),
					{
						confirmationMessages: s.confirmationMessages
							? {
									title: s.confirmationMessages.title,
									message:
										typeof s.confirmationMessages.message == "string"
											? s.confirmationMessages.message
											: Ce.from(s.confirmationMessages.message),
								}
							: void 0,
						invocationMessage: Ce.fromStrict(s.invocationMessage),
						pastTenseMessage: Ce.fromStrict(s.pastTenseMessage),
						presentation: s.presentation,
					})
				: void 0
		}
	}
	registerTool(e, t, n) {
		return (
			this._registeredTools.set(t, { extension: e, tool: n }),
			this._proxy.$registerTool(t),
			q(() => {
				this._registeredTools.delete(t), this._proxy.$unregisterTool(t)
			})
		)
	}
}
var _S = class {
	constructor(e, t, n, r) {
		this._documents = t
		this._commands = n
		this._uriTransformer = r
		this._languageIds = []
		this._handlePool = 0
		this._ids = new Set()
		this._proxy = e.getProxy(N.MainThreadLanguages)
	}
	$acceptLanguageIds(e) {
		this._languageIds = e
	}
	async getLanguages() {
		return this._languageIds.slice(0)
	}
	async changeLanguage(e, t) {
		await this._proxy.$changeLanguage(e, t)
		let n = this._documents.getDocumentData(e)
		if (!n) throw new Error(`document '${e.toString()}' NOT found`)
		return n.document
	}
	async tokenAtPosition(e, t) {
		let n = e.version,
			r = Je.from(t),
			i = await this._proxy.$tokensAtPosition(e.uri, r),
			s = { type: 0, range: e.getWordRangeAtPosition(t) ?? new pe(t.line, t.character, t.line, t.character) }
		if (!i) return s
		let a = { range: H.to(i.range), type: DD.to(i.type) }
		return !a.range.contains(t) || n !== e.version ? s : a
	}
	createLanguageStatusItem(e, t, n) {
		let r = this._handlePool++,
			i = this._proxy,
			s = this._ids,
			a = `${e.identifier.value}/${t}`
		if (s.has(a)) throw new Error(`LanguageStatusItem with id '${t}' ALREADY exists`)
		s.add(a)
		let l = {
				selector: n,
				id: t,
				name: e.displayName ?? e.name,
				severity: 0,
				command: void 0,
				text: "",
				detail: "",
				busy: !1,
			},
			d,
			c = new Q(),
			u = () => {
				if ((d?.dispose(), !s.has(a))) {
					console.warn(
						`LanguageStatusItem (${t}) from ${e.identifier.value} has been disposed and CANNOT be updated anymore`,
					)
					return
				}
				d = gf(() => {
					c.clear(),
						this._proxy.$setLanguageStatus(r, {
							id: a,
							name: l.name ?? e.displayName ?? e.name,
							source: e.displayName ?? e.name,
							selector: Fs.from(l.selector, this._uriTransformer),
							label: l.text,
							detail: l.detail ?? "",
							severity: l.severity === 2 ? It.Error : l.severity === 1 ? It.Warning : It.Info,
							command: l.command && this._commands.toInternal(l.command, c),
							accessibilityInfo: l.accessibilityInformation,
							busy: l.busy,
						})
				}, 0)
			},
			m = {
				dispose() {
					c.dispose(), d?.dispose(), i.$removeLanguageStatus(r), s.delete(a)
				},
				get id() {
					return l.id
				},
				get name() {
					return l.name
				},
				set name(f) {
					;(l.name = f), u()
				},
				get selector() {
					return l.selector
				},
				set selector(f) {
					;(l.selector = f), u()
				},
				get text() {
					return l.text
				},
				set text(f) {
					;(l.text = f), u()
				},
				set text2(f) {
					M(e, "languageStatusText"), (l.text = f), u()
				},
				get text2() {
					return M(e, "languageStatusText"), l.text
				},
				get detail() {
					return l.detail
				},
				set detail(f) {
					;(l.detail = f), u()
				},
				get severity() {
					return l.severity
				},
				set severity(f) {
					;(l.severity = f), u()
				},
				get accessibilityInformation() {
					return l.accessibilityInformation
				},
				set accessibilityInformation(f) {
					;(l.accessibilityInformation = f), u()
				},
				get command() {
					return l.command
				},
				set command(f) {
					;(l.command = f), u()
				},
				get busy() {
					return l.busy
				},
				set busy(f) {
					;(l.busy = f), u()
				},
			}
		return u(), m
	}
}
function vB(o) {
	return o && o.title
}
var xm = class {
	constructor(e, t) {
		this._logService = t
		this._proxy = e.getProxy(N.MainThreadMessageService)
	}
	showMessage(e, t, n, r, i) {
		let s = { source: { identifier: e.identifier, label: e.displayName || e.name } },
			a
		typeof r == "string" || vB(r)
			? (a = [r, ...i])
			: ((s.modal = r?.modal), (s.useCustom = r?.useCustom), (s.detail = r?.detail), (a = i)),
			s.useCustom && M(e, "resolvers")
		let l = [],
			d = !1
		for (let c = 0; c < a.length; c++) {
			let u = a[c]
			if (typeof u == "string") l.push({ title: u, handle: c, isCloseAffordance: !1 })
			else if (typeof u == "object") {
				let { title: m, isCloseAffordance: f } = u
				l.push({ title: m, isCloseAffordance: !!f, handle: c }),
					f &&
						(d
							? this._logService.warn(
									`[${e.identifier}] Only one message item can have 'isCloseAffordance':`,
									u,
								)
							: (d = !0))
			} else this._logService.warn(`[${e.identifier}] Invalid message item:`, u)
		}
		return this._proxy.$showMessage(t, n, s, l).then((c) => {
			if (typeof c == "number") return a[c]
		})
	}
}
xm = R([S(1, te)], xm)
var Th = class {
		constructor(e, t, n, r) {
			this.start = e
			this.deletedCount = t
			this.deletedItems = n
			this.items = r
		}
		asApiEvent() {
			return {
				range: new dr(this.start, this.start + this.deletedCount),
				addedCells: this.items.map((e) => e.apiCell),
				removedCells: this.deletedItems,
			}
		}
	},
	Cm = class {
		constructor(e, t, n) {
			this.notebook = e
			this._extHostDocument = t
			this._cellData = n
			;(this.handle = n.handle),
				(this.uri = y.revive(n.uri)),
				(this.cellKind = n.cellKind),
				(this._outputs = n.outputs.map(Ms.to)),
				(this._internalMetadata = n.internalMetadata ?? {}),
				(this._metadata = Object.freeze(n.metadata ?? {})),
				(this._previousResult = Object.freeze(ju.to(n.internalMetadata ?? {})))
		}
		static asModelAddData(e) {
			return {
				EOL: e.eol,
				lines: e.source,
				languageId: e.language,
				uri: e.uri,
				isDirty: !1,
				versionId: 1,
				encoding: "utf8",
			}
		}
		get internalMetadata() {
			return this._internalMetadata
		}
		get apiCell() {
			if (!this._apiCell) {
				let e = this,
					t = this._extHostDocument.getDocument(this.uri)
				if (!t) throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`)
				let n = {
					get index() {
						return e.notebook.getCellIndex(e)
					},
					notebook: e.notebook.apiNotebook,
					kind: ug.to(this._cellData.cellKind),
					document: t.document,
					get mime() {
						return e._mime
					},
					set mime(r) {
						e._mime = r
					},
					get outputs() {
						return e._outputs.slice(0)
					},
					get metadata() {
						return e._metadata
					},
					get executionSummary() {
						return e._previousResult
					},
				}
				this._apiCell = Object.freeze(n)
			}
			return this._apiCell
		}
		setOutputs(e) {
			this._outputs = e.map(Ms.to)
		}
		setOutputItems(e, t, n) {
			let r = n.map(wd.to),
				i = this._outputs.find((s) => s.id === e)
			if (
				i &&
				(t || (i.items.length = 0), i.items.push(...r), i.items.length > 1 && i.items.every((s) => Qb(s.mime)))
			) {
				let s = new Map(),
					a = []
				i.items.forEach((l) => {
					let d
					s.has(l.mime) ? (d = s.get(l.mime)) : ((d = []), s.set(l.mime, d), a.push(l.mime)), d.push(l.data)
				}),
					(i.items.length = 0),
					a.forEach((l) => {
						let d = IM(s.get(l))
						i.items.push({ mime: l, data: d.data.buffer })
					})
			}
		}
		setMetadata(e) {
			this._metadata = Object.freeze(e)
		}
		setInternalMetadata(e) {
			;(this._internalMetadata = e), (this._previousResult = Object.freeze(ju.to(e)))
		}
		setMime(e) {}
	},
	DS = class o {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._textDocumentsAndEditors = t
			this._textDocuments = n
			this.uri = r
			this.handle = o._handlePool++
			this._cells = []
			this._versionId = 0
			this._isDirty = !1
			this._disposed = !1
			;(this._notebookType = i.viewType),
				(this._metadata = Object.freeze(i.metadata ?? Object.create(null))),
				this._spliceNotebookCells([[0, 0, i.cells]], !0, void 0),
				(this._versionId = i.versionId)
		}
		static {
			this._handlePool = 0
		}
		dispose() {
			this._disposed = !0
		}
		get versionId() {
			return this._versionId
		}
		get apiNotebook() {
			if (!this._notebook) {
				let e = this,
					t = {
						get uri() {
							return e.uri
						},
						get version() {
							return e._versionId
						},
						get notebookType() {
							return e._notebookType
						},
						get isDirty() {
							return e._isDirty
						},
						get isUntitled() {
							return e.uri.scheme === W.untitled
						},
						get isClosed() {
							return e._disposed
						},
						get metadata() {
							return e._metadata
						},
						get cellCount() {
							return e._cells.length
						},
						cellAt(n) {
							return (n = e._validateIndex(n)), e._cells[n].apiCell
						},
						getCells(n) {
							return (n ? e._getCells(n) : e._cells).map((i) => i.apiCell)
						},
						save() {
							return e._save()
						},
						[Symbol.for("debug.description")]() {
							return `NotebookDocument(${this.uri.toString()})`
						},
					}
				this._notebook = Object.freeze(t)
			}
			return this._notebook
		}
		acceptDocumentPropertiesChanged(e) {
			e.metadata && (this._metadata = Object.freeze({ ...this._metadata, ...e.metadata }))
		}
		acceptDirty(e) {
			this._isDirty = e
		}
		acceptModelChanged(e, t, n) {
			;(this._versionId = e.versionId), (this._isDirty = t), this.acceptDocumentPropertiesChanged({ metadata: n })
			let r = { notebook: this.apiNotebook, metadata: n, cellChanges: [], contentChanges: [] },
				i = []
			for (let a of e.rawEvents)
				a.kind === 1
					? this._spliceNotebookCells(a.changes, !1, r.contentChanges)
					: a.kind === 2
						? this._moveCells(a.index, a.length, a.newIdx, r.contentChanges)
						: a.kind === 8
							? (this._setCellOutputs(a.index, a.outputs),
								i.push({
									cell: this._cells[a.index].apiCell,
									outputs: this._cells[a.index].apiCell.outputs,
								}))
							: a.kind === 9
								? (this._setCellOutputItems(a.index, a.outputId, a.append, a.outputItems),
									i.push({
										cell: this._cells[a.index].apiCell,
										outputs: this._cells[a.index].apiCell.outputs,
									}))
								: a.kind === 5
									? (this._changeCellLanguage(a.index, a.language),
										i.push({
											cell: this._cells[a.index].apiCell,
											document: this._cells[a.index].apiCell.document,
										}))
									: a.kind === 10
										? i.push({
												cell: this._cells[a.index].apiCell,
												document: this._cells[a.index].apiCell.document,
											})
										: a.kind === 13
											? this._changeCellMime(a.index, a.mime)
											: a.kind === 7
												? (this._changeCellMetadata(a.index, a.metadata),
													i.push({
														cell: this._cells[a.index].apiCell,
														metadata: this._cells[a.index].apiCell.metadata,
													}))
												: a.kind === 12 &&
													(this._changeCellInternalMetadata(a.index, a.internalMetadata),
													i.push({
														cell: this._cells[a.index].apiCell,
														executionSummary: this._cells[a.index].apiCell.executionSummary,
													}))
			let s = new Map()
			for (let a = 0; a < i.length; a++) {
				let l = i[a],
					d = s.get(l.cell)
				if (d === void 0) {
					let c = r.cellChanges.push({
						document: void 0,
						executionSummary: void 0,
						metadata: void 0,
						outputs: void 0,
						...l,
					})
					s.set(l.cell, c - 1)
				} else r.cellChanges[d] = { ...r.cellChanges[d], ...l }
			}
			return Object.freeze(r), Object.freeze(r.cellChanges), Object.freeze(r.contentChanges), r
		}
		_validateIndex(e) {
			return (e = e | 0), e < 0 ? 0 : e >= this._cells.length ? this._cells.length - 1 : e
		}
		_validateRange(e) {
			let t = e.start | 0,
				n = e.end | 0
			return t < 0 && (t = 0), n > this._cells.length && (n = this._cells.length), e.with({ start: t, end: n })
		}
		_getCells(e) {
			e = this._validateRange(e)
			let t = []
			for (let n = e.start; n < e.end; n++) t.push(this._cells[n])
			return t
		}
		async _save() {
			return this._disposed
				? Promise.reject(new Error("Notebook has been closed"))
				: this._proxy.$trySaveNotebook(this.uri)
		}
		_spliceNotebookCells(e, t, n) {
			if (this._disposed) return
			let r = [],
				i = [],
				s = []
			if (
				(e.reverse().forEach((a) => {
					let d = a[2].map((m) => {
							let f = new Cm(this, this._textDocumentsAndEditors, m)
							return t || i.push(Cm.asModelAddData(m)), f
						}),
						c = new Th(a[0], a[1], [], d),
						u = this._cells.splice(a[0], a[1], ...d)
					for (let m of u) s.push(m.uri), c.deletedItems.push(m.apiCell)
					r.push(c)
				}),
				this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
					addedDocuments: i,
					removedDocuments: s,
				}),
				n)
			)
				for (let a of r) n.push(a.asApiEvent())
		}
		_moveCells(e, t, n, r) {
			let i = this._cells.splice(e, t)
			this._cells.splice(n, 0, ...i)
			let s = [
				new Th(
					e,
					t,
					i.map((a) => a.apiCell),
					[],
				),
				new Th(n, 0, [], i),
			]
			for (let a of s) r.push(a.asApiEvent())
		}
		_setCellOutputs(e, t) {
			this._cells[e].setOutputs(t)
		}
		_setCellOutputItems(e, t, n, r) {
			this._cells[e].setOutputItems(t, n, r)
		}
		_changeCellLanguage(e, t) {
			let n = this._cells[e]
			n.apiCell.document.languageId !== t && this._textDocuments.$acceptModelLanguageChanged(n.uri, t)
		}
		_changeCellMime(e, t) {
			let n = this._cells[e]
			n.apiCell.mime = t
		}
		_changeCellMetadata(e, t) {
			this._cells[e].setMetadata(t)
		}
		_changeCellInternalMetadata(e, t) {
			this._cells[e].setInternalMetadata(t)
		}
		getCellFromApiCell(e) {
			return this._cells.find((t) => t.apiCell === e)
		}
		getCellFromIndex(e) {
			return this._cells[e]
		}
		getCell(e) {
			return this._cells.find((t) => t.handle === e)
		}
		getCellIndex(e) {
			return this._cells.indexOf(e)
		}
	}
var Qd = class o {
	constructor(e, t, n, r, i, s, a) {
		this.id = e
		this._proxy = t
		this.notebookData = n
		this._visibleRanges = r
		this._selections = i
		this._viewColumn = s
		this.viewType = a
		this._visible = !1
	}
	static {
		this.apiEditorsToExtHost = new WeakMap()
	}
	get apiEditor() {
		if (!this._editor) {
			let e = this
			;(this._editor = {
				get notebook() {
					return e.notebookData.apiNotebook
				},
				get selection() {
					return e._selections[0]
				},
				set selection(t) {
					this.selections = [t]
				},
				get selections() {
					return e._selections
				},
				set selections(t) {
					if (!Array.isArray(t) || !t.every(dr.isNotebookRange)) throw We("selections")
					;(e._selections = t), e._trySetSelections(t)
				},
				get visibleRanges() {
					return e._visibleRanges
				},
				revealRange(t, n) {
					e._proxy.$tryRevealRange(e.id, Zr.from(t), n ?? 0)
				},
				get viewColumn() {
					return e._viewColumn
				},
				get replOptions() {
					if (e.viewType === "repl") return { appendIndex: this.notebook.cellCount - 1 }
				},
				[Symbol.for("debug.description")]() {
					return `NotebookEditor(${this.notebook.uri.toString()})`
				},
			}),
				o.apiEditorsToExtHost.set(this._editor, this)
		}
		return this._editor
	}
	get visible() {
		return this._visible
	}
	_acceptVisibility(e) {
		this._visible = e
	}
	_acceptVisibleRanges(e) {
		this._visibleRanges = e
	}
	_acceptSelections(e) {
		this._selections = e
	}
	_trySetSelections(e) {
		this._proxy.$trySetSelections(this.id, e.map(Zr.from))
	}
	_acceptViewColumn(e) {
		this._viewColumn = e
	}
}
var Sm = class {
	constructor(e, t) {
		;(this.piece = e),
			(this.color = t),
			(this.size_left = 0),
			(this.lf_left = 0),
			(this.parent = this),
			(this.left = this),
			(this.right = this)
	}
	next() {
		if (this.right !== ue) return kS(this.right)
		let e = this
		for (; e.parent !== ue && e.parent.left !== e; ) e = e.parent
		return e.parent === ue ? ue : e.parent
	}
	prev() {
		if (this.left !== ue) return g1(this.left)
		let e = this
		for (; e.parent !== ue && e.parent.right !== e; ) e = e.parent
		return e.parent === ue ? ue : e.parent
	}
	detach() {
		;(this.parent = null), (this.left = null), (this.right = null)
	}
}
var ue = new Sm(null, 0)
ue.parent = ue
ue.left = ue
ue.right = ue
ue.color = 0
function kS(o) {
	for (; o.left !== ue; ) o = o.left
	return o
}
function g1(o) {
	for (; o.right !== ue; ) o = o.right
	return o
}
function h1(o) {
	return o === ue ? 0 : o.size_left + o.piece.length + h1(o.right)
}
function v1(o) {
	return o === ue ? 0 : o.lf_left + o.piece.lineFeedCnt + v1(o.right)
}
function f1() {
	ue.parent = ue
}
function wh(o, e) {
	let t = e.right
	;(t.size_left += e.size_left + (e.piece ? e.piece.length : 0)),
		(t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0)),
		(e.right = t.left),
		t.left !== ue && (t.left.parent = e),
		(t.parent = e.parent),
		e.parent === ue ? (o.root = t) : e.parent.left === e ? (e.parent.left = t) : (e.parent.right = t),
		(t.left = e),
		(e.parent = t)
}
function Ph(o, e) {
	let t = e.left
	;(e.left = t.right),
		t.right !== ue && (t.right.parent = e),
		(t.parent = e.parent),
		(e.size_left -= t.size_left + (t.piece ? t.piece.length : 0)),
		(e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0)),
		e.parent === ue ? (o.root = t) : e === e.parent.right ? (e.parent.right = t) : (e.parent.left = t),
		(t.right = e),
		(e.parent = t)
}
function _h(o, e) {
	let t, n
	if (
		(e.left === ue
			? ((n = e), (t = n.right))
			: e.right === ue
				? ((n = e), (t = n.left))
				: ((n = kS(e.right)), (t = n.right)),
		n === o.root)
	) {
		;(o.root = t), (t.color = 0), e.detach(), f1(), (o.root.parent = ue)
		return
	}
	let r = n.color === 1
	if (
		(n === n.parent.left ? (n.parent.left = t) : (n.parent.right = t),
		n === e
			? ((t.parent = n.parent), Eh(o, t))
			: (n.parent === e ? (t.parent = n) : (t.parent = n.parent),
				Eh(o, t),
				(n.left = e.left),
				(n.right = e.right),
				(n.parent = e.parent),
				(n.color = e.color),
				e === o.root ? (o.root = n) : e === e.parent.left ? (e.parent.left = n) : (e.parent.right = n),
				n.left !== ue && (n.left.parent = n),
				n.right !== ue && (n.right.parent = n),
				(n.size_left = e.size_left),
				(n.lf_left = e.lf_left),
				Eh(o, n)),
		e.detach(),
		t.parent.left === t)
	) {
		let s = h1(t),
			a = v1(t)
		if (s !== t.parent.size_left || a !== t.parent.lf_left) {
			let l = s - t.parent.size_left,
				d = a - t.parent.lf_left
			;(t.parent.size_left = s), (t.parent.lf_left = a), Ui(o, t.parent, l, d)
		}
	}
	if ((Eh(o, t.parent), r)) {
		f1()
		return
	}
	let i
	for (; t !== o.root && t.color === 0; )
		t === t.parent.left
			? ((i = t.parent.right),
				i.color === 1 && ((i.color = 0), (t.parent.color = 1), wh(o, t.parent), (i = t.parent.right)),
				i.left.color === 0 && i.right.color === 0
					? ((i.color = 1), (t = t.parent))
					: (i.right.color === 0 && ((i.left.color = 0), (i.color = 1), Ph(o, i), (i = t.parent.right)),
						(i.color = t.parent.color),
						(t.parent.color = 0),
						(i.right.color = 0),
						wh(o, t.parent),
						(t = o.root)))
			: ((i = t.parent.left),
				i.color === 1 && ((i.color = 0), (t.parent.color = 1), Ph(o, t.parent), (i = t.parent.left)),
				i.left.color === 0 && i.right.color === 0
					? ((i.color = 1), (t = t.parent))
					: (i.left.color === 0 && ((i.right.color = 0), (i.color = 1), wh(o, i), (i = t.parent.left)),
						(i.color = t.parent.color),
						(t.parent.color = 0),
						(i.left.color = 0),
						Ph(o, t.parent),
						(t = o.root)))
	;(t.color = 0), f1()
}
function b1(o, e) {
	for (Eh(o, e); e !== o.root && e.parent.color === 1; )
		if (e.parent === e.parent.parent.left) {
			let t = e.parent.parent.right
			t.color === 1
				? ((e.parent.color = 0), (t.color = 0), (e.parent.parent.color = 1), (e = e.parent.parent))
				: (e === e.parent.right && ((e = e.parent), wh(o, e)),
					(e.parent.color = 0),
					(e.parent.parent.color = 1),
					Ph(o, e.parent.parent))
		} else {
			let t = e.parent.parent.left
			t.color === 1
				? ((e.parent.color = 0), (t.color = 0), (e.parent.parent.color = 1), (e = e.parent.parent))
				: (e === e.parent.left && ((e = e.parent), Ph(o, e)),
					(e.parent.color = 0),
					(e.parent.parent.color = 1),
					wh(o, e.parent.parent))
		}
	o.root.color = 0
}
function Ui(o, e, t, n) {
	for (; e !== o.root && e !== ue; )
		e.parent.left === e && ((e.parent.size_left += t), (e.parent.lf_left += n)), (e = e.parent)
}
function Eh(o, e) {
	let t = 0,
		n = 0
	if (e !== o.root) {
		for (; e !== o.root && e === e.parent.right; ) e = e.parent
		if (e !== o.root)
			for (
				e = e.parent,
					t = h1(e.left) - e.size_left,
					n = v1(e.left) - e.lf_left,
					e.size_left += t,
					e.lf_left += n;
				e !== o.root && (t !== 0 || n !== 0);

			)
				e.parent.left === e && ((e.parent.size_left += t), (e.parent.lf_left += n)), (e = e.parent)
	}
}
var js = 65535
function NN(o) {
	let e
	return o[o.length - 1] < 65536 ? (e = new Uint16Array(o.length)) : (e = new Uint32Array(o.length)), e.set(o, 0), e
}
var y1 = class {
	constructor(e, t, n, r, i) {
		this.lineStarts = e
		this.cr = t
		this.lf = n
		this.crlf = r
		this.isBasicASCII = i
	}
}
function Hi(o, e = !0) {
	let t = [0],
		n = 1
	for (let r = 0, i = o.length; r < i; r++) {
		let s = o.charCodeAt(r)
		s === 13
			? r + 1 < i && o.charCodeAt(r + 1) === 10
				? ((t[n++] = r + 2), r++)
				: (t[n++] = r + 1)
			: s === 10 && (t[n++] = r + 1)
	}
	return e ? NN(t) : t
}
function UN(o, e) {
	;(o.length = 0), (o[0] = 0)
	let t = 1,
		n = 0,
		r = 0,
		i = 0,
		s = !0
	for (let l = 0, d = e.length; l < d; l++) {
		let c = e.charCodeAt(l)
		c === 13
			? l + 1 < d && e.charCodeAt(l + 1) === 10
				? (i++, (o[t++] = l + 2), l++)
				: (n++, (o[t++] = l + 1))
			: c === 10
				? (r++, (o[t++] = l + 1))
				: s && c !== 9 && (c < 32 || c > 126) && (s = !1)
	}
	let a = new y1(NN(o), n, r, i, s)
	return (o.length = 0), a
}
var tr = class {
		constructor(e, t, n, r, i) {
			;(this.bufferIndex = e), (this.start = t), (this.end = n), (this.lineFeedCnt = r), (this.length = i)
		}
	},
	Wi = class {
		constructor(e, t) {
			;(this.buffer = e), (this.lineStarts = t)
		}
	},
	I1 = class {
		constructor(e, t) {
			;(this._pieces = []),
				(this._tree = e),
				(this._BOM = t),
				(this._index = 0),
				e.root !== ue && e.iterate(e.root, (n) => (n !== ue && this._pieces.push(n.piece), !0))
		}
		read() {
			return this._pieces.length === 0
				? this._index === 0
					? (this._index++, this._BOM)
					: null
				: this._index > this._pieces.length - 1
					? null
					: this._index === 0
						? this._BOM + this._tree.getPieceContent(this._pieces[this._index++])
						: this._tree.getPieceContent(this._pieces[this._index++])
		}
	},
	x1 = class {
		constructor(e) {
			;(this._limit = e), (this._cache = [])
		}
		get(e) {
			for (let t = this._cache.length - 1; t >= 0; t--) {
				let n = this._cache[t]
				if (n.nodeStartOffset <= e && n.nodeStartOffset + n.node.piece.length >= e) return n
			}
			return null
		}
		get2(e) {
			for (let t = this._cache.length - 1; t >= 0; t--) {
				let n = this._cache[t]
				if (
					n.nodeStartLineNumber &&
					n.nodeStartLineNumber < e &&
					n.nodeStartLineNumber + n.node.piece.lineFeedCnt >= e
				)
					return n
			}
			return null
		}
		set(e) {
			this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e)
		}
		validate(e) {
			let t = !1,
				n = this._cache
			for (let r = 0; r < n.length; r++) {
				let i = n[r]
				if (i.node.parent === null || i.nodeStartOffset >= e) {
					;(n[r] = null), (t = !0)
					continue
				}
			}
			if (t) {
				let r = []
				for (let i of n) i !== null && r.push(i)
				this._cache = r
			}
		}
	},
	RS = class {
		constructor(e, t, n) {
			this.create(e, t, n)
		}
		create(e, t, n) {
			;(this._buffers = [new Wi("", [0])]),
				(this._lastChangeBufferPos = { line: 0, column: 0 }),
				(this.root = ue),
				(this._lineCnt = 1),
				(this._length = 0),
				(this._EOL = t),
				(this._EOLLength = t.length),
				(this._EOLNormalized = n)
			let r = null
			for (let i = 0, s = e.length; i < s; i++)
				if (e[i].buffer.length > 0) {
					e[i].lineStarts || (e[i].lineStarts = Hi(e[i].buffer))
					let a = new tr(
						i + 1,
						{ line: 0, column: 0 },
						{
							line: e[i].lineStarts.length - 1,
							column: e[i].buffer.length - e[i].lineStarts[e[i].lineStarts.length - 1],
						},
						e[i].lineStarts.length - 1,
						e[i].buffer.length,
					)
					this._buffers.push(e[i]), (r = this.rbInsertRight(r, a))
				}
			;(this._searchCache = new x1(1)),
				(this._lastVisitedLine = { lineNumber: 0, value: "" }),
				this.computeBufferMetadata()
		}
		normalizeEOL(e) {
			let t = js,
				n = t - Math.floor(t / 3),
				r = n * 2,
				i = "",
				s = 0,
				a = []
			if (
				(this.iterate(this.root, (l) => {
					let d = this.getNodeContent(l),
						c = d.length
					if (s <= n || s + c < r) return (i += d), (s += c), !0
					let u = i.replace(/\r\n|\r|\n/g, e)
					return a.push(new Wi(u, Hi(u))), (i = d), (s = c), !0
				}),
				s > 0)
			) {
				let l = i.replace(/\r\n|\r|\n/g, e)
				a.push(new Wi(l, Hi(l)))
			}
			this.create(a, e, !0)
		}
		getEOL() {
			return this._EOL
		}
		setEOL(e) {
			;(this._EOL = e), (this._EOLLength = this._EOL.length), this.normalizeEOL(e)
		}
		createSnapshot(e) {
			return new I1(this, e)
		}
		equal(e) {
			if (this.getLength() !== e.getLength() || this.getLineCount() !== e.getLineCount()) return !1
			let t = 0
			return this.iterate(this.root, (r) => {
				if (r === ue) return !0
				let i = this.getNodeContent(r),
					s = i.length,
					a = e.nodeAt(t),
					l = e.nodeAt(t + s),
					d = e.getValueInRange2(a, l)
				return (t += s), i === d
			})
		}
		getOffsetAt(e, t) {
			let n = 0,
				r = this.root
			for (; r !== ue; )
				if (r.left !== ue && r.lf_left + 1 >= e) r = r.left
				else if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) {
					n += r.size_left
					let i = this.getAccumulatedValue(r, e - r.lf_left - 2)
					return (n += i + t - 1)
				} else (e -= r.lf_left + r.piece.lineFeedCnt), (n += r.size_left + r.piece.length), (r = r.right)
			return n
		}
		getPositionAt(e) {
			;(e = Math.floor(e)), (e = Math.max(0, e))
			let t = this.root,
				n = 0,
				r = e
			for (; t !== ue; )
				if (t.size_left !== 0 && t.size_left >= e) t = t.left
				else if (t.size_left + t.piece.length >= e) {
					let i = this.getIndexOf(t, e - t.size_left)
					if (((n += t.lf_left + i.index), i.index === 0)) {
						let s = this.getOffsetAt(n + 1, 1),
							a = r - s
						return new cn(n + 1, a + 1)
					}
					return new cn(n + 1, i.remainder + 1)
				} else if (
					((e -= t.size_left + t.piece.length), (n += t.lf_left + t.piece.lineFeedCnt), t.right === ue)
				) {
					let i = this.getOffsetAt(n + 1, 1),
						s = r - e - i
					return new cn(n + 1, s + 1)
				} else t = t.right
			return new cn(1, 1)
		}
		getValueInRange(e, t) {
			if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn) return ""
			let n = this.nodeAt2(e.startLineNumber, e.startColumn),
				r = this.nodeAt2(e.endLineNumber, e.endColumn),
				i = this.getValueInRange2(n, r)
			return t
				? t !== this._EOL || !this._EOLNormalized
					? i.replace(/\r\n|\r|\n/g, t)
					: t === this.getEOL() && this._EOLNormalized
						? i
						: i.replace(/\r\n|\r|\n/g, t)
				: i
		}
		getValueInRange2(e, t) {
			if (e.node === t.node) {
				let a = e.node,
					l = this._buffers[a.piece.bufferIndex].buffer,
					d = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start)
				return l.substring(d + e.remainder, d + t.remainder)
			}
			let n = e.node,
				r = this._buffers[n.piece.bufferIndex].buffer,
				i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start),
				s = r.substring(i + e.remainder, i + n.piece.length)
			for (n = n.next(); n !== ue; ) {
				let a = this._buffers[n.piece.bufferIndex].buffer,
					l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				if (n === t.node) {
					s += a.substring(l, l + t.remainder)
					break
				} else s += a.substr(l, n.piece.length)
				n = n.next()
			}
			return s
		}
		getLinesContent() {
			let e = [],
				t = 0,
				n = "",
				r = !1
			return (
				this.iterate(this.root, (i) => {
					if (i === ue) return !0
					let s = i.piece,
						a = s.length
					if (a === 0) return !0
					let l = this._buffers[s.bufferIndex].buffer,
						d = this._buffers[s.bufferIndex].lineStarts,
						c = s.start.line,
						u = s.end.line,
						m = d[c] + s.start.column
					if (r && (l.charCodeAt(m) === 10 && (m++, a--), (e[t++] = n), (n = ""), (r = !1), a === 0))
						return !0
					if (c === u)
						return (
							!this._EOLNormalized && l.charCodeAt(m + a - 1) === 13
								? ((r = !0), (n += l.substr(m, a - 1)))
								: (n += l.substr(m, a)),
							!0
						)
					;(n += this._EOLNormalized
						? l.substring(m, Math.max(m, d[c + 1] - this._EOLLength))
						: l.substring(m, d[c + 1]).replace(/(\r\n|\r|\n)$/, "")),
						(e[t++] = n)
					for (let f = c + 1; f < u; f++)
						(n = this._EOLNormalized
							? l.substring(d[f], d[f + 1] - this._EOLLength)
							: l.substring(d[f], d[f + 1]).replace(/(\r\n|\r|\n)$/, "")),
							(e[t++] = n)
					return (
						!this._EOLNormalized && l.charCodeAt(d[u] + s.end.column - 1) === 13
							? ((r = !0), s.end.column === 0 ? t-- : (n = l.substr(d[u], s.end.column - 1)))
							: (n = l.substr(d[u], s.end.column)),
						!0
					)
				}),
				r && ((e[t++] = n), (n = "")),
				(e[t++] = n),
				e
			)
		}
		getLength() {
			return this._length
		}
		getLineCount() {
			return this._lineCnt
		}
		getLineContent(e) {
			return this._lastVisitedLine.lineNumber === e
				? this._lastVisitedLine.value
				: ((this._lastVisitedLine.lineNumber = e),
					e === this._lineCnt
						? (this._lastVisitedLine.value = this.getLineRawContent(e))
						: this._EOLNormalized
							? (this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength))
							: (this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, "")),
					this._lastVisitedLine.value)
		}
		_getCharCode(e) {
			if (e.remainder === e.node.piece.length) {
				let t = e.node.next()
				if (!t) return 0
				let n = this._buffers[t.piece.bufferIndex],
					r = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start)
				return n.buffer.charCodeAt(r)
			} else {
				let t = this._buffers[e.node.piece.bufferIndex],
					r = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder
				return t.buffer.charCodeAt(r)
			}
		}
		getLineCharCode(e, t) {
			let n = this.nodeAt2(e, t + 1)
			return this._getCharCode(n)
		}
		getLineLength(e) {
			if (e === this.getLineCount()) {
				let t = this.getOffsetAt(e, 1)
				return this.getLength() - t
			}
			return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength
		}
		getCharCode(e) {
			let t = this.nodeAt(e)
			return this._getCharCode(t)
		}
		getNearestChunk(e) {
			let t = this.nodeAt(e)
			if (t.remainder === t.node.piece.length) {
				let n = t.node.next()
				if (!n || n === ue) return ""
				let r = this._buffers[n.piece.bufferIndex],
					i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				return r.buffer.substring(i, i + n.piece.length)
			} else {
				let n = this._buffers[t.node.piece.bufferIndex],
					r = this.offsetInBuffer(t.node.piece.bufferIndex, t.node.piece.start),
					i = r + t.remainder,
					s = r + t.node.piece.length
				return n.buffer.substring(i, s)
			}
		}
		findMatchesInNode(e, t, n, r, i, s, a, l, d, c, u) {
			let m = this._buffers[e.piece.bufferIndex],
				f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start),
				h = this.offsetInBuffer(e.piece.bufferIndex, i),
				g = this.offsetInBuffer(e.piece.bufferIndex, s),
				I,
				C = { line: 0, column: 0 },
				T,
				w
			t._wordSeparators
				? ((T = m.buffer.substring(h, g)), (w = (L) => L + h), t.reset(0))
				: ((T = m.buffer), (w = (L) => L), t.reset(h))
			do
				if (((I = t.next(T)), I)) {
					if (w(I.index) >= g) return c
					this.positionInBuffer(e, w(I.index) - f, C)
					let L = this.getLineFeedCnt(e.piece.bufferIndex, i, C),
						A = C.line === i.line ? C.column - i.column + r : C.column + 1,
						J = A + I[0].length
					if (((u[c++] = Mk(new Re(n + L, A, n + L, J), I, l)), w(I.index) + I[0].length >= g || c >= d))
						return c
				}
			while (I)
			return c
		}
		findMatchesLineByLine(e, t, n, r) {
			let i = [],
				s = 0,
				a = new Bx(t.wordSeparators, t.regex),
				l = this.nodeAt2(e.startLineNumber, e.startColumn)
			if (l === null) return []
			let d = this.nodeAt2(e.endLineNumber, e.endColumn)
			if (d === null) return []
			let c = this.positionInBuffer(l.node, l.remainder),
				u = this.positionInBuffer(d.node, d.remainder)
			if (l.node === d.node)
				return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, c, u, t, n, r, s, i), i
			let m = e.startLineNumber,
				f = l.node
			for (; f !== d.node; ) {
				let g = this.getLineFeedCnt(f.piece.bufferIndex, c, f.piece.end)
				if (g >= 1) {
					let C = this._buffers[f.piece.bufferIndex].lineStarts,
						T = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start),
						w = C[c.line + g],
						L = m === e.startLineNumber ? e.startColumn : 1
					if (
						((s = this.findMatchesInNode(f, a, m, L, c, this.positionInBuffer(f, w - T), t, n, r, s, i)),
						s >= r)
					)
						return i
					m += g
				}
				let I = m === e.startLineNumber ? e.startColumn - 1 : 0
				if (m === e.endLineNumber) {
					let C = this.getLineContent(m).substring(I, e.endColumn - 1)
					return (s = this._findMatchesInLine(t, a, C, e.endLineNumber, I, s, i, n, r)), i
				}
				if (((s = this._findMatchesInLine(t, a, this.getLineContent(m).substr(I), m, I, s, i, n, r)), s >= r))
					return i
				m++, (l = this.nodeAt2(m, 1)), (f = l.node), (c = this.positionInBuffer(l.node, l.remainder))
			}
			if (m === e.endLineNumber) {
				let g = m === e.startLineNumber ? e.startColumn - 1 : 0,
					I = this.getLineContent(m).substring(g, e.endColumn - 1)
				return (s = this._findMatchesInLine(t, a, I, e.endLineNumber, g, s, i, n, r)), i
			}
			let h = m === e.startLineNumber ? e.startColumn : 1
			return (s = this.findMatchesInNode(d.node, a, m, h, c, u, t, n, r, s, i)), i
		}
		_findMatchesInLine(e, t, n, r, i, s, a, l, d) {
			let c = e.wordSeparators
			if (!l && e.simpleSearch) {
				let m = e.simpleSearch,
					f = m.length,
					h = n.length,
					g = -f
				for (; (g = n.indexOf(m, g + f)) !== -1; )
					if (
						(!c || Fk(c, n, h, g, f)) &&
						((a[s++] = new Yl(new Re(r, g + 1 + i, r, g + 1 + f + i), null)), s >= d)
					)
						return s
				return s
			}
			let u
			t.reset(0)
			do
				if (
					((u = t.next(n)),
					u && ((a[s++] = Mk(new Re(r, u.index + 1 + i, r, u.index + 1 + u[0].length + i), u, l)), s >= d))
				)
					return s
			while (u)
			return s
		}
		insert(e, t, n = !1) {
			if (
				((this._EOLNormalized = this._EOLNormalized && n),
				(this._lastVisitedLine.lineNumber = 0),
				(this._lastVisitedLine.value = ""),
				this.root !== ue)
			) {
				let { node: r, remainder: i, nodeStartOffset: s } = this.nodeAt(e),
					a = r.piece,
					l = a.bufferIndex,
					d = this.positionInBuffer(r, i)
				if (
					r.piece.bufferIndex === 0 &&
					a.end.line === this._lastChangeBufferPos.line &&
					a.end.column === this._lastChangeBufferPos.column &&
					s + a.length === e &&
					t.length < js
				) {
					this.appendToNode(r, t), this.computeBufferMetadata()
					return
				}
				if (s === e) this.insertContentToNodeLeft(t, r), this._searchCache.validate(e)
				else if (s + r.piece.length > e) {
					let c = [],
						u = new tr(
							a.bufferIndex,
							d,
							a.end,
							this.getLineFeedCnt(a.bufferIndex, d, a.end),
							this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, d),
						)
					if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(r, i) === 10) {
						let g = { line: u.start.line + 1, column: 0 }
						;(u = new tr(
							u.bufferIndex,
							g,
							u.end,
							this.getLineFeedCnt(u.bufferIndex, g, u.end),
							u.length - 1,
						)),
							(t += `
`)
					}
					if (this.shouldCheckCRLF() && this.startWithLF(t))
						if (this.nodeCharCodeAt(r, i - 1) === 13) {
							let g = this.positionInBuffer(r, i - 1)
							this.deleteNodeTail(r, g), (t = "\r" + t), r.piece.length === 0 && c.push(r)
						} else this.deleteNodeTail(r, d)
					else this.deleteNodeTail(r, d)
					let m = this.createNewPieces(t)
					u.length > 0 && this.rbInsertRight(r, u)
					let f = r
					for (let h = 0; h < m.length; h++) f = this.rbInsertRight(f, m[h])
					this.deleteNodes(c)
				} else this.insertContentToNodeRight(t, r)
			} else {
				let r = this.createNewPieces(t),
					i = this.rbInsertLeft(null, r[0])
				for (let s = 1; s < r.length; s++) i = this.rbInsertRight(i, r[s])
			}
			this.computeBufferMetadata()
		}
		delete(e, t) {
			if (
				((this._lastVisitedLine.lineNumber = 0), (this._lastVisitedLine.value = ""), t <= 0 || this.root === ue)
			)
				return
			let n = this.nodeAt(e),
				r = this.nodeAt(e + t),
				i = n.node,
				s = r.node
			if (i === s) {
				let m = this.positionInBuffer(i, n.remainder),
					f = this.positionInBuffer(i, r.remainder)
				if (n.nodeStartOffset === e) {
					if (t === i.piece.length) {
						let h = i.next()
						_h(this, i), this.validateCRLFWithPrevNode(h), this.computeBufferMetadata()
						return
					}
					this.deleteNodeHead(i, f),
						this._searchCache.validate(e),
						this.validateCRLFWithPrevNode(i),
						this.computeBufferMetadata()
					return
				}
				if (n.nodeStartOffset + i.piece.length === e + t) {
					this.deleteNodeTail(i, m), this.validateCRLFWithNextNode(i), this.computeBufferMetadata()
					return
				}
				this.shrinkNode(i, m, f), this.computeBufferMetadata()
				return
			}
			let a = [],
				l = this.positionInBuffer(i, n.remainder)
			this.deleteNodeTail(i, l), this._searchCache.validate(e), i.piece.length === 0 && a.push(i)
			let d = this.positionInBuffer(s, r.remainder)
			this.deleteNodeHead(s, d), s.piece.length === 0 && a.push(s)
			let c = i.next()
			for (let m = c; m !== ue && m !== s; m = m.next()) a.push(m)
			let u = i.piece.length === 0 ? i.prev() : i
			this.deleteNodes(a), this.validateCRLFWithNextNode(u), this.computeBufferMetadata()
		}
		insertContentToNodeLeft(e, t) {
			let n = []
			if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
				let s = t.piece,
					a = { line: s.start.line + 1, column: 0 },
					l = new tr(s.bufferIndex, a, s.end, this.getLineFeedCnt(s.bufferIndex, a, s.end), s.length - 1)
				;(t.piece = l),
					(e += `
`),
					Ui(this, t, -1, -1),
					t.piece.length === 0 && n.push(t)
			}
			let r = this.createNewPieces(e),
				i = this.rbInsertLeft(t, r[r.length - 1])
			for (let s = r.length - 2; s >= 0; s--) i = this.rbInsertLeft(i, r[s])
			this.validateCRLFWithPrevNode(i), this.deleteNodes(n)
		}
		insertContentToNodeRight(e, t) {
			this.adjustCarriageReturnFromNext(e, t) &&
				(e += `
`)
			let n = this.createNewPieces(e),
				r = this.rbInsertRight(t, n[0]),
				i = r
			for (let s = 1; s < n.length; s++) i = this.rbInsertRight(i, n[s])
			this.validateCRLFWithPrevNode(r)
		}
		positionInBuffer(e, t, n) {
			let r = e.piece,
				i = e.piece.bufferIndex,
				s = this._buffers[i].lineStarts,
				l = s[r.start.line] + r.start.column + t,
				d = r.start.line,
				c = r.end.line,
				u = 0,
				m = 0,
				f = 0
			for (; d <= c && ((u = (d + (c - d) / 2) | 0), (f = s[u]), u !== c); )
				if (((m = s[u + 1]), l < f)) c = u - 1
				else if (l >= m) d = u + 1
				else break
			return n ? ((n.line = u), (n.column = l - f), null) : { line: u, column: l - f }
		}
		getLineFeedCnt(e, t, n) {
			if (n.column === 0) return n.line - t.line
			let r = this._buffers[e].lineStarts
			if (n.line === r.length - 1) return n.line - t.line
			let i = r[n.line + 1],
				s = r[n.line] + n.column
			if (i > s + 1) return n.line - t.line
			let a = s - 1
			return this._buffers[e].buffer.charCodeAt(a) === 13 ? n.line - t.line + 1 : n.line - t.line
		}
		offsetInBuffer(e, t) {
			return this._buffers[e].lineStarts[t.line] + t.column
		}
		deleteNodes(e) {
			for (let t = 0; t < e.length; t++) _h(this, e[t])
		}
		createNewPieces(e) {
			if (e.length > js) {
				let c = []
				for (; e.length > js; ) {
					let m = e.charCodeAt(js - 1),
						f
					m === 13 || (m >= 55296 && m <= 56319)
						? ((f = e.substring(0, js - 1)), (e = e.substring(js - 1)))
						: ((f = e.substring(0, js)), (e = e.substring(js)))
					let h = Hi(f)
					c.push(
						new tr(
							this._buffers.length,
							{ line: 0, column: 0 },
							{ line: h.length - 1, column: f.length - h[h.length - 1] },
							h.length - 1,
							f.length,
						),
					),
						this._buffers.push(new Wi(f, h))
				}
				let u = Hi(e)
				return (
					c.push(
						new tr(
							this._buffers.length,
							{ line: 0, column: 0 },
							{ line: u.length - 1, column: e.length - u[u.length - 1] },
							u.length - 1,
							e.length,
						),
					),
					this._buffers.push(new Wi(e, u)),
					c
				)
			}
			let t = this._buffers[0].buffer.length,
				n = Hi(e, !1),
				r = this._lastChangeBufferPos
			if (
				this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t &&
				t !== 0 &&
				this.startWithLF(e) &&
				this.endWithCR(this._buffers[0].buffer)
			) {
				;(this._lastChangeBufferPos = {
					line: this._lastChangeBufferPos.line,
					column: this._lastChangeBufferPos.column + 1,
				}),
					(r = this._lastChangeBufferPos)
				for (let c = 0; c < n.length; c++) n[c] += t + 1
				;(this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1))),
					(this._buffers[0].buffer += "_" + e),
					(t += 1)
			} else {
				if (t !== 0) for (let c = 0; c < n.length; c++) n[c] += t
				;(this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1))),
					(this._buffers[0].buffer += e)
			}
			let i = this._buffers[0].buffer.length,
				s = this._buffers[0].lineStarts.length - 1,
				a = i - this._buffers[0].lineStarts[s],
				l = { line: s, column: a },
				d = new tr(0, r, l, this.getLineFeedCnt(0, r, l), i - t)
			return (this._lastChangeBufferPos = l), [d]
		}
		getLinesRawContent() {
			return this.getContentOfSubTree(this.root)
		}
		getLineRawContent(e, t = 0) {
			let n = this.root,
				r = "",
				i = this._searchCache.get2(e)
			if (i) {
				n = i.node
				let s = this.getAccumulatedValue(n, e - i.nodeStartLineNumber - 1),
					a = this._buffers[n.piece.bufferIndex].buffer,
					l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				if (i.nodeStartLineNumber + n.piece.lineFeedCnt === e) r = a.substring(l + s, l + n.piece.length)
				else {
					let d = this.getAccumulatedValue(n, e - i.nodeStartLineNumber)
					return a.substring(l + s, l + d - t)
				}
			} else {
				let s = 0,
					a = e
				for (; n !== ue; )
					if (n.left !== ue && n.lf_left >= e - 1) n = n.left
					else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
						let l = this.getAccumulatedValue(n, e - n.lf_left - 2),
							d = this.getAccumulatedValue(n, e - n.lf_left - 1),
							c = this._buffers[n.piece.bufferIndex].buffer,
							u = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
						return (
							(s += n.size_left),
							this._searchCache.set({
								node: n,
								nodeStartOffset: s,
								nodeStartLineNumber: a - (e - 1 - n.lf_left),
							}),
							c.substring(u + l, u + d - t)
						)
					} else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
						let l = this.getAccumulatedValue(n, e - n.lf_left - 2),
							d = this._buffers[n.piece.bufferIndex].buffer,
							c = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
						r = d.substring(c + l, c + n.piece.length)
						break
					} else (e -= n.lf_left + n.piece.lineFeedCnt), (s += n.size_left + n.piece.length), (n = n.right)
			}
			for (n = n.next(); n !== ue; ) {
				let s = this._buffers[n.piece.bufferIndex].buffer
				if (n.piece.lineFeedCnt > 0) {
					let a = this.getAccumulatedValue(n, 0),
						l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
					return (r += s.substring(l, l + a - t)), r
				} else {
					let a = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
					r += s.substr(a, n.piece.length)
				}
				n = n.next()
			}
			return r
		}
		computeBufferMetadata() {
			let e = this.root,
				t = 1,
				n = 0
			for (; e !== ue; )
				(t += e.lf_left + e.piece.lineFeedCnt), (n += e.size_left + e.piece.length), (e = e.right)
			;(this._lineCnt = t), (this._length = n), this._searchCache.validate(this._length)
		}
		getIndexOf(e, t) {
			let n = e.piece,
				r = this.positionInBuffer(e, t),
				i = r.line - n.start.line
			if (this.offsetInBuffer(n.bufferIndex, n.end) - this.offsetInBuffer(n.bufferIndex, n.start) === t) {
				let s = this.getLineFeedCnt(e.piece.bufferIndex, n.start, r)
				if (s !== i) return { index: s, remainder: 0 }
			}
			return { index: i, remainder: r.column }
		}
		getAccumulatedValue(e, t) {
			if (t < 0) return 0
			let n = e.piece,
				r = this._buffers[n.bufferIndex].lineStarts,
				i = n.start.line + t + 1
			return i > n.end.line
				? r[n.end.line] + n.end.column - r[n.start.line] - n.start.column
				: r[i] - r[n.start.line] - n.start.column
		}
		deleteNodeTail(e, t) {
			let n = e.piece,
				r = n.lineFeedCnt,
				i = this.offsetInBuffer(n.bufferIndex, n.end),
				s = t,
				a = this.offsetInBuffer(n.bufferIndex, s),
				l = this.getLineFeedCnt(n.bufferIndex, n.start, s),
				d = l - r,
				c = a - i,
				u = n.length + c
			;(e.piece = new tr(n.bufferIndex, n.start, s, l, u)), Ui(this, e, c, d)
		}
		deleteNodeHead(e, t) {
			let n = e.piece,
				r = n.lineFeedCnt,
				i = this.offsetInBuffer(n.bufferIndex, n.start),
				s = t,
				a = this.getLineFeedCnt(n.bufferIndex, s, n.end),
				l = this.offsetInBuffer(n.bufferIndex, s),
				d = a - r,
				c = i - l,
				u = n.length + c
			;(e.piece = new tr(n.bufferIndex, s, n.end, a, u)), Ui(this, e, c, d)
		}
		shrinkNode(e, t, n) {
			let r = e.piece,
				i = r.start,
				s = r.end,
				a = r.length,
				l = r.lineFeedCnt,
				d = t,
				c = this.getLineFeedCnt(r.bufferIndex, r.start, d),
				u = this.offsetInBuffer(r.bufferIndex, t) - this.offsetInBuffer(r.bufferIndex, i)
			;(e.piece = new tr(r.bufferIndex, r.start, d, c, u)), Ui(this, e, u - a, c - l)
			let m = new tr(
					r.bufferIndex,
					n,
					s,
					this.getLineFeedCnt(r.bufferIndex, n, s),
					this.offsetInBuffer(r.bufferIndex, s) - this.offsetInBuffer(r.bufferIndex, n),
				),
				f = this.rbInsertRight(e, m)
			this.validateCRLFWithPrevNode(f)
		}
		appendToNode(e, t) {
			this.adjustCarriageReturnFromNext(t, e) &&
				(t += `
`)
			let n = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e),
				r = this._buffers[0].buffer.length
			this._buffers[0].buffer += t
			let i = Hi(t, !1)
			for (let f = 0; f < i.length; f++) i[f] += r
			if (n) {
				let f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2]
				this._buffers[0].lineStarts.pop(),
					(this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: r - f })
			}
			this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1))
			let s = this._buffers[0].lineStarts.length - 1,
				a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[s],
				l = { line: s, column: a },
				d = e.piece.length + t.length,
				c = e.piece.lineFeedCnt,
				u = this.getLineFeedCnt(0, e.piece.start, l),
				m = u - c
			;(e.piece = new tr(e.piece.bufferIndex, e.piece.start, l, u, d)),
				(this._lastChangeBufferPos = l),
				Ui(this, e, t.length, m)
		}
		nodeAt(e) {
			let t = this.root,
				n = this._searchCache.get(e)
			if (n) return { node: n.node, nodeStartOffset: n.nodeStartOffset, remainder: e - n.nodeStartOffset }
			let r = 0
			for (; t !== ue; )
				if (t.size_left > e) t = t.left
				else if (t.size_left + t.piece.length >= e) {
					r += t.size_left
					let i = { node: t, remainder: e - t.size_left, nodeStartOffset: r }
					return this._searchCache.set(i), i
				} else (e -= t.size_left + t.piece.length), (r += t.size_left + t.piece.length), (t = t.right)
			return null
		}
		nodeAt2(e, t) {
			let n = this.root,
				r = 0
			for (; n !== ue; )
				if (n.left !== ue && n.lf_left >= e - 1) n = n.left
				else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
					let i = this.getAccumulatedValue(n, e - n.lf_left - 2),
						s = this.getAccumulatedValue(n, e - n.lf_left - 1)
					return (r += n.size_left), { node: n, remainder: Math.min(i + t - 1, s), nodeStartOffset: r }
				} else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
					let i = this.getAccumulatedValue(n, e - n.lf_left - 2)
					if (i + t - 1 <= n.piece.length) return { node: n, remainder: i + t - 1, nodeStartOffset: r }
					t -= n.piece.length - i
					break
				} else (e -= n.lf_left + n.piece.lineFeedCnt), (r += n.size_left + n.piece.length), (n = n.right)
			for (n = n.next(); n !== ue; ) {
				if (n.piece.lineFeedCnt > 0) {
					let i = this.getAccumulatedValue(n, 0),
						s = this.offsetOfNode(n)
					return { node: n, remainder: Math.min(t - 1, i), nodeStartOffset: s }
				} else if (n.piece.length >= t - 1) {
					let i = this.offsetOfNode(n)
					return { node: n, remainder: t - 1, nodeStartOffset: i }
				} else t -= n.piece.length
				n = n.next()
			}
			return null
		}
		nodeCharCodeAt(e, t) {
			if (e.piece.lineFeedCnt < 1) return -1
			let n = this._buffers[e.piece.bufferIndex],
				r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t
			return n.buffer.charCodeAt(r)
		}
		offsetOfNode(e) {
			if (!e) return 0
			let t = e.size_left
			for (; e !== this.root; )
				e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), (e = e.parent)
			return t
		}
		shouldCheckCRLF() {
			return !(
				this._EOLNormalized &&
				this._EOL ===
					`
`
			)
		}
		startWithLF(e) {
			if (typeof e == "string") return e.charCodeAt(0) === 10
			if (e === ue || e.piece.lineFeedCnt === 0) return !1
			let t = e.piece,
				n = this._buffers[t.bufferIndex].lineStarts,
				r = t.start.line,
				i = n[r] + t.start.column
			return r === n.length - 1 || n[r + 1] > i + 1
				? !1
				: this._buffers[t.bufferIndex].buffer.charCodeAt(i) === 10
		}
		endWithCR(e) {
			return typeof e == "string"
				? e.charCodeAt(e.length - 1) === 13
				: e === ue || e.piece.lineFeedCnt === 0
					? !1
					: this.nodeCharCodeAt(e, e.piece.length - 1) === 13
		}
		validateCRLFWithPrevNode(e) {
			if (this.shouldCheckCRLF() && this.startWithLF(e)) {
				let t = e.prev()
				this.endWithCR(t) && this.fixCRLF(t, e)
			}
		}
		validateCRLFWithNextNode(e) {
			if (this.shouldCheckCRLF() && this.endWithCR(e)) {
				let t = e.next()
				this.startWithLF(t) && this.fixCRLF(e, t)
			}
		}
		fixCRLF(e, t) {
			let n = [],
				r = this._buffers[e.piece.bufferIndex].lineStarts,
				i
			e.piece.end.column === 0
				? (i = { line: e.piece.end.line - 1, column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1 })
				: (i = { line: e.piece.end.line, column: e.piece.end.column - 1 })
			let s = e.piece.length - 1,
				a = e.piece.lineFeedCnt - 1
			;(e.piece = new tr(e.piece.bufferIndex, e.piece.start, i, a, s)),
				Ui(this, e, -1, -1),
				e.piece.length === 0 && n.push(e)
			let l = { line: t.piece.start.line + 1, column: 0 },
				d = t.piece.length - 1,
				c = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end)
			;(t.piece = new tr(t.piece.bufferIndex, l, t.piece.end, c, d)),
				Ui(this, t, -1, -1),
				t.piece.length === 0 && n.push(t)
			let u = this.createNewPieces(`\r
`)
			this.rbInsertRight(e, u[0])
			for (let m = 0; m < n.length; m++) _h(this, n[m])
		}
		adjustCarriageReturnFromNext(e, t) {
			if (this.shouldCheckCRLF() && this.endWithCR(e)) {
				let n = t.next()
				if (this.startWithLF(n)) {
					if (
						((e += `
`),
						n.piece.length === 1)
					)
						_h(this, n)
					else {
						let r = n.piece,
							i = { line: r.start.line + 1, column: 0 },
							s = r.length - 1,
							a = this.getLineFeedCnt(r.bufferIndex, i, r.end)
						;(n.piece = new tr(r.bufferIndex, i, r.end, a, s)), Ui(this, n, -1, -1)
					}
					return !0
				}
			}
			return !1
		}
		iterate(e, t) {
			if (e === ue) return t(ue)
			let n = this.iterate(e.left, t)
			return n && t(e) && this.iterate(e.right, t)
		}
		getNodeContent(e) {
			if (e === ue) return ""
			let t = this._buffers[e.piece.bufferIndex],
				n = e.piece,
				r = this.offsetInBuffer(n.bufferIndex, n.start),
				i = this.offsetInBuffer(n.bufferIndex, n.end)
			return t.buffer.substring(r, i)
		}
		getPieceContent(e) {
			let t = this._buffers[e.bufferIndex],
				n = this.offsetInBuffer(e.bufferIndex, e.start),
				r = this.offsetInBuffer(e.bufferIndex, e.end)
			return t.buffer.substring(n, r)
		}
		rbInsertRight(e, t) {
			let n = new Sm(t, 1)
			if (((n.left = ue), (n.right = ue), (n.parent = ue), (n.size_left = 0), (n.lf_left = 0), this.root === ue))
				(this.root = n), (n.color = 0)
			else if (e.right === ue) (e.right = n), (n.parent = e)
			else {
				let i = kS(e.right)
				;(i.left = n), (n.parent = i)
			}
			return b1(this, n), n
		}
		rbInsertLeft(e, t) {
			let n = new Sm(t, 1)
			if (((n.left = ue), (n.right = ue), (n.parent = ue), (n.size_left = 0), (n.lf_left = 0), this.root === ue))
				(this.root = n), (n.color = 0)
			else if (e.left === ue) (e.left = n), (n.parent = e)
			else {
				let r = g1(e.left)
				;(r.right = n), (n.parent = r)
			}
			return b1(this, n), n
		}
		getContentOfSubTree(e) {
			let t = ""
			return this.iterate(e, (n) => ((t += this.getNodeContent(n)), !0)), t
		}
	}
function AS(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0
	for (let i = 0, s = o.length; i < s; i++) {
		let a = o.charCodeAt(i)
		a === 13
			? (e === 0 && (t = i),
				e++,
				i + 1 < s && o.charCodeAt(i + 1) === 10 ? ((r |= 2), i++) : (r |= 3),
				(n = i + 1))
			: a === 10 && ((r |= 1), e === 0 && (t = i), e++, (n = i + 1))
	}
	return e === 0 && (t = o.length), [e, t, o.length - n, r]
}
var C1
function bB() {
	return C1 || (C1 = new TextDecoder("UTF-16LE")), C1
}
function HN(o, e, t) {
	let n = new Uint16Array(o.buffer, e, t)
	return t > 0 && (n[0] === 65279 || n[0] === 65534) ? yB(o, e, t) : bB().decode(n)
}
function yB(o, e, t) {
	let n = [],
		r = 0
	for (let i = 0; i < t; i++) {
		let s = GA(o, e)
		;(e += 2), (n[r++] = String.fromCharCode(s))
	}
	return n.join("")
}
function OS(o) {
	return o.replace(/\n/g, "\\n").replace(/\r/g, "\\r")
}
var LS = class o {
	constructor(e, t, n, r) {
		this.oldPosition = e
		this.oldText = t
		this.newPosition = n
		this.newText = r
	}
	get oldLength() {
		return this.oldText.length
	}
	get oldEnd() {
		return this.oldPosition + this.oldText.length
	}
	get newLength() {
		return this.newText.length
	}
	get newEnd() {
		return this.newPosition + this.newText.length
	}
	toString() {
		return this.oldText.length === 0
			? `(insert@${this.oldPosition} "${OS(this.newText)}")`
			: this.newText.length === 0
				? `(delete@${this.oldPosition} "${OS(this.oldText)}")`
				: `(replace@${this.oldPosition} "${OS(this.oldText)}" with "${OS(this.newText)}")`
	}
	static _writeStringSize(e) {
		return 4 + 2 * e.length
	}
	static _writeString(e, t, n) {
		let r = t.length
		vf(e, r, n), (n += 4)
		for (let i = 0; i < r; i++) QA(e, t.charCodeAt(i), n), (n += 2)
		return n
	}
	static _readString(e, t) {
		let n = hf(e, t)
		return (t += 4), HN(e, t, n)
	}
	writeSize() {
		return 8 + o._writeStringSize(this.oldText) + o._writeStringSize(this.newText)
	}
	write(e, t) {
		return (
			vf(e, this.oldPosition, t),
			(t += 4),
			vf(e, this.newPosition, t),
			(t += 4),
			(t = o._writeString(e, this.oldText, t)),
			(t = o._writeString(e, this.newText, t)),
			t
		)
	}
	static read(e, t, n) {
		let r = hf(e, t)
		t += 4
		let i = hf(e, t)
		t += 4
		let s = o._readString(e, t)
		t += o._writeStringSize(s)
		let a = o._readString(e, t)
		return (t += o._writeStringSize(a)), n.push(new o(r, s, i, a)), t
	}
}
var MS = class o extends $ {
	constructor(t, n, r, i, s, a, l) {
		super()
		this._onDidChangeContent = this._register(new E())
		this.onDidChangeContent = this._onDidChangeContent.event
		;(this._BOM = n),
			(this._mightContainNonBasicASCII = !a),
			(this._mightContainRTL = i),
			(this._mightContainUnusualLineTerminators = s),
			(this._pieceTree = new RS(t, r, l))
	}
	equals(t) {
		return !(t instanceof o) || this._BOM !== t._BOM || this.getEOL() !== t.getEOL()
			? !1
			: this._pieceTree.equal(t._pieceTree)
	}
	mightContainRTL() {
		return this._mightContainRTL
	}
	mightContainUnusualLineTerminators() {
		return this._mightContainUnusualLineTerminators
	}
	resetMightContainUnusualLineTerminators() {
		this._mightContainUnusualLineTerminators = !1
	}
	mightContainNonBasicASCII() {
		return this._mightContainNonBasicASCII
	}
	getBOM() {
		return this._BOM
	}
	getEOL() {
		return this._pieceTree.getEOL()
	}
	createSnapshot(t) {
		return this._pieceTree.createSnapshot(t ? this._BOM : "")
	}
	getOffsetAt(t, n) {
		return this._pieceTree.getOffsetAt(t, n)
	}
	getPositionAt(t) {
		return this._pieceTree.getPositionAt(t)
	}
	getRangeAt(t, n) {
		let r = t + n,
			i = this.getPositionAt(t),
			s = this.getPositionAt(r)
		return new Re(i.lineNumber, i.column, s.lineNumber, s.column)
	}
	getValueInRange(t, n = 0) {
		if (t.isEmpty()) return ""
		let r = this._getEndOfLine(n)
		return this._pieceTree.getValueInRange(t, r)
	}
	getValueLengthInRange(t, n = 0) {
		if (t.isEmpty()) return 0
		if (t.startLineNumber === t.endLineNumber) return t.endColumn - t.startColumn
		let r = this.getOffsetAt(t.startLineNumber, t.startColumn),
			i = this.getOffsetAt(t.endLineNumber, t.endColumn),
			s = 0,
			a = this._getEndOfLine(n),
			l = this.getEOL()
		if (a.length !== l.length) {
			let d = a.length - l.length,
				c = t.endLineNumber - t.startLineNumber
			s = d * c
		}
		return i - r + s
	}
	getCharacterCountInRange(t, n = 0) {
		if (this._mightContainNonBasicASCII) {
			let r = 0,
				i = t.startLineNumber,
				s = t.endLineNumber
			for (let a = i; a <= s; a++) {
				let l = this.getLineContent(a),
					d = a === i ? t.startColumn - 1 : 0,
					c = a === s ? t.endColumn - 1 : l.length
				for (let u = d; u < c; u++) kl(l.charCodeAt(u)) ? ((r = r + 1), (u = u + 1)) : (r = r + 1)
			}
			return (r += this._getEndOfLine(n).length * (s - i)), r
		}
		return this.getValueLengthInRange(t, n)
	}
	getNearestChunk(t) {
		return this._pieceTree.getNearestChunk(t)
	}
	getLength() {
		return this._pieceTree.getLength()
	}
	getLineCount() {
		return this._pieceTree.getLineCount()
	}
	getLinesContent() {
		return this._pieceTree.getLinesContent()
	}
	getLineContent(t) {
		return this._pieceTree.getLineContent(t)
	}
	getLineCharCode(t, n) {
		return this._pieceTree.getLineCharCode(t, n)
	}
	getCharCode(t) {
		return this._pieceTree.getCharCode(t)
	}
	getLineLength(t) {
		return this._pieceTree.getLineLength(t)
	}
	getLineMinColumn(t) {
		return 1
	}
	getLineMaxColumn(t) {
		return this.getLineLength(t) + 1
	}
	getLineFirstNonWhitespaceColumn(t) {
		let n = xv(this.getLineContent(t))
		return n === -1 ? 0 : n + 1
	}
	getLineLastNonWhitespaceColumn(t) {
		let n = vA(this.getLineContent(t))
		return n === -1 ? 0 : n + 2
	}
	_getEndOfLine(t) {
		switch (t) {
			case 1:
				return `
`
			case 2:
				return `\r
`
			case 0:
				return this.getEOL()
			default:
				throw new Error("Unknown EOL preference")
		}
	}
	setEOL(t) {
		this._pieceTree.setEOL(t)
	}
	applyEdits(t, n, r) {
		let i = this._mightContainRTL,
			s = this._mightContainUnusualLineTerminators,
			a = this._mightContainNonBasicASCII,
			l = !0,
			d = []
		for (let I = 0; I < t.length; I++) {
			let C = t[I]
			l && C._isTracked && (l = !1)
			let T = C.range
			if (C.text) {
				let ne = !0
				a || ((ne = !yA(C.text)), (a = ne)), !i && ne && (i = Ev(C.text)), !s && ne && (s = wv(C.text))
			}
			let w = "",
				L = 0,
				A = 0,
				J = 0
			if (C.text) {
				let ne
				;[L, A, J, ne] = AS(C.text)
				let oe = this.getEOL(),
					Y =
						oe ===
						`\r
`
							? 2
							: 1
				ne === 0 || ne === Y ? (w = C.text) : (w = C.text.replace(/\r\n|\r|\n/g, oe))
			}
			d[I] = {
				sortIndex: I,
				identifier: C.identifier || null,
				range: T,
				rangeOffset: this.getOffsetAt(T.startLineNumber, T.startColumn),
				rangeLength: this.getValueLengthInRange(T),
				text: w,
				eolCount: L,
				firstLineLength: A,
				lastLineLength: J,
				forceMoveMarkers: !!C.forceMoveMarkers,
				isAutoWhitespaceEdit: C.isAutoWhitespaceEdit || !1,
			}
		}
		d.sort(o._sortOpsAscending)
		let c = !1
		for (let I = 0, C = d.length - 1; I < C; I++) {
			let T = d[I].range.getEndPosition(),
				w = d[I + 1].range.getStartPosition()
			if (w.isBeforeOrEqual(T)) {
				if (w.isBefore(T)) throw new Error("Overlapping ranges are not allowed!")
				c = !0
			}
		}
		l && (d = this._reduceOperations(d))
		let u = r || n ? o._getInverseEditRanges(d) : [],
			m = []
		if (n)
			for (let I = 0; I < d.length; I++) {
				let C = d[I],
					T = u[I]
				if (C.isAutoWhitespaceEdit && C.range.isEmpty())
					for (let w = T.startLineNumber; w <= T.endLineNumber; w++) {
						let L = ""
						;(w === T.startLineNumber &&
							((L = this.getLineContent(C.range.startLineNumber)), xv(L) !== -1)) ||
							m.push({ lineNumber: w, oldContent: L })
					}
			}
		let f = null
		if (r) {
			let I = 0
			f = []
			for (let C = 0; C < d.length; C++) {
				let T = d[C],
					w = u[C],
					L = this.getValueInRange(T.range),
					A = T.rangeOffset + I
				;(I += T.text.length - L.length),
					(f[C] = {
						sortIndex: T.sortIndex,
						identifier: T.identifier,
						range: w,
						text: L,
						textChange: new LS(T.rangeOffset, L, A, T.text),
					})
			}
			c || f.sort((C, T) => C.sortIndex - T.sortIndex)
		}
		;(this._mightContainRTL = i),
			(this._mightContainUnusualLineTerminators = s),
			(this._mightContainNonBasicASCII = a)
		let h = this._doApplyEdits(d),
			g = null
		if (n && m.length > 0) {
			m.sort((I, C) => C.lineNumber - I.lineNumber), (g = [])
			for (let I = 0, C = m.length; I < C; I++) {
				let T = m[I].lineNumber
				if (I > 0 && m[I - 1].lineNumber === T) continue
				let w = m[I].oldContent,
					L = this.getLineContent(T)
				L.length === 0 || L === w || xv(L) !== -1 || g.push(T)
			}
		}
		return this._onDidChangeContent.fire(), new Rb(f, h, g)
	}
	_reduceOperations(t) {
		return t.length < 1e3 ? t : [this._toSingleEditOperation(t)]
	}
	_toSingleEditOperation(t) {
		let n = !1,
			r = t[0].range,
			i = t[t.length - 1].range,
			s = new Re(r.startLineNumber, r.startColumn, i.endLineNumber, i.endColumn),
			a = r.startLineNumber,
			l = r.startColumn,
			d = []
		for (let h = 0, g = t.length; h < g; h++) {
			let I = t[h],
				C = I.range
			;(n = n || I.forceMoveMarkers),
				d.push(this.getValueInRange(new Re(a, l, C.startLineNumber, C.startColumn))),
				I.text.length > 0 && d.push(I.text),
				(a = C.endLineNumber),
				(l = C.endColumn)
		}
		let c = d.join(""),
			[u, m, f] = AS(c)
		return {
			sortIndex: 0,
			identifier: t[0].identifier,
			range: s,
			rangeOffset: this.getOffsetAt(s.startLineNumber, s.startColumn),
			rangeLength: this.getValueLengthInRange(s, 0),
			text: c,
			eolCount: u,
			firstLineLength: m,
			lastLineLength: f,
			forceMoveMarkers: n,
			isAutoWhitespaceEdit: !1,
		}
	}
	_doApplyEdits(t) {
		t.sort(o._sortOpsDescending)
		let n = []
		for (let r = 0; r < t.length; r++) {
			let i = t[r],
				s = i.range.startLineNumber,
				a = i.range.startColumn,
				l = i.range.endLineNumber,
				d = i.range.endColumn
			if (s === l && a === d && i.text.length === 0) continue
			i.text
				? (this._pieceTree.delete(i.rangeOffset, i.rangeLength),
					this._pieceTree.insert(i.rangeOffset, i.text, !0))
				: this._pieceTree.delete(i.rangeOffset, i.rangeLength)
			let c = new Re(s, a, l, d)
			n.push({
				range: c,
				rangeLength: i.rangeLength,
				text: i.text,
				rangeOffset: i.rangeOffset,
				forceMoveMarkers: i.forceMoveMarkers,
			})
		}
		return n
	}
	findMatchesLineByLine(t, n, r, i) {
		return this._pieceTree.findMatchesLineByLine(t, n, r, i)
	}
	getPieceTree() {
		return this._pieceTree
	}
	static _getInverseEditRange(t, n) {
		let r = t.startLineNumber,
			i = t.startColumn,
			[s, a, l] = AS(n),
			d
		if (n.length > 0) {
			let c = s + 1
			c === 1 ? (d = new Re(r, i, r, i + a)) : (d = new Re(r, i, r + c - 1, l + 1))
		} else d = new Re(r, i, r, i)
		return d
	}
	static _getInverseEditRanges(t) {
		let n = [],
			r = 0,
			i = 0,
			s = null
		for (let a = 0, l = t.length; a < l; a++) {
			let d = t[a],
				c,
				u
			s
				? s.range.endLineNumber === d.range.startLineNumber
					? ((c = r), (u = i + (d.range.startColumn - s.range.endColumn)))
					: ((c = r + (d.range.startLineNumber - s.range.endLineNumber)), (u = d.range.startColumn))
				: ((c = d.range.startLineNumber), (u = d.range.startColumn))
			let m
			if (d.text.length > 0) {
				let f = d.eolCount + 1
				f === 1
					? (m = new Re(c, u, c, u + d.firstLineLength))
					: (m = new Re(c, u, c + f - 1, d.lastLineLength + 1))
			} else m = new Re(c, u, c, u)
			;(r = m.endLineNumber), (i = m.endColumn), n.push(m), (s = d)
		}
		return n
	}
	static _sortOpsAscending(t, n) {
		let r = Re.compareRangesUsingEnds(t.range, n.range)
		return r === 0 ? t.sortIndex - n.sortIndex : r
	}
	static _sortOpsDescending(t, n) {
		let r = Re.compareRangesUsingEnds(t.range, n.range)
		return r === 0 ? n.sortIndex - t.sortIndex : -r
	}
}
var S1 = class {
		constructor(e, t, n, r, i, s, a, l, d) {
			this._chunks = e
			this._bom = t
			this._cr = n
			this._lf = r
			this._crlf = i
			this._containsRTL = s
			this._containsUnusualLineTerminators = a
			this._isBasicASCII = l
			this._normalizeEOL = d
		}
		_getEOL(e) {
			let t = this._cr + this._lf + this._crlf,
				n = this._cr + this._crlf
			return t === 0
				? e === 1
					? `
`
					: `\r
`
				: n > t / 2
					? `\r
`
					: `
`
		}
		create(e) {
			let t = this._getEOL(e),
				n = this._chunks
			if (
				this._normalizeEOL &&
				((t ===
					`\r
` &&
					(this._cr > 0 || this._lf > 0)) ||
					(t ===
						`
` &&
						(this._cr > 0 || this._crlf > 0)))
			)
				for (let i = 0, s = n.length; i < s; i++) {
					let a = n[i].buffer.replace(/\r\n|\r|\n/g, t),
						l = Hi(a)
					n[i] = new Wi(a, l)
				}
			let r = new MS(
				n,
				this._bom,
				t,
				this._containsRTL,
				this._containsUnusualLineTerminators,
				this._isBasicASCII,
				this._normalizeEOL,
			)
			return { textBuffer: r, disposable: r }
		}
		getFirstLineText(e) {
			return this._chunks[0].buffer.substr(0, e).split(/\r\n|\r|\n/)[0]
		}
	},
	Dh = class {
		constructor() {
			;(this.chunks = []),
				(this.BOM = ""),
				(this._hasPreviousChar = !1),
				(this._previousChar = 0),
				(this._tmpLineStarts = []),
				(this.cr = 0),
				(this.lf = 0),
				(this.crlf = 0),
				(this.containsRTL = !1),
				(this.containsUnusualLineTerminators = !1),
				(this.isBasicASCII = !0)
		}
		acceptChunk(e) {
			if (e.length === 0) return
			this.chunks.length === 0 && xA(e) && ((this.BOM = IA), (e = e.substr(1)))
			let t = e.charCodeAt(e.length - 1)
			t === 13 || (t >= 55296 && t <= 56319)
				? (this._acceptChunk1(e.substr(0, e.length - 1), !1),
					(this._hasPreviousChar = !0),
					(this._previousChar = t))
				: (this._acceptChunk1(e, !1), (this._hasPreviousChar = !1), (this._previousChar = t))
		}
		_acceptChunk1(e, t) {
			;(!t && e.length === 0) ||
				(this._hasPreviousChar
					? this._acceptChunk2(String.fromCharCode(this._previousChar) + e)
					: this._acceptChunk2(e))
		}
		_acceptChunk2(e) {
			let t = UN(this._tmpLineStarts, e)
			this.chunks.push(new Wi(e, t.lineStarts)),
				(this.cr += t.cr),
				(this.lf += t.lf),
				(this.crlf += t.crlf),
				t.isBasicASCII ||
					((this.isBasicASCII = !1),
					this.containsRTL || (this.containsRTL = Ev(e)),
					this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = wv(e)))
		}
		finish(e = !0) {
			return (
				this._finish(),
				new S1(
					this.chunks,
					this.BOM,
					this.cr,
					this.lf,
					this.crlf,
					this.containsRTL,
					this.containsUnusualLineTerminators,
					this.isBasicASCII,
					e,
				)
			)
		}
		_finish() {
			if ((this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar)) {
				this._hasPreviousChar = !1
				let e = this.chunks[this.chunks.length - 1]
				e.buffer += String.fromCharCode(this._previousChar)
				let t = Hi(e.buffer)
				;(e.lineStarts = t), this._previousChar === 13 && this.cr++
			}
		}
	}
var FS = class extends $ {
	constructor(t, n, r) {
		super()
		this._source = t
		this._inputTextBuffer = n
		this._outputs = r
		this._outputTextBuffers = void 0
	}
	_getFullModelRange(t) {
		let n = t.getLineCount()
		return new Re(1, 1, n, this._getLineMaxColumn(t, n))
	}
	_getLineMaxColumn(t, n) {
		if (n < 1 || n > t.getLineCount()) throw new Error("Illegal value for lineNumber")
		return t.getLineLength(n) + 1
	}
	get inputTextBuffer() {
		if (!this._inputTextBuffer) {
			let t = new Dh()
			t.acceptChunk(this._source)
			let n = t.finish(!0),
				{ textBuffer: r, disposable: i } = n.create(1)
			;(this._inputTextBuffer = r), this._register(i)
		}
		return this._inputTextBuffer
	}
	get outputTextBuffers() {
		return (
			this._outputTextBuffers ||
				(this._outputTextBuffers = this._outputs.map((t) => {
					let n = new Dh()
					n.acceptChunk(t)
					let r = n.finish(!0),
						{ textBuffer: i, disposable: s } = r.create(1)
					return this._register(s), i
				})),
			this._outputTextBuffers
		)
	}
	findInInputs(t) {
		let r = new jg(t, !1, !1, null).parseSearchRequest()
		if (!r) return []
		let i = this._getFullModelRange(this.inputTextBuffer)
		return this.inputTextBuffer.findMatchesLineByLine(i, r, !0, 5e3)
	}
	findInOutputs(t) {
		let r = new jg(t, !1, !1, null).parseSearchRequest()
		return r
			? this.outputTextBuffers
					.map((i) => {
						let s = i.findMatchesLineByLine(this._getFullModelRange(i), r, !0, 5e3)
						if (s.length !== 0) return { textBuffer: i, matches: s }
					})
					.filter((i) => !!i)
			: []
	}
}
function T1(o, e) {
	let t = -1,
		n = [],
		r = []
	return (
		o.forEach((s) => {
			s.range.startLineNumber !== t && r.length > 0 && (n.push([...r]), (r = [])),
				r.push(s),
				(t = s.range.endLineNumber)
		}),
		r.length > 0 && n.push([...r]),
		n.map((s) => {
			let a = [],
				l = s[0].range.startLineNumber,
				d = s[s.length - 1].range.endLineNumber
			for (let c = l; c <= d; c++) a.push(e.getLineContent(c))
			return new np(
				a.join(`
`) +
					`
`,
				s.map(
					(c) =>
						new Re(
							c.range.startLineNumber - 1,
							c.range.startColumn - 1,
							c.range.endLineNumber - 1,
							c.range.endColumn - 1,
						),
				),
			)
		})
	)
}
var VVe = Object.freeze({
		id: "application",
		order: 100,
		title: p("applicationConfigurationTitle", "Application"),
		type: "object",
	}),
	WN = Object.freeze({
		id: "workbench",
		order: 7,
		title: p("workbenchConfigurationTitle", "Workbench"),
		type: "object",
	}),
	xB = Object.freeze({
		id: "security",
		scope: 1,
		title: p("securityConfigurationTitle", "Security"),
		type: "object",
		order: 7,
	}),
	BVe = Object.freeze({
		id: "problems",
		title: p("problemsConfigurationTitle", "Problems"),
		type: "object",
		order: 101,
	}),
	CB = Object.freeze({ id: "window", order: 8, title: p("windowConfigurationTitle", "Window"), type: "object" }),
	SB = { ConfigurationMigration: "base.contributions.configuration.migration" },
	E1 = class {
		constructor() {
			this.migrations = []
			this._onDidRegisterConfigurationMigrations = new E()
			this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event
		}
		registerConfigurationMigrations(e) {
			this.migrations.push(...e)
		}
	},
	WS = new E1()
yt.add(SB.ConfigurationMigration, WS)
var NS = class extends $ {
	constructor(t, n) {
		super()
		this.configurationService = t
		this.workspaceService = n
		this._register(
			this.workspaceService.onDidChangeWorkspaceFolders(async (r) => {
				for (let i of r.added) await this.migrateConfigurationsForFolder(i, WS.migrations)
			}),
		),
			this.migrateConfigurations(WS.migrations),
			this._register(WS.onDidRegisterConfigurationMigration((r) => this.migrateConfigurations(r)))
	}
	static {
		this.ID = "workbench.contrib.configurationMigration"
	}
	async migrateConfigurations(t) {
		await this.migrateConfigurationsForFolder(void 0, t)
		for (let n of this.workspaceService.getWorkspace().folders) await this.migrateConfigurationsForFolder(n, t)
	}
	async migrateConfigurationsForFolder(t, n) {
		await Promise.all([n.map((r) => this.migrateConfigurationsForFolderAndOverride(r, t?.uri))])
	}
	async migrateConfigurationsForFolderAndOverride(t, n) {
		let r = this.configurationService.inspect(t.key, { resource: n }),
			i =
				this.workspaceService.getWorkbenchState() === 3
					? [
							["user", 2],
							["userLocal", 3],
							["userRemote", 4],
							["workspace", 5],
							["workspaceFolder", 6],
						]
					: [
							["user", 2],
							["userLocal", 3],
							["userRemote", 4],
							["workspace", 5],
						]
		for (let [s, a] of i) {
			let l = r[s]
			if (!l) continue
			let d = []
			if (l.value !== void 0) {
				let c = await this.runMigration(t, s, l.value, n, void 0)
				for (let u of c ?? []) d.push([u, []])
			}
			for (let { identifiers: c, value: u } of l.overrides ?? [])
				if (u !== void 0) {
					let m = await this.runMigration(t, s, u, n, c)
					for (let f of m ?? []) d.push([f, c])
				}
			d.length &&
				(await Promise.allSettled(
					d.map(async ([[c, u], m]) =>
						this.configurationService.updateValue(c, u.value, { resource: n, overrideIdentifiers: m }, a),
					),
				))
		}
	}
	async runMigration(t, n, r, i, s) {
		let a = (d) => {
				let u = this.configurationService.inspect(d, { resource: i })[n]
				if (u) return s ? u.overrides?.find(({ identifiers: m }) => nn(m, s))?.value : u.value
			},
			l = await t.migrateFn(r, a)
		return Array.isArray(l) ? l : [[t.key, l]]
	}
}
NS = R([S(0, vr), S(1, mi)], NS)
var US = class extends $ {
	constructor(t) {
		super()
		this.remoteAgentService = t
		this._ready = new Cn()
		this.ready = this._ready.p
		this.create()
	}
	static {
		this.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration"
	}
	async create() {
		try {
			await this.doCreate()
		} finally {
			this._ready.complete()
		}
	}
	async doCreate() {
		if (!Ie && (await this.remoteAgentService.getEnvironment())?.os !== 1) return
		yt.as(go.Configuration).registerConfiguration({
			...xB,
			properties: {
				"security.allowedUNCHosts": {
					type: "array",
					items: {
						type: "string",
						pattern: "^[^\\\\]+$",
						patternErrorMessage: p(
							"security.allowedUNCHosts.patternErrorMessage",
							"UNC host names must not contain backslashes.",
						),
					},
					default: [],
					markdownDescription: p(
						"security.allowedUNCHosts",
						"A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc.",
					),
					scope: 3,
				},
				"security.restrictUNCAccess": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"security.restrictUNCAccess",
						"If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc.",
					),
					scope: 3,
				},
			},
		})
	}
}
US = R([S(0, zx)], US)
var kh = "window.newWindowProfile",
	HS = class extends $ {
		constructor(t, n) {
			super()
			this.userDataProfilesService = t
			this.configurationService = n
			this.registerNewWindowProfileConfiguration(),
				this._register(
					this.userDataProfilesService.onDidChangeProfiles((r) =>
						this.registerNewWindowProfileConfiguration(),
					),
				),
				this.setNewWindowProfile(),
				this.checkAndResetNewWindowProfileConfig(),
				this._register(
					n.onDidChangeConfiguration((r) => {
						r.source !== 7 && r.affectsConfiguration(kh) && this.setNewWindowProfile()
					}),
				),
				this._register(
					this.userDataProfilesService.onDidChangeProfiles(() => this.checkAndResetNewWindowProfileConfig()),
				)
		}
		static {
			this.ID = "workbench.contrib.dynamicWindowConfiguration"
		}
		registerNewWindowProfileConfiguration() {
			let t = yt.as(go.Configuration),
				n = {
					...CB,
					properties: {
						[kh]: {
							type: ["string", "null"],
							default: null,
							enum: [...this.userDataProfilesService.profiles.map((r) => r.name), null],
							enumItemLabels: [
								...this.userDataProfilesService.profiles.map((r) => ""),
								p("active window", "Active Window"),
							],
							description: p(
								"newWindowProfile",
								"Specifies the profile to use when opening a new window. If a profile name is provided, the new window will use that profile. If no profile name is provided, the new window will use the profile of the active window or the Default profile if no active window exists.",
							),
							scope: 1,
						},
					},
				}
			this.configurationNode
				? t.updateConfigurations({ add: [n], remove: [this.configurationNode] })
				: t.registerConfiguration(n),
				(this.configurationNode = n)
		}
		setNewWindowProfile() {
			let t = this.configurationService.getValue(kh)
			this.newWindowProfile = t ? this.userDataProfilesService.profiles.find((n) => n.name === t) : void 0
		}
		checkAndResetNewWindowProfileConfig() {
			let t = this.configurationService.getValue(kh)
			if (!t) return
			let n = this.newWindowProfile
				? this.userDataProfilesService.profiles.find((r) => r.id === this.newWindowProfile.id)
				: void 0
			t !== n?.name && this.configurationService.updateValue(kh, n?.name)
		}
	}
HS = R([S(0, FM), S(1, vr)], HS)
var t7e = O("editorResolverService")
var TB = yt.as(go.Configuration),
	EB = {
		...WN,
		properties: {
			"workbench.editorAssociations": {
				type: "object",
				markdownDescription: p(
					"editor.editorAssociations",
					'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.',
				),
				additionalProperties: { type: "string" },
			},
		},
	}
TB.registerConfiguration(EB)
function VN(o, e) {
	if (new Set([W.extension, W.webviewPanel, W.vscodeWorkspaceTrust, W.vscodeSettings]).has(e.scheme)) return !1
	let r = typeof o == "string" && o.indexOf(Ue.sep) >= 0 ? `${e.scheme}:${e.path}` : Ht(e)
	return vi(typeof o == "string" ? o.toLowerCase() : o, r.toLowerCase())
}
var VS = class o {
	constructor(e, t, n, r, i, s, a) {
		this._textDocumentsAndEditors = n
		this._textDocuments = r
		this._extHostFileSystem = i
		this._extHostSearch = s
		this._logService = a
		this._notebookStatusBarItemProviders = new Map()
		this._documents = new ft()
		this._editors = new Map()
		this._onDidChangeActiveNotebookEditor = new E()
		this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event
		this._visibleNotebookEditors = []
		this._onDidOpenNotebookDocument = new E()
		this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event
		this._onDidCloseNotebookDocument = new E()
		this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event
		this._onDidChangeVisibleNotebookEditors = new E()
		this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event
		this._statusBarCache = new pr("NotebookCellStatusBarCache")
		this._handlePool = 0
		this._notebookSerializer = new Map()
		;(this._notebookProxy = e.getProxy(N.MainThreadNotebook)),
			(this._notebookDocumentsProxy = e.getProxy(N.MainThreadNotebookDocuments)),
			(this._notebookEditorsProxy = e.getProxy(N.MainThreadNotebookEditors)),
			(this._commandsConverter = t.converter),
			t.registerArgumentProcessor({
				processArgument: (l) => {
					if (l && l.$mid === 13) {
						let d = l.notebookEditor?.notebookUri,
							c = l.cell.handle,
							m = this._documents.get(d)?.getCell(c)
						if (m) return m.apiCell
					}
					if (l && l.$mid === 14) {
						let d = l.uri,
							c = this._documents.get(d)
						if (c) return c.apiNotebook
					}
					return l
				},
			}),
			o._registerApiCommands(t)
	}
	static {
		this._notebookStatusBarItemProviderHandlePool = 0
	}
	get activeNotebookEditor() {
		return this._activeNotebookEditor?.apiEditor
	}
	get visibleNotebookEditors() {
		return this._visibleNotebookEditors.map((e) => e.apiEditor)
	}
	getEditorById(e) {
		let t = this._editors.get(e)
		if (!t) throw new Error(`unknown text editor: ${e}. known editors: ${[...this._editors.keys()]} `)
		return t
	}
	getIdByEditor(e) {
		for (let [t, n] of this._editors) if (n.apiEditor === e) return t
	}
	get notebookDocuments() {
		return [...this._documents.values()]
	}
	getNotebookDocument(e, t) {
		let n = this._documents.get(e)
		if (!n && !t) throw new Error(`NO notebook document for '${e}'`)
		return n
	}
	static _convertNotebookRegistrationData(e, t) {
		if (!t) return
		let n = t.filenamePattern.map((r) => Tg.from(r)).filter((r) => r !== void 0)
		if (t.filenamePattern && !n) {
			console.warn(`Notebook content provider view options file name pattern is invalid ${t.filenamePattern}`)
			return
		}
		return {
			extension: e.identifier,
			providerDisplayName: e.displayName || e.name,
			displayName: t.displayName,
			filenamePattern: n,
			priority: t.exclusive ? "exclusive" : void 0,
		}
	}
	registerNotebookCellStatusBarItemProvider(e, t, n) {
		let r = o._notebookStatusBarItemProviderHandlePool++,
			i =
				typeof n.onDidChangeCellStatusBarItems == "function"
					? o._notebookStatusBarItemProviderHandlePool++
					: void 0
		this._notebookStatusBarItemProviders.set(r, n),
			this._notebookProxy.$registerNotebookCellStatusBarItemProvider(r, i, t)
		let s
		return (
			i !== void 0 &&
				(s = n.onDidChangeCellStatusBarItems((a) => this._notebookProxy.$emitCellStatusBarEvent(i))),
			new ye(() => {
				this._notebookStatusBarItemProviders.delete(r),
					this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(r, i),
					s?.dispose()
			})
		)
	}
	async createNotebookDocument(e) {
		let t = await this._notebookDocumentsProxy.$tryCreateNotebook({
			viewType: e.viewType,
			content: e.content && Ya.from(e.content),
		})
		return y.revive(t)
	}
	async openNotebookDocument(e) {
		let t = this._documents.get(e)
		if (t) return t.apiNotebook
		let n = await this._notebookDocumentsProxy.$tryOpenNotebook(e),
			r = this._documents.get(y.revive(n))
		return Do(r?.apiNotebook)
	}
	async showNotebookDocument(e, t) {
		let n
		typeof t == "object"
			? (n = {
					position: wt.from(t.viewColumn),
					preserveFocus: t.preserveFocus,
					selections: t.selections && t.selections.map(Zr.from),
					pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
					label:
						typeof t.asRepl == "string" ? t.asRepl : typeof t.asRepl == "object" ? t.asRepl.label : void 0,
				})
			: (n = { preserveFocus: !1, pinned: !0 })
		let r = t?.asRepl ? "repl" : e.notebookType,
			i = await this._notebookEditorsProxy.$tryShowNotebookDocument(e.uri, r, n),
			s = i && this._editors.get(i)?.apiEditor
		if (s) return s
		throw i
			? new Error(
					`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`,
				)
			: new Error(`Could NOT open editor for "${e.uri.toString()}".`)
	}
	async $provideNotebookCellStatusBarItems(e, t, n, r) {
		let i = this._notebookStatusBarItemProviders.get(e),
			s = y.revive(t),
			a = this._documents.get(s)
		if (!a || !i) return
		let l = a.getCellFromIndex(n)
		if (!l) return
		let d = await i.provideCellStatusBarItems(l.apiCell, r)
		if (!d) return
		let c = new Q(),
			u = this._statusBarCache.add([c]),
			f = (Array.isArray(d) ? d : [d]).map((h) => zD.from(h, this._commandsConverter, c))
		return { cacheId: u, items: f }
	}
	$releaseNotebookCellStatusBarItems(e) {
		this._statusBarCache.delete(e)
	}
	registerNotebookSerializer(e, t, n, r, i) {
		if (Qi(t)) throw new Error("viewType cannot be empty or just whitespace")
		let s = this._handlePool++
		return (
			this._notebookSerializer.set(s, { viewType: t, serializer: n, options: r }),
			this._notebookProxy.$registerNotebookSerializer(
				s,
				{ id: e.identifier, location: e.extensionLocation },
				t,
				KD.from(r),
				o._convertNotebookRegistrationData(e, i),
			),
			q(() => {
				this._notebookProxy.$unregisterNotebookSerializer(s)
			})
		)
	}
	async $dataToNotebook(e, t, n) {
		let r = this._notebookSerializer.get(e)
		if (!r) throw new Error("NO serializer found")
		let i = await r.serializer.deserializeNotebook(t.buffer, n)
		return new Xt(Ya.from(i))
	}
	async $notebookToData(e, t, n) {
		let r = this._notebookSerializer.get(e)
		if (!r) throw new Error("NO serializer found")
		let i = await r.serializer.serializeNotebook(Ya.to(t.value), n)
		return z.wrap(i)
	}
	async $saveNotebook(e, t, n, r, i) {
		let s = y.revive(t),
			a = this._notebookSerializer.get(e)
		if ((this.trace(`enter saveNotebook(versionId: ${n}, ${s.toString()})`), !a))
			throw new Error("NO serializer found")
		let l = this._documents.get(s)
		if (!l) throw new Error("Document NOT found")
		if (l.versionId !== n) throw new Error("Document version mismatch")
		if (!this._extHostFileSystem.value.isWritableFileSystem(s.scheme))
			throw new ql(p("err.readonly", "Unable to modify read-only file '{0}'", this._resourceForError(s)), 6)
		let d = {
			metadata: iw(l.apiNotebook.metadata, (h) => !(a.options?.transientDocumentMetadata ?? {})[h]),
			cells: [],
		}
		for (let h of l.apiNotebook.getCells()) {
			let g = new xs(
				h.kind,
				h.document.getText(),
				h.document.languageId,
				h.mime,
				a.options?.transientOutputs ? [] : [...h.outputs],
				h.metadata,
				h.executionSummary,
			)
			;(g.metadata = iw(h.metadata, (I) => !(a.options?.transientCellMetadata ?? {})[I])), d.cells.push(g)
		}
		if ((await this._validateWriteFile(s, r), i.isCancellationRequested)) throw new Error("canceled")
		let c = await a.serializer.serializeNotebook(d, i)
		if (i.isCancellationRequested) throw new Error("canceled")
		this.trace(`serialized versionId: ${n} ${s.toString()}`),
			await this._extHostFileSystem.value.writeFile(s, c),
			this.trace(`Finished write versionId: ${n} ${s.toString()}`)
		let u = this._extHostFileSystem.getFileSystemProviderExtUri(s.scheme),
			m = await this._extHostFileSystem.value.stat(s),
			f = {
				name: u.basename(s),
				isFile: (m.type & 1) !== 0,
				isDirectory: (m.type & 2) !== 0,
				isSymbolicLink: (m.type & 64) !== 0,
				mtime: m.mtime,
				ctime: m.ctime,
				size: m.size,
				readonly: !!((m.permissions ?? 0) & 1) || !this._extHostFileSystem.value.isWritableFileSystem(s.scheme),
				locked: !!((m.permissions ?? 0) & 2),
				etag: uP({ mtime: m.mtime, size: m.size }),
				children: void 0,
			}
		return this.trace(`exit saveNotebook(versionId: ${n}, ${s.toString()})`), f
	}
	async $searchInNotebooks(e, t, n, r, i) {
		let s = this._notebookSerializer.get(e)?.serializer
		if (!s) return { limitHit: !1, results: [] }
		let a = new dc()
		await (async (m, f, h) => {
			await Promise.all(
				m.map(
					async (g) =>
						await Promise.all(
							g.filenamePatterns.map((I) => {
								let C = {
									_reason: h._reason,
									folderQueries: h.folderQueries,
									includePattern: h.includePattern,
									excludePattern: h.excludePattern,
									maxResults: h.maxResults,
									type: 1,
									filePattern: I,
								}
								return this._extHostSearch
									.doInternalFileSearchWithCustomCallback(C, f, (T) => {
										T.forEach((w) => {
											a.has(w) ||
												r.some((A) =>
													g.isFromSettings && !A.isFromSettings
														? !1
														: A.filenamePatterns.some((J) => VN(J, w)),
												) ||
												a.add(w)
										})
									})
									.catch((T) => {
										if (T.code === "ENOENT")
											return (
												console.warn(
													"Could not find notebook search results, ignoring notebook results.",
												),
												{ limitHit: !1, messages: [] }
											)
										throw T
									})
							}),
						),
				),
			)
		})(n, i, t)
		let d = new ft(),
			c = !1,
			u = Array.from(a).map(async (m) => {
				let f = []
				try {
					if (i.isCancellationRequested) return
					if (t.maxResults && [...d.values()].reduce((C, T) => C + T.cellResults.length, 0) > t.maxResults) {
						c = !0
						return
					}
					let h = [],
						g = this._documents.get(m)
					if (g)
						g.apiNotebook.getCells().forEach((T) =>
							h.push({
								input: T.document.getText(),
								outputs: T.outputs.flatMap((w) => w.items.map((L) => L.data.toString())),
							}),
						)
					else {
						let C = await this._extHostFileSystem.value.readFile(m),
							T = z.fromString(C.toString()),
							w = await s.deserializeNotebook(T.buffer, i)
						if (i.isCancellationRequested) return
						Ya.from(w).cells.forEach((A) =>
							h.push({
								input: A.source,
								outputs: A.outputs.flatMap((J) => J.items.map((ne) => ne.valueBytes.toString())),
							}),
						)
					}
					if (i.isCancellationRequested) return
					h.forEach((C, T) => {
						let w = t.contentPattern.pattern,
							L = new FS(C.input, void 0, C.outputs),
							A = L.findInInputs(w),
							J = L.findInOutputs(w),
							ne = J.flatMap((oe) => T1(oe.matches, oe.textBuffer)).map(
								(oe, Y) => ((oe.webviewIndex = Y), oe),
							)
						if (A.length > 0 || J.length > 0) {
							let oe = { index: T, contentResults: T1(A, L.inputTextBuffer), webviewResults: ne }
							f.push(oe)
						}
					})
					let I = { resource: m, cellResults: f }
					d.set(m, I)
					return
				} catch {
					return
				}
			})
		return await Promise.all(u), { limitHit: c, results: [...d.values()] }
	}
	async _validateWriteFile(e, t) {
		let n = await this._extHostFileSystem.value.stat(e)
		if (
			typeof t?.mtime == "number" &&
			typeof t.etag == "string" &&
			t.etag !== nL &&
			typeof n.mtime == "number" &&
			typeof n.size == "number" &&
			t.mtime < n.mtime &&
			t.etag !== uP({ mtime: t.mtime, size: n.size })
		)
			throw new ql(p("fileModifiedError", "File Modified Since"), 3, t)
	}
	_resourceForError(e) {
		return e.scheme === W.file ? e.fsPath : e.toString()
	}
	_createExtHostEditor(e, t, n) {
		if (this._editors.has(t)) throw new Error(`editor with id ALREADY EXSIST: ${t}`)
		let r = new Qd(
			t,
			this._notebookEditorsProxy,
			e,
			n.visibleRanges.map(Zr.to),
			n.selections.map(Zr.to),
			typeof n.viewColumn == "number" ? wt.to(n.viewColumn) : void 0,
			n.viewType,
		)
		this._editors.set(t, r)
	}
	$acceptDocumentAndEditorsDelta(e) {
		if (e.value.removedDocuments)
			for (let n of e.value.removedDocuments) {
				let r = y.revive(n),
					i = this._documents.get(r)
				i &&
					(i.dispose(),
					this._documents.delete(r),
					this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({
						removedDocuments: i.apiNotebook.getCells().map((s) => s.document.uri),
					}),
					this._onDidCloseNotebookDocument.fire(i.apiNotebook))
				for (let s of this._editors.values())
					s.notebookData.uri.toString() === r.toString() && this._editors.delete(s.id)
			}
		if (e.value.addedDocuments) {
			let n = []
			for (let r of e.value.addedDocuments) {
				let i = y.revive(r.uri)
				if (this._documents.has(i)) throw new Error(`adding EXISTING notebook ${i} `)
				let s = new DS(this._notebookDocumentsProxy, this._textDocumentsAndEditors, this._textDocuments, i, r)
				n.push(...r.cells.map((a) => Cm.asModelAddData(a))),
					this._documents.get(i)?.dispose(),
					this._documents.set(i, s),
					this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: n }),
					this._onDidOpenNotebookDocument.fire(s.apiNotebook)
			}
		}
		if (e.value.addedEditors)
			for (let n of e.value.addedEditors) {
				if (this._editors.has(n.id)) return
				let r = y.revive(n.documentUri),
					i = this._documents.get(r)
				i && this._createExtHostEditor(i, n.id, n)
			}
		let t = []
		if (e.value.removedEditors)
			for (let n of e.value.removedEditors) {
				let r = this._editors.get(n)
				r &&
					(this._editors.delete(n),
					this._activeNotebookEditor?.id === r.id && (this._activeNotebookEditor = void 0),
					t.push(r))
			}
		if (e.value.visibleEditors) {
			this._visibleNotebookEditors = e.value.visibleEditors.map((r) => this._editors.get(r)).filter((r) => !!r)
			let n = new Set()
			this._visibleNotebookEditors.forEach((r) => n.add(r.id))
			for (let r of this._editors.values()) {
				let i = n.has(r.id)
				r._acceptVisibility(i)
			}
			;(this._visibleNotebookEditors = [...this._editors.values()].map((r) => r).filter((r) => r.visible)),
				this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors)
		}
		e.value.newActiveEditor === null
			? (this._activeNotebookEditor = void 0)
			: e.value.newActiveEditor &&
				(this._editors.get(e.value.newActiveEditor) ||
					console.error(`FAILED to find active notebook editor ${e.value.newActiveEditor}`),
				(this._activeNotebookEditor = this._editors.get(e.value.newActiveEditor))),
			e.value.newActiveEditor !== void 0 &&
				this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor?.apiEditor)
	}
	static _registerApiCommands(e) {
		let t = G.String.with("notebookType", "A notebook type"),
			n = new be(
				"vscode.executeDataToNotebook",
				"_executeDataToNotebook",
				"Invoke notebook serializer",
				[
					t,
					new G(
						"data",
						"Bytes to convert to data",
						(i) => i instanceof Uint8Array,
						(i) => z.wrap(i),
					),
				],
				new ge("Notebook Data", (i) => Ya.to(i.value)),
			),
			r = new be(
				"vscode.executeNotebookToData",
				"_executeNotebookToData",
				"Invoke notebook serializer",
				[
					t,
					new G(
						"NotebookData",
						"Notebook data to convert to bytes",
						(i) => !0,
						(i) => new Xt(Ya.from(i)),
					),
				],
				new ge("Bytes", (i) => i.buffer),
			)
		e.registerApiCommand(n), e.registerApiCommand(r)
	}
	trace(e) {
		this._logService.trace(`[Extension Host Notebook] ${e}`)
	}
}
var BS = class {
	constructor(e, t, n, r = { timeout: 1500, errors: 3 }) {
		this._logService = e
		this._notebooksAndEditors = t
		this._mainThreadBulkEdits = n
		this._thresholds = r
		this._onWillSaveNotebookDocumentEvent = new si()
	}
	dispose() {}
	getOnWillSaveNotebookDocumentEvent(e) {
		return (t, n, r) => {
			let i = function (a) {
				t.call(n, a)
			}
			return (i.extension = e), this._onWillSaveNotebookDocumentEvent.event(i, void 0, r)
		}
	}
	async $participateInSave(e, t, n) {
		let r = y.revive(e),
			i = this._notebooksAndEditors.getNotebookDocument(r)
		if (!i) throw new Error("Unable to resolve notebook document")
		let s = []
		if (
			(await this._onWillSaveNotebookDocumentEvent.fireAsync(
				{ notebook: i.apiNotebook, reason: xg.to(t) },
				n,
				async (l, d) => {
					let c = Date.now(),
						u = await await Promise.resolve(l)
					Date.now() - c > this._thresholds.timeout &&
						this._logService.warn(
							"onWillSaveNotebookDocument-listener from extension",
							d.extension.identifier,
						),
						!n.isCancellationRequested &&
							u &&
							(u instanceof Jr
								? s.push(u)
								: this._logService.warn(
										"onWillSaveNotebookDocument-listener from extension",
										d.extension.identifier,
										"ignored due to invalid data",
									))
				},
			),
			n.isCancellationRequested)
		)
			return !1
		if (s.length === 0) return !0
		let a = { edits: [] }
		for (let l of s) {
			let { edits: d } = $n.from(l)
			a.edits = a.edits.concat(d)
		}
		return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new Xt(a))
	}
}
var $S = class {
	constructor(e) {
		this._notebooksAndEditors = e
		this._onDidSaveNotebookDocument = new E()
		this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event
		this._onDidChangeNotebookDocument = new E()
		this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event
	}
	$acceptModelChanged(e, t, n, r) {
		let s = this._notebooksAndEditors.getNotebookDocument(y.revive(e)).acceptModelChanged(t.value, n, r)
		this._onDidChangeNotebookDocument.fire(s)
	}
	$acceptDirtyStateChanged(e, t) {
		this._notebooksAndEditors.getNotebookDocument(y.revive(e)).acceptDirty(t)
	}
	$acceptModelSaved(e) {
		let t = this._notebooksAndEditors.getNotebookDocument(y.revive(e))
		this._onDidSaveNotebookDocument.fire(t.apiNotebook)
	}
}
var Tm = class {
	constructor(e, t) {
		this._logService = e
		this._notebooksAndEditors = t
		this._onDidChangeNotebookEditorSelection = new E()
		this._onDidChangeNotebookEditorVisibleRanges = new E()
		this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event
		this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event
	}
	$acceptEditorPropertiesChanged(e, t) {
		this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", e, t)
		let n = this._notebooksAndEditors.getEditorById(e)
		t.visibleRanges && n._acceptVisibleRanges(t.visibleRanges.ranges.map(Zr.to)),
			t.selections && n._acceptSelections(t.selections.selections.map(Zr.to)),
			t.visibleRanges &&
				this._onDidChangeNotebookEditorVisibleRanges.fire({
					notebookEditor: n.apiEditor,
					visibleRanges: n.apiEditor.visibleRanges,
				}),
			t.selections &&
				this._onDidChangeNotebookEditorSelection.fire(
					Object.freeze({ notebookEditor: n.apiEditor, selections: n.apiEditor.selections }),
				)
	}
	$acceptEditorViewColumns(e) {
		for (let t in e) this._notebooksAndEditors.getEditorById(t)._acceptViewColumn(wt.to(e[t]))
	}
}
Tm = R([S(0, te)], Tm)
var u8e = O("INotebookExecutionService")
var BN = 100
var f8e = O("INotebookKernelService"),
	g8e = O("INotebookKernelHistoryService")
var Em = class {
	constructor(e, t, n, r, i) {
		this._initData = t
		this._extHostNotebook = n
		this._commands = r
		this._logService = i
		this._activeExecutions = new ft()
		this._activeNotebookExecutions = new ft()
		this._kernelDetectionTask = new Map()
		this._kernelDetectionTaskHandlePool = 0
		this._kernelSourceActionProviders = new Map()
		this._kernelSourceActionProviderHandlePool = 0
		this._kernelData = new Map()
		this._handlePool = 0
		this._onDidChangeCellExecutionState = new E()
		this.onDidChangeNotebookCellExecutionState = this._onDidChangeCellExecutionState.event
		this.id = 0
		this.variableStore = {}
		this._proxy = e.getProxy(N.MainThreadNotebookKernels)
		let s = new be(
				"notebook.selectKernel",
				"_notebook.selectKernel",
				"Trigger kernel picker for specified notebook editor widget",
				[
					new G(
						"options",
						"Select kernel options",
						(l) => !0,
						(l) => {
							if (l && "notebookEditor" in l && "id" in l) {
								let d = this._extHostNotebook.getIdByEditor(l.notebookEditor)
								return { id: l.id, extension: l.extension, notebookEditorId: d }
							} else if (l && "notebookEditor" in l) {
								let d = this._extHostNotebook.getIdByEditor(l.notebookEditor)
								if (d === void 0)
									throw new Error(
										`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${l.notebookEditor.notebook.uri.toString()}`,
									)
								return { notebookEditorId: d }
							}
							return l
						},
					),
				],
				ge.Void,
			),
			a = new be(
				"vscode.executeNotebookVariableProvider",
				"_executeNotebookVariableProvider",
				"Execute notebook variable provider",
				[G.Uri],
				new ge("A promise that resolves to an array of variables", (l, d) =>
					l.map((c) => ({
						variable: {
							name: c.name,
							value: c.value,
							expression: c.expression,
							type: c.type,
							language: c.language,
						},
						hasNamedChildren: c.hasNamedChildren,
						indexedChildrenCount: c.indexedChildrenCount,
					})),
				),
			)
		this._commands.registerApiCommand(s), this._commands.registerApiCommand(a)
	}
	createNotebookController(e, t, n, r, i, s) {
		for (let A of this._kernelData.values())
			if (A.controller.id === t && we.equals(e.identifier, A.extensionId))
				throw new Error(`notebook controller with id '${t}' ALREADY exist`)
		let a = this._handlePool++,
			l = this
		this._logService.trace(`NotebookController[${a}], CREATED by ${e.identifier.value}, ${t}`)
		let d = () =>
				console.warn(`NO execute handler from notebook controller '${f.id}' of extension: '${e.identifier}'`),
			c = !1,
			u = new E(),
			m = new E(),
			f = {
				id: zS(e.identifier, t),
				notebookType: n,
				extensionId: e.identifier,
				extensionLocation: e.extensionLocation,
				label: r || e.identifier.value,
				preloads: s ? s.map(sx.from) : [],
			},
			h = i ?? d,
			g,
			I
		this._proxy.$addKernel(a, f).catch((A) => {
			console.log(A), (c = !0)
		})
		let C = 0,
			T = () => {
				if (c) return
				let A = ++C
				Promise.resolve().then(() => {
					A === C && this._proxy.$updateKernel(a, f)
				})
			},
			w = new ft(),
			L = {
				get id() {
					return t
				},
				get notebookType() {
					return f.notebookType
				},
				onDidChangeSelectedNotebooks: u.event,
				get label() {
					return f.label
				},
				set label(A) {
					;(f.label = A ?? e.displayName ?? e.name), T()
				},
				get detail() {
					return f.detail ?? ""
				},
				set detail(A) {
					;(f.detail = A), T()
				},
				get description() {
					return f.description ?? ""
				},
				set description(A) {
					;(f.description = A), T()
				},
				get supportedLanguages() {
					return f.supportedLanguages
				},
				set supportedLanguages(A) {
					;(f.supportedLanguages = A), T()
				},
				get supportsExecutionOrder() {
					return f.supportsExecutionOrder ?? !1
				},
				set supportsExecutionOrder(A) {
					;(f.supportsExecutionOrder = A), T()
				},
				get rendererScripts() {
					return f.preloads ? f.preloads.map(sx.to) : []
				},
				get executeHandler() {
					return h
				},
				set executeHandler(A) {
					h = A ?? d
				},
				get interruptHandler() {
					return g
				},
				set interruptHandler(A) {
					;(g = A), (f.supportsInterrupt = !!A), T()
				},
				set variableProvider(A) {
					M(e, "notebookVariableProvider"),
						(I = A),
						(f.hasVariableProvider = !!A),
						A?.onDidChangeVariables((J) => l._proxy.$variablesUpdated(J.uri)),
						T()
				},
				get variableProvider() {
					return I
				},
				createNotebookCellExecution(A) {
					if (c) throw new Error("notebook controller is DISPOSED")
					if (!w.has(A.notebook.uri))
						throw (
							(l._logService.trace(
								`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`,
								Array.from(w.keys()).map((J) => J.toString()),
							),
							new Error(
								`notebook controller is NOT associated to notebook: ${A.notebook.uri.toString()}`,
							))
						)
					return l._createNotebookCellExecution(A, zS(e.identifier, this.id))
				},
				createNotebookExecution(A) {
					if ((M(e, "notebookExecution"), c)) throw new Error("notebook controller is DISPOSED")
					if (!w.has(A.uri))
						throw (
							(l._logService.trace(
								`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`,
								Array.from(w.keys()).map((J) => J.toString()),
							),
							new Error(`notebook controller is NOT associated to notebook: ${A.uri.toString()}`))
						)
					return l._createNotebookExecution(A, zS(e.identifier, this.id))
				},
				dispose: () => {
					c ||
						(this._logService.trace(`NotebookController[${a}], DISPOSED`),
						(c = !0),
						this._kernelData.delete(a),
						u.dispose(),
						m.dispose(),
						this._proxy.$removeKernel(a))
				},
				updateNotebookAffinity(A, J) {
					J === -1 && M(e, "notebookControllerAffinityHidden"), l._proxy.$updateNotebookPriority(a, A.uri, J)
				},
				onDidReceiveMessage: m.event,
				postMessage(A, J) {
					return (
						M(e, "notebookMessaging"), l._proxy.$postMessage(a, J && l._extHostNotebook.getIdByEditor(J), A)
					)
				},
				asWebviewUri(A) {
					return M(e, "notebookMessaging"), hl(A, l._initData.remote)
				},
			}
		return (
			this._kernelData.set(a, {
				extensionId: e.identifier,
				controller: L,
				onDidReceiveMessage: m,
				onDidChangeSelection: u,
				associatedNotebooks: w,
			}),
			L
		)
	}
	getIdByController(e) {
		for (let [t, n] of this._kernelData) if (n.controller === e) return zS(n.extensionId, e.id)
		return null
	}
	createNotebookControllerDetectionTask(e, t) {
		let n = this._kernelDetectionTaskHandlePool++,
			r = this
		this._logService.trace(`NotebookControllerDetectionTask[${n}], CREATED by ${e.identifier.value}`),
			this._proxy.$addKernelDetectionTask(n, t)
		let i = {
			dispose: () => {
				this._kernelDetectionTask.delete(n), r._proxy.$removeKernelDetectionTask(n)
			},
		}
		return this._kernelDetectionTask.set(n, i), i
	}
	registerKernelSourceActionProvider(e, t, n) {
		let r = this._kernelSourceActionProviderHandlePool++,
			i = typeof n.onDidChangeNotebookKernelSourceActions == "function" ? r : void 0,
			s = this
		this._kernelSourceActionProviders.set(r, n),
			this._logService.trace(`NotebookKernelSourceActionProvider[${r}], CREATED by ${e.identifier.value}`),
			this._proxy.$addKernelSourceActionProvider(r, r, t)
		let a
		return (
			i !== void 0 &&
				(a = n.onDidChangeNotebookKernelSourceActions((l) =>
					this._proxy.$emitNotebookKernelSourceActionsChangeEvent(i),
				)),
			{
				dispose: () => {
					this._kernelSourceActionProviders.delete(r),
						s._proxy.$removeKernelSourceActionProvider(r, r),
						a?.dispose()
				},
			}
		)
	}
	async $provideKernelSourceActions(e, t) {
		let n = this._kernelSourceActionProviders.get(e)
		if (n) {
			let r = new Q()
			return ((await n.provideNotebookKernelSourceActions(t)) ?? []).map((s) =>
				qD.from(s, this._commands.converter, r),
			)
		}
		return []
	}
	$acceptNotebookAssociation(e, t, n) {
		let r = this._kernelData.get(e)
		if (r) {
			let i = this._extHostNotebook.getNotebookDocument(y.revive(t))
			n ? r.associatedNotebooks.set(i.uri, !0) : r.associatedNotebooks.delete(i.uri),
				this._logService.trace(`NotebookController[${e}] ASSOCIATE notebook`, i.uri.toString(), n),
				r.onDidChangeSelection.fire({ selected: n, notebook: i.apiNotebook })
		}
	}
	async $executeCells(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getNotebookDocument(y.revive(t)),
			s = []
		for (let a of n) {
			let l = i.getCell(a)
			l && s.push(l.apiCell)
		}
		try {
			this._logService.trace(`NotebookController[${e}] EXECUTE cells`, i.uri.toString(), s.length),
				await r.controller.executeHandler.call(r.controller, s, i.apiNotebook, r.controller)
		} catch (a) {
			this._logService.error(`NotebookController[${e}] execute cells FAILED`, a), console.error(a)
		}
	}
	async $cancelCells(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getNotebookDocument(y.revive(t))
		if (r.controller.interruptHandler) await r.controller.interruptHandler.call(r.controller, i.apiNotebook)
		else
			for (let s of n) {
				let a = i.getCell(s)
				a && this._activeExecutions.get(a.uri)?.cancel()
			}
		if (r.controller.interruptHandler) {
			let s = this._activeNotebookExecutions.get(i.uri)
			this._activeNotebookExecutions.delete(i.uri),
				n.length && Array.isArray(s) && s.length && s.forEach((a) => a.dispose())
		}
	}
	async $provideVariables(e, t, n, r, i, s, a) {
		let l = this._kernelData.get(e)
		if (!l) return
		let d = this._extHostNotebook.getNotebookDocument(y.revive(n)),
			c = l.controller.variableProvider
		if (!c) return
		let u
		if (r !== void 0) {
			if (((u = this.variableStore[r]), !u)) return
		} else this.variableStore = {}
		let m = i === "named" ? 1 : 2,
			f = c.provideVariables(d.apiNotebook, u, m, s, a),
			h = 0
		for await (let g of f) {
			if (a.isCancellationRequested) return
			let I = {
				id: this.id++,
				name: g.variable.name,
				value: g.variable.value,
				type: g.variable.type,
				interfaces: g.variable.interfaces,
				language: g.variable.language,
				expression: g.variable.expression,
				hasNamedChildren: g.hasNamedChildren,
				indexedChildrenCount: g.indexedChildrenCount,
				extensionId: l.extensionId.value,
			}
			if (((this.variableStore[I.id] = g.variable), this._proxy.$receiveVariable(t, I), h++ >= BN)) return
		}
	}
	$acceptKernelMessageFromRenderer(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getEditorById(t)
		r.onDidReceiveMessage.fire(Object.freeze({ editor: i.apiEditor, message: n }))
	}
	$cellExecutionChanged(e, t, n) {
		let i = this._extHostNotebook.getNotebookDocument(y.revive(e)).getCell(t)
		if (i) {
			let s = n ? $D.to(n) : 1
			s !== void 0 && this._onDidChangeCellExecutionState.fire({ cell: i.apiCell, state: s })
		}
	}
	_createNotebookCellExecution(e, t) {
		if (e.index < 0) throw new Error("CANNOT execute cell that has been REMOVED from notebook")
		let r = this._extHostNotebook.getNotebookDocument(e.notebook.uri).getCellFromApiCell(e)
		if (!r) throw new Error("invalid cell")
		if (this._activeExecutions.has(r.uri)) throw new Error(`duplicate execution for ${r.uri}`)
		let i = new w1(t, r, this._proxy)
		this._activeExecutions.set(r.uri, i)
		let s = i.onDidChangeState(() => {
			i.state === 2 && (i.dispose(), s.dispose(), this._activeExecutions.delete(r.uri))
		})
		return i.asApiObject()
	}
	_createNotebookExecution(e, t) {
		let n = this._extHostNotebook.getNotebookDocument(e.uri),
			r = e.getCells().find((a) => {
				let l = n.getCellFromApiCell(a)
				return l && this._activeExecutions.has(l.uri)
			})
		if (r) throw new Error(`duplicate cell execution for ${r.document.uri}`)
		if (this._activeNotebookExecutions.has(n.uri)) throw new Error(`duplicate notebook execution for ${n.uri}`)
		let i = new P1(t, n, this._proxy),
			s = i.onDidChangeState(() => {
				i.state === 2 && (i.dispose(), s.dispose(), this._activeNotebookExecutions.delete(n.uri))
			})
		return this._activeNotebookExecutions.set(n.uri, [i, s]), i.asApiObject()
	}
}
Em = R([S(4, te)], Em)
var w1 = class o extends $ {
	constructor(t, n, r) {
		super()
		this._cell = n
		this._proxy = r
		this._handle = o.HANDLE++
		this._onDidChangeState = new E()
		this.onDidChangeState = this._onDidChangeState.event
		this._state = 0
		this._tokenSource = this._register(new _e())
		;(this._collector = new _1(10, (i) => this.update(i))),
			(this._executionOrder = n.internalMetadata.executionOrder),
			this._proxy.$createExecution(this._handle, t, this._cell.notebook.uri, this._cell.handle)
	}
	static {
		this.HANDLE = 0
	}
	get state() {
		return this._state
	}
	cancel() {
		this._tokenSource.cancel()
	}
	async updateSoon(t) {
		await this._collector.addItem(t)
	}
	async update(t) {
		let n = Array.isArray(t) ? t : [t]
		return this._proxy.$updateExecution(this._handle, new Xt(n))
	}
	verifyStateForOutput() {
		if (this._state === 0) throw new Error("Must call start before modifying cell output")
		if (this._state === 2) throw new Error("Cannot modify cell output after calling resolve")
	}
	cellIndexToHandle(t) {
		let n = this._cell
		if ((t && (n = this._cell.notebook.getCellFromApiCell(t)), !n)) throw new Error("INVALID cell")
		return n.handle
	}
	validateAndConvertOutputs(t) {
		return t.map((n) => {
			let r = Cs.ensureUniqueMimeTypes(n.items, !0)
			return r === n.items ? Ms.from(n) : Ms.from({ items: r, id: n.id, metadata: n.metadata })
		})
	}
	async updateOutputs(t, n, r) {
		let i = this.cellIndexToHandle(n),
			s = this.validateAndConvertOutputs(an(t))
		return this.updateSoon({ editType: 1, cellHandle: i, append: r, outputs: s })
	}
	async updateOutputItems(t, n, r) {
		return (
			(t = Cs.ensureUniqueMimeTypes(an(t), !0)),
			this.updateSoon({ editType: 2, items: t.map(wd.from), outputId: n.id, append: r })
		)
	}
	asApiObject() {
		let t = this
		return Object.freeze({
			get token() {
				return t._tokenSource.token
			},
			get cell() {
				return t._cell.apiCell
			},
			get executionOrder() {
				return t._executionOrder
			},
			set executionOrder(r) {
				;(t._executionOrder = r), t.update([{ editType: 3, executionOrder: t._executionOrder }])
			},
			start(r) {
				if (t._state === 2 || t._state === 1) throw new Error("Cannot call start again")
				;(t._state = 1), t._onDidChangeState.fire(), t.update({ editType: 3, runStartTime: r })
			},
			end(r, i, s) {
				if (t._state === 2) throw new Error("Cannot call resolve twice")
				;(t._state = 2), t._onDidChangeState.fire(), t._collector.flush()
				let a = wB(s)
				t._proxy.$completeExecution(t._handle, new Xt({ runEndTime: i, lastRunSuccess: r, error: a }))
			},
			clearOutput(r) {
				return t.verifyStateForOutput(), t.updateOutputs([], r, !1)
			},
			appendOutput(r, i) {
				return t.verifyStateForOutput(), t.updateOutputs(r, i, !0)
			},
			replaceOutput(r, i) {
				return t.verifyStateForOutput(), t.updateOutputs(r, i, !1)
			},
			appendOutputItems(r, i) {
				return t.verifyStateForOutput(), t.updateOutputItems(r, i, !0)
			},
			replaceOutputItems(r, i) {
				return t.verifyStateForOutput(), t.updateOutputItems(r, i, !1)
			},
		})
	}
}
function wB(o) {
	let e = (r) =>
			r
				? {
						startLineNumber: r.start.line,
						startColumn: r.start.character,
						endLineNumber: r.end.line,
						endColumn: r.end.character,
					}
				: void 0,
		t = (r) => ({ uri: r.uri, position: r.position, label: r.label })
	return o
		? {
				name: o.name,
				message: o.message,
				stack: o.stack instanceof Array ? o.stack.map((r) => t(r)) : o.stack,
				location: e(o.location),
				uri: o.uri,
			}
		: void 0
}
var P1 = class o extends $ {
		constructor(t, n, r) {
			super()
			this._notebook = n
			this._proxy = r
			this._handle = o.HANDLE++
			this._onDidChangeState = new E()
			this.onDidChangeState = this._onDidChangeState.event
			this._state = 0
			this._tokenSource = this._register(new _e())
			this._proxy.$createNotebookExecution(this._handle, t, this._notebook.uri)
		}
		static {
			this.HANDLE = 0
		}
		get state() {
			return this._state
		}
		cancel() {
			this._tokenSource.cancel()
		}
		asApiObject() {
			return Object.freeze({
				start: () => {
					if (this._state === 2 || this._state === 1) throw new Error("Cannot call start again")
					;(this._state = 1), this._onDidChangeState.fire(), this._proxy.$beginNotebookExecution(this._handle)
				},
				end: () => {
					if (this._state === 2) throw new Error("Cannot call resolve twice")
					;(this._state = 2),
						this._onDidChangeState.fire(),
						this._proxy.$completeNotebookExecution(this._handle)
				},
			})
		}
	},
	_1 = class {
		constructor(e, t) {
			this.delay = e
			this.callback = t
			this.batch = []
			this.startedTimer = Date.now()
		}
		addItem(e) {
			return (
				this.batch.push(e),
				this.currentDeferred ||
					((this.currentDeferred = new Cn()),
					(this.startedTimer = Date.now()),
					Wt(this.delay).then(() => this.flush())),
				Date.now() - this.startedTimer > this.delay ? this.flush() : this.currentDeferred.p
			)
		}
		flush() {
			if (this.batch.length === 0 || !this.currentDeferred) return Promise.resolve()
			let e = this.currentDeferred
			this.currentDeferred = void 0
			let t = this.batch
			return (this.batch = []), this.callback(t).finally(() => e.complete())
		}
	}
function zS(o, e) {
	return `${o.value}/${e}`
}
var qS = class {
	constructor(e, t) {
		this._extHostNotebook = t
		this._rendererMessageEmitters = new Map()
		this.proxy = e.getProxy(N.MainThreadNotebookRenderers)
	}
	$postRendererMessage(e, t, n) {
		let r = this._extHostNotebook.getEditorById(e)
		this._rendererMessageEmitters.get(t)?.fire({ editor: r.apiEditor, message: n })
	}
	createRendererMessaging(e, t) {
		if (!e.contributes?.notebookRenderer?.some((r) => r.id === t))
			throw new Error(
				`Extensions may only call createRendererMessaging() for renderers they contribute (got ${t})`,
			)
		return {
			onDidReceiveMessage: (r, i, s) => this.getOrCreateEmitterFor(t).event(r, i, s),
			postMessage: (r, i) => {
				Qd.apiEditorsToExtHost.has(r) && ([r, i] = [i, r])
				let s = i && Qd.apiEditorsToExtHost.get(i)
				return this.proxy.$postMessage(s?.id, t, r)
			},
		}
	}
	getOrCreateEmitterFor(e) {
		let t = this._rendererMessageEmitters.get(e)
		return (
			t ||
			((t = new E({
				onDidRemoveLastListener: () => {
					t?.dispose(), this._rendererMessageEmitters.delete(e)
				},
			})),
			this._rendererMessageEmitters.set(e, t),
			t)
		)
	}
}
var KS = class {
	constructor(e) {
		this.handlers = new Map()
		this.proxy = e.getProxy(N.MainThreadProfileContentHandlers)
	}
	registerProfileContentHandler(e, t, n) {
		if ((M(e, "profileContentHandlers"), this.handlers.has(t)))
			throw new Error(`Handler with id '${t}' already registered`)
		return (
			this.handlers.set(t, n),
			this.proxy.$registerProfileContentHandler(t, n.name, n.description, e.identifier.value),
			q(() => {
				this.handlers.delete(t), this.proxy.$unregisterProfileContentHandler(t)
			})
		)
	}
	async $saveProfile(e, t, n, r) {
		let i = this.handlers.get(e)
		if (!i) throw new Error(`Unknown handler with id: ${e}`)
		return i.saveProfile(t, n, r)
	}
	async $readProfile(e, t, n) {
		let r = this.handlers.get(e)
		if (!r) throw new Error(`Unknown handler with id: ${e}`)
		return r.readProfile(Ee(t) ? t : y.revive(t), n)
	}
}
var GS = class {
	constructor(e) {
		this._handles = 0
		this._mapHandleToCancellationSource = new Map()
		this._proxy = e
	}
	async withProgress(e, t, n) {
		let r = this._handles++,
			{ title: i, location: s, cancellable: a } = t,
			l = { label: e.displayName || e.name, id: e.identifier.value }
		return (
			this._proxy
				.$startProgress(
					r,
					{ location: VD.from(s), title: i, source: l, cancellable: a },
					e.isUnderDevelopment ? void 0 : e.identifier.value,
				)
				.catch(Qh),
			this._withProgress(r, n, !!a)
		)
	}
	_withProgress(e, t, n) {
		let r
		n && ((r = new _e()), this._mapHandleToCancellationSource.set(e, r))
		let i = (a) => {
				this._proxy.$progressEnd(a), this._mapHandleToCancellationSource.delete(a), r?.dispose()
			},
			s
		try {
			s = t(new jS(this._proxy, e), n && r ? r.token : De.None)
		} catch (a) {
			throw (i(e), a)
		}
		return (
			s.then(
				(a) => i(e),
				(a) => i(e),
			),
			s
		)
	}
	$acceptProgressCanceled(e) {
		let t = this._mapHandleToCancellationSource.get(e)
		t && (t.cancel(), this._mapHandleToCancellationSource.delete(e))
	}
}
function PB(o, e) {
	return (
		(o.message = e.message),
		typeof e.increment == "number" &&
			(typeof o.increment == "number" ? (o.increment += e.increment) : (o.increment = e.increment)),
		o
	)
}
var jS = class extends ha {
	constructor(t, n) {
		super((r) => this.throttledReport(r))
		this._proxy = t
		this._handle = n
	}
	throttledReport(t) {
		this._proxy.$progressReport(this._handle, t)
	}
}
R(
	[
		SO(
			100,
			(t, n) => PB(t, n),
			() => Object.create(null),
		),
	],
	jS.prototype,
	"throttledReport",
	1,
)
var QS = class o {
	constructor(e, t) {
		this.uriTransformer = t
		this.providers = new Map()
		this.proxy = e.getProxy(N.MainThreadQuickDiff)
	}
	static {
		this.handlePool = 0
	}
	$provideOriginalResource(e, t, n) {
		let r = y.revive(t),
			i = this.providers.get(e)
		return i ? Jt(() => i.provideOriginalResource(r, n)).then((s) => s || null) : Promise.resolve(null)
	}
	registerQuickDiffProvider(e, t, n, r) {
		let i = o.handlePool++
		return (
			this.providers.set(i, t),
			this.proxy.$registerQuickDiffProvider(i, Fs.from(e, this.uriTransformer), n, r, t.visible ?? !0),
			{
				dispose: () => {
					this.proxy.$unregisterQuickDiffProvider(i), this.providers.delete(i)
				},
			}
		)
	}
}
function $N(o, e, t) {
	let n = o.getProxy(N.MainThreadQuickOpen)
	class r {
		constructor(f, h) {
			this._sessions = new Map()
			this._instances = 0
			;(this._workspace = f), (this._commands = h)
		}
		showQuickPick(f, h, g, I = De.None) {
			this._onDidSelectItem = void 0
			let C = Promise.resolve(h),
				T = ++this._instances,
				w = n.$show(
					T,
					{
						title: g?.title,
						placeHolder: g?.placeHolder,
						matchOnDescription: g?.matchOnDescription,
						matchOnDetail: g?.matchOnDetail,
						ignoreFocusLost: g?.ignoreFocusOut,
						canPickMany: g?.canPickMany,
					},
					I,
				),
				L = {},
				A = w.then(() => L)
			return Promise.race([A, C])
				.then((J) => {
					if (J === L) return
					let ne = nt(f, "quickPickItemTooltip")
					return C.then((oe) => {
						let Y = []
						for (let j = 0; j < oe.length; j++) {
							let K = oe[j]
							if (typeof K == "string") Y.push({ label: K, handle: j })
							else if (K.kind === -1) Y.push({ type: "separator", label: K.label })
							else {
								K.tooltip &&
									!ne &&
									console.warn(
										`Extension '${f.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${f.identifier.value}`,
									)
								let qe = K.iconPath ? d(K.iconPath) : void 0
								Y.push({
									label: K.label,
									iconPath: qe?.iconPath,
									iconClass: qe?.iconClass,
									description: K.description,
									detail: K.detail,
									picked: K.picked,
									alwaysShow: K.alwaysShow,
									tooltip: ne ? Ce.fromStrict(K.tooltip) : void 0,
									handle: j,
								})
							}
						}
						return (
							g &&
								typeof g.onDidSelectItem == "function" &&
								(this._onDidSelectItem = (j) => {
									g.onDidSelectItem(oe[j])
								}),
							n.$setItems(T, Y),
							w.then((j) => {
								if (typeof j == "number") return oe[j]
								if (Array.isArray(j)) return j.map((K) => oe[K])
							})
						)
					})
				})
				.then(void 0, (J) => {
					if (!bn(J)) return n.$setError(T, J), Promise.reject(J)
				})
		}
		$onItemSelected(f) {
			this._onDidSelectItem?.(f)
		}
		showInput(f, h = De.None) {
			return (
				(this._validateInput = f?.validateInput),
				n.$input(f, typeof this._validateInput == "function", h).then(void 0, (g) => {
					if (!bn(g)) return Promise.reject(g)
				})
			)
		}
		async $validateInput(f) {
			if (!this._validateInput) return
			let h = await this._validateInput(f)
			if (!h || typeof h == "string") return h
			let g
			switch (h.severity) {
				case 1:
					g = It.Info
					break
				case 2:
					g = It.Warning
					break
				case 3:
					g = It.Error
					break
				default:
					g = h.message ? It.Error : It.Ignore
					break
			}
			return { content: h.message, severity: g }
		}
		async showWorkspaceFolderPick(f, h = De.None) {
			let g = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [f])
			if (!g) return
			let I = await this._workspace.getWorkspaceFolders2()
			if (I) return I.find((C) => C.uri.toString() === g.uri.toString())
		}
		createQuickPick(f) {
			let h = new c(f, () => this._sessions.delete(h._id))
			return this._sessions.set(h._id, h), h
		}
		createInputBox(f) {
			let h = new u(f, () => this._sessions.delete(h._id))
			return this._sessions.set(h._id, h), h
		}
		$onDidChangeValue(f, h) {
			this._sessions.get(f)?._fireDidChangeValue(h)
		}
		$onDidAccept(f) {
			this._sessions.get(f)?._fireDidAccept()
		}
		$onDidChangeActive(f, h) {
			let g = this._sessions.get(f)
			g instanceof c && g._fireDidChangeActive(h)
		}
		$onDidChangeSelection(f, h) {
			let g = this._sessions.get(f)
			g instanceof c && g._fireDidChangeSelection(h)
		}
		$onDidTriggerButton(f, h) {
			this._sessions.get(f)?._fireDidTriggerButton(h)
		}
		$onDidTriggerItemButton(f, h, g) {
			let I = this._sessions.get(f)
			I instanceof c && I._fireDidTriggerItemButton(h, g)
		}
		$onDidHide(f) {
			this._sessions.get(f)?._fireDidHide()
		}
	}
	class i {
		constructor(f, h) {
			this._extension = f
			this._onDidDispose = h
			this._id = c._nextId++
			this._visible = !1
			this._expectingHide = !1
			this._enabled = !0
			this._busy = !1
			this._ignoreFocusOut = !0
			this._value = ""
			this._valueSelection = void 0
			this._buttons = []
			this._handlesToButtons = new Map()
			this._onDidAcceptEmitter = new E()
			this._onDidChangeValueEmitter = new E()
			this._onDidTriggerButtonEmitter = new E()
			this._onDidHideEmitter = new E()
			this._pendingUpdate = { id: this._id }
			this._disposed = !1
			this._disposables = [
				this._onDidTriggerButtonEmitter,
				this._onDidHideEmitter,
				this._onDidAcceptEmitter,
				this._onDidChangeValueEmitter,
			]
			this.onDidChangeValue = this._onDidChangeValueEmitter.event
			this.onDidAccept = this._onDidAcceptEmitter.event
			this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event
			this.onDidHide = this._onDidHideEmitter.event
		}
		static {
			this._nextId = 1
		}
		get title() {
			return this._title
		}
		set title(f) {
			;(this._title = f), this.update({ title: f })
		}
		get step() {
			return this._steps
		}
		set step(f) {
			;(this._steps = f), this.update({ step: f })
		}
		get totalSteps() {
			return this._totalSteps
		}
		set totalSteps(f) {
			;(this._totalSteps = f), this.update({ totalSteps: f })
		}
		get enabled() {
			return this._enabled
		}
		set enabled(f) {
			;(this._enabled = f), this.update({ enabled: f })
		}
		get busy() {
			return this._busy
		}
		set busy(f) {
			;(this._busy = f), this.update({ busy: f })
		}
		get ignoreFocusOut() {
			return this._ignoreFocusOut
		}
		set ignoreFocusOut(f) {
			;(this._ignoreFocusOut = f), this.update({ ignoreFocusOut: f })
		}
		get value() {
			return this._value
		}
		set value(f) {
			;(this._value = f), this.update({ value: f })
		}
		get valueSelection() {
			return this._valueSelection
		}
		set valueSelection(f) {
			;(this._valueSelection = f), this.update({ valueSelection: f })
		}
		get placeholder() {
			return this._placeholder
		}
		set placeholder(f) {
			;(this._placeholder = f), this.update({ placeholder: f })
		}
		get buttons() {
			return this._buttons
		}
		set buttons(f) {
			let h = nt(this._extension, "quickInputButtonLocation")
			!h &&
				f.some((g) => g.location) &&
				console.warn(
					`Extension '${this._extension.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`,
				),
				(this._buttons = f.slice()),
				this._handlesToButtons.clear(),
				f.forEach((g, I) => {
					let C = g === bi.Back ? -1 : I
					this._handlesToButtons.set(C, g)
				}),
				this.update({
					buttons: f.map((g, I) => ({
						...d(g.iconPath),
						tooltip: g.tooltip,
						handle: g === bi.Back ? -1 : I,
						location: h ? g.location : void 0,
					})),
				})
		}
		show() {
			;(this._visible = !0), (this._expectingHide = !0), this.update({ visible: !0 })
		}
		hide() {
			;(this._visible = !1), this.update({ visible: !1 })
		}
		_fireDidAccept() {
			this._onDidAcceptEmitter.fire()
		}
		_fireDidChangeValue(f) {
			;(this._value = f), this._onDidChangeValueEmitter.fire(f)
		}
		_fireDidTriggerButton(f) {
			let h = this._handlesToButtons.get(f)
			h && this._onDidTriggerButtonEmitter.fire(h)
		}
		_fireDidHide() {
			this._expectingHide && ((this._expectingHide = this._visible), this._onDidHideEmitter.fire())
		}
		dispose() {
			this._disposed ||
				((this._disposed = !0),
				this._fireDidHide(),
				(this._disposables = Fn(this._disposables)),
				this._updateTimeout && (clearTimeout(this._updateTimeout), (this._updateTimeout = void 0)),
				this._onDidDispose(),
				n.$dispose(this._id))
		}
		update(f) {
			if (!this._disposed) {
				for (let h of Object.keys(f)) {
					let g = f[h]
					this._pendingUpdate[h] = g === void 0 ? null : g
				}
				"visible" in this._pendingUpdate
					? (this._updateTimeout && (clearTimeout(this._updateTimeout), (this._updateTimeout = void 0)),
						this.dispatchUpdate())
					: this._visible &&
						!this._updateTimeout &&
						(this._updateTimeout = setTimeout(() => {
							;(this._updateTimeout = void 0), this.dispatchUpdate()
						}, 0))
			}
		}
		dispatchUpdate() {
			n.$createOrUpdate(this._pendingUpdate), (this._pendingUpdate = { id: this._id })
		}
	}
	function s(m) {
		if (m instanceof Vt) return { id: m.id }
		let f = l(m),
			h = a(m)
		return { dark: typeof f == "string" ? y.file(f) : f, light: typeof h == "string" ? y.file(h) : h }
	}
	function a(m) {
		return typeof m == "object" && "light" in m ? m.light : m
	}
	function l(m) {
		return typeof m == "object" && "dark" in m ? m.dark : m
	}
	function d(m) {
		let f = s(m),
			h,
			g
		return "id" in f ? (g = Yt.asClassName(f)) : (h = f), { iconPath: h, iconClass: g }
	}
	class c extends i {
		constructor(h, g) {
			super(h, g)
			this._items = []
			this._handlesToItems = new Map()
			this._itemsToHandles = new Map()
			this._canSelectMany = !1
			this._matchOnDescription = !0
			this._matchOnDetail = !0
			this._sortByLabel = !0
			this._keepScrollPosition = !1
			this._activeItems = []
			this._onDidChangeActiveEmitter = new E()
			this._selectedItems = []
			this._onDidChangeSelectionEmitter = new E()
			this._onDidTriggerItemButtonEmitter = new E()
			this.onDidChangeActive = this._onDidChangeActiveEmitter.event
			this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event
			this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event
			this._disposables.push(
				this._onDidChangeActiveEmitter,
				this._onDidChangeSelectionEmitter,
				this._onDidTriggerItemButtonEmitter,
			),
				this.update({ type: "quickPick" })
		}
		get items() {
			return this._items
		}
		set items(h) {
			;(this._items = h.slice()),
				this._handlesToItems.clear(),
				this._itemsToHandles.clear(),
				h.forEach((C, T) => {
					this._handlesToItems.set(T, C), this._itemsToHandles.set(C, T)
				})
			let g = nt(this._extension, "quickPickItemTooltip"),
				I = []
			for (let C = 0; C < h.length; C++) {
				let T = h[C]
				if (T.kind === -1) I.push({ type: "separator", label: T.label })
				else {
					T.tooltip &&
						!g &&
						console.warn(
							`Extension '${this._extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`,
						)
					let w = T.iconPath ? d(T.iconPath) : void 0
					I.push({
						handle: C,
						label: T.label,
						iconPath: w?.iconPath,
						iconClass: w?.iconClass,
						description: T.description,
						detail: T.detail,
						picked: T.picked,
						alwaysShow: T.alwaysShow,
						tooltip: g ? Ce.fromStrict(T.tooltip) : void 0,
						buttons: T.buttons?.map((L, A) => ({ ...d(L.iconPath), tooltip: L.tooltip, handle: A })),
					})
				}
			}
			this.update({ items: I })
		}
		get canSelectMany() {
			return this._canSelectMany
		}
		set canSelectMany(h) {
			;(this._canSelectMany = h), this.update({ canSelectMany: h })
		}
		get matchOnDescription() {
			return this._matchOnDescription
		}
		set matchOnDescription(h) {
			;(this._matchOnDescription = h), this.update({ matchOnDescription: h })
		}
		get matchOnDetail() {
			return this._matchOnDetail
		}
		set matchOnDetail(h) {
			;(this._matchOnDetail = h), this.update({ matchOnDetail: h })
		}
		get sortByLabel() {
			return this._sortByLabel
		}
		set sortByLabel(h) {
			;(this._sortByLabel = h), this.update({ sortByLabel: h })
		}
		get keepScrollPosition() {
			return this._keepScrollPosition
		}
		set keepScrollPosition(h) {
			;(this._keepScrollPosition = h), this.update({ keepScrollPosition: h })
		}
		get activeItems() {
			return this._activeItems
		}
		set activeItems(h) {
			;(this._activeItems = h.filter((g) => this._itemsToHandles.has(g))),
				this.update({ activeItems: this._activeItems.map((g) => this._itemsToHandles.get(g)) })
		}
		get selectedItems() {
			return this._selectedItems
		}
		set selectedItems(h) {
			;(this._selectedItems = h.filter((g) => this._itemsToHandles.has(g))),
				this.update({ selectedItems: this._selectedItems.map((g) => this._itemsToHandles.get(g)) })
		}
		_fireDidChangeActive(h) {
			let g = Ye(h.map((I) => this._handlesToItems.get(I)))
			;(this._activeItems = g), this._onDidChangeActiveEmitter.fire(g)
		}
		_fireDidChangeSelection(h) {
			let g = Ye(h.map((I) => this._handlesToItems.get(I)))
			;(this._selectedItems = g), this._onDidChangeSelectionEmitter.fire(g)
		}
		_fireDidTriggerItemButton(h, g) {
			let I = this._handlesToItems.get(h)
			if (!I || !I.buttons || !I.buttons.length) return
			let C = I.buttons[g]
			C && this._onDidTriggerItemButtonEmitter.fire({ button: C, item: I })
		}
	}
	class u extends i {
		constructor(h, g) {
			super(h, g)
			this._password = !1
			this.update({ type: "inputBox" })
		}
		get password() {
			return this._password
		}
		set password(h) {
			;(this._password = h), this.update({ password: h })
		}
		get prompt() {
			return this._prompt
		}
		set prompt(h) {
			;(this._prompt = h), this.update({ prompt: h })
		}
		get validationMessage() {
			return this._validationMessage
		}
		set validationMessage(h) {
			;(this._validationMessage = h),
				h
					? typeof h == "string"
						? this.update({ validationMessage: h, severity: It.Error })
						: this.update({ validationMessage: h.message, severity: h.severity ?? It.Error })
					: this.update({ validationMessage: void 0, severity: It.Ignore })
		}
	}
	return new r(e, t)
}
function zN(o) {
	return o instanceof y
}
function _B(o, e) {
	return o.scheme === W.file && e.scheme === W.file && Ve
		? o.toString() === e.toString()
		: o.toString().toLowerCase() === e.toString().toLowerCase()
}
function D1(o) {
	if (o)
		return typeof o.iconPath == "string"
			? y.file(o.iconPath)
			: y.isUri(o.iconPath) || Yt.isThemeIcon(o.iconPath)
				? o.iconPath
				: void 0
}
function Jd(o) {
	if (o) {
		if (y.isUri(o)) return o
		if (Yt.isThemeIcon(o)) return o
		{
			let e = o
			return { light: e.light, dark: e.dark }
		}
	} else return
}
function DB(o) {
	let e = Jd(o.authorIcon),
		t = o.references?.map((n) => ({ ...n, icon: Jd(n.icon) }))
	return { ...o, authorIcon: e, references: t }
}
function k1(o) {
	return o ? { ...o, icon: Jd(o.icon) } : void 0
}
function R1(o, e) {
	if (!o.iconPath && !e.iconPath) return 0
	if (o.iconPath) {
		if (!e.iconPath) return 1
	} else return -1
	let t = typeof o.iconPath == "string" ? o.iconPath : y.isUri(o.iconPath) ? o.iconPath.fsPath : o.iconPath.id,
		n = typeof e.iconPath == "string" ? e.iconPath : y.isUri(e.iconPath) ? e.iconPath.fsPath : e.iconPath.id
	return ah(t, n)
}
function kB(o, e) {
	let t = 0
	if (o.strikeThrough !== e.strikeThrough) return o.strikeThrough ? 1 : -1
	if (o.faded !== e.faded) return o.faded ? 1 : -1
	if (o.tooltip !== e.tooltip) return (o.tooltip || "").localeCompare(e.tooltip || "")
	if (((t = R1(o, e)), t !== 0)) return t
	if (o.light && e.light) t = R1(o.light, e.light)
	else {
		if (o.light) return 1
		if (e.light) return -1
	}
	if (t !== 0) return t
	if (o.dark && e.dark) t = R1(o.dark, e.dark)
	else {
		if (o.dark) return 1
		if (e.dark) return -1
	}
	return t
}
function RB(o, e) {
	if (o.command !== e.command) return o.command < e.command ? -1 : 1
	if (o.title !== e.title) return o.title < e.title ? -1 : 1
	if (o.tooltip !== e.tooltip) {
		if (o.tooltip !== void 0 && e.tooltip !== void 0) return o.tooltip < e.tooltip ? -1 : 1
		if (o.tooltip !== void 0) return 1
		if (e.tooltip !== void 0) return -1
	}
	if (o.arguments === e.arguments) return 0
	if (o.arguments)
		if (e.arguments) {
			if (o.arguments.length !== e.arguments.length) return o.arguments.length - e.arguments.length
		} else return 1
	else return -1
	for (let t = 0; t < o.arguments.length; t++) {
		let n = o.arguments[t],
			r = e.arguments[t]
		if (n !== r && !(zN(n) && zN(r) && _B(n, r))) return n < r ? -1 : 1
	}
	return 0
}
function qN(o, e) {
	let t = ah(o.resourceUri.fsPath, e.resourceUri.fsPath, !0)
	if (t !== 0) return t
	if (o.command && e.command) t = RB(o.command, e.command)
	else {
		if (o.command) return 1
		if (e.command) return -1
	}
	if (t !== 0) return t
	if (o.decorations && e.decorations) t = kB(o.decorations, e.decorations)
	else {
		if (o.decorations) return 1
		if (e.decorations) return -1
	}
	if (t !== 0) return t
	if (o.multiFileDiffEditorModifiedUri && e.multiFileDiffEditorModifiedUri)
		t = ah(o.multiFileDiffEditorModifiedUri.fsPath, e.multiFileDiffEditorModifiedUri.fsPath, !0)
	else {
		if (o.multiFileDiffEditorModifiedUri) return 1
		if (e.multiFileDiffEditorModifiedUri) return -1
	}
	if (t !== 0) return t
	if (o.multiDiffEditorOriginalUri && e.multiDiffEditorOriginalUri)
		t = ah(o.multiDiffEditorOriginalUri.fsPath, e.multiDiffEditorOriginalUri.fsPath, !0)
	else {
		if (o.multiDiffEditorOriginalUri) return 1
		if (e.multiDiffEditorOriginalUri) return -1
	}
	return t
}
function AB(o, e) {
	for (let t = 0; t < o.length; t++) if (o[t] !== e[t]) return !1
	return !0
}
function OB(o, e) {
	return (
		o.command === e.command &&
		o.title === e.title &&
		o.tooltip === e.tooltip &&
		(o.arguments && e.arguments ? AB(o.arguments, e.arguments) : o.arguments === e.arguments)
	)
}
function LB(o, e) {
	return mn(o, e, OB)
}
var A1 = class {
		constructor(e, t, n, r, i) {
			this._extension = e
			this._sourceControlHandle = r
			this._documentUri = i
			this._value = ""
			this._onDidChange = new E()
			this._placeholder = ""
			this._enabled = !0
			this._visible = !0
			;(this.#t = t), (this.#e = n)
		}
		#e
		#t
		get value() {
			return this._value
		}
		set value(e) {
			;(e = e ?? ""), this.#e.$setInputBoxValue(this._sourceControlHandle, e), this.updateValue(e)
		}
		get onDidChange() {
			return this._onDidChange.event
		}
		get placeholder() {
			return this._placeholder
		}
		set placeholder(e) {
			this.#e.$setInputBoxPlaceholder(this._sourceControlHandle, e), (this._placeholder = e)
		}
		get validateInput() {
			return M(this._extension, "scmValidation"), this._validateInput
		}
		set validateInput(e) {
			if ((M(this._extension, "scmValidation"), e && typeof e != "function"))
				throw new Error(`[${this._extension.identifier.value}]: Invalid SCM input box validation function`)
			;(this._validateInput = e), this.#e.$setValidationProviderIsEnabled(this._sourceControlHandle, !!e)
		}
		get enabled() {
			return this._enabled
		}
		set enabled(e) {
			;(e = !!e),
				this._enabled !== e &&
					((this._enabled = e), this.#e.$setInputBoxEnablement(this._sourceControlHandle, e))
		}
		get visible() {
			return this._visible
		}
		set visible(e) {
			;(e = !!e),
				this._visible !== e &&
					((this._visible = e), this.#e.$setInputBoxVisibility(this._sourceControlHandle, e))
		}
		get document() {
			return M(this._extension, "scmTextDocument"), this.#t.getDocument(this._documentUri)
		}
		showValidationMessage(e, t) {
			M(this._extension, "scmValidation"), this.#e.$showValidationMessage(this._sourceControlHandle, e, t)
		}
		$onInputBoxValueChange(e) {
			this.updateValue(e)
		}
		updateValue(e) {
			;(this._value = e), this._onDidChange.fire(e)
		}
	},
	O1 = class o {
		constructor(e, t, n, r, i, s, a) {
			this._proxy = e
			this._commands = t
			this._sourceControlHandle = n
			this._id = r
			this._label = i
			this.multiDiffEditorEnableViewChanges = s
			this._extension = a
			this._resourceHandlePool = 0
			this._resourceStates = []
			this._resourceStatesMap = new Map()
			this._resourceStatesCommandsMap = new Map()
			this._resourceStatesDisposablesMap = new Map()
			this._onDidUpdateResourceStates = new E()
			this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event
			this._disposed = !1
			this._onDidDispose = new E()
			this.onDidDispose = this._onDidDispose.event
			this._handlesSnapshot = []
			this._resourceSnapshot = []
			this._contextValue = void 0
			this._hideWhenEmpty = void 0
			this.handle = o._handlePool++
		}
		static {
			this._handlePool = 0
		}
		get disposed() {
			return this._disposed
		}
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		set label(e) {
			;(this._label = e), this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, e)
		}
		get contextValue() {
			return this._contextValue
		}
		set contextValue(e) {
			;(this._contextValue = e), this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features)
		}
		get hideWhenEmpty() {
			return this._hideWhenEmpty
		}
		set hideWhenEmpty(e) {
			;(this._hideWhenEmpty = e), this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features)
		}
		get features() {
			return { contextValue: this.contextValue, hideWhenEmpty: this.hideWhenEmpty }
		}
		get resourceStates() {
			return [...this._resourceStates]
		}
		set resourceStates(e) {
			;(this._resourceStates = [...e]), this._onDidUpdateResourceStates.fire()
		}
		getResourceState(e) {
			return this._resourceStatesMap.get(e)
		}
		$executeResourceCommand(e, t) {
			let n = this._resourceStatesCommandsMap.get(e)
			return n
				? Jt(() => this._commands.executeCommand(n.command, ...(n.arguments || []), t))
				: Promise.resolve(void 0)
		}
		_takeResourceStateSnapshot() {
			let e = [...this._resourceStates].sort(qN),
				n = WT(this._resourceSnapshot, e, qN).map((s) => {
					let a = s.toInsert.map((l) => {
						let d = this._resourceHandlePool++
						this._resourceStatesMap.set(d, l)
						let c = l.resourceUri,
							u
						if (l.command)
							if (
								l.command.command === "vscode.open" ||
								l.command.command === "vscode.diff" ||
								l.command.command === "vscode.changes"
							) {
								let oe = new Q()
								;(u = this._commands.converter.toInternal(l.command, oe)),
									this._resourceStatesDisposablesMap.set(d, oe)
							} else this._resourceStatesCommandsMap.set(d, l.command)
						let m = nt(this._extension, "scmMultiDiffEditor"),
							f = m ? l.multiDiffEditorOriginalUri : void 0,
							h = m ? l.multiFileDiffEditorModifiedUri : void 0,
							g = D1(l.decorations),
							I = (l.decorations && D1(l.decorations.light)) || g,
							C = (l.decorations && D1(l.decorations.dark)) || g,
							T = [I, C],
							w = (l.decorations && l.decorations.tooltip) || "",
							L = l.decorations && !!l.decorations.strikeThrough,
							A = l.decorations && !!l.decorations.faded,
							J = l.contextValue || ""
						return { rawResource: [d, c, T, w, L, A, J, u, f, h], handle: d }
					})
					return { start: s.start, deleteCount: s.deleteCount, toInsert: a }
				}),
				r = n.map(({ start: s, deleteCount: a, toInsert: l }) => [s, a, l.map((d) => d.rawResource)]),
				i = n.reverse()
			for (let { start: s, deleteCount: a, toInsert: l } of i) {
				let d = l.map((u) => u.handle),
					c = this._handlesSnapshot.splice(s, a, ...d)
				for (let u of c)
					this._resourceStatesMap.delete(u),
						this._resourceStatesCommandsMap.delete(u),
						this._resourceStatesDisposablesMap.get(u)?.dispose(),
						this._resourceStatesDisposablesMap.delete(u)
			}
			return (this._resourceSnapshot = e), r
		}
		dispose() {
			;(this._disposed = !0), this._onDidDispose.fire()
		}
	},
	Rh = class Rh {
		constructor(e, t, n, r, i, s, a) {
			this._extension = e
			this._commands = r
			this._id = i
			this._label = s
			this._rootUri = a
			this._groups = new Map()
			this._count = void 0
			this._quickDiffProvider = void 0
			this._historyProviderDisposable = new Dn()
			this._commitTemplate = void 0
			this._acceptInputDisposables = new Dn()
			this._acceptInputCommand = void 0
			this._actionButtonDisposables = new Dn()
			this._statusBarDisposables = new Dn()
			this._statusBarCommands = void 0
			this._selected = !1
			this._onDidChangeSelection = new E()
			this.onDidChangeSelection = this._onDidChangeSelection.event
			this.handle = Rh._handlePool++
			this.createdResourceGroups = new Map()
			this.updatedResourceGroups = new Set()
			this.#e = n
			let l = y.from({
				scheme: W.vscodeSourceControl,
				path: `${i}/scm${this.handle}/input`,
				query: a ? `rootUri=${encodeURIComponent(a.toString())}` : void 0,
			})
			;(this._inputBox = new A1(e, t, this.#e, this.handle, l)),
				this.#e.$registerSourceControl(this.handle, i, s, a, l)
		}
		static {
			this._handlePool = 0
		}
		#e
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		get rootUri() {
			return this._rootUri
		}
		get inputBox() {
			return this._inputBox
		}
		get count() {
			return this._count
		}
		set count(e) {
			this._count !== e && ((this._count = e), this.#e.$updateSourceControl(this.handle, { count: e }))
		}
		get quickDiffProvider() {
			return this._quickDiffProvider
		}
		set quickDiffProvider(e) {
			this._quickDiffProvider = e
			let t
			nt(this._extension, "quickDiffProvider") && (t = e?.label),
				this.#e.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!e, quickDiffLabel: t })
		}
		get historyProvider() {
			return M(this._extension, "scmHistoryProvider"), this._historyProvider
		}
		set historyProvider(e) {
			M(this._extension, "scmHistoryProvider"),
				(this._historyProvider = e),
				(this._historyProviderDisposable.value = new Q()),
				this.#e.$updateSourceControl(this.handle, { hasHistoryProvider: !!e }),
				e &&
					(this._historyProviderDisposable.value.add(
						e.onDidChangeCurrentHistoryItemRefs(() => {
							let t = k1(e?.currentHistoryItemRef),
								n = k1(e?.currentHistoryItemRemoteRef),
								r = k1(e?.currentHistoryItemBaseRef)
							this.#e.$onDidChangeHistoryProviderCurrentHistoryItemRefs(this.handle, t, n, r)
						}),
					),
					this._historyProviderDisposable.value.add(
						e.onDidChangeHistoryItemRefs((t) => {
							if (t.added.length === 0 && t.modified.length === 0 && t.removed.length === 0) return
							let n = t.added.map((s) => ({ ...s, icon: Jd(s.icon) })),
								r = t.modified.map((s) => ({ ...s, icon: Jd(s.icon) })),
								i = t.removed.map((s) => ({ ...s, icon: Jd(s.icon) }))
							this.#e.$onDidChangeHistoryProviderHistoryItemRefs(this.handle, {
								added: n,
								modified: r,
								removed: i,
								silent: t.silent,
							})
						}),
					))
		}
		get commitTemplate() {
			return this._commitTemplate
		}
		set commitTemplate(e) {
			e !== this._commitTemplate &&
				((this._commitTemplate = e), this.#e.$updateSourceControl(this.handle, { commitTemplate: e }))
		}
		get acceptInputCommand() {
			return this._acceptInputCommand
		}
		set acceptInputCommand(e) {
			;(this._acceptInputDisposables.value = new Q()), (this._acceptInputCommand = e)
			let t = this._commands.converter.toInternal(e, this._acceptInputDisposables.value)
			this.#e.$updateSourceControl(this.handle, { acceptInputCommand: t })
		}
		get actionButton() {
			return M(this._extension, "scmActionButton"), this._actionButton
		}
		set actionButton(e) {
			if ((M(this._extension, "scmActionButton"), Fb(this._actionButton, e))) return
			;(this._actionButton = e), (this._actionButtonDisposables.value = new Q())
			let t =
				e !== void 0
					? {
							command: {
								...this._commands.converter.toInternal(e.command, this._actionButtonDisposables.value),
								shortTitle: e.command.shortTitle,
							},
							secondaryCommands: e.secondaryCommands?.map((n) =>
								n.map((r) =>
									this._commands.converter.toInternal(r, this._actionButtonDisposables.value),
								),
							),
							enabled: e.enabled,
						}
					: void 0
			this.#e.$updateSourceControl(this.handle, { actionButton: t ?? null })
		}
		get statusBarCommands() {
			return this._statusBarCommands
		}
		set statusBarCommands(e) {
			if (this._statusBarCommands && e && LB(this._statusBarCommands, e)) return
			;(this._statusBarDisposables.value = new Q()), (this._statusBarCommands = e)
			let t = (e || []).map((n) => this._commands.converter.toInternal(n, this._statusBarDisposables.value))
			this.#e.$updateSourceControl(this.handle, { statusBarCommands: t })
		}
		get selected() {
			return this._selected
		}
		createResourceGroup(e, t, n) {
			let r = nt(this._extension, "scmMultiDiffEditor") && n?.multiDiffEditorEnableViewChanges === !0,
				i = new O1(this.#e, this._commands, this.handle, e, t, r, this._extension),
				s = Te.once(i.onDidDispose)(() => this.createdResourceGroups.delete(i))
			return this.createdResourceGroups.set(i, s), this.eventuallyAddResourceGroups(), i
		}
		eventuallyAddResourceGroups() {
			let e = [],
				t = []
			for (let [n, r] of this.createdResourceGroups) {
				r.dispose()
				let i = n.onDidUpdateResourceStates(() => {
					this.updatedResourceGroups.add(n), this.eventuallyUpdateResourceStates()
				})
				Te.once(n.onDidDispose)(() => {
					this.updatedResourceGroups.delete(n),
						i.dispose(),
						this._groups.delete(n.handle),
						this.#e.$unregisterGroup(this.handle, n.handle)
				}),
					e.push([n.handle, n.id, n.label, n.features, n.multiDiffEditorEnableViewChanges])
				let s = n._takeResourceStateSnapshot()
				s.length > 0 && t.push([n.handle, s]), this._groups.set(n.handle, n)
			}
			this.#e.$registerGroups(this.handle, e, t), this.createdResourceGroups.clear()
		}
		eventuallyUpdateResourceStates() {
			let e = []
			this.updatedResourceGroups.forEach((t) => {
				let n = t._takeResourceStateSnapshot()
				n.length !== 0 && e.push([t.handle, n])
			}),
				e.length > 0 && this.#e.$spliceResourceStates(this.handle, e),
				this.updatedResourceGroups.clear()
		}
		getResourceGroup(e) {
			return this._groups.get(e)
		}
		setSelectionState(e) {
			;(this._selected = e), this._onDidChangeSelection.fire(e)
		}
		dispose() {
			this._acceptInputDisposables.dispose(),
				this._actionButtonDisposables.dispose(),
				this._statusBarDisposables.dispose(),
				this._groups.forEach((e) => e.dispose()),
				this.#e.$unregisterSourceControl(this.handle)
		}
	}
R([Ml(100)], Rh.prototype, "eventuallyAddResourceGroups", 1),
	R([Ml(100)], Rh.prototype, "eventuallyUpdateResourceStates", 1)
var L1 = Rh,
	vl = class {
		constructor(e, t, n, r) {
			this._commands = t
			this._extHostDocuments = n
			this.logService = r
			this._sourceControls = new Map()
			this._sourceControlsByExtension = new On()
			this._onDidChangeActiveProvider = new E()
			;(this._proxy = e.getProxy(N.MainThreadSCM)),
				(this._telemetry = e.getProxy(N.MainThreadTelemetry)),
				t.registerArgumentProcessor({
					processArgument: (i) => {
						if (i && i.$mid === 3) {
							let s = this._sourceControls.get(i.sourceControlHandle)
							if (!s) return i
							let a = s.getResourceGroup(i.groupHandle)
							return a ? a.getResourceState(i.handle) : i
						} else if (i && i.$mid === 4) {
							let s = this._sourceControls.get(i.sourceControlHandle)
							return s ? s.getResourceGroup(i.groupHandle) : i
						} else if (i && i.$mid === 5) {
							let s = this._sourceControls.get(i.handle)
							return s || i
						}
						return i
					},
				})
		}
		static {
			this._handlePool = 0
		}
		get onDidChangeActiveProvider() {
			return this._onDidChangeActiveProvider.event
		}
		createSourceControl(e, t, n, r) {
			this.logService.trace("ExtHostSCM#createSourceControl", e.identifier.value, t, n, r),
				this._telemetry.$publicLog2("api/scm/createSourceControl", { extensionId: e.identifier.value })
			let i = vl._handlePool++,
				s = new L1(e, this._extHostDocuments, this._proxy, this._commands, t, n, r)
			this._sourceControls.set(i, s)
			let a = this._sourceControlsByExtension.get(e.identifier) || []
			return a.push(s), this._sourceControlsByExtension.set(e.identifier, a), s
		}
		getLastInputBox(e) {
			this.logService.trace("ExtHostSCM#getLastInputBox", e.identifier.value)
			let t = this._sourceControlsByExtension.get(e.identifier),
				n = t && t[t.length - 1]
			return n && n.inputBox
		}
		$provideOriginalResource(e, t, n) {
			let r = y.revive(t)
			this.logService.trace("ExtHostSCM#$provideOriginalResource", e, r.toString())
			let i = this._sourceControls.get(e)
			return !i || !i.quickDiffProvider || !i.quickDiffProvider.provideOriginalResource
				? Promise.resolve(null)
				: Jt(() => i.quickDiffProvider.provideOriginalResource(r, n)).then((s) => s || null)
		}
		$onInputBoxValueChange(e, t) {
			this.logService.trace("ExtHostSCM#$onInputBoxValueChange", e)
			let n = this._sourceControls.get(e)
			return n && n.inputBox.$onInputBoxValueChange(t), Promise.resolve(void 0)
		}
		$executeResourceCommand(e, t, n, r) {
			this.logService.trace("ExtHostSCM#$executeResourceCommand", e, t, n)
			let i = this._sourceControls.get(e)
			if (!i) return Promise.resolve(void 0)
			let s = i.getResourceGroup(t)
			return s ? s.$executeResourceCommand(n, r) : Promise.resolve(void 0)
		}
		$validateInput(e, t, n) {
			this.logService.trace("ExtHostSCM#$validateInput", e)
			let r = this._sourceControls.get(e)
			return !r || !r.inputBox.validateInput
				? Promise.resolve(void 0)
				: Jt(() => r.inputBox.validateInput(t, n)).then((i) => {
						if (!i) return Promise.resolve(void 0)
						let s = Ce.fromStrict(i.message)
						return s ? Promise.resolve([s, i.type]) : Promise.resolve(void 0)
					})
		}
		$setSelectedSourceControl(e) {
			return (
				this.logService.trace("ExtHostSCM#$setSelectedSourceControl", e),
				e !== void 0 && this._sourceControls.get(e)?.setSelectionState(!0),
				this._selectedSourceControlHandle !== void 0 &&
					this._sourceControls.get(this._selectedSourceControlHandle)?.setSelectionState(!1),
				(this._selectedSourceControlHandle = e),
				Promise.resolve(void 0)
			)
		}
		async $resolveHistoryItemRefsCommonAncestor(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.resolveHistoryItemRefsCommonAncestor(t, n)) ??
					void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", r)
				return
			}
		}
		async $provideHistoryItemRefs(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemRefs(t, n))?.map((s) => ({
						...s,
						icon: Jd(s.icon),
					})) ?? void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$provideHistoryItemRefs", r)
				return
			}
		}
		async $provideHistoryItems(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItems(t, n))?.map((s) =>
						DB(s),
					) ?? void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$provideHistoryItems", r)
				return
			}
		}
		async $provideHistoryItemChanges(e, t, n, r) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemChanges(t, n, r)) ?? void 0
				)
			} catch (i) {
				this.logService.error("ExtHostSCM#$provideHistoryItemChanges", i)
				return
			}
		}
	}
vl = R([S(3, te)], vl)
var JS = class o {
	constructor(e, t) {
		this.uriTransformer = t
		this.providers = new Map()
		this.proxy = e.getProxy(N.MainThreadShare)
	}
	static {
		this.handlePool = 0
	}
	async $provideShare(e, t, n) {
		return (
			(await this.providers
				.get(e)
				?.provideShare({ selection: H.to(t.selection), resourceUri: y.revive(t.resourceUri) }, n)) ?? void 0
		)
	}
	registerShareProvider(e, t) {
		let n = o.handlePool++
		return (
			this.providers.set(n, t),
			this.proxy.$registerShareProvider(n, Fs.from(e, this.uriTransformer), t.id, t.label, t.priority),
			{
				dispose: () => {
					this.proxy.$unregisterShareProvider(n), this.providers.delete(n)
				},
			}
		)
	}
}
var XS = class o {
	constructor(e) {
		this.providers = new Map()
		this.sessions = new Map()
		this.synthesizers = new Map()
		this.proxy = e.getProxy(N.MainThreadSpeech)
	}
	static {
		this.ID_POOL = 1
	}
	async $createSpeechToTextSession(e, t, n) {
		let r = this.providers.get(e)
		if (!r) return
		let i = new Q(),
			s = new _e()
		this.sessions.set(t, s)
		let a = await r.provideSpeechToTextSession(s.token, n ? { language: n } : void 0)
		a &&
			(i.add(
				a.onDidChange((l) => {
					s.token.isCancellationRequested || this.proxy.$emitSpeechToTextEvent(t, l)
				}),
			),
			i.add(s.token.onCancellationRequested(() => i.dispose())))
	}
	async $cancelSpeechToTextSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e)
	}
	async $createTextToSpeechSession(e, t, n) {
		let r = this.providers.get(e)
		if (!r) return
		let i = new Q(),
			s = new _e()
		this.sessions.set(t, s)
		let a = await r.provideTextToSpeechSession(s.token, n ? { language: n } : void 0)
		a &&
			(this.synthesizers.set(t, a),
			i.add(
				a.onDidChange((l) => {
					s.token.isCancellationRequested || this.proxy.$emitTextToSpeechEvent(t, l)
				}),
			),
			i.add(s.token.onCancellationRequested(() => i.dispose())))
	}
	async $synthesizeSpeech(e, t) {
		this.synthesizers.get(e)?.synthesize(t)
	}
	async $cancelTextToSpeechSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e), this.synthesizers.delete(e)
	}
	async $createKeywordRecognitionSession(e, t) {
		let n = this.providers.get(e)
		if (!n) return
		let r = new Q(),
			i = new _e()
		this.sessions.set(t, i)
		let s = await n.provideKeywordRecognitionSession(i.token)
		s &&
			(r.add(
				s.onDidChange((a) => {
					i.token.isCancellationRequested || this.proxy.$emitKeywordRecognitionEvent(t, a)
				}),
			),
			r.add(i.token.onCancellationRequested(() => r.dispose())))
	}
	async $cancelKeywordRecognitionSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e)
	}
	registerProvider(e, t, n) {
		let r = o.ID_POOL++
		return (
			this.providers.set(r, n),
			this.proxy.$registerProvider(r, t, { extension: e, displayName: e.value }),
			q(() => {
				this.proxy.$unregisterProvider(r), this.providers.delete(r)
			})
		)
	}
}
var M1 = class o {
		constructor(e, t, n, r, i, s = 1, a, l) {
			this._onDispose = l
			this._disposed = !1
			this._text = ""
			this._staleCommandRegistrations = new Q()
			if (((this.#e = e), (this.#t = t), i && r)) {
				this._entryId = hF(r.identifier, i)
				let d = n.get(this._entryId)
				d &&
					((s = d.alignLeft ? 1 : 2),
					(a = d.priority),
					(this._visible = !0),
					(this.name = d.name),
					(this.text = d.text),
					(this.tooltip = d.tooltip),
					(this.command = d.command),
					(this.accessibilityInformation = d.accessibilityInformation))
			} else this._entryId = String(o.ID_GEN++)
			;(this._extension = r), (this._id = i), (this._alignment = s), (this._priority = this.validatePriority(a))
		}
		static {
			this.ID_GEN = 0
		}
		static {
			this.ALLOWED_BACKGROUND_COLORS = new Map([
				["statusBarItem.errorBackground", new vs("statusBarItem.errorForeground")],
				["statusBarItem.warningBackground", new vs("statusBarItem.warningForeground")],
			])
		}
		#e
		#t
		validatePriority(e) {
			if (fn(e))
				return e === Number.POSITIVE_INFINITY
					? Number.MAX_VALUE
					: e === Number.NEGATIVE_INFINITY
						? -Number.MAX_VALUE
						: e
		}
		get id() {
			return this._id ?? this._extension.identifier.value
		}
		get entryId() {
			return this._entryId
		}
		get alignment() {
			return this._alignment
		}
		get priority() {
			return this._priority
		}
		get text() {
			return this._text
		}
		get name() {
			return this._name
		}
		get tooltip() {
			return this._tooltip
		}
		get tooltip2() {
			return this._extension && M(this._extension, "statusBarItemTooltip"), this._tooltip2
		}
		get color() {
			return this._color
		}
		get backgroundColor() {
			return this._backgroundColor
		}
		get command() {
			return this._command?.fromApi
		}
		get accessibilityInformation() {
			return this._accessibilityInformation
		}
		set text(e) {
			;(this._text = e), this.update()
		}
		set name(e) {
			;(this._name = e), this.update()
		}
		set tooltip(e) {
			;(this._tooltip = e), this.update()
		}
		set tooltip2(e) {
			this._extension && M(this._extension, "statusBarItemTooltip"), (this._tooltip2 = e), this.update()
		}
		set color(e) {
			;(this._color = e), this.update()
		}
		set backgroundColor(e) {
			e && !o.ALLOWED_BACKGROUND_COLORS.has(e.id) && (e = void 0), (this._backgroundColor = e), this.update()
		}
		set command(e) {
			this._command?.fromApi !== e &&
				(this._latestCommandRegistration &&
					this._staleCommandRegistrations.add(this._latestCommandRegistration),
				(this._latestCommandRegistration = new Q()),
				typeof e == "string"
					? (this._command = {
							fromApi: e,
							internal: this.#t.toInternal({ title: "", command: e }, this._latestCommandRegistration),
						})
					: e
						? (this._command = {
								fromApi: e,
								internal: this.#t.toInternal(e, this._latestCommandRegistration),
							})
						: (this._command = void 0),
				this.update())
		}
		set accessibilityInformation(e) {
			;(this._accessibilityInformation = e), this.update()
		}
		show() {
			;(this._visible = !0), this.update()
		}
		hide() {
			clearTimeout(this._timeoutHandle), (this._visible = !1), this.#e.$disposeEntry(this._entryId)
		}
		update() {
			this._disposed ||
				!this._visible ||
				(clearTimeout(this._timeoutHandle),
				(this._timeoutHandle = setTimeout(() => {
					this._timeoutHandle = void 0
					let e
					this._extension
						? this._id
							? (e = `${this._extension.identifier.value}.${this._id}`)
							: (e = this._extension.identifier.value)
						: (e = this._id)
					let t
					this._name
						? (t = this._name)
						: (t = p(
								"extensionLabel",
								"{0} (Extension)",
								this._extension.displayName || this._extension.name,
							))
					let n = this._color
					this._backgroundColor && (n = o.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id))
					let r, i
					typeof this._tooltip2 == "function"
						? ((r = Ce.fromStrict(this._tooltip)), (i = !0))
						: ((r = Ce.fromStrict(this._tooltip2 ?? this._tooltip)), (i = !1)),
						this.#e.$setEntry(
							this._entryId,
							e,
							this._extension?.identifier.value,
							t,
							this._text,
							r,
							i,
							this._command?.internal,
							n,
							this._backgroundColor,
							this._alignment === 1,
							this._priority,
							this._accessibilityInformation,
						),
						this._staleCommandRegistrations.clear()
				}, 0)))
		}
		dispose() {
			this.hide(), this._onDispose?.(), (this._disposed = !0)
		}
	},
	F1 = class {
		constructor(e) {
			this._messages = []
			;(this._item = e.createStatusBarEntry(void 0, "status.extensionMessage", 1, Number.MIN_VALUE)),
				(this._item.name = p("status.extensionMessage", "Extension Status"))
		}
		dispose() {
			;(this._messages.length = 0), this._item.dispose()
		}
		setMessage(e) {
			let t = { message: e }
			return (
				this._messages.unshift(t),
				this._update(),
				new ye(() => {
					let n = this._messages.indexOf(t)
					n >= 0 && (this._messages.splice(n, 1), this._update())
				})
			)
		}
		_update() {
			this._messages.length > 0
				? ((this._item.text = this._messages[0].message), this._item.show())
				: this._item.hide()
		}
	},
	YS = class {
		constructor(e, t) {
			this._entries = new Map()
			this._existingItems = new Map()
			;(this._proxy = e.getProxy(N.MainThreadStatusBar)),
				(this._commands = t),
				(this._statusMessage = new F1(this))
		}
		$acceptStaticEntries(e) {
			for (let t of e) this._existingItems.set(t.entryId, t)
		}
		async $provideTooltip(e, t) {
			let n = this._entries.get(e)
			if (!n) return
			let r = typeof n.tooltip2 == "function" ? await n.tooltip2(t) : n.tooltip2
			return t.isCancellationRequested ? void 0 : Ce.fromStrict(r)
		}
		createStatusBarEntry(e, t, n, r) {
			let i = new M1(this._proxy, this._commands, this._existingItems, e, t, n, r, () =>
				this._entries.delete(i.entryId),
			)
			return this._entries.set(i.entryId, i), i
		}
		setStatusBarMessage(e, t) {
			let n = this._statusMessage.setMessage(e),
				r
			return (
				typeof t == "number"
					? (r = setTimeout(() => n.dispose(), t))
					: typeof t < "u" &&
						t.then(
							() => n.dispose(),
							() => n.dispose(),
						),
				new ye(() => {
					n.dispose(), clearTimeout(r)
				})
			)
		}
	}
var ZS = class extends $ {
	constructor(t, n) {
		super()
		this._extHostDocumentsAndEditors = n
		this._onDidChangeTextEditorSelection = new E()
		this._onDidChangeTextEditorOptions = new E()
		this._onDidChangeTextEditorVisibleRanges = new E()
		this._onDidChangeTextEditorViewColumn = new E()
		this._onDidChangeTextEditorDiffInformation = new E()
		this._onDidChangeActiveTextEditor = new E()
		this._onDidChangeVisibleTextEditors = new E()
		this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event
		this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event
		this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event
		this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event
		this.onDidChangeTextEditorDiffInformation = this._onDidChangeTextEditorDiffInformation.event
		this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event
		this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event
		;(this._proxy = t.getProxy(N.MainThreadTextEditors)),
			this._register(
				this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((r) =>
					this._onDidChangeVisibleTextEditors.fire(r),
				),
			),
			this._register(
				this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((r) =>
					this._onDidChangeActiveTextEditor.fire(r),
				),
			)
	}
	getActiveTextEditor() {
		return this._extHostDocumentsAndEditors.activeEditor()
	}
	getVisibleTextEditors(t) {
		let n = this._extHostDocumentsAndEditors.allEditors()
		return t ? n : n.map((r) => r.value)
	}
	async showTextDocument(t, n, r) {
		let i
		typeof n == "number"
			? (i = { position: wt.from(n), preserveFocus: r })
			: typeof n == "object"
				? (i = {
						position: wt.from(n.viewColumn),
						preserveFocus: n.preserveFocus,
						selection: typeof n.selection == "object" ? H.from(n.selection) : void 0,
						pinned: typeof n.preview == "boolean" ? !n.preview : void 0,
					})
				: (i = { preserveFocus: !1 })
		let s = await this._proxy.$tryShowTextDocument(t.uri, i),
			a = s && this._extHostDocumentsAndEditors.getEditor(s)
		if (a) return a.value
		throw s
			? new Error(
					`Could NOT open editor for "${t.uri.toString()}" because another editor opened in the meantime.`,
				)
			: new Error(`Could NOT open editor for "${t.uri.toString()}".`)
	}
	createTextEditorDecorationType(t, n) {
		return new tC(this._proxy, t, n).value
	}
	$acceptEditorPropertiesChanged(t, n) {
		let r = this._extHostDocumentsAndEditors.getEditor(t)
		if (!r) throw new Error("unknown text editor")
		if ((n.options && r._acceptOptions(n.options), n.selections)) {
			let i = n.selections.selections.map(Zn.to)
			r._acceptSelections(i)
		}
		if (n.visibleRanges) {
			let i = Ye(n.visibleRanges.map(H.to))
			r._acceptVisibleRanges(i)
		}
		if (
			(n.options &&
				this._onDidChangeTextEditorOptions.fire({
					textEditor: r.value,
					options: { ...n.options, lineNumbers: kd.to(n.options.lineNumbers) },
				}),
			n.selections)
		) {
			let i = xd.fromValue(n.selections.source),
				s = n.selections.selections.map(Zn.to)
			this._onDidChangeTextEditorSelection.fire({ textEditor: r.value, selections: s, kind: i })
		}
		if (n.visibleRanges) {
			let i = Ye(n.visibleRanges.map(H.to))
			this._onDidChangeTextEditorVisibleRanges.fire({ textEditor: r.value, visibleRanges: i })
		}
	}
	$acceptEditorPositionData(t) {
		for (let n in t) {
			let r = this._extHostDocumentsAndEditors.getEditor(n)
			if (!r) throw new Error("Unknown text editor")
			let i = wt.to(t[n])
			r.value.viewColumn !== i &&
				(r._acceptViewColumn(i),
				this._onDidChangeTextEditorViewColumn.fire({ textEditor: r.value, viewColumn: i }))
		}
	}
	$acceptEditorDiffInformation(t, n) {
		let r = this._extHostDocumentsAndEditors.getEditor(t)
		if (!r) throw new Error("unknown text editor")
		if (!n) {
			r._acceptDiffInformation(void 0),
				this._onDidChangeTextEditorDiffInformation.fire({ textEditor: r.value, diffInformation: void 0 })
			return
		}
		let i = this,
			s = n.map((a) => {
				let l = y.revive(a.original),
					d = y.revive(a.modified),
					c = a.changes.map((u) => {
						let [m, f, h, g] = u,
							I
						return (
							m === f ? (I = 1) : h === g ? (I = 2) : (I = 3),
							{
								original: { startLineNumber: m, endLineNumberExclusive: f },
								modified: { startLineNumber: h, endLineNumberExclusive: g },
								kind: I,
							}
						)
					})
				return Object.freeze({
					documentVersion: a.documentVersion,
					original: l,
					modified: d,
					changes: c,
					get isStale() {
						return i._extHostDocumentsAndEditors.getDocument(d)?.version !== a.documentVersion
					},
				})
			})
		r._acceptDiffInformation(s),
			this._onDidChangeTextEditorDiffInformation.fire({ textEditor: r.value, diffInformation: s })
	}
	getDiffInformation(t) {
		return Promise.resolve(this._proxy.$getDiffInformation(t))
	}
}
var wm = class {
	constructor(e) {
		;(this._actual = new ud(2)), (this._onDidChangeActiveColorTheme = new E())
	}
	get activeColorTheme() {
		return this._actual
	}
	$onColorThemeChange(e) {
		let t
		switch (e) {
			case "light":
				t = 1
				break
			case "hcDark":
				t = 3
				break
			case "hcLight":
				t = 4
				break
			default:
				t = 2
		}
		;(this._actual = new ud(t)), this._onDidChangeActiveColorTheme.fire(this._actual)
	}
	get onDidChangeActiveColorTheme() {
		return this._onDidChangeActiveColorTheme.event
	}
}
wm = R([S(0, ie)], wm)
var V$e = O("IExtHostTimeline"),
	eT = class {
		constructor(e, t) {
			this._providers = new Map()
			this._itemsBySourceAndUriMap = new Map()
			;(this._proxy = e.getProxy(N.MainThreadTimeline)),
				t.registerArgumentProcessor({
					processArgument: (n, r) => {
						if (n && n.$mid === 12)
							if (this._providers.get(n.source) && r && nt(r, "timeline")) {
								let i = n.uri === void 0 ? void 0 : y.revive(n.uri)
								return this._itemsBySourceAndUriMap.get(n.source)?.get(KN(i))?.get(n.handle)
							} else return
						return n
					},
				})
		}
		async $getTimeline(e, t, n, r) {
			return this._providers.get(e)?.provider.provideTimeline(y.revive(t), n, r)
		}
		registerTimelineProvider(e, t, n, r) {
			let i = new Q(),
				s = this.convertTimelineItem(t.id, r, i).bind(this),
				a
			t.onDidChange &&
				(a = t.onDidChange(
					(d) => this._proxy.$emitTimelineChangeEvent({ uri: void 0, reset: !0, ...d, id: t.id }),
					this,
				))
			let l = this._itemsBySourceAndUriMap
			return this.registerTimelineProviderCore(
				{
					...t,
					scheme: e,
					onDidChange: void 0,
					async provideTimeline(d, c, u) {
						c?.resetCache && (i.clear(), l.get(t.id)?.clear())
						let m = await t.provideTimeline(d, c, u)
						if (m == null) return
						let f = s(d, c)
						return { ...m, source: t.id, items: m.items.map(f) }
					},
					dispose() {
						for (let d of l.values()) d.get(t.id)?.clear()
						a?.dispose(), i.dispose()
					},
				},
				n,
			)
		}
		convertTimelineItem(e, t, n) {
			return (r, i) => {
				let s
				if (i?.cacheResults) {
					let a = this._itemsBySourceAndUriMap.get(e)
					a === void 0 && ((a = new Map()), this._itemsBySourceAndUriMap.set(e, a))
					let l = KN(r)
					;(s = a.get(l)), s === void 0 && ((s = new Map()), a.set(l, s))
				}
				return (a) => {
					let { iconPath: l, ...d } = a,
						c = `${e}|${a.id ?? a.timestamp}`
					s?.set(c, a)
					let u, m, f
					a.iconPath &&
						(l instanceof Vt
							? (f = { id: l.id, color: l.color })
							: y.isUri(l)
								? ((u = l), (m = l))
								: ({ light: u, dark: m } = l))
					let h
					return (
						en.isMarkdownString(d.tooltip)
							? (h = Ce.from(d.tooltip))
							: Ee(d.tooltip)
								? (h = d.tooltip)
								: en.isMarkdownString(d.detail)
									? (console.warn(
											"Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
										),
										(h = Ce.from(d.detail)))
									: Ee(d.detail) &&
										(console.warn(
											"Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
										),
										(h = d.detail)),
						{
							...d,
							id: d.id ?? void 0,
							handle: c,
							source: e,
							command: a.command ? t.toInternal(a.command, n) : void 0,
							icon: u,
							iconDark: m,
							themeIcon: f,
							tooltip: h,
							accessibilityInformation: a.accessibilityInformation,
						}
					)
				}
			}
		}
		registerTimelineProviderCore(e, t) {
			if (this._providers.get(e.id)) throw new Error(`Timeline Provider ${e.id} already exists.`)
			return (
				this._proxy.$registerTimelineProvider({ id: e.id, label: e.label, scheme: e.scheme }),
				this._providers.set(e.id, { provider: e, extension: t }),
				q(() => {
					for (let r of this._itemsBySourceAndUriMap.values()) r.get(e.id)?.clear()
					this._providers.delete(e.id), this._proxy.$unregisterTimelineProvider(e.id), e.dispose()
				})
			)
		}
	}
function KN(o) {
	return o?.toString()
}
var MB = { IconContribution: "base.contributions.icons" },
	FB
;((e) => {
	function o(t, n) {
		let r = t.defaults
		for (; Yt.isThemeIcon(r); ) {
			let i = Pm.getIcon(r.id)
			if (!i) return
			r = i.defaults
		}
		return r
	}
	e.getDefinition = o
})((FB ||= {}))
var NB
;((t) => {
	function o(n) {
		return {
			weight: n.weight,
			style: n.style,
			src: n.src.map((r) => ({ format: r.format, location: r.location.toString() })),
		}
	}
	t.toJSONObject = o
	function e(n) {
		let r = (i) => (Ee(i) ? i : void 0)
		if (n && Array.isArray(n.src) && n.src.every((i) => Ee(i.format) && Ee(i.location)))
			return {
				weight: r(n.weight),
				style: r(n.style),
				src: n.src.map((i) => ({ format: i.format, location: y.parse(i.location) })),
			}
	}
	t.fromJSONObject = e
})((NB ||= {}))
var UB = /^([\w_-]+)$/
var HB = p("schema.fontId.formatError", "The font ID must only contain letters, numbers, underscores and dashes."),
	N1 = class {
		constructor() {
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this.iconSchema = {
				definitions: {
					icons: {
						type: "object",
						properties: {
							fontId: {
								type: "string",
								description: p(
									"iconDefinition.fontId",
									"The id of the font to use. If not set, the font that is defined first is used.",
								),
								pattern: UB.source,
								patternErrorMessage: HB,
							},
							fontCharacter: {
								type: "string",
								description: p(
									"iconDefinition.fontCharacter",
									"The font character associated with the icon definition.",
								),
							},
						},
						additionalProperties: !1,
						defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }],
					},
				},
				type: "object",
				properties: {},
			}
			this.iconReferenceSchema = {
				type: "string",
				pattern: `^${Yt.iconNameExpression}$`,
				enum: [],
				enumDescriptions: [],
			}
			;(this.iconsById = {}), (this.iconFontsById = {})
		}
		registerIcon(e, t, n, r) {
			let i = this.iconsById[e]
			if (i) {
				if (n && !i.description) {
					;(i.description = n), (this.iconSchema.properties[e].markdownDescription = `${n} $(${e})`)
					let l = this.iconReferenceSchema.enum.indexOf(e)
					l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = n), this._onDidChange.fire()
				}
				return i
			}
			let s = { id: e, description: n, defaults: t, deprecationMessage: r }
			this.iconsById[e] = s
			let a = { $ref: "#/definitions/icons" }
			return (
				r && (a.deprecationMessage = r),
				n && (a.markdownDescription = `${n}: $(${e})`),
				(this.iconSchema.properties[e] = a),
				this.iconReferenceSchema.enum.push(e),
				this.iconReferenceSchema.enumDescriptions.push(n || ""),
				this._onDidChange.fire(),
				{ id: e }
			)
		}
		deregisterIcon(e) {
			delete this.iconsById[e], delete this.iconSchema.properties[e]
			let t = this.iconReferenceSchema.enum.indexOf(e)
			t !== -1 &&
				(this.iconReferenceSchema.enum.splice(t, 1), this.iconReferenceSchema.enumDescriptions.splice(t, 1)),
				this._onDidChange.fire()
		}
		getIcons() {
			return Object.keys(this.iconsById).map((e) => this.iconsById[e])
		}
		getIcon(e) {
			return this.iconsById[e]
		}
		getIconSchema() {
			return this.iconSchema
		}
		getIconReferenceSchema() {
			return this.iconReferenceSchema
		}
		registerIconFont(e, t) {
			let n = this.iconFontsById[e]
			return n || ((this.iconFontsById[e] = t), this._onDidChange.fire(), t)
		}
		deregisterIconFont(e) {
			delete this.iconFontsById[e]
		}
		getIconFont(e) {
			return this.iconFontsById[e]
		}
		toString() {
			let e = (i, s) => i.id.localeCompare(s.id),
				t = (i) => {
					for (; Yt.isThemeIcon(i.defaults); ) i = this.iconsById[i.defaults.id]
					return `codicon codicon-${i ? i.id : ""}`
				},
				n = []
			n.push(
				"| preview     | identifier                        | default codicon ID                | description",
			),
				n.push(
					"| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |",
				)
			let r = Object.keys(this.iconsById).map((i) => this.iconsById[i])
			for (let i of r.filter((s) => !!s.description).sort(e))
				n.push(
					`|<i class="${t(i)}"></i>|${i.id}|${Yt.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ""}|`,
				)
			n.push("| preview     | identifier                        "),
				n.push("| ----------- | --------------------------------- |")
			for (let i of r.filter((s) => !Yt.isThemeIcon(s.defaults)).sort(e))
				n.push(`|<i class="${t(i)}"></i>|${i.id}|`)
			return n.join(`
`)
		}
	},
	Pm = new N1()
yt.add(MB.IconContribution, Pm)
function Ah(o, e, t, n) {
	return Pm.registerIcon(o, e, t, n)
}
function WB() {
	let o = hL()
	for (let e in o) {
		let t = "\\" + o[e].toString(16)
		Pm.registerIcon(e, { fontCharacter: t })
	}
}
WB()
var GN = "vscode://schemas/icons",
	QN = yt.as(od.JSONContribution)
QN.registerSchema(GN, Pm.getIconSchema())
var jN = new Hn(() => QN.notifySchemaChanged(GN), 200)
Pm.onDidChange(() => {
	jN.isScheduled() || jN.schedule()
})
var t6e = Ah("widget-close", ce.close, p("widgetClose", "Icon for the close action in widgets.")),
	n6e = Ah("goto-previous-location", ce.arrowUp, p("previousChangeIcon", "Icon for goto previous editor location.")),
	r6e = Ah("goto-next-location", ce.arrowDown, p("nextChangeIcon", "Icon for goto next editor location.")),
	o6e = Yt.modify(ce.sync, "spin"),
	i6e = Yt.modify(ce.loading, "spin")
var b6e = p("views log", "Views"),
	y6e = Ah("default-view-icon", ce.window, p("defaultViewIcon", "Default view icon.")),
	W1
;((t) => (
	(t.ViewContainersRegistry = "workbench.registry.view.containers"), (t.ViewsRegistry = "workbench.registry.view")
))((W1 ||= {}))
var U1 = class extends $ {
	constructor() {
		super(...arguments)
		this._onDidRegister = this._register(new E())
		this.onDidRegister = this._onDidRegister.event
		this._onDidDeregister = this._register(new E())
		this.onDidDeregister = this._onDidDeregister.event
		this.viewContainers = new Map()
		this.defaultViewContainers = []
	}
	get all() {
		return [...this.viewContainers.values()].flat()
	}
	registerViewContainer(t, n, r) {
		let i = this.get(t.id)
		if (i) return i
		let s = t
		return (
			(s.openCommandActionDescriptor = r?.doNotRegisterOpenCommand
				? void 0
				: (s.openCommandActionDescriptor ?? { id: s.id })),
			KT(this.viewContainers, n, []).push(s),
			r?.isDefault && this.defaultViewContainers.push(s),
			this._onDidRegister.fire({ viewContainer: s, viewContainerLocation: n }),
			s
		)
	}
	deregisterViewContainer(t) {
		for (let n of this.viewContainers.keys()) {
			let r = this.viewContainers.get(n),
				i = r?.indexOf(t)
			if (i !== -1) {
				r?.splice(i, 1),
					r.length === 0 && this.viewContainers.delete(n),
					this._onDidDeregister.fire({ viewContainer: t, viewContainerLocation: n })
				return
			}
		}
	}
	get(t) {
		return this.all.filter((n) => n.id === t)[0]
	}
	getViewContainers(t) {
		return [...(this.viewContainers.get(t) || [])]
	}
	getViewContainerLocation(t) {
		return [...this.viewContainers.keys()].filter(
			(n) => this.getViewContainers(n).filter((r) => r?.id === t.id).length > 0,
		)[0]
	}
	getDefaultViewContainer(t) {
		return this.defaultViewContainers.find((n) => this.getViewContainerLocation(n) === t)
	}
}
yt.add(W1.ViewContainersRegistry, new U1())
function VB(o, e) {
	let t = o.group ?? "9_more",
		n = e.group ?? "9_more"
	return t !== n ? t.localeCompare(n) : (o.order ?? 5) - (e.order ?? 5)
}
var H1 = class extends $ {
	constructor() {
		super(...arguments)
		this._onViewsRegistered = this._register(new E())
		this.onViewsRegistered = this._onViewsRegistered.event
		this._onViewsDeregistered = this._register(new E())
		this.onViewsDeregistered = this._onViewsDeregistered.event
		this._onDidChangeContainer = this._register(new E())
		this.onDidChangeContainer = this._onDidChangeContainer.event
		this._onDidChangeViewWelcomeContent = this._register(new E())
		this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event
		this._viewContainers = []
		this._views = new Map()
		this._viewWelcomeContents = new cc()
	}
	registerViews(t, n) {
		this.registerViews2([{ views: t, viewContainer: n }])
	}
	registerViews2(t) {
		t.forEach(({ views: n, viewContainer: r }) => this.addViews(n, r)), this._onViewsRegistered.fire(t)
	}
	deregisterViews(t, n) {
		let r = this.removeViews(t, n)
		r.length && this._onViewsDeregistered.fire({ views: r, viewContainer: n })
	}
	moveViews(t, n) {
		for (let r of this._views.keys())
			if (r !== n) {
				let i = this.removeViews(t, r)
				i.length && (this.addViews(i, n), this._onDidChangeContainer.fire({ views: i, from: r, to: n }))
			}
	}
	getViews(t) {
		return this._views.get(t) || []
	}
	getView(t) {
		for (let n of this._viewContainers) {
			let r = (this._views.get(n) || []).filter((i) => i.id === t)[0]
			if (r) return r
		}
		return null
	}
	getViewContainer(t) {
		for (let n of this._viewContainers) if ((this._views.get(n) || []).filter((i) => i.id === t)[0]) return n
		return null
	}
	registerViewWelcomeContent(t, n) {
		return (
			this._viewWelcomeContents.add(t, n),
			this._onDidChangeViewWelcomeContent.fire(t),
			q(() => {
				this._viewWelcomeContents.delete(t, n), this._onDidChangeViewWelcomeContent.fire(t)
			})
		)
	}
	registerViewWelcomeContent2(t, n) {
		let r = new Map()
		for (let [i, s] of n)
			this._viewWelcomeContents.add(t, s),
				r.set(
					i,
					q(() => {
						this._viewWelcomeContents.delete(t, s), this._onDidChangeViewWelcomeContent.fire(t)
					}),
				)
		return this._onDidChangeViewWelcomeContent.fire(t), r
	}
	getViewWelcomeContent(t) {
		let n = []
		return this._viewWelcomeContents.forEach(t, (r) => n.push(r)), n.sort(VB)
	}
	addViews(t, n) {
		let r = this._views.get(n)
		r || ((r = []), this._views.set(n, r), this._viewContainers.push(n))
		for (let i of t) {
			if (this.getView(i.id) !== null)
				throw new Error(p("duplicateId", "A view with id '{0}' is already registered", i.id))
			r.push(i)
		}
	}
	removeViews(t, n) {
		let r = this._views.get(n)
		if (!r) return []
		let i = [],
			s = []
		for (let a of r) t.includes(a) ? i.push(a) : s.push(a)
		return (
			i.length &&
				(s.length
					? this._views.set(n, s)
					: (this._views.delete(n), this._viewContainers.splice(this._viewContainers.indexOf(n), 1))),
			i
		)
	}
}
yt.add(W1.ViewsRegistry, new H1())
var I6e = O("viewDescriptorService")
var Eo = class extends Error {
	constructor(t) {
		super(p("treeView.notRegistered", "No tree view with id '{0}' registered.", t))
		this.name = "NoTreeViewError"
	}
	static is(t) {
		return !!t && t.name === "NoTreeViewError"
	}
}
var tT = class {
	constructor() {
		this._dragOperations = new Map()
	}
	removeDragOperationTransfer(e) {
		if (e && this._dragOperations.has(e)) {
			let t = this._dragOperations.get(e)
			return this._dragOperations.delete(e), t
		}
	}
	addDragOperationTransfer(e, t) {
		this._dragOperations.set(e, t)
	}
}
function JN(o, e) {
	if (Ee(o)) return { label: o }
	if (o && typeof o == "object" && typeof o.label == "string") {
		let t
		return (
			Array.isArray(o.highlights) &&
				((t = o.highlights.filter((n) => n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number")),
				(t = t.length ? t : void 0)),
			{ label: o.label, highlights: t }
		)
	}
}
var nT = class extends $ {
		constructor(t, n, r) {
			super()
			this._proxy = t
			this.commands = n
			this.logService = r
			this.treeViews = new Map()
			this.treeDragAndDropService = new tT()
			function i(s) {
				return s && s.$treeViewId && (s.$treeItemHandle || s.$selectedTreeItems || s.$focusedTreeItem)
			}
			n.registerArgumentProcessor({
				processArgument: (s) =>
					i(s)
						? this.convertArgument(s)
						: Array.isArray(s) && s.length > 0
							? s.map((a) => (i(a) ? this.convertArgument(a) : a))
							: s,
			})
		}
		registerTreeDataProvider(t, n, r) {
			let i = this.createTreeView(t, { treeDataProvider: n }, r)
			return { dispose: () => i.dispose() }
		}
		createTreeView(t, n, r) {
			if (!n || !n.treeDataProvider) throw new Error("Options with treeDataProvider is mandatory")
			let i = n.dragAndDropController?.dropMimeTypes ?? [],
				s = n.dragAndDropController?.dragMimeTypes ?? [],
				a = !!n.dragAndDropController?.handleDrag,
				l = !!n.dragAndDropController?.handleDrop,
				d = this.createExtHostTreeView(t, n, r),
				c = {
					showCollapseAll: !!n.showCollapseAll,
					canSelectMany: !!n.canSelectMany,
					dropMimeTypes: i,
					dragMimeTypes: s,
					hasHandleDrag: a,
					hasHandleDrop: l,
					manuallyManageCheckboxes: !!n.manageCheckboxStateManually,
				},
				u = this._proxy.$registerTreeViewDataProvider(t, c),
				m = {
					get onDidCollapseElement() {
						return d.onDidCollapseElement
					},
					get onDidExpandElement() {
						return d.onDidExpandElement
					},
					get selection() {
						return d.selectedElements
					},
					get onDidChangeSelection() {
						return d.onDidChangeSelection
					},
					get activeItem() {
						return M(r, "treeViewActiveItem"), d.focusedElement
					},
					get onDidChangeActiveItem() {
						return M(r, "treeViewActiveItem"), d.onDidChangeActiveItem
					},
					get visible() {
						return d.visible
					},
					get onDidChangeVisibility() {
						return d.onDidChangeVisibility
					},
					get onDidChangeCheckboxState() {
						return d.onDidChangeCheckboxState
					},
					get message() {
						return d.message
					},
					set message(f) {
						Kr(f) && M(r, "treeViewMarkdownMessage"), (d.message = f)
					},
					get title() {
						return d.title
					},
					set title(f) {
						d.title = f
					},
					get description() {
						return d.description
					},
					set description(f) {
						d.description = f
					},
					get badge() {
						return d.badge
					},
					set badge(f) {
						f !== void 0 && Z_.isViewBadge(f)
							? (d.badge = { value: Math.floor(Math.abs(f.value)), tooltip: f.tooltip })
							: f === void 0 && (d.badge = void 0)
					},
					reveal: (f, h) => d.reveal(f, h),
					dispose: async () => {
						await u, this.treeViews.delete(t), d.dispose()
					},
				}
			return this._register(m), m
		}
		async $getChildren(t, n) {
			let r = this.treeViews.get(t)
			if (!r) return Promise.reject(new Eo(t))
			if (!n) {
				let s = await r.getChildren()
				return s ? [[0, ...s]] : void 0
			}
			let i = []
			for (let s = 0; s < n.length; s++) {
				let a = n[s],
					l = await r.getChildren(a)
				l && i.push([s, ...l])
			}
			return i
		}
		async $handleDrop(t, n, r, i, s, a, l, d) {
			let c = this.treeViews.get(t)
			if (!c) return Promise.reject(new Eo(t))
			let u = Rd.toDataTransfer(r, async (m) => (await this._proxy.$resolveDropFileData(t, n, m)).buffer)
			return l === t && d && (await this.addAdditionalTransferItems(u, c, d, s, a)), c.onDrop(u, i, s)
		}
		async addAdditionalTransferItems(t, n, r, i, s) {
			let a = this.treeDragAndDropService.removeDragOperationTransfer(s)
			if (a)
				(await a)?.forEach((l, d) => {
					l && t.set(d, l)
				})
			else if (s && n.handleDrag) {
				let l = n.handleDrag(r, t, i)
				this.treeDragAndDropService.addDragOperationTransfer(s, l), await l
			}
			return t
		}
		async $handleDrag(t, n, r, i) {
			let s = this.treeViews.get(t)
			if (!s) return Promise.reject(new Eo(t))
			let a = await this.addAdditionalTransferItems(new vo(), s, n, i, r)
			if (!(!a || i.isCancellationRequested)) return Rd.from(a)
		}
		async $hasResolve(t) {
			let n = this.treeViews.get(t)
			if (!n) throw new Eo(t)
			return n.hasResolve
		}
		$resolve(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new Eo(t)
			return i.resolveTreeItem(n, r)
		}
		$setExpanded(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new Eo(t)
			i.setExpanded(n, r)
		}
		$setSelectionAndFocus(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new Eo(t)
			i.setSelectionAndFocus(n, r)
		}
		$setVisible(t, n) {
			let r = this.treeViews.get(t)
			if (!r) {
				if (!n) return
				throw new Eo(t)
			}
			r.setVisible(n)
		}
		$changeCheckboxState(t, n) {
			let r = this.treeViews.get(t)
			if (!r) throw new Eo(t)
			r.setCheckboxState(n)
		}
		createExtHostTreeView(t, n, r) {
			let i = this._register(new V1(t, n, this._proxy, this.commands.converter, this.logService, r))
			return this.treeViews.set(t, i), i
		}
		convertArgument(t) {
			let n = this.treeViews.get(t.$treeViewId)
			return n && "$treeItemHandle" in t
				? n.getExtensionElement(t.$treeItemHandle)
				: n && "$focusedTreeItem" in t && t.$focusedTreeItem
					? n.focusedElement
					: null
		}
	},
	V1 = class o extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.viewId = t
			this.proxy = r
			this.commands = i
			this.logService = s
			this.extension = a
			this.roots = void 0
			this.elements = new Map()
			this.nodes = new Map()
			this._visible = !1
			this._selectedHandles = []
			this._focusedHandle = void 0
			this._onDidExpandElement = this._register(new E())
			this.onDidExpandElement = this._onDidExpandElement.event
			this._onDidCollapseElement = this._register(new E())
			this.onDidCollapseElement = this._onDidCollapseElement.event
			this._onDidChangeSelection = this._register(new E())
			this.onDidChangeSelection = this._onDidChangeSelection.event
			this._onDidChangeActiveItem = this._register(new E())
			this.onDidChangeActiveItem = this._onDidChangeActiveItem.event
			this._onDidChangeVisibility = this._register(new E())
			this.onDidChangeVisibility = this._onDidChangeVisibility.event
			this._onDidChangeCheckboxState = this._register(new E())
			this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event
			this._onDidChangeData = this._register(new E())
			this.refreshPromise = Promise.resolve()
			this.refreshQueue = Promise.resolve()
			this._message = ""
			this._title = ""
			this._refreshCancellationSource = new _e()
			if (a.contributes && a.contributes.views)
				for (let u in a.contributes.views)
					for (let m of a.contributes.views[u]) m.id === t && (this._title = m.name)
			;(this.dataProvider = n.treeDataProvider),
				(this.dndController = n.dragAndDropController),
				this.dataProvider.onDidChangeTreeData &&
					this._register(
						this.dataProvider.onDidChangeTreeData((u) => {
							;(Array.isArray(u) && u.length === 0) ||
								this._onDidChangeData.fire({ message: !1, element: u })
						}),
					)
			let l,
				d,
				c = Te.debounce(
					this._onDidChangeData.event,
					(u, m) => (
						u || (u = { message: !1, elements: [] }),
						m.element !== !1 &&
							(l ||
								((l = new Promise((f) => (d = f))),
								(this.refreshPromise = this.refreshPromise.then(() => l))),
							Array.isArray(m.element) ? u.elements.push(...m.element) : u.elements.push(m.element)),
						m.message && (u.message = !0),
						u
					),
					200,
					!0,
				)
			this._register(
				c(({ message: u, elements: m }) => {
					m.length &&
						(this.refreshQueue = this.refreshQueue.then(() => {
							let f = d
							return (l = null), this.refresh(m).then(() => f())
						})),
						u && this.proxy.$setMessage(this.viewId, Ce.fromStrict(this._message) ?? "")
				}),
			)
		}
		static {
			this.LABEL_HANDLE_PREFIX = "0"
		}
		static {
			this.ID_HANDLE_PREFIX = "1"
		}
		get visible() {
			return this._visible
		}
		get selectedElements() {
			return this._selectedHandles.map((t) => this.getExtensionElement(t)).filter((t) => !bt(t))
		}
		get focusedElement() {
			return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0
		}
		async getChildren(t) {
			let n = t ? this.getExtensionElement(t) : void 0
			if (t && !n) return this.logService.error(`No tree item with id '${t}' found.`), Promise.resolve([])
			let r = this.getChildrenNodes(t)
			return r || (r = await this.fetchChildrenNodes(n)), r ? r.map((i) => i.item) : void 0
		}
		getExtensionElement(t) {
			return this.elements.get(t)
		}
		reveal(t, n) {
			n = n || { select: !0, focus: !1 }
			let r = bt(n.select) ? !0 : n.select,
				i = bt(n.focus) ? !1 : n.focus,
				s = bt(n.expand) ? !1 : n.expand
			return typeof this.dataProvider.getParent != "function"
				? Promise.reject(
						new Error(
							"Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method",
						),
					)
				: t
					? this.refreshPromise
							.then(() => this.resolveUnknownParentChain(t))
							.then(
								(a) =>
									this.resolveTreeNode(t, a[a.length - 1]).then((l) =>
										this.proxy.$reveal(
											this.viewId,
											{ item: l.item, parentChain: a.map((d) => d.item) },
											{ select: r, focus: i, expand: s },
										),
									),
								(a) => this.logService.error(a),
							)
					: this.proxy.$reveal(this.viewId, void 0, { select: r, focus: i, expand: s })
		}
		get message() {
			return this._message
		}
		set message(t) {
			;(this._message = t), this._onDidChangeData.fire({ message: !0, element: !1 })
		}
		get title() {
			return this._title
		}
		set title(t) {
			;(this._title = t), this.proxy.$setTitle(this.viewId, t, this._description)
		}
		get description() {
			return this._description
		}
		set description(t) {
			;(this._description = t), this.proxy.$setTitle(this.viewId, this._title, t)
		}
		get badge() {
			return this._badge
		}
		set badge(t) {
			;(this._badge?.value === t?.value && this._badge?.tooltip === t?.tooltip) ||
				((this._badge = wg.from(t)), this.proxy.$setBadge(this.viewId, t))
		}
		setExpanded(t, n) {
			let r = this.getExtensionElement(t)
			r &&
				(n
					? this._onDidExpandElement.fire(Object.freeze({ element: r }))
					: this._onDidCollapseElement.fire(Object.freeze({ element: r })))
		}
		setSelectionAndFocus(t, n) {
			let r = !mn(this._selectedHandles, t)
			this._selectedHandles = t
			let i = this._focusedHandle !== n
			;(this._focusedHandle = n),
				r && this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements })),
				i && this._onDidChangeActiveItem.fire(Object.freeze({ activeItem: this.focusedElement }))
		}
		setVisible(t) {
			t !== this._visible &&
				((this._visible = t), this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible })))
		}
		async setCheckboxState(t) {
			let n = (
				await Promise.all(
					t.map(async (r) => {
						let i = this.getExtensionElement(r.treeItemHandle)
						return i
							? {
									extensionItem: i,
									treeItem: await this.dataProvider.getTreeItem(i),
									newState: r.newState ? 1 : 0,
								}
							: Promise.resolve(void 0)
					}),
				)
			).filter((r) => r !== void 0)
			n.forEach((r) => {
				r.treeItem.checkboxState = r.newState ? 1 : 0
			}),
				this._onDidChangeCheckboxState.fire({ items: n.map((r) => [r.extensionItem, r.newState]) })
		}
		async handleDrag(t, n, r) {
			let i = []
			for (let s of t) {
				let a = this.getExtensionElement(s)
				a && i.push(a)
			}
			if (!(!this.dndController?.handleDrag || i.length === 0))
				return await this.dndController.handleDrag(i, n, r), n
		}
		get hasHandleDrag() {
			return !!this.dndController?.handleDrag
		}
		async onDrop(t, n, r) {
			let i = n ? this.getExtensionElement(n) : void 0
			if (!((!i && n) || !this.dndController?.handleDrop))
				return Jt(() => (this.dndController?.handleDrop ? this.dndController.handleDrop(i, t, r) : void 0))
		}
		get hasResolve() {
			return !!this.dataProvider.resolveTreeItem
		}
		async resolveTreeItem(t, n) {
			if (!this.dataProvider.resolveTreeItem) return
			let r = this.elements.get(t)
			if (r) {
				let i = this.nodes.get(r)
				if (i) {
					let s = (await this.dataProvider.resolveTreeItem(i.extensionItem, r, n)) ?? i.extensionItem
					return (
						this.validateTreeItem(s),
						(i.item.tooltip = this.getTooltip(s.tooltip)),
						(i.item.command = this.getCommand(i.disposableStore, s.command)),
						i.item
					)
				}
			}
		}
		resolveUnknownParentChain(t) {
			return this.resolveParent(t).then((n) =>
				n
					? this.resolveUnknownParentChain(n).then((r) =>
							this.resolveTreeNode(n, r[r.length - 1]).then((i) => (r.push(i), r)),
						)
					: Promise.resolve([]),
			)
		}
		resolveParent(t) {
			let n = this.nodes.get(t)
			return n
				? Promise.resolve(n.parent ? this.elements.get(n.parent.item.handle) : void 0)
				: Jt(() => this.dataProvider.getParent(t))
		}
		resolveTreeNode(t, n) {
			let r = this.nodes.get(t)
			return r
				? Promise.resolve(r)
				: Jt(() => this.dataProvider.getTreeItem(t))
						.then((i) => this.createHandle(t, i, n, !0))
						.then((i) =>
							this.getChildren(n ? n.item.handle : void 0).then(() => {
								let s = this.getExtensionElement(i)
								if (s) {
									let a = this.nodes.get(s)
									if (a) return Promise.resolve(a)
								}
								throw new Error(
									`Cannot resolve tree item for element ${i} from extension ${this.extension.identifier.value}`,
								)
							}),
						)
		}
		getChildrenNodes(t) {
			if (t) {
				let n
				if (typeof t == "string") {
					let r = this.getExtensionElement(t)
					n = r ? this.nodes.get(r) : void 0
				} else n = t
				return (n && n.children) || void 0
			}
			return this.roots
		}
		async fetchChildrenNodes(t) {
			this.clearChildren(t)
			let n = new _e(this._refreshCancellationSource.token)
			try {
				let r = t ? this.nodes.get(t) : void 0,
					i = await this.dataProvider.getChildren(t)
				if (n.token.isCancellationRequested) return
				let s = Ye(i || []),
					a = await Promise.all(Ye(s).map((d) => this.dataProvider.getTreeItem(d)))
				if (n.token.isCancellationRequested) return
				let l = a.map((d, c) => (d ? this.createAndRegisterTreeNode(s[c], d, r) : null))
				return Ye(l)
			} finally {
				n.dispose()
			}
		}
		refresh(t) {
			if (t.some((r) => !r))
				return (
					this._refreshCancellationSource.dispose(!0),
					(this._refreshCancellationSource = new _e()),
					this.clearAll(),
					this.proxy.$refresh(this.viewId)
				)
			{
				let r = this.getHandlesToRefresh(t)
				if (r.length) return this.refreshHandles(r)
			}
			return Promise.resolve(void 0)
		}
		getHandlesToRefresh(t) {
			let n = new Set(),
				r = t.map((s) => this.nodes.get(s))
			for (let s of r)
				if (s && !n.has(s.item.handle)) {
					let a = s
					for (
						;
						a &&
						a.parent &&
						r.findIndex((l) => a && a.parent && l && l.item.handle === a.parent.item.handle) === -1;

					) {
						let l = this.elements.get(a.parent.item.handle)
						a = l ? this.nodes.get(l) : void 0
					}
					a && !a.parent && n.add(s.item.handle)
				}
			let i = []
			return (
				n.forEach((s) => {
					let a = this.elements.get(s)
					if (a) {
						let l = this.nodes.get(a)
						l && (!l.parent || !n.has(l.parent.item.handle)) && i.push(s)
					}
				}),
				i
			)
		}
		refreshHandles(t) {
			let n = {}
			return Promise.all(
				t.map((r) =>
					this.refreshNode(r).then((i) => {
						i && (n[r] = i.item)
					}),
				),
			).then(() => (Object.keys(n).length ? this.proxy.$refresh(this.viewId, n) : void 0))
		}
		refreshNode(t) {
			let n = this.getExtensionElement(t)
			if (n) {
				let r = this.nodes.get(n)
				if (r)
					return (
						this.clearChildren(n),
						Jt(() => this.dataProvider.getTreeItem(n)).then((i) => {
							if (i) {
								let s = this.createTreeNode(n, i, r.parent)
								return this.updateNodeCache(n, s, r, r.parent), r.dispose(), s
							}
							return null
						})
					)
			}
			return Promise.resolve(null)
		}
		createAndRegisterTreeNode(t, n, r) {
			let i = this.createTreeNode(t, n, r)
			if (n.id && this.elements.has(i.item.handle))
				throw new Error(p("treeView.duplicateElement", "Element with id {0} is already registered", n.id))
			return this.addNodeToCache(t, i), this.addNodeToParentCache(i, r), i
		}
		getTooltip(t) {
			return en.isMarkdownString(t) ? Ce.from(t) : t
		}
		getCommand(t, n) {
			return n ? { ...this.commands.toInternal(n, t), originalId: n.command } : void 0
		}
		getCheckbox(t) {
			if (t.checkboxState === void 0) return
			let n, r, i
			return (
				typeof t.checkboxState == "number"
					? (n = t.checkboxState)
					: ((n = t.checkboxState.state),
						(r = t.checkboxState.tooltip),
						(i = t.checkboxState.accessibilityInformation)),
				{ isChecked: n === 1, tooltip: r, accessibilityInformation: i }
			)
		}
		validateTreeItem(t) {
			if (!Ci.isTreeItem(t, this.extension))
				throw new Error(`Extension ${this.extension.identifier.value} has provided an invalid tree item.`)
		}
		createTreeNode(t, n, r) {
			this.validateTreeItem(n)
			let i = this._register(new Q()),
				s = this.createHandle(t, n, r),
				a = this.getLightIconPath(n)
			return {
				item: {
					handle: s,
					parentHandle: r ? r.item.handle : void 0,
					label: JN(n.label, this.extension),
					description: n.description,
					resourceUri: n.resourceUri,
					tooltip: this.getTooltip(n.tooltip),
					command: this.getCommand(i, n.command),
					contextValue: n.contextValue,
					icon: a,
					iconDark: this.getDarkIconPath(n) || a,
					themeIcon: this.getThemeIcon(n),
					collapsibleState: bt(n.collapsibleState) ? 0 : n.collapsibleState,
					accessibilityInformation: n.accessibilityInformation,
					checkbox: this.getCheckbox(n),
				},
				extensionItem: n,
				parent: r,
				children: void 0,
				disposableStore: i,
				dispose() {
					i.dispose()
				},
			}
		}
		getThemeIcon(t) {
			return t.iconPath instanceof Vt ? t.iconPath : void 0
		}
		createHandle(t, { id: n, label: r, resourceUri: i }, s, a) {
			if (n) return `${o.ID_HANDLE_PREFIX}/${n}`
			let l = JN(r, this.extension),
				d = s ? s.item.handle : o.LABEL_HANDLE_PREFIX,
				c = l ? l.label : i ? Ht(i) : ""
			c = c.indexOf("/") !== -1 ? c.replace("/", "//") : c
			let u = this.nodes.has(t) ? this.nodes.get(t).item.handle : void 0,
				m = this.getChildrenNodes(s) || [],
				f,
				h = 0
			do {
				if (((f = `${d}/${h}:${c}`), a || !this.elements.has(f) || u === f)) break
				h++
			} while (h <= m.length)
			return f
		}
		getLightIconPath(t) {
			if (t.iconPath && !(t.iconPath instanceof Vt))
				return typeof t.iconPath == "string" || y.isUri(t.iconPath)
					? this.getIconPath(t.iconPath)
					: this.getIconPath(t.iconPath.light)
		}
		getDarkIconPath(t) {
			if (t.iconPath && !(t.iconPath instanceof Vt) && t.iconPath.dark) return this.getIconPath(t.iconPath.dark)
		}
		getIconPath(t) {
			return y.isUri(t) ? t : y.file(t)
		}
		addNodeToCache(t, n) {
			this.elements.set(n.item.handle, t), this.nodes.set(t, n)
		}
		updateNodeCache(t, n, r, i) {
			this.elements.delete(n.item.handle),
				this.nodes.delete(t),
				n.item.handle !== r.item.handle && this.elements.delete(r.item.handle),
				this.addNodeToCache(t, n)
			let s = this.getChildrenNodes(i) || [],
				a = s.filter((l) => l.item.handle === r.item.handle)[0]
			a && s.splice(s.indexOf(a), 1, n)
		}
		addNodeToParentCache(t, n) {
			n
				? (n.children || (n.children = []), n.children.push(t))
				: (this.roots || (this.roots = []), this.roots.push(t))
		}
		clearChildren(t) {
			if (t) {
				let n = this.nodes.get(t)
				if (n) {
					if (n.children)
						for (let r of n.children) {
							let i = this.elements.get(r.item.handle)
							i && this.clear(i)
						}
					n.children = void 0
				}
			} else this.clearAll()
		}
		clear(t) {
			let n = this.nodes.get(t)
			if (n) {
				if (n.children)
					for (let r of n.children) {
						let i = this.elements.get(r.item.handle)
						i && this.clear(i)
					}
				this.nodes.delete(t), this.elements.delete(n.item.handle), n.dispose()
			}
		}
		clearAll() {
			;(this.roots = void 0), this.elements.clear(), this.nodes.forEach((t) => t.dispose()), this.nodes.clear()
		}
		dispose() {
			super.dispose(),
				this._refreshCancellationSource.dispose(),
				this.clearAll(),
				this.proxy.$disposeTree(this.viewId)
		}
	}
var rT = class o {
	constructor(e) {
		this._openers = new Map()
		this._proxy = e.getProxy(N.MainThreadUriOpeners)
	}
	static {
		this.supportedSchemes = new Set([W.http, W.https])
	}
	registerExternalUriOpener(e, t, n, r) {
		if (this._openers.has(t)) throw new Error(`Opener with id '${t}' already registered`)
		let i = r.schemes.find((s) => !o.supportedSchemes.has(s))
		if (i) throw new Error(`Scheme '${i}' is not supported. Only http and https are currently supported.`)
		return (
			this._openers.set(t, n),
			this._proxy.$registerUriOpener(t, r.schemes, e, r.label),
			q(() => {
				this._openers.delete(t), this._proxy.$unregisterUriOpener(t)
			})
		)
	}
	async $canOpenUri(e, t, n) {
		let r = this._openers.get(e)
		if (!r) throw new Error(`Unknown opener with id: ${e}`)
		let i = y.revive(t)
		return r.canOpenExternalUri(i, n)
	}
	async $openUri(e, t, n) {
		let r = this._openers.get(e)
		if (!r) throw new Error(`Unknown opener id: '${e}'`)
		return r.openExternalUri(y.revive(t.resolvedUri), { sourceUri: y.revive(t.sourceUri) }, n)
	}
}
var oT = class o {
	constructor(e) {
		this.handles = new sr()
		this.handlers = new Map()
		this._proxy = e.getProxy(N.MainThreadUrls)
	}
	static {
		this.HandlePool = 0
	}
	registerUriHandler(e, t) {
		let n = e.identifier
		if (this.handles.has(n)) throw new Error(`Protocol handler already registered for extension ${n}`)
		let r = o.HandlePool++
		return (
			this.handles.add(n),
			this.handlers.set(r, t),
			this._proxy.$registerUriHandler(r, n, e.displayName || e.name),
			q(() => {
				this.handles.delete(n), this.handlers.delete(r), this._proxy.$unregisterUriHandler(r)
			})
		)
	}
	$handleExternalUri(e, t) {
		let n = this.handlers.get(e)
		if (!n) return Promise.resolve(void 0)
		try {
			n.handleUri(y.revive(t))
		} catch (r) {
			Be(r)
		}
		return Promise.resolve(void 0)
	}
	async createAppUri(e) {
		return y.revive(await this._proxy.$createAppUri(e))
	}
}
var B1 = class extends $ {
		constructor(t, n, r, i) {
			super()
			this.#s = void 0
			this.#l = !0
			this.#c = !1
			this.#u = this._register(new E())
			this.onDidDispose = this.#u.event
			this.#p = this._register(new E())
			this.onDidChangeViewState = this.#p.event
			;(this.#e = t),
				(this.#t = n),
				(this.#r = r),
				(this.#n = i.viewType),
				(this.#i = i.panelOptions),
				(this.#s = i.viewColumn),
				(this.#o = i.title),
				(this.#d = i.active)
		}
		#e
		#t
		#n
		#r
		#i
		#o
		#a
		#s
		#l
		#d
		#c
		#u
		#p
		dispose() {
			this.#c ||
				((this.#c = !0), this.#u.fire(), this.#t.$disposeWebview(this.#e), this.#r.dispose(), super.dispose())
		}
		get webview() {
			return this.assertNotDisposed(), this.#r
		}
		get viewType() {
			return this.assertNotDisposed(), this.#n
		}
		get title() {
			return this.assertNotDisposed(), this.#o
		}
		set title(t) {
			this.assertNotDisposed(), this.#o !== t && ((this.#o = t), this.#t.$setTitle(this.#e, t))
		}
		get iconPath() {
			return this.assertNotDisposed(), this.#a
		}
		set iconPath(t) {
			this.assertNotDisposed(),
				this.#a !== t && ((this.#a = t), this.#t.$setIconPath(this.#e, y.isUri(t) ? { light: t, dark: t } : t))
		}
		get options() {
			return this.#i
		}
		get viewColumn() {
			if ((this.assertNotDisposed(), !(typeof this.#s == "number" && this.#s < 0))) return this.#s
		}
		get active() {
			return this.assertNotDisposed(), this.#d
		}
		get visible() {
			return this.assertNotDisposed(), this.#l
		}
		_updateViewState(t) {
			this.#c ||
				((this.active !== t.active || this.visible !== t.visible || this.viewColumn !== t.viewColumn) &&
					((this.#d = t.active),
					(this.#l = t.visible),
					(this.#s = t.viewColumn),
					this.#p.fire({ webviewPanel: this })))
		}
		reveal(t, n) {
			this.assertNotDisposed(),
				this.#t.$reveal(this.#e, { viewColumn: typeof t > "u" ? void 0 : wt.from(t), preserveFocus: !!n })
		}
		assertNotDisposed() {
			if (this.#c) throw new Error("Webview is disposed")
		}
	},
	iT = class o extends $ {
		constructor(t, n, r) {
			super()
			this.webviews = n
			this.workspace = r
			this._webviewPanels = new Map()
			this._serializers = new Map()
			this._proxy = t.getProxy(N.MainThreadWebviewPanels)
		}
		static newHandle() {
			return He()
		}
		dispose() {
			super.dispose(), this._webviewPanels.forEach((t) => t.dispose()), this._webviewPanels.clear()
		}
		createWebviewPanel(t, n, r, i, s = {}) {
			let a = typeof i == "object" ? i.viewColumn : i,
				l = { viewColumn: wt.from(a), preserveFocus: typeof i == "object" && !!i.preserveFocus },
				d = qs(t),
				c = o.newHandle()
			this._proxy.$createWebviewPanel(
				$d(t),
				c,
				n,
				{
					title: r,
					panelOptions: BB(s),
					webviewOptions: ZR(t, this.workspace, s),
					serializeBuffersForPostMessage: d,
				},
				l,
			)
			let u = this.webviews.createNewWebview(c, s, t)
			return this.createNewWebviewPanel(c, n, r, a, s, u, !0)
		}
		$onDidChangeWebviewPanelViewStates(t) {
			let n = Object.keys(t)
			n.sort((r, i) => {
				let s = t[r],
					a = t[i]
				return s.active ? 1 : a.active ? -1 : +s.visible - +a.visible
			})
			for (let r of n) {
				let i = this.getWebviewPanel(r)
				if (!i) continue
				let s = t[r]
				i._updateViewState({ active: s.active, visible: s.visible, viewColumn: wt.to(s.position) })
			}
		}
		async $onDidDisposeWebviewPanel(t) {
			this.getWebviewPanel(t)?.dispose(), this._webviewPanels.delete(t), this.webviews.deleteWebview(t)
		}
		registerWebviewPanelSerializer(t, n, r) {
			if (this._serializers.has(n)) throw new Error(`Serializer for '${n}' already registered`)
			return (
				this._serializers.set(n, { serializer: r, extension: t }),
				this._proxy.$registerSerializer(n, { serializeBuffersForPostMessage: qs(t) }),
				new ye(() => {
					this._serializers.delete(n), this._proxy.$unregisterSerializer(n)
				})
			)
		}
		async $deserializeWebviewPanel(t, n, r, i) {
			let s = this._serializers.get(n)
			if (!s) throw new Error(`No serializer found for '${n}'`)
			let { serializer: a, extension: l } = s,
				d = this.webviews.createNewWebview(t, r.webviewOptions, l),
				c = this.createNewWebviewPanel(t, n, r.title, i, r.panelOptions, d, r.active)
			await a.deserializeWebviewPanel(c, r.state)
		}
		createNewWebviewPanel(t, n, r, i, s, a, l) {
			let d = new B1(t, this._proxy, a, { viewType: n, title: r, viewColumn: i, panelOptions: s, active: l })
			return this._webviewPanels.set(t, d), d
		}
		getWebviewPanel(t) {
			return this._webviewPanels.get(t)
		}
	}
function BB(o) {
	return { enableFindWidget: o.enableFindWidget, retainContextWhenHidden: o.retainContextWhenHidden }
}
var $1 = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.#i = !1
			this.#d = this._register(new E())
			this.onDidChangeVisibility = this.#d.event
			this.#c = this._register(new E())
			this.onDidDispose = this.#c.event
			;(this.#n = r), (this.#a = i), (this.#e = t), (this.#t = n), (this.#r = s), (this.#o = a)
		}
		#e
		#t
		#n
		#r
		#i
		#o
		#a
		#s
		#l
		dispose() {
			this.#i || ((this.#i = !0), this.#c.fire(), this.#r.dispose(), super.dispose())
		}
		#d
		#c
		get title() {
			return this.assertNotDisposed(), this.#a
		}
		set title(t) {
			this.assertNotDisposed(), this.#a !== t && ((this.#a = t), this.#t.$setWebviewViewTitle(this.#e, t))
		}
		get description() {
			return this.assertNotDisposed(), this.#s
		}
		set description(t) {
			this.assertNotDisposed(), this.#s !== t && ((this.#s = t), this.#t.$setWebviewViewDescription(this.#e, t))
		}
		get visible() {
			return this.#o
		}
		get webview() {
			return this.#r
		}
		get viewType() {
			return this.#n
		}
		_setVisible(t) {
			t === this.#o || this.#i || ((this.#o = t), this.#d.fire())
		}
		get badge() {
			return this.assertNotDisposed(), this.#l
		}
		set badge(t) {
			this.assertNotDisposed(),
				!(t?.value === this.#l?.value && t?.tooltip === this.#l?.tooltip) &&
					((this.#l = wg.from(t)), this.#t.$setWebviewViewBadge(this.#e, t))
		}
		show(t) {
			this.assertNotDisposed(), this.#t.$show(this.#e, !!t)
		}
		assertNotDisposed() {
			if (this.#i) throw new Error("Webview is disposed")
		}
	},
	sT = class {
		constructor(e, t) {
			this._extHostWebview = t
			this._viewProviders = new Map()
			this._webviewViews = new Map()
			this._proxy = e.getProxy(N.MainThreadWebviewViews)
		}
		registerWebviewViewProvider(e, t, n, r) {
			if ((gt.logIncoming(0, 0, 0, "registerWebviewViewProvider start: " + t), this._viewProviders.has(t)))
				throw new Error(`View provider for '${t}' already registered`)
			return (
				this._viewProviders.set(t, { provider: n, extension: e }),
				this._proxy.$registerWebviewViewProvider($d(e), t, {
					retainContextWhenHidden: r?.retainContextWhenHidden,
					serializeBuffersForPostMessage: qs(e),
				}),
				new ye(() => {
					this._viewProviders.delete(t), this._proxy.$unregisterWebviewViewProvider(t)
				})
			)
		}
		async $resolveWebviewView(e, t, n, r, i) {
			console.log("resolveWebviewView", e, t, n, r), gt.logIncoming(0, 0, 0, "resolveWebviewView start: " + t)
			let s = this._viewProviders.get(t)
			if (!s) throw new Error(`No view provider found for '${t}'`)
			let { provider: a, extension: l } = s,
				d = this._extHostWebview.createNewWebview(e, {}, l),
				c = new $1(e, this._proxy, t, n, d, !0)
			this._webviewViews.set(e, c), await a.resolveWebviewView(c, { state: r }, i)
		}
		async $onDidChangeWebviewViewVisibility(e, t) {
			this.getWebviewView(e)._setVisible(t)
		}
		async $disposeWebviewView(e) {
			let t = this.getWebviewView(e)
			this._webviewViews.delete(e), t.dispose(), this._extHostWebview.deleteWebview(e)
		}
		getWebviewView(e) {
			let t = this._webviewViews.get(e)
			if (!t) throw new Error("No webview found")
			return t
		}
	}
function XN(o) {
	let e = o.get(Xe),
		t = o.get(uo),
		n = o.get(Li),
		r = o.get(ur),
		i = o.get(Sn),
		s = o.get(sl),
		a = o.get(pn),
		l = o.get(pi),
		d = o.get(ie),
		c = o.get(fp),
		u = o.get(hp),
		m = o.get(co),
		f = o.get(te),
		h = o.get(ol),
		g = o.get($s),
		I = o.get(uC),
		C = o.get(Op),
		T = o.get(Xo),
		w = o.get(Np),
		L = o.get(Pp),
		A = o.get(_p),
		J = o.get(Hd)
	d.set(de.ExtHostFileSystemInfo, t),
		d.set(de.ExtHostLogLevelServiceShape, m),
		d.set(de.ExtHostWorkspace, i),
		d.set(de.ExtHostConfiguration, a),
		d.set(de.ExtHostExtensionService, r),
		d.set(de.ExtHostStorage, c),
		d.set(de.ExtHostTunnelService, h),
		d.set(de.ExtHostWindow, I),
		d.set(de.ExtHostSecretState, C),
		d.set(de.ExtHostTelemetry, s),
		d.set(de.ExtHostEditorTabs, T),
		d.set(de.ExtHostManagedSockets, w),
		d.set(de.ExtHostAuthentication, L),
		d.set(de.ExtHostChatProvider, A)
	let ne = d.set(de.ExtHostDecorations, o.get(Xx)),
		oe = d.set(de.ExtHostDocumentsAndEditors, o.get(eo)),
		Y = d.set(de.ExtHostCommands, o.get(Tn)),
		j = d.set(de.ExtHostTerminalService, o.get(er)),
		K = d.set(de.ExtHostTerminalShellIntegration, o.get(em)),
		qe = d.set(de.ExtHostDebugService, o.get(Qp)),
		Bt = d.set(de.ExtHostSearch, o.get(Yp)),
		vt = d.set(de.ExtHostTask, o.get(zp)),
		ae = d.set(de.ExtHostOutputService, o.get(Jx)),
		Z = d.set(de.ExtHostLocalization, o.get(Mp)),
		se = d.set(de.ExtHostUrls, new oT(d)),
		ee = d.set(de.ExtHostDocuments, new KC(d, oe)),
		fe = d.set(de.ExtHostDocumentContentProviders, new zC(d, oe, f)),
		Ae = d.set(de.ExtHostDocumentSaveParticipant, new qC(f, ee, d.getProxy(N.MainThreadBulkEdits))),
		he = d.set(de.ExtHostNotebook, new VS(d, Y, oe, ee, n, Bt, f)),
		le = d.set(de.ExtHostNotebookDocuments, new $S(he)),
		Et = d.set(de.ExtHostNotebookEditors, new Tm(f, he)),
		_t = d.set(de.ExtHostNotebookKernels, new Em(d, e, he, Y, f)),
		Se = d.set(de.ExtHostNotebookRenderers, new qS(d, he)),
		En = d.set(de.ExtHostNotebookDocumentSaveParticipant, new BS(f, he, d.getProxy(N.MainThreadBulkEdits))),
		Ft = d.set(de.ExtHostEditors, new ZS(d, oe)),
		to = d.set(de.ExtHostTreeViews, new nT(d.getProxy(N.MainThreadTreeViews), Y, f)),
		nc = d.set(de.ExtHostEditorInsets, new FC(d.getProxy(N.MainThreadEditorInsets), Ft, e.remote)),
		ti = d.set(de.ExtHostDiagnostics, new To(d, f, t, oe)),
		no = d.set(de.ExtHostLanguages, new _S(d, ee, Y.converter, l)),
		$e = d.set(de.ExtHostLanguageFeatures, new CS(d, l, ee, Y, ti, f, g, s)),
		mt = d.set(de.ExtHostCodeMapper, new NC(d)),
		zh = d.set(de.ExtHostFileSystem, new JC(d, $e)),
		Cr = d.set(de.ExtHostFileSystemEventService, new tS(d, f, oe)),
		mr = d.set(de.ExtHostQuickOpen, $N(d, i, Y)),
		Il = d.set(de.ExtHostSCM, new vl(d, Y, ee, f)),
		rc = d.set(de.ExtHostQuickDiff, new QS(d, l)),
		Vm = d.set(de.ExtHostShare, new JS(d, l)),
		qh = d.set(de.ExtHostComments, CN(d, Y, ee)),
		oc = d.set(de.ExtHostProgress, new GS(d.getProxy(N.MainThreadProgress))),
		Bm = d.set(de.ExtHostLabelService, new rS(d)),
		xl = d.set(de.ExtHostTheming, new wm(d)),
		Sr = d.set(de.ExtHostTimeline, new eT(d, Y)),
		Bi = d.set(de.ExtHostWebviews, new HC(d, e.remote, i, f, g)),
		Nt = d.set(de.ExtHostWebviewPanels, new iT(d, Bi, i)),
		qn = d.set(de.ExtHostCustomEditors, new VC(d, ee, u, Bi, Nt)),
		MT = d.set(de.ExtHostWebviewViews, new sT(d, Bi)),
		Js = d.set(de.ExtHostTesting, o.get(zs)),
		ic = d.set(de.ExtHostUriOpeners, new rT(d)),
		$m = d.set(de.ExtHostProfileContentHandlers, new KS(d))
	d.set(de.ExtHostInteractive, new nS(d, he, oe, Y, f))
	let k = d.set(de.ExtHostLanguageModelTools, new PS(d, A)),
		U = d.set(de.ExtHostChatAgents2, new AC(d, f, Y, ee, A, ti, k)),
		B = d.set(de.ExtHostAiRelatedInformation, new DC(d)),
		ve = d.set(de.ExtHostAiEmbeddingVector, new GC(d)),
		Me = d.set(de.ExtHostStatusBar, new YS(d, Y.converter)),
		hn = d.set(de.ExtHostSpeech, new XS(d)),
		it = d.set(de.ExtHostEmbeddings, new jC(d))
	d.set(de.ExtHostMcp, o.get(Hd))
	let nr = Object.values(de)
	d.assertRegistered(nr)
	let tn = new pm(d, oe),
		Mn = new MC(d),
		Tr = new xm(d, f),
		jt = new $C(d),
		wn = new LC(d)
	return (
		RC.register(Y),
		function (P, vn, Ne) {
			function X(b) {
				return (x, _, Oe) => {
					let Dt = b((_n) => {
						try {
							x.call(_, _n)
						} catch (pH) {
							Qh(new Fc(P.identifier, pH, "FAILED to handle event"))
						}
					})
					return Oe?.push(Dt), Dt
				}
			}
			let xe = (function () {
					let b = !P.isUnderDevelopment
					function x() {
						b ||
							(f.info(
								`Extension '${P.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`,
							),
							(b = !0))
					}
					return function _(Oe) {
						if (Array.isArray(Oe)) Oe.forEach(_)
						else if (typeof Oe == "string") x()
						else {
							let Dt = Oe
							typeof Dt.scheme > "u" && x(),
								typeof Dt.exclusive == "boolean" && M(P, "documentFiltersExclusive")
						}
						return Oe
					}
				})(),
				Ut = {
					getSession(b, x, _) {
						return (
							((typeof _?.forceNewSession == "object" && _.forceNewSession.learnMore) ||
								(typeof _?.createIfNone == "object" && _.createIfNone.learnMore)) &&
								M(P, "authLearnMore"),
							L.getSession(P, b, x, _)
						)
					},
					getAccounts(b) {
						return L.getAccounts(b)
					},
					async hasSession(b, x) {
						return M(P, "authSession"), !!(await L.getSession(P, b, x, { silent: !0 }))
					},
					get onDidChangeSessions() {
						return X(L.getExtensionScopedSessionsEvent(P.identifier.value))
					},
					registerAuthenticationProvider(b, x, _, Oe) {
						return L.registerAuthenticationProvider(b, x, _, Oe)
					},
				},
				Pn = {
					registerCommand(b, x, _) {
						return Y.registerCommand(!0, b, x, _, void 0, P)
					},
					registerTextEditorCommand(b, x, _) {
						return Y.registerCommand(
							!0,
							b,
							(...Oe) => {
								let Dt = Ft.getActiveTextEditor()
								if (!Dt) {
									f.warn("Cannot execute " + b + " because there is no active text editor.")
									return
								}
								return Dt.edit((_n) => {
									x.apply(_, [Dt, _n, ...Oe])
								}).then(
									(_n) => {
										_n || f.warn("Edits from command " + b + " were not applied.")
									},
									(_n) => {
										f.warn("An error occurred while running command " + b, _n)
									},
								)
							},
							void 0,
							void 0,
							P,
						)
					},
					registerDiffInformationCommand: (b, x, _) => (
						M(P, "diffCommand"),
						Y.registerCommand(
							!0,
							b,
							async (...Oe) => {
								let Dt = oe.activeEditor(!0)
								if (!Dt) {
									f.warn("Cannot execute " + b + " because there is no active text editor.")
									return
								}
								let _n = await Ft.getDiffInformation(Dt.id)
								x.apply(_, [_n, ...Oe])
							},
							void 0,
							void 0,
							P,
						)
					),
					executeCommand(b, ...x) {
						return Y.executeCommand(b, ...x)
					},
					getCommands(b = !1) {
						return Y.getCommands(b)
					},
				},
				zm = {
					get machineId() {
						return e.telemetryInfo.machineId
					},
					get sessionId() {
						return e.telemetryInfo.sessionId
					},
					get language() {
						return e.environment.appLanguage
					},
					get appName() {
						return e.environment.appName
					},
					get appRoot() {
						return e.environment.appRoot?.fsPath ?? ""
					},
					get appHost() {
						return e.environment.appHost
					},
					get uriScheme() {
						return e.environment.appUriScheme
					},
					get clipboard() {
						return Mn.value
					},
					get shell() {
						return j.getDefaultShell(!1)
					},
					get onDidChangeShell() {
						return X(j.onDidChangeShell)
					},
					get isTelemetryEnabled() {
						return s.getTelemetryConfiguration()
					},
					get onDidChangeTelemetryEnabled() {
						return X(s.onDidChangeTelemetryEnabled)
					},
					get telemetryConfiguration() {
						return M(P, "telemetry"), s.getTelemetryDetails()
					},
					get onDidChangeTelemetryConfiguration() {
						return M(P, "telemetry"), X(s.onDidChangeTelemetryConfiguration)
					},
					get isNewAppInstall() {
						return Pk(e.telemetryInfo.firstSessionDate)
					},
					createTelemetryLogger(b, x) {
						return qg.validateSender(b), s.instantiateLogger(P, b, x)
					},
					openExternal(b, x) {
						return I.openUri(b, {
							allowTunneling: !!e.remote.authority,
							allowContributedOpeners: x?.allowContributedOpeners,
						})
					},
					async asExternalUri(b) {
						if (b.scheme === e.environment.appUriScheme) return se.createAppUri(b)
						try {
							return await I.asExternalUri(b, { allowTunneling: !!e.remote.authority })
						} catch (x) {
							if (kv(b, W.http) || kv(b, W.https)) return b
							throw x
						}
					},
					get remoteName() {
						return zl(e.remote.authority)
					},
					get remoteAuthority() {
						return M(P, "resolvers"), e.remote.authority
					},
					get uiKind() {
						return e.uiKind
					},
					get logLevel() {
						return f.getLevel()
					},
					get onDidChangeLogLevel() {
						return X(f.onDidChangeLogLevel)
					},
					get appQuality() {
						return M(P, "resolvers"), e.quality
					},
					get appCommit() {
						return M(P, "resolvers"), e.commit
					},
				}
			e.environment.extensionTestsLocationURI || Object.freeze(zm)
			let Cl = {
					createTestController(b, x, _) {
						return Js.createTestController(P, b, x, _)
					},
					createTestObserver() {
						return M(P, "testObserver"), Js.createTestObserver()
					},
					runTests(b) {
						return M(P, "testObserver"), Js.runTests(b)
					},
					registerTestFollowupProvider(b) {
						return M(P, "testObserver"), Js.registerTestFollowupProvider(b)
					},
					get onDidChangeTestResults() {
						return M(P, "testObserver"), X(Js.onResultsChanged)
					},
					get testResults() {
						return M(P, "testObserver"), Js.results
					},
				},
				ni = e.remote.isRemote ? 2 : 1,
				YU = {
					getExtension(b, x) {
						nt(P, "extensionsAny") || (x = !1)
						let _ = vn.mine.getExtensionDescription(b)
						if (_) return new ll(r, P.identifier, _, ni, !1)
						if (x) {
							let Oe = vn.all.getExtensionDescription(b)
							if (Oe) return new ll(r, P.identifier, Oe, ni, !0)
						}
					},
					get all() {
						let b = []
						for (let x of vn.mine.getAllExtensionDescriptions()) b.push(new ll(r, P.identifier, x, ni, !1))
						return b
					},
					get allAcrossExtensionHosts() {
						M(P, "extensionsAny")
						let b = new sr(vn.mine.getAllExtensionDescriptions().map((_) => _.identifier)),
							x = []
						for (let _ of vn.all.getAllExtensionDescriptions()) {
							let Oe = !b.has(_.identifier)
							x.push(new ll(r, P.identifier, _, ni, Oe))
						}
						return x
					},
					get onDidChange() {
						return nt(P, "extensionsAny")
							? X(Te.any(vn.mine.onDidChange, vn.all.onDidChange))
							: X(vn.mine.onDidChange)
					},
				},
				ZU = {
					createDiagnosticCollection(b) {
						return ti.createDiagnosticCollection(P.identifier, b)
					},
					get onDidChangeDiagnostics() {
						return X(ti.onDidChangeDiagnostics)
					},
					getDiagnostics: (b) => ti.getDiagnostics(b),
					getLanguages() {
						return no.getLanguages()
					},
					setTextDocumentLanguage(b, x) {
						return no.changeLanguage(b.uri, x)
					},
					match(b, x) {
						let _ = BD.from(b),
							Oe
						return (
							BR(_) &&
								(Oe = he.notebookDocuments.find((Dt) =>
									Dt.apiNotebook.getCells().find((_n) => _n.document === x),
								)?.apiNotebook),
							VR(_, x.uri, x.languageId, !0, Oe?.uri, Oe?.notebookType)
						)
					},
					registerCodeActionsProvider(b, x, _) {
						return $e.registerCodeActionProvider(P, xe(b), x, _)
					},
					registerDocumentPasteEditProvider(b, x, _) {
						return $e.registerDocumentPasteEditProvider(P, xe(b), x, _)
					},
					registerCodeLensProvider(b, x) {
						return $e.registerCodeLensProvider(P, xe(b), x)
					},
					registerDefinitionProvider(b, x) {
						return $e.registerDefinitionProvider(P, xe(b), x)
					},
					registerDeclarationProvider(b, x) {
						return $e.registerDeclarationProvider(P, xe(b), x)
					},
					registerImplementationProvider(b, x) {
						return $e.registerImplementationProvider(P, xe(b), x)
					},
					registerTypeDefinitionProvider(b, x) {
						return $e.registerTypeDefinitionProvider(P, xe(b), x)
					},
					registerHoverProvider(b, x) {
						return $e.registerHoverProvider(P, xe(b), x, P.identifier)
					},
					registerEvaluatableExpressionProvider(b, x) {
						return $e.registerEvaluatableExpressionProvider(P, xe(b), x, P.identifier)
					},
					registerInlineValuesProvider(b, x) {
						return $e.registerInlineValuesProvider(P, xe(b), x, P.identifier)
					},
					registerDocumentHighlightProvider(b, x) {
						return $e.registerDocumentHighlightProvider(P, xe(b), x)
					},
					registerMultiDocumentHighlightProvider(b, x) {
						return $e.registerMultiDocumentHighlightProvider(P, xe(b), x)
					},
					registerLinkedEditingRangeProvider(b, x) {
						return $e.registerLinkedEditingRangeProvider(P, xe(b), x)
					},
					registerReferenceProvider(b, x) {
						return $e.registerReferenceProvider(P, xe(b), x)
					},
					registerRenameProvider(b, x) {
						return $e.registerRenameProvider(P, xe(b), x)
					},
					registerNewSymbolNamesProvider(b, x) {
						return M(P, "newSymbolNamesProvider"), $e.registerNewSymbolNamesProvider(P, xe(b), x)
					},
					registerDocumentSymbolProvider(b, x, _) {
						return $e.registerDocumentSymbolProvider(P, xe(b), x, _)
					},
					registerWorkspaceSymbolProvider(b) {
						return $e.registerWorkspaceSymbolProvider(P, b)
					},
					registerDocumentFormattingEditProvider(b, x) {
						return $e.registerDocumentFormattingEditProvider(P, xe(b), x)
					},
					registerDocumentRangeFormattingEditProvider(b, x) {
						return $e.registerDocumentRangeFormattingEditProvider(P, xe(b), x)
					},
					registerOnTypeFormattingEditProvider(b, x, _, ...Oe) {
						return $e.registerOnTypeFormattingEditProvider(P, xe(b), x, [_].concat(Oe))
					},
					registerDocumentSemanticTokensProvider(b, x, _) {
						return $e.registerDocumentSemanticTokensProvider(P, xe(b), x, _)
					},
					registerDocumentRangeSemanticTokensProvider(b, x, _) {
						return $e.registerDocumentRangeSemanticTokensProvider(P, xe(b), x, _)
					},
					registerSignatureHelpProvider(b, x, _, ...Oe) {
						return typeof _ == "object"
							? $e.registerSignatureHelpProvider(P, xe(b), x, _)
							: $e.registerSignatureHelpProvider(P, xe(b), x, typeof _ > "u" ? [] : [_, ...Oe])
					},
					registerCompletionItemProvider(b, x, ..._) {
						return $e.registerCompletionItemProvider(P, xe(b), x, _)
					},
					registerInlineCompletionItemProvider(b, x, _) {
						return (
							x.handleDidShowCompletionItem && M(P, "inlineCompletionsAdditions"),
							x.handleDidPartiallyAcceptCompletionItem && M(P, "inlineCompletionsAdditions"),
							_ && M(P, "inlineCompletionsAdditions"),
							$e.registerInlineCompletionsProvider(P, xe(b), x, _)
						)
					},
					registerInlineEditProvider(b, x) {
						return M(P, "inlineEdit"), $e.registerInlineEditProvider(P, xe(b), x)
					},
					registerDocumentLinkProvider(b, x) {
						return $e.registerDocumentLinkProvider(P, xe(b), x)
					},
					registerColorProvider(b, x) {
						return $e.registerColorProvider(P, xe(b), x)
					},
					registerFoldingRangeProvider(b, x) {
						return $e.registerFoldingRangeProvider(P, xe(b), x)
					},
					registerSelectionRangeProvider(b, x) {
						return $e.registerSelectionRangeProvider(P, b, x)
					},
					registerCallHierarchyProvider(b, x) {
						return $e.registerCallHierarchyProvider(P, b, x)
					},
					registerTypeHierarchyProvider(b, x) {
						return $e.registerTypeHierarchyProvider(P, b, x)
					},
					setLanguageConfiguration: (b, x) => $e.setLanguageConfiguration(P, b, x),
					getTokenInformationAtPosition(b, x) {
						return M(P, "tokenInformation"), no.tokenAtPosition(b, x)
					},
					registerInlayHintsProvider(b, x) {
						return $e.registerInlayHintsProvider(P, b, x)
					},
					createLanguageStatusItem(b, x) {
						return no.createLanguageStatusItem(P, b, x)
					},
					registerDocumentDropEditProvider(b, x, _) {
						return $e.registerDocumentOnDropEditProvider(P, b, x, _)
					},
				},
				eH = {
					get activeTextEditor() {
						return Ft.getActiveTextEditor()
					},
					get visibleTextEditors() {
						return Ft.getVisibleTextEditors()
					},
					get activeTerminal() {
						return j.activeTerminal
					},
					get terminals() {
						return j.terminals
					},
					async showTextDocument(b, x, _) {
						y.isUri(b) &&
							b.scheme === W.vscodeRemote &&
							!b.authority &&
							g.report(
								"workspace.showTextDocument",
								P,
								"A URI of 'vscode-remote' scheme requires an authority.",
							)
						let Oe = await (y.isUri(b) ? Promise.resolve(b0.openTextDocument(b)) : Promise.resolve(b))
						return Ft.showTextDocument(Oe, x, _)
					},
					createTextEditorDecorationType(b) {
						return Ft.createTextEditorDecorationType(P, b)
					},
					onDidChangeActiveTextEditor(b, x, _) {
						return X(Ft.onDidChangeActiveTextEditor)(b, x, _)
					},
					onDidChangeVisibleTextEditors(b, x, _) {
						return X(Ft.onDidChangeVisibleTextEditors)(b, x, _)
					},
					onDidChangeTextEditorSelection(b, x, _) {
						return X(Ft.onDidChangeTextEditorSelection)(b, x, _)
					},
					onDidChangeTextEditorOptions(b, x, _) {
						return X(Ft.onDidChangeTextEditorOptions)(b, x, _)
					},
					onDidChangeTextEditorVisibleRanges(b, x, _) {
						return X(Ft.onDidChangeTextEditorVisibleRanges)(b, x, _)
					},
					onDidChangeTextEditorViewColumn(b, x, _) {
						return X(Ft.onDidChangeTextEditorViewColumn)(b, x, _)
					},
					onDidChangeTextEditorDiffInformation(b, x, _) {
						return M(P, "textEditorDiffInformation"), X(Ft.onDidChangeTextEditorDiffInformation)(b, x, _)
					},
					onDidCloseTerminal(b, x, _) {
						return X(j.onDidCloseTerminal)(b, x, _)
					},
					onDidOpenTerminal(b, x, _) {
						return X(j.onDidOpenTerminal)(b, x, _)
					},
					onDidChangeActiveTerminal(b, x, _) {
						return X(j.onDidChangeActiveTerminal)(b, x, _)
					},
					onDidChangeTerminalDimensions(b, x, _) {
						return M(P, "terminalDimensions"), X(j.onDidChangeTerminalDimensions)(b, x, _)
					},
					onDidChangeTerminalState(b, x, _) {
						return X(j.onDidChangeTerminalState)(b, x, _)
					},
					onDidWriteTerminalData(b, x, _) {
						return M(P, "terminalDataWriteEvent"), X(j.onDidWriteTerminalData)(b, x, _)
					},
					onDidExecuteTerminalCommand(b, x, _) {
						return M(P, "terminalExecuteCommandEvent"), X(j.onDidExecuteTerminalCommand)(b, x, _)
					},
					onDidChangeTerminalShellIntegration(b, x, _) {
						return X(K.onDidChangeTerminalShellIntegration)(b, x, _)
					},
					onDidStartTerminalShellExecution(b, x, _) {
						return X(K.onDidStartTerminalShellExecution)(b, x, _)
					},
					onDidEndTerminalShellExecution(b, x, _) {
						return X(K.onDidEndTerminalShellExecution)(b, x, _)
					},
					get state() {
						return I.getState()
					},
					onDidChangeWindowState(b, x, _) {
						return X(I.onDidChangeWindowState)(b, x, _)
					},
					showInformationMessage(b, ...x) {
						return Tr.showMessage(P, It.Info, b, x[0], x.slice(1))
					},
					showWarningMessage(b, ...x) {
						return Tr.showMessage(P, It.Warning, b, x[0], x.slice(1))
					},
					showErrorMessage(b, ...x) {
						return Tr.showMessage(P, It.Error, b, x[0], x.slice(1))
					},
					showQuickPick(b, x, _) {
						return mr.showQuickPick(P, b, x, _)
					},
					showWorkspaceFolderPick(b) {
						return mr.showWorkspaceFolderPick(b)
					},
					showInputBox(b, x) {
						return mr.showInput(b, x)
					},
					showOpenDialog(b) {
						return jt.showOpenDialog(b)
					},
					showSaveDialog(b) {
						return jt.showSaveDialog(b)
					},
					createStatusBarItem(b, x, _) {
						let Oe, Dt, _n
						return (
							typeof b == "string" ? ((Oe = b), (Dt = x), (_n = _)) : ((Dt = b), (_n = x)),
							Me.createStatusBarEntry(P, Oe, Dt, _n)
						)
					},
					setStatusBarMessage(b, x) {
						return Me.setStatusBarMessage(b, x)
					},
					withScmProgress(b) {
						return (
							g.report("window.withScmProgress", P, "Use 'withProgress' instead."),
							oc.withProgress(P, { location: 1 }, (x, _) => b({ report(Oe) {} }))
						)
					},
					withProgress(b, x) {
						return oc.withProgress(P, b, x)
					},
					createOutputChannel(b, x) {
						return ae.createOutputChannel(b, x, P)
					},
					createWebviewPanel(b, x, _, Oe) {
						return Nt.createWebviewPanel(P, b, x, _, Oe)
					},
					createWebviewTextEditorInset(b, x, _, Oe) {
						return M(P, "editorInsets"), nc.createWebviewEditorInset(b, x, _, Oe, P)
					},
					createTerminal(b, x, _) {
						return typeof b == "object"
							? "pty" in b
								? j.createExtensionTerminal(b)
								: j.createTerminalFromOptions(b)
							: j.createTerminal(b, x, _)
					},
					registerTerminalLinkProvider(b) {
						return j.registerLinkProvider(b)
					},
					registerTerminalProfileProvider(b, x) {
						return j.registerProfileProvider(P, b, x)
					},
					registerTerminalCompletionProvider(b, ...x) {
						return M(P, "terminalCompletionProvider"), j.registerTerminalCompletionProvider(P, b, ...x)
					},
					registerTerminalQuickFixProvider(b, x) {
						return (
							M(P, "terminalQuickFixProvider"),
							j.registerTerminalQuickFixProvider(b, P.identifier.value, x)
						)
					},
					registerTreeDataProvider(b, x) {
						return to.registerTreeDataProvider(b, x, P)
					},
					createTreeView(b, x) {
						return to.createTreeView(b, x, P)
					},
					registerWebviewPanelSerializer: (b, x) => Nt.registerWebviewPanelSerializer(P, b, x),
					registerCustomEditorProvider: (b, x, _ = {}) => qn.registerCustomEditorProvider(P, b, x, _),
					registerFileDecorationProvider(b) {
						return ne.registerFileDecorationProvider(b, P)
					},
					registerUriHandler(b) {
						return se.registerUriHandler(P, b)
					},
					createQuickPick() {
						return mr.createQuickPick(P)
					},
					createInputBox() {
						return mr.createInputBox(P)
					},
					get activeColorTheme() {
						return xl.activeColorTheme
					},
					onDidChangeActiveColorTheme(b, x, _) {
						return X(xl.onDidChangeActiveColorTheme)(b, x, _)
					},
					registerWebviewViewProvider(b, x, _) {
						return MT.registerWebviewViewProvider(P, b, x, _?.webviewOptions)
					},
					get activeNotebookEditor() {
						return he.activeNotebookEditor
					},
					onDidChangeActiveNotebookEditor(b, x, _) {
						return X(he.onDidChangeActiveNotebookEditor)(b, x, _)
					},
					get visibleNotebookEditors() {
						return he.visibleNotebookEditors
					},
					get onDidChangeVisibleNotebookEditors() {
						return X(he.onDidChangeVisibleNotebookEditors)
					},
					onDidChangeNotebookEditorSelection(b, x, _) {
						return X(Et.onDidChangeNotebookEditorSelection)(b, x, _)
					},
					onDidChangeNotebookEditorVisibleRanges(b, x, _) {
						return X(Et.onDidChangeNotebookEditorVisibleRanges)(b, x, _)
					},
					showNotebookDocument(b, x) {
						return he.showNotebookDocument(b, x)
					},
					registerExternalUriOpener(b, x, _) {
						return M(P, "externalUriOpener"), ic.registerExternalUriOpener(P.identifier, b, x, _)
					},
					registerProfileContentHandler(b, x) {
						return M(P, "profileContentHandlers"), $m.registerProfileContentHandler(P, b, x)
					},
					registerQuickDiffProvider(b, x, _, Oe) {
						return M(P, "quickDiffProvider"), rc.registerQuickDiffProvider(xe(b), x, _, Oe)
					},
					get tabGroups() {
						return T.tabGroups
					},
					registerShareProvider(b, x) {
						return M(P, "shareProvider"), Vm.registerShareProvider(xe(b), x)
					},
					get nativeHandle() {
						return M(P, "nativeWindowHandle"), I.nativeHandle
					},
					createChatStatusItem: (b) => (M(P, "chatStatusItem"), wn.createChatStatusItem(P, b)),
				},
				b0 = {
					get rootPath() {
						return (
							g.report(
								"workspace.rootPath",
								P,
								"Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath",
							),
							i.getPath()
						)
					},
					set rootPath(b) {
						throw new wo("rootPath")
					},
					getWorkspaceFolder(b) {
						return i.getWorkspaceFolder(b)
					},
					get workspaceFolders() {
						return i.getWorkspaceFolders()
					},
					get name() {
						return i.name
					},
					set name(b) {
						throw new wo("name")
					},
					get workspaceFile() {
						return i.workspaceFile
					},
					set workspaceFile(b) {
						throw new wo("workspaceFile")
					},
					updateWorkspaceFolders: (b, x, ..._) => i.updateWorkspaceFolders(P, b, x || 0, ..._),
					onDidChangeWorkspaceFolders: function (b, x, _) {
						return X(i.onDidChangeWorkspace)(b, x, _)
					},
					asRelativePath: (b, x) => i.getRelativePath(b, x),
					findFiles: (b, x, _, Oe) => i.findFiles(b, x, _, P.identifier, Oe),
					findFiles2: (b, x, _) => (M(P, "findFiles2"), i.findFiles2(b, x, P.identifier, _)),
					findTextInFiles: (b, x, _, Oe) => {
						M(P, "findTextInFiles")
						let Dt, _n
						return (
							typeof x == "object" ? ((Dt = x), (_n = _)) : ((Dt = {}), (_n = x), (Oe = _)),
							i.findTextInFiles(b, Dt || {}, _n, P.identifier, Oe)
						)
					},
					findTextInFiles2: (b, x, _) => (
						M(P, "findTextInFiles2"), M(P, "textSearchProvider2"), i.findTextInFiles2(b, x, P.identifier, _)
					),
					save: (b) => i.save(b),
					saveAs: (b) => i.saveAs(b),
					saveAll: (b) => i.saveAll(b),
					applyEdit(b, x) {
						return tn.applyWorkspaceEdit(b, P, x)
					},
					createFileSystemWatcher: (b, x, _, Oe) => {
						let Dt = { ignoreCreateEvents: !!x, ignoreChangeEvents: !!_, ignoreDeleteEvents: !!Oe }
						return Cr.createFileSystemWatcher(i, Ne, P, b, Dt)
					},
					get textDocuments() {
						return ee.getAllDocumentData().map((b) => b.document)
					},
					set textDocuments(b) {
						throw new wo("textDocuments")
					},
					openTextDocument(b, x) {
						let _
						if (
							((x = x ?? b),
							typeof x?.encoding == "string" && M(P, "textDocumentEncoding"),
							typeof b == "string")
						)
							_ = Promise.resolve(y.file(b))
						else if (y.isUri(b)) _ = Promise.resolve(b)
						else if (!x || typeof x == "object") _ = ee.createDocumentData(x)
						else throw new Error("illegal argument - uriOrFileNameOrOptions")
						return _.then(
							(Oe) => (
								f.trace(`openTextDocument from ${P.identifier}`),
								Oe.scheme === W.vscodeRemote &&
									!Oe.authority &&
									g.report(
										"workspace.openTextDocument",
										P,
										"A URI of 'vscode-remote' scheme requires an authority.",
									),
								ee.ensureDocumentData(Oe, x).then((Dt) => Dt.document)
							),
						)
					},
					onDidOpenTextDocument: (b, x, _) => X(ee.onDidAddDocument)(b, x, _),
					onDidCloseTextDocument: (b, x, _) => X(ee.onDidRemoveDocument)(b, x, _),
					onDidChangeTextDocument: (b, x, _) => X(ee.onDidChangeDocument)(b, x, _),
					onDidSaveTextDocument: (b, x, _) => X(ee.onDidSaveDocument)(b, x, _),
					onWillSaveTextDocument: (b, x, _) => X(Ae.getOnWillSaveTextDocumentEvent(P))(b, x, _),
					get notebookDocuments() {
						return he.notebookDocuments.map((b) => b.apiNotebook)
					},
					async openNotebookDocument(b, x) {
						let _
						if (y.isUri(b)) (_ = b), await he.openNotebookDocument(b)
						else if (typeof b == "string")
							_ = y.revive(await he.createNotebookDocument({ viewType: b, content: x }))
						else throw new Error("Invalid arguments")
						return he.getNotebookDocument(_).apiNotebook
					},
					onDidSaveNotebookDocument(b, x, _) {
						return X(le.onDidSaveNotebookDocument)(b, x, _)
					},
					onDidChangeNotebookDocument(b, x, _) {
						return X(le.onDidChangeNotebookDocument)(b, x, _)
					},
					onWillSaveNotebookDocument(b, x, _) {
						return X(En.getOnWillSaveNotebookDocumentEvent(P))(b, x, _)
					},
					get onDidOpenNotebookDocument() {
						return X(he.onDidOpenNotebookDocument)
					},
					get onDidCloseNotebookDocument() {
						return X(he.onDidCloseNotebookDocument)
					},
					registerNotebookSerializer(b, x, _, Oe) {
						return he.registerNotebookSerializer(P, b, x, _, nt(P, "notebookLiveShare") ? Oe : void 0)
					},
					onDidChangeConfiguration: (b, x, _) => X(Ne.onDidChangeConfiguration)(b, x, _),
					getConfiguration(b, x) {
						return (x = arguments.length === 1 ? void 0 : x), Ne.getConfiguration(b, x, P)
					},
					registerTextDocumentContentProvider(b, x) {
						return fe.registerTextDocumentContentProvider(b, x)
					},
					registerTaskProvider: (b, x) => (
						g.report(
							"window.registerTaskProvider",
							P,
							"Use the corresponding function on the 'tasks' namespace instead",
						),
						vt.registerTaskProvider(P, b, x)
					),
					registerFileSystemProvider(b, x, _) {
						return ev(zh.registerFileSystemProvider(P, b, x, _), n.addFileSystemProvider(b, x, _))
					},
					get fs() {
						return n.value
					},
					registerFileSearchProvider: (b, x) => (
						M(P, "fileSearchProvider"), Bt.registerFileSearchProviderOld(b, x)
					),
					registerTextSearchProvider: (b, x) => (
						M(P, "textSearchProvider"), Bt.registerTextSearchProviderOld(b, x)
					),
					registerAITextSearchProvider: (b, x) => (
						M(P, "aiTextSearchProvider"), M(P, "textSearchProvider2"), Bt.registerAITextSearchProvider(b, x)
					),
					registerFileSearchProvider2: (b, x) => (
						M(P, "fileSearchProvider2"), Bt.registerFileSearchProvider(b, x)
					),
					registerTextSearchProvider2: (b, x) => (
						M(P, "textSearchProvider2"), Bt.registerTextSearchProvider(b, x)
					),
					registerRemoteAuthorityResolver: (b, x) => (
						M(P, "resolvers"), r.registerRemoteAuthorityResolver(b, x)
					),
					registerResourceLabelFormatter: (b) => (M(P, "resolvers"), Bm.$registerResourceLabelFormatter(b)),
					getRemoteExecServer: (b) => (M(P, "resolvers"), r.getRemoteExecServer(b)),
					onDidCreateFiles: (b, x, _) => X(Cr.onDidCreateFile)(b, x, _),
					onDidDeleteFiles: (b, x, _) => X(Cr.onDidDeleteFile)(b, x, _),
					onDidRenameFiles: (b, x, _) => X(Cr.onDidRenameFile)(b, x, _),
					onWillCreateFiles: (b, x, _) => X(Cr.getOnWillCreateFileEvent(P))(b, x, _),
					onWillDeleteFiles: (b, x, _) => X(Cr.getOnWillDeleteFileEvent(P))(b, x, _),
					onWillRenameFiles: (b, x, _) => X(Cr.getOnWillRenameFileEvent(P))(b, x, _),
					openTunnel: (b) => (
						M(P, "tunnels"),
						h.openTunnel(P, b).then((x) => {
							if (!x) throw new Error("cannot open tunnel")
							return x
						})
					),
					get tunnels() {
						return M(P, "tunnels"), h.getTunnels()
					},
					onDidChangeTunnels: (b, x, _) => (M(P, "tunnels"), X(h.onDidChangeTunnels)(b, x, _)),
					registerPortAttributesProvider: (b, x) => (
						M(P, "portsAttributes"), h.registerPortsAttributesProvider(b, x)
					),
					registerTunnelProvider: (b, x) => (M(P, "tunnelFactory"), h.registerTunnelProvider(b, x)),
					registerTimelineProvider: (b, x) => (
						M(P, "timeline"), Sr.registerTimelineProvider(b, x, P.identifier, Y.converter)
					),
					get isTrusted() {
						return i.trusted
					},
					requestWorkspaceTrust: (b) => (M(P, "workspaceTrust"), i.requestWorkspaceTrust(b)),
					onDidGrantWorkspaceTrust: (b, x, _) => X(i.onDidGrantWorkspaceTrust)(b, x, _),
					registerEditSessionIdentityProvider: (b, x) => (
						M(P, "editSessionIdentityProvider"), i.registerEditSessionIdentityProvider(b, x)
					),
					onWillCreateEditSessionIdentity: (b, x, _) => (
						M(P, "editSessionIdentityProvider"), X(i.getOnWillCreateEditSessionIdentityEvent(P))(b, x, _)
					),
					registerCanonicalUriProvider: (b, x) => (
						M(P, "canonicalUriProvider"), i.registerCanonicalUriProvider(b, x)
					),
					getCanonicalUri: (b, x, _) => (M(P, "canonicalUriProvider"), i.provideCanonicalUri(b, x, _)),
					decode: function (b) {
						return M(P, "textDocumentEncoding"), i.decode(b, void 0, void 0)
					},
					encode: function (b) {
						return M(P, "textDocumentEncoding"), i.encode(b, void 0, void 0)
					},
				},
				tH = {
					get inputBox() {
						return (
							g.report("scm.inputBox", P, "Use 'SourceControl.inputBox' instead"), Il.getLastInputBox(P)
						)
					},
					createSourceControl(b, x, _) {
						return Il.createSourceControl(P, b, x, _)
					},
				},
				nH = {
					createCommentController(b, x) {
						return qh.createCommentController(P, b, x)
					},
				},
				rH = {
					get activeDebugSession() {
						return qe.activeDebugSession
					},
					get activeDebugConsole() {
						return qe.activeDebugConsole
					},
					get breakpoints() {
						return qe.breakpoints
					},
					get activeStackItem() {
						return qe.activeStackItem
					},
					registerDebugVisualizationProvider(b, x) {
						return M(P, "debugVisualization"), qe.registerDebugVisualizationProvider(P, b, x)
					},
					registerDebugVisualizationTreeProvider(b, x) {
						return M(P, "debugVisualization"), qe.registerDebugVisualizationTree(P, b, x)
					},
					onDidStartDebugSession(b, x, _) {
						return X(qe.onDidStartDebugSession)(b, x, _)
					},
					onDidTerminateDebugSession(b, x, _) {
						return X(qe.onDidTerminateDebugSession)(b, x, _)
					},
					onDidChangeActiveDebugSession(b, x, _) {
						return X(qe.onDidChangeActiveDebugSession)(b, x, _)
					},
					onDidReceiveDebugSessionCustomEvent(b, x, _) {
						return X(qe.onDidReceiveDebugSessionCustomEvent)(b, x, _)
					},
					onDidChangeBreakpoints(b, x, _) {
						return X(qe.onDidChangeBreakpoints)(b, x, _)
					},
					onDidChangeActiveStackItem(b, x, _) {
						return X(qe.onDidChangeActiveStackItem)(b, x, _)
					},
					registerDebugConfigurationProvider(b, x, _) {
						return qe.registerDebugConfigurationProvider(b, x, _ || 1)
					},
					registerDebugAdapterDescriptorFactory(b, x) {
						return qe.registerDebugAdapterDescriptorFactory(P, b, x)
					},
					registerDebugAdapterTrackerFactory(b, x) {
						return qe.registerDebugAdapterTrackerFactory(b, x)
					},
					startDebugging(b, x, _) {
						return !_ || (typeof _ == "object" && "configuration" in _)
							? qe.startDebugging(b, x, { parentSession: _ })
							: qe.startDebugging(b, x, _ || {})
					},
					stopDebugging(b) {
						return qe.stopDebugging(b)
					},
					addBreakpoints(b) {
						return qe.addBreakpoints(b)
					},
					removeBreakpoints(b) {
						return qe.removeBreakpoints(b)
					},
					asDebugSourceUri(b, x) {
						return qe.asDebugSourceUri(b, x)
					},
				},
				oH = {
					registerTaskProvider: (b, x) => vt.registerTaskProvider(P, b, x),
					fetchTasks: (b) => vt.fetchTasks(b),
					executeTask: (b) => vt.executeTask(P, b),
					get taskExecutions() {
						return vt.taskExecutions
					},
					onDidStartTask: (b, x, _) => X(vt.onDidStartTask)(b, x, _),
					onDidEndTask: (b, x, _) => X(vt.onDidEndTask)(b, x, _),
					onDidStartTaskProcess: (b, x, _) => X(vt.onDidStartTaskProcess)(b, x, _),
					onDidEndTaskProcess: (b, x, _) => X(vt.onDidEndTaskProcess)(b, x, _),
					onDidStartTaskProblemMatchers: (b, x, _) => (
						M(P, "taskProblemMatcherStatus"), X(vt.onDidStartTaskProblemMatchers)(b, x, _)
					),
					onDidEndTaskProblemMatchers: (b, x, _) => (
						M(P, "taskProblemMatcherStatus"), X(vt.onDidEndTaskProblemMatchers)(b, x, _)
					),
				},
				iH = {
					createNotebookController(b, x, _, Oe, Dt) {
						return _t.createNotebookController(P, b, x, _, Oe, nt(P, "notebookMessaging") ? Dt : void 0)
					},
					registerNotebookCellStatusBarItemProvider: (b, x) =>
						he.registerNotebookCellStatusBarItemProvider(P, b, x),
					createRendererMessaging(b) {
						return Se.createRendererMessaging(P, b)
					},
					createNotebookControllerDetectionTask(b) {
						return M(P, "notebookKernelSource"), _t.createNotebookControllerDetectionTask(P, b)
					},
					registerKernelSourceActionProvider(b, x) {
						return M(P, "notebookKernelSource"), _t.registerKernelSourceActionProvider(P, b, x)
					},
					onDidChangeNotebookCellExecutionState(b, x, _) {
						return M(P, "notebookCellExecutionState"), X(_t.onDidChangeNotebookCellExecutionState)(b, x, _)
					},
				},
				sH = {
					t(...b) {
						if (typeof b[0] == "string") {
							let x = b.shift(),
								_ = !b || typeof b[0] != "object" ? b : b[0]
							return Z.getMessage(P.identifier.value, { message: x, args: _ })
						}
						return Z.getMessage(P.identifier.value, b[0])
					},
					get bundle() {
						return Z.getBundle(P.identifier.value)
					},
					get uri() {
						return Z.getBundleUri(P.identifier.value)
					},
				},
				aH = {
					transferActiveChat(b) {
						return M(P, "interactive"), U.transferActiveChat(b)
					},
				},
				lH = {
					getRelatedInformation(b, x) {
						return M(P, "aiRelatedInformation"), B.getRelatedInformation(P, b, x)
					},
					registerRelatedInformationProvider(b, x) {
						return M(P, "aiRelatedInformation"), B.registerRelatedInformationProvider(P, b, x)
					},
					registerEmbeddingVectorProvider(b, x) {
						return M(P, "aiRelatedInformation"), ve.registerEmbeddingVectorProvider(P, b, x)
					},
				},
				dH = {
					registerMappedEditsProvider(b, x) {
						return M(P, "mappedEditsProvider"), { dispose() {} }
					},
					registerMappedEditsProvider2(b) {
						return M(P, "mappedEditsProvider"), mt.registerMappedEditsProvider(P, b)
					},
					createChatParticipant(b, x) {
						return U.createChatAgent(P, b, x)
					},
					createDynamicChatParticipant(b, x, _) {
						return M(P, "chatParticipantPrivate"), U.createDynamicChatAgent(P, b, x, _)
					},
					registerChatParticipantDetectionProvider(b) {
						return M(P, "chatParticipantPrivate"), U.registerChatParticipantDetectionProvider(P, b)
					},
					registerRelatedFilesProvider(b, x) {
						return M(P, "chatEditing"), U.registerRelatedFilesProvider(P, b, x)
					},
					onDidDisposeChatSession: (b, x, _) => (
						M(P, "chatParticipantPrivate"), X(U.onDidDisposeChatSession)(b, x, _)
					),
				},
				cH = {
					selectChatModels: (b) => A.selectLanguageModels(P, b ?? {}),
					onDidChangeChatModels: (b, x, _) => A.onDidChangeProviders(b, x, _),
					registerChatModelProvider: (b, x, _) => (M(P, "chatProvider"), A.registerLanguageModel(P, b, x, _)),
					get embeddingModels() {
						return M(P, "embeddings"), it.embeddingsModels
					},
					onDidChangeEmbeddingModels: (b, x, _) => (M(P, "embeddings"), it.onDidChange(b, x, _)),
					registerEmbeddingsProvider(b, x) {
						return M(P, "embeddings"), it.registerEmbeddingsProvider(P, b, x)
					},
					async computeEmbeddings(b, x, _) {
						return M(P, "embeddings"), it.computeEmbeddings(b, x, _)
					},
					registerTool(b, x) {
						return k.registerTool(P, b, x)
					},
					invokeTool(b, x, _) {
						return k.invokeTool(P, b, x, _)
					},
					get tools() {
						return k.getTools(P)
					},
					fileIsIgnored(b, x) {
						return A.fileIsIgnored(P, b, x)
					},
					registerIgnoredFileProvider(b) {
						return A.registerIgnoredFileProvider(P, b)
					},
					registerMcpConfigurationProvider(b, x) {
						return M(P, "mcpConfigurationProvider"), J.registerMcpConfigurationProvider(P, b, x)
					},
				},
				uH = {
					registerSpeechProvider(b, x) {
						return M(P, "speech"), hn.registerProvider(P.identifier, b, x)
					},
				}
			return {
				version: e.version,
				ai: lH,
				authentication: Ut,
				commands: Pn,
				comments: nH,
				chat: dH,
				debug: rH,
				env: zm,
				extensions: YU,
				interactive: aH,
				l10n: sH,
				languages: ZU,
				lm: cH,
				notebooks: iH,
				scm: tH,
				speech: uH,
				tasks: oH,
				tests: Cl,
				window: eH,
				workspace: b0,
				Breakpoint: bs,
				TerminalOutputAnchor: W_,
				ChatResultFeedbackKind: ZI,
				ChatVariableLevel: pD,
				ChatCompletionItem: tI,
				ChatReferenceDiagnostic: Bu,
				CallHierarchyIncomingCall: yu,
				CallHierarchyItem: Wa,
				CallHierarchyOutgoingCall: Iu,
				CancellationError: xt,
				CancellationTokenSource: _e,
				CandidatePortSource: rP,
				CodeAction: yi,
				CodeActionKind: lt,
				CodeActionTriggerKind: pI,
				CodeLens: Pa,
				Color: $o,
				ColorInformation: Aa,
				ColorPresentation: Oa,
				ColorThemeKind: $I,
				CommentMode: nD,
				CommentState: rD,
				CommentThreadCollapsibleState: MI,
				CommentThreadState: FI,
				CommentThreadApplicability: NI,
				CommentThreadFocus: UI,
				CompletionItem: ka,
				CompletionItemKind: ig,
				CompletionItemTag: gI,
				CompletionList: Bo,
				CompletionTriggerKind: fI,
				ConfigurationTarget: kI,
				CustomExecution: hd,
				DebugAdapterExecutable: jo,
				DebugAdapterInlineImplementation: ys,
				DebugAdapterNamedPipeServer: Ti,
				DebugAdapterServer: Go,
				DebugConfigurationProviderTriggerKind: w_,
				DebugConsoleMode: HI,
				DebugVisualization: Gy,
				DecorationRangeBehavior: TI,
				Diagnostic: Sa,
				DiagnosticRelatedInformation: hs,
				DiagnosticSeverity: Ku,
				DiagnosticTag: dI,
				Disposable: ye,
				DocumentHighlight: Ea,
				DocumentHighlightKind: cI,
				MultiDocumentHighlight: wa,
				DocumentLink: Ra,
				DocumentSymbol: Xr,
				EndOfLine: qu,
				EnvironmentVariableMutatorType: lI,
				EvaluatableExpression: La,
				InlineValueText: Ma,
				InlineValueVariableLookup: Fa,
				InlineValueEvaluatableExpression: Na,
				InlineCompletionTriggerKind: RI,
				EventEmitter: E,
				ExtensionKind: BI,
				ExtensionMode: QI,
				ExternalUriOpenerPriority: aD,
				FileChangeType: OI,
				FileDecoration: bd,
				FileDecoration2: bd,
				FileSystemError: rt,
				FileType: jl,
				FilePermission: Gl,
				FoldingRange: vu,
				FoldingRangeKind: LI,
				FunctionBreakpoint: Ko,
				InlineCompletionItem: mu,
				InlineCompletionList: fu,
				Hover: ld,
				VerboseHover: Ta,
				HoverVerbosityAction: V_,
				IndentAction: $R,
				Location: rn,
				MarkdownString: en,
				OverviewRulerLane: kP,
				ParameterInformation: cu,
				PortAutoForwardAction: dD,
				Position: Pe,
				ProcessExecution: xi,
				ProgressLocation: PI,
				QuickInputButtonLocation: oD,
				QuickInputButtons: bi,
				Range: pe,
				RelativePattern: Si,
				Selection: Vn,
				SelectionRange: Ii,
				SemanticTokens: Qo,
				SemanticTokensBuilder: jy,
				SemanticTokensEdit: Su,
				SemanticTokensEdits: Ba,
				SemanticTokensLegend: vd,
				ShellExecution: zo,
				ShellQuoting: Y_,
				SignatureHelp: pu,
				SignatureHelpTriggerKind: B_,
				SignatureInformation: uu,
				SnippetString: Wn,
				SourceBreakpoint: qo,
				StandardTokenType: ag,
				StatusBarAlignment: bI,
				SymbolInformation: ho,
				SymbolKind: og,
				SymbolTag: uI,
				Task: gn,
				TaskEventKind: J_,
				TaskGroup: un,
				TaskPanelKind: X_,
				TaskRevealKind: Q_,
				TaskScope: wI,
				TerminalLink: Ny,
				TerminalQuickFixTerminalCommand: Hy,
				TerminalQuickFixOpener: Uy,
				TerminalLocation: j_,
				TerminalProfile: Wy,
				TerminalExitReason: q_,
				TerminalShellExecutionCommandLineConfidence: EI,
				TerminalCompletionItem: Vy,
				TerminalCompletionItemKind: G_,
				TerminalCompletionList: By,
				TerminalShellType: K_,
				TextDocumentSaveReason: II,
				TextEdit: Ln,
				SnippetTextEdit: gd,
				TextEditorCursorStyle: nP,
				TextEditorChangeKind: CI,
				TextEditorLineNumbersStyle: yI,
				TextEditorRevealType: xI,
				TextEditorSelectionChangeKind: xd,
				SyntaxTokenType: Cd,
				TextDocumentChangeReason: SI,
				ThemeColor: vs,
				ThemeIcon: Vt,
				TreeItem: Ci,
				TreeItemCheckboxState: DI,
				TreeItemCollapsibleState: _I,
				TypeHierarchyItem: $a,
				UIKind: Ux,
				Uri: y,
				ViewColumn: vI,
				WorkspaceEdit: Jr,
				DocumentPasteTriggerKind: eD,
				DocumentDropEdit: gu,
				DocumentDropOrPasteEditKind: bo,
				DocumentPasteEdit: qy,
				InlayHint: Da,
				InlayHintLabelPart: _a,
				InlayHintKind: $_,
				RemoteAuthorityResolverError: wi,
				ResolvedAuthority: Fy,
				ManagedResolvedAuthority: Ha,
				SourceControlInputBoxValidationType: z_,
				ExtensionRuntime: JI,
				TimelineItem: bu,
				NotebookRange: dr,
				NotebookCellKind: zI,
				NotebookCellExecutionState: sg,
				NotebookCellData: xs,
				NotebookData: Tu,
				NotebookRendererScript: wu,
				NotebookCellStatusBarAlignment: qI,
				NotebookEditorRevealType: KI,
				NotebookCellOutput: Cs,
				NotebookCellOutputItem: Eu,
				CellErrorStackFrame: Qy,
				NotebookCellStatusBarItem: Jy,
				NotebookControllerAffinity: iD,
				NotebookControllerAffinity2: jI,
				NotebookEdit: Fr,
				NotebookKernelSourceAction: Xy,
				NotebookVariablesRequestKind: GI,
				PortAttributes: Zy,
				LinkedEditingRanges: Yy,
				TestResultState: sD,
				TestRunRequest: Ua,
				TestMessage: Ei,
				TestMessageStackFrame: eI,
				TestTag: Is,
				TestRunProfileKind: XI,
				TextSearchCompleteMessageType: Ag,
				DataTransfer: vo,
				DataTransferItem: dd,
				TestCoverageCount: fd,
				FileCoverage: Ss,
				StatementCoverage: _u,
				BranchCoverage: Du,
				DeclarationCoverage: ku,
				WorkspaceTrustState: lD,
				LanguageStatusSeverity: mI,
				QuickPickItemKind: WI,
				InputBoxValidationSeverity: VI,
				TabInputText: za,
				TabInputTextDiff: Ts,
				TabInputTextMerge: Ru,
				TabInputCustom: qa,
				TabInputNotebook: Ka,
				TabInputNotebookDiff: ja,
				TabInputWebview: Au,
				TabInputTerminal: Ou,
				TabInputInteractiveWindow: Lu,
				TabInputChat: Mu,
				TabInputTextMultiDiff: Fu,
				TelemetryTrustedValue: xa,
				LogLevel: ma,
				EditSessionIdentityMatch: zR,
				InteractiveSessionVoteDirection: cD,
				ChatCopyKind: uD,
				ChatEditingSessionActionOutcome: YI,
				InteractiveEditorResponseFeedbackKind: mD,
				DebugStackFrame: xu,
				DebugThread: Cu,
				RelatedInformationType: bD,
				SpeechToTextStatus: yD,
				TextToSpeechStatus: ID,
				PartialAcceptTriggerKind: hI,
				KeywordRecognitionStatus: xD,
				ChatResponseMarkdownPart: Es,
				ChatResponseFileTreePart: Ps,
				ChatResponseAnchorPart: _i,
				ChatResponseProgressPart: yd,
				ChatResponseProgressPart2: Ga,
				ChatResponseReferencePart: yo,
				ChatResponseReferencePart2: yo,
				ChatResponseCodeCitationPart: ks,
				ChatResponseCodeblockUriPart: Ds,
				ChatResponseWarningPart: Di,
				ChatResponseTextEditPart: ki,
				ChatResponseNotebookEditPart: As,
				ChatResponseMarkdownWithVulnerabilitiesPart: Pi,
				ChatResponseCommandButtonPart: _s,
				ChatResponseConfirmationPart: ws,
				ChatResponseMovePart: Rs,
				ChatResponseReferencePartStatusKind: fD,
				ChatRequestTurn: Nu,
				ChatResponseTurn: Uu,
				ChatLocation: ex,
				ChatRequestEditorData: Hu,
				ChatRequestNotebookData: Wu,
				ChatReferenceBinaryData: Vu,
				LanguageModelChatMessageRole: dg,
				LanguageModelChatMessage: $u,
				LanguageModelChatMessage2: zu,
				LanguageModelToolResultPart: Os,
				LanguageModelTextPart: Pt,
				LanguageModelToolCallPart: Io,
				LanguageModelError: Nr,
				LanguageModelToolResult: Qa,
				LanguageModelDataPart: Id,
				ChatImageMimeType: hD,
				ExtendedLanguageModelToolResult: rI,
				PreparedTerminalToolInvocation: nI,
				LanguageModelChatToolMode: vD,
				LanguageModelPromptTsxPart: xo,
				NewSymbolName: Ky,
				NewSymbolNameTag: tD,
				NewSymbolNameTriggerKind: AI,
				InlineEdit: oI,
				InlineEditTriggerKind: tx,
				ExcludeSettingOptions: Cx,
				TextSearchContext2: Ai,
				TextSearchMatch2: cr,
				TextSearchCompleteMessageTypeNew: Ag,
				ChatErrorLevel: gD,
				McpSSEServerDefinition: sI,
				McpStdioServerDefinition: iI,
			}
		}
	)
}
var Xd = class {
	constructor(e, t, n, r, i, s, a) {
		this._apiFactory = e
		this._extensionRegistry = t
		this._instaService = n
		this._extHostConfiguration = r
		this._extHostExtensionService = i
		this._initData = s
		this._logService = a
		;(this._factories = new Map()), (this._alternatives = [])
	}
	async install() {
		this._installInterceptor(), Ct("code/extHost/willWaitForConfig")
		let e = await this._extHostConfiguration.getConfigProvider()
		Ct("code/extHost/didWaitForConfig")
		let t = await this._extHostExtensionService.getExtensionPathIndex()
		this.register(new z1(this._apiFactory, t, this._extensionRegistry, e, this._logService)),
			this.register(this._instaService.createInstance(bl)),
			this._initData.remote.isRemote &&
				this.register(this._instaService.createInstance(Oh, t, this._initData.environment.appUriScheme))
	}
	register(e) {
		if ("nodeModuleName" in e)
			if (Array.isArray(e.nodeModuleName)) for (let t of e.nodeModuleName) this._factories.set(t, e)
			else this._factories.set(e.nodeModuleName, e)
		typeof e.alternativeModuleName == "function" && this._alternatives.push((t) => e.alternativeModuleName(t))
	}
}
Xd = R([S(2, Uo), S(3, pn), S(4, ur), S(5, Xe), S(6, te)], Xd)
var bl = class {
	static {
		this.aliased = new Map([
			["vscode-ripgrep", "@vscode/ripgrep"],
			["vscode-windows-registry", "@vscode/windows-registry"],
		])
	}
	constructor(e) {
		if (e.environment.appRoot && bl.aliased.size) {
			let t = _r(this.forceForwardSlashes(e.environment.appRoot.fsPath)),
				n = "[a-z0-9_.-]",
				r = `@${n}+\\/${n}+|${n}+`,
				i = "node_modules|node_modules\\.asar(?:\\.unpacked)?"
			this.re = new RegExp(`^(${t}/${i}\\/)(${r})(.*)$`, "i")
		}
	}
	alternativeModuleName(e) {
		if (!this.re) return
		let t = this.re.exec(this.forceForwardSlashes(e))
		if (!t) return
		let [, n, r, i] = t,
			s = bl.aliased.get(r)
		if (s !== void 0) return console.warn(`${r} as been renamed to ${s}, please update your imports`), n + s + i
	}
	forceForwardSlashes(e) {
		return e.replace(/\\/g, "/")
	}
}
bl = R([S(0, Xe)], bl)
var z1 = class {
		constructor(e, t, n, r, i) {
			this._apiFactory = e
			this._extensionPaths = t
			this._extensionRegistry = n
			this._configProvider = r
			this._logService = i
			this.nodeModuleName = "vscode"
			this._extApiImpl = new On()
		}
		load(e, t) {
			let n = this._extensionPaths.findSubstr(t)
			if (n) {
				let r = this._extApiImpl.get(n.identifier)
				return (
					r ||
						((r = this._apiFactory(n, this._extensionRegistry, this._configProvider)),
						this._extApiImpl.set(n.identifier, r)),
					r
				)
			}
			if (!this._defaultApiImpl) {
				let r = ""
				this._extensionPaths.forEach(
					(i, s) =>
						(r += `	${s} -> ${i.identifier.value}
`),
				),
					this._logService
						.warn(`Could not identify extension for 'vscode' require call from ${t}. These are the extension path mappings: 
${r}`),
					(this._defaultApiImpl = this._apiFactory(eF, this._extensionRegistry, this._configProvider))
			}
			return this._defaultApiImpl
		}
	},
	Oh = class {
		constructor(e, t, n) {
			this._extensionPaths = e
			this._appUriScheme = t
			this.nodeModuleName = ["open", "opn"]
			this._mainThreadTelemetry = n.getProxy(N.MainThreadTelemetry)
			let r = n.getProxy(N.MainThreadWindow)
			this._impl = (i, s) => {
				let a = y.parse(i)
				return s
					? this.callOriginal(i, s)
					: a.scheme === "http" || a.scheme === "https"
						? r.$openUri(a, i, { allowTunneling: !0 })
						: a.scheme === "mailto" || a.scheme === this._appUriScheme
							? r.$openUri(a, i, {})
							: this.callOriginal(i, s)
			}
		}
		load(e, t, n) {
			let r = this._extensionPaths.findSubstr(t)
			return (
				r && ((this._extensionId = r.identifier.value), this.sendShimmingTelemetry()),
				(this._original = n(e)),
				this._impl
			)
		}
		callOriginal(e, t) {
			return this.sendNoForwardTelemetry(), this._original(e, t)
		}
		sendShimmingTelemetry() {
			this._extensionId &&
				this._mainThreadTelemetry.$publicLog2("shimming.open", { extension: this._extensionId })
		}
		sendNoForwardTelemetry() {
			this._extensionId &&
				this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", { extension: this._extensionId })
		}
	}
Oh = R([S(2, ie)], Oh)
import {
	LogLevel as Zd,
	createHttpPatch as aU,
	createProxyResolver as s$,
	createTlsPatch as a$,
	createNetPatch as l$,
	loadSystemCertificates as d$,
} from "@vscode/proxy-agent"
import { createRequire as c$ } from "module"
import { parse as iU } from "url"
import { spawn as t$ } from "child_process"
import { userInfo as XB } from "os"
import * as q1 from "os"
var YN = /^\d+$/,
	$B = /^Microsoft.PowerShell_.*/,
	zB = /^Microsoft.PowerShellPreview_.*/
var Lh
switch (process.arch) {
	case "ia32":
		Lh = 1
		break
	case "arm":
	case "arm64":
		Lh = 2
		break
	default:
		Lh = 0
		break
}
var _m
process.env.PROCESSOR_ARCHITEW6432
	? (_m = process.env.PROCESSOR_ARCHITEW6432 === "ARM64" ? 2 : 0)
	: process.env.PROCESSOR_ARCHITECTURE === "ARM64"
		? (_m = 2)
		: process.env.PROCESSOR_ARCHITECTURE === "X86"
			? (_m = 1)
			: (_m = 0)
var Yd = class {
	constructor(e, t, n) {
		this.exePath = e
		this.displayName = t
		this.knownToExist = n
	}
	async exists() {
		return (
			this.knownToExist === void 0 && (this.knownToExist = await or.existsFile(this.exePath)), this.knownToExist
		)
	}
}
function qB({ useAlternateBitness: o = !1 } = {}) {
	return o
		? Lh === 0
			? process.env["ProgramFiles(x86)"] || null
			: (_m === 0 && process.env.ProgramW6432) || null
		: process.env.ProgramFiles || null
}
async function aT({ useAlternateBitness: o = !1, findPreview: e = !1 } = {}) {
	let t = qB({ useAlternateBitness: o })
	if (!t) return null
	let n = Fe(t, "PowerShell")
	if (!(await or.existsDirectory(n))) return null
	let r = -1,
		i = null
	for (let l of await Qe.readdir(n)) {
		let d = -1
		if (e) {
			let u = l.indexOf("-")
			if (u < 0) continue
			let m = l.substring(0, u)
			if (!YN.test(m) || l.substring(u + 1) !== "preview") continue
			d = parseInt(m, 10)
		} else {
			if (!YN.test(l)) continue
			d = parseInt(l, 10)
		}
		if (d <= r) continue
		let c = Fe(n, l, "pwsh.exe")
		;(await or.existsFile(c)) && ((i = c), (r = d))
	}
	if (!i) return null
	let s = t.includes("x86") ? " (x86)" : "",
		a = e ? " Preview" : ""
	return new Yd(i, `PowerShell${a}${s}`, !0)
}
async function ZN({ findPreview: o } = {}) {
	if (!process.env.LOCALAPPDATA) return null
	let e = Fe(process.env.LOCALAPPDATA, "Microsoft", "WindowsApps")
	if (!(await or.existsDirectory(e))) return null
	let { pwshMsixDirRegex: t, pwshMsixName: n } = o
		? { pwshMsixDirRegex: zB, pwshMsixName: "PowerShell Preview (Store)" }
		: { pwshMsixDirRegex: $B, pwshMsixName: "PowerShell (Store)" }
	for (let r of await Qe.readdir(e))
		if (t.test(r)) {
			let i = Fe(e, r, "pwsh.exe")
			return new Yd(i, n)
		}
	return null
}
function KB() {
	let o = Fe(q1.homedir(), ".dotnet", "tools", "pwsh.exe")
	return new Yd(o, ".NET Core PowerShell Global Tool")
}
function jB() {
	let o = Fe(q1.homedir(), "scoop", "apps"),
		e = Fe(o, "pwsh", "current", "pwsh.exe")
	return new Yd(e, "PowerShell (Scoop)")
}
function GB() {
	let o = Fe(
		process.env.windir,
		Lh === 1 && _m !== 1 ? "SysNative" : "System32",
		"WindowsPowerShell",
		"v1.0",
		"powershell.exe",
	)
	return new Yd(o, "Windows PowerShell", !0)
}
async function* QB() {
	let o = await aT()
	o && (yield o),
		(o = await aT({ useAlternateBitness: !0 })),
		o && (yield o),
		(o = await ZN()),
		o && (yield o),
		(o = KB()),
		o && (yield o),
		(o = await aT({ findPreview: !0 })),
		o && (yield o),
		(o = await ZN({ findPreview: !0 })),
		o && (yield o),
		(o = await aT({ useAlternateBitness: !0, findPreview: !0 })),
		o && (yield o),
		(o = await jB()),
		o && (yield o),
		(o = GB()),
		o && (yield o)
}
async function* JB() {
	for await (let o of QB()) (await o.exists()) && (yield o)
}
async function eU() {
	for await (let o of JB()) return o
	return null
}
async function tU(o, e) {
	return o === 1 ? (Ie ? ZB() : gC(e)) : YB(o, e)
}
var K1 = null
function YB(o, e) {
	if ((Ve && o === 2) || (st && o === 3)) return "/bin/bash"
	if (!K1) {
		let t
		if (Ie) t = "/bin/bash"
		else {
			if (((t = e.SHELL), !t))
				try {
					t = XB().shell
				} catch {}
			t || (t = "sh"), t === "/bin/false" && (t = "/bin/bash")
		}
		K1 = t
	}
	return K1
}
var j1 = null
async function ZB() {
	return j1 || (j1 = (await eU()).exePath), j1
}
import Gqe from "minimist"
var Xqe = {
	o: p("optionsUpperCase", "Options"),
	e: p("extensionsManagement", "Extensions Management"),
	t: p("troubleshooting", "Troubleshooting"),
}
var e$ = {
	tunnel: {
		type: "subcommand",
		description: "Make the current machine accessible from vscode.dev or other machines through a secure tunnel",
		options: {
			"cli-data-dir": {
				type: "string",
				args: "dir",
				description: p("cliDataDir", "Directory where CLI metadata should be stored."),
			},
			"disable-telemetry": { type: "boolean" },
			"telemetry-level": { type: "string" },
			user: {
				type: "subcommand",
				options: {
					login: {
						type: "subcommand",
						options: { provider: { type: "string" }, "access-token": { type: "string" } },
					},
				},
			},
		},
	},
	"serve-web": {
		type: "subcommand",
		description: "Run a server that displays the editor UI in browsers.",
		options: {
			"cli-data-dir": {
				type: "string",
				args: "dir",
				description: p("cliDataDir", "Directory where CLI metadata should be stored."),
			},
			"disable-telemetry": { type: "boolean" },
			"telemetry-level": { type: "string" },
		},
	},
	diff: {
		type: "boolean",
		cat: "o",
		alias: "d",
		args: ["file", "file"],
		description: p("diff", "Compare two files with each other."),
	},
	merge: {
		type: "boolean",
		cat: "o",
		alias: "m",
		args: ["path1", "path2", "base", "result"],
		description: p(
			"merge",
			"Perform a three-way merge by providing paths for two modified versions of a file, the common origin of both modified versions and the output file to save merge results.",
		),
	},
	add: {
		type: "boolean",
		cat: "o",
		alias: "a",
		args: "folder",
		description: p("add", "Add folder(s) to the last active window."),
	},
	remove: {
		type: "boolean",
		cat: "o",
		args: "folder",
		description: p("remove", "Remove folder(s) from the last active window."),
	},
	goto: {
		type: "boolean",
		cat: "o",
		alias: "g",
		args: "file:line[:character]",
		description: p("goto", "Open a file at the path on the specified line and character position."),
	},
	"new-window": { type: "boolean", cat: "o", alias: "n", description: p("newWindow", "Force to open a new window.") },
	"reuse-window": {
		type: "boolean",
		cat: "o",
		alias: "r",
		description: p("reuseWindow", "Force to open a file or folder in an already opened window."),
	},
	wait: {
		type: "boolean",
		cat: "o",
		alias: "w",
		description: p("wait", "Wait for the files to be closed before returning."),
	},
	waitMarkerFilePath: { type: "string" },
	locale: {
		type: "string",
		cat: "o",
		args: "locale",
		description: p("locale", "The locale to use (e.g. en-US or zh-TW)."),
	},
	"user-data-dir": {
		type: "string",
		cat: "o",
		args: "dir",
		description: p(
			"userDataDir",
			"Specifies the directory that user data is kept in. Can be used to open multiple distinct instances of Code.",
		),
	},
	profile: {
		type: "string",
		cat: "o",
		args: "profileName",
		description: p(
			"profileName",
			"Opens the provided folder or workspace with the given profile and associates the profile with the workspace. If the profile does not exist, a new empty one is created.",
		),
	},
	help: { type: "boolean", cat: "o", alias: "h", description: p("help", "Print usage.") },
	"extensions-dir": {
		type: "string",
		deprecates: ["extensionHomePath"],
		cat: "e",
		args: "dir",
		description: p("extensionHomePath", "Set the root path for extensions."),
	},
	"extensions-download-dir": { type: "string" },
	"builtin-extensions-dir": { type: "string" },
	"list-extensions": {
		type: "boolean",
		cat: "e",
		description: p("listExtensions", "List the installed extensions."),
	},
	"show-versions": {
		type: "boolean",
		cat: "e",
		description: p("showVersions", "Show versions of installed extensions, when using --list-extensions."),
	},
	category: {
		type: "string",
		allowEmptyValue: !0,
		cat: "e",
		description: p("category", "Filters installed extensions by provided category, when using --list-extensions."),
		args: "category",
	},
	"install-extension": {
		type: "string[]",
		cat: "e",
		args: "ext-id | path",
		description: p(
			"installExtension",
			"Installs or updates an extension. The argument is either an extension id or a path to a VSIX. The identifier of an extension is '${publisher}.${name}'. Use '--force' argument to update to latest version. To install a specific version provide '@${version}'. For example: 'vscode.csharp@1.2.3'.",
		),
	},
	"pre-release": {
		type: "boolean",
		cat: "e",
		description: p(
			"install prerelease",
			"Installs the pre-release version of the extension, when using --install-extension",
		),
	},
	"uninstall-extension": {
		type: "string[]",
		cat: "e",
		args: "ext-id",
		description: p("uninstallExtension", "Uninstalls an extension."),
	},
	"update-extensions": {
		type: "boolean",
		cat: "e",
		description: p("updateExtensions", "Update the installed extensions."),
	},
	"enable-proposed-api": {
		type: "string[]",
		allowEmptyValue: !0,
		cat: "e",
		args: "ext-id",
		description: p(
			"experimentalApis",
			"Enables proposed API features for extensions. Can receive one or more extension IDs to enable individually.",
		),
	},
	"add-mcp": {
		type: "string[]",
		cat: "o",
		args: "json",
		description: p(
			"addMcp",
			`Adds a Model Context Protocol server definition to the user profile, or workspace or folder when used with --mcp-workspace. Accepts JSON input in the form '{"name":"server-name","command":...}'`,
		),
	},
	version: { type: "boolean", cat: "t", alias: "v", description: p("version", "Print version.") },
	verbose: {
		type: "boolean",
		cat: "t",
		global: !0,
		description: p("verbose", "Print verbose output (implies --wait)."),
	},
	log: {
		type: "string[]",
		cat: "t",
		args: "level",
		global: !0,
		description: p(
			"log",
			"Log level to use. Default is 'info'. Allowed values are 'critical', 'error', 'warn', 'info', 'debug', 'trace', 'off'. You can also configure the log level of an extension by passing extension id and log level in the following format: '${publisher}.${name}:${logLevel}'. For example: 'vscode.csharp:trace'. Can receive one or more such entries.",
		),
	},
	status: {
		type: "boolean",
		alias: "s",
		cat: "t",
		description: p("status", "Print process usage and diagnostics information."),
	},
	"prof-startup": { type: "boolean", cat: "t", description: p("prof-startup", "Run CPU profiler during startup.") },
	"prof-append-timers": { type: "string" },
	"prof-duration-markers": { type: "string[]" },
	"prof-duration-markers-file": { type: "string" },
	"no-cached-data": { type: "boolean" },
	"prof-startup-prefix": { type: "string" },
	"prof-v8-extensions": { type: "boolean" },
	"disable-extensions": {
		type: "boolean",
		deprecates: ["disableExtensions"],
		cat: "t",
		description: p(
			"disableExtensions",
			"Disable all installed extensions. This option is not persisted and is effective only when the command opens a new window.",
		),
	},
	"disable-extension": {
		type: "string[]",
		cat: "t",
		args: "ext-id",
		description: p(
			"disableExtension",
			"Disable the provided extension. This option is not persisted and is effective only when the command opens a new window.",
		),
	},
	sync: { type: "string", cat: "t", description: p("turn sync", "Turn sync on or off."), args: ["on | off"] },
	"inspect-extensions": {
		type: "string",
		allowEmptyValue: !0,
		deprecates: ["debugPluginHost"],
		args: "port",
		cat: "t",
		description: p(
			"inspect-extensions",
			"Allow debugging and profiling of extensions. Check the developer tools for the connection URI.",
		),
	},
	"inspect-brk-extensions": {
		type: "string",
		allowEmptyValue: !0,
		deprecates: ["debugBrkPluginHost"],
		args: "port",
		cat: "t",
		description: p(
			"inspect-brk-extensions",
			"Allow debugging and profiling of extensions with the extension host being paused after start. Check the developer tools for the connection URI.",
		),
	},
	"disable-lcd-text": { type: "boolean", cat: "t", description: p("disableLCDText", "Disable LCD font rendering.") },
	"disable-gpu": { type: "boolean", cat: "t", description: p("disableGPU", "Disable GPU hardware acceleration.") },
	"disable-chromium-sandbox": {
		type: "boolean",
		cat: "t",
		description: p(
			"disableChromiumSandbox",
			"Use this option only when there is requirement to launch the application as sudo user on Linux or when running as an elevated user in an applocker environment on Windows.",
		),
	},
	sandbox: { type: "boolean" },
	"locate-shell-integration-path": {
		type: "string",
		cat: "t",
		args: ["shell"],
		description: p(
			"locateShellIntegrationPath",
			"Print the path to a terminal shell integration script. Allowed values are 'bash', 'pwsh', 'zsh' or 'fish'.",
		),
	},
	telemetry: {
		type: "boolean",
		cat: "t",
		description: p("telemetry", "Shows all telemetry events which VS code collects."),
	},
	remote: { type: "string", allowEmptyValue: !0 },
	"folder-uri": { type: "string[]", cat: "o", args: "uri" },
	"file-uri": { type: "string[]", cat: "o", args: "uri" },
	"locate-extension": { type: "string[]" },
	extensionDevelopmentPath: { type: "string[]" },
	extensionDevelopmentKind: { type: "string[]" },
	extensionTestsPath: { type: "string" },
	extensionEnvironment: { type: "string" },
	debugId: { type: "string" },
	debugRenderer: { type: "boolean" },
	"inspect-ptyhost": { type: "string", allowEmptyValue: !0 },
	"inspect-brk-ptyhost": { type: "string", allowEmptyValue: !0 },
	"inspect-search": { type: "string", deprecates: ["debugSearch"], allowEmptyValue: !0 },
	"inspect-brk-search": { type: "string", deprecates: ["debugBrkSearch"], allowEmptyValue: !0 },
	"inspect-sharedprocess": { type: "string", allowEmptyValue: !0 },
	"inspect-brk-sharedprocess": { type: "string", allowEmptyValue: !0 },
	"export-default-configuration": { type: "string" },
	"install-source": { type: "string" },
	"enable-smoke-test-driver": { type: "boolean" },
	logExtensionHostCommunication: { type: "boolean" },
	"skip-release-notes": { type: "boolean" },
	"skip-welcome": { type: "boolean" },
	"disable-telemetry": { type: "boolean" },
	"disable-updates": { type: "boolean" },
	"use-inmemory-secretstorage": { type: "boolean", deprecates: ["disable-keytar"] },
	"password-store": { type: "string" },
	"disable-workspace-trust": { type: "boolean" },
	"disable-crash-reporter": { type: "boolean" },
	"crash-reporter-directory": { type: "string" },
	"crash-reporter-id": { type: "string" },
	"skip-add-to-recently-opened": { type: "boolean" },
	"open-url": { type: "boolean" },
	"file-write": { type: "boolean" },
	"file-chmod": { type: "boolean" },
	"install-builtin-extension": { type: "string[]" },
	force: { type: "boolean" },
	"do-not-sync": { type: "boolean" },
	"do-not-include-pack-dependencies": { type: "boolean" },
	trace: { type: "boolean" },
	"trace-memory-infra": { type: "boolean" },
	"trace-category-filter": { type: "string" },
	"trace-options": { type: "string" },
	"preserve-env": { type: "boolean" },
	"force-user-env": { type: "boolean" },
	"force-disable-user-env": { type: "boolean" },
	"open-devtools": { type: "boolean" },
	"disable-gpu-sandbox": { type: "boolean" },
	logsPath: { type: "string" },
	"__enable-file-policy": { type: "boolean" },
	editSessionId: { type: "string" },
	continueOn: { type: "string" },
	"enable-coi": { type: "boolean" },
	"unresponsive-sample-interval": { type: "string" },
	"unresponsive-sample-period": { type: "string" },
	"no-proxy-server": { type: "boolean" },
	"no-sandbox": { type: "boolean", alias: "sandbox" },
	"proxy-server": { type: "string" },
	"proxy-bypass-list": { type: "string" },
	"proxy-pac-url": { type: "string" },
	"js-flags": { type: "string" },
	inspect: { type: "string", allowEmptyValue: !0 },
	"inspect-brk": { type: "string", allowEmptyValue: !0 },
	nolazy: { type: "boolean" },
	"force-device-scale-factor": { type: "string" },
	"force-renderer-accessibility": { type: "boolean" },
	"ignore-certificate-errors": { type: "boolean" },
	"allow-insecure-localhost": { type: "boolean" },
	"log-net-log": { type: "string" },
	vmodule: { type: "string" },
	_urls: { type: "string[]" },
	"disable-dev-shm-usage": { type: "boolean" },
	"profile-temp": { type: "boolean" },
	"ozone-platform": { type: "string" },
	"enable-tracing": { type: "string" },
	"trace-startup-format": { type: "string" },
	"trace-startup-file": { type: "string" },
	"trace-startup-duration": { type: "string" },
	"xdg-portal-required-version": { type: "string" },
	_: { type: "string[]" },
}
function G1(o) {
	return o.VSCODE_CLI === "1"
}
var Q1
async function nU(o, e, t, n) {
	return t["force-disable-user-env"]
		? (e.trace("resolveShellEnv(): skipped (--force-disable-user-env)"), {})
		: Ie
			? (e.trace("resolveShellEnv(): skipped (Windows)"), {})
			: G1(n) && !t["force-user-env"]
				? (e.trace("resolveShellEnv(): skipped (VSCODE_CLI is set)"), {})
				: (G1(n)
						? e.trace("resolveShellEnv(): running (--force-user-env)")
						: e.trace("resolveShellEnv(): running (macOS/Linux)"),
					Q1 ||
						(Q1 = so.withAsyncBody(async (r, i) => {
							let s = new _e(),
								a = 1e4,
								l = o.getValue("application.shellEnvironmentResolutionTimeout")
							typeof l == "number" && (a = XO(l, 1, 120) * 1e3)
							let d = setTimeout(() => {
								s.dispose(!0),
									i(
										new Error(
											p(
												"resolveShellEnvTimeout",
												"Unable to resolve your shell environment in a reasonable time. Please review your shell configuration and restart.",
											),
										),
									)
							}, a)
							try {
								r(await n$(e, s.token))
							} catch (c) {
								!bn(c) && !s.token.isCancellationRequested
									? i(
											new Error(
												p(
													"resolveShellEnvError",
													"Unable to resolve your shell environment: {0}",
													Jn(c),
												),
											),
										)
									: r({})
							} finally {
								clearTimeout(d), s.dispose()
							}
						})),
					Q1)
}
async function n$(o, e) {
	let t = process.env.ELECTRON_RUN_AS_NODE
	o.trace("getUnixShellEnvironment#runAsNode", t)
	let n = process.env.ELECTRON_NO_ATTACH_CONSOLE
	o.trace("getUnixShellEnvironment#noAttach", n)
	let r = He().replace(/-/g, "").substr(0, 12),
		i = new RegExp(r + "({.*})" + r),
		s = {
			...process.env,
			ELECTRON_RUN_AS_NODE: "1",
			ELECTRON_NO_ATTACH_CONSOLE: "1",
			VSCODE_RESOLVING_ENVIRONMENT: "1",
		}
	o.trace("getUnixShellEnvironment#env", s)
	let a = await tU(wl, s)
	return (
		o.trace("getUnixShellEnvironment#shell", a),
		new Promise((l, d) => {
			if (e.isCancellationRequested) return d(new xt())
			let c = Ze(a),
				u,
				m,
				f = ""
			;/^(?:pwsh|powershell)(?:-preview)?$/.test(c)
				? ((u = `& '${process.execPath}' ${f} -p '''${r}'' + JSON.stringify(process.env) + ''${r}'''`),
					(m = ["-Login", "-Command"]))
				: c === "nu"
					? ((u = `^'${process.execPath}' ${f} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
						(m = ["-i", "-l", "-c"]))
					: c === "xonsh"
						? ((u = `import os, json; print("${r}", json.dumps(dict(os.environ)), "${r}")`),
							(m = ["-i", "-l", "-c"]))
						: ((u = `'${process.execPath}' ${f} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
							c === "tcsh" || c === "csh" ? (m = ["-ic"]) : (m = ["-i", "-l", "-c"])),
				o.trace("getUnixShellEnvironment#spawn", JSON.stringify(m), u)
			let h = t$(a, [...m, u], { detached: !0, stdio: ["ignore", "pipe", "pipe"], env: s })
			e.onCancellationRequested(() => (h.kill(), d(new xt()))),
				h.on("error", (C) => {
					o.error("getUnixShellEnvironment#errorChildProcess", Jn(C)), d(C)
				})
			let g = []
			h.stdout.on("data", (C) => g.push(C))
			let I = []
			h.stderr.on("data", (C) => I.push(C)),
				h.on("close", (C, T) => {
					let w = Buffer.concat(g).toString("utf8")
					o.trace("getUnixShellEnvironment#raw", w)
					let L = Buffer.concat(I).toString("utf8")
					if ((L.trim() && o.trace("getUnixShellEnvironment#stderr", L), C || T))
						return d(
							new Error(
								p(
									"resolveShellEnvExitError",
									"Unexpected exit code from spawned shell (code {0}, signal {1})",
									C,
									T,
								),
							),
						)
					let A = i.exec(w),
						J = A ? A[1] : "{}"
					try {
						let ne = JSON.parse(J)
						t ? (ne.ELECTRON_RUN_AS_NODE = t) : delete ne.ELECTRON_RUN_AS_NODE,
							n ? (ne.ELECTRON_NO_ATTACH_CONSOLE = n) : delete ne.ELECTRON_NO_ATTACH_CONSOLE,
							delete ne.VSCODE_RESOLVING_ENVIRONMENT,
							delete ne.XDG_RUNTIME_DIR,
							o.trace("getUnixShellEnvironment#result", ne),
							l(ne)
					} catch (ne) {
						o.error("getUnixShellEnvironment#errorCaught", Jn(ne)), d(ne)
					}
				})
		})
	)
}
import { parse as rU } from "url"
function r$(o, e) {
	return o.protocol === "http:"
		? e.HTTP_PROXY || e.http_proxy || null
		: (o.protocol === "https:" && (e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy)) || null
}
async function oU(o, e, t = {}) {
	let n = rU(o),
		r = t.proxyUrl || r$(n, e)
	if (!r) return null
	let i = rU(r)
	if (!/^https?:$/.test(i.protocol || "")) return null
	let s = {
		host: i.hostname || "",
		port: (i.port ? +i.port : 0) || (i.protocol === "https" ? 443 : 80),
		auth: i.auth,
		rejectUnauthorized: Xh(t.strictSSL) ? t.strictSSL : !0,
	}
	if (n.protocol === "http:") {
		let { default: a } = await import("http-proxy-agent")
		return new a.HttpProxyAgent(r, s)
	} else {
		let { default: a } = await import("https-proxy-agent")
		return new a.HttpsProxyAgent(r, s)
	}
}
import { createGunzip as o$ } from "zlib"
var lT = class extends iy {
	constructor(t, n, r, i) {
		super(i)
		this.machine = t
		this.configurationService = n
		this.environmentService = r
		this.configure(),
			this._register(
				n.onDidChangeConfiguration((s) => {
					s.affectsConfiguration("http") && this.configure()
				}),
			)
	}
	configure() {
		;(this.proxyUrl = this.getConfigValue("http.proxy")),
			(this.strictSSL = !!this.getConfigValue("http.proxyStrictSSL")),
			(this.authorization = this.getConfigValue("http.proxyAuthorization"))
	}
	async request(t, n) {
		let { proxyUrl: r, strictSSL: i } = this,
			s
		try {
			s = await nU(this.configurationService, this.logService, this.environmentService.args, process.env)
		} catch (d) {
			this.shellEnvErrorLogged ||
				((this.shellEnvErrorLogged = !0), this.logService.error("resolving shell environment failed", Gm(d)))
		}
		let a = { ...process.env, ...s },
			l = t.agent ? t.agent : await oU(t.url || "", a, { proxyUrl: r, strictSSL: i })
		return (
			(t.agent = l),
			(t.strictSSL = i),
			this.authorization && (t.headers = { ...(t.headers || {}), "Proxy-Authorization": this.authorization }),
			this.logAndRequest(t, () => sU(t, n))
		)
	}
	async resolveProxy(t) {}
	async lookupAuthorization(t) {}
	async lookupKerberosAuthorization(t) {
		try {
			let n = this.getConfigValue("http.proxyKerberosServicePrincipal")
			return "Negotiate " + (await J1(t, n, this.logService, "RequestService#lookupKerberosAuthorization"))
		} catch (n) {
			this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed", n)
			return
		}
	}
	async loadCertificates() {
		return (await import("@vscode/proxy-agent")).loadSystemCertificates({ log: this.logService })
	}
	getConfigValue(t) {
		if (this.machine === "remote") return this.configurationService.getValue(t)
		let n = this.configurationService.inspect(t)
		return n.userLocalValue || n.defaultValue
	}
}
lT = R([S(1, vr), S(2, LM), S(3, te)], lT)
async function J1(o, e, t, n) {
	let r = await import("kerberos"),
		i = r.default || r,
		s = new URL(o),
		a = e || (process.platform === "win32" ? `HTTP/${s.hostname}` : `HTTP@${s.hostname}`)
	return (
		t.debug(`${n} Kerberos authentication lookup`, `proxyURL:${s}`, `spn:${a}`),
		(await i.initializeClient(a)).step("")
	)
}
async function i$(o) {
	return (iU(o.url).protocol === "https:" ? await import("https") : await import("http")).request
}
async function sU(o, e) {
	return so.withAsyncBody(async (t, n) => {
		let r = iU(o.url),
			i = o.getRawRequest ? o.getRawRequest(o) : await i$(o),
			s = {
				hostname: r.hostname,
				port: r.port ? parseInt(r.port) : r.protocol === "https:" ? 443 : 80,
				protocol: r.protocol,
				path: r.path,
				method: o.type || "GET",
				headers: o.headers,
				agent: o.agent,
				rejectUnauthorized: Xh(o.strictSSL) ? o.strictSSL : !0,
			}
		o.user && o.password && (s.auth = o.user + ":" + o.password), o.disableCache && (s.cache = "no-store")
		let a = i(s, (l) => {
			let d = fn(o.followRedirects) ? o.followRedirects : 3
			if (l.statusCode && l.statusCode >= 300 && l.statusCode < 400 && d > 0 && l.headers.location)
				sU({ ...o, url: l.headers.location, followRedirects: d - 1 }, e).then(t, n)
			else {
				let c = l
				!o.isChromiumNetwork && l.headers["content-encoding"] === "gzip" && (c = l.pipe(o$())),
					t({ res: l, stream: ZA(c) })
			}
		})
		if ((a.on("error", n), o.timeout))
			if (o.isChromiumNetwork) {
				let l = setTimeout(() => {
					a.abort(), n(new Error(`Request timeout after ${o.timeout}ms`))
				}, o.timeout)
				a.on("response", () => clearTimeout(l)),
					a.on("error", () => clearTimeout(l)),
					a.on("abort", () => clearTimeout(l))
			} else a.setTimeout(o.timeout)
		o.isChromiumNetwork && a.removeHeader("Content-Length"),
			o.data && typeof o.data == "string" && a.write(o.data),
			a.end(),
			e.onCancellationRequested(() => {
				a.abort(), n(new xt())
			})
	})
}
import * as ec from "@vscode/proxy-agent"
var km = c$(import.meta.url),
	lU = km("http"),
	cT = km("https"),
	dU = km("tls"),
	cU = km("net"),
	hU = !1,
	uU = !1
function vU(o, e, t, n, r, i, s) {
	let a = i.remote.isRemote,
		l = i.environment.useHostProxy ?? !a,
		d = l,
		c = l,
		u = () => !a || e.getConfiguration("http").get("useLocalProxyConfiguration", l),
		m = {
			resolveProxy: (C) => o.resolveProxy(C),
			lookupProxyAuthorization: b$.bind(void 0, o, n, r, e, {}, {}, i.remote.isRemote, d),
			getProxyURL: () => Gs(e, a, "http.proxy"),
			getProxySupport: () => Gs(e, a, "http.proxySupport") || "off",
			getNoProxyConfig: () => Gs(e, a, "http.noProxy") || [],
			isAdditionalFetchSupportEnabled: () => Gs(e, a, "http.fetchAdditionalSupport", !0),
			addCertificatesV1: () => g$(e, a),
			addCertificatesV2: () => h$(e, a),
			log: n,
			getLogLevel: () => {
				let C = n.getLevel()
				switch (C) {
					case 1:
						return Zd.Trace
					case 2:
						return Zd.Debug
					case 3:
						return Zd.Info
					case 4:
						return Zd.Warning
					case 5:
						return Zd.Error
					case 0:
						return Zd.Off
					default:
						return T(C)
				}
				function T(w) {
					return n.error("Unknown log level", w), Zd.Debug
				}
			},
			proxyResolveTelemetry: () => {},
			isUseHostProxyEnabled: u,
			loadAdditionalCertificates: async () => {
				let C = []
				if ((i.remote.isRemote && C.push(d$({ log: n })), c)) {
					n.trace("ProxyResolver#loadAdditionalCertificates: Loading certificates from main process")
					let T = o.loadCertificates()
					T.then((w) =>
						n.trace(
							"ProxyResolver#loadAdditionalCertificates: Loaded certificates from main process",
							w.length,
						),
					),
						C.push(T)
				}
				return (
					i.environment.extensionTestsLocationURI &&
						cT.globalAgent.testCertificates?.length &&
						(n.trace("ProxyResolver#loadAdditionalCertificates: Loading test certificates"),
						C.push(Promise.resolve(cT.globalAgent.testCertificates))),
					(await Promise.all(C)).flat()
				)
			},
			env: process.env,
		},
		{ resolveProxyWithRequest: f, resolveProxyURL: h } = s$(m),
		g = ec.default || ec
	;(g.resolveProxyURL = h), p$(m, e, r, i, h, s)
	let I = f$(m, f)
	return v$(t, I)
}
var u$ = [
	"content-length",
	"host",
	"trailer",
	"te",
	"upgrade",
	"cookie2",
	"keep-alive",
	"transfer-encoding",
	"set-cookie",
]
function p$(o, e, t, n, r, i) {
	if (!globalThis.__vscodeOriginalFetch) {
		let s = globalThis.fetch
		globalThis.__vscodeOriginalFetch = s
		let a = ec.createFetchPatch(o, s, r)
		globalThis.__vscodePatchedFetch = a
		let l = !1
		n.remote.isRemote ||
			((l = e.getConfiguration("http").get("electronFetch", uU)),
			i.add(
				e.onDidChangeConfiguration((d) => {
					d.affectsConfiguration("http.electronFetch") &&
						(l = e.getConfiguration("http").get("electronFetch", uU))
				}),
			)),
			(globalThis.fetch = async function (c, u) {
				function m(A) {
					return u && A in u ? u[A] : typeof c == "object" && "cache" in c ? c[A] : void 0
				}
				let f = typeof c == "string" ? c : "cache" in c ? c.url : c.toString(),
					h = f.startsWith("data:")
				h && Dm(t, "data")
				let g = f.startsWith("blob:")
				g && Dm(t, "blob")
				let I = m("redirect") === "manual"
				I && Dm(t, "manualRedirect")
				let C = m("integrity")
				if ((C && Dm(t, "integrity"), !l || h || g || I || C)) {
					let A = await a(c, u)
					return pU(t, A, f), A
				}
				if (u?.headers) {
					let A = new Headers(u.headers)
					for (let J of u$) A.delete(J)
					u = { ...u, headers: A }
				}
				let T = c instanceof URL ? c.toString() : c,
					L = await km("electron").net.fetch(T, u)
				return pU(t, L, f), L
			})
	}
}
function pU(o, e, t) {
	let n = e.url
	Object.defineProperty(e, "url", {
		get() {
			return Dm(o, "url"), n || t
		},
	})
	let r = e.type
	Object.defineProperty(e, "type", {
		get() {
			return Dm(o, "typeProperty"), r !== "default" ? r : "basic"
		},
	})
}
var mU = { url: 0, typeProperty: 0, data: 0, blob: 0, integrity: 0, manualRedirect: 0 },
	dT,
	m$ = !1
function Dm(o, e) {
	m$ &&
		!mU[e]++ &&
		(dT && clearTimeout(dT),
		(dT = setTimeout(() => {
			o.$publicLog2("fetchFeatureUse", mU)
		}, 1e4)),
		dT.unref())
}
function f$(o, e) {
	function t(n, r) {
		let i = n.default || n
		return (i.__vscodeOriginal = Object.assign({}, i)), Object.assign(i, r)
	}
	return { http: t(lU, aU(o, lU, e)), https: t(cT, aU(o, cT, e)), net: t(cU, l$(o, cU)), tls: t(dU, a$(o, dU)) }
}
function g$(o, e) {
	return !Gs(o, e, "http.experimental.systemCertificatesV2", hU) && !!Gs(o, e, "http.systemCertificates")
}
function h$(o, e) {
	return !!Gs(o, e, "http.experimental.systemCertificatesV2", hU) && !!Gs(o, e, "http.systemCertificates")
}
var fU = new Map()
function v$(o, e) {
	return o.getExtensionPathIndex().then((t) => {
		let n = km("module"),
			r = n._load
		n._load = function (s, a, l) {
			if (s === "net") return e.net
			if (s === "tls") return e.tls
			if (s !== "http" && s !== "https" && s !== "undici") return r.apply(this, arguments)
			let d = t.findSubstr(y.file(a.filename)),
				c = fU.get(d)
			if ((c || fU.set(d, (c = {})), !c[s]))
				if (s === "undici") {
					let u = r.apply(this, arguments)
					ec.patchUndici(u), (c[s] = u)
				} else {
					let u = e[s]
					c[s] = { ...u }
				}
			return c[s]
		}
	})
}
async function b$(o, e, t, n, r, i, s, a, l, d, c) {
	let u = r[l]
	d && (r[l] = d),
		e.trace(
			"ProxyResolver#lookupProxyAuthorization callback",
			`proxyURL:${l}`,
			`proxyAuthenticate:${d}`,
			`proxyAuthenticateCache:${u}`,
		)
	let m = d || u,
		f = Array.isArray(m) ? m : typeof m == "string" ? [m] : []
	if ((I$(t, f, s), f.some((g) => /^(Negotiate|Kerberos)( |$)/i.test(g)) && !c.kerberosRequested)) {
		c.kerberosRequested = !0
		try {
			let g = Gs(n, s, "http.proxyKerberosServicePrincipal")
			return "Negotiate " + (await J1(l, g, e, "ProxyResolver#lookupProxyAuthorization"))
		} catch (g) {
			e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication failed", g)
		}
		if (s && a) {
			e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication lookup on host", `proxyURL:${l}`)
			let g = await o.lookupKerberosAuthorization(l)
			if (g) return "Negotiate " + g
		}
	}
	let h = f.find((g) => /^Basic( |$)/i.test(g))
	if (h)
		try {
			let g = i[l]
			if (g)
				if (c.basicAuthCacheUsed)
					e.debug(
						"ProxyResolver#lookupProxyAuthorization Basic authentication deleting cached credentials",
						`proxyURL:${l}`,
					),
						delete i[l]
				else
					return (
						e.debug(
							"ProxyResolver#lookupProxyAuthorization Basic authentication using cached credentials",
							`proxyURL:${l}`,
						),
						(c.basicAuthCacheUsed = !0),
						g
					)
			c.basicAuthAttempt = (c.basicAuthAttempt || 0) + 1
			let I = / realm="([^"]+)"/i.exec(h)?.[1]
			e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication lookup", `proxyURL:${l}`, `realm:${I}`)
			let C = new URL(l),
				T = {
					scheme: "basic",
					host: C.hostname,
					port: Number(C.port),
					realm: I || "",
					isProxy: !0,
					attempt: c.basicAuthAttempt,
				},
				w = await o.lookupAuthorization(T)
			if (w) {
				e.debug(
					"ProxyResolver#lookupProxyAuthorization Basic authentication received credentials",
					`proxyURL:${l}`,
					`realm:${I}`,
				)
				let L = "Basic " + Buffer.from(`${w.username}:${w.password}`).toString("base64")
				return (i[l] = L), L
			} else
				e.debug(
					"ProxyResolver#lookupProxyAuthorization Basic authentication received no credentials",
					`proxyURL:${l}`,
					`realm:${I}`,
				)
		} catch (g) {
			e.error("ProxyResolver#lookupProxyAuthorization Basic authentication failed", g)
		}
}
var gU = !1,
	y$ = !1
function I$(o, e, t) {
	!y$ ||
		gU ||
		!e.length ||
		((gU = !0),
		o.$publicLog2("proxyAuthenticationRequest", {
			authenticationType: e.map((n) => n.split(" ")[0]).join(","),
			extensionHostType: t ? "remote" : "local",
		}))
}
function Gs(o, e, t, n) {
	if (e) return o.getConfiguration().get(t) ?? n
	let r = o.getConfiguration().inspect(t)
	return r?.globalLocalValue ?? r?.defaultValue ?? n
}
import { tmpdir as x$ } from "os"
var Rm = class extends $ {
	constructor(e, t) {
		super()
		let n = e.getProxy(N.MainThreadDownloadService)
		t.registerCommand(!1, "_workbench.downloadResource", async (r) => {
			let i = y.file(Fe(x$(), He()))
			return await n.$download(r, i), i
		})
	}
}
Rm = R([S(0, ie), S(1, Tn)], Rm)
import * as bU from "http"
import * as uT from "fs"
var X1 = class {
		constructor(e, t, n) {
			this._commands = e
			this.logService = t
			this._ipcHandlePath = n
			;(this._server = bU.createServer((r, i) => this.onRequest(r, i))),
				this.setup().catch((r) => (t.error(r), ""))
		}
		get ipcHandlePath() {
			return this._ipcHandlePath
		}
		async setup() {
			try {
				this._server.listen(this.ipcHandlePath), this._server.on("error", (e) => this.logService.error(e))
			} catch {
				this.logService.error("Could not start open from terminal server.")
			}
			return this._ipcHandlePath
		}
		onRequest(e, t) {
			let n = (i, s) => {
					t.writeHead(i, { "content-type": "application/json" }),
						t.end(JSON.stringify(s || null), (a) => a && this.logService.error(a))
				},
				r = []
			e.setEncoding("utf8"),
				e.on("data", (i) => r.push(i)),
				e.on("end", async () => {
					try {
						let i = JSON.parse(r.join("")),
							s
						switch (i.type) {
							case "open":
								s = await this.open(i)
								break
							case "openExternal":
								s = await this.openExternal(i)
								break
							case "status":
								s = await this.getStatus(i)
								break
							case "extensionManagement":
								s = await this.manageExtensions(i)
								break
							default:
								n(404, `Unknown message type: ${i.type}`)
								break
						}
						n(200, s)
					} catch (i) {
						let s = i instanceof Error ? i.message : JSON.stringify(i)
						n(500, s), this.logService.error("Error while processing pipe request", i)
					}
				})
		}
		async open(e) {
			let {
					fileURIs: t,
					folderURIs: n,
					forceNewWindow: r,
					diffMode: i,
					mergeMode: s,
					addMode: a,
					removeMode: l,
					forceReuseWindow: d,
					gotoLineMode: c,
					waitMarkerFilePath: u,
					remoteAuthority: m,
				} = e,
				f = []
			if (Array.isArray(n))
				for (let C of n)
					try {
						f.push({ folderUri: y.parse(C) })
					} catch {}
			if (Array.isArray(t))
				for (let C of t)
					try {
						aL(C) ? f.push({ workspaceUri: y.parse(C) }) : f.push({ fileUri: y.parse(C) })
					} catch {}
			let h = u ? y.file(u) : void 0,
				I = {
					forceNewWindow: r,
					diffMode: i,
					mergeMode: s,
					addMode: a,
					removeMode: l,
					gotoLineMode: c,
					forceReuseWindow: d,
					preferNewWindow: !d && !h && !a && !l,
					waitMarkerFileURI: h,
					remoteAuthority: m,
				}
			this._commands.executeCommand("_remoteCLI.windowOpen", f, I)
		}
		async openExternal(e) {
			for (let t of e.uris) {
				let n = y.parse(t),
					r = n.scheme === "file" ? n : t
				await this._commands.executeCommand("_remoteCLI.openExternal", r)
			}
		}
		async manageExtensions(e) {
			let t = (r) => r?.map((i) => (/\.vsix$/i.test(i) ? y.parse(i) : i)),
				n = { list: e.list, install: t(e.install), uninstall: t(e.uninstall), force: e.force }
			return await this._commands.executeCommand("_remoteCLI.manageExtensions", n)
		}
		async getStatus(e) {
			return await this._commands.executeCommand("_remoteCLI.getSystemStatus")
		}
		dispose() {
			this._server.close(),
				this._ipcHandlePath &&
					process.platform !== "win32" &&
					uT.existsSync(this._ipcHandlePath) &&
					uT.unlinkSync(this._ipcHandlePath)
		}
	},
	Am = class extends X1 {
		constructor(e, t) {
			super(e, t, RO())
		}
	}
Am = R([S(0, Tn), S(1, te)], Am)
var Om = class {
	constructor(e, t) {
		;(this._mainThreadConsole = e.getProxy(N.MainThreadConsole)),
			(this._includeStack = t.consoleForward.includeStack),
			(this._logNative = t.consoleForward.logNative),
			this._wrapConsoleMethod("info", "log"),
			this._wrapConsoleMethod("log", "log"),
			this._wrapConsoleMethod("warn", "warn"),
			this._wrapConsoleMethod("debug", "debug"),
			this._wrapConsoleMethod("error", "error")
	}
	_wrapConsoleMethod(e, t) {
		let n = this,
			r = console[e]
		Object.defineProperty(console, e, {
			set: () => {},
			get: () =>
				function () {
					n._handleConsoleCall(e, t, r, arguments)
				},
		})
	}
	_handleConsoleCall(e, t, n, r) {
		this._mainThreadConsole.$logExtensionHostMessage({
			type: "__$console",
			severity: t,
			arguments: S$(r, this._includeStack),
		}),
			this._logNative && this._nativeConsoleLogMessage(e, n, r)
	}
}
Om = R([S(0, ie), S(1, Xe)], Om)
var C$ = 1e5
function S$(o, e) {
	let t = []
	if (o.length)
		for (let n = 0; n < o.length; n++) {
			let r = o[n]
			if (typeof r > "u") r = "undefined"
			else if (r instanceof Error) {
				let i = r
				i.stack ? (r = i.stack) : (r = i.toString())
			}
			t.push(r)
		}
	if (e) {
		let n = new Error().stack
		n &&
			t.push({
				__$stack: n
					.split(
						`
`,
					)
					.slice(3).join(`
`),
			})
	}
	try {
		let n = rw(t)
		return n.length > C$ ? "Output omitted for a large object that exceeds the limits" : n
	} catch (n) {
		return `Output omitted for an object that cannot be inspected ('${n.toString()}')`
	}
}
var T$ = 1024 * 1024,
	Lm = class extends Om {
		constructor(t, n) {
			super(t, n)
			this._isMakingConsoleCall = !1
			this._wrapStream("stderr", "error"), this._wrapStream("stdout", "log")
		}
		_nativeConsoleLogMessage(t, n, r) {
			let i = t === "error" || t === "warn" ? process.stderr : process.stdout
			;(this._isMakingConsoleCall = !0),
				i.write(`
START_NATIVE_LOG
`),
				n.apply(console, r),
				i.write(`
END_NATIVE_LOG
`),
				(this._isMakingConsoleCall = !1)
		}
		_wrapStream(t, n) {
			let r = process[t],
				i = r.write,
				s = ""
			Object.defineProperty(r, "write", {
				set: () => {},
				get: () => (a, l, d) => {
					if (!this._isMakingConsoleCall) {
						s += a.toString(l)
						let c =
							s.length > T$
								? s.length
								: s.lastIndexOf(`
`)
						c !== -1 && (console[n](s.slice(0, c)), (s = s.slice(c + 1)))
					}
					i.call(r, a, l, d)
				},
			})
		}
	}
Lm = R([S(0, ie), S(1, Xe)], Lm)
import { promises as tc } from "fs"
async function yU(o, e, t, n, r, i) {
	let s
	try {
		await E$(o, e, t, n, r, i)
	} catch (a) {
		s = a
	} finally {
		s && r.errorTransformer && (s = r.errorTransformer(s)), typeof s < "u" && t.error(s), t.end()
	}
}
async function E$(o, e, t, n, r, i) {
	Y1(i)
	let s = await o.open(e, { create: !1 })
	try {
		Y1(i)
		let a = 0,
			l = 0,
			d = r && typeof r.length == "number" ? r.length : void 0,
			c = z.alloc(Math.min(r.bufferSize, typeof d == "number" ? d : r.bufferSize)),
			u = r && typeof r.position == "number" ? r.position : 0,
			m = 0
		do
			(l = await o.read(s, u, c.buffer, m, c.byteLength - m)),
				(u += l),
				(m += l),
				(a += l),
				typeof d == "number" && (d -= l),
				m === c.byteLength &&
					(await t.write(n(c)),
					(c = z.alloc(Math.min(r.bufferSize, typeof d == "number" ? d : r.bufferSize))),
					(m = 0))
		while (l > 0 && (typeof d != "number" || d > 0) && Y1(i) && w$(a, r))
		if (m > 0) {
			let f = m
			typeof d == "number" && (f = Math.min(m, d)), t.write(n(c.slice(0, f)))
		}
	} catch (a) {
		throw ZO(a)
	} finally {
		await o.close(s)
	}
}
function Y1(o) {
	if (o.isCancellationRequested) throw $i()
	return !0
}
function w$(o, e) {
	if (typeof e?.limits?.size == "number" && o > e.limits.size)
		throw Wo(p("fileTooLargeError", "File is too large to open"), "EntryTooLarge")
	return !0
}
var pT = class extends $ {
	constructor(t, n) {
		super()
		this.logService = t
		this.options = n
		this._onDidChangeFile = this._register(new E())
		this.onDidChangeFile = this._onDidChangeFile.event
		this._onDidWatchError = this._register(new E())
		this.onDidWatchError = this._onDidWatchError.event
		this.universalWatchRequests = []
		this.universalWatchRequestDelayer = this._register(
			new Zi(this.getRefreshWatchersDelay(this.universalWatchRequests.length)),
		)
		this.nonRecursiveWatchRequests = []
		this.nonRecursiveWatchRequestDelayer = this._register(
			new Zi(this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)),
		)
	}
	watch(t, n) {
		return n.recursive || this.options?.watcher?.forceUniversal
			? this.watchUniversal(t, n)
			: this.watchNonRecursive(t, n)
	}
	getRefreshWatchersDelay(t) {
		return t > 200 ? 500 : 0
	}
	watchUniversal(t, n) {
		let r = this.toWatchRequest(t, n),
			i = VT(this.universalWatchRequests, r)
		return (
			this.refreshUniversalWatchers(),
			q(() => {
				i(), this.refreshUniversalWatchers()
			})
		)
	}
	toWatchRequest(t, n) {
		let r = {
			path: this.toWatchPath(t),
			excludes: n.excludes,
			includes: n.includes,
			recursive: n.recursive,
			filter: n.filter,
			correlationId: n.correlationId,
		}
		if (wN(r)) {
			let i = this.options?.watcher?.recursive?.usePolling
			i === !0
				? (r.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5e3)
				: Array.isArray(i) &&
					i.includes(r.path) &&
					(r.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5e3)
		}
		return r
	}
	refreshUniversalWatchers() {
		this.universalWatchRequestDelayer
			.trigger(
				() => this.doRefreshUniversalWatchers(),
				this.getRefreshWatchersDelay(this.universalWatchRequests.length),
			)
			.catch((t) => Be(t))
	}
	doRefreshUniversalWatchers() {
		return (
			this.universalWatcher ||
				((this.universalWatcher = this._register(
					this.createUniversalWatcher(
						(t) => this._onDidChangeFile.fire(l1(t)),
						(t) => this.onWatcherLogMessage(t),
						this.logService.getLevel() === 1,
					),
				)),
				this._register(
					this.logService.onDidChangeLogLevel(() => {
						this.universalWatcher?.setVerboseLogging(this.logService.getLevel() === 1)
					}),
				)),
			this.universalWatcher.watch(this.universalWatchRequests)
		)
	}
	watchNonRecursive(t, n) {
		let r = {
				path: this.toWatchPath(t),
				excludes: n.excludes,
				includes: n.includes,
				recursive: !1,
				filter: n.filter,
				correlationId: n.correlationId,
			},
			i = VT(this.nonRecursiveWatchRequests, r)
		return (
			this.refreshNonRecursiveWatchers(),
			q(() => {
				i(), this.refreshNonRecursiveWatchers()
			})
		)
	}
	refreshNonRecursiveWatchers() {
		this.nonRecursiveWatchRequestDelayer
			.trigger(
				() => this.doRefreshNonRecursiveWatchers(),
				this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length),
			)
			.catch((t) => Be(t))
	}
	doRefreshNonRecursiveWatchers() {
		return (
			this.nonRecursiveWatcher ||
				((this.nonRecursiveWatcher = this._register(
					this.createNonRecursiveWatcher(
						(t) => this._onDidChangeFile.fire(l1(t)),
						(t) => this.onWatcherLogMessage(t),
						this.logService.getLevel() === 1,
					),
				)),
				this._register(
					this.logService.onDidChangeLogLevel(() => {
						this.nonRecursiveWatcher?.setVerboseLogging(this.logService.getLevel() === 1)
					}),
				)),
			this.nonRecursiveWatcher.watch(this.nonRecursiveWatchRequests)
		)
	}
	onWatcherLogMessage(t) {
		t.type === "error" && this._onDidWatchError.fire(t.message), this.logWatcherMessage(t)
	}
	logWatcherMessage(t) {
		this.logService[t.type](t.message)
	}
	toFilePath(t) {
		return jn(t.fsPath)
	}
	toWatchPath(t) {
		let n = this.toFilePath(t)
		return _A(n)
	}
}
import { fork as D$ } from "child_process"
function IU(o) {
	let e = o
	return e && typeof e.type == "string" && typeof e.severity == "string"
}
function P$(o) {
	let e = [],
		t
	try {
		let n = JSON.parse(o.arguments),
			r = n[n.length - 1]
		r && r.__$stack && (n.pop(), (t = r.__$stack)), e.push(...n)
	} catch {
		e.push("Unable to log remote console arguments", o.arguments)
	}
	return { args: e, stack: t }
}
function _$(o) {
	if (!o) return o
	let e = o.indexOf(`
`)
	return e === -1 ? o : o.substring(0, e)
}
function xU(o, e) {
	let { args: t, stack: n } = P$(o),
		r = typeof t[0] == "string" && t.length === 1,
		i = _$(n)
	i && (i = `(${i.trim()})`)
	let s = []
	if (
		(typeof t[0] == "string"
			? i && r
				? (s = [`%c[${e}] %c${t[0]} %c${i}`, Mm("blue"), Mm(""), Mm("grey")])
				: (s = [`%c[${e}] %c${t[0]}`, Mm("blue"), Mm(""), ...t.slice(1)])
			: (s = [`%c[${e}]%`, Mm("blue"), ...t]),
		i && !r && s.push(i),
		typeof console[o.severity] != "function")
	)
		throw new Error("Unknown console method")
	console[o.severity].apply(console, s)
}
function Mm(o) {
	return `color: ${o}`
}
var mT = class {
	constructor(e, t) {
		this.modulePath = e
		this.options = t
		this.activeRequests = new Set()
		this.channels = new Map()
		this._onDidProcessExit = new E()
		this.onDidProcessExit = this._onDidProcessExit.event
		let n = t && t.timeout ? t.timeout : 6e4
		;(this.disposeDelayer = new pf(n)), (this.child = null), (this._client = null)
	}
	getChannel(e) {
		let t = this
		return {
			call(n, r, i) {
				return t.requestPromise(e, n, r, i)
			},
			listen(n, r) {
				return t.requestEvent(e, n, r)
			},
		}
	}
	requestPromise(e, t, n, r = De.None) {
		if (!this.disposeDelayer) return Promise.reject(new Error("disposed"))
		if (r.isCancellationRequested) return Promise.reject($i())
		this.disposeDelayer.cancel()
		let i = this.getCachedChannel(e),
			s = kr((d) => i.call(t, n, d)),
			a = r.onCancellationRequested(() => s.cancel()),
			l = q(() => s.cancel())
		return (
			this.activeRequests.add(l),
			s.finally(() => {
				a.dispose(),
					this.activeRequests.delete(l),
					this.activeRequests.size === 0 &&
						this.disposeDelayer &&
						this.disposeDelayer.trigger(() => this.disposeClient())
			}),
			s
		)
	}
	requestEvent(e, t, n) {
		if (!this.disposeDelayer) return Te.None
		this.disposeDelayer.cancel()
		let r,
			i = new E({
				onWillAddFirstListener: () => {
					;(r = this.getCachedChannel(e).listen(t, n)(i.fire, i)), this.activeRequests.add(r)
				},
				onDidRemoveLastListener: () => {
					this.activeRequests.delete(r),
						r.dispose(),
						this.activeRequests.size === 0 &&
							this.disposeDelayer &&
							this.disposeDelayer.trigger(() => this.disposeClient())
				},
			})
		return i.event
	}
	get client() {
		if (!this._client) {
			let e = this.options && this.options.args ? this.options.args : [],
				t = Object.create(null)
			;(t.env = { ...je(process.env), VSCODE_PARENT_PID: String(process.pid) }),
				this.options && this.options.env && (t.env = { ...t.env, ...this.options.env }),
				this.options && this.options.freshExecArgv && (t.execArgv = []),
				this.options &&
					typeof this.options.debug == "number" &&
					(t.execArgv = ["--nolazy", "--inspect=" + this.options.debug]),
				this.options &&
					typeof this.options.debugBrk == "number" &&
					(t.execArgv = ["--nolazy", "--inspect-brk=" + this.options.debugBrk]),
				t.execArgv === void 0 &&
					(t.execArgv = process.execArgv
						.filter((u) => !/^--inspect(-brk)?=/.test(u))
						.filter((u) => !u.startsWith("--vscode-"))),
				W2(t.env),
				(this.child = D$(this.modulePath, e, t))
			let n = new E(),
				i = Te.fromNodeEventEmitter(
					this.child,
					"message",
					(u) => u,
				)((u) => {
					if (IU(u)) {
						xU(u, `IPC Library: ${this.options.serverName}`)
						return
					}
					n.fire(z.wrap(Buffer.from(u, "base64")))
				}),
				s = this.options.useQueue ? B2(this.child) : this.child,
				a = (u) => this.child && this.child.connected && s.send(u.buffer.toString("base64")),
				l = n.event,
				d = { send: a, onMessage: l }
			this._client = new Cf(d)
			let c = () => this.disposeClient()
			process.once("exit", c),
				this.child.on("error", (u) => console.warn('IPC "' + this.options.serverName + '" errored with ' + u)),
				this.child.on("exit", (u, m) => {
					process.removeListener("exit", c),
						i.dispose(),
						this.activeRequests.forEach((f) => Fn(f)),
						this.activeRequests.clear(),
						u !== 0 &&
							m !== "SIGTERM" &&
							console.warn(
								'IPC "' +
									this.options.serverName +
									'" crashed with exit code ' +
									u +
									" and signal " +
									m,
							),
						this.disposeDelayer?.cancel(),
						this.disposeClient(),
						this._onDidProcessExit.fire({ code: u, signal: m })
				})
		}
		return this._client
	}
	getCachedChannel(e) {
		let t = this.channels.get(e)
		return t || ((t = this.client.getChannel(e)), this.channels.set(e, t)), t
	}
	disposeClient() {
		this._client &&
			(this.child && (this.child.kill(), (this.child = null)), (this._client = null), this.channels.clear())
	}
	dispose() {
		this._onDidProcessExit.dispose(),
			this.disposeDelayer?.cancel(),
			(this.disposeDelayer = void 0),
			this.disposeClient(),
			this.activeRequests.clear()
	}
}
var fT = class extends ZC {
	constructor(e, t, n) {
		super(e, t, n), this.init()
	}
	createWatcher(e) {
		let t = e.add(
			new mT(Ic.asFileUri("bootstrap-fork").fsPath, {
				serverName: "File Watcher",
				args: ["--type=fileWatcher"],
				env: {
					VSCODE_ESM_ENTRYPOINT: "vs/platform/files/node/watcher/watcherMain",
					VSCODE_PIPE_LOGGING: "true",
					VSCODE_VERBOSE_LOGGING: "true",
				},
			}),
		)
		return (
			e.add(
				t.onDidProcessExit(({ code: n, signal: r }) =>
					this.onError(`terminated by itself with code ${n}, signal: ${r} (ETERM)`),
				),
			),
			jE.toService(PO(t.getChannel("watcher")))
		)
	}
}
import { watchFile as k$, unwatchFile as R$ } from "fs"
var gT = class extends $ {
	constructor() {
		super()
		this._onDidChangeFile = this._register(new E())
		this.onDidChangeFile = this._onDidChangeFile.event
		this._onDidLogMessage = this._register(new E())
		this.onDidLogMessage = this._onDidLogMessage.event
		this._onDidWatchFail = this._register(new E())
		this.onDidWatchFail = this._onDidWatchFail.event
		this.correlatedWatchRequests = new Map()
		this.nonCorrelatedWatchRequests = new Map()
		this.suspendedWatchRequests = this._register(new Wr())
		this.suspendedWatchRequestsWithPolling = new Set()
		this.updateWatchersDelayer = this._register(new Zi(this.getUpdateWatchersDelay()))
		this.suspendedWatchRequestPollingInterval = 5007
		this.joinWatch = new Cn()
		this.verboseLogging = !1
		this._register(
			this.onDidWatchFail((t) =>
				this.suspendWatchRequest({
					id: this.computeId(t),
					correlationId: this.isCorrelated(t) ? t.correlationId : void 0,
					path: t.path,
				}),
			),
		)
	}
	isCorrelated(t) {
		return eS(t)
	}
	computeId(t) {
		return this.isCorrelated(t) ? t.correlationId : ar(t)
	}
	async watch(t) {
		this.joinWatch.isSettled || this.joinWatch.complete(), (this.joinWatch = new Cn())
		try {
			this.correlatedWatchRequests.clear(), this.nonCorrelatedWatchRequests.clear()
			for (let n of t)
				this.isCorrelated(n)
					? this.correlatedWatchRequests.set(n.correlationId, n)
					: this.nonCorrelatedWatchRequests.set(this.computeId(n), n)
			for (let [n] of this.suspendedWatchRequests)
				!this.nonCorrelatedWatchRequests.has(n) &&
					!this.correlatedWatchRequests.has(n) &&
					(this.suspendedWatchRequests.deleteAndDispose(n), this.suspendedWatchRequestsWithPolling.delete(n))
			return await this.updateWatchers(!1)
		} finally {
			this.joinWatch.complete()
		}
	}
	updateWatchers(t) {
		let n = []
		for (let [r, i] of [...this.nonCorrelatedWatchRequests, ...this.correlatedWatchRequests])
			this.suspendedWatchRequests.has(r) || n.push(i)
		return this.updateWatchersDelayer
			.trigger(() => this.doWatch(n), t ? this.getUpdateWatchersDelay() : 0)
			.catch((r) => Be(r))
	}
	getUpdateWatchersDelay() {
		return 800
	}
	isSuspended(t) {
		let n = this.computeId(t)
		return this.suspendedWatchRequestsWithPolling.has(n) ? "polling" : this.suspendedWatchRequests.has(n)
	}
	async suspendWatchRequest(t) {
		if (this.suspendedWatchRequests.has(t.id)) return
		let n = new Q()
		this.suspendedWatchRequests.set(t.id, n),
			await this.joinWatch.p,
			!n.isDisposed && (this.monitorSuspendedWatchRequest(t, n), this.updateWatchers(!0))
	}
	resumeWatchRequest(t) {
		this.suspendedWatchRequests.deleteAndDispose(t.id),
			this.suspendedWatchRequestsWithPolling.delete(t.id),
			this.updateWatchers(!1)
	}
	monitorSuspendedWatchRequest(t, n) {
		this.doMonitorWithExistingWatcher(t, n)
			? (this.trace(`reusing an existing recursive watcher to monitor ${t.path}`),
				this.suspendedWatchRequestsWithPolling.delete(t.id))
			: (this.doMonitorWithNodeJS(t, n), this.suspendedWatchRequestsWithPolling.add(t.id))
	}
	doMonitorWithExistingWatcher(t, n) {
		let r = this.recursiveWatcher?.subscribe(t.path, (i, s) => {
			n.isDisposed ||
				(i ? this.monitorSuspendedWatchRequest(t, n) : s?.type === 1 && this.onMonitoredPathAdded(t))
		})
		return r ? (n.add(r), !0) : !1
	}
	doMonitorWithNodeJS(t, n) {
		let r = !1,
			i = (s, a) => {
				if (n.isDisposed) return
				let l = this.isPathNotFound(s),
					d = this.isPathNotFound(a),
					c = r
				;(r = l), !l && (d || c) && this.onMonitoredPathAdded(t)
			}
		this.trace(`starting fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`)
		try {
			k$(t.path, { persistent: !1, interval: this.suspendedWatchRequestPollingInterval }, i)
		} catch (s) {
			this.warn(`fs.watchFile() failed with error ${s} on path ${t.path} (correlationId: ${t.correlationId})`)
		}
		n.add(
			q(() => {
				this.trace(`stopping fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`)
				try {
					R$(t.path, i)
				} catch (s) {
					this.warn(
						`fs.unwatchFile() failed with error ${s} on path ${t.path} (correlationId: ${t.correlationId})`,
					)
				}
			}),
		)
	}
	onMonitoredPathAdded(t) {
		this.trace(`detected ${t.path} exists again, resuming watcher (correlationId: ${t.correlationId})`)
		let n = { resource: y.file(t.path), type: 1, cId: t.correlationId }
		this._onDidChangeFile.fire([n]), this.traceEvent(n, t), this.resumeWatchRequest(t)
	}
	isPathNotFound(t) {
		return t.ctimeMs === 0 && t.ino === 0
	}
	async stop() {
		this.suspendedWatchRequests.clearAndDisposeAll(), this.suspendedWatchRequestsWithPolling.clear()
	}
	traceEvent(t, n) {
		if (this.verboseLogging) {
			let r = ` >> normalized ${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`
			this.traceWithCorrelation(r, n)
		}
	}
	traceWithCorrelation(t, n) {
		this.verboseLogging && this.trace(`${t}${typeof n.correlationId == "number" ? ` <${n.correlationId}> ` : ""}`)
	}
	requestToString(t) {
		return `${t.path} (excludes: ${t.excludes.length > 0 ? t.excludes : "<none>"}, includes: ${t.includes && t.includes.length > 0 ? JSON.stringify(t.includes) : "<all>"}, filter: ${DN(t.filter)}, correlationId: ${typeof t.correlationId == "number" ? t.correlationId : "<none>"})`
	}
	async setVerboseLogging(t) {
		this.verboseLogging = t
	}
}
import { watch as A$, promises as O$ } from "fs"
var hT = class o extends $ {
	constructor(t, n, r, i, s, a) {
		super()
		this.request = t
		this.recursiveWatcher = n
		this.onDidFilesChange = r
		this.onDidWatchFail = i
		this.onLogMessage = s
		this.verboseLogging = a
		this.throttledFileChangesEmitter = this._register(
			new Tc({ maxWorkChunkSize: 100, throttleDelay: 200, maxBufferedWork: 1e4 }, (t) =>
				this.onDidFilesChange(t),
			),
		)
		this.fileChangesAggregator = this._register(
			new Lv((t) => this.handleFileChanges(t), o.FILE_CHANGES_HANDLER_DELAY),
		)
		this.cts = new _e()
		this.realPath = new Rt(async () => {
			let t = this.request.path
			try {
				;(t = await Vv(this.request.path)),
					this.request.path !== t &&
						this.trace(
							`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${t})`,
						)
			} catch {}
			return t
		})
		this._isReusingRecursiveWatcher = !1
		this.didFail = !1
		;(this.excludes = c1(this.request.path, this.request.excludes)),
			(this.includes = this.request.includes ? c1(this.request.path, this.request.includes) : void 0),
			(this.filter = eS(this.request) ? this.request.filter : void 0),
			(this.ready = this.watch())
	}
	static {
		this.FILE_DELETE_HANDLER_DELAY = 100
	}
	static {
		this.FILE_CHANGES_HANDLER_DELAY = 75
	}
	get isReusingRecursiveWatcher() {
		return this._isReusingRecursiveWatcher
	}
	get failed() {
		return this.didFail
	}
	async watch() {
		try {
			let t = await O$.stat(this.request.path)
			if (this.cts.token.isCancellationRequested) return
			this._register(await this.doWatch(t.isDirectory()))
		} catch (t) {
			t.code !== "ENOENT"
				? this.error(t)
				: this.trace(
						`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${t})`,
					),
				this.notifyWatchFailed()
		}
	}
	notifyWatchFailed() {
		;(this.didFail = !0), this.onDidWatchFail?.()
	}
	async doWatch(t) {
		let n = new Q()
		return (
			this.doWatchWithExistingWatcher(t, n)
				? (this.trace(`reusing an existing recursive watcher for ${this.request.path}`),
					(this._isReusingRecursiveWatcher = !0))
				: ((this._isReusingRecursiveWatcher = !1), await this.doWatchWithNodeJS(t, n)),
			n
		)
	}
	doWatchWithExistingWatcher(t, n) {
		if (t) return !1
		let r = y.file(this.request.path),
			i = this.recursiveWatcher?.subscribe(this.request.path, async (s, a) => {
				if (!n.isDisposed)
					if (s) {
						let l = await this.doWatch(t)
						n.isDisposed ? l.dispose() : n.add(l)
					} else
						a &&
							(typeof a.cId == "number" || typeof this.request.correlationId == "number") &&
							this.onFileChange({ resource: r, type: a.type, cId: this.request.correlationId }, !0)
			})
		return i ? (n.add(i), !0) : !1
	}
	async doWatchWithNodeJS(t, n) {
		let r = await this.realPath.value
		if (this.cts.token.isCancellationRequested) return
		if (st && zr(r, "/Volumes/", !0)) {
			this.error(
				`Refusing to watch ${r} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`,
			)
			return
		}
		let i = new _e(this.cts.token)
		n.add(q(() => i.dispose(!0)))
		let s = new Q()
		n.add(s)
		try {
			let a = y.file(this.request.path),
				l = Ze(r),
				d = A$(r)
			s.add(
				q(() => {
					d.removeAllListeners(), d.close()
				}),
			),
				this.trace(`Started watching: '${r}'`)
			let c = new Set()
			if (t)
				try {
					for (let m of await Qe.readdir(r)) c.add(m)
				} catch (m) {
					this.error(m)
				}
			if (i.token.isCancellationRequested) return
			let u = new Map()
			s.add(
				q(() => {
					for (let [, m] of u) m.dispose()
					u.clear()
				}),
			),
				d.on("error", (m, f) => {
					i.token.isCancellationRequested ||
						(this.error(`Failed to watch ${r} for changes using fs.watch() (${m}, ${f})`),
						this.notifyWatchFailed())
				}),
				d.on("change", (m, f) => {
					if (i.token.isCancellationRequested) return
					this.verboseLogging && this.traceWithCorrelation(`[raw] ["${m}"] ${f}`)
					let h = ""
					if ((f && ((h = f.toString()), st && (h = Ll(h))), !(!h || (m !== "change" && m !== "rename"))))
						if (t)
							if (m === "rename") {
								u.get(h)?.dispose()
								let g = setTimeout(async () => {
									if ((u.delete(h), yc(h, l, !Ve) && !(await Qe.exists(r)))) {
										this.onWatchedPathDeleted(a)
										return
									}
									if (i.token.isCancellationRequested) return
									let I = await this.existsChildStrictCase(Fe(r, h))
									if (i.token.isCancellationRequested) return
									let C
									I ? (c.has(h) ? (C = 0) : ((C = 1), c.add(h))) : (c.delete(h), (C = 2)),
										this.onFileChange({
											resource: ct(a, h),
											type: C,
											cId: this.request.correlationId,
										})
								}, o.FILE_DELETE_HANDLER_DELAY)
								u.set(
									h,
									q(() => clearTimeout(g)),
								)
							} else {
								let g
								c.has(h) ? (g = 0) : ((g = 1), c.add(h)),
									this.onFileChange({ resource: ct(a, h), type: g, cId: this.request.correlationId })
							}
						else if (m === "rename" || !yc(h, l, !Ve)) {
							let g = setTimeout(async () => {
								let I = await Qe.exists(r)
								i.token.isCancellationRequested ||
									(I
										? (this.onFileChange(
												{ resource: a, type: 0, cId: this.request.correlationId },
												!0,
											),
											s.add(await this.doWatch(!1)))
										: this.onWatchedPathDeleted(a))
							}, o.FILE_DELETE_HANDLER_DELAY)
							s.clear(), s.add(q(() => clearTimeout(g)))
						} else this.onFileChange({ resource: a, type: 0, cId: this.request.correlationId }, !0)
				})
		} catch (a) {
			if (i.token.isCancellationRequested) return
			this.error(`Failed to watch ${r} for changes using fs.watch() (${a.toString()})`), this.notifyWatchFailed()
		}
	}
	onWatchedPathDeleted(t) {
		this.warn("Watcher shutdown because watched path got deleted"),
			this.onFileChange({ resource: t, type: 2, cId: this.request.correlationId }, !0),
			this.fileChangesAggregator.flush(),
			this.notifyWatchFailed()
	}
	onFileChange(t, n = !1) {
		this.cts.token.isCancellationRequested ||
			(this.verboseLogging &&
				this.traceWithCorrelation(
					`${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`,
				),
			!n && this.excludes.some((r) => r(t.resource.fsPath))
				? this.verboseLogging && this.traceWithCorrelation(` >> ignored (excluded) ${t.resource.fsPath}`)
				: !n && this.includes && this.includes.length > 0 && !this.includes.some((r) => r(t.resource.fsPath))
					? this.verboseLogging &&
						this.traceWithCorrelation(` >> ignored (not included) ${t.resource.fsPath}`)
					: this.fileChangesAggregator.work(t))
	}
	handleFileChanges(t) {
		let n = PN(t),
			r = []
		for (let s of n) {
			if (_N(s, this.filter)) {
				this.verboseLogging && this.traceWithCorrelation(` >> ignored (filtered) ${s.resource.fsPath}`)
				continue
			}
			r.push(s)
		}
		if (r.length === 0) return
		if (this.verboseLogging)
			for (let s of r)
				this.traceWithCorrelation(
					` >> normalized ${s.type === 1 ? "[ADDED]" : s.type === 2 ? "[DELETED]" : "[CHANGED]"} ${s.resource.fsPath}`,
				)
		this.throttledFileChangesEmitter.work(r)
			? this.throttledFileChangesEmitter.pending > 0 &&
				this.trace(
					`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${r[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
				)
			: this.warn(
					`started ignoring events due to too many file change events at once (incoming: ${r.length}, most recent change: ${r[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
				)
	}
	async existsChildStrictCase(t) {
		if (Ve) return Qe.exists(t)
		try {
			let n = Ze(t)
			return (await Qe.readdir(Qt(t))).some((i) => i === n)
		} catch (n) {
			return this.trace(n), !1
		}
	}
	setVerboseLogging(t) {
		this.verboseLogging = t
	}
	error(t) {
		this.cts.token.isCancellationRequested ||
			this.onLogMessage?.({ type: "error", message: `[File Watcher (node.js)] ${t}` })
	}
	warn(t) {
		this.cts.token.isCancellationRequested ||
			this.onLogMessage?.({ type: "warn", message: `[File Watcher (node.js)] ${t}` })
	}
	trace(t) {
		!this.cts.token.isCancellationRequested &&
			this.verboseLogging &&
			this.onLogMessage?.({ type: "trace", message: `[File Watcher (node.js)] ${t}` })
	}
	traceWithCorrelation(t) {
		!this.cts.token.isCancellationRequested &&
			this.verboseLogging &&
			this.trace(
				`${t}${typeof this.request.correlationId == "number" ? ` <${this.request.correlationId}> ` : ""}`,
			)
	}
	dispose() {
		this.cts.dispose(!0), super.dispose()
	}
}
var vT = class extends gT {
	constructor(t) {
		super()
		this.recursiveWatcher = t
		this.onDidError = Te.None
		this._watchers = new Map()
		this.worker = this._register(new Dn())
	}
	get watchers() {
		return this._watchers.values()
	}
	async doWatch(t) {
		t = this.removeDuplicateRequests(t)
		let n = [],
			r = new Set(Array.from(this.watchers))
		for (let i of t) {
			let s = this._watchers.get(this.requestToWatcherKey(i))
			s && e_(s.request.excludes, i.excludes) && e_(s.request.includes, i.includes) ? r.delete(s) : n.push(i)
		}
		n.length && this.trace(`Request to start watching: ${n.map((i) => this.requestToString(i)).join(",")}`),
			r.size &&
				this.trace(
					`Request to stop watching: ${Array.from(r)
						.map((i) => this.requestToString(i.request))
						.join(",")}`,
				),
			this.worker.clear()
		for (let i of r) this.stopWatching(i)
		this.createWatchWorker().work(n)
	}
	createWatchWorker() {
		return (
			(this.worker.value = new Tc(
				{ maxWorkChunkSize: 100, throttleDelay: 100, maxBufferedWork: Number.MAX_VALUE },
				(t) => {
					for (let n of t) this.startWatching(n)
				},
			)),
			this.worker.value
		)
	}
	requestToWatcherKey(t) {
		return typeof t.correlationId == "number" ? t.correlationId : this.pathToWatcherKey(t.path)
	}
	pathToWatcherKey(t) {
		return Ve ? t : t.toLowerCase()
	}
	startWatching(t) {
		let n = new hT(
				t,
				this.recursiveWatcher,
				(i) => this._onDidChangeFile.fire(i),
				() => this._onDidWatchFail.fire(t),
				(i) => this._onDidLogMessage.fire(i),
				this.verboseLogging,
			),
			r = { request: t, instance: n }
		this._watchers.set(this.requestToWatcherKey(t), r)
	}
	async stop() {
		await super.stop()
		for (let t of this.watchers) this.stopWatching(t)
	}
	stopWatching(t) {
		this.trace("stopping file watcher", t),
			this._watchers.delete(this.requestToWatcherKey(t.request)),
			t.instance.dispose()
	}
	removeDuplicateRequests(t) {
		let n = new Map()
		for (let r of t) {
			let i = n.get(r.correlationId)
			i || ((i = new Map()), n.set(r.correlationId, i))
			let s = this.pathToWatcherKey(r.path)
			i.has(s) &&
				this.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(r)}`),
				i.set(s, r)
		}
		return Array.from(n.values())
			.map((r) => Array.from(r.values()))
			.flat()
	}
	async setVerboseLogging(t) {
		super.setVerboseLogging(t)
		for (let n of this.watchers) n.instance.setVerboseLogging(t)
	}
	trace(t, n) {
		this.verboseLogging && this._onDidLogMessage.fire({ type: "trace", message: this.toMessage(t, n) })
	}
	warn(t) {
		this._onDidLogMessage.fire({ type: "warn", message: this.toMessage(t) })
	}
	toMessage(t, n) {
		return n
			? `[File Watcher (node.js)] ${t} (${this.requestToString(n.request)})`
			: `[File Watcher (node.js)] ${t}`
	}
}
var bT = class extends YC {
	constructor(e, t, n) {
		super(e, t, n), this.init()
	}
	createWatcher(e) {
		return e.add(new vT(void 0))
	}
}
var yT = class o extends pT {
	constructor(t, n) {
		super(t, n)
		this.onDidChangeCapabilities = Te.None
		this.resourceLocks = new ft((t) => Rl.getComparisonKey(t))
		this.mapHandleToPos = new Map()
		this.mapHandleToLock = new Map()
		this.writeHandles = new Map()
	}
	static {
		this.TRACE_LOG_RESOURCE_LOCKS = !1
	}
	get capabilities() {
		return (
			this._capabilities || ((this._capabilities = 253982), Ve && (this._capabilities |= 1024)),
			this._capabilities
		)
	}
	async stat(t) {
		try {
			let { stat: n, symbolicLink: r } = await or.stat(this.toFilePath(t))
			return {
				type: this.toType(n, r),
				ctime: n.birthtime.getTime(),
				mtime: n.mtime.getTime(),
				size: n.size,
				permissions: (n.mode & 128) === 0 ? 2 : void 0,
			}
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	async statIgnoreError(t) {
		try {
			return await this.stat(t)
		} catch {
			return
		}
	}
	async readdir(t) {
		try {
			let n = await Qe.readdir(this.toFilePath(t), { withFileTypes: !0 }),
				r = []
			return (
				await Promise.all(
					n.map(async (i) => {
						try {
							let s
							i.isSymbolicLink() ? (s = (await this.stat(ct(t, i.name))).type) : (s = this.toType(i)),
								r.push([i.name, s])
						} catch (s) {
							this.logService.trace(s)
						}
					}),
				),
				r
			)
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	toType(t, n) {
		let r
		return n?.dangling ? (r = 0) : t.isFile() ? (r = 1) : t.isDirectory() ? (r = 2) : (r = 0), n && (r |= 64), r
	}
	async createResourceLock(t) {
		let n = this.toFilePath(t)
		this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${n})`)
		let r
		for (; (r = this.resourceLocks.get(t)); )
			this.traceLock(
				`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${n})`,
			),
				await r.wait()
		let i = new dn()
		return (
			this.resourceLocks.set(t, i),
			this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${n})`),
			q(() => {
				this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${n})`),
					this.resourceLocks.get(t) === i &&
						(this.traceLock(
							`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${n})`,
						),
						this.resourceLocks.delete(t)),
					this.traceLock(
						`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${n})`,
					),
					i.open()
			})
		)
	}
	async readFile(t, n) {
		let r
		try {
			n?.atomic &&
				(this.traceLock(`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(t)})`),
				(r = await this.createResourceLock(t)))
			let i = this.toFilePath(t)
			return await tc.readFile(i)
		} catch (i) {
			throw this.toFileSystemProviderError(i)
		} finally {
			r?.dispose()
		}
	}
	traceLock(t) {
		o.TRACE_LOG_RESOURCE_LOCKS && this.logService.trace(t)
	}
	readFileStream(t, n, r) {
		let i = Al((s) => z.concat(s.map((a) => z.wrap(a))).buffer)
		return yU(this, t, i, (s) => s.buffer, { ...n, bufferSize: 256 * 1024 }, r), i
	}
	async writeFile(t, n, r) {
		return r?.atomic !== !1 && r?.atomic?.postfix && (await this.canWriteFileAtomic(t))
			? this.doWriteFileAtomic(t, ct(Yi(t), `${Ht(t)}${r.atomic.postfix}`), n, r)
			: this.doWriteFile(t, n, r)
	}
	async canWriteFileAtomic(t) {
		try {
			let n = this.toFilePath(t),
				{ symbolicLink: r } = await or.stat(n)
			if (r) return !1
		} catch {}
		return !0
	}
	async doWriteFileAtomic(t, n, r, i) {
		let s = new Q()
		try {
			s.add(await this.createResourceLock(t)),
				s.add(await this.createResourceLock(n)),
				await this.doWriteFile(n, r, i, !0)
			try {
				await this.rename(n, t, { overwrite: !0 })
			} catch (a) {
				try {
					await this.delete(n, { recursive: !1, useTrash: !1, atomic: !1 })
				} catch {}
				throw a
			}
		} finally {
			s.dispose()
		}
	}
	async doWriteFile(t, n, r, i) {
		let s
		try {
			let a = this.toFilePath(t)
			if (!r.create || !r.overwrite) {
				if (await Qe.exists(a)) {
					if (!r.overwrite) throw Wo(p("fileExists", "File already exists"), "EntryExists")
				} else if (!r.create) throw Wo(p("fileNotExists", "File does not exist"), "EntryNotFound")
			}
			;(s = await this.open(t, { create: !0, unlock: r.unlock }, i)), await this.write(s, 0, n, 0, n.byteLength)
		} catch (a) {
			throw await this.toFileSystemProviderWriteError(t, a)
		} finally {
			typeof s == "number" && (await this.close(s))
		}
	}
	static {
		this.canFlush = !0
	}
	static configureFlushOnWrite(t) {
		o.canFlush = t
	}
	async open(t, n, r) {
		let i = this.toFilePath(t),
			s
		Kl(n) && !r && (s = await this.createResourceLock(t))
		let a
		try {
			if (Kl(n) && n.unlock)
				try {
					let { stat: l } = await or.stat(i)
					l.mode & 128 || (await tc.chmod(i, l.mode | 128))
				} catch (l) {
					l.code !== "ENOENT" && this.logService.trace(l)
				}
			if (Ie && Kl(n))
				try {
					;(a = await Qe.open(i, "r+")), await Qe.ftruncate(a, 0)
				} catch (l) {
					if ((l.code !== "ENOENT" && this.logService.trace(l), typeof a == "number")) {
						try {
							await Qe.close(a)
						} catch (d) {
							this.logService.trace(d)
						}
						a = void 0
					}
				}
			typeof a != "number" && (a = await Qe.open(i, Kl(n) ? "w" : "r"))
		} catch (l) {
			throw (
				(s?.dispose(),
				Kl(n) ? await this.toFileSystemProviderWriteError(t, l) : this.toFileSystemProviderError(l))
			)
		}
		if ((this.mapHandleToPos.set(a, 0), Kl(n) && this.writeHandles.set(a, t), s)) {
			let l = this.mapHandleToLock.get(a)
			this.traceLock(`[Disk FileSystemProvider]: open() - storing lock for handle ${a} (${i})`),
				this.mapHandleToLock.set(a, s),
				l &&
					(this.traceLock(
						`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${a} (${i})`,
					),
					l.dispose())
		}
		return a
	}
	async close(t) {
		let n = this.mapHandleToLock.get(t)
		try {
			if ((this.mapHandleToPos.delete(t), this.writeHandles.delete(t) && o.canFlush))
				try {
					await Qe.fdatasync(t)
				} catch (r) {
					o.configureFlushOnWrite(!1), this.logService.error(r)
				}
			return await Qe.close(t)
		} catch (r) {
			throw this.toFileSystemProviderError(r)
		} finally {
			n &&
				(this.mapHandleToLock.get(t) === n &&
					(this.traceLock(
						`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${t}`,
					),
					this.mapHandleToLock.delete(t)),
				this.traceLock(`[Disk FileSystemProvider]: close() - disposing lock for handle ${t}`),
				n.dispose())
		}
	}
	async read(t, n, r, i, s) {
		let a = this.normalizePos(t, n),
			l = null
		try {
			l = (await Qe.read(t, r, i, s, a)).bytesRead
		} catch (d) {
			throw this.toFileSystemProviderError(d)
		} finally {
			this.updatePos(t, a, l)
		}
		return l
	}
	normalizePos(t, n) {
		return n === this.mapHandleToPos.get(t) ? null : n
	}
	updatePos(t, n, r) {
		let i = this.mapHandleToPos.get(t)
		typeof i == "number" &&
			(typeof n == "number" ||
				(typeof r == "number" ? this.mapHandleToPos.set(t, i + r) : this.mapHandleToPos.delete(t)))
	}
	async write(t, n, r, i, s) {
		return zA(() => this.doWrite(t, n, r, i, s), 100, 3)
	}
	async doWrite(t, n, r, i, s) {
		let a = this.normalizePos(t, n),
			l = null
		try {
			l = (await Qe.write(t, r, i, s, a)).bytesWritten
		} catch (d) {
			throw await this.toFileSystemProviderWriteError(this.writeHandles.get(t), d)
		} finally {
			this.updatePos(t, a, l)
		}
		return l
	}
	async mkdir(t) {
		try {
			await tc.mkdir(this.toFilePath(t))
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	async delete(t, n) {
		try {
			let r = this.toFilePath(t)
			if (n.recursive) {
				let i
				n?.atomic !== !1 && n.atomic.postfix && (i = Fe(Qt(r), `${Ze(r)}${n.atomic.postfix}`)),
					await Qe.rm(r, 1, i)
			} else
				try {
					await tc.unlink(r)
				} catch (i) {
					if (i.code === "EPERM" || i.code === "EISDIR") {
						let s = !1
						try {
							let { stat: a, symbolicLink: l } = await or.stat(r)
							s = a.isDirectory() && !l
						} catch {}
						if (s) await tc.rmdir(r)
						else throw i
					} else throw i
				}
		} catch (r) {
			throw this.toFileSystemProviderError(r)
		}
	}
	async rename(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n)
		if (i !== s)
			try {
				await this.validateMoveCopy(t, n, "move", r.overwrite), await Qe.rename(i, s)
			} catch (a) {
				throw (
					((a.code === "EINVAL" || a.code === "EBUSY" || a.code === "ENAMETOOLONG") &&
						(a = new Error(
							p("moveError", "Unable to move '{0}' into '{1}' ({2}).", Ze(i), Ze(Qt(s)), a.toString()),
						)),
					this.toFileSystemProviderError(a))
				)
			}
	}
	async copy(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n)
		if (i !== s)
			try {
				await this.validateMoveCopy(t, n, "copy", r.overwrite), await Qe.copy(i, s, { preserveSymlinks: !0 })
			} catch (a) {
				throw (
					((a.code === "EINVAL" || a.code === "EBUSY" || a.code === "ENAMETOOLONG") &&
						(a = new Error(
							p("copyError", "Unable to copy '{0}' into '{1}' ({2}).", Ze(i), Ze(Qt(s)), a.toString()),
						)),
					this.toFileSystemProviderError(a))
				)
			}
	}
	async validateMoveCopy(t, n, r, i) {
		let s = this.toFilePath(t),
			a = this.toFilePath(n),
			l = !1
		if ((!!(this.capabilities & 1024) || (l = yc(s, a, !0)), l)) {
			if (r === "copy")
				throw Wo(
					p("fileCopyErrorPathCase", "File cannot be copied to same path with different path case"),
					"EntryExists",
				)
			if (r === "move") return
		}
		let c = await this.statIgnoreError(t)
		if (!c) throw Wo(p("fileMoveCopyErrorNotFound", "File to move/copy does not exist"), "EntryNotFound")
		let u = await this.statIgnoreError(n)
		if (u) {
			if (!i)
				throw Wo(
					p(
						"fileMoveCopyErrorExists",
						"File at target already exists and thus will not be moved/copied to unless overwrite is specified",
					),
					"EntryExists",
				)
			;((c.type & 1) !== 0 && (u.type & 1) !== 0) ||
				(await this.delete(n, { recursive: !0, useTrash: !1, atomic: !1 }))
		}
	}
	async cloneFile(t, n) {
		return this.doCloneFile(t, n, !1)
	}
	async doCloneFile(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n),
			a = !!(this.capabilities & 1024)
		if (yc(i, s, !a)) return
		let l = new Q()
		try {
			l.add(await this.createResourceLock(t)),
				l.add(await this.createResourceLock(n)),
				r && (await tc.mkdir(Qt(s), { recursive: !0 })),
				await tc.copyFile(i, s)
		} catch (d) {
			if (d.code === "ENOENT" && !r) return this.doCloneFile(t, n, !0)
			throw this.toFileSystemProviderError(d)
		} finally {
			l.dispose()
		}
	}
	createUniversalWatcher(t, n, r) {
		return new fT(
			(i) => t(i),
			(i) => n(i),
			r,
		)
	}
	createNonRecursiveWatcher(t, n, r) {
		return new bT(
			(i) => t(i),
			(i) => n(i),
			r,
		)
	}
	toFileSystemProviderError(t) {
		if (t instanceof ga) return t
		let n = t,
			r
		switch (t.code) {
			case "ENOENT":
				r = "EntryNotFound"
				break
			case "EISDIR":
				r = "EntryIsADirectory"
				break
			case "ENOTDIR":
				r = "EntryNotADirectory"
				break
			case "EEXIST":
				r = "EntryExists"
				break
			case "EPERM":
			case "EACCES":
				r = "NoPermissions"
				break
			case "ERR_UNC_HOST_NOT_ALLOWED":
				;(n = `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`),
					(r = "Unknown")
				break
			default:
				r = "Unknown"
		}
		return Wo(n, r)
	}
	async toFileSystemProviderWriteError(t, n) {
		let r = this.toFileSystemProviderError(n)
		if (t && r.code === "NoPermissions")
			try {
				let { stat: i } = await or.stat(this.toFilePath(t))
				i.mode & 128 || (r = Wo(n, "EntryWriteLocked"))
			} catch (i) {
				this.logService.trace(i)
			}
		return r
	}
}
var Fm = class {
	constructor(e, t) {
		e.addFileSystemProvider(W.file, new Z1(t), { isCaseSensitive: Ve })
	}
}
Fm = R([S(0, Li), S(1, te)], Fm)
var Z1 = class {
	constructor(e) {
		this.impl = new yT(e)
	}
	async stat(e) {
		let t = await this.impl.stat(e)
		return {
			type: t.type,
			ctime: t.ctime,
			mtime: t.mtime,
			size: t.size,
			permissions: t.permissions === 1 ? 1 : void 0,
		}
	}
	readDirectory(e) {
		return this.impl.readdir(e)
	}
	createDirectory(e) {
		return this.impl.mkdir(e)
	}
	readFile(e) {
		return this.impl.readFile(e)
	}
	writeFile(e, t, n) {
		return this.impl.writeFile(e, t, { ...n, unlock: !1, atomic: !1 })
	}
	delete(e, t) {
		return this.impl.delete(e, { ...t, useTrash: !1, atomic: !1 })
	}
	rename(e, t, n) {
		return this.impl.rename(e, t, n)
	}
	copy(e, t, n) {
		return this.impl.copy(e, t, n)
	}
	get onDidChangeFile() {
		throw new Error("Method not implemented.")
	}
	watch(e, t) {
		throw new Error("Method not implemented.")
	}
}
import CU from "module"
var SU = CU.createRequire(import.meta.url),
	e0 = class extends Xd {
		_installInterceptor() {
			let e = this,
				t = SU("module"),
				n = t._load
			t._load = function (l, d, c) {
				return (
					(l = s(l)),
					e._factories.has(l)
						? e._factories.get(l).load(l, y.file(uO(d.filename)), (u) => n.apply(this, [u, d, c]))
						: n.apply(this, arguments)
				)
			}
			let r = t._resolveLookupPaths
			t._resolveLookupPaths = (a, l) => r.call(this, s(a), l)
			let i = t._resolveFilename
			t._resolveFilename = function (l, d, c, u) {
				return (
					l === "vsda" &&
						Array.isArray(u?.paths) &&
						u.paths.length === 0 &&
						(u.paths = t._nodeModulePaths(import.meta.dirname)),
					i.call(this, l, d, c, u)
				)
			}
			let s = (a) => {
				for (let l of e._alternatives) {
					let d = l(a)
					if (d) {
						a = d
						break
					}
				}
				return a
			}
		}
	},
	t0 = class o extends Xd {
		constructor() {
			super(...arguments)
			this._store = new Q()
		}
		static _createDataUri(t) {
			return `data:text/javascript;base64,${Buffer.from(t).toString("base64")}`
		}
		static {
			this._loaderScript = `
	let lookup;
	export const initialize = async (context) => {
		let requestIds = 0;
		const { port } = context;
		const pendingRequests = new Map();
		port.onmessage = (event) => {
			const { id, url } = event.data;
			pendingRequests.get(id)?.(url);
		};
		lookup = url => {
			// debugger;
			const myId = requestIds++;
			return new Promise((resolve) => {
				pendingRequests.set(myId, resolve);
				port.postMessage({ id: myId, url, });
			});
		};
	};
	export const resolve = async (specifier, context, nextResolve) => {
		if (specifier !== 'vscode' || !context.parentURL) {
			return nextResolve(specifier, context);
		}
		const otherUrl = await lookup(context.parentURL);
		return {
			url: otherUrl,
			shortCircuit: true,
		};
	};`
		}
		static {
			this._vscodeImportFnName = "_VSCODE_IMPORT_VSCODE_API"
		}
		dispose() {
			this._store.dispose()
		}
		_installInterceptor() {
			let t = new Jh(),
				n = new Map()
			Object.defineProperty(globalThis, o._vscodeImportFnName, {
				enumerable: !1,
				configurable: !1,
				writable: !1,
				value: (l) => t.getKey(l),
			})
			let { port1: r, port2: i } = new MessageChannel(),
				s,
				a = r
			;(a.onmessage = (l) => {
				s || ((s = this._factories.get("vscode")), fc(s))
				let { id: d, url: c } = l.data,
					u = y.parse(c),
					m = s.load("_not_used", u, () => {
						throw new Error("CANNOT LOAD MODULE from here.")
					}),
					f = t.get(m)
				f || ((f = He()), t.set(m, f))
				let h = n.get(f)
				if (!h) {
					let g = `const _vscodeInstance = globalThis.${o._vscodeImportFnName}('${f}');

${Object.keys(m).map((I) => `export const ${I} = _vscodeInstance['${I}'];`).join(`
`)}`
					;(h = o._createDataUri(g)), n.set(f, h)
				}
				r.postMessage({ id: d, url: h })
			}),
				CU.register(o._createDataUri(o._loaderScript), {
					parentURL: import.meta.url,
					data: { port: i },
					transferList: [i],
				}),
				this._store.add(
					q(() => {
						r.close(), i.close()
					}),
				)
		}
	},
	IT = class extends al {
		constructor() {
			super(...arguments)
			this.extensionRuntime = 1
		}
		async _beforeAlmostReadyToRunExtensions() {
			this._instaService.createInstance(Lm)
			let t = this._instaService.invokeFunction(XN)
			if (
				(this._instaService.createInstance(Rm),
				this._initData.remote.isRemote && this._initData.remote.authority)
			) {
				let r = this._instaService.createInstance(Am)
				process.env.VSCODE_IPC_HOOK_CLI = r.ipcHandlePath
			}
			this._instaService.createInstance(Fm),
				await this._instaService
					.createInstance(e0, t, { mine: this._myRegistry, all: this._globalRegistry })
					.install(),
				await this._store
					.add(
						this._instaService.createInstance(t0, t, { mine: this._myRegistry, all: this._globalRegistry }),
					)
					.install(),
				Ct("code/extHost/didInitAPI")
			let n = await this._extHostConfiguration.getConfigProvider()
			await vU(
				this._extHostWorkspace,
				n,
				this,
				this._logService,
				this._mainThreadTelemetryProxy,
				this._initData,
				this._store,
			),
				Ct("code/extHost/didInitProxyResolver")
		}
		_getEntryPoint(t) {
			return t.main
		}
		async _doLoadModule(t, n, r, i) {
			if (n.scheme !== W.file) throw new Error(`Cannot load URI: '${n}', must be of file-scheme`)
			let s = null
			r.codeLoadingStart(),
				this._logService.trace(`ExtensionService#loadModule [${i}] -> ${n.toString(!0)}`),
				this._logService.flush()
			let a = t?.identifier.value
			t && (await this._extHostLocalizationService.initializeLocalizedMessages(t))
			try {
				a && Ct(`code/extHost/willLoadExtensionCode/${a}`),
					i === "esm" ? (s = await import(n.fsPath)) : (s = SU(n.fsPath))
			} finally {
				a && Ct(`code/extHost/didLoadExtensionCode/${a}`), r.codeLoadingStop()
			}
			return s
		}
		async _loadCommonJSModule(t, n, r) {
			return this._doLoadModule(t, n, r, "cjs")
		}
		async _loadESMModule(t, n, r) {
			return this._doLoadModule(t, n, r, "esm")
		}
		async $setRemoteEnvironment(t) {
			if (this._initData.remote.isRemote)
				for (let n in t) {
					let r = t[n]
					r === null ? delete process.env[n] : (process.env[n] = r)
				}
		}
	}
import * as Nm from "fs"
import { exec as UU } from "child_process"
var L$ = (o, e, t) => {
		let n = new Uint8Array(16)
		for (let s = 0; s < 16; s++) n[s] = Math.round(Math.random() * 256)
		let r = Ol(z.wrap(n))
		return (
			[
				`GET ws://localhost${o}?${e}&skipWebSocketFrames=true HTTP/1.1`,
				"Connection: Upgrade",
				"Upgrade: websocket",
				`Sec-WebSocket-Key: ${r}`,
			].join(`\r
`) +
			`\r
\r
`
		)
	},
	TU = z.fromString(`\r
\r
`)
async function EU(o, e, t, n, r) {
	o.write(z.fromString(L$(e, t, n)))
	let i = new Q()
	try {
		return await new Promise((s, a) => {
			let l
			i.add(
				o.onData((d) => {
					l ? (l = z.concat([l, d], l.byteLength + d.byteLength)) : (l = d)
					let c = l.indexOf(TU)
					if (c === -1) return
					s(o), o.pauseData()
					let u = l.slice(c + TU.byteLength)
					u.byteLength && r.onData.fire(u)
				}),
			),
				i.add(o.onClose((d) => a(d ?? new Error("socket closed")))),
				i.add(o.onEnd(() => a(new Error("socket ended"))))
		})
	} catch (s) {
		throw (o.dispose(), s)
	} finally {
		i.dispose()
	}
}
var xT = class extends $ {
	constructor(t, n) {
		super()
		this.debugLabel = t
		this.pausableDataEmitter = this._register(new ai())
		this.onData = (...t) => (
			this.pausableDataEmitter.isPaused && queueMicrotask(() => this.pausableDataEmitter.resume()),
			this.pausableDataEmitter.event(...t)
		)
		this.didDisposeEmitter = this._register(new E())
		this.onDidDispose = this.didDisposeEmitter.event
		this.ended = !1
		this._register(n.onData),
			this._register(n.onData.event((r) => this.pausableDataEmitter.fire(r))),
			(this.onClose = this._register(n.onClose).event),
			(this.onEnd = this._register(n.onEnd).event)
	}
	pauseData() {
		this.pausableDataEmitter.pause()
	}
	drain() {
		return Promise.resolve()
	}
	end() {
		;(this.ended = !0), this.closeRemote()
	}
	traceSocketEvent(t, n) {
		Tf.traceSocketEvent(this, this.debugLabel, t, n)
	}
	dispose() {
		this.ended || this.closeRemote(), this.didDisposeEmitter.fire(), super.dispose()
	}
}
var M$ = "signService",
	yl = O(M$)
import * as OU from "net"
import * as LU from "os"
import * as n0 from "net"
var r0 = {
	1: !0,
	7: !0,
	9: !0,
	11: !0,
	13: !0,
	15: !0,
	17: !0,
	19: !0,
	20: !0,
	21: !0,
	22: !0,
	23: !0,
	25: !0,
	37: !0,
	42: !0,
	43: !0,
	53: !0,
	69: !0,
	77: !0,
	79: !0,
	87: !0,
	95: !0,
	101: !0,
	102: !0,
	103: !0,
	104: !0,
	109: !0,
	110: !0,
	111: !0,
	113: !0,
	115: !0,
	117: !0,
	119: !0,
	123: !0,
	135: !0,
	137: !0,
	139: !0,
	143: !0,
	161: !0,
	179: !0,
	389: !0,
	427: !0,
	465: !0,
	512: !0,
	513: !0,
	514: !0,
	515: !0,
	526: !0,
	530: !0,
	531: !0,
	532: !0,
	540: !0,
	548: !0,
	554: !0,
	556: !0,
	563: !0,
	587: !0,
	601: !0,
	636: !0,
	989: !0,
	990: !0,
	993: !0,
	995: !0,
	1719: !0,
	1720: !0,
	1723: !0,
	2049: !0,
	3659: !0,
	4045: !0,
	5060: !0,
	5061: !0,
	6e3: !0,
	6566: !0,
	6665: !0,
	6666: !0,
	6667: !0,
	6668: !0,
	6669: !0,
	6697: !0,
	10080: !0,
}
function wU(o, e, t, n = "127.0.0.1") {
	let r = !1,
		i,
		s = 1,
		a = n0.createServer({ pauseOnConnect: !0 })
	function l(d, c) {
		r || ((r = !0), a.removeAllListeners(), a.close(), i && clearTimeout(i), c(d))
	}
	return new Promise((d) => {
		;(i = setTimeout(() => {
			l(0, d)
		}, t)),
			a.on("listening", () => {
				l(o, d)
			}),
			a.on("error", (c) => {
				c && (c.code === "EADDRINUSE" || c.code === "EACCES") && s < e ? (o++, s++, a.listen(o, n)) : l(0, d)
			}),
			a.on("close", () => {
				l(0, d)
			}),
			a.listen(o, n)
	})
}
var F$ = 30 * 1e3
function i0(o) {
	switch (o) {
		case 1:
			return "Management"
		case 2:
			return "ExtensionHost"
		case 3:
			return "Tunnel"
	}
}
function _U(o) {
	let e = new _e()
	return setTimeout(() => e.cancel(), o), e.token
}
function N$(o, e) {
	if (o.isCancellationRequested || e.isCancellationRequested) return De.Cancelled
	let t = new _e()
	return o.onCancellationRequested(() => t.cancel()), e.onCancellationRequested(() => t.cancel()), t.token
}
var Mh = class {
	get didTimeout() {
		return this._state === "timedout"
	}
	constructor(e) {
		;(this._state = "pending"),
			(this._disposables = new Q()),
			({ promise: this.promise, resolve: this._resolvePromise, reject: this._rejectPromise } = ff()),
			e.isCancellationRequested
				? this._timeout()
				: this._disposables.add(e.onCancellationRequested(() => this._timeout()))
	}
	registerDisposable(e) {
		this._state === "pending" ? this._disposables.add(e) : e.dispose()
	}
	_timeout() {
		this._state === "pending" &&
			(this._disposables.dispose(), (this._state = "timedout"), this._rejectPromise(this._createTimeoutError()))
	}
	_createTimeoutError() {
		let e = new Error("Time limit reached")
		return (e.code = "ETIMEDOUT"), (e.syscall = "connect"), e
	}
	resolve(e) {
		this._state === "pending" && (this._disposables.dispose(), (this._state = "resolved"), this._resolvePromise(e))
	}
	reject(e) {
		this._state === "pending" && (this._disposables.dispose(), (this._state = "rejected"), this._rejectPromise(e))
	}
}
function U$(o, e) {
	let t = new Mh(e)
	return (
		t.registerDisposable(
			o.onControlMessage((n) => {
				let r = JSON.parse(n.toString()),
					i = $$(r)
				i ? t.reject(i) : t.resolve(r)
			}),
		),
		t.promise
	)
}
function H$(o, e, t, n, r, i, s, a) {
	let l = new Mh(a),
		d = zt.create(!1)
	return (
		o.info(`Creating a socket (${s})...`),
		Ct(`code/willCreateSocket/${i}`),
		e.connect(t, n, r, s).then(
			(c) => {
				l.didTimeout
					? (Ct(`code/didCreateSocketError/${i}`),
						o.info(
							`Creating a socket (${s}) finished after ${d.elapsed()} ms, but this is too late and has timed out already.`,
						),
						c?.dispose())
					: (Ct(`code/didCreateSocketOK/${i}`),
						o.info(`Creating a socket (${s}) was successful after ${d.elapsed()} ms.`),
						l.resolve(c))
			},
			(c) => {
				Ct(`code/didCreateSocketError/${i}`),
					o.info(`Creating a socket (${s}) returned an error after ${d.elapsed()} ms.`),
					o.error(c),
					l.reject(c)
			},
		),
		l.promise
	)
}
function o0(o, e) {
	let t = new Mh(e)
	return (
		o.then(
			(n) => {
				t.didTimeout || t.resolve(n)
			},
			(n) => {
				t.didTimeout || t.reject(n)
			},
		),
		t.promise
	)
}
async function W$(o, e, t, n) {
	let r = AU(o, e)
	o.logService.trace(`${r} 1/6. invoking socketFactory.connect().`)
	let i
	try {
		i = await H$(
			o.logService,
			o.remoteSocketFactoryService,
			o.connectTo,
			xE.getServerRootPath(),
			`reconnectionToken=${o.reconnectionToken}&reconnection=${o.reconnectionProtocol ? "true" : "false"}`,
			i0(e),
			`renderer-${i0(e)}-${o.reconnectionToken}`,
			n,
		)
	} catch (c) {
		throw (o.logService.error(`${r} socketFactory.connect() failed or timed out. Error:`), o.logService.error(c), c)
	}
	o.logService.trace(`${r} 2/6. socketFactory.connect() was successful.`)
	let s, a
	o.reconnectionProtocol
		? (o.reconnectionProtocol.beginAcceptReconnection(i, null), (s = o.reconnectionProtocol), (a = !1))
		: ((s = new Nl({ socket: i })), (a = !0)),
		o.logService.trace(`${r} 3/6. sending AuthRequest control message.`)
	let l = await o0(o.signService.createNewMessage(He()), n),
		d = { type: "auth", auth: o.connectionToken || "00000000000000000000", data: l.data }
	s.sendControl(z.fromString(JSON.stringify(d)))
	try {
		let c = await U$(s, N$(n, _U(1e4)))
		if (c.type !== "sign" || typeof c.data != "string") {
			let h = new Error("Unexpected handshake message")
			throw ((h.code = "VSCODE_CONNECTION_ERROR"), h)
		}
		if (
			(o.logService.trace(`${r} 4/6. received SignRequest control message.`),
			!(await o0(o.signService.validate(l, c.signedData), n)))
		) {
			let h = new Error("Refused to connect to unsupported server")
			throw ((h.code = "VSCODE_CONNECTION_ERROR"), h)
		}
		let m = await o0(o.signService.sign(c.data), n),
			f = { type: "connectionType", commit: o.commit, signedData: m, desiredConnectionType: e }
		return (
			t && (f.args = t),
			o.logService.trace(`${r} 5/6. sending ConnectionTypeRequest control message.`),
			s.sendControl(z.fromString(JSON.stringify(f))),
			{ protocol: s, ownsProtocol: a }
		)
	} catch (c) {
		throw (
			(c &&
				c.code === "ETIMEDOUT" &&
				(o.logService.error(`${r} the handshake timed out. Error:`), o.logService.error(c)),
			c &&
				c.code === "VSCODE_CONNECTION_ERROR" &&
				(o.logService.error(`${r} received error control message when negotiating connection. Error:`),
				o.logService.error(c)),
			a && RU(s),
			c)
		)
	}
}
async function V$(o, e, t) {
	let n = Date.now(),
		r = AU(o, 3),
		{ protocol: i } = await W$(o, 3, e, t)
	return o.logService.trace(`${r} 6/6. handshake finished, connection is up and running after ${K$(n)}!`), i
}
async function DU(o, e, t) {
	let { connectTo: n, connectionToken: r } = await o.addressProvider.getAddress()
	return {
		commit: o.commit,
		quality: o.quality,
		connectTo: n,
		connectionToken: r,
		reconnectionToken: e,
		reconnectionProtocol: t,
		remoteSocketFactoryService: o.remoteSocketFactoryService,
		signService: o.signService,
		logService: o.logService,
	}
}
async function kU(o, e, t) {
	let n = await DU(o, He(), null)
	return await V$(n, { host: e, port: t }, De.None)
}
function B$(o) {
	return kr(
		(e) =>
			new Promise((t, n) => {
				let r = setTimeout(t, o * 1e3)
				e.onCancellationRequested(() => {
					clearTimeout(r), t()
				})
			}),
	)
}
var s0 = class {
		constructor(e, t) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.type = 0
		}
	},
	a0 = class {
		constructor(e, t, n, r) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.durationSeconds = n
			this.cancellableTimer = r
			this.type = 1
		}
		skipWait() {
			this.cancellableTimer.cancel()
		}
	},
	l0 = class {
		constructor(e, t, n) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.type = 2
		}
	},
	ST = class {
		constructor(e, t, n) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.type = 4
		}
	},
	d0 = class {
		constructor(e, t, n, r) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.handled = r
			this.type = 3
		}
	},
	PU = class o extends $ {
		constructor(t, n, r, i, s) {
			super()
			this._connectionType = t
			this._options = n
			this.reconnectionToken = r
			this.protocol = i
			this._reconnectionFailureIsFatal = s
			this._onDidStateChange = this._register(new E())
			this.onDidStateChange = this._onDidStateChange.event
			this._permanentFailure = !1
			this._isReconnecting = !1
			this._isDisposed = !1
			this._onDidStateChange.fire(new ST(this.reconnectionToken, 0, 0)),
				this._register(
					i.onSocketClose((a) => {
						let l = CT(this._connectionType, this.reconnectionToken, !0)
						a
							? a.type === 0
								? (this._options.logService.info(
										`${l} received socket close event (hadError: ${a.hadError}).`,
									),
									a.error && this._options.logService.error(a.error))
								: (this._options.logService.info(
										`${l} received socket close event (wasClean: ${a.wasClean}, code: ${a.code}, reason: ${a.reason}).`,
									),
									a.event && this._options.logService.error(a.event))
							: this._options.logService.info(`${l} received socket close event.`),
							this._beginReconnecting()
					}),
				),
				this._register(
					i.onSocketTimeout((a) => {
						let l = CT(this._connectionType, this.reconnectionToken, !0)
						this._options.logService.info(
							`${l} received socket timeout event (unacknowledgedMsgCount: ${a.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${a.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${a.timeSinceLastReceivedSomeData}).`,
						),
							this._beginReconnecting()
					}),
				),
				o._instances.push(this),
				this._register(
					q(() => {
						let a = o._instances.indexOf(this)
						a >= 0 && o._instances.splice(a, 1)
					}),
				),
				this._isPermanentFailure &&
					this._gotoPermanentFailure(
						o._permanentFailureMillisSinceLastIncomingData,
						o._permanentFailureAttempt,
						o._permanentFailureHandled,
					)
		}
		static triggerPermanentFailure(t, n, r) {
			;(this._permanentFailure = !0),
				(this._permanentFailureMillisSinceLastIncomingData = t),
				(this._permanentFailureAttempt = n),
				(this._permanentFailureHandled = r),
				this._instances.forEach((i) =>
					i._gotoPermanentFailure(
						this._permanentFailureMillisSinceLastIncomingData,
						this._permanentFailureAttempt,
						this._permanentFailureHandled,
					),
				)
		}
		static debugTriggerReconnection() {
			this._instances.forEach((t) => t._beginReconnecting())
		}
		static debugPauseSocketWriting() {
			this._instances.forEach((t) => t._pauseSocketWriting())
		}
		static {
			this._permanentFailure = !1
		}
		static {
			this._permanentFailureMillisSinceLastIncomingData = 0
		}
		static {
			this._permanentFailureAttempt = 0
		}
		static {
			this._permanentFailureHandled = !1
		}
		static {
			this._instances = []
		}
		get _isPermanentFailure() {
			return this._permanentFailure || o._permanentFailure
		}
		dispose() {
			super.dispose(), (this._isDisposed = !0)
		}
		async _beginReconnecting() {
			if (!this._isReconnecting)
				try {
					;(this._isReconnecting = !0), await this._runReconnectingLoop()
				} finally {
					this._isReconnecting = !1
				}
		}
		async _runReconnectingLoop() {
			if (this._isPermanentFailure || this._isDisposed) return
			let t = CT(this._connectionType, this.reconnectionToken, !0)
			this._options.logService.info(
				`${t} starting reconnecting loop. You can get more information with the trace log level.`,
			),
				this._onDidStateChange.fire(
					new s0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()),
				)
			let n = [0, 5, 5, 10, 10, 10, 10, 10, 30],
				r = -1
			do {
				r++
				let i = r < n.length ? n[r] : n[n.length - 1]
				try {
					if (i > 0) {
						let a = B$(i)
						this._onDidStateChange.fire(
							new a0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), i, a),
						),
							this._options.logService.info(`${t} waiting for ${i} seconds before reconnecting...`)
						try {
							await a
						} catch {}
					}
					if (this._isPermanentFailure) {
						this._options.logService.error(
							`${t} permanent failure occurred while running the reconnecting loop.`,
						)
						break
					}
					this._onDidStateChange.fire(
						new l0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r + 1),
					),
						this._options.logService.info(`${t} resolving connection...`)
					let s = await DU(this._options, this.reconnectionToken, this.protocol)
					this._options.logService.info(`${t} connecting to ${s.connectTo}...`),
						await this._reconnect(s, _U(F$)),
						this._options.logService.info(`${t} reconnected!`),
						this._onDidStateChange.fire(
							new ST(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r + 1),
						)
					break
				} catch (s) {
					if (s.code === "VSCODE_CONNECTION_ERROR") {
						this._options.logService.error(
							`${t} A permanent error occurred in the reconnecting loop! Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								!1,
							)
						break
					}
					if (r > 360) {
						this._options.logService.error(
							`${t} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								!1,
							)
						break
					}
					if (du.isTemporarilyNotAvailable(s)) {
						this._options.logService.info(
							`${t} A temporarily not available error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (
						(s.code === "ETIMEDOUT" ||
							s.code === "ENETUNREACH" ||
							s.code === "ECONNREFUSED" ||
							s.code === "ECONNRESET") &&
						s.syscall === "connect"
					) {
						this._options.logService.info(
							`${t} A network error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (bn(s)) {
						this._options.logService.info(
							`${t} A promise cancelation error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (s instanceof du) {
						this._options.logService.error(
							`${t} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								du.isHandled(s),
							)
						break
					}
					this._options.logService.error(
						`${t} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`,
					),
						this._options.logService.error(s),
						this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), r + 1, !1)
					break
				}
			} while (!this._isPermanentFailure && !this._isDisposed)
		}
		_onReconnectionPermanentFailure(t, n, r) {
			this._reconnectionFailureIsFatal ? o.triggerPermanentFailure(t, n, r) : this._gotoPermanentFailure(t, n, r)
		}
		_gotoPermanentFailure(t, n, r) {
			this._onDidStateChange.fire(new d0(this.reconnectionToken, t, n, r)), RU(this.protocol)
		}
		_pauseSocketWriting() {
			this.protocol.pauseSocketWriting()
		}
	}
function RU(o) {
	try {
		o.acceptDisconnect()
		let e = o.getSocket()
		o.dispose(), e.dispose()
	} catch (e) {
		Be(e)
	}
}
function $$(o) {
	if (o && o.type === "error") {
		let e = new Error(`Connection error: ${o.reason}`)
		return (e.code = "VSCODE_CONNECTION_ERROR"), e
	}
	return null
}
function z$(o, e) {
	for (; o.length < e; ) o += " "
	return o
}
function q$(o, e) {
	return `[remote-connection][${z$(i0(o), 13)}][${e.substr(0, 5)}\u2026]`
}
function CT(o, e, t) {
	return `${q$(o, e)}[${t ? "reconnect" : "initial"}]`
}
function AU(o, e) {
	return `${CT(e, o.reconnectionToken, !!o.reconnectionProtocol)}[${o.connectTo}]`
}
function K$(o) {
	return `${Date.now() - o} ms`
}
var TT = O("remoteSocketFactoryService")
async function j$(o, e, t, n, r) {
	let i
	for (
		let s = 3;
		s &&
		(i?.dispose(), (i = await new Uh(o, e, t, n, r).waitForReady()), !((r && r0[r]) || !r0[i.tunnelLocalPort]));
		s--
	);
	return i
}
var Uh = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.defaultTunnelHost = n
			this.suggestedLocalPort = s
			this.privacy = "private"
			this._socketsDispose = new Map()
			;(this._options = t),
				(this._server = OU.createServer()),
				(this._barrier = new dn()),
				(this._listeningListener = () => this._barrier.open()),
				this._server.on("listening", this._listeningListener),
				(this._connectionListener = (a) => this._onConnection(a)),
				this._server.on("connection", this._connectionListener),
				(this._errorListener = () => {}),
				this._server.on("error", this._errorListener),
				(this.tunnelRemotePort = i),
				(this.tunnelRemoteHost = r)
		}
		async dispose() {
			super.dispose(),
				this._server.removeListener("listening", this._listeningListener),
				this._server.removeListener("connection", this._connectionListener),
				this._server.removeListener("error", this._errorListener),
				this._server.close(),
				Array.from(this._socketsDispose.values()).forEach((n) => {
					n()
				})
		}
		async waitForReady() {
			let t = this.suggestedLocalPort ?? this.tunnelRemotePort,
				n = So(this.defaultTunnelHost) ? "0.0.0.0" : "127.0.0.1",
				r = await wU(t, 2, 1e3, n),
				i = null
			return (
				this._server.listen(r, this.defaultTunnelHost),
				await this._barrier.wait(),
				(i = this._server.address()),
				i ||
					((r = 0),
					this._server.listen(r, this.defaultTunnelHost),
					await this._barrier.wait(),
					(i = this._server.address())),
				(this.tunnelLocalPort = i.port),
				(this.localAddress = `${this.tunnelRemoteHost === "127.0.0.1" ? "127.0.0.1" : "localhost"}:${i.port}`),
				this
			)
		}
		async _onConnection(t) {
			t.pause()
			let n = Mi(this.tunnelRemoteHost) || So(this.tunnelRemoteHost) ? "localhost" : this.tunnelRemoteHost,
				r = await kU(this._options, n, this.tunnelRemotePort),
				i = r.getSocket(),
				s = r.readEntireBuffer()
			r.dispose(),
				s.byteLength > 0 && t.write(s.buffer),
				t.on("end", () => {
					t.localAddress && this._socketsDispose.delete(t.localAddress), i.end()
				}),
				t.on("close", () => i.end()),
				t.on("error", () => {
					t.localAddress && this._socketsDispose.delete(t.localAddress),
						i instanceof ts ? i.socket.destroy() : i.end()
				}),
				i instanceof ts ? this._mirrorNodeSocket(t, i) : this._mirrorGenericSocket(t, i),
				t.localAddress &&
					this._socketsDispose.set(t.localAddress, () => {
						t.end(), i.end()
					})
		}
		_mirrorGenericSocket(t, n) {
			n.onClose(() => t.destroy()),
				n.onEnd(() => t.end()),
				n.onData((r) => t.write(r.buffer)),
				t.on("data", (r) => n.write(z.wrap(r))),
				t.resume()
		}
		_mirrorNodeSocket(t, n) {
			let r = n.socket
			r.on("end", () => t.end()),
				r.on("close", () => t.end()),
				r.on("error", () => {
					t.destroy()
				}),
				r.pipe(t),
				t.pipe(r)
		}
	},
	Fh = class extends vp {
		constructor(t, n, r, i, s) {
			super(n, s)
			this.remoteSocketFactoryService = t
			this.signService = r
			this.productService = i
		}
		isPortPrivileged(t) {
			return JF(t, this.defaultTunnelHost, wl, LU.release())
		}
		retainOrCreateTunnel(t, n, r, i, s, a, l, d) {
			let c = this.getTunnelFromMap(n, r)
			if (c) return ++c.refcount, c.value
			if (QF(t)) return this.createWithProvider(t, n, r, s, a, l, d)
			{
				this.logService.trace(
					`ForwardedPorts: (TunnelService) Creating tunnel without provider ${n}:${r} on local port ${s}.`,
				)
				let u = {
						commit: this.productService.commit,
						quality: this.productService.quality,
						addressProvider: t,
						remoteSocketFactoryService: this.remoteSocketFactoryService,
						signService: this.signService,
						logService: this.logService,
						ipcLogger: null,
					},
					m = j$(u, i, n, r, s)
				return (
					this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created without provider."),
					this.addTunnelToMap(n, r, m),
					m
				)
			}
		}
	}
Fh = R([S(0, TT), S(1, te), S(2, yl), S(3, Yc), S(4, vr)], Fh)
var Nh = class extends Fh {
	constructor(e, t, n, r, i) {
		super(e, t, n, r, i)
	}
}
Nh = R([S(0, TT), S(1, te), S(2, yl), S(3, Yc), S(4, vr)], Nh)
var ET = class extends $ {
	constructor(t, n, r, i, s) {
		super()
		this.remoteSocketFactoryService = t
		this.logService = n
		this.productService = r
		this.signService = i
		this.configurationService = s
		this._tunnelServices = new Map()
	}
	async openTunnel(t, n, r, i, s, a, l, d, c) {
		if (
			(this.logService.trace(
				`ForwardedPorts: (SharedTunnelService) openTunnel request for ${r}:${i} on local port ${a}.`,
			),
			!this._tunnelServices.has(t))
		) {
			let u = new Nh(
				this.remoteSocketFactoryService,
				this.logService,
				this.signService,
				this.productService,
				this.configurationService,
			)
			this._register(u),
				this._tunnelServices.set(t, u),
				u.onTunnelClosed(async () => {
					;(await u.tunnels).length === 0 && (u.dispose(), this._tunnelServices.delete(t))
				})
		}
		return this._tunnelServices.get(t).openTunnel(n, r, i, s, a, l, d, c)
	}
}
ET = R([S(0, TT), S(1, te), S(2, Yc), S(3, yl), S(4, vr)], ET)
var MU = O("dialogService")
var GXe = O("fileDialogService")
var G$ = 10 * 1e3,
	wT = "remote.tunnels.toRestore",
	c0 = "remote.tunnels.toRestoreExpiration",
	Q$ = 1e3 * 60 * 60 * 24 * 14,
	FU = "onTunnel",
	xYe = new D(
		"forwardedPortsViewEnabled",
		!1,
		p("tunnel.forwardedPortsViewEnabled", "Whether the Ports view is enabled."),
	),
	J$ = new D(
		"forwardedPortsViewOnlyEnabled",
		!1,
		p("tunnel.forwardedPortsViewEnabled", "Whether the Ports view is enabled."),
	)
function p0(o) {
	let e = o.match(/^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/)
	if (e) return { host: e[1]?.substring(0, e[1].length - 1) || "localhost", port: Number(e[2]) }
}
var u0 = { source: 0, description: p("tunnel.source.user", "User Forwarded") },
	CYe = { source: 1, description: p("tunnel.source.auto", "Auto Forwarded") }
function NU(o, e, t) {
	let n = o.get(Hr(e, t))
	if (n) return n
	if (Mi(e))
		for (let r of bp) {
			let i = Hr(r, t)
			if (o.has(i)) return o.get(i)
		}
	else if (So(e))
		for (let r of zg) {
			let i = Hr(r, t)
			if (o.has(i)) return o.get(i)
		}
}
function xr(o, e, t) {
	let n = NU(o, e, t)
	if (n) return n
	let r = So(e) ? "localhost" : Mi(e) ? "0.0.0.0" : void 0
	if (r) return NU(o, r, t)
}
function Hr(o, e) {
	return o + ":" + e
}
function X$(o) {
	return (
		o &&
		"host" in o &&
		typeof o.host == "string" &&
		"port" in o &&
		typeof o.port == "number" &&
		(!("detail" in o) || typeof o.detail == "string") &&
		(!("pid" in o) || typeof o.pid == "string")
	)
}
var PT = class o extends $ {
		constructor(t) {
			super()
			this.configurationService = t
			this.portsAttributes = []
			this._onDidChangeAttributes = new E()
			this.onDidChangeAttributes = this._onDidChangeAttributes.event
			this._register(
				t.onDidChangeConfiguration((n) => {
					;(n.affectsConfiguration(o.SETTING) || n.affectsConfiguration(o.DEFAULTS)) &&
						this.updateAttributes()
				}),
			),
				this.updateAttributes()
		}
		static {
			this.SETTING = "remote.portsAttributes"
		}
		static {
			this.DEFAULTS = "remote.otherPortsAttributes"
		}
		static {
			this.RANGE = /^(\d+)\-(\d+)$/
		}
		static {
			this.HOST_AND_PORT = /^([a-z0-9\-]+):(\d{1,5})$/
		}
		updateAttributes() {
			;(this.portsAttributes = this.readSetting()), this._onDidChangeAttributes.fire()
		}
		getAttributes(t, n, r) {
			let i = this.findNextIndex(t, n, r, this.portsAttributes, 0),
				s = {
					label: void 0,
					onAutoForward: void 0,
					elevateIfNeeded: void 0,
					requireLocalPort: void 0,
					protocol: void 0,
				}
			for (; i >= 0; ) {
				let a = this.portsAttributes[i]
				a.key === t
					? ((s.onAutoForward = a.onAutoForward ?? s.onAutoForward),
						(s.elevateIfNeeded = a.elevateIfNeeded !== void 0 ? a.elevateIfNeeded : s.elevateIfNeeded),
						(s.label = a.label ?? s.label),
						(s.requireLocalPort = a.requireLocalPort),
						(s.protocol = a.protocol))
					: ((s.onAutoForward = s.onAutoForward ?? a.onAutoForward),
						(s.elevateIfNeeded = s.elevateIfNeeded !== void 0 ? s.elevateIfNeeded : a.elevateIfNeeded),
						(s.label = s.label ?? a.label),
						(s.requireLocalPort = s.requireLocalPort !== void 0 ? s.requireLocalPort : void 0),
						(s.protocol = s.protocol ?? a.protocol)),
					(i = this.findNextIndex(t, n, r, this.portsAttributes, i + 1))
			}
			return s.onAutoForward !== void 0 ||
				s.elevateIfNeeded !== void 0 ||
				s.label !== void 0 ||
				s.requireLocalPort !== void 0 ||
				s.protocol !== void 0
				? s
				: this.getOtherAttributes()
		}
		hasStartEnd(t) {
			return t.start !== void 0 && t.end !== void 0
		}
		hasHostAndPort(t) {
			return t.host !== void 0 && t.port !== void 0 && Ee(t.host) && fn(t.port)
		}
		findNextIndex(t, n, r, i, s) {
			if (s >= i.length) return -1
			let a = !Mi(n) && !So(n),
				d = i
					.slice(s)
					.findIndex((c) =>
						fn(c.key)
							? a
								? !1
								: c.key === t
							: this.hasStartEnd(c.key)
								? a
									? !1
									: t >= c.key.start && t <= c.key.end
								: this.hasHostAndPort(c.key)
									? t === c.key.port && n === c.key.host
									: r
										? c.key.test(r)
										: !1,
					)
			return d >= 0 ? d + s : -1
		}
		readSetting() {
			let t = this.configurationService.getValue(o.SETTING)
			if (!t || !dt(t)) return []
			let n = []
			for (let i in t) {
				if (i === void 0) continue
				let s = t[i],
					a
				if (Number(i)) a = Number(i)
				else if (Ee(i))
					if (o.RANGE.test(i)) {
						let l = i.match(o.RANGE)
						a = { start: Number(l[1]), end: Number(l[2]) }
					} else if (o.HOST_AND_PORT.test(i)) {
						let l = i.match(o.HOST_AND_PORT)
						a = { host: l[1], port: Number(l[2]) }
					} else {
						let l
						try {
							l = RegExp(i)
						} catch {}
						l && (a = l)
					}
				a &&
					n.push({
						key: a,
						elevateIfNeeded: s.elevateIfNeeded,
						onAutoForward: s.onAutoForward,
						label: s.label,
						requireLocalPort: s.requireLocalPort,
						protocol: s.protocol,
					})
			}
			let r = this.configurationService.getValue(o.DEFAULTS)
			return (
				r &&
					(this.defaultPortAttributes = {
						elevateIfNeeded: r.elevateIfNeeded,
						label: r.label,
						onAutoForward: r.onAutoForward,
						requireLocalPort: r.requireLocalPort,
						protocol: r.protocol,
					}),
				this.sortAttributes(n)
			)
		}
		sortAttributes(t) {
			function n(r, i) {
				return fn(r.key)
					? r.key
					: i.hasStartEnd(r.key)
						? r.key.start
						: i.hasHostAndPort(r.key)
							? r.key.port
							: Number.MAX_VALUE
			}
			return t.sort((r, i) => n(r, this) - n(i, this))
		}
		getOtherAttributes() {
			return this.defaultPortAttributes
		}
		static providedActionToAction(t) {
			switch (t) {
				case 1:
					return "notify"
				case 2:
					return "openBrowser"
				case 6:
					return "openBrowserOnce"
				case 3:
					return "openPreview"
				case 4:
					return "silent"
				case 5:
					return "ignore"
				default:
					return
			}
		}
		async addAttributes(t, n, r) {
			let s = this.configurationService.inspect(o.SETTING).userRemoteValue,
				a
			!s || !dt(s) ? (a = {}) : (a = je(s)), a[`${t}`] || (a[`${t}`] = {})
			for (let l in n) a[`${t}`][l] = n[l]
			return this.configurationService.updateValue(o.SETTING, a, r)
		}
	},
	Hh = class extends $ {
		constructor(t, n, r, i, s, a, l, d, c, u) {
			super()
			this.tunnelService = t
			this.storageService = n
			this.configurationService = r
			this.environmentService = i
			this.remoteAuthorityResolverService = s
			this.workspaceContextService = a
			this.logService = l
			this.dialogService = d
			this.extensionService = c
			this.contextKeyService = u
			this.inProgress = new Map()
			this._onForwardPort = new E()
			this.onForwardPort = this._onForwardPort.event
			this._onClosePort = new E()
			this.onClosePort = this._onClosePort.event
			this._onPortName = new E()
			this.onPortName = this._onPortName.event
			this._onCandidatesChanged = new E()
			this.onCandidatesChanged = this._onCandidatesChanged.event
			this._onEnvironmentTunnelsSet = new E()
			this.onEnvironmentTunnelsSet = this._onEnvironmentTunnelsSet.event
			this._environmentTunnelsSet = !1
			this.restoreListener = void 0
			this.restoreComplete = !1
			this.onRestoreComplete = new E()
			this.unrestoredExtensionTunnels = new Map()
			this.sessionCachedProperties = new Map()
			this.portAttributesProviders = []
			this.hasCheckedExtensionsOnTunnelOpened = !1
			this.mismatchCooldown = new Date()
			;(this.configPortsAttributes = new PT(r)),
				(this.tunnelRestoreValue = this.getTunnelRestoreValue()),
				this._register(this.configPortsAttributes.onDidChangeAttributes(this.updateAttributes, this)),
				(this.forwarded = new Map()),
				(this.remoteTunnels = new Map()),
				this.tunnelService.tunnels.then(async (m) => {
					let f = await this.getAttributes(
						m.map((h) => ({ port: h.tunnelRemotePort, host: h.tunnelRemoteHost })),
					)
					for (let h of m)
						if (h.localAddress) {
							let g = Hr(h.tunnelRemoteHost, h.tunnelRemotePort),
								I = xr(this._candidates ?? new Map(), h.tunnelRemoteHost, h.tunnelRemotePort)
							this.forwarded.set(g, {
								remotePort: h.tunnelRemotePort,
								remoteHost: h.tunnelRemoteHost,
								localAddress: h.localAddress,
								protocol: f?.get(h.tunnelRemotePort)?.protocol ?? "http",
								localUri: await this.makeLocalUri(h.localAddress, f?.get(h.tunnelRemotePort)),
								localPort: h.tunnelLocalPort,
								name: f?.get(h.tunnelRemotePort)?.label,
								runningProcess: I?.detail,
								hasRunningProcess: !!I,
								pid: I?.pid,
								privacy: h.privacy,
								source: u0,
							}),
								this.remoteTunnels.set(g, h)
						}
				}),
				(this.detected = new Map()),
				this._register(
					this.tunnelService.onTunnelOpened(async (m) => {
						let f = Hr(m.tunnelRemoteHost, m.tunnelRemotePort)
						if (
							!xr(this.forwarded, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							!xr(this.detected, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							!xr(this.inProgress, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							m.localAddress
						) {
							let h = xr(this._candidates ?? new Map(), m.tunnelRemoteHost, m.tunnelRemotePort),
								g = (
									await this.getAttributes([{ port: m.tunnelRemotePort, host: m.tunnelRemoteHost }])
								)?.get(m.tunnelRemotePort)
							this.forwarded.set(f, {
								remoteHost: m.tunnelRemoteHost,
								remotePort: m.tunnelRemotePort,
								localAddress: m.localAddress,
								protocol: g?.protocol ?? "http",
								localUri: await this.makeLocalUri(m.localAddress, g),
								localPort: m.tunnelLocalPort,
								name: g?.label,
								closeable: !0,
								runningProcess: h?.detail,
								hasRunningProcess: !!h,
								pid: h?.pid,
								privacy: m.privacy,
								source: u0,
							})
						}
						await this.storeForwarded(),
							this.checkExtensionActivationEvents(!0),
							this.remoteTunnels.set(f, m),
							this._onForwardPort.fire(this.forwarded.get(f))
					}),
				),
				this._register(this.tunnelService.onTunnelClosed((m) => this.onTunnelClosed(m, "Other"))),
				this.checkExtensionActivationEvents(!1)
		}
		extensionHasActivationEvent() {
			return this.extensionService.extensions.find((t) => t.activationEvents?.includes(FU))
				? (this.contextKeyService.createKey(J$.key, !0), !0)
				: !1
		}
		checkExtensionActivationEvents(t) {
			if (
				this.hasCheckedExtensionsOnTunnelOpened ||
				(t && (this.hasCheckedExtensionsOnTunnelOpened = !0),
				this.environmentService.remoteAuthority !== void 0 && !t) ||
				this.extensionHasActivationEvent()
			)
				return
			let r = this._register(
				this.extensionService.onDidRegisterExtensions(() => {
					this.extensionHasActivationEvent() && r.dispose()
				}),
			)
		}
		async onTunnelClosed(t, n) {
			let r = Hr(t.host, t.port)
			this.forwarded.has(r) && (this.forwarded.delete(r), await this.storeForwarded(), this._onClosePort.fire(t))
		}
		makeLocalUri(t, n) {
			if (t.startsWith("http")) return y.parse(t)
			let r = n?.protocol ?? "http"
			return y.parse(`${r}://${t}`)
		}
		async addStorageKeyPostfix(t) {
			let n = this.workspaceContextService.getWorkspace(),
				r = n.configuration
					? ar(n.configuration.path)
					: n.folders.length > 0
						? ar(n.folders[0].uri.path)
						: void 0
			if (r === void 0) {
				this.logService.debug("Could not get workspace hash for forwarded ports storage key.")
				return
			}
			return `${t}.${this.environmentService.remoteAuthority}.${r}`
		}
		async getTunnelRestoreStorageKey() {
			return this.addStorageKeyPostfix(wT)
		}
		async getRestoreExpirationStorageKey() {
			return this.addStorageKeyPostfix(c0)
		}
		async getTunnelRestoreValue() {
			let t = this.storageService.get(wT, 1)
			if (t) return this.storageService.remove(wT, 1), await this.storeForwarded(), t
			let n = await this.getTunnelRestoreStorageKey()
			if (n) return this.storageService.get(n, 0)
		}
		async restoreForwarded() {
			if (
				(this.cleanupExpiredTunnelsForRestore(),
				this.configurationService.getValue("remote.restoreForwardedPorts"))
			) {
				let t = await this.tunnelRestoreValue
				if (t && t !== this.knownPortsRestoreValue) {
					let n = JSON.parse(t) ?? []
					this.logService.trace(
						`ForwardedPorts: (TunnelModel) restoring ports ${n.map((r) => r.remotePort).join(", ")}`,
					)
					for (let r of n) {
						let i = xr(this.detected, r.remoteHost, r.remotePort)
						;(r.source.source !== 2 && !i) || (r.source.source === 2 && i)
							? await this.doForward({
									remote: { host: r.remoteHost, port: r.remotePort },
									local: r.localPort,
									name: r.name,
									elevateIfNeeded: !0,
									source: r.source,
								})
							: r.source.source === 2 &&
								!i &&
								this.unrestoredExtensionTunnels.set(Hr(r.remoteHost, r.remotePort), r)
					}
				}
			}
			if (((this.restoreComplete = !0), this.onRestoreComplete.fire(), !this.restoreListener)) {
				let t = await this.getTunnelRestoreStorageKey()
				;(this.restoreListener = this._register(new Q())),
					this.restoreListener.add(
						this.storageService.onDidChangeValue(
							0,
							void 0,
							this.restoreListener,
						)(async (n) => {
							n.key === t &&
								((this.tunnelRestoreValue = Promise.resolve(this.storageService.get(t, 0))),
								await this.restoreForwarded())
						}),
					)
			}
		}
		cleanupExpiredTunnelsForRestore() {
			let t = this.storageService.keys(0, 0).filter((n) => n.startsWith(c0))
			for (let n of t) {
				let r = this.storageService.getNumber(n, 0)
				if (r && r < Date.now()) {
					this.tunnelRestoreValue = Promise.resolve(void 0)
					let i = n.replace(c0, wT)
					this.storageService.remove(n, 0), this.storageService.remove(i, 0)
				}
			}
		}
		async storeForwarded() {
			if (this.configurationService.getValue("remote.restoreForwardedPorts")) {
				let t = Array.from(this.forwarded.values()),
					n = t.map((a) => ({
						remoteHost: a.remoteHost,
						remotePort: a.remotePort,
						localPort: a.localPort,
						name: a.name,
						localAddress: a.localAddress,
						localUri: a.localUri,
						protocol: a.protocol,
						source: a.source,
					})),
					r
				t.length > 0 && (r = JSON.stringify(n))
				let i = await this.getTunnelRestoreStorageKey(),
					s = await this.getRestoreExpirationStorageKey()
				!r && i && s
					? (this.storageService.remove(i, 0), this.storageService.remove(s, 0))
					: r !== this.knownPortsRestoreValue &&
						i &&
						s &&
						(this.storageService.store(i, r, 0, 0), this.storageService.store(s, Date.now() + Q$, 0, 0)),
					(this.knownPortsRestoreValue = r)
			}
		}
		async showPortMismatchModalIfNeeded(t, n, r) {
			if (!t.tunnelLocalPort || !r?.requireLocalPort || t.tunnelLocalPort === n) return
			let i = new Date()
			if (this.mismatchCooldown.getTime() + G$ > i.getTime()) return
			this.mismatchCooldown = i
			let s = p(
				"remote.localPortMismatch.single",
				`Local port {0} could not be used for forwarding to remote port {1}.

This usually happens when there is already another process using local port {0}.

Port number {2} has been used instead.`,
				n,
				t.tunnelRemotePort,
				t.tunnelLocalPort,
			)
			return this.dialogService.info(s)
		}
		async forward(t, n) {
			return (
				!this.restoreComplete &&
					this.environmentService.remoteAuthority &&
					(await Te.toPromise(this.onRestoreComplete.event)),
				this.doForward(t, n)
			)
		}
		async doForward(t, n) {
			await this.extensionService.activateByEvent(FU)
			let r = xr(this.forwarded, t.remote.host, t.remote.port)
			n = n ?? (n !== null ? (await this.getAttributes([t.remote]))?.get(t.remote.port) : void 0)
			let i = t.local !== void 0 ? t.local : t.remote.port,
				s
			if (r) return this.mergeAttributesIntoExistingTunnel(r, t, n)
			{
				let a = this.environmentService.remoteAuthority,
					l = a
						? {
								getAddress: async () =>
									(await this.remoteAuthorityResolverService.resolveAuthority(a)).authority,
							}
						: void 0,
					d = Hr(t.remote.host, t.remote.port)
				this.inProgress.set(d, !0), (t = this.mergeCachedAndUnrestoredProperties(d, t))
				let c = await this.tunnelService.openTunnel(
					l,
					t.remote.host,
					t.remote.port,
					void 0,
					i,
					t.elevateIfNeeded ? t.elevateIfNeeded : n?.elevateIfNeeded,
					t.privacy,
					n?.protocol,
				)
				if (typeof c == "string") s = c
				else if (c && c.localAddress) {
					let u = xr(this._candidates ?? new Map(), t.remote.host, t.remote.port),
						m = c.protocol ? (c.protocol === "https" ? "https" : "http") : (n?.protocol ?? "http"),
						f = {
							remoteHost: c.tunnelRemoteHost,
							remotePort: c.tunnelRemotePort,
							localPort: c.tunnelLocalPort,
							name: n?.label ?? t.name,
							closeable: !0,
							localAddress: c.localAddress,
							protocol: m,
							localUri: await this.makeLocalUri(c.localAddress, n),
							runningProcess: u?.detail,
							hasRunningProcess: !!u,
							pid: u?.pid,
							source: t.source ?? u0,
							privacy: c.privacy,
						}
					return (
						this.forwarded.set(d, f),
						this.remoteTunnels.set(d, c),
						this.inProgress.delete(d),
						await this.storeForwarded(),
						await this.showPortMismatchModalIfNeeded(c, i, n),
						this._onForwardPort.fire(f),
						c
					)
				}
				this.inProgress.delete(d)
			}
			return s
		}
		mergeCachedAndUnrestoredProperties(t, n) {
			let r = this.unrestoredExtensionTunnels.has(t)
				? this.unrestoredExtensionTunnels
				: this.sessionCachedProperties.has(t)
					? this.sessionCachedProperties
					: void 0
			if (r) {
				let i = r.get(t)
				r.delete(t),
					i &&
						((n.name = i.name ?? n.name),
						(n.local = ("local" in i ? i.local : "localPort" in i ? i.localPort : void 0) ?? n.local),
						(n.privacy = n.privacy))
			}
			return n
		}
		async mergeAttributesIntoExistingTunnel(t, n, r) {
			let i = r?.label ?? n.name,
				s
			;((u) => ((u[(u.None = 0)] = "None"), (u[(u.Fire = 1)] = "Fire"), (u[(u.Reopen = 2)] = "Reopen")))(
				(s ||= {}),
			)
			let a = 0
			switch (
				(i !== t.name && ((t.name = i), (a = 1)),
				(r?.protocol || t.protocol !== "http") &&
					r?.protocol !== t.protocol &&
					((n.source = t.source), (a = 2)),
				n.privacy && t.privacy !== n.privacy && (a = 2),
				a)
			) {
				case 1: {
					this._onForwardPort.fire()
					break
				}
				case 2:
					await this.close(t.remoteHost, t.remotePort, "User"), await this.doForward(n, r)
			}
			return xr(this.remoteTunnels, n.remote.host, n.remote.port)
		}
		async name(t, n, r) {
			let i = xr(this.forwarded, t, n),
				s = Hr(t, n)
			if (i) {
				;(i.name = r), await this.storeForwarded(), this._onPortName.fire({ host: t, port: n })
				return
			} else
				this.detected.has(s) && ((this.detected.get(s).name = r), this._onPortName.fire({ host: t, port: n }))
		}
		async close(t, n, r) {
			let i = Hr(t, n),
				s = this.forwarded.get(i)
			return (
				r === "AutoForwardEnd" &&
					s &&
					s.source.source === 1 &&
					this.sessionCachedProperties.set(i, { local: s.localPort, name: s.name, privacy: s.privacy }),
				await this.tunnelService.closeTunnel(t, n),
				this.onTunnelClosed({ host: t, port: n }, r)
			)
		}
		address(t, n) {
			let r = Hr(t, n)
			return (this.forwarded.get(r) || this.detected.get(r))?.localAddress
		}
		get environmentTunnelsSet() {
			return this._environmentTunnelsSet
		}
		addEnvironmentTunnels(t) {
			if (t)
				for (let n of t) {
					let r = xr(this._candidates ?? new Map(), n.remoteAddress.host, n.remoteAddress.port),
						i =
							typeof n.localAddress == "string"
								? n.localAddress
								: Hr(n.localAddress.host, n.localAddress.port)
					this.detected.set(Hr(n.remoteAddress.host, n.remoteAddress.port), {
						remoteHost: n.remoteAddress.host,
						remotePort: n.remoteAddress.port,
						localAddress: i,
						protocol: "http",
						localUri: this.makeLocalUri(i),
						closeable: !1,
						runningProcess: r?.detail,
						hasRunningProcess: !!r,
						pid: r?.pid,
						privacy: "constantPrivate",
						source: { source: 2, description: p("tunnel.staticallyForwarded", "Statically Forwarded") },
					}),
						this.tunnelService.setEnvironmentTunnel(
							n.remoteAddress.host,
							n.remoteAddress.port,
							i,
							"constantPrivate",
							"http",
						)
				}
			;(this._environmentTunnelsSet = !0), this._onEnvironmentTunnelsSet.fire(), this._onForwardPort.fire()
		}
		setCandidateFilter(t) {
			this._candidateFilter = t
		}
		async setCandidates(t) {
			let n = t
			this._candidateFilter && (n = await this._candidateFilter(t))
			let r = this.updateInResponseToCandidates(n)
			this.logService.trace(
				`ForwardedPorts: (TunnelModel) removed candidates ${Array.from(r.values())
					.map((i) => i.port)
					.join(", ")}`,
			),
				this._onCandidatesChanged.fire(r)
		}
		updateInResponseToCandidates(t) {
			let n = this._candidates ?? new Map(),
				r = new Map()
			return (
				(this._candidates = r),
				t.forEach((i) => {
					let s = Hr(i.host, i.port)
					r.set(s, { host: i.host, port: i.port, detail: i.detail, pid: i.pid }), n.has(s) && n.delete(s)
					let a = xr(this.forwarded, i.host, i.port)
					a && ((a.runningProcess = i.detail), (a.hasRunningProcess = !0), (a.pid = i.pid))
				}),
				n.forEach((i, s) => {
					let a = p0(s)
					if (!a) return
					let l = xr(this.forwarded, a.host, a.port)
					l && ((l.runningProcess = void 0), (l.hasRunningProcess = !1), (l.pid = void 0))
					let d = xr(this.detected, a.host, a.port)
					d && ((d.runningProcess = void 0), (d.hasRunningProcess = !1), (d.pid = void 0))
				}),
				n
			)
		}
		get candidates() {
			return this._candidates ? Array.from(this._candidates.values()) : []
		}
		get candidatesOrUndefined() {
			return this._candidates ? this.candidates : void 0
		}
		async updateAttributes() {
			let t = Array.from(this.forwarded.values()),
				n = await this.getAttributes(
					t.map((r) => ({ port: r.remotePort, host: r.remoteHost })),
					!1,
				)
			if (n)
				for (let r of t) {
					let i = n.get(r.remotePort)
					;(i?.protocol || r.protocol !== "http") &&
						i?.protocol !== r.protocol &&
						(await this.doForward(
							{
								remote: { host: r.remoteHost, port: r.remotePort },
								local: r.localPort,
								name: r.name,
								source: r.source,
							},
							i,
						)),
						i && i.label && i.label !== r.name && (await this.name(r.remoteHost, r.remotePort, i.label))
				}
		}
		async getAttributes(t, n = !0) {
			let r = new Map(),
				i = new Map()
			t.forEach((c) => {
				let u = xr(this._candidates ?? new Map(), bp[0], c.port) ?? c
				if (u) {
					r.set(c.port, u)
					let m = X$(u) ? u.pid : void 0
					i.has(m) || i.set(m, []), i.get(m)?.push(c.port)
				}
			})
			let s = new Map()
			if (
				(t.forEach((c) => {
					let u = this.configPortsAttributes.getAttributes(c.port, c.host, r.get(c.port)?.detail)
					u && s.set(c.port, u)
				}),
				this.portAttributesProviders.length === 0 || !n)
			)
				return s.size > 0 ? s : void 0
			let a = await Promise.all(
					this.portAttributesProviders.flatMap((c) =>
						Array.from(i.entries()).map((u) => {
							let m = u[1],
								f = r.get(m[0])
							return c.providePortAttributes(m, f?.pid, f?.detail, De.None)
						}),
					),
				),
				l = new Map()
			if (
				(a.forEach((c) =>
					c.forEach((u) => {
						u && l.set(u.port, u)
					}),
				),
				!s && !l)
			)
				return
			let d = new Map()
			return (
				t.forEach((c) => {
					let u = s.get(c.port),
						m = l.get(c.port)
					d.set(c.port, {
						elevateIfNeeded: u?.elevateIfNeeded,
						label: u?.label,
						onAutoForward: u?.onAutoForward ?? PT.providedActionToAction(m?.autoForwardAction),
						requireLocalPort: u?.requireLocalPort,
						protocol: u?.protocol,
					})
				}),
				d
			)
		}
		addAttributesProvider(t) {
			this.portAttributesProviders.push(t)
		}
	}
R([Ml(1e3)], Hh.prototype, "storeForwarded", 1),
	(Hh = R([S(0, GF), S(1, uy), S(2, vr), S(3, $x), S(4, pF), S(5, mi), S(6, te), S(7, MU), S(8, Ty), S(9, ca)], Hh))
function Y$(o) {
	let e = o.trim().split(`
`),
		t = []
	return (
		e.forEach((r) => {
			let i = /\/proc\/(\d+)\/fd\/\d+ -> socket:\[(\d+)\]/.exec(r)
			i && i.length >= 3 && t.push({ pid: parseInt(i[1], 10), socket: parseInt(i[2], 10) })
		}),
		t.reduce((r, i) => ((r[i.socket] = i), r), {})
	)
}
function Z$(...o) {
	let e = [].concat(...o.map(t6))
	return [
		...new Map(
			e
				.filter((t) => t.st === "0A")
				.map((t) => {
					let n = t.local_address.split(":")
					return { socket: parseInt(t.inode, 10), ip: e6(n[0]), port: parseInt(n[1], 16) }
				})
				.map((t) => [t.ip + ":" + t.port, t]),
		).values(),
	]
}
function e6(o) {
	let e = ""
	if (o.length === 8)
		for (let t = o.length - 2; t >= 0; t -= 2) (e += parseInt(o.substr(t, 2), 16)), t !== 0 && (e += ".")
	else
		for (let t = 0; t < o.length; t += 8) {
			let n = o.substring(t, t + 8),
				r = ""
			for (let i = 8; i >= 2; i -= 2)
				(r += n.substring(i - 2, i)),
					(i === 6 || i === 2) &&
						((r = parseInt(r, 16).toString(16)),
						(e += `${r}`),
						(r = ""),
						t + i !== o.length - 6 && (e += ":"))
		}
	return e
}
function t6(o) {
	let e = o.trim().split(`
`),
		t = e
			.shift()
			.trim()
			.split(/\s+/)
			.filter((r) => r !== "rx_queue" && r !== "tm->when")
	return e.map((r) =>
		r
			.trim()
			.split(/\s+/)
			.reduce((i, s, a) => ((i[t[a] || a] = s), i), {}),
	)
}
function n6(o) {
	return o.length > 500
		? !1
		: !!o.match(/.*\.vscode-server-[a-zA-Z]+\/bin.*/) ||
				o.indexOf("out/server-main.js") !== -1 ||
				o.indexOf("_productName=VSCode") !== -1
}
function r6(o) {
	let e = o.trim().split(`
`),
		t = []
	return (
		e.forEach((n) => {
			let r = /^\d+\s+\D+\s+root\s+(\d+)\s+(\d+).+\d+\:\d+\:\d+\s+(.+)$/.exec(n)
			r && r.length >= 4 && t.push({ pid: parseInt(r[1], 10), ppid: parseInt(r[2]), cmd: r[3] })
		}),
		t
	)
}
async function o6(o, e, t) {
	let n = t.reduce((i, s) => ((i[s.pid] = s), i), {}),
		r = []
	return (
		o.forEach(({ socket: i, ip: s, port: a }) => {
			let l = e[i] ? e[i].pid : void 0,
				d = l ? n[l]?.cmd : void 0
			l && d && !n6(d) && r.push({ host: s, port: a, detail: d, pid: l })
		}),
		r
	)
}
function i6(o, e, t) {
	let n = new Map(),
		r = r6(e)
	for (let i of o) {
		let s = t.get(i.port)
		if (s) {
			n.set(i.port, s)
			continue
		}
		let a = r.find((l) => l.cmd.includes(`${i.port}`))
		if (a) {
			let l = a,
				d
			do (d = r.find((c) => c.ppid === l.pid)), d && (l = d)
			while (d)
			n.set(i.port, { host: i.ip, port: i.port, pid: l.pid, detail: l.cmd, ppid: l.ppid })
		} else n.set(i.port, { host: i.ip, port: i.port, ppid: Number.MAX_VALUE })
	}
	return n
}
var Um = class extends rl {
	constructor(t, n, r, i) {
		super(t, n, r)
		this.initData = n
		this.signService = i
		this._initialCandidates = void 0
		this._foundRootPorts = new Map()
		this._candidateFindingEnabled = !1
		Ve &&
			n.remote.isRemote &&
			n.remote.authority &&
			(this._proxy.$setRemoteTunnelService(process.pid), this.setInitialCandidates())
	}
	async $registerCandidateFinder(t) {
		if (t && this._candidateFindingEnabled) return
		this._candidateFindingEnabled = t
		let n
		this._initialCandidates &&
			((n = this._initialCandidates), await this._proxy.$onFoundNewCandidates(this._initialCandidates))
		let r = new mb(),
			i = 0
		for (; this._candidateFindingEnabled; ) {
			let s = new Date().getTime(),
				a = (await this.findCandidatePorts()).filter((c) => Mi(c.host) || So(c.host))
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${a.map((c) => c.port).join(", ")}`,
			)
			let l = new Date().getTime() - s
			this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${l} ms.`),
				i++ > 3 && r.update(l),
				(!n || JSON.stringify(n) !== JSON.stringify(a)) && ((n = a), await this._proxy.$onFoundNewCandidates(n))
			let d = this.calculateDelay(r.value)
			this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${d} ms.`),
				await new Promise((c) => setTimeout(() => c(), d))
		}
	}
	calculateDelay(t) {
		return Math.max(t * 20, 2e3)
	}
	async setInitialCandidates() {
		;(this._initialCandidates = await this.findCandidatePorts()),
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map((t) => t.port).join(", ")}`,
			)
	}
	async findCandidatePorts() {
		let t = "",
			n = ""
		try {
			;(t = await Nm.promises.readFile("/proc/net/tcp", "utf8")),
				(n = await Nm.promises.readFile("/proc/net/tcp6", "utf8"))
		} catch {}
		let r = Z$(t, n),
			i = await new Promise((f) => {
				UU("ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:", (h, g, I) => {
					f(g)
				})
			}),
			s = Y$(i),
			a = await Qe.readdir("/proc"),
			l = []
		for (let f of a)
			try {
				let h = Number(f),
					g = ct(y.file("/proc"), f)
				if ((await Nm.promises.stat(g.fsPath)).isDirectory() && !isNaN(h)) {
					let C = await Nm.promises.readlink(ct(g, "cwd").fsPath),
						T = await Nm.promises.readFile(ct(g, "cmdline").fsPath, "utf8")
					l.push({ pid: h, cwd: C, cmd: T })
				}
			} catch {}
		let d = [],
			c = r.filter((f) => {
				let h = s[f.socket]
				return h || d.push(f), h
			}),
			u = o6(c, s, l),
			m
		if (
			(this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${d.length}`),
			d.length > 0)
		) {
			let f = await new Promise((h) => {
				UU("ps -F -A -l | grep root", (g, I, C) => {
					h(I)
				})
			})
			;(this._foundRootPorts = i6(d, f, this._foundRootPorts)),
				(m = Array.from(this._foundRootPorts.values())),
				this.logService.trace(
					`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${m.map((h) => h.port).join(", ")}`,
				)
		}
		return u.then((f) => (m ? f.concat(m) : f))
	}
	makeManagedTunnelFactory(t) {
		return async (n) => {
			let r = new Uh(
				{
					commit: this.initData.commit,
					quality: this.initData.quality,
					logService: this.logService,
					ipcLogger: null,
					remoteSocketFactoryService: {
						_serviceBrand: void 0,
						async connect(s, a, l, d) {
							let c = await t.makeConnection()
							return m0.connect(c, a, l, d)
						},
						register() {
							throw new Error("not implemented")
						},
					},
					addressProvider: {
						getAddress() {
							return Promise.resolve({ connectTo: new lu(0), connectionToken: t.connectionToken })
						},
					},
					signService: this.signService,
				},
				"localhost",
				n.remoteAddress.host || "localhost",
				n.remoteAddress.port,
				n.localAddressPort,
			)
			await r.waitForReady()
			let i = new E()
			return {
				localAddress: p0(r.localAddress) ?? r.localAddress,
				remoteAddress: { port: r.tunnelRemotePort, host: r.tunnelRemoteHost },
				onDidDispose: i.event,
				dispose: () => {
					r.dispose(), i.fire(), i.dispose()
				},
			}
		}
	}
}
Um = R([S(0, ie), S(1, Xe), S(2, te), S(3, yl)], Um)
var m0 = class o extends xT {
	constructor(t, n, r) {
		super(n, r)
		this.passing = t
	}
	static connect(t, n, r, i) {
		let s = new Q(),
			a = { onClose: s.add(new E()), onData: s.add(new E()), onEnd: s.add(new E()) }
		s.add(t.onDidReceiveMessage((d) => a.onData.fire(z.wrap(d)))),
			s.add(t.onDidEnd(() => a.onEnd.fire())),
			s.add(t.onDidClose((d) => a.onClose.fire({ type: 0, error: d, hadError: !!d })))
		let l = new o(t, i, a)
		return l._register(s), EU(l, n, r, i, a)
	}
	write(t) {
		this.passing.send(t.buffer)
	}
	closeRemote() {
		this.passing.end()
	}
	async drain() {
		await this.passing.drain?.()
	}
}
import * as Qs from "fs"
var _T = class extends gp {
	constructor() {
		super(...arguments)
		this._workspaceStorageLock = null
	}
	async _getWorkspaceStorageURI(t) {
		let n = await super._getWorkspaceStorageURI(t)
		if (n.scheme !== W.file) return n
		if (this._environment.skipWorkspaceStorageLock)
			return this._logService.info(`Skipping acquiring lock for ${n.fsPath}.`), n
		let r = n.fsPath,
			i = 0
		do {
			let s
			i === 0 ? (s = r) : (s = /[/\\]$/.test(r) ? `${r.substr(0, r.length - 1)}-${i}` : `${r}-${i}`), await s6(s)
			let a = Fe(s, "vscode.lock"),
				l = await WU(this._logService, a, !1)
			if (l)
				return (
					(this._workspaceStorageLock = l),
					process.on("exit", () => {
						l.dispose()
					}),
					y.file(s)
				)
			i++
		} while (i < 10)
		return n
	}
	onWillDeactivateAll() {
		this._workspaceStorageLock?.setWillRelease(6e3)
	}
}
async function s6(o) {
	try {
		await Qs.promises.stat(o)
		return
	} catch {}
	try {
		await Qs.promises.mkdir(o, { recursive: !0 })
	} catch {}
}
var a6 = 1e3,
	HU = 600 * 1e3,
	g0 = class extends $ {
		constructor(t, n) {
			super()
			this.logService = t
			this.filename = n
			;(this._timer = this._register(new Sc())),
				this._timer.cancelAndSet(async () => {
					let r = await h0(t, n)
					;(!r || r.pid !== process.pid) &&
						(t.info(`Lock '${n}': The lock was lost unexpectedly.`), this._timer.cancel())
					try {
						await Qs.promises.utimes(n, new Date(), new Date())
					} catch (i) {
						t.error(i), t.info(`Lock '${n}': Could not update mtime.`)
					}
				}, a6)
		}
		dispose() {
			super.dispose()
			try {
				Qs.unlinkSync(this.filename)
			} catch {}
		}
		async setWillRelease(t) {
			this.logService.info(
				`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${t} ms.`,
			)
			try {
				let n = { pid: process.pid, willReleaseAt: Date.now() + t }
				await Qe.writeFile(this.filename, JSON.stringify(n), { flag: "w" })
			} catch (n) {
				this.logService.error(n)
			}
		}
	}
async function WU(o, e, t) {
	try {
		let r = { pid: process.pid, willReleaseAt: 0 }
		await Qe.writeFile(e, JSON.stringify(r), { flag: "wx" })
	} catch (r) {
		o.error(r)
	}
	let n = await h0(o, e)
	return !n || n.pid !== process.pid
		? t
			? (o.info(`Lock '${e}': Could not acquire lock, giving up.`), null)
			: (o.info(`Lock '${e}': Could not acquire lock, checking if the file is stale.`), d6(o, e))
		: (o.info(`Lock '${e}': Lock acquired.`), new g0(o, e))
}
async function h0(o, e) {
	let t
	try {
		t = await Qs.promises.readFile(e)
	} catch (n) {
		return o.error(n), null
	}
	try {
		return JSON.parse(String(t))
	} catch (n) {
		return o.error(n), null
	}
}
async function f0(o, e) {
	let t
	try {
		t = await Qs.promises.stat(e)
	} catch (n) {
		return o.error(n), 0
	}
	return t.mtime.getTime()
}
function l6(o) {
	try {
		return process.kill(o, 0), !0
	} catch {
		return !1
	}
}
async function d6(o, e) {
	let t = await h0(o, e)
	if (!t) return o.info(`Lock '${e}': Could not read pid of lock holder.`), Wh(o, e)
	if (t.willReleaseAt) {
		let a = t.willReleaseAt - Date.now()
		if (a < 5e3) {
			for (
				a > 0
					? o.info(`Lock '${e}': The lockfile is scheduled to be released in ${a} ms.`)
					: o.info(`Lock '${e}': The lockfile is scheduled to have been released.`);
				a > 0;

			) {
				if ((await Wt(Math.min(100, a)), (await f0(o, e)) === 0)) return Wh(o, e)
				a = t.willReleaseAt - Date.now()
			}
			return Wh(o, e)
		}
	}
	if (!l6(t.pid)) return o.info(`Lock '${e}': The pid ${t.pid} appears to be gone.`), Wh(o, e)
	let n = await f0(o, e),
		r = Date.now() - n
	if (r <= HU) return o.info(`Lock '${e}': The lock does not look stale, elapsed: ${r} ms, giving up.`), null
	o.info(`Lock '${e}': The lock looks stale, waiting for 2s.`), await Wt(2e3)
	let i = await f0(o, e),
		s = Date.now() - i
	return s <= HU
		? (o.info(`Lock '${e}': The lock does not look stale, elapsed: ${s} ms, giving up.`), null)
		: (o.info(`Lock '${e}': The lock looks stale even after waiting for 2s.`), Wh(o, e))
}
async function Wh(o, e) {
	o.info(`Lock '${e}': Deleting a stale lock.`)
	try {
		await Qs.promises.unlink(e)
	} catch {}
	return WU(o, e, !0)
}
async function c6(o, e, t, n, r) {
	try {
		let i = await import("@vscode/spdlog")
		i.setFlushOn(0)
		let s = await i.createAsyncRotatingLogger(o, e, t, n)
		return r ? s.clearFormatters() : s.setPattern("%Y-%m-%d %H:%M:%S.%e [%l] %v"), s
	} catch (i) {
		console.error(i)
	}
	return null
}
function VU(o, e, t) {
	switch (e) {
		case 1:
			o.trace(t)
			break
		case 2:
			o.debug(t)
			break
		case 3:
			o.info(t)
			break
		case 4:
			o.warn(t)
			break
		case 5:
			o.error(t)
			break
		case 0:
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
function BU(o, e) {
	switch (e) {
		case 1:
			o.setLevel(0)
			break
		case 2:
			o.setLevel(1)
			break
		case 3:
			o.setLevel(2)
			break
		case 4:
			o.setLevel(3)
			break
		case 5:
			o.setLevel(4)
			break
		case 0:
			o.setLevel(6)
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
var DT = class extends pa {
	constructor(t, n, r, i, s) {
		super()
		this.buffer = []
		this.setLevel(s),
			(this._loggerCreationPromise = this._createSpdLogLogger(t, n, r, i)),
			this._register(
				this.onDidChangeLogLevel((a) => {
					this._logger && BU(this._logger, a)
				}),
			)
	}
	async _createSpdLogLogger(t, n, r, i) {
		let s = r ? 6 : 1,
			a = (30 / s) * Hc.MB,
			l = await c6(t, n, a, s, i)
		if (l) {
			;(this._logger = l), BU(this._logger, this.getLevel())
			for (let { level: d, message: c } of this.buffer) VU(this._logger, d, c)
			this.buffer = []
		}
	}
	log(t, n) {
		this._logger ? VU(this._logger, t, n) : this.getLevel() <= t && this.buffer.push({ level: t, message: n })
	}
	flush() {
		this._logger ? this.flushLogger() : this._loggerCreationPromise.then(() => this.flushLogger())
	}
	dispose() {
		this._logger ? this.disposeLogger() : this._loggerCreationPromise.then(() => this.disposeLogger()),
			super.dispose()
	}
	flushLogger() {
		this._logger && this._logger.flush()
	}
	disposeLogger() {
		this._logger && (this._logger.drop(), (this._logger = void 0))
	}
}
var kT = class extends ml {
	doCreateLogger(e, t, n) {
		return e.scheme === W.file
			? new DT(n?.name || He(), e.fsPath, !n?.donotRotate, !!n?.donotUseFormatters, t)
			: super.doCreateLogger(e, t, n)
	}
	registerLogger(e) {
		super.registerLogger(e), this._proxy.$registerLogger(e)
	}
	deregisterLogger(e) {
		super.deregisterLogger(e), this._proxy.$deregisterLogger(e)
	}
}
import { homedir as u6 } from "os"
var RT = class extends cl {
	homeDir() {
		return u6()
	}
}
var AT = class extends $ {
	constructor(e, t = []) {
		super(), (this.logger = new ib([e, ...t])), this._register(e.onDidChangeLogLevel((n) => this.setLevel(n)))
	}
	get onDidChangeLogLevel() {
		return this.logger.onDidChangeLogLevel
	}
	setLevel(e) {
		this.logger.setLevel(e)
	}
	getLevel() {
		return this.logger.getLevel()
	}
	trace(e, ...t) {
		this.logger.trace(e, ...t)
	}
	debug(e, ...t) {
		this.logger.debug(e, ...t)
	}
	info(e, ...t) {
		this.logger.info(e, ...t)
	}
	warn(e, ...t) {
		this.logger.warn(e, ...t)
	}
	error(e, ...t) {
		this.logger.error(e, ...t)
	}
	flush() {
		this.logger.flush()
	}
}
var Hm = class extends AT {
	constructor(e, t, n) {
		let r = n.remote.isRemote ? "remoteexthost" : e ? "workerexthost" : "exthost",
			i = n.remote.isRemote
				? p("remote", "Extension Host (Remote)")
				: e
					? p("worker", "Extension Host (Worker)")
					: p("local", "Extension Host")
		super(t.createLogger(r, { name: i }))
	}
}
Hm = R([S(1, co), S(2, Xe)], Hm)
import { spawn as m6 } from "child_process"
import { readFile as f6 } from "fs/promises"
import { homedir as zU } from "os"
function $U(o) {
	let e = new Map(),
		n = o.replace(
			/\r\n?/g,
			`
`,
		).split(`
`)
	for (let s of n) {
		if (((s = s.trim()), !s || s.startsWith("#"))) continue
		let [a, l] = r(s)
		a && e.set(a, l)
	}
	return e
	function r(s) {
		s.startsWith("export ") && (s = s.substring(7).trim())
		let a = i(s, (u) => u === "=" || u === ":")
		if (a === -1) return [null, null]
		let l = s.substring(0, a).trim(),
			d = s.substring(a + 1).trim(),
			c = i(d, (u) => u === "#")
		if ((c !== -1 && (d = d.substring(0, c).trim()), d.length >= 2)) {
			let u = d[0],
				m = d[d.length - 1]
			;((u === '"' && m === '"') || (u === "'" && m === "'") || (u === "`" && m === "`")) &&
				((d = d.substring(1, d.length - 1)),
				u === '"' &&
					(d = d
						.replace(
							/\\n/g,
							`
`,
						)
						.replace(/\\r/g, "\r")))
		}
		return [l, d]
	}
	function i(s, a) {
		let l = !1,
			d = ""
		for (let c = 0; c < s.length; c++) {
			let u = s[c]
			if (l) u === d && s[c - 1] !== "\\" && (l = !1)
			else if (u === '"' || u === "'" || u === "`") (l = !0), (d = u)
			else if (a(u)) return c
		}
		return -1
	}
}
import { Transform as p6 } from "stream"
var Vh = class extends p6 {
	constructor(e) {
		if ((super(), typeof e == "number")) (this.splitter = e), (this.spitterLen = 1)
		else {
			let t = Buffer.isBuffer(e) ? e : Buffer.from(e)
			;(this.splitter = t.length === 1 ? t[0] : t), (this.spitterLen = t.length)
		}
	}
	_transform(e, t, n) {
		this.buffer ? (this.buffer = Buffer.concat([this.buffer, e])) : (this.buffer = e)
		let r = 0
		for (; r < this.buffer.length; ) {
			let i =
				typeof this.splitter == "number"
					? this.buffer.indexOf(this.splitter, r)
					: AE(this.buffer, this.splitter, r)
			if (i === -1) break
			this.push(this.buffer.slice(r, i + this.spitterLen)), (r = i + this.spitterLen)
		}
		;(this.buffer = r === this.buffer.length ? void 0 : this.buffer.slice(r)), n()
	}
	_flush(e) {
		this.buffer && this.push(this.buffer), e()
	}
}
var Wm = class extends fl {
	constructor(t) {
		super(t)
		this.nodeServers = new Map()
	}
	_startMcp(t, n) {
		n.type === 1 ? this.startNodeMpc(t, n) : super._startMcp(t, n)
	}
	$stopMcp(t) {
		let n = this.nodeServers.get(t)
		n ? (n.abortCtrl.abort(), this.nodeServers.delete(t)) : super.$stopMcp(t)
	}
	$sendMessage(t, n) {
		let r = this.nodeServers.get(t)
		r
			? r.child.stdin.write(
					n +
						`
`,
				)
			: super.$sendMessage(t, n)
	}
	async startNodeMpc(t, n) {
		let r = (l) =>
				this._proxy.$onDidChangeState(t, {
					state: Ur.Kind.Error,
					message: typeof l == "string" ? l : l.message,
				}),
			i = { ...process.env }
		if (n.envFile)
			try {
				for (let [l, d] of $U(await f6(n.envFile, "utf-8"))) i[l] = d
			} catch (l) {
				r(`Failed to read envFile '${n.envFile}': ${l.message}`)
				return
			}
		for (let [l, d] of Object.entries(n.env)) i[l] = d === null ? void 0 : String(d)
		let s = new AbortController(),
			a
		try {
			let l = n.cwd ? y.revive(n.cwd).fsPath : zU(),
				{ executable: d, args: c, shell: u } = await h6(n.command, n.args, l, i)
			this._proxy.$onDidPublishLog(t, 2, `Server command line: ${d} ${c.join(" ")}`),
				(a = m6(d, c, {
					stdio: "pipe",
					cwd: n.cwd ? y.revive(n.cwd).fsPath : zU(),
					signal: s.signal,
					env: i,
					shell: u,
				}))
		} catch (l) {
			r(l), s.abort()
			return
		}
		this._proxy.$onDidChangeState(t, { state: Ur.Kind.Starting }),
			a.stdout
				.pipe(
					new Vh(`
`),
				)
				.on("data", (l) => this._proxy.$onDidReceiveMessage(t, l.toString())),
			a.stdin.on("error", r),
			a.stdout.on("error", r),
			a.stderr
				.pipe(
					new Vh(`
`),
				)
				.on("data", (l) => this._proxy.$onDidPublishLog(t, 4, `[server stderr] ${l.toString().trimEnd()}`)),
			a.on("spawn", () => this._proxy.$onDidChangeState(t, { state: Ur.Kind.Running })),
			a.on("error", (l) => {
				s.signal.aborted ? this._proxy.$onDidChangeState(t, { state: Ur.Kind.Stopped }) : r(l)
			}),
			a.on("exit", (l) =>
				l === 0 || s.signal.aborted
					? this._proxy.$onDidChangeState(t, { state: Ur.Kind.Stopped })
					: this._proxy.$onDidChangeState(t, {
							state: Ur.Kind.Error,
							message: `Process exited with code ${l}`,
						}),
			),
			this.nodeServers.set(t, { abortCtrl: s, child: a })
	}
}
Wm = R([S(0, ie)], Wm)
var g6 = /\.(bat|cmd)$/i,
	h6 = async (o, e, t, n) => {
		if (process.platform !== "win32") return { executable: o, args: e, shell: !1 }
		let r = await Wd(o, t, void 0, n)
		if (r && g6.test(r)) {
			let i = (s) => (s.includes(" ") ? `"${s}"` : s)
			return { executable: i(r), args: e.map(i), shell: !0 }
		}
		return { executable: o, args: e, shell: !1 }
	}
Ke(ur, IT, 0)
Ke(co, kT, 1)
Ke(te, new gr(Hm, [!1], !0))
Ke(yl, om, 1)
Ke(hp, _T, 0)
Ke(sl, new gr(Cp, [!1], !0))
Ke(Qp, sm, 0)
Ke(Yp, um, 0)
Ke(zp, nm, 0)
Ke(er, tm, 0)
Ke(ol, Um, 0)
Ke(Yo, RT, 0)
Ke(Hd, Wm, 0)
import { createRequire as b6 } from "module"
var KU = b6(import.meta.url)
;(function () {
	for (let e = 0; e < process.execArgv.length; e++)
		process.execArgv[e] === "--inspect-port=0" && (process.execArgv.splice(e, 1), e--)
})()
var OT = v6(process.argv.slice(2), { boolean: ["transformURIs", "skipWorkspaceStorageLock"], string: ["useHostProxy"] })
;(function () {
	let o = KU("module"),
		e = o._load
	o._load = function (t) {
		if (t === "natives")
			throw new Error(
				'Either the extension or an NPM dependency is using the [unsupported "natives" node module](https://go.microsoft.com/fwlink/?linkid=871887).',
			)
		return e.apply(this, arguments)
	}
})()
var LT = process.exit.bind(process),
	y6 = process.on.bind(process)
function I6(o) {
	;(process.exit = function (e) {
		if (o) LT(e)
		else {
			let t = new Error("An extension called process.exit() and this was prevented.")
			console.warn(t.stack)
		}
	}),
		(process.crash = function () {
			let e = new Error("An extension called process.crash() and this was prevented.")
			console.warn(e.stack)
		}),
		(process.env.ELECTRON_RUN_AS_NODE = "1"),
		(process.on = function (e, t) {
			if (e === "uncaughtException") {
				let n = t
				t = function (...r) {
					try {
						return n.apply(void 0, r)
					} catch {}
				}
			}
			y6(e, t)
		})
}
var Vi = function (o) {
	LT()
}
function x6() {
	let o = b2(process.env)
	if (o.type === 3)
		return new Promise((e, t) => {
			let n = (r) => {
				let i = r[0],
					s = new ui()
				i.on("message", (a) => s.fire(z.wrap(a.data))),
					i.on("close", () => {
						Vi("renderer closed the MessagePort")
					}),
					i.start(),
					e({ onMessage: s.event, send: (a) => i.postMessage(a.buffer) })
			}
			process.parentPort.on("message", (r) => n(r.ports))
		})
	if (o.type === 2)
		return new Promise((e, t) => {
			let n = null,
				r = setTimeout(() => {
					Vi("VSCODE_EXTHOST_IPC_SOCKET timeout")
				}, 6e4),
				i = 108e5,
				s = 3e5,
				a = new mf(() => Vi("renderer disconnected for too long (1)"), i),
				l = new mf(() => Vi("renderer disconnected for too long (2)"), s)
			process.on("message", (c, u) => {
				if (c && c.type === "VSCODE_EXTHOST_IPC_SOCKET") {
					u.setNoDelay(!0)
					let m = z.wrap(Buffer.from(c.initialDataChunk, "base64")),
						f
					if (c.skipWebSocketFrames) f = new ts(u, "extHost-socket")
					else {
						let h = z.wrap(Buffer.from(c.inflateBytes, "base64"))
						f = new Qv(new ts(u, "extHost-socket"), c.permessageDeflate, h, !1)
					}
					n
						? (gt.logOutgoing(0, 0, 0, "Reconnection case"),
							a.cancel(),
							l.cancel(),
							n.beginAcceptReconnection(f, m),
							n.endAcceptReconnection(),
							n.sendResume())
						: (gt.logOutgoing(0, 0, 0, "New connection case"),
							clearTimeout(r),
							(n = new Nl({ socket: f, initialChunk: m })),
							n.sendResume(),
							n.onDidDispose(() => Vi("renderer disconnected")),
							e(n),
							n.onSocketClose(() => {
								a.schedule()
							}))
				}
				if (c && c.type === "VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME") {
					if ((gt.logOutgoing(0, 0, 0, "Reduce grace time case"), l.isScheduled())) return
					a.isScheduled() && l.schedule()
				}
			})
			let d = { type: "VSCODE_EXTHOST_IPC_READY" }
			process.send?.(d)
		})
	{
		let e = o.pipeName
		return new Promise((t, n) => {
			let r = qU.createConnection(e, () => {
				r.removeListener("error", n)
				let i = new Nl({ socket: new ts(r, "extHost-renderer") })
				i.sendResume(), t(i)
			})
			r.once("error", n),
				r.on("close", () => {
					Vi("renderer closed the socket")
				})
		})
	}
}
async function C6() {
	let o = await x6()
	return new (class {
		constructor() {
			this._onMessage = new ui()
			this.onMessage = this._onMessage.event
			;(this._terminating = !1),
				(this._protocolListener = o.onMessage((e) => {
					t2(e, 2)
						? ((this._terminating = !0),
							this._protocolListener.dispose(),
							Vi("received terminate message from renderer"))
						: this._onMessage.fire(e)
				}))
		}
		send(e) {
			this._terminating || o.send(e)
		}
		async drain() {
			if (o.drain) return o.drain()
		}
	})()
}
function S6(o) {
	return new Promise((e) => {
		let t = o.onMessage((n) => {
			t.dispose()
			let r = JSON.parse(n.toString()),
				i = r.commit,
				s = nb.commit
			if ((i && s && i !== s && LT(55), r.parentPid)) {
				let a = 0
				setInterval(function () {
					try {
						process.kill(r.parentPid, 0), (a = 0)
					} catch (d) {
						d && d.code === "EPERM"
							? (a++,
								a >= 3 &&
									Vi(
										`parent process ${r.parentPid} does not exist anymore (3 x EPERM): ${d.message} (code: ${d.code}) (errno: ${d.errno})`,
									))
							: Vi(
									`parent process ${r.parentPid} does not exist anymore: ${d.message} (code: ${d.code}) (errno: ${d.errno})`,
								)
					}
				}, 1e3)
				let l
				try {
					;(l = KU("native-watchdog")), l.start(r.parentPid)
				} catch (d) {
					Be(d)
				}
			}
			console.log("send initialized message"), o.send(wk(0)), e({ protocol: o, initData: r })
		})
		console.log("send ready message"), o.send(wk(1))
	})
}
async function T6() {
	let o = []
	process.on("unhandledRejection", (a, l) => {
		o.push(l),
			setTimeout(() => {
				let d = o.indexOf(l)
				d >= 0 &&
					l.catch((c) => {
						o.splice(d, 1),
							bn(c) ||
								(console.warn(`rejected promise not handled within 1 second: ${c}`),
								c && c.stack && console.warn(`stack trace: ${c.stack}`),
								a && Be(a))
					})
			}, 1e3)
	}),
		process.on("rejectionHandled", (a) => {
			let l = o.indexOf(a)
			l >= 0 && o.splice(l, 1)
		}),
		process.on("uncaughtException", function (a) {
			T0(a) || Be(a)
		}),
		Ct("code/extHost/willConnectToRenderer")
	let e = await C6()
	Ct("code/extHost/didConnectToRenderer")
	let t = await S6(e)
	Ct("code/extHost/didWaitForInitData")
	let { initData: n } = t
	I6(!!n.environment.extensionTestsLocationURI),
		(n.environment.useHostProxy = OT.useHostProxy !== void 0 ? OT.useHostProxy !== "false" : void 0),
		(n.environment.skipWorkspaceStorageLock = re(OT.skipWorkspaceStorageLock, !1))
	let r = new (class {
			constructor() {
				this.pid = process.pid
			}
			exit(l) {
				LT(l)
			}
			fsExists(l) {
				return Qe.exists(l)
			}
			fsRealpath(l) {
				return Vv(l)
			}
		})(),
		i = null
	n.remote.authority && OT.transformURIs && (i = v2(n.remote.authority))
	let s = new Gx(t.protocol, n, r, i)
	Vi = (a) => s.terminate(a)
}
function E6() {
	T6().catch((o) => console.log(o))
}
var jU = E6
var gt = new sa("extension"),
	$h = process.argv.slice(2)
console.log("args:", $h)
var v0 = $h.includes("--listen") || process.env.VSCODE_EXTHOST_LISTEN === "true",
	Bh = parseInt(
		$h.find((o) => o.startsWith("--vscode-socket-port="))?.substring(21) ||
			process.env.VSCODE_EXTHOST_DEBUG_PORT ||
			"51234",
		10,
	),
	QU =
		$h.find((o) => o.startsWith("--vscode-socket-host="))?.substring(21) ||
		process.env.VSCODE_EXTHOST_SOCKET_HOST ||
		"127.0.0.1",
	JU =
		$h.find((o) => o.startsWith("--vscode-will-send-socket="))?.substring(26) ||
		process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET ||
		"0",
	XU = process.env.VSCODE_EXTHOST_IPC_HOOK
console.log(`Extension host starting in ${v0 ? "LISTEN" : "CONNECT"} mode`)
console.log("PORT:", Bh)
console.log("SOCKET_HOST:", QU)
console.log("WILL_SEND_SOCKET:", JU)
console.log("pipeName:", XU)
if (XU) console.log("Using pipeName, connection will be handled by VSCode IPC")
else {
	let a = function () {
			let c = GU.createServer((m) => {
					console.log("Main process connected to extension host"), m.setNoDelay(!0)
					let f = {
						type: "VSCODE_EXTHOST_IPC_SOCKET",
						initialDataChunk: "",
						skipWebSocketFrames: !0,
						permessageDeflate: !1,
						inflateBytes: "",
					}
					t.forEach((h) => {
						try {
							h(f, m)
						} catch (g) {
							console.error("Error in message handler:", g)
						}
					}),
						m.on("error", (h) => {
							console.error("Socket error:", h), gt.logOutgoing(0, 0, 0, "Socket error:", h)
						}),
						m.on("close", () => {
							console.log("Client connection closed, waiting for new connections..."),
								gt.logOutgoing(0, 0, 0, "Client connection closed, waiting for new connections...")
						})
				}),
				u = setInterval(() => {
					c.listening && console.log("Server still waiting for connections...")
				}, 6e4)
			process.on("exit", () => {
				clearInterval(u)
			}),
				c.listen(Bh, "127.0.0.1", () => {
					console.log(`Extension host server listening on 127.0.0.1:${Bh}`),
						console.log("Waiting for main process to connect...")
				}),
				c.on("error", (m) => {
					console.error("Server error:", m),
						gt.logOutgoing(0, 0, 0, "Server error:", m),
						setTimeout(() => {
							if (!c.listening) {
								console.log("Attempting to restart server after error...")
								try {
									c.listen(Bh, "127.0.0.1")
								} catch (f) {
									console.error("Failed to restart server:", f)
								}
							}
						}, 5e3)
				})
		},
		l = function () {
			if (n) {
				console.log("Already in reconnection process, skipping")
				return
			}
			try {
				let c = process.env.VSCODE_EXTHOST_SOCKET_HOST || "127.0.0.1",
					u = parseInt(process.env.VSCODE_EXTHOST_SOCKET_PORT || "0", 10)
				if (!u) throw new Error("Invalid socket port")
				console.log(`Attempting to connect to ${c}:${u}`)
				let m = GU.createConnection(u, c)
				m.setNoDelay(!0),
					m.on("connect", () => {
						console.log("Connected to main server"), (n = !1), (r = 0)
						let f = {
							type: "VSCODE_EXTHOST_IPC_SOCKET",
							initialDataChunk: "",
							skipWebSocketFrames: !0,
							permessageDeflate: !1,
							inflateBytes: "",
						}
						t.forEach((h) => {
							try {
								h(f, m)
							} catch (g) {
								console.error("Error in message handler:", g)
							}
						})
					}),
					m.on("error", (f) => {
						console.error("Socket connection error:", f),
							gt.logOutgoing(0, 0, 0, "Socket connection error:", f),
							d()
					}),
					m.on("close", () => {
						console.log("Socket connection closed"), d()
					})
			} catch (c) {
				console.error("Connection error:", c), gt.logOutgoing(0, 0, 0, "Connection error:", c), d()
			}
		}
	;(process.env.VSCODE_EXTHOST_SOCKET_PORT = Bh.toString()),
		(process.env.VSCODE_EXTHOST_SOCKET_HOST = QU),
		(process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET = JU),
		console.log("set send socket:", process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET)
	let o = process.on,
		e = process.send || (() => !1),
		t = [],
		n = !1,
		r = 0,
		i = 5,
		s = 1e3
	;(process.on = function (c, u) {
		return (
			c === "message" &&
				t.push((m, f) => {
					u.length === 1 ? u(m) : u(m, f)
				}),
			o.call(process, c, u)
		)
	}),
		(process.send = function (c) {
			return (
				c?.type === "VSCODE_EXTHOST_IPC_READY" &&
					(console.log("Extension host process is ready to receive socket"), v0 ? a() : l()),
				e.call(process, c)
			)
		})
	async function d() {
		if (n) {
			console.log("Already in reconnection process, skipping"),
				gt.logOutgoing(0, 0, 0, "Already in reconnection process, skipping")
			return
		}
		if (r >= i) {
			console.error("Max reconnection attempts reached. Giving up."),
				gt.logOutgoing(0, 0, 0, "Max reconnection attempts reached. Giving up.")
			return
		}
		;(n = !0),
			r++,
			console.log(`Attempting to reconnect (attempt ${r}/${i})...`),
			console.log(`Waiting ${s}ms before reconnecting...`),
			await new Promise((c) => setTimeout(c, s)),
			console.log("Reconnection delay finished, attempting to connect..."),
			(n = !1),
			l()
	}
}
console.log("Starting extension host process...")
v0 && (process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET = "1")
jU()
export { gt as fileLoggerGlobal }
