var W0 = Object.defineProperty
var OH = Object.getOwnPropertyDescriptor
var V0 = (o) => {
	throw TypeError(o)
}
var LH = (o, e) => {
	for (var t in e) W0(o, t, { get: e[t], enumerable: !0 })
}
var R = (o, e, t, n) => {
		for (var r = n > 1 ? void 0 : n ? OH(e, t) : e, i = o.length - 1, s; i >= 0; i--)
			(s = o[i]) && (r = (n ? s(e, t, r) : s(r)) || r)
		return n && r && W0(e, t, r), r
	},
	S = (o, e) => (t, n) => e(t, n, o)
var YT = (o, e, t) => e.has(o) || V0("Cannot " + t)
var sn = (o, e, t) => (YT(o, e, "read from private field"), t ? t.call(o) : e.get(o)),
	Ym = (o, e, t) =>
		e.has(o)
			? V0("Cannot add the same private member more than once")
			: e instanceof WeakSet
				? e.add(o)
				: e.set(o, t),
	sv = (o, e, t, n) => (YT(o, e, "write to private field"), n ? n.call(o, t) : e.set(o, t), t),
	Zm = (o, e, t) => (YT(o, e, "access private method"), t)
import { fork as n3 } from "child_process"
import * as ic from "path"
import { fileURLToPath as r3 } from "url"
import * as vH from "net"
var kt = class {
	constructor(e) {
		this.executor = e
		this._didRun = !1
	}
	get hasValue() {
		return this._didRun
	}
	get value() {
		if (!this._didRun)
			try {
				this._value = this.executor()
			} catch (e) {
				this._error = e
			} finally {
				this._didRun = !0
			}
		if (this._error) throw this._error
		return this._value
	}
	get rawValue() {
		return this._value
	}
}
var ZT = class {
		constructor() {
			;(this.listeners = []),
				(this.unexpectedErrorHandler = function (e) {
					setTimeout(() => {
						throw e.stack
							? jn.isErrorNoTelemetry(e)
								? new jn(
										e.message +
											`

` +
											e.stack,
									)
								: new Error(
										e.message +
											`

` +
											e.stack,
									)
							: e
					}, 0)
				})
		}
		addListener(e) {
			return (
				this.listeners.push(e),
				() => {
					this._removeListener(e)
				}
			)
		}
		emit(e) {
			this.listeners.forEach((t) => {
				t(e)
			})
		}
		_removeListener(e) {
			this.listeners.splice(this.listeners.indexOf(e), 1)
		}
		setUnexpectedErrorHandler(e) {
			this.unexpectedErrorHandler = e
		}
		getUnexpectedErrorHandler() {
			return this.unexpectedErrorHandler
		}
		onUnexpectedError(e) {
			this.unexpectedErrorHandler(e), this.emit(e)
		}
		onUnexpectedExternalError(e) {
			this.unexpectedErrorHandler(e)
		}
	},
	cc = new ZT()
function ef(o) {
	cc.setUnexpectedErrorHandler(o)
}
function B0(o) {
	if (!o || typeof o != "object") return !1
	let e = o
	return e.code === "EPIPE" && e.syscall?.toUpperCase() === "WRITE"
}
function kl(o) {
	cc.onUnexpectedError(o)
}
function Be(o) {
	bn(o) || cc.onUnexpectedError(o)
}
function dv(o) {
	bn(o) || cc.onUnexpectedExternalError(o)
}
function Do(o) {
	if (o instanceof Error) {
		let { name: e, message: t, cause: n } = o,
			r = o.stacktrace || o.stack
		return {
			$isError: !0,
			name: e,
			message: t,
			stack: r,
			noTelemetry: jn.isErrorNoTelemetry(o),
			cause: n ? Do(n) : void 0,
			code: o.code,
		}
	}
	return o
}
function tf(o) {
	let e
	return (
		o.noTelemetry ? (e = new jn()) : ((e = new Error()), (e.name = o.name)),
		(e.message = o.message),
		(e.stack = o.stack),
		o.code && (e.code = o.code),
		o.cause && (e.cause = tf(o.cause)),
		e
	)
}
var av = "Canceled"
function bn(o) {
	return o instanceof xt ? !0 : o instanceof Error && o.name === av && o.message === av
}
var xt = class extends Error {
	constructor() {
		super(av), (this.name = this.message)
	}
}
function Ki() {
	let o = new Error(av)
	return (o.name = o.message), o
}
function We(o) {
	return o ? new Error(`Illegal argument: ${o}`) : new Error("Illegal argument")
}
function uc(o) {
	return o ? new Error(`Illegal state: ${o}`) : new Error("Illegal state")
}
var _o = class extends TypeError {
	constructor(e) {
		super(e ? `${e} is read-only and cannot be changed` : "Cannot change read-only property")
	}
}
function nf(o) {
	return o
		? o.message
			? o.message
			: o.stack
				? o.stack.split(`
`)[0]
				: String(o)
		: "Error"
}
var lv = class extends Error {
		constructor(e) {
			super("NotImplemented"), e && (this.message = e)
		}
	},
	Dl = class extends Error {
		constructor(e) {
			super("NotSupported"), e && (this.message = e)
		}
	}
var jn = class o extends Error {
		constructor(e) {
			super(e), (this.name = "CodeExpectedError")
		}
		static fromError(e) {
			if (e instanceof o) return e
			let t = new o()
			return (t.message = e.message), (t.stack = e.stack), t
		}
		static isErrorNoTelemetry(e) {
			return e.name === "CodeExpectedError"
		}
	},
	Gt = class o extends Error {
		constructor(e) {
			super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, o.prototype)
		}
	}
function z0(o, e, t = o.length - 1) {
	let n = MH(o, e, t)
	if (n !== -1) return o[n]
}
function MH(o, e, t = o.length - 1) {
	for (let n = t; n >= 0; n--) {
		let r = o[n]
		if (e(r)) return n
	}
	return -1
}
function FH(o, e, t = 0, n = o.length) {
	let r = t,
		i = n
	for (; r < i; ) {
		let s = Math.floor((r + i) / 2)
		e(o[s]) ? (r = s + 1) : (i = s)
	}
	return r - 1
}
function q0(o, e, t = 0, n = o.length) {
	let r = t,
		i = n
	for (; r < i; ) {
		let s = Math.floor((r + i) / 2)
		e(o[s]) ? (i = s) : (r = s + 1)
	}
	return r
}
var $0 = class o {
	constructor(e) {
		this._array = e
		this._findLastMonotonousLastIdx = 0
	}
	static {
		this.assertInvariants = !1
	}
	findLastMonotonous(e) {
		if (o.assertInvariants) {
			if (this._prevFindLastPredicate) {
				for (let n of this._array)
					if (this._prevFindLastPredicate(n) && !e(n))
						throw new Error(
							"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.",
						)
			}
			this._prevFindLastPredicate = e
		}
		let t = FH(this._array, e, this._findLastMonotonousLastIdx)
		return (this._findLastMonotonousLastIdx = t + 1), t === -1 ? void 0 : this._array[t]
	}
}
function mn(o, e, t = (n, r) => n === r) {
	if (o === e) return !0
	if (!o || !e || o.length !== e.length) return !1
	for (let n = 0, r = o.length; n < r; n++) if (!t(o[n], e[n])) return !1
	return !0
}
function j0(o, e) {
	let t = [],
		n
	for (let r of o.slice(0).sort(e)) !n || e(n[0], r) !== 0 ? ((n = [r]), t.push(n)) : n.push(r)
	return t
}
function eE(o, e, t) {
	let n = []
	function r(a, l, d) {
		if (l === 0 && d.length === 0) return
		let c = n[n.length - 1]
		c && c.start + c.deleteCount === a
			? ((c.deleteCount += l), c.toInsert.push(...d))
			: n.push({ start: a, deleteCount: l, toInsert: d })
	}
	let i = 0,
		s = 0
	for (;;) {
		if (i === o.length) {
			r(i, 0, e.slice(s))
			break
		}
		if (s === e.length) {
			r(i, o.length - i, [])
			break
		}
		let a = o[i],
			l = e[s],
			d = t(a, l)
		d === 0 ? ((i += 1), (s += 1)) : d < 0 ? (r(i, 1, []), (i += 1)) : d > 0 && (r(i, 0, [l]), (s += 1))
	}
	return n
}
function G0(o, e, t) {
	let n = eE(o, e, t),
		r = [],
		i = []
	for (let s of n) r.push(...o.slice(s.start, s.start + s.deleteCount)), i.push(...s.toInsert)
	return { removed: r, added: i }
}
function Q0(o, e, t, n, r) {
	return t === 0
		? Promise.resolve([])
		: new Promise((i, s) => {
				;(async () => {
					let a = o.length,
						l = o.slice(0, t).sort(e)
					for (let d = t, c = Math.min(t + n, a); d < a; d = c, c = Math.min(c + n, a)) {
						if ((d > t && (await new Promise((u) => setTimeout(u))), r && r.isCancellationRequested))
							throw new xt()
						NH(o, e, l, d, c)
					}
					return l
				})().then(i, s)
			})
}
function NH(o, e, t, n, r) {
	for (let i = t.length; n < r; n++) {
		let s = o[n]
		if (e(s, t[i - 1]) < 0) {
			t.pop()
			let a = q0(t, (l) => e(s, l) < 0)
			t.splice(a, 0, s)
		}
	}
}
function Ye(o) {
	return o.filter((e) => !!e)
}
function J0(o) {
	let e = 0
	for (let t = 0; t < o.length; t++) o[t] && ((o[e] = o[t]), (e += 1))
	o.length = e
}
function rf(o) {
	return !Array.isArray(o) || o.length === 0
}
function si(o) {
	return Array.isArray(o) && o.length > 0
}
function ai(o, e = (t) => t) {
	let t = new Set()
	return o.filter((n) => {
		let r = e(n)
		return t.has(r) ? !1 : (t.add(r), !0)
	})
}
function tE(o, e) {
	return o.push(e), () => UH(o, e)
}
function UH(o, e) {
	let t = o.indexOf(e)
	if (t > -1) return o.splice(t, 1), e
}
function nE(o, e) {
	let t
	if (typeof e == "number") {
		let n = e
		t = () => {
			let r = Math.sin(n++) * 179426549
			return r - Math.floor(r)
		}
	} else t = Math.random
	for (let n = o.length - 1; n > 0; n -= 1) {
		let r = Math.floor(t() * (n + 1)),
			i = o[n]
		;(o[n] = o[r]), (o[r] = i)
	}
}
function Rl(o, e) {
	return Array.isArray(o) ? o.map(e) : e(o)
}
function an(o) {
	return Array.isArray(o) ? o : [o]
}
var X0
;((a) => {
	function o(l) {
		return l < 0
	}
	a.isLessThan = o
	function e(l) {
		return l <= 0
	}
	a.isLessThanOrEqual = e
	function t(l) {
		return l > 0
	}
	a.isGreaterThan = t
	function n(l) {
		return l === 0
	}
	;(a.isNeitherLessOrGreaterThan = n), (a.greaterThan = 1), (a.lessThan = -1), (a.neitherLessOrGreaterThan = 0)
})((X0 ||= {}))
function Y0(o, e) {
	return (t, n) => e(o(t), o(n))
}
var Z0 = (o, e) => o - e
var K0 = class o {
	constructor(e) {
		this.iterate = e
	}
	static {
		this.empty = new o((e) => {})
	}
	forEach(e) {
		this.iterate((t) => (e(t), !0))
	}
	toArray() {
		let e = []
		return this.iterate((t) => (e.push(t), !0)), e
	}
	filter(e) {
		return new o((t) => this.iterate((n) => (e(n) ? t(n) : !0)))
	}
	map(e) {
		return new o((t) => this.iterate((n) => t(e(n))))
	}
	some(e) {
		let t = !1
		return this.iterate((n) => ((t = e(n)), !t)), t
	}
	findFirst(e) {
		let t
		return this.iterate((n) => (e(n) ? ((t = n), !1) : !0)), t
	}
	findLast(e) {
		let t
		return this.iterate((n) => (e(n) && (t = n), !0)), t
	}
	findLastMaxBy(e) {
		let t,
			n = !0
		return this.iterate((r) => ((n || X0.isGreaterThan(e(r, t))) && ((n = !1), (t = r)), !0)), t
	}
}
function pc(o, e) {
	let t = Object.create(null)
	for (let n of o) {
		let r = e(n),
			i = t[r]
		i || (i = t[r] = []), i.push(n)
	}
	return t
}
function rE(o, e) {
	let t = [],
		n = []
	for (let r of o) e.has(r) || t.push(r)
	for (let r of e) o.has(r) || n.push(r)
	return { removed: t, added: n }
}
var tA,
	nA,
	eA = class {
		constructor(e, t) {
			this.toKey = t
			this._map = new Map()
			this[tA] = "SetWithKey"
			for (let n of e) this.add(n)
		}
		get size() {
			return this._map.size
		}
		add(e) {
			let t = this.toKey(e)
			return this._map.set(t, e), this
		}
		delete(e) {
			return this._map.delete(this.toKey(e))
		}
		has(e) {
			return this._map.has(this.toKey(e))
		}
		*entries() {
			for (let e of this._map.values()) yield [e, e]
		}
		keys() {
			return this.values()
		}
		*values() {
			for (let e of this._map.values()) yield e
		}
		clear() {
			this._map.clear()
		}
		forEach(e, t) {
			this._map.forEach((n) => e.call(t, n, n, this))
		}
		[((nA = Symbol.iterator), (tA = Symbol.toStringTag), nA)]() {
			return this.values()
		}
	}
function aE(o, e, t) {
	let n = o.get(e)
	return n === void 0 && ((n = t), o.set(e, n)), n
}
var oE = class {
	constructor(e, t) {
		this.uri = e
		this.value = t
	}
}
function WH(o) {
	return Array.isArray(o)
}
var rA,
	ft = class o {
		constructor(e, t) {
			this[rA] = "ResourceMap"
			if (e instanceof o) (this.map = new Map(e.map)), (this.toKey = t ?? o.defaultToKey)
			else if (WH(e)) {
				;(this.map = new Map()), (this.toKey = t ?? o.defaultToKey)
				for (let [n, r] of e) this.set(n, r)
			} else (this.map = new Map()), (this.toKey = e ?? o.defaultToKey)
		}
		static {
			this.defaultToKey = (e) => e.toString()
		}
		set(e, t) {
			return this.map.set(this.toKey(e), new oE(e, t)), this
		}
		get(e) {
			return this.map.get(this.toKey(e))?.value
		}
		has(e) {
			return this.map.has(this.toKey(e))
		}
		get size() {
			return this.map.size
		}
		clear() {
			this.map.clear()
		}
		delete(e) {
			return this.map.delete(this.toKey(e))
		}
		forEach(e, t) {
			typeof t < "u" && (e = e.bind(t))
			for (let [n, r] of this.map) e(r.value, r.uri, this)
		}
		*values() {
			for (let e of this.map.values()) yield e.value
		}
		*keys() {
			for (let e of this.map.values()) yield e.uri
		}
		*entries() {
			for (let e of this.map.values()) yield [e.uri, e.value]
		}
		*[((rA = Symbol.toStringTag), Symbol.iterator)]() {
			for (let [, e] of this.map) yield [e.uri, e.value]
		}
	},
	oA,
	mc = class {
		constructor(e, t) {
			this[oA] = "ResourceSet"
			!e || typeof e == "function"
				? (this._map = new ft(e))
				: ((this._map = new ft(t)), e.forEach(this.add, this))
		}
		get size() {
			return this._map.size
		}
		add(e) {
			return this._map.set(e, e), this
		}
		clear() {
			this._map.clear()
		}
		delete(e) {
			return this._map.delete(e)
		}
		forEach(e, t) {
			this._map.forEach((n, r) => e.call(t, r, r, this))
		}
		has(e) {
			return this._map.has(e)
		}
		entries() {
			return this._map.entries()
		}
		keys() {
			return this._map.keys()
		}
		values() {
			return this._map.keys()
		}
		[((oA = Symbol.toStringTag), Symbol.iterator)]() {
			return this.keys()
		}
	}
var iA,
	iE = class {
		constructor() {
			this[iA] = "LinkedMap"
			;(this._map = new Map()), (this._head = void 0), (this._tail = void 0), (this._size = 0), (this._state = 0)
		}
		clear() {
			this._map.clear(), (this._head = void 0), (this._tail = void 0), (this._size = 0), this._state++
		}
		isEmpty() {
			return !this._head && !this._tail
		}
		get size() {
			return this._size
		}
		get first() {
			return this._head?.value
		}
		get last() {
			return this._tail?.value
		}
		has(e) {
			return this._map.has(e)
		}
		get(e, t = 0) {
			let n = this._map.get(e)
			if (n) return t !== 0 && this.touch(n, t), n.value
		}
		set(e, t, n = 0) {
			let r = this._map.get(e)
			if (r) (r.value = t), n !== 0 && this.touch(r, n)
			else {
				switch (((r = { key: e, value: t, next: void 0, previous: void 0 }), n)) {
					case 0:
						this.addItemLast(r)
						break
					case 1:
						this.addItemFirst(r)
						break
					case 2:
						this.addItemLast(r)
						break
					default:
						this.addItemLast(r)
						break
				}
				this._map.set(e, r), this._size++
			}
			return this
		}
		delete(e) {
			return !!this.remove(e)
		}
		remove(e) {
			let t = this._map.get(e)
			if (t) return this._map.delete(e), this.removeItem(t), this._size--, t.value
		}
		shift() {
			if (!this._head && !this._tail) return
			if (!this._head || !this._tail) throw new Error("Invalid list")
			let e = this._head
			return this._map.delete(e.key), this.removeItem(e), this._size--, e.value
		}
		forEach(e, t) {
			let n = this._state,
				r = this._head
			for (; r; ) {
				if ((t ? e.bind(t)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== n))
					throw new Error("LinkedMap got modified during iteration.")
				r = r.next
			}
		}
		keys() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: n.key, done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		values() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: n.value, done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		entries() {
			let e = this,
				t = this._state,
				n = this._head,
				r = {
					[Symbol.iterator]() {
						return r
					},
					next() {
						if (e._state !== t) throw new Error("LinkedMap got modified during iteration.")
						if (n) {
							let i = { value: [n.key, n.value], done: !1 }
							return (n = n.next), i
						} else return { value: void 0, done: !0 }
					},
				}
			return r
		}
		[((iA = Symbol.toStringTag), Symbol.iterator)]() {
			return this.entries()
		}
		trimOld(e) {
			if (e >= this.size) return
			if (e === 0) {
				this.clear()
				return
			}
			let t = this._head,
				n = this.size
			for (; t && n > e; ) this._map.delete(t.key), (t = t.next), n--
			;(this._head = t), (this._size = n), t && (t.previous = void 0), this._state++
		}
		trimNew(e) {
			if (e >= this.size) return
			if (e === 0) {
				this.clear()
				return
			}
			let t = this._tail,
				n = this.size
			for (; t && n > e; ) this._map.delete(t.key), (t = t.previous), n--
			;(this._tail = t), (this._size = n), t && (t.next = void 0), this._state++
		}
		addItemFirst(e) {
			if (!this._head && !this._tail) this._tail = e
			else if (this._head) (e.next = this._head), (this._head.previous = e)
			else throw new Error("Invalid list")
			;(this._head = e), this._state++
		}
		addItemLast(e) {
			if (!this._head && !this._tail) this._head = e
			else if (this._tail) (e.previous = this._tail), (this._tail.next = e)
			else throw new Error("Invalid list")
			;(this._tail = e), this._state++
		}
		removeItem(e) {
			if (e === this._head && e === this._tail) (this._head = void 0), (this._tail = void 0)
			else if (e === this._head) {
				if (!e.next) throw new Error("Invalid list")
				;(e.next.previous = void 0), (this._head = e.next)
			} else if (e === this._tail) {
				if (!e.previous) throw new Error("Invalid list")
				;(e.previous.next = void 0), (this._tail = e.previous)
			} else {
				let t = e.next,
					n = e.previous
				if (!t || !n) throw new Error("Invalid list")
				;(t.previous = n), (n.next = t)
			}
			;(e.next = void 0), (e.previous = void 0), this._state++
		}
		touch(e, t) {
			if (!this._head || !this._tail) throw new Error("Invalid list")
			if (!(t !== 1 && t !== 2)) {
				if (t === 1) {
					if (e === this._head) return
					let n = e.next,
						r = e.previous
					e === this._tail ? ((r.next = void 0), (this._tail = r)) : ((n.previous = r), (r.next = n)),
						(e.previous = void 0),
						(e.next = this._head),
						(this._head.previous = e),
						(this._head = e),
						this._state++
				} else if (t === 2) {
					if (e === this._tail) return
					let n = e.next,
						r = e.previous
					e === this._head ? ((n.previous = void 0), (this._head = n)) : ((n.previous = r), (r.next = n)),
						(e.next = void 0),
						(e.previous = this._tail),
						(this._tail.next = e),
						(this._tail = e),
						this._state++
				}
			}
		}
		toJSON() {
			let e = []
			return (
				this.forEach((t, n) => {
					e.push([n, t])
				}),
				e
			)
		}
		fromJSON(e) {
			this.clear()
			for (let [t, n] of e) this.set(t, n)
		}
	},
	sE = class extends iE {
		constructor(e, t = 1) {
			super(), (this._limit = e), (this._ratio = Math.min(Math.max(0, t), 1))
		}
		get limit() {
			return this._limit
		}
		set limit(e) {
			;(this._limit = e), this.checkTrim()
		}
		get ratio() {
			return this._ratio
		}
		set ratio(e) {
			;(this._ratio = Math.min(Math.max(0, e), 1)), this.checkTrim()
		}
		get(e, t = 2) {
			return super.get(e, t)
		}
		peek(e) {
			return super.get(e, 0)
		}
		set(e, t) {
			return super.set(e, t, 2), this
		}
		checkTrim() {
			this.size > this._limit && this.trim(Math.round(this._limit * this._ratio))
		}
	},
	ko = class extends sE {
		constructor(e, t = 1) {
			super(e, t)
		}
		trim(e) {
			this.trimOld(e)
		}
		set(e, t) {
			return super.set(e, t), this.checkTrim(), this
		}
	}
var cv = class {
		constructor(e) {
			this._m1 = new Map()
			this._m2 = new Map()
			if (e) for (let [t, n] of e) this.set(t, n)
		}
		clear() {
			this._m1.clear(), this._m2.clear()
		}
		set(e, t) {
			this._m1.set(e, t), this._m2.set(t, e)
		}
		get(e) {
			return this._m1.get(e)
		}
		getKey(e) {
			return this._m2.get(e)
		}
		delete(e) {
			let t = this._m1.get(e)
			return t === void 0 ? !1 : (this._m1.delete(e), this._m2.delete(t), !0)
		}
		forEach(e, t) {
			this._m1.forEach((n, r) => {
				e.call(t, n, r, this)
			})
		}
		keys() {
			return this._m1.keys()
		}
		values() {
			return this._m1.values()
		}
	},
	fc = class {
		constructor() {
			this.map = new Map()
		}
		add(e, t) {
			let n = this.map.get(e)
			n || ((n = new Set()), this.map.set(e, n)), n.add(t)
		}
		delete(e, t) {
			let n = this.map.get(e)
			n && (n.delete(t), n.size === 0 && this.map.delete(e))
		}
		forEach(e, t) {
			let n = this.map.get(e)
			n && n.forEach(t)
		}
		get(e) {
			let t = this.map.get(e)
			return t || new Set()
		}
	}
function ji(o, e) {
	let t = this,
		n = !1,
		r
	return function () {
		if (n) return r
		if (((n = !0), e))
			try {
				r = o.apply(t, arguments)
			} finally {
				e()
			}
		else r = o.apply(t, arguments)
		return r
	}
}
function yn(o, e) {
	if (!o) throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed")
}
function gc(o, e = "Unreachable") {
	throw new Error(e)
}
function hc(o, e = "unexpected state") {
	if (!o) throw typeof e == "string" ? new Gt(`Assertion Failed: ${e}`) : e
}
function of(o) {
	if (!o()) {
		debugger
		o(), Be(new Gt("Assertion Failed"))
	}
}
function we(o) {
	return typeof o == "string"
}
function aA(o) {
	return Array.isArray(o) && o.every((e) => we(e))
}
function dt(o) {
	return typeof o == "object" && o !== null && !Array.isArray(o) && !(o instanceof RegExp) && !(o instanceof Date)
}
function lA(o) {
	let e = Object.getPrototypeOf(Uint8Array)
	return typeof o == "object" && o instanceof e
}
function fn(o) {
	return typeof o == "number" && !isNaN(o)
}
function dA(o) {
	return !!o && typeof o[Symbol.iterator] == "function"
}
function uv(o) {
	return o === !0 || o === !1
}
function vc(o) {
	return typeof o > "u"
}
function or(o) {
	return !bt(o)
}
function bt(o) {
	return vc(o) || o === null
}
function bc(o, e) {
	if (!o) throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type")
}
function Ro(o) {
	return hc(o != null, "Argument is `undefined` or `null`."), o
}
var VH = Object.prototype.hasOwnProperty
function pv(o) {
	if (!dt(o)) return !1
	for (let e in o) if (VH.call(o, e)) return !1
	return !0
}
function cA(o) {
	return typeof o == "function"
}
function uA(o, e) {
	if (we(e)) {
		if (typeof o !== e) throw new Error(`argument does not match constraint: typeof ${e}`)
	} else if (cA(e)) {
		try {
			if (o instanceof e) return
		} catch {}
		if ((!bt(o) && o.constructor === e) || (e.length === 1 && e.call(void 0, o) === !0)) return
		throw new Error(
			"argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true",
		)
	}
}
var Rt
;((L) => {
	function o(A) {
		return A && typeof A == "object" && typeof A[Symbol.iterator] == "function"
	}
	L.is = o
	let e = Object.freeze([])
	function t() {
		return e
	}
	L.empty = t
	function* n(A) {
		yield A
	}
	L.single = n
	function r(A) {
		return o(A) ? A : n(A)
	}
	L.wrap = r
	function i(A) {
		return A || e
	}
	L.from = i
	function* s(A) {
		for (let J = A.length - 1; J >= 0; J--) yield A[J]
	}
	L.reverse = s
	function a(A) {
		return !A || A[Symbol.iterator]().next().done === !0
	}
	L.isEmpty = a
	function l(A) {
		return A[Symbol.iterator]().next().value
	}
	L.first = l
	function d(A, J) {
		let ne = 0
		for (let oe of A) if (J(oe, ne++)) return !0
		return !1
	}
	L.some = d
	function c(A, J) {
		for (let ne of A) if (J(ne)) return ne
	}
	L.find = c
	function* u(A, J) {
		for (let ne of A) J(ne) && (yield ne)
	}
	L.filter = u
	function* m(A, J) {
		let ne = 0
		for (let oe of A) yield J(oe, ne++)
	}
	L.map = m
	function* f(A, J) {
		let ne = 0
		for (let oe of A) yield* J(oe, ne++)
	}
	L.flatMap = f
	function* h(...A) {
		for (let J of A) dA(J) ? yield* J : yield J
	}
	L.concat = h
	function g(A, J, ne) {
		let oe = ne
		for (let Y of A) oe = J(oe, Y)
		return oe
	}
	L.reduce = g
	function I(A) {
		let J = 0
		for (let ne of A) J++
		return J
	}
	L.length = I
	function* C(A, J, ne = A.length) {
		for (
			J < -A.length && (J = 0),
				J < 0 && (J += A.length),
				ne < 0 ? (ne += A.length) : ne > A.length && (ne = A.length);
			J < ne;
			J++
		)
			yield A[J]
	}
	L.slice = C
	function T(A, J = Number.POSITIVE_INFINITY) {
		let ne = []
		if (J === 0) return [ne, A]
		let oe = A[Symbol.iterator]()
		for (let Y = 0; Y < J; Y++) {
			let j = oe.next()
			if (j.done) return [ne, L.empty()]
			ne.push(j.value)
		}
		return [
			ne,
			{
				[Symbol.iterator]() {
					return oe
				},
			},
		]
	}
	L.consume = T
	async function w(A) {
		let J = []
		for await (let ne of A) J.push(ne)
		return Promise.resolve(J)
	}
	L.asyncToArray = w
})((Rt ||= {}))
var BH = !1,
	yc = null
var pA = class o {
	constructor() {
		this.livingDisposables = new Map()
	}
	static {
		this.idx = 0
	}
	getDisposableData(e) {
		let t = this.livingDisposables.get(e)
		return (
			t ||
				((t = { parent: null, source: null, isSingleton: !1, value: e, idx: o.idx++ }),
				this.livingDisposables.set(e, t)),
			t
		)
	}
	trackDisposable(e) {
		let t = this.getDisposableData(e)
		t.source || (t.source = new Error().stack)
	}
	setParent(e, t) {
		let n = this.getDisposableData(e)
		n.parent = t
	}
	markAsDisposed(e) {
		this.livingDisposables.delete(e)
	}
	markAsSingleton(e) {
		this.getDisposableData(e).isSingleton = !0
	}
	getRootParent(e, t) {
		let n = t.get(e)
		if (n) return n
		let r = e.parent ? this.getRootParent(this.getDisposableData(e.parent), t) : e
		return t.set(e, r), r
	}
	getTrackedDisposables() {
		let e = new Map()
		return [...this.livingDisposables.entries()]
			.filter(([, n]) => n.source !== null && !this.getRootParent(n, e).isSingleton)
			.flatMap(([n]) => n)
	}
	computeLeakingDisposables(e = 10, t) {
		let n
		if (t) n = t
		else {
			let l = new Map(),
				d = [...this.livingDisposables.values()].filter(
					(u) => u.source !== null && !this.getRootParent(u, l).isSingleton,
				)
			if (d.length === 0) return
			let c = new Set(d.map((u) => u.value))
			if (((n = d.filter((u) => !(u.parent && c.has(u.parent)))), n.length === 0))
				throw new Error("There are cyclic diposable chains!")
		}
		if (!n) return
		function r(l) {
			function d(u, m) {
				for (; u.length > 0 && m.some((f) => (typeof f == "string" ? f === u[0] : u[0].match(f))); ) u.shift()
			}
			let c = l.source
				.split(
					`
`,
				)
				.map((u) => u.trim().replace("at ", ""))
				.filter((u) => u !== "")
			return (
				d(c, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]), c.reverse()
			)
		}
		let i = new fc()
		for (let l of n) {
			let d = r(l)
			for (let c = 0; c <= d.length; c++)
				i.add(
					d.slice(0, c).join(`
`),
					l,
				)
		}
		n.sort(Y0((l) => l.idx, Z0))
		let s = "",
			a = 0
		for (let l of n.slice(0, e)) {
			a++
			let d = r(l),
				c = []
			for (let u = 0; u < d.length; u++) {
				let m = d[u]
				m = `(shared with ${
					i.get(
						d.slice(0, u + 1).join(`
`),
					).size
				}/${n.length} leaks) at ${m}`
				let h = i.get(
						d.slice(0, u).join(`
`),
					),
					g = pc(
						[...h].map((I) => r(I)[u]),
						(I) => I,
					)
				delete g[d[u]]
				for (let [I, C] of Object.entries(g))
					c.unshift(`    - stacktraces of ${C.length} other leaks continue with ${I}`)
				c.unshift(m)
			}
			s += `


==================== Leaking disposable ${a}/${n.length}: ${l.value.constructor.name} ====================
${c.join(`
`)}
============================================================

`
		}
		return (
			n.length > e &&
				(s += `


... and ${n.length - e} more leaking disposables

`),
			{ leaks: n, details: s }
		)
	}
}
function $H(o) {
	yc = o
}
if (BH) {
	let o = "__is_disposable_tracked__"
	$H(
		new (class {
			trackDisposable(e) {
				let t = new Error("Potentially leaked disposable").stack
				setTimeout(() => {
					e[o] || console.log(t)
				}, 3e3)
			}
			setParent(e, t) {
				if (e && e !== $.None)
					try {
						e[o] = !0
					} catch {}
			}
			markAsDisposed(e) {
				if (e && e !== $.None)
					try {
						e[o] = !0
					} catch {}
			}
			markAsSingleton(e) {}
		})(),
	)
}
function oa(o) {
	return yc?.trackDisposable(o), o
}
function ia(o) {
	yc?.markAsDisposed(o)
}
function sf(o, e) {
	yc?.setParent(o, e)
}
function zH(o, e) {
	if (yc) for (let t of o) yc.setParent(t, e)
}
function mv(o) {
	return typeof o == "object" && o !== null && typeof o.dispose == "function" && o.dispose.length === 0
}
function Nn(o) {
	if (Rt.is(o)) {
		let e = []
		for (let t of o)
			if (t)
				try {
					t.dispose()
				} catch (n) {
					e.push(n)
				}
		if (e.length === 1) throw e[0]
		if (e.length > 1) throw new AggregateError(e, "Encountered errors while disposing of store")
		return Array.isArray(o) ? [] : o
	} else if (o) return o.dispose(), o
}
function fv(...o) {
	let e = q(() => Nn(o))
	return zH(o, e), e
}
function q(o) {
	let e = oa({
		dispose: ji(() => {
			ia(e), o()
		}),
	})
	return e
}
var Q = class o {
		constructor() {
			this._toDispose = new Set()
			this._isDisposed = !1
			oa(this)
		}
		static {
			this.DISABLE_DISPOSED_WARNING = !1
		}
		dispose() {
			this._isDisposed || (ia(this), (this._isDisposed = !0), this.clear())
		}
		get isDisposed() {
			return this._isDisposed
		}
		clear() {
			if (this._toDispose.size !== 0)
				try {
					Nn(this._toDispose)
				} finally {
					this._toDispose.clear()
				}
		}
		add(e) {
			if (!e) return e
			if (e === this) throw new Error("Cannot register a disposable on itself!")
			return (
				sf(e, this),
				this._isDisposed
					? o.DISABLE_DISPOSED_WARNING ||
						console.warn(
							new Error(
								"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!",
							).stack,
						)
					: this._toDispose.add(e),
				e
			)
		}
		delete(e) {
			if (e) {
				if (e === this) throw new Error("Cannot dispose a disposable on itself!")
				this._toDispose.delete(e), e.dispose()
			}
		}
		deleteAndLeak(e) {
			e && this._toDispose.has(e) && (this._toDispose.delete(e), sf(e, null))
		}
	},
	$ = class {
		constructor() {
			this._store = new Q()
			oa(this), sf(this._store, this)
		}
		static {
			this.None = Object.freeze({ dispose() {} })
		}
		dispose() {
			ia(this), this._store.dispose()
		}
		_register(e) {
			if (e === this) throw new Error("Cannot register a disposable on itself!")
			return this._store.add(e)
		}
	},
	kn = class {
		constructor() {
			this._isDisposed = !1
			oa(this)
		}
		get value() {
			return this._isDisposed ? void 0 : this._value
		}
		set value(e) {
			this._isDisposed || e === this._value || (this._value?.dispose(), e && sf(e, this), (this._value = e))
		}
		clear() {
			this.value = void 0
		}
		dispose() {
			;(this._isDisposed = !0), ia(this), this._value?.dispose(), (this._value = void 0)
		}
		clearAndLeak() {
			let e = this._value
			return (this._value = void 0), e && sf(e, null), e
		}
	}
var Br = class {
	constructor() {
		this._store = new Map()
		this._isDisposed = !1
		oa(this)
	}
	dispose() {
		ia(this), (this._isDisposed = !0), this.clearAndDisposeAll()
	}
	clearAndDisposeAll() {
		if (this._store.size)
			try {
				Nn(this._store.values())
			} finally {
				this._store.clear()
			}
	}
	has(e) {
		return this._store.has(e)
	}
	get size() {
		return this._store.size
	}
	get(e) {
		return this._store.get(e)
	}
	set(e, t, n = !1) {
		this._isDisposed &&
			console.warn(
				new Error(
					"Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!",
				).stack,
			),
			n || this._store.get(e)?.dispose(),
			this._store.set(e, t)
	}
	deleteAndDispose(e) {
		this._store.get(e)?.dispose(), this._store.delete(e)
	}
	deleteAndLeak(e) {
		let t = this._store.get(e)
		return this._store.delete(e), t
	}
	keys() {
		return this._store.keys()
	}
	values() {
		return this._store.values()
	}
	[Symbol.iterator]() {
		return this._store[Symbol.iterator]()
	}
}
function Al(o, e) {
	return new lE(o, e)
}
var lE = class {
	constructor(e, t) {
		this.reducer = e
		this.options = t
		this.state = { flowing: !1, ended: !1, destroyed: !1 }
		this.buffer = { data: [], error: [] }
		this.listeners = { data: [], error: [], end: [] }
		this.pendingWritePromises = []
	}
	pause() {
		this.state.destroyed || (this.state.flowing = !1)
	}
	resume() {
		this.state.destroyed ||
			this.state.flowing ||
			((this.state.flowing = !0), this.flowData(), this.flowErrors(), this.flowEnd())
	}
	write(e) {
		if (!this.state.destroyed) {
			if (this.state.flowing) this.emitData(e)
			else if (
				(this.buffer.data.push(e),
				typeof this.options?.highWaterMark == "number" && this.buffer.data.length > this.options.highWaterMark)
			)
				return new Promise((t) => this.pendingWritePromises.push(t))
		}
	}
	error(e) {
		this.state.destroyed || (this.state.flowing ? this.emitError(e) : this.buffer.error.push(e))
	}
	end(e) {
		this.state.destroyed ||
			(typeof e < "u" && this.write(e),
			this.state.flowing ? (this.emitEnd(), this.destroy()) : (this.state.ended = !0))
	}
	emitData(e) {
		this.listeners.data.slice(0).forEach((t) => t(e))
	}
	emitError(e) {
		this.listeners.error.length === 0 ? Be(e) : this.listeners.error.slice(0).forEach((t) => t(e))
	}
	emitEnd() {
		this.listeners.end.slice(0).forEach((e) => e())
	}
	on(e, t) {
		if (!this.state.destroyed)
			switch (e) {
				case "data":
					this.listeners.data.push(t), this.resume()
					break
				case "end":
					this.listeners.end.push(t), this.state.flowing && this.flowEnd() && this.destroy()
					break
				case "error":
					this.listeners.error.push(t), this.state.flowing && this.flowErrors()
					break
			}
	}
	removeListener(e, t) {
		if (this.state.destroyed) return
		let n
		switch (e) {
			case "data":
				n = this.listeners.data
				break
			case "end":
				n = this.listeners.end
				break
			case "error":
				n = this.listeners.error
				break
		}
		if (n) {
			let r = n.indexOf(t)
			r >= 0 && n.splice(r, 1)
		}
	}
	flowData() {
		if (this.buffer.data.length === 0) return
		if (typeof this.reducer == "function") {
			let t = this.reducer(this.buffer.data)
			this.emitData(t)
		} else for (let t of this.buffer.data) this.emitData(t)
		this.buffer.data.length = 0
		let e = [...this.pendingWritePromises]
		;(this.pendingWritePromises.length = 0), e.forEach((t) => t())
	}
	flowErrors() {
		if (this.listeners.error.length > 0) {
			for (let e of this.buffer.error) this.emitError(e)
			this.buffer.error.length = 0
		}
	}
	flowEnd() {
		return this.state.ended ? (this.emitEnd(), this.listeners.end.length > 0) : !1
	}
	destroy() {
		this.state.destroyed ||
			((this.state.destroyed = !0),
			(this.state.ended = !0),
			(this.buffer.data.length = 0),
			(this.buffer.error.length = 0),
			(this.listeners.data.length = 0),
			(this.listeners.error.length = 0),
			(this.listeners.end.length = 0),
			(this.pendingWritePromises.length = 0))
	}
}
function mA(o, e) {
	let t = [],
		n
	for (; (n = o.read()) !== null; ) t.push(n)
	return e(t)
}
function gv(o, e) {
	return new Promise((t, n) => {
		let r = []
		hv(o, {
			onData: (i) => {
				e && r.push(i)
			},
			onError: (i) => {
				e ? n(i) : t(void 0)
			},
			onEnd: () => {
				t(e ? e(r) : void 0)
			},
		})
	})
}
function hv(o, e, t) {
	o.on("error", (n) => {
		t?.isCancellationRequested || e.onError(n)
	}),
		o.on("end", () => {
			t?.isCancellationRequested || e.onEnd()
		}),
		o.on("data", (n) => {
			t?.isCancellationRequested || e.onData(n)
		})
}
function fA(o, e) {
	let t = Al(e)
	return t.end(o), t
}
function gA(o, e, t) {
	let n = Al(t)
	return (
		hv(o, {
			onData: (r) => n.write(e.data(r)),
			onError: (r) => n.error(e.error ? e.error(r) : r),
			onEnd: () => n.end(),
		}),
		n
	)
}
var vv = typeof Buffer < "u",
	KH = new kt(() => new Uint8Array(256)),
	dE,
	cE,
	z = class o {
		static alloc(e) {
			return vv ? new o(Buffer.allocUnsafe(e)) : new o(new Uint8Array(e))
		}
		static wrap(e) {
			return vv && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new o(e)
		}
		static fromString(e, t) {
			return !(t?.dontUseNodeBuffer || !1) && vv
				? new o(Buffer.from(e))
				: (dE || (dE = new TextEncoder()), new o(dE.encode(e)))
		}
		static fromByteArray(e) {
			let t = o.alloc(e.length)
			for (let n = 0, r = e.length; n < r; n++) t.buffer[n] = e[n]
			return t
		}
		static concat(e, t) {
			if (typeof t > "u") {
				t = 0
				for (let i = 0, s = e.length; i < s; i++) t += e[i].byteLength
			}
			let n = o.alloc(t),
				r = 0
			for (let i = 0, s = e.length; i < s; i++) {
				let a = e[i]
				n.set(a, r), (r += a.byteLength)
			}
			return n
		}
		constructor(e) {
			;(this.buffer = e), (this.byteLength = this.buffer.byteLength)
		}
		clone() {
			let e = o.alloc(this.byteLength)
			return e.set(this), e
		}
		toString() {
			return vv ? this.buffer.toString() : (cE || (cE = new TextDecoder()), cE.decode(this.buffer))
		}
		slice(e, t) {
			return new o(this.buffer.subarray(e, t))
		}
		set(e, t) {
			if (e instanceof o) this.buffer.set(e.buffer, t)
			else if (e instanceof Uint8Array) this.buffer.set(e, t)
			else if (e instanceof ArrayBuffer) this.buffer.set(new Uint8Array(e), t)
			else if (ArrayBuffer.isView(e)) this.buffer.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t)
			else throw new Error("Unknown argument 'array'")
		}
		readUInt32BE(e) {
			return af(this.buffer, e)
		}
		writeUInt32BE(e, t) {
			lf(this.buffer, e, t)
		}
		readUInt32LE(e) {
			return jH(this.buffer, e)
		}
		writeUInt32LE(e, t) {
			GH(this.buffer, e, t)
		}
		readUInt8(e) {
			return QH(this.buffer, e)
		}
		writeUInt8(e, t) {
			JH(this.buffer, e, t)
		}
		indexOf(e, t = 0) {
			return uE(this.buffer, e instanceof o ? e.buffer : e, t)
		}
		equals(e) {
			return this === e
				? !0
				: this.byteLength !== e.byteLength
					? !1
					: this.buffer.every((t, n) => t === e.buffer[n])
		}
	}
function uE(o, e, t = 0) {
	let n = e.byteLength,
		r = o.byteLength
	if (n === 0) return 0
	if (n === 1) return o.indexOf(e[0])
	if (n > r - t) return -1
	let i = KH.value
	i.fill(e.length)
	for (let d = 0; d < e.length; d++) i[e[d]] = e.length - d - 1
	let s = t + e.length - 1,
		a = s,
		l = -1
	for (; s < r; )
		if (o[s] === e[a]) {
			if (a === 0) {
				l = s
				break
			}
			s--, a--
		} else (s += Math.max(e.length - a, i[o[s]])), (a = e.length - 1)
	return l
}
function hA(o, e) {
	return ((o[e + 0] << 0) >>> 0) | ((o[e + 1] << 8) >>> 0)
}
function vA(o, e, t) {
	;(o[t + 0] = e & 255), (e = e >>> 8), (o[t + 1] = e & 255)
}
function af(o, e) {
	return o[e] * 2 ** 24 + o[e + 1] * 2 ** 16 + o[e + 2] * 2 ** 8 + o[e + 3]
}
function lf(o, e, t) {
	;(o[t + 3] = e), (e = e >>> 8), (o[t + 2] = e), (e = e >>> 8), (o[t + 1] = e), (e = e >>> 8), (o[t] = e)
}
function jH(o, e) {
	return ((o[e + 0] << 0) >>> 0) | ((o[e + 1] << 8) >>> 0) | ((o[e + 2] << 16) >>> 0) | ((o[e + 3] << 24) >>> 0)
}
function GH(o, e, t) {
	;(o[t + 0] = e & 255),
		(e = e >>> 8),
		(o[t + 1] = e & 255),
		(e = e >>> 8),
		(o[t + 2] = e & 255),
		(e = e >>> 8),
		(o[t + 3] = e & 255)
}
function QH(o, e) {
	return o[e]
}
function JH(o, e, t) {
	o[t] = e
}
function bA(o) {
	return mA(o, (e) => z.concat(e))
}
function yA(o) {
	return gv(o, (e) => z.concat(e))
}
function IA(o) {
	return fA(o, (e) => z.concat(e))
}
function xA(o) {
	return gA(o, { data: (e) => (typeof e == "string" ? z.fromString(e) : z.wrap(e)) }, (e) => z.concat(e))
}
function Ic(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = new Uint8Array(Math.floor((o.length / 4) * 3)),
		i = (a) => {
			switch (t) {
				case 3:
					;(r[n++] = e | a), (t = 0)
					break
				case 2:
					;(r[n++] = e | (a >>> 2)), (e = a << 6), (t = 3)
					break
				case 1:
					;(r[n++] = e | (a >>> 4)), (e = a << 4), (t = 2)
					break
				default:
					;(e = a << 2), (t = 1)
			}
		}
	for (let a = 0; a < o.length; a++) {
		let l = o.charCodeAt(a)
		if (l >= 65 && l <= 90) i(l - 65)
		else if (l >= 97 && l <= 122) i(l - 97 + 26)
		else if (l >= 48 && l <= 57) i(l - 48 + 52)
		else if (l === 43 || l === 45) i(62)
		else if (l === 47 || l === 95) i(63)
		else {
			if (l === 61) break
			throw new SyntaxError(`Unexpected base64 character ${o[a]}`)
		}
	}
	let s = n
	for (; t > 0; ) i(0)
	return z.wrap(r).slice(0, s)
}
var XH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	YH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
function Ol({ buffer: o }, e = !0, t = !1) {
	let n = t ? YH : XH,
		r = "",
		i = o.byteLength % 3,
		s = 0
	for (; s < o.byteLength - i; s += 3) {
		let a = o[s + 0],
			l = o[s + 1],
			d = o[s + 2]
		;(r += n[a >>> 2]),
			(r += n[((a << 4) | (l >>> 4)) & 63]),
			(r += n[((l << 2) | (d >>> 6)) & 63]),
			(r += n[d & 63])
	}
	if (i === 1) {
		let a = o[s + 0]
		;(r += n[a >>> 2]), (r += n[(a << 4) & 63]), e && (r += "==")
	} else if (i === 2) {
		let a = o[s + 0],
			l = o[s + 1]
		;(r += n[a >>> 2]), (r += n[((a << 4) | (l >>> 4)) & 63]), (r += n[(l << 2) & 63]), e && (r += "=")
	}
	return r
}
import { tmpdir as W6 } from "os"
import { createDeflateRaw as V6, createInflateRaw as B6 } from "zlib"
var $t = class o {
		static {
			this.Undefined = new o(void 0)
		}
		constructor(e) {
			;(this.element = e), (this.next = o.Undefined), (this.prev = o.Undefined)
		}
	},
	Ao = class {
		constructor() {
			this._first = $t.Undefined
			this._last = $t.Undefined
			this._size = 0
		}
		get size() {
			return this._size
		}
		isEmpty() {
			return this._first === $t.Undefined
		}
		clear() {
			let e = this._first
			for (; e !== $t.Undefined; ) {
				let t = e.next
				;(e.prev = $t.Undefined), (e.next = $t.Undefined), (e = t)
			}
			;(this._first = $t.Undefined), (this._last = $t.Undefined), (this._size = 0)
		}
		unshift(e) {
			return this._insert(e, !1)
		}
		push(e) {
			return this._insert(e, !0)
		}
		_insert(e, t) {
			let n = new $t(e)
			if (this._first === $t.Undefined) (this._first = n), (this._last = n)
			else if (t) {
				let i = this._last
				;(this._last = n), (n.prev = i), (i.next = n)
			} else {
				let i = this._first
				;(this._first = n), (n.next = i), (i.prev = n)
			}
			this._size += 1
			let r = !1
			return () => {
				r || ((r = !0), this._remove(n))
			}
		}
		shift() {
			if (this._first !== $t.Undefined) {
				let e = this._first.element
				return this._remove(this._first), e
			}
		}
		pop() {
			if (this._last !== $t.Undefined) {
				let e = this._last.element
				return this._remove(this._last), e
			}
		}
		_remove(e) {
			if (e.prev !== $t.Undefined && e.next !== $t.Undefined) {
				let t = e.prev
				;(t.next = e.next), (e.next.prev = t)
			} else
				e.prev === $t.Undefined && e.next === $t.Undefined
					? ((this._first = $t.Undefined), (this._last = $t.Undefined))
					: e.next === $t.Undefined
						? ((this._last = this._last.prev), (this._last.next = $t.Undefined))
						: e.prev === $t.Undefined &&
							((this._first = this._first.next), (this._first.prev = $t.Undefined))
			this._size -= 1
		}
		*[Symbol.iterator]() {
			let e = this._first
			for (; e !== $t.Undefined; ) yield e.element, (e = e.next)
		}
	}
var ZH = globalThis.performance.now.bind(globalThis.performance),
	zt = class o {
		static create(e) {
			return new o(e)
		}
		constructor(e) {
			;(this._now = e === !1 ? Date.now : ZH), (this._startTime = this._now()), (this._stopTime = -1)
		}
		stop() {
			this._stopTime = this._now()
		}
		reset() {
			;(this._startTime = this._now()), (this._stopTime = -1)
		}
		elapsed() {
			return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime
		}
	}
var SA = !1,
	e4 = !1,
	Ee
;((vt) => {
	vt.None = () => $.None
	function e(ae) {
		if (e4) {
			let { onDidAddListener: Z } = ae,
				se = df.create(),
				ee = 0
			ae.onDidAddListener = () => {
				++ee === 2 &&
					(console.warn(
						"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here",
					),
					se.print()),
					Z?.()
			}
		}
	}
	function t(ae, Z) {
		return f(ae, () => {}, 0, void 0, !0, void 0, Z)
	}
	vt.defer = t
	function n(ae) {
		return (Z, se = null, ee) => {
			let fe = !1,
				Ae
			return (
				(Ae = ae(
					(he) => {
						if (!fe) return Ae ? Ae.dispose() : (fe = !0), Z.call(se, he)
					},
					null,
					ee,
				)),
				fe && Ae.dispose(),
				Ae
			)
		}
	}
	vt.once = n
	function r(ae, Z) {
		return vt.once(vt.filter(ae, Z))
	}
	vt.onceIf = r
	function i(ae, Z, se) {
		return u((ee, fe = null, Ae) => ae((he) => ee.call(fe, Z(he)), null, Ae), se)
	}
	vt.map = i
	function s(ae, Z, se) {
		return u(
			(ee, fe = null, Ae) =>
				ae(
					(he) => {
						Z(he), ee.call(fe, he)
					},
					null,
					Ae,
				),
			se,
		)
	}
	vt.forEach = s
	function a(ae, Z, se) {
		return u((ee, fe = null, Ae) => ae((he) => Z(he) && ee.call(fe, he), null, Ae), se)
	}
	vt.filter = a
	function l(ae) {
		return ae
	}
	vt.signal = l
	function d(...ae) {
		return (Z, se = null, ee) => {
			let fe = fv(...ae.map((Ae) => Ae((he) => Z.call(se, he))))
			return m(fe, ee)
		}
	}
	vt.any = d
	function c(ae, Z, se, ee) {
		let fe = se
		return i(ae, (Ae) => ((fe = Z(fe, Ae)), fe), ee)
	}
	vt.reduce = c
	function u(ae, Z) {
		let se,
			ee = {
				onWillAddFirstListener() {
					se = ae(fe.fire, fe)
				},
				onDidRemoveLastListener() {
					se?.dispose()
				},
			}
		Z || e(ee)
		let fe = new E(ee)
		return Z?.add(fe), fe.event
	}
	function m(ae, Z) {
		return Z instanceof Array ? Z.push(ae) : Z && Z.add(ae), ae
	}
	function f(ae, Z, se = 100, ee = !1, fe = !1, Ae, he) {
		let de,
			Et,
			_t,
			Te = 0,
			wn,
			Ft = {
				leakWarningThreshold: Ae,
				onWillAddFirstListener() {
					de = ae((sc) => {
						Te++,
							(Et = Z(Et, sc)),
							ee && !_t && (ro.fire(Et), (Et = void 0)),
							(wn = () => {
								let oi = Et
								;(Et = void 0), (_t = void 0), (!ee || Te > 1) && ro.fire(oi), (Te = 0)
							}),
							typeof se == "number"
								? (clearTimeout(_t), (_t = setTimeout(wn, se)))
								: _t === void 0 && ((_t = 0), queueMicrotask(wn))
					})
				},
				onWillRemoveListener() {
					fe && Te > 0 && wn?.()
				},
				onDidRemoveLastListener() {
					;(wn = void 0), de.dispose()
				},
			}
		he || e(Ft)
		let ro = new E(Ft)
		return he?.add(ro), ro.event
	}
	vt.debounce = f
	function h(ae, Z = 0, se) {
		return vt.debounce(ae, (ee, fe) => (ee ? (ee.push(fe), ee) : [fe]), Z, void 0, !0, void 0, se)
	}
	vt.accumulate = h
	function g(ae, Z = (ee, fe) => ee === fe, se) {
		let ee = !0,
			fe
		return a(
			ae,
			(Ae) => {
				let he = ee || !Z(Ae, fe)
				return (ee = !1), (fe = Ae), he
			},
			se,
		)
	}
	vt.latch = g
	function I(ae, Z, se) {
		return [vt.filter(ae, Z, se), vt.filter(ae, (ee) => !Z(ee), se)]
	}
	vt.split = I
	function C(ae, Z = !1, se = [], ee) {
		let fe = se.slice(),
			Ae = ae((Et) => {
				fe ? fe.push(Et) : de.fire(Et)
			})
		ee && ee.add(Ae)
		let he = () => {
				fe?.forEach((Et) => de.fire(Et)), (fe = null)
			},
			de = new E({
				onWillAddFirstListener() {
					Ae || ((Ae = ae((Et) => de.fire(Et))), ee && ee.add(Ae))
				},
				onDidAddFirstListener() {
					fe && (Z ? setTimeout(he) : he())
				},
				onDidRemoveLastListener() {
					Ae && Ae.dispose(), (Ae = null)
				},
			})
		return ee && ee.add(de), de.event
	}
	vt.buffer = C
	function T(ae, Z) {
		return (ee, fe, Ae) => {
			let he = Z(new L())
			return ae(
				function (de) {
					let Et = he.evaluate(de)
					Et !== w && ee.call(fe, Et)
				},
				void 0,
				Ae,
			)
		}
	}
	vt.chain = T
	let w = Symbol("HaltChainable")
	class L {
		constructor() {
			this.steps = []
		}
		map(Z) {
			return this.steps.push(Z), this
		}
		forEach(Z) {
			return this.steps.push((se) => (Z(se), se)), this
		}
		filter(Z) {
			return this.steps.push((se) => (Z(se) ? se : w)), this
		}
		reduce(Z, se) {
			let ee = se
			return this.steps.push((fe) => ((ee = Z(ee, fe)), ee)), this
		}
		latch(Z = (se, ee) => se === ee) {
			let se = !0,
				ee
			return (
				this.steps.push((fe) => {
					let Ae = se || !Z(fe, ee)
					return (se = !1), (ee = fe), Ae ? fe : w
				}),
				this
			)
		}
		evaluate(Z) {
			for (let se of this.steps) if (((Z = se(Z)), Z === w)) break
			return Z
		}
	}
	function A(ae, Z, se = (ee) => ee) {
		let ee = (...de) => he.fire(se(...de)),
			fe = () => ae.on(Z, ee),
			Ae = () => ae.removeListener(Z, ee),
			he = new E({ onWillAddFirstListener: fe, onDidRemoveLastListener: Ae })
		return he.event
	}
	vt.fromNodeEventEmitter = A
	function J(ae, Z, se = (ee) => ee) {
		let ee = (...de) => he.fire(se(...de)),
			fe = () => ae.addEventListener(Z, ee),
			Ae = () => ae.removeEventListener(Z, ee),
			he = new E({ onWillAddFirstListener: fe, onDidRemoveLastListener: Ae })
		return he.event
	}
	vt.fromDOMEventEmitter = J
	function ne(ae, Z) {
		return new Promise((se) => n(ae)(se, null, Z))
	}
	vt.toPromise = ne
	function oe(ae) {
		let Z = new E()
		return (
			ae
				.then(
					(se) => {
						Z.fire(se)
					},
					() => {
						Z.fire(void 0)
					},
				)
				.finally(() => {
					Z.dispose()
				}),
			Z.event
		)
	}
	vt.fromPromise = oe
	function Y(ae, Z) {
		return ae((se) => Z.fire(se))
	}
	vt.forward = Y
	function j(ae, Z, se) {
		return Z(se), ae((ee) => Z(ee))
	}
	vt.runAndSubscribe = j
	class K {
		constructor(Z, se) {
			this._observable = Z
			this._counter = 0
			this._hasChanged = !1
			let ee = {
				onWillAddFirstListener: () => {
					Z.addObserver(this), this._observable.reportChanges()
				},
				onDidRemoveLastListener: () => {
					Z.removeObserver(this)
				},
			}
			se || e(ee), (this.emitter = new E(ee)), se && se.add(this.emitter)
		}
		beginUpdate(Z) {
			this._counter++
		}
		handlePossibleChange(Z) {}
		handleChange(Z, se) {
			this._hasChanged = !0
		}
		endUpdate(Z) {
			this._counter--,
				this._counter === 0 &&
					(this._observable.reportChanges(),
					this._hasChanged && ((this._hasChanged = !1), this.emitter.fire(this._observable.get())))
		}
	}
	function qe(ae, Z) {
		return new K(ae, Z).emitter.event
	}
	vt.fromObservable = qe
	function Bt(ae) {
		return (Z, se, ee) => {
			let fe = 0,
				Ae = !1,
				he = {
					beginUpdate() {
						fe++
					},
					endUpdate() {
						fe--, fe === 0 && (ae.reportChanges(), Ae && ((Ae = !1), Z.call(se)))
					},
					handlePossibleChange() {},
					handleChange() {
						Ae = !0
					},
				}
			ae.addObserver(he), ae.reportChanges()
			let de = {
				dispose() {
					ae.removeObserver(he)
				},
			}
			return ee instanceof Q ? ee.add(de) : Array.isArray(ee) && ee.push(de), de
		}
	}
	vt.fromObservableLight = Bt
})((Ee ||= {}))
var pE = class o {
		constructor(e) {
			this.listenerCount = 0
			this.invocationCount = 0
			this.elapsedOverall = 0
			this.durations = []
			;(this.name = `${e}_${o._idPool++}`), o.all.add(this)
		}
		static {
			this.all = new Set()
		}
		static {
			this._idPool = 0
		}
		start(e) {
			;(this._stopWatch = new zt()), (this.listenerCount = e)
		}
		stop() {
			if (this._stopWatch) {
				let e = this._stopWatch.elapsed()
				this.durations.push(e),
					(this.elapsedOverall += e),
					(this.invocationCount += 1),
					(this._stopWatch = void 0)
			}
		}
	},
	TA = -1
var mE = class o {
		constructor(e, t, n = (o._idPool++).toString(16).padStart(3, "0")) {
			this._errorHandler = e
			this.threshold = t
			this.name = n
			this._warnCountdown = 0
		}
		static {
			this._idPool = 1
		}
		dispose() {
			this._stacks?.clear()
		}
		check(e, t) {
			let n = this.threshold
			if (n <= 0 || t < n) return
			this._stacks || (this._stacks = new Map())
			let r = this._stacks.get(e.value) || 0
			if ((this._stacks.set(e.value, r + 1), (this._warnCountdown -= 1), this._warnCountdown <= 0)) {
				this._warnCountdown = n * 0.5
				let [i, s] = this.getMostFrequentStack(),
					a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${s}):`
				console.warn(a), console.warn(i)
				let l = new fE(a, i)
				this._errorHandler(l)
			}
			return () => {
				let i = this._stacks.get(e.value) || 0
				this._stacks.set(e.value, i - 1)
			}
		}
		getMostFrequentStack() {
			if (!this._stacks) return
			let e,
				t = 0
			for (let [n, r] of this._stacks) (!e || t < r) && ((e = [n, r]), (t = r))
			return e
		}
	},
	df = class o {
		constructor(e) {
			this.value = e
		}
		static create() {
			let e = new Error()
			return new o(e.stack ?? "")
		}
		print() {
			console.warn(
				this.value
					.split(
						`
`,
					)
					.slice(2).join(`
`),
			)
		}
	},
	fE = class extends Error {
		constructor(e, t) {
			super(e), (this.name = "ListenerLeakError"), (this.stack = t)
		}
	},
	gE = class extends Error {
		constructor(e, t) {
			super(e), (this.name = "ListenerRefusalError"), (this.stack = t)
		}
	},
	t4 = 0,
	xc = class {
		constructor(e) {
			this.value = e
			this.id = t4++
		}
	},
	n4 = 2,
	EA = (o, e) => {
		if (o instanceof xc) e(o)
		else
			for (let t = 0; t < o.length; t++) {
				let n = o[t]
				n && e(n)
			}
	},
	E = class {
		constructor(e) {
			this._size = 0
			;(this._options = e),
				(this._leakageMon =
					TA > 0 || this._options?.leakWarningThreshold
						? new mE(e?.onListenerError ?? Be, this._options?.leakWarningThreshold ?? TA)
						: void 0),
				(this._perfMon = this._options?._profName ? new pE(this._options._profName) : void 0),
				(this._deliveryQueue = this._options?.deliveryQueue)
		}
		dispose() {
			if (!this._disposed) {
				if (
					((this._disposed = !0),
					this._deliveryQueue?.current === this && this._deliveryQueue.reset(),
					this._listeners)
				) {
					if (SA) {
						let e = this._listeners
						queueMicrotask(() => {
							EA(e, (t) => t.stack?.print())
						})
					}
					;(this._listeners = void 0), (this._size = 0)
				}
				this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose()
			}
		}
		get event() {
			return (
				(this._event ??= (e, t, n) => {
					if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
						let l = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`
						console.warn(l)
						let d = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1],
							c = new gE(`${l}. HINT: Stack shows most frequent listener (${d[1]}-times)`, d[0])
						return (this._options?.onListenerError || Be)(c), $.None
					}
					if (this._disposed) return $.None
					t && (e = e.bind(t))
					let r = new xc(e),
						i,
						s
					this._leakageMon &&
						this._size >= Math.ceil(this._leakageMon.threshold * 0.2) &&
						((r.stack = df.create()), (i = this._leakageMon.check(r.stack, this._size + 1))),
						SA && (r.stack = s ?? df.create()),
						this._listeners
							? this._listeners instanceof xc
								? ((this._deliveryQueue ??= new hE()), (this._listeners = [this._listeners, r]))
								: this._listeners.push(r)
							: (this._options?.onWillAddFirstListener?.(this),
								(this._listeners = r),
								this._options?.onDidAddFirstListener?.(this)),
						this._options?.onDidAddListener?.(this),
						this._size++
					let a = q(() => {
						i?.(), this._removeListener(r)
					})
					return n instanceof Q ? n.add(a) : Array.isArray(n) && n.push(a), a
				}),
				this._event
			)
		}
		_removeListener(e) {
			if ((this._options?.onWillRemoveListener?.(this), !this._listeners)) return
			if (this._size === 1) {
				;(this._listeners = void 0), this._options?.onDidRemoveLastListener?.(this), (this._size = 0)
				return
			}
			let t = this._listeners,
				n = t.indexOf(e)
			if (n === -1)
				throw (
					(console.log("disposed?", this._disposed),
					console.log("size?", this._size),
					console.log("arr?", JSON.stringify(this._listeners)),
					new Error("Attempted to dispose unknown listener"))
				)
			this._size--, (t[n] = void 0)
			let r = this._deliveryQueue.current === this
			if (this._size * n4 <= t.length) {
				let i = 0
				for (let s = 0; s < t.length; s++)
					t[s]
						? (t[i++] = t[s])
						: r &&
							i < this._deliveryQueue.end &&
							(this._deliveryQueue.end--, i < this._deliveryQueue.i && this._deliveryQueue.i--)
				t.length = i
			}
		}
		_deliver(e, t) {
			if (!e) return
			let n = this._options?.onListenerError || Be
			if (!n) {
				e.value(t)
				return
			}
			try {
				e.value(t)
			} catch (r) {
				n(r)
			}
		}
		_deliverQueue(e) {
			let t = e.current._listeners
			for (; e.i < e.end; ) this._deliver(t[e.i++], e.value)
			e.reset()
		}
		fire(e) {
			if (
				(this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()),
				this._perfMon?.start(this._size),
				this._listeners)
			)
				if (this._listeners instanceof xc) this._deliver(this._listeners, e)
				else {
					let t = this._deliveryQueue
					t.enqueue(this, e, this._listeners.length), this._deliverQueue(t)
				}
			this._perfMon?.stop()
		}
		hasListeners() {
			return this._size > 0
		}
	}
var hE = class {
		constructor() {
			this.i = -1
			this.end = 0
		}
		enqueue(e, t, n) {
			;(this.i = 0), (this.end = n), (this.current = e), (this.value = t)
		}
		reset() {
			;(this.i = this.end), (this.current = void 0), (this.value = void 0)
		}
	},
	di = class extends E {
		async fireAsync(e, t, n) {
			if (this._listeners)
				for (
					this._asyncDeliveryQueue || (this._asyncDeliveryQueue = new Ao()),
						EA(this._listeners, (r) => this._asyncDeliveryQueue.push([r.value, e]));
					this._asyncDeliveryQueue.size > 0 && !t.isCancellationRequested;

				) {
					let [r, i] = this._asyncDeliveryQueue.shift(),
						s = [],
						a = {
							...i,
							token: t,
							waitUntil: (l) => {
								if (Object.isFrozen(s)) throw new Error("waitUntil can NOT be called asynchronous")
								n && (l = n(l, r)), s.push(l)
							},
						}
					try {
						r(a)
					} catch (l) {
						Be(l)
						continue
					}
					Object.freeze(s),
						await Promise.allSettled(s).then((l) => {
							for (let d of l) d.status === "rejected" && Be(d.reason)
						})
				}
		}
	},
	ci = class extends E {
		constructor(t) {
			super(t)
			this._isPaused = 0
			this._eventQueue = new Ao()
			this._mergeFn = t?.merge
		}
		get isPaused() {
			return this._isPaused !== 0
		}
		pause() {
			this._isPaused++
		}
		resume() {
			if (this._isPaused !== 0 && --this._isPaused === 0)
				if (this._mergeFn) {
					if (this._eventQueue.size > 0) {
						let t = Array.from(this._eventQueue)
						this._eventQueue.clear(), super.fire(this._mergeFn(t))
					}
				} else for (; !this._isPaused && this._eventQueue.size !== 0; ) super.fire(this._eventQueue.shift())
		}
		fire(t) {
			this._size && (this._isPaused !== 0 ? this._eventQueue.push(t) : super.fire(t))
		}
	},
	bv = class extends ci {
		constructor(e) {
			super(e), (this._delay = e.delay ?? 100)
		}
		fire(e) {
			this._handle ||
				(this.pause(),
				(this._handle = setTimeout(() => {
					;(this._handle = void 0), this.resume()
				}, this._delay))),
				super.fire(e)
		}
	}
var yv = class {
	constructor() {
		this.listening = !1
		this.inputEvent = Ee.None
		this.inputEventListener = $.None
		this.emitter = new E({
			onDidAddFirstListener: () => {
				;(this.listening = !0), (this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter))
			},
			onDidRemoveLastListener: () => {
				;(this.listening = !1), this.inputEventListener.dispose()
			},
		})
		this.event = this.emitter.event
	}
	set input(e) {
		;(this.inputEvent = e),
			this.listening &&
				(this.inputEventListener.dispose(), (this.inputEventListener = e(this.emitter.fire, this.emitter)))
	}
	dispose() {
		this.inputEventListener.dispose(), this.emitter.dispose()
	}
}
function vE() {
	return globalThis._VSCODE_NLS_MESSAGES
}
function cf() {
	return globalThis._VSCODE_NLS_LANGUAGE
}
var r4 =
	cf() === "pseudo" ||
	(typeof document < "u" &&
		document.location &&
		typeof document.location.hash == "string" &&
		document.location.hash.indexOf("pseudo=true") >= 0)
function Iv(o, e) {
	let t
	return (
		e.length === 0
			? (t = o)
			: (t = o.replace(/\{(\d+)\}/g, (n, r) => {
					let i = r[0],
						s = e[i],
						a = n
					return (
						typeof s == "string"
							? (a = s)
							: (typeof s == "number" || typeof s == "boolean" || s === void 0 || s === null) &&
								(a = String(s)),
						a
					)
				})),
		r4 && (t = "\uFF3B" + t.replace(/[aouei]/g, "$&$&") + "\uFF3D"),
		t
	)
}
function p(o, e, ...t) {
	return Iv(typeof o == "number" ? wA(o, e) : e, t)
}
function wA(o, e) {
	let t = vE()?.[o]
	if (typeof t != "string") {
		if (typeof e == "string") return e
		throw new Error(`!!! NLS MISSING: ${o} !!!`)
	}
	return t
}
function uf(o, e, ...t) {
	let n
	typeof o == "number" ? (n = wA(o, e)) : (n = e)
	let r = Iv(n, t)
	return { value: r, original: e === n ? r : Iv(e, t) }
}
var ui = "en",
	mf = !1,
	ff = !1,
	pf = !1,
	o4 = !1,
	kA = !1,
	bE = !1,
	i4 = !1,
	yE = !1,
	RA = !1,
	AA = !1,
	xv,
	Cv = ui,
	PA = ui,
	s4,
	Gi,
	Qi = globalThis,
	$r
typeof Qi.vscode < "u" && typeof Qi.vscode.process < "u"
	? ($r = Qi.vscode.process)
	: typeof process < "u" && typeof process?.versions?.node == "string" && ($r = process)
var OA = typeof $r?.versions?.electron == "string",
	a4 = OA && $r?.type === "renderer"
if (typeof $r == "object") {
	;(mf = $r.platform === "win32"),
		(ff = $r.platform === "darwin"),
		(pf = $r.platform === "linux"),
		(o4 = pf && !!$r.env.SNAP && !!$r.env.SNAP_REVISION),
		(i4 = OA),
		(RA = !!$r.env.CI || !!$r.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
		(xv = ui),
		(Cv = ui)
	let o = $r.env.VSCODE_NLS_CONFIG
	if (o)
		try {
			let e = JSON.parse(o)
			;(xv = e.userLocale),
				(PA = e.osLocale),
				(Cv = e.resolvedLanguage || ui),
				(s4 = e.languagePack?.translationsConfigFile)
		} catch {}
	kA = !0
} else
	typeof navigator == "object" && !a4
		? ((Gi = navigator.userAgent),
			(mf = Gi.indexOf("Windows") >= 0),
			(ff = Gi.indexOf("Macintosh") >= 0),
			(yE =
				(Gi.indexOf("Macintosh") >= 0 || Gi.indexOf("iPad") >= 0 || Gi.indexOf("iPhone") >= 0) &&
				!!navigator.maxTouchPoints &&
				navigator.maxTouchPoints > 0),
			(pf = Gi.indexOf("Linux") >= 0),
			(AA = Gi?.indexOf("Mobi") >= 0),
			(bE = !0),
			(Cv = cf() || ui),
			(xv = navigator.language.toLowerCase()),
			(PA = xv))
		: console.error("Unable to resolve platform.")
function IE(o) {
	switch (o) {
		case 0:
			return "Web"
		case 1:
			return "Mac"
		case 2:
			return "Linux"
		case 3:
			return "Windows"
	}
}
var Sv = 0
ff ? (Sv = 1) : mf ? (Sv = 3) : pf && (Sv = 2)
var Ie = mf,
	st = ff,
	Ve = pf
var Tv = kA
var Oo = bE,
	l4 = bE && typeof Qi.importScripts == "function",
	LA = l4 ? Qi.origin : void 0,
	MA = yE,
	FA = AA,
	aa = RA,
	Ev = Sv,
	pi = Gi,
	sa = Cv,
	d4
;((n) => {
	function o() {
		return sa
	}
	n.value = o
	function e() {
		return sa.length === 2 ? sa === "en" : sa.length >= 3 ? sa[0] === "e" && sa[1] === "n" && sa[2] === "-" : !1
	}
	n.isDefaultVariant = e
	function t() {
		return sa === "en"
	}
	n.isDefault = t
})((d4 ||= {}))
var c4 = typeof Qi.postMessage == "function" && !Qi.importScripts,
	wv = (() => {
		if (c4) {
			let o = []
			Qi.addEventListener("message", (t) => {
				if (t.data && t.data.vscodeScheduleAsyncWork)
					for (let n = 0, r = o.length; n < r; n++) {
						let i = o[n]
						if (i.id === t.data.vscodeScheduleAsyncWork) {
							o.splice(n, 1), i.callback()
							return
						}
					}
			})
			let e = 0
			return (t) => {
				let n = ++e
				o.push({ id: n, callback: t }), Qi.postMessage({ vscodeScheduleAsyncWork: n }, "*")
			}
		}
		return (o) => setTimeout(o)
	})()
var Ll = ff || yE ? 2 : mf ? 1 : 3,
	_A = !0,
	DA = !1
function Pv() {
	if (!DA) {
		DA = !0
		let o = new Uint8Array(2)
		;(o[0] = 1), (o[1] = 2), (_A = new Uint16Array(o.buffer)[0] === 513)
	}
	return _A
}
var gf = !!(pi && pi.indexOf("Chrome") >= 0),
	NA = !!(pi && pi.indexOf("Firefox") >= 0),
	UA = !!(!gf && pi && pi.indexOf("Safari") >= 0),
	_v = !!(pi && pi.indexOf("Edg/") >= 0),
	z3 = !!(pi && pi.indexOf("Android") >= 0)
var Ml,
	xE = globalThis.vscode
if (typeof xE < "u" && typeof xE.process < "u") {
	let o = xE.process
	Ml = {
		get platform() {
			return o.platform
		},
		get arch() {
			return o.arch
		},
		get env() {
			return o.env
		},
		cwd() {
			return o.cwd()
		},
	}
} else
	typeof process < "u" && typeof process?.versions?.node == "string"
		? (Ml = {
				get platform() {
					return process.platform
				},
				get arch() {
					return process.arch
				},
				get env() {
					return process.env
				},
				cwd() {
					return process.env.VSCODE_CWD || process.cwd()
				},
			})
		: (Ml = {
				get platform() {
					return Ie ? "win32" : st ? "darwin" : "linux"
				},
				get arch() {},
				get env() {
					return {}
				},
				cwd() {
					return "/"
				},
			})
var Lo = Ml.cwd,
	Pr = Ml.env,
	CE = Ml.platform,
	u4 = Ml.arch
var p4 = 65,
	m4 = 97,
	f4 = 90,
	g4 = 122,
	Fl = 46,
	Hn = 47,
	_r = 92,
	Ji = 58,
	h4 = 63,
	kv = class extends Error {
		constructor(e, t, n) {
			let r
			typeof t == "string" && t.indexOf("not ") === 0
				? ((r = "must not be"), (t = t.replace(/^not /, "")))
				: (r = "must be")
			let i = e.indexOf(".") !== -1 ? "property" : "argument",
				s = `The "${e}" ${i} ${r} of type ${t}`
			;(s += `. Received type ${typeof n}`), super(s), (this.code = "ERR_INVALID_ARG_TYPE")
		}
	}
function v4(o, e) {
	if (o === null || typeof o != "object") throw new kv(e, "Object", o)
}
function ln(o, e) {
	if (typeof o != "string") throw new kv(e, "string", o)
}
var Dr = CE === "win32"
function Ge(o) {
	return o === Hn || o === _r
}
function SE(o) {
	return o === Hn
}
function Xi(o) {
	return (o >= p4 && o <= f4) || (o >= m4 && o <= g4)
}
function Rv(o, e, t, n) {
	let r = "",
		i = 0,
		s = -1,
		a = 0,
		l = 0
	for (let d = 0; d <= o.length; ++d) {
		if (d < o.length) l = o.charCodeAt(d)
		else {
			if (n(l)) break
			l = Hn
		}
		if (n(l)) {
			if (!(s === d - 1 || a === 1))
				if (a === 2) {
					if (
						r.length < 2 ||
						i !== 2 ||
						r.charCodeAt(r.length - 1) !== Fl ||
						r.charCodeAt(r.length - 2) !== Fl
					) {
						if (r.length > 2) {
							let c = r.lastIndexOf(t)
							c === -1
								? ((r = ""), (i = 0))
								: ((r = r.slice(0, c)), (i = r.length - 1 - r.lastIndexOf(t))),
								(s = d),
								(a = 0)
							continue
						} else if (r.length !== 0) {
							;(r = ""), (i = 0), (s = d), (a = 0)
							continue
						}
					}
					e && ((r += r.length > 0 ? `${t}..` : ".."), (i = 2))
				} else r.length > 0 ? (r += `${t}${o.slice(s + 1, d)}`) : (r = o.slice(s + 1, d)), (i = d - s - 1)
			;(s = d), (a = 0)
		} else l === Fl && a !== -1 ? ++a : (a = -1)
	}
	return r
}
function b4(o) {
	return o ? `${o[0] === "." ? "" : "."}${o}` : ""
}
function HA(o, e) {
	v4(e, "pathObject")
	let t = e.dir || e.root,
		n = e.base || `${e.name || ""}${b4(e.ext)}`
	return t ? (t === e.root ? `${t}${n}` : `${t}${o}${n}`) : n
}
var qt = {
		resolve(...o) {
			let e = "",
				t = "",
				n = !1
			for (let r = o.length - 1; r >= -1; r--) {
				let i
				if (r >= 0) {
					if (((i = o[r]), ln(i, `paths[${r}]`), i.length === 0)) continue
				} else
					e.length === 0
						? (i = Lo())
						: ((i = Pr[`=${e}`] || Lo()),
							(i === void 0 ||
								(i.slice(0, 2).toLowerCase() !== e.toLowerCase() && i.charCodeAt(2) === _r)) &&
								(i = `${e}\\`))
				let s = i.length,
					a = 0,
					l = "",
					d = !1,
					c = i.charCodeAt(0)
				if (s === 1) Ge(c) && ((a = 1), (d = !0))
				else if (Ge(c))
					if (((d = !0), Ge(i.charCodeAt(1)))) {
						let u = 2,
							m = u
						for (; u < s && !Ge(i.charCodeAt(u)); ) u++
						if (u < s && u !== m) {
							let f = i.slice(m, u)
							for (m = u; u < s && Ge(i.charCodeAt(u)); ) u++
							if (u < s && u !== m) {
								for (m = u; u < s && !Ge(i.charCodeAt(u)); ) u++
								;(u === s || u !== m) && ((l = `\\\\${f}\\${i.slice(m, u)}`), (a = u))
							}
						}
					} else a = 1
				else
					Xi(c) &&
						i.charCodeAt(1) === Ji &&
						((l = i.slice(0, 2)), (a = 2), s > 2 && Ge(i.charCodeAt(2)) && ((d = !0), (a = 3)))
				if (l.length > 0)
					if (e.length > 0) {
						if (l.toLowerCase() !== e.toLowerCase()) continue
					} else e = l
				if (n) {
					if (e.length > 0) break
				} else if (((t = `${i.slice(a)}\\${t}`), (n = d), d && e.length > 0)) break
			}
			return (t = Rv(t, !n, "\\", Ge)), n ? `${e}\\${t}` : `${e}${t}` || "."
		},
		normalize(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return "."
			let t = 0,
				n,
				r = !1,
				i = o.charCodeAt(0)
			if (e === 1) return SE(i) ? "\\" : o
			if (Ge(i))
				if (((r = !0), Ge(o.charCodeAt(1)))) {
					let a = 2,
						l = a
					for (; a < e && !Ge(o.charCodeAt(a)); ) a++
					if (a < e && a !== l) {
						let d = o.slice(l, a)
						for (l = a; a < e && Ge(o.charCodeAt(a)); ) a++
						if (a < e && a !== l) {
							for (l = a; a < e && !Ge(o.charCodeAt(a)); ) a++
							if (a === e) return `\\\\${d}\\${o.slice(l)}\\`
							a !== l && ((n = `\\\\${d}\\${o.slice(l, a)}`), (t = a))
						}
					}
				} else t = 1
			else
				Xi(i) &&
					o.charCodeAt(1) === Ji &&
					((n = o.slice(0, 2)), (t = 2), e > 2 && Ge(o.charCodeAt(2)) && ((r = !0), (t = 3)))
			let s = t < e ? Rv(o.slice(t), !r, "\\", Ge) : ""
			if (
				(s.length === 0 && !r && (s = "."),
				s.length > 0 && Ge(o.charCodeAt(e - 1)) && (s += "\\"),
				!r && n === void 0 && o.includes(":"))
			) {
				if (s.length >= 2 && Xi(s.charCodeAt(0)) && s.charCodeAt(1) === Ji) return `.\\${s}`
				let a = o.indexOf(":")
				do if (a === e - 1 || Ge(o.charCodeAt(a + 1))) return `.\\${s}`
				while ((a = o.indexOf(":", a + 1)) !== -1)
			}
			return n === void 0 ? (r ? `\\${s}` : s) : r ? `${n}\\${s}` : `${n}${s}`
		},
		isAbsolute(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return !1
			let t = o.charCodeAt(0)
			return Ge(t) || (e > 2 && Xi(t) && o.charCodeAt(1) === Ji && Ge(o.charCodeAt(2)))
		},
		join(...o) {
			if (o.length === 0) return "."
			let e, t
			for (let i = 0; i < o.length; ++i) {
				let s = o[i]
				ln(s, "path"), s.length > 0 && (e === void 0 ? (e = t = s) : (e += `\\${s}`))
			}
			if (e === void 0) return "."
			let n = !0,
				r = 0
			if (typeof t == "string" && Ge(t.charCodeAt(0))) {
				++r
				let i = t.length
				i > 1 && Ge(t.charCodeAt(1)) && (++r, i > 2 && (Ge(t.charCodeAt(2)) ? ++r : (n = !1)))
			}
			if (n) {
				for (; r < e.length && Ge(e.charCodeAt(r)); ) r++
				r >= 2 && (e = `\\${e.slice(r)}`)
			}
			return qt.normalize(e)
		},
		relative(o, e) {
			if ((ln(o, "from"), ln(e, "to"), o === e)) return ""
			let t = qt.resolve(o),
				n = qt.resolve(e)
			if (t === n || ((o = t.toLowerCase()), (e = n.toLowerCase()), o === e)) return ""
			if (t.length !== o.length || n.length !== e.length) {
				let h = t.split("\\"),
					g = n.split("\\")
				h[h.length - 1] === "" && h.pop(), g[g.length - 1] === "" && g.pop()
				let I = h.length,
					C = g.length,
					T = I < C ? I : C,
					w
				for (w = 0; w < T && h[w].toLowerCase() === g[w].toLowerCase(); w++);
				return w === 0
					? n
					: w === T
						? C > T
							? g.slice(w).join("\\")
							: I > T
								? "..\\".repeat(I - 1 - w) + ".."
								: ""
						: "..\\".repeat(I - w) + g.slice(w).join("\\")
			}
			let r = 0
			for (; r < o.length && o.charCodeAt(r) === _r; ) r++
			let i = o.length
			for (; i - 1 > r && o.charCodeAt(i - 1) === _r; ) i--
			let s = i - r,
				a = 0
			for (; a < e.length && e.charCodeAt(a) === _r; ) a++
			let l = e.length
			for (; l - 1 > a && e.charCodeAt(l - 1) === _r; ) l--
			let d = l - a,
				c = s < d ? s : d,
				u = -1,
				m = 0
			for (; m < c; m++) {
				let h = o.charCodeAt(r + m)
				if (h !== e.charCodeAt(a + m)) break
				h === _r && (u = m)
			}
			if (m !== c) {
				if (u === -1) return n
			} else {
				if (d > c) {
					if (e.charCodeAt(a + m) === _r) return n.slice(a + m + 1)
					if (m === 2) return n.slice(a + m)
				}
				s > c && (o.charCodeAt(r + m) === _r ? (u = m) : m === 2 && (u = 3)), u === -1 && (u = 0)
			}
			let f = ""
			for (m = r + u + 1; m <= i; ++m)
				(m === i || o.charCodeAt(m) === _r) && (f += f.length === 0 ? ".." : "\\..")
			return (a += u), f.length > 0 ? `${f}${n.slice(a, l)}` : (n.charCodeAt(a) === _r && ++a, n.slice(a, l))
		},
		toNamespacedPath(o) {
			if (typeof o != "string" || o.length === 0) return o
			let e = qt.resolve(o)
			if (e.length <= 2) return o
			if (e.charCodeAt(0) === _r) {
				if (e.charCodeAt(1) === _r) {
					let t = e.charCodeAt(2)
					if (t !== h4 && t !== Fl) return `\\\\?\\UNC\\${e.slice(2)}`
				}
			} else if (Xi(e.charCodeAt(0)) && e.charCodeAt(1) === Ji && e.charCodeAt(2) === _r) return `\\\\?\\${e}`
			return e
		},
		dirname(o) {
			ln(o, "path")
			let e = o.length
			if (e === 0) return "."
			let t = -1,
				n = 0,
				r = o.charCodeAt(0)
			if (e === 1) return Ge(r) ? o : "."
			if (Ge(r)) {
				if (((t = n = 1), Ge(o.charCodeAt(1)))) {
					let a = 2,
						l = a
					for (; a < e && !Ge(o.charCodeAt(a)); ) a++
					if (a < e && a !== l) {
						for (l = a; a < e && Ge(o.charCodeAt(a)); ) a++
						if (a < e && a !== l) {
							for (l = a; a < e && !Ge(o.charCodeAt(a)); ) a++
							if (a === e) return o
							a !== l && (t = n = a + 1)
						}
					}
				}
			} else Xi(r) && o.charCodeAt(1) === Ji && ((t = e > 2 && Ge(o.charCodeAt(2)) ? 3 : 2), (n = t))
			let i = -1,
				s = !0
			for (let a = e - 1; a >= n; --a)
				if (Ge(o.charCodeAt(a))) {
					if (!s) {
						i = a
						break
					}
				} else s = !1
			if (i === -1) {
				if (t === -1) return "."
				i = t
			}
			return o.slice(0, i)
		},
		basename(o, e) {
			e !== void 0 && ln(e, "suffix"), ln(o, "path")
			let t = 0,
				n = -1,
				r = !0,
				i
			if (
				(o.length >= 2 && Xi(o.charCodeAt(0)) && o.charCodeAt(1) === Ji && (t = 2),
				e !== void 0 && e.length > 0 && e.length <= o.length)
			) {
				if (e === o) return ""
				let s = e.length - 1,
					a = -1
				for (i = o.length - 1; i >= t; --i) {
					let l = o.charCodeAt(i)
					if (Ge(l)) {
						if (!r) {
							t = i + 1
							break
						}
					} else
						a === -1 && ((r = !1), (a = i + 1)),
							s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (n = i) : ((s = -1), (n = a)))
				}
				return t === n ? (n = a) : n === -1 && (n = o.length), o.slice(t, n)
			}
			for (i = o.length - 1; i >= t; --i)
				if (Ge(o.charCodeAt(i))) {
					if (!r) {
						t = i + 1
						break
					}
				} else n === -1 && ((r = !1), (n = i + 1))
			return n === -1 ? "" : o.slice(t, n)
		},
		extname(o) {
			ln(o, "path")
			let e = 0,
				t = -1,
				n = 0,
				r = -1,
				i = !0,
				s = 0
			o.length >= 2 && o.charCodeAt(1) === Ji && Xi(o.charCodeAt(0)) && (e = n = 2)
			for (let a = o.length - 1; a >= e; --a) {
				let l = o.charCodeAt(a)
				if (Ge(l)) {
					if (!i) {
						n = a + 1
						break
					}
					continue
				}
				r === -1 && ((i = !1), (r = a + 1)),
					l === Fl ? (t === -1 ? (t = a) : s !== 1 && (s = 1)) : t !== -1 && (s = -1)
			}
			return t === -1 || r === -1 || s === 0 || (s === 1 && t === r - 1 && t === n + 1) ? "" : o.slice(t, r)
		},
		format: HA.bind(null, "\\"),
		parse(o) {
			ln(o, "path")
			let e = { root: "", dir: "", base: "", ext: "", name: "" }
			if (o.length === 0) return e
			let t = o.length,
				n = 0,
				r = o.charCodeAt(0)
			if (t === 1) return Ge(r) ? ((e.root = e.dir = o), e) : ((e.base = e.name = o), e)
			if (Ge(r)) {
				if (((n = 1), Ge(o.charCodeAt(1)))) {
					let u = 2,
						m = u
					for (; u < t && !Ge(o.charCodeAt(u)); ) u++
					if (u < t && u !== m) {
						for (m = u; u < t && Ge(o.charCodeAt(u)); ) u++
						if (u < t && u !== m) {
							for (m = u; u < t && !Ge(o.charCodeAt(u)); ) u++
							u === t ? (n = u) : u !== m && (n = u + 1)
						}
					}
				}
			} else if (Xi(r) && o.charCodeAt(1) === Ji) {
				if (t <= 2) return (e.root = e.dir = o), e
				if (((n = 2), Ge(o.charCodeAt(2)))) {
					if (t === 3) return (e.root = e.dir = o), e
					n = 3
				}
			}
			n > 0 && (e.root = o.slice(0, n))
			let i = -1,
				s = n,
				a = -1,
				l = !0,
				d = o.length - 1,
				c = 0
			for (; d >= n; --d) {
				if (((r = o.charCodeAt(d)), Ge(r))) {
					if (!l) {
						s = d + 1
						break
					}
					continue
				}
				a === -1 && ((l = !1), (a = d + 1)),
					r === Fl ? (i === -1 ? (i = d) : c !== 1 && (c = 1)) : i !== -1 && (c = -1)
			}
			return (
				a !== -1 &&
					(i === -1 || c === 0 || (c === 1 && i === a - 1 && i === s + 1)
						? (e.base = e.name = o.slice(s, a))
						: ((e.name = o.slice(s, i)), (e.base = o.slice(s, a)), (e.ext = o.slice(i, a)))),
				s > 0 && s !== n ? (e.dir = o.slice(0, s - 1)) : (e.dir = e.root),
				e
			)
		},
		sep: "\\",
		delimiter: ";",
		win32: null,
		posix: null,
	},
	y4 = (() => {
		if (Dr) {
			let o = /\\/g
			return () => {
				let e = Lo().replace(o, "/")
				return e.slice(e.indexOf("/"))
			}
		}
		return () => Lo()
	})(),
	Ue = {
		resolve(...o) {
			let e = "",
				t = !1
			for (let n = o.length - 1; n >= 0 && !t; n--) {
				let r = o[n]
				ln(r, `paths[${n}]`), r.length !== 0 && ((e = `${r}/${e}`), (t = r.charCodeAt(0) === Hn))
			}
			if (!t) {
				let n = y4()
				;(e = `${n}/${e}`), (t = n.charCodeAt(0) === Hn)
			}
			return (e = Rv(e, !t, "/", SE)), t ? `/${e}` : e.length > 0 ? e : "."
		},
		normalize(o) {
			if ((ln(o, "path"), o.length === 0)) return "."
			let e = o.charCodeAt(0) === Hn,
				t = o.charCodeAt(o.length - 1) === Hn
			return (
				(o = Rv(o, !e, "/", SE)),
				o.length === 0 ? (e ? "/" : t ? "./" : ".") : (t && (o += "/"), e ? `/${o}` : o)
			)
		},
		isAbsolute(o) {
			return ln(o, "path"), o.length > 0 && o.charCodeAt(0) === Hn
		},
		join(...o) {
			if (o.length === 0) return "."
			let e = []
			for (let t = 0; t < o.length; ++t) {
				let n = o[t]
				ln(n, "path"), n.length > 0 && e.push(n)
			}
			return e.length === 0 ? "." : Ue.normalize(e.join("/"))
		},
		relative(o, e) {
			if ((ln(o, "from"), ln(e, "to"), o === e || ((o = Ue.resolve(o)), (e = Ue.resolve(e)), o === e))) return ""
			let t = 1,
				n = o.length,
				r = n - t,
				i = 1,
				s = e.length - i,
				a = r < s ? r : s,
				l = -1,
				d = 0
			for (; d < a; d++) {
				let u = o.charCodeAt(t + d)
				if (u !== e.charCodeAt(i + d)) break
				u === Hn && (l = d)
			}
			if (d === a)
				if (s > a) {
					if (e.charCodeAt(i + d) === Hn) return e.slice(i + d + 1)
					if (d === 0) return e.slice(i + d)
				} else r > a && (o.charCodeAt(t + d) === Hn ? (l = d) : d === 0 && (l = 0))
			let c = ""
			for (d = t + l + 1; d <= n; ++d) (d === n || o.charCodeAt(d) === Hn) && (c += c.length === 0 ? ".." : "/..")
			return `${c}${e.slice(i + l)}`
		},
		toNamespacedPath(o) {
			return o
		},
		dirname(o) {
			if ((ln(o, "path"), o.length === 0)) return "."
			let e = o.charCodeAt(0) === Hn,
				t = -1,
				n = !0
			for (let r = o.length - 1; r >= 1; --r)
				if (o.charCodeAt(r) === Hn) {
					if (!n) {
						t = r
						break
					}
				} else n = !1
			return t === -1 ? (e ? "/" : ".") : e && t === 1 ? "//" : o.slice(0, t)
		},
		basename(o, e) {
			e !== void 0 && ln(e, "suffix"), ln(o, "path")
			let t = 0,
				n = -1,
				r = !0,
				i
			if (e !== void 0 && e.length > 0 && e.length <= o.length) {
				if (e === o) return ""
				let s = e.length - 1,
					a = -1
				for (i = o.length - 1; i >= 0; --i) {
					let l = o.charCodeAt(i)
					if (l === Hn) {
						if (!r) {
							t = i + 1
							break
						}
					} else
						a === -1 && ((r = !1), (a = i + 1)),
							s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (n = i) : ((s = -1), (n = a)))
				}
				return t === n ? (n = a) : n === -1 && (n = o.length), o.slice(t, n)
			}
			for (i = o.length - 1; i >= 0; --i)
				if (o.charCodeAt(i) === Hn) {
					if (!r) {
						t = i + 1
						break
					}
				} else n === -1 && ((r = !1), (n = i + 1))
			return n === -1 ? "" : o.slice(t, n)
		},
		extname(o) {
			ln(o, "path")
			let e = -1,
				t = 0,
				n = -1,
				r = !0,
				i = 0
			for (let s = o.length - 1; s >= 0; --s) {
				let a = o[s]
				if (a === "/") {
					if (!r) {
						t = s + 1
						break
					}
					continue
				}
				n === -1 && ((r = !1), (n = s + 1)),
					a === "." ? (e === -1 ? (e = s) : i !== 1 && (i = 1)) : e !== -1 && (i = -1)
			}
			return e === -1 || n === -1 || i === 0 || (i === 1 && e === n - 1 && e === t + 1) ? "" : o.slice(e, n)
		},
		format: HA.bind(null, "/"),
		parse(o) {
			ln(o, "path")
			let e = { root: "", dir: "", base: "", ext: "", name: "" }
			if (o.length === 0) return e
			let t = o.charCodeAt(0) === Hn,
				n
			t ? ((e.root = "/"), (n = 1)) : (n = 0)
			let r = -1,
				i = 0,
				s = -1,
				a = !0,
				l = o.length - 1,
				d = 0
			for (; l >= n; --l) {
				let c = o.charCodeAt(l)
				if (c === Hn) {
					if (!a) {
						i = l + 1
						break
					}
					continue
				}
				s === -1 && ((a = !1), (s = l + 1)),
					c === Fl ? (r === -1 ? (r = l) : d !== 1 && (d = 1)) : r !== -1 && (d = -1)
			}
			if (s !== -1) {
				let c = i === 0 && t ? 1 : i
				r === -1 || d === 0 || (d === 1 && r === s - 1 && r === i + 1)
					? (e.base = e.name = o.slice(c, s))
					: ((e.name = o.slice(c, r)), (e.base = o.slice(c, s)), (e.ext = o.slice(r, s)))
			}
			return i > 0 ? (e.dir = o.slice(0, i - 1)) : t && (e.dir = "/"), e
		},
		sep: "/",
		delimiter: ":",
		win32: null,
		posix: null,
	}
Ue.win32 = qt.win32 = qt
Ue.posix = qt.posix = Ue
var Gn = Dr ? qt.normalize : Ue.normalize,
	In = Dr ? qt.isAbsolute : Ue.isAbsolute,
	Fe = Dr ? qt.join : Ue.join,
	WA = Dr ? qt.resolve : Ue.resolve,
	Mo = Dr ? qt.relative : Ue.relative,
	Qt = Dr ? qt.dirname : Ue.dirname,
	Ze = Dr ? qt.basename : Ue.basename,
	la = Dr ? qt.extname : Ue.extname,
	j3 = Dr ? qt.format : Ue.format,
	G3 = Dr ? qt.parse : Ue.parse,
	Q3 = Dr ? qt.toNamespacedPath : Ue.toNamespacedPath,
	at = Dr ? qt.sep : Ue.sep,
	Av = Dr ? qt.delimiter : Ue.delimiter
var He = (function () {
	if (typeof crypto.randomUUID == "function") return crypto.randomUUID.bind(crypto)
	let o = new Uint8Array(16),
		e = []
	for (let t = 0; t < 256; t++) e.push(t.toString(16).padStart(2, "0"))
	return function () {
		crypto.getRandomValues(o), (o[6] = (o[6] & 15) | 64), (o[8] = (o[8] & 63) | 128)
		let n = 0,
			r = ""
		return (
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += "-"),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			(r += e[o[n++]]),
			r
		)
	}
})()
var VA = Object.freeze(function (o, e) {
		let t = setTimeout(o.bind(e), 0)
		return {
			dispose() {
				clearTimeout(t)
			},
		}
	}),
	De
;((n) => {
	function o(r) {
		return r === n.None || r === n.Cancelled || r instanceof Cc
			? !0
			: !r || typeof r != "object"
				? !1
				: typeof r.isCancellationRequested == "boolean" && typeof r.onCancellationRequested == "function"
	}
	;(n.isCancellationToken = o),
		(n.None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: Ee.None })),
		(n.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: VA }))
})((De ||= {}))
var Cc = class {
		constructor() {
			this._isCancelled = !1
			this._emitter = null
		}
		cancel() {
			this._isCancelled ||
				((this._isCancelled = !0), this._emitter && (this._emitter.fire(void 0), this.dispose()))
		}
		get isCancellationRequested() {
			return this._isCancelled
		}
		get onCancellationRequested() {
			return this._isCancelled ? VA : (this._emitter || (this._emitter = new E()), this._emitter.event)
		}
		dispose() {
			this._emitter && (this._emitter.dispose(), (this._emitter = null))
		}
	},
	_e = class {
		constructor(e) {
			this._token = void 0
			this._parentListener = void 0
			this._parentListener = e && e.onCancellationRequested(this.cancel, this)
		}
		get token() {
			return this._token || (this._token = new Cc()), this._token
		}
		cancel() {
			this._token ? this._token instanceof Cc && this._token.cancel() : (this._token = De.Cancelled)
		}
		dispose(e = !1) {
			e && this.cancel(),
				this._parentListener?.dispose(),
				this._token ? this._token instanceof Cc && this._token.dispose() : (this._token = De.None)
		}
	}
function I4(o) {
	return o
}
var Ov = class {
	constructor(e, t) {
		this.lastCache = void 0
		this.lastArgKey = void 0
		typeof e == "function"
			? ((this._fn = e), (this._computeKey = I4))
			: ((this._fn = t), (this._computeKey = e.getCacheKey))
	}
	get(e) {
		let t = this._computeKey(e)
		return this.lastArgKey !== t && ((this.lastArgKey = t), (this.lastCache = this._fn(e))), this.lastCache
	}
}
function TE(o) {
	return o < 0 ? 0 : o > 255 ? 255 : o | 0
}
function Nl(o) {
	return o < 0 ? 0 : o > 4294967295 ? 4294967295 : o | 0
}
function Yi(o) {
	return !o || typeof o != "string" ? !0 : o.trim().length === 0
}
var C4 = /{([^}]+)}/g
function _E(o, e) {
	return Object.keys(e).length === 0 ? o : o.replace(C4, (t, n) => e[n] ?? t)
}
function kr(o) {
	return o.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&")
}
function KA(o, e) {
	let t = 0,
		n = o.indexOf(e)
	for (; n !== -1; ) t++, (n = o.indexOf(e, n + e.length))
	return t
}
function DE(o, e) {
	if (!o || !e) return o
	let t = e.length
	if (t === 0 || o.length === 0) return o
	let n = 0
	for (; o.indexOf(e, n) === n; ) n = n + t
	return o.substring(n)
}
function Rr(o, e) {
	if (!o || !e) return o
	let t = e.length,
		n = o.length
	if (t === 0 || n === 0) return o
	let r = n,
		i = -1
	for (; (i = o.lastIndexOf(e, r - 1)), !(i === -1 || i + t !== r); ) {
		if (i === 0) return ""
		r = i
	}
	return o.substring(0, r)
}
function jA(o) {
	return o.replace(/\*/g, "")
}
function Mv(o, e, t = {}) {
	if (!o) throw new Error("Cannot create regex from empty string")
	e || (o = kr(o)),
		t.wholeWord && (/\B/.test(o.charAt(0)) || (o = "\\b" + o), /\B/.test(o.charAt(o.length - 1)) || (o = o + "\\b"))
	let n = ""
	return (
		t.global && (n += "g"),
		t.matchCase || (n += "i"),
		t.multiline && (n += "m"),
		t.unicode && (n += "u"),
		new RegExp(o, n)
	)
}
function Fv(o) {
	return o.source === "^" || o.source === "^$" || o.source === "$" || o.source === "^\\s*$"
		? !1
		: !!(o.exec("") && o.lastIndex === 0)
}
function Nv(o) {
	return o.split(/\r\n|\r|\n/)
}
function Uv(o) {
	for (let e = 0, t = o.length; e < t; e++) {
		let n = o.charCodeAt(e)
		if (n !== 32 && n !== 9) return e
	}
	return -1
}
function GA(o, e = o.length - 1) {
	for (let t = e; t >= 0; t--) {
		let n = o.charCodeAt(t)
		if (n !== 32 && n !== 9) return t
	}
	return -1
}
function Fo(o, e) {
	return o < e ? -1 : o > e ? 1 : 0
}
function Hv(o, e, t = 0, n = o.length, r = 0, i = e.length) {
	for (; t < n && r < i; t++, r++) {
		let l = o.charCodeAt(t),
			d = e.charCodeAt(r)
		if (l < d) return -1
		if (l > d) return 1
	}
	let s = n - t,
		a = i - r
	return s < a ? -1 : s > a ? 1 : 0
}
function Wv(o, e) {
	return Sc(o, e, 0, o.length, 0, e.length)
}
function Sc(o, e, t = 0, n = o.length, r = 0, i = e.length) {
	for (; t < n && r < i; t++, r++) {
		let l = o.charCodeAt(t),
			d = e.charCodeAt(r)
		if (l === d) continue
		if (l >= 128 || d >= 128) return Hv(o.toLowerCase(), e.toLowerCase(), t, n, r, i)
		BA(l) && (l -= 32), BA(d) && (d -= 32)
		let c = l - d
		if (c !== 0) return c
	}
	let s = n - t,
		a = i - r
	return s < a ? -1 : s > a ? 1 : 0
}
function BA(o) {
	return o >= 97 && o <= 122
}
function kE(o) {
	return o >= 65 && o <= 90
}
function xn(o, e) {
	return o.length === e.length && Sc(o, e) === 0
}
function Zi(o, e) {
	let t = e.length
	return e.length > o.length ? !1 : Sc(o, e, 0, t) === 0
}
function QA(o, e) {
	let t = Math.min(o.length, e.length),
		n
	for (n = 0; n < t; n++) if (o.charCodeAt(n) !== e.charCodeAt(n)) return n
	return t
}
function Ul(o) {
	return 55296 <= o && o <= 56319
}
function hf(o) {
	return 56320 <= o && o <= 57343
}
function Vv(o, e) {
	return ((o - 55296) << 10) + (e - 56320) + 65536
}
function RE(o, e, t) {
	let n = o.charCodeAt(t)
	if (Ul(n) && t + 1 < e) {
		let r = o.charCodeAt(t + 1)
		if (hf(r)) return Vv(n, r)
	}
	return n
}
function S4(o, e) {
	let t = o.charCodeAt(e - 1)
	if (hf(t) && e > 1) {
		let n = o.charCodeAt(e - 2)
		if (Ul(n)) return Vv(n, t)
	}
	return t
}
var wE = class {
		get offset() {
			return this._offset
		}
		constructor(e, t = 0) {
			;(this._str = e), (this._len = e.length), (this._offset = t)
		}
		setOffset(e) {
			this._offset = e
		}
		prevCodePoint() {
			let e = S4(this._str, this._offset)
			return (this._offset -= e >= 65536 ? 2 : 1), e
		}
		nextCodePoint() {
			let e = RE(this._str, this._len, this._offset)
			return (this._offset += e >= 65536 ? 2 : 1), e
		}
		eol() {
			return this._offset >= this._len
		}
	},
	PE = class {
		get offset() {
			return this._iterator.offset
		}
		constructor(e, t = 0) {
			this._iterator = new wE(e, t)
		}
		nextGraphemeLength() {
			let e = Lv.getInstance(),
				t = this._iterator,
				n = t.offset,
				r = e.getGraphemeBreakType(t.nextCodePoint())
			for (; !t.eol(); ) {
				let i = t.offset,
					s = e.getGraphemeBreakType(t.nextCodePoint())
				if ($A(r, s)) {
					t.setOffset(i)
					break
				}
				r = s
			}
			return t.offset - n
		}
		prevGraphemeLength() {
			let e = Lv.getInstance(),
				t = this._iterator,
				n = t.offset,
				r = e.getGraphemeBreakType(t.prevCodePoint())
			for (; t.offset > 0; ) {
				let i = t.offset,
					s = e.getGraphemeBreakType(t.prevCodePoint())
				if ($A(s, r)) {
					t.setOffset(i)
					break
				}
				r = s
			}
			return n - t.offset
		}
		eol() {
			return this._iterator.eol()
		}
	}
function AE(o, e) {
	return new PE(o, e).nextGraphemeLength()
}
var EE
function T4() {
	return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/
}
function Bv(o) {
	return EE || (EE = T4()), EE.test(o)
}
var E4 = /^[\t\n\r\x20-\x7E]*$/
function JA(o) {
	return E4.test(o)
}
var w4 = /[\u2028\u2029]/
function $v(o) {
	return w4.test(o)
}
var P4 = /(?:\x1b\[|\x9b)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/,
	_4 = /(?:\x1b\]|\x9d).*?(?:\x1b\\|\x07|\x9c)/,
	D4 = /\x1b(?:[ #%\(\)\*\+\-\.\/]?[a-zA-Z0-9\|}~@])/,
	lz = new RegExp("(?:" + [P4.source, _4.source, D4.source].join("|") + ")", "g")
var XA = String.fromCharCode(65279)
function YA(o) {
	return !!(o && o.length > 0 && o.charCodeAt(0) === 65279)
}
function ZA(o, e) {
	if (!o || !e || o.length < e.length) return !1
	let t = e.length,
		n = o.toLowerCase(),
		r = 0,
		i = -1
	for (; r < t; ) {
		let s = n.indexOf(e[r], i + 1)
		if (s < 0) return !1
		;(i = s), r++
	}
	return !0
}
function OE(o, e = !1) {
	return o ? (e && (o = o.replace(/\\./g, "")), o.toLowerCase() !== o) : !1
}
function eO(o) {
	return o.charAt(0).toUpperCase() + o.slice(1)
}
function tO(o, e = 1) {
	if (e === 0) return ""
	let t = -1
	do
		(t = o.indexOf(
			`
`,
			t + 1,
		)),
			e--
	while (e > 0 && t >= 0)
	return t === -1 ? o : (o[t - 1] === "\r" && t--, o.substr(0, t))
}
function $A(o, e) {
	return o === 0
		? e !== 5 && e !== 7
		: o === 2 && e === 3
			? !1
			: o === 4 || o === 2 || o === 3 || e === 4 || e === 2 || e === 3
				? !0
				: !(
						(o === 8 && (e === 8 || e === 9 || e === 11 || e === 12)) ||
						((o === 11 || o === 9) && (e === 9 || e === 10)) ||
						((o === 12 || o === 10) && e === 10) ||
						e === 5 ||
						e === 13 ||
						e === 7 ||
						o === 1 ||
						(o === 13 && e === 14) ||
						(o === 6 && e === 6)
					)
}
var Lv = class o {
	static {
		this._INSTANCE = null
	}
	static getInstance() {
		return o._INSTANCE || (o._INSTANCE = new o()), o._INSTANCE
	}
	constructor() {
		this._data = k4()
	}
	getGraphemeBreakType(e) {
		if (e < 32) return e === 10 ? 3 : e === 13 ? 2 : 4
		if (e < 127) return 0
		let t = this._data,
			n = t.length / 3,
			r = 1
		for (; r <= n; )
			if (e < t[3 * r]) r = 2 * r
			else if (e > t[3 * r + 1]) r = 2 * r + 1
			else return t[3 * r + 2]
		return 0
	}
}
function k4() {
	return JSON.parse(
		"[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]",
	)
}
var zA = class o {
		constructor(e) {
			this.confusableDictionary = e
		}
		static {
			this.ambiguousCharacterData = new kt(() =>
				JSON.parse(
					'{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}',
				),
			)
		}
		static {
			this.cache = new Ov({ getCacheKey: JSON.stringify }, (e) => {
				function t(c) {
					let u = new Map()
					for (let m = 0; m < c.length; m += 2) u.set(c[m], c[m + 1])
					return u
				}
				function n(c, u) {
					let m = new Map(c)
					for (let [f, h] of u) m.set(f, h)
					return m
				}
				function r(c, u) {
					if (!c) return u
					let m = new Map()
					for (let [f, h] of c) u.has(f) && m.set(f, h)
					return m
				}
				let i = this.ambiguousCharacterData.value,
					s = e.filter((c) => !c.startsWith("_") && c in i)
				s.length === 0 && (s = ["_default"])
				let a
				for (let c of s) {
					let u = t(i[c])
					a = r(a, u)
				}
				let l = t(i._common),
					d = n(l, a)
				return new o(d)
			})
		}
		static getInstance(e) {
			return o.cache.get(Array.from(e))
		}
		static {
			this._locales = new kt(() => Object.keys(o.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")))
		}
		static getLocales() {
			return o._locales.value
		}
		isAmbiguous(e) {
			return this.confusableDictionary.has(e)
		}
		containsAmbiguousCharacter(e) {
			for (let t = 0; t < e.length; t++) {
				let n = e.codePointAt(t)
				if (typeof n == "number" && this.isAmbiguous(n)) return !0
			}
			return !1
		}
		getPrimaryConfusable(e) {
			return this.confusableDictionary.get(e)
		}
		getConfusableCodePoints() {
			return new Set(this.confusableDictionary.keys())
		}
	},
	qA = class o {
		static getRawData() {
			return JSON.parse(
				'{"_common":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],"cs":[173,8203,12288],"de":[173,8203,12288],"es":[8203,12288],"fr":[173,8203,12288],"it":[160,173,12288],"ja":[173],"ko":[173,12288],"pl":[173,8203,12288],"pt-BR":[173,8203,12288],"qps-ploc":[160,173,8203,12288],"ru":[173,12288],"tr":[160,173,8203,12288],"zh-hans":[160,173,8203,12288],"zh-hant":[173,12288]}',
			)
		}
		static {
			this._data = void 0
		}
		static getData() {
			return this._data || (this._data = new Set([...Object.values(o.getRawData())].flat())), this._data
		}
		static isInvisibleCharacter(e) {
			return o.getData().has(e)
		}
		static containsInvisibleCharacter(e) {
			for (let t = 0; t < e.length; t++) {
				let n = e.codePointAt(t)
				if (typeof n == "number" && (o.isInvisibleCharacter(n) || n === 32)) return !0
			}
			return !1
		}
		static get codePoints() {
			return o.getData()
		}
	}
function da(o) {
	return o === 47 || o === 92
}
function zv(o) {
	return o.replace(/[\\/]/g, Ue.sep)
}
function nO(o) {
	return o.indexOf("/") === -1 && (o = zv(o)), /^[a-zA-Z]:(\/|$)/.test(o) && (o = "/" + o), o
}
function vf(o, e = Ue.sep) {
	if (!o) return ""
	let t = o.length,
		n = o.charCodeAt(0)
	if (da(n)) {
		if (da(o.charCodeAt(1)) && !da(o.charCodeAt(2))) {
			let i = 3,
				s = i
			for (; i < t && !da(o.charCodeAt(i)); i++);
			if (s !== i && !da(o.charCodeAt(i + 1))) {
				for (i += 1; i < t; i++) if (da(o.charCodeAt(i))) return o.slice(0, i + 1).replace(/[\\/]/g, e)
			}
		}
		return e
	} else if (oO(n) && o.charCodeAt(1) === 58) return da(o.charCodeAt(2)) ? o.slice(0, 2) + e : o.slice(0, 2)
	let r = o.indexOf("://")
	if (r !== -1) {
		for (r += 3; r < t; r++) if (da(o.charCodeAt(r))) return o.slice(0, r + 1)
	}
	return ""
}
var R4 = /[\\/:\*\?"<>\|]/g,
	A4 = /[/]/g,
	O4 = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i
function rO(o, e = Ie) {
	let t = e ? R4 : A4
	return !(
		!o ||
		o.length === 0 ||
		/^\s+$/.test(o) ||
		((t.lastIndex = 0), t.test(o)) ||
		(e && O4.test(o)) ||
		o === "." ||
		o === ".." ||
		(e && o[o.length - 1] === ".") ||
		(e && o.length !== o.trim().length) ||
		o.length > 255
	)
}
function Tc(o, e, t) {
	let n = o === e
	return !t || n ? n : !o || !e ? !1 : xn(o, e)
}
function Kr(o, e, t, n = at) {
	if (o === e) return !0
	if (!o || !e || e.length > o.length) return !1
	if (t) {
		if (!Zi(o, e)) return !1
		if (e.length === o.length) return !0
		let i = e.length
		return e.charAt(e.length - 1) === n && i--, o.charAt(i) === n
	}
	return e.charAt(e.length - 1) !== n && (e += n), o.indexOf(e) === 0
}
function oO(o) {
	return (o >= 65 && o <= 90) || (o >= 97 && o <= 122)
}
function iO(o) {
	return Ie ? ((o = Rr(o, at)), o.endsWith(":") && (o += at)) : ((o = Rr(o, at)), o || (o = at)), o
}
function LE(o) {
	let e = Gn(o)
	return Ie ? (o.length > 3 ? !1 : qv(e) && (o.length === 2 || e.charCodeAt(2) === 92)) : e === Ue.sep
}
function qv(o, e = Ie) {
	return e ? oO(o.charCodeAt(0)) && o.charCodeAt(1) === 58 : !1
}
function ME(o, e = Ie) {
	return qv(o, e) ? o[0] : void 0
}
var L4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
	M4 = "BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789"
function sO(o, e, t = 8) {
	let n = ""
	for (let i = 0; i < t; i++) {
		let s
		i === 0 && Ie && !e && (t === 3 || t === 4) ? (s = M4) : (s = L4),
			(n += s.charAt(Math.floor(Math.random() * s.length)))
	}
	let r
	return e ? (r = `${e}-${n}`) : (r = n), o ? Fe(o, r) : r
}
var F4 = /^\w[\w\d+.-]*$/,
	N4 = /^\//,
	U4 = /^\/\//
function H4(o, e) {
	if (!o.scheme && e)
		throw new Error(
			`[UriError]: Scheme is missing: {scheme: "", authority: "${o.authority}", path: "${o.path}", query: "${o.query}", fragment: "${o.fragment}"}`,
		)
	if (o.scheme && !F4.test(o.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.")
	if (o.path) {
		if (o.authority) {
			if (!N4.test(o.path))
				throw new Error(
					'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
				)
		} else if (U4.test(o.path))
			throw new Error(
				'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
			)
	}
}
function W4(o, e) {
	return !o && !e ? "file" : o
}
function V4(o, e) {
	switch (o) {
		case "https":
		case "http":
		case "file":
			e ? e[0] !== No && (e = No + e) : (e = No)
			break
	}
	return e
}
var Ot = "",
	No = "/",
	B4 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
	b = class o {
		static isUri(e) {
			return e instanceof o
				? !0
				: e
					? typeof e.authority == "string" &&
						typeof e.fragment == "string" &&
						typeof e.path == "string" &&
						typeof e.query == "string" &&
						typeof e.scheme == "string" &&
						typeof e.fsPath == "string" &&
						typeof e.with == "function" &&
						typeof e.toString == "function"
					: !1
		}
		constructor(e, t, n, r, i, s = !1) {
			typeof e == "object"
				? ((this.scheme = e.scheme || Ot),
					(this.authority = e.authority || Ot),
					(this.path = e.path || Ot),
					(this.query = e.query || Ot),
					(this.fragment = e.fragment || Ot))
				: ((this.scheme = W4(e, s)),
					(this.authority = t || Ot),
					(this.path = V4(this.scheme, n || Ot)),
					(this.query = r || Ot),
					(this.fragment = i || Ot),
					H4(this, s))
		}
		get fsPath() {
			return bf(this, !1)
		}
		with(e) {
			if (!e) return this
			let { scheme: t, authority: n, path: r, query: i, fragment: s } = e
			return (
				t === void 0 ? (t = this.scheme) : t === null && (t = Ot),
				n === void 0 ? (n = this.authority) : n === null && (n = Ot),
				r === void 0 ? (r = this.path) : r === null && (r = Ot),
				i === void 0 ? (i = this.query) : i === null && (i = Ot),
				s === void 0 ? (s = this.fragment) : s === null && (s = Ot),
				t === this.scheme && n === this.authority && r === this.path && i === this.query && s === this.fragment
					? this
					: new ca(t, n, r, i, s)
			)
		}
		static parse(e, t = !1) {
			let n = B4.exec(e)
			return n
				? new ca(n[2] || Ot, Kv(n[4] || Ot), Kv(n[5] || Ot), Kv(n[7] || Ot), Kv(n[9] || Ot), t)
				: new ca(Ot, Ot, Ot, Ot, Ot)
		}
		static file(e) {
			let t = Ot
			if ((Ie && (e = e.replace(/\\/g, No)), e[0] === No && e[1] === No)) {
				let n = e.indexOf(No, 2)
				n === -1 ? ((t = e.substring(2)), (e = No)) : ((t = e.substring(2, n)), (e = e.substring(n) || No))
			}
			return new ca("file", t, e, Ot, Ot)
		}
		static from(e, t) {
			return new ca(e.scheme, e.authority, e.path, e.query, e.fragment, t)
		}
		static joinPath(e, ...t) {
			if (!e.path) throw new Error("[UriError]: cannot call joinPath on URI without path")
			let n
			return (
				Ie && e.scheme === "file" ? (n = o.file(qt.join(bf(e, !0), ...t)).path) : (n = Ue.join(e.path, ...t)),
				e.with({ path: n })
			)
		}
		toString(e = !1) {
			return NE(this, e)
		}
		toJSON() {
			return this
		}
		static revive(e) {
			if (e) {
				if (e instanceof o) return e
				{
					let t = new ca(e)
					return (
						(t._formatted = e.external ?? null), (t._fsPath = e._sep === dO ? (e.fsPath ?? null) : null), t
					)
				}
			} else return e
		}
		[Symbol.for("debug.description")]() {
			return `URI(${this.toString()})`
		}
	}
function yf(o) {
	return !o || typeof o != "object"
		? !1
		: typeof o.scheme == "string" &&
				(typeof o.authority == "string" || typeof o.authority > "u") &&
				(typeof o.path == "string" || typeof o.path > "u") &&
				(typeof o.query == "string" || typeof o.query > "u") &&
				(typeof o.fragment == "string" || typeof o.fragment > "u")
}
var dO = Ie ? 1 : void 0,
	ca = class extends b {
		constructor() {
			super(...arguments)
			this._formatted = null
			this._fsPath = null
		}
		get fsPath() {
			return this._fsPath || (this._fsPath = bf(this, !1)), this._fsPath
		}
		toString(t = !1) {
			return t ? NE(this, !0) : (this._formatted || (this._formatted = NE(this, !1)), this._formatted)
		}
		toJSON() {
			let t = { $mid: 1 }
			return (
				this._fsPath && ((t.fsPath = this._fsPath), (t._sep = dO)),
				this._formatted && (t.external = this._formatted),
				this.path && (t.path = this.path),
				this.scheme && (t.scheme = this.scheme),
				this.authority && (t.authority = this.authority),
				this.query && (t.query = this.query),
				this.fragment && (t.fragment = this.fragment),
				t
			)
		}
	},
	cO = {
		58: "%3A",
		47: "%2F",
		63: "%3F",
		35: "%23",
		91: "%5B",
		93: "%5D",
		64: "%40",
		33: "%21",
		36: "%24",
		38: "%26",
		39: "%27",
		40: "%28",
		41: "%29",
		42: "%2A",
		43: "%2B",
		44: "%2C",
		59: "%3B",
		61: "%3D",
		32: "%20",
	}
function aO(o, e, t) {
	let n,
		r = -1
	for (let i = 0; i < o.length; i++) {
		let s = o.charCodeAt(i)
		if (
			(s >= 97 && s <= 122) ||
			(s >= 65 && s <= 90) ||
			(s >= 48 && s <= 57) ||
			s === 45 ||
			s === 46 ||
			s === 95 ||
			s === 126 ||
			(e && s === 47) ||
			(t && s === 91) ||
			(t && s === 93) ||
			(t && s === 58)
		)
			r !== -1 && ((n += encodeURIComponent(o.substring(r, i))), (r = -1)), n !== void 0 && (n += o.charAt(i))
		else {
			n === void 0 && (n = o.substr(0, i))
			let a = cO[s]
			a !== void 0
				? (r !== -1 && ((n += encodeURIComponent(o.substring(r, i))), (r = -1)), (n += a))
				: r === -1 && (r = i)
		}
	}
	return r !== -1 && (n += encodeURIComponent(o.substring(r))), n !== void 0 ? n : o
}
function $4(o) {
	let e
	for (let t = 0; t < o.length; t++) {
		let n = o.charCodeAt(t)
		n === 35 || n === 63 ? (e === void 0 && (e = o.substr(0, t)), (e += cO[n])) : e !== void 0 && (e += o[t])
	}
	return e !== void 0 ? e : o
}
function bf(o, e) {
	let t
	return (
		o.authority && o.path.length > 1 && o.scheme === "file"
			? (t = `//${o.authority}${o.path}`)
			: o.path.charCodeAt(0) === 47 &&
				  ((o.path.charCodeAt(1) >= 65 && o.path.charCodeAt(1) <= 90) ||
						(o.path.charCodeAt(1) >= 97 && o.path.charCodeAt(1) <= 122)) &&
				  o.path.charCodeAt(2) === 58
				? e
					? (t = o.path.substr(1))
					: (t = o.path[1].toLowerCase() + o.path.substr(2))
				: (t = o.path),
		Ie && (t = t.replace(/\//g, "\\")),
		t
	)
}
function NE(o, e) {
	let t = e ? $4 : aO,
		n = "",
		{ scheme: r, authority: i, path: s, query: a, fragment: l } = o
	if ((r && ((n += r), (n += ":")), (i || r === "file") && ((n += No), (n += No)), i)) {
		let d = i.indexOf("@")
		if (d !== -1) {
			let c = i.substr(0, d)
			;(i = i.substr(d + 1)),
				(d = c.lastIndexOf(":")),
				d === -1
					? (n += t(c, !1, !1))
					: ((n += t(c.substr(0, d), !1, !1)), (n += ":"), (n += t(c.substr(d + 1), !1, !0))),
				(n += "@")
		}
		;(i = i.toLowerCase()),
			(d = i.lastIndexOf(":")),
			d === -1 ? (n += t(i, !1, !0)) : ((n += t(i.substr(0, d), !1, !0)), (n += i.substr(d)))
	}
	if (s) {
		if (s.length >= 3 && s.charCodeAt(0) === 47 && s.charCodeAt(2) === 58) {
			let d = s.charCodeAt(1)
			d >= 65 && d <= 90 && (s = `/${String.fromCharCode(d + 32)}:${s.substr(3)}`)
		} else if (s.length >= 2 && s.charCodeAt(1) === 58) {
			let d = s.charCodeAt(0)
			d >= 65 && d <= 90 && (s = `${String.fromCharCode(d + 32)}:${s.substr(2)}`)
		}
		n += t(s, !0, !1)
	}
	return a && ((n += "?"), (n += t(a, !1, !1))), l && ((n += "#"), (n += e ? l : aO(l, !1, !1))), n
}
function uO(o) {
	try {
		return decodeURIComponent(o)
	} catch {
		return o.length > 3 ? o.substr(0, 3) + uO(o.substr(3)) : o
	}
}
var lO = /(%[0-9A-Za-z][0-9A-Za-z])+/g
function Kv(o) {
	return o.match(lO) ? o.replace(lO, (e) => uO(e)) : o
}
var W
;((Te) => (
	(Te.inMemory = "inmemory"),
	(Te.vscode = "vscode"),
	(Te.internal = "private"),
	(Te.walkThrough = "walkThrough"),
	(Te.walkThroughSnippet = "walkThroughSnippet"),
	(Te.http = "http"),
	(Te.https = "https"),
	(Te.file = "file"),
	(Te.mailto = "mailto"),
	(Te.untitled = "untitled"),
	(Te.data = "data"),
	(Te.command = "command"),
	(Te.vscodeRemote = "vscode-remote"),
	(Te.vscodeRemoteResource = "vscode-remote-resource"),
	(Te.vscodeManagedRemoteResource = "vscode-managed-remote-resource"),
	(Te.vscodeUserData = "vscode-userdata"),
	(Te.vscodeCustomEditor = "vscode-custom-editor"),
	(Te.vscodeNotebookCell = "vscode-notebook-cell"),
	(Te.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata"),
	(Te.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff"),
	(Te.vscodeNotebookCellOutput = "vscode-notebook-cell-output"),
	(Te.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff"),
	(Te.vscodeNotebookMetadata = "vscode-notebook-metadata"),
	(Te.vscodeInteractiveInput = "vscode-interactive-input"),
	(Te.vscodeSettings = "vscode-settings"),
	(Te.vscodeWorkspaceTrust = "vscode-workspace-trust"),
	(Te.vscodeTerminal = "vscode-terminal"),
	(Te.vscodeChatCodeBlock = "vscode-chat-code-block"),
	(Te.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block"),
	(Te.vscodeChatSesssion = "vscode-chat-editor"),
	(Te.webviewPanel = "webview-panel"),
	(Te.vscodeWebview = "vscode-webview"),
	(Te.extension = "extension"),
	(Te.vscodeFileResource = "vscode-file"),
	(Te.tmp = "tmp"),
	(Te.vsls = "vsls"),
	(Te.vscodeSourceControl = "vscode-scm"),
	(Te.commentsInput = "comment"),
	(Te.codeSetting = "code-setting"),
	(Te.outputChannel = "output"),
	(Te.accessibleView = "accessible-view")
))((W ||= {}))
function jv(o, e) {
	return b.isUri(o) ? xn(o.scheme, e) : Zi(o, e + ":")
}
function pO(o, ...e) {
	return e.some((t) => jv(o, t))
}
var z4 = "tkn",
	UE = class {
		constructor() {
			this._hosts = Object.create(null)
			this._ports = Object.create(null)
			this._connectionTokens = Object.create(null)
			this._preferredWebSchema = "http"
			this._delegate = null
			this._serverRootPath = "/"
		}
		setPreferredWebSchema(e) {
			this._preferredWebSchema = e
		}
		setDelegate(e) {
			this._delegate = e
		}
		setServerRootPath(e, t) {
			this._serverRootPath = Ue.join(t ?? "/", q4(e))
		}
		getServerRootPath() {
			return this._serverRootPath
		}
		get _remoteResourcesPath() {
			return Ue.join(this._serverRootPath, W.vscodeRemoteResource)
		}
		set(e, t, n) {
			;(this._hosts[e] = t), (this._ports[e] = n)
		}
		setConnectionToken(e, t) {
			this._connectionTokens[e] = t
		}
		getPreferredWebSchema() {
			return this._preferredWebSchema
		}
		rewrite(e) {
			if (this._delegate)
				try {
					return this._delegate(e)
				} catch (a) {
					return Be(a), e
				}
			let t = e.authority,
				n = this._hosts[t]
			n && n.indexOf(":") !== -1 && n.indexOf("[") === -1 && (n = `[${n}]`)
			let r = this._ports[t],
				i = this._connectionTokens[t],
				s = `path=${encodeURIComponent(e.path)}`
			return (
				typeof i == "string" && (s += `&${z4}=${encodeURIComponent(i)}`),
				b.from({
					scheme: Oo ? this._preferredWebSchema : W.vscodeRemoteResource,
					authority: `${n}:${r}`,
					path: this._remoteResourcesPath,
					query: s,
				})
			)
		}
	},
	WE = new UE()
function q4(o) {
	return `${o.quality ?? "oss"}-${o.commit ?? "dev"}`
}
var mO = "vs/../../node_modules",
	fO = "vs/../../node_modules.asar"
var VE = "vscode-app",
	HE = class o {
		static {
			this.FALLBACK_AUTHORITY = VE
		}
		asBrowserUri(e) {
			let t = this.toUri(e)
			return this.uriToBrowserUri(t)
		}
		uriToBrowserUri(e) {
			return e.scheme === W.vscodeRemote
				? WE.rewrite(e)
				: e.scheme === W.file && (Tv || LA === `${W.vscodeFileResource}://${o.FALLBACK_AUTHORITY}`)
					? e.with({
							scheme: W.vscodeFileResource,
							authority: e.authority || o.FALLBACK_AUTHORITY,
							query: null,
							fragment: null,
						})
					: e
		}
		asFileUri(e) {
			let t = this.toUri(e)
			return this.uriToFileUri(t)
		}
		uriToFileUri(e) {
			return e.scheme === W.vscodeFileResource
				? e.with({
						scheme: W.file,
						authority: e.authority !== o.FALLBACK_AUTHORITY ? e.authority : null,
						query: null,
						fragment: null,
					})
				: e
		}
		toUri(e) {
			if (b.isUri(e)) return e
			if (globalThis._VSCODE_FILE_ROOT) {
				let t = globalThis._VSCODE_FILE_ROOT
				if (/^\w[\w\d+.-]*:\/\//.test(t)) return b.joinPath(b.parse(t, !0), e)
				let n = Fe(t, e)
				return b.file(n)
			}
			throw new Error("Cannot determine URI for module id!")
		}
	},
	Ec = new HE(),
	xz = Object.freeze({ "Cache-Control": "no-cache, no-store" }),
	Cz = Object.freeze({ "Document-Policy": "include-js-call-stacks-in-crash-reports" }),
	K4
;((i) => {
	let o = new Map([
		["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
		["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
		["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }],
	])
	i.CoopAndCoep = Object.freeze(o.get("3"))
	let t = "vscode-coi"
	function n(s) {
		let a
		typeof s == "string"
			? (a = new URL(s).searchParams)
			: s instanceof URL
				? (a = s.searchParams)
				: b.isUri(s) && (a = new URL(s.toString(!0)).searchParams)
		let l = a?.get(t)
		if (l) return o.get(l)
	}
	i.getHeadersFromQuery = n
	function r(s, a, l) {
		if (!globalThis.crossOriginIsolated) return
		let d = a && l ? "3" : l ? "2" : "1"
		s instanceof URLSearchParams ? s.set(t, d) : (s[t] = d)
	}
	i.addSearchParam = r
})((K4 ||= {}))
function so(o) {
	return bf(o, !0)
}
var es = class {
		constructor(e) {
			this._ignorePathCasing = e
		}
		compare(e, t, n = !1) {
			return e === t ? 0 : Fo(this.getComparisonKey(e, n), this.getComparisonKey(t, n))
		}
		isEqual(e, t, n = !1) {
			return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, n) === this.getComparisonKey(t, n)
		}
		getComparisonKey(e, t = !1) {
			return e
				.with({ path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0, fragment: t ? null : void 0 })
				.toString()
		}
		ignorePathCasing(e) {
			return this._ignorePathCasing(e)
		}
		isEqualOrParent(e, t, n = !1) {
			if (e.scheme === t.scheme) {
				if (e.scheme === W.file)
					return (
						Kr(so(e), so(t), this._ignorePathCasing(e)) &&
						e.query === t.query &&
						(n || e.fragment === t.fragment)
					)
				if (gO(e.authority, t.authority))
					return (
						Kr(e.path, t.path, this._ignorePathCasing(e), "/") &&
						e.query === t.query &&
						(n || e.fragment === t.fragment)
					)
			}
			return !1
		}
		joinPath(e, ...t) {
			return b.joinPath(e, ...t)
		}
		basenameOrAuthority(e) {
			return Ht(e) || e.authority
		}
		basename(e) {
			return Ue.basename(e.path)
		}
		extname(e) {
			return Ue.extname(e.path)
		}
		dirname(e) {
			if (e.path.length === 0) return e
			let t
			return (
				e.scheme === W.file
					? (t = b.file(Qt(so(e))).path)
					: ((t = Ue.dirname(e.path)),
						e.authority &&
							t.length &&
							t.charCodeAt(0) !== 47 &&
							(console.error(`dirname("${e.toString})) resulted in a relative path`), (t = "/"))),
				e.with({ path: t })
			)
		}
		normalizePath(e) {
			if (!e.path.length) return e
			let t
			return e.scheme === W.file ? (t = b.file(Gn(so(e))).path) : (t = Ue.normalize(e.path)), e.with({ path: t })
		}
		relativePath(e, t) {
			if (e.scheme !== t.scheme || !gO(e.authority, t.authority)) return
			if (e.scheme === W.file) {
				let i = Mo(so(e), so(t))
				return Ie ? zv(i) : i
			}
			let n = e.path || "/",
				r = t.path || "/"
			if (this._ignorePathCasing(e)) {
				let i = 0
				for (
					let s = Math.min(n.length, r.length);
					i < s &&
					!(n.charCodeAt(i) !== r.charCodeAt(i) && n.charAt(i).toLowerCase() !== r.charAt(i).toLowerCase());
					i++
				);
				n = r.substr(0, i) + n.substr(i)
			}
			return Ue.relative(n, r)
		}
		resolvePath(e, t) {
			if (e.scheme === W.file) {
				let n = b.file(WA(so(e), t))
				return e.with({ authority: n.authority, path: n.path })
			}
			return (t = nO(t)), e.with({ path: Ue.resolve(e.path, t) })
		}
		isAbsolutePath(e) {
			return !!e.path && e.path[0] === "/"
		}
		isEqualAuthority(e, t) {
			return e === t || (e !== void 0 && t !== void 0 && xn(e, t))
		}
		hasTrailingPathSeparator(e, t = at) {
			if (e.scheme === W.file) {
				let n = so(e)
				return n.length > vf(n).length && n[n.length - 1] === t
			} else {
				let n = e.path
				return n.length > 1 && n.charCodeAt(n.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath)
			}
		}
		removeTrailingPathSeparator(e, t = at) {
			return hO(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e
		}
		addTrailingPathSeparator(e, t = at) {
			let n = !1
			if (e.scheme === W.file) {
				let r = so(e)
				n = r !== void 0 && r.length === vf(r).length && r[r.length - 1] === t
			} else {
				t = "/"
				let r = e.path
				n = r.length === 1 && r.charCodeAt(r.length - 1) === 47
			}
			return !n && !hO(e, t) ? e.with({ path: e.path + "/" }) : e
		}
	},
	et = new es(() => !1),
	Hl = new es((o) => (o.scheme === W.file ? !Ve : !0)),
	BE = new es((o) => !0),
	jr = et.isEqual.bind(et),
	j4 = et.isEqualOrParent.bind(et),
	Dz = et.getComparisonKey.bind(et),
	If = et.basenameOrAuthority.bind(et),
	Ht = et.basename.bind(et),
	Gv = et.extname.bind(et),
	ts = et.dirname.bind(et),
	ct = et.joinPath.bind(et),
	kz = et.normalizePath.bind(et),
	xf = et.relativePath.bind(et),
	Rz = et.resolvePath.bind(et),
	vO = et.isAbsolutePath.bind(et),
	gO = et.isEqualAuthority.bind(et),
	hO = et.hasTrailingPathSeparator.bind(et),
	Az = et.removeTrailingPathSeparator.bind(et),
	Oz = et.addTrailingPathSeparator.bind(et)
var G4
;((i) => {
	;(i.META_DATA_LABEL = "label"),
		(i.META_DATA_DESCRIPTION = "description"),
		(i.META_DATA_SIZE = "size"),
		(i.META_DATA_MIME = "mime")
	function r(s) {
		let a = new Map()
		s.path
			.substring(s.path.indexOf(";") + 1, s.path.lastIndexOf(";"))
			.split(";")
			.forEach((c) => {
				let [u, m] = c.split(":")
				u && m && a.set(u, m)
			})
		let d = s.path.substring(0, s.path.indexOf(";"))
		return d && a.set(i.META_DATA_MIME, d), a
	}
	i.parseMetaData = r
})((G4 ||= {}))
var bO = Symbol("MicrotaskDelay")
function ao(o) {
	return !!o && typeof o.then == "function"
}
function Ar(o) {
	let e = new _e(),
		t = o(e.token),
		n = !1,
		r = new Promise((i, s) => {
			let a = e.token.onCancellationRequested(() => {
				;(n = !0), a.dispose(), s(new xt())
			})
			Promise.resolve(t).then(
				(l) => {
					a.dispose(), e.dispose(), n ? mv(l) && l.dispose() : i(l)
				},
				(l) => {
					a.dispose(), e.dispose(), s(l)
				},
			)
		})
	return new (class {
		cancel() {
			e.cancel(), e.dispose()
		}
		then(i, s) {
			return r.then(i, s)
		}
		catch(i) {
			return this.then(void 0, i)
		}
		finally(i) {
			return r.finally(i)
		}
	})()
}
function Zv(o, e, t) {
	return new Promise((n, r) => {
		let i = e.onCancellationRequested(() => {
			i.dispose(), n(t)
		})
		o.then(n, r).finally(() => i.dispose())
	})
}
function yO(o, e) {
	return new Promise((t, n) => {
		let r = e.onCancellationRequested(() => {
			r.dispose(), n(new xt())
		})
		o.then(t, n).finally(() => r.dispose())
	})
}
function Jt(o) {
	return new Promise((e, t) => {
		let n = o()
		ao(n) ? n.then(e, t) : e(n)
	})
}
function Tf() {
	let o, e
	return {
		promise: new Promise((n, r) => {
			;(o = n), (e = r)
		}),
		resolve: o,
		reject: e,
	}
}
var $E = class {
		constructor() {
			this.isDisposed = !1
			;(this.activePromise = null), (this.queuedPromise = null), (this.queuedPromiseFactory = null)
		}
		queue(e) {
			if (this.isDisposed) return Promise.reject(new Error("Throttler is disposed"))
			if (this.activePromise) {
				if (((this.queuedPromiseFactory = e), !this.queuedPromise)) {
					let t = () => {
						if (((this.queuedPromise = null), this.isDisposed)) return
						let n = this.queue(this.queuedPromiseFactory)
						return (this.queuedPromiseFactory = null), n
					}
					this.queuedPromise = new Promise((n) => {
						this.activePromise.then(t, t).then(n)
					})
				}
				return new Promise((t, n) => {
					this.queuedPromise.then(t, n)
				})
			}
			return (
				(this.activePromise = e()),
				new Promise((t, n) => {
					this.activePromise.then(
						(r) => {
							;(this.activePromise = null), t(r)
						},
						(r) => {
							;(this.activePromise = null), n(r)
						},
					)
				})
			)
		}
		dispose() {
			this.isDisposed = !0
		}
	},
	Jv = class {
		constructor() {
			this.current = Promise.resolve(null)
		}
		queue(e) {
			return (this.current = this.current.then(
				() => e(),
				() => e(),
			))
		}
	}
var Q4 = (o, e) => {
		let t = !0,
			n = setTimeout(() => {
				;(t = !1), e()
			}, o)
		return {
			isTriggered: () => t,
			dispose: () => {
				clearTimeout(n), (t = !1)
			},
		}
	},
	J4 = (o) => {
		let e = !0
		return (
			queueMicrotask(() => {
				e && ((e = !1), o())
			}),
			{
				isTriggered: () => e,
				dispose: () => {
					e = !1
				},
			}
		)
	},
	Cf = class {
		constructor(e) {
			this.defaultDelay = e
			;(this.deferred = null),
				(this.completionPromise = null),
				(this.doResolve = null),
				(this.doReject = null),
				(this.task = null)
		}
		trigger(e, t = this.defaultDelay) {
			;(this.task = e),
				this.cancelTimeout(),
				this.completionPromise ||
					(this.completionPromise = new Promise((r, i) => {
						;(this.doResolve = r), (this.doReject = i)
					}).then(() => {
						if (((this.completionPromise = null), (this.doResolve = null), this.task)) {
							let r = this.task
							return (this.task = null), r()
						}
					}))
			let n = () => {
				;(this.deferred = null), this.doResolve?.(null)
			}
			return (this.deferred = t === bO ? J4(n) : Q4(t, n)), this.completionPromise
		}
		isTriggered() {
			return !!this.deferred?.isTriggered()
		}
		cancel() {
			this.cancelTimeout(), this.completionPromise && (this.doReject?.(new xt()), (this.completionPromise = null))
		}
		cancelTimeout() {
			this.deferred?.dispose(), (this.deferred = null)
		}
		dispose() {
			this.cancel()
		}
	},
	ns = class {
		constructor(e) {
			;(this.delayer = new Cf(e)), (this.throttler = new $E())
		}
		trigger(e, t) {
			return this.delayer.trigger(() => this.throttler.queue(e), t)
		}
		isTriggered() {
			return this.delayer.isTriggered()
		}
		cancel() {
			this.delayer.cancel()
		}
		dispose() {
			this.delayer.dispose(), this.throttler.dispose()
		}
	},
	dn = class {
		constructor() {
			;(this._isOpen = !1),
				(this._promise = new Promise((e, t) => {
					this._completePromise = e
				}))
		}
		isOpen() {
			return this._isOpen
		}
		open() {
			;(this._isOpen = !0), this._completePromise(!0)
		}
		wait() {
			return this._promise
		}
	}
function Wt(o, e) {
	return e
		? new Promise((t, n) => {
				let r = setTimeout(() => {
						i.dispose(), t()
					}, o),
					i = e.onCancellationRequested(() => {
						clearTimeout(r), i.dispose(), n(new xt())
					})
			})
		: Ar((t) => Wt(o, t))
}
function Ef(o, e = 0, t) {
	let n = setTimeout(() => {
			o(), t && r.dispose()
		}, e),
		r = q(() => {
			clearTimeout(n), t?.delete(r)
		})
	return t?.add(r), r
}
function IO(o, e = (n) => !!n, t = null) {
	if (o.length === 0) return Promise.resolve(t)
	let n = o.length,
		r = () => {
			n = -1
			for (let i of o) i.cancel?.()
		}
	return new Promise((i, s) => {
		for (let a of o)
			a.then((l) => {
				--n >= 0 && e(l) ? (r(), i(l)) : n === 0 && i(t)
			}).catch((l) => {
				--n >= 0 && (r(), s(l))
			})
	})
}
var zE = class {
		constructor(e) {
			this._size = 0
			this._isDisposed = !1
			;(this.maxDegreeOfParalellism = e),
				(this.outstandingPromises = []),
				(this.runningPromises = 0),
				(this._onDrained = new E())
		}
		whenIdle() {
			return this.size > 0 ? Ee.toPromise(this.onDrained) : Promise.resolve()
		}
		get onDrained() {
			return this._onDrained.event
		}
		get size() {
			return this._size
		}
		queue(e) {
			if (this._isDisposed) throw new Error("Object has been disposed")
			return (
				this._size++,
				new Promise((t, n) => {
					this.outstandingPromises.push({ factory: e, c: t, e: n }), this.consume()
				})
			)
		}
		consume() {
			for (; this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism; ) {
				let e = this.outstandingPromises.shift()
				this.runningPromises++
				let t = e.factory()
				t.then(e.c, e.e),
					t.then(
						() => this.consumed(),
						() => this.consumed(),
					)
			}
		}
		consumed() {
			this._isDisposed ||
				(this.runningPromises--,
				--this._size === 0 && this._onDrained.fire(),
				this.outstandingPromises.length > 0 && this.consume())
		}
		clear() {
			if (this._isDisposed) throw new Error("Object has been disposed")
			;(this.outstandingPromises.length = 0), (this._size = this.runningPromises)
		}
		dispose() {
			;(this._isDisposed = !0), (this.outstandingPromises.length = 0), (this._size = 0), this._onDrained.dispose()
		}
	},
	qE = class extends zE {
		constructor() {
			super(1)
		}
	}
var Pc = class {
	constructor() {
		this.queues = new Map()
		this.drainers = new Set()
		this.drainListeners = void 0
		this.drainListenerCount = 0
	}
	async whenDrained() {
		if (this.isDrained()) return
		let e = new Cn()
		return this.drainers.add(e), e.p
	}
	isDrained() {
		for (let [, e] of this.queues) if (e.size > 0) return !1
		return !0
	}
	queueSize(e, t = et) {
		let n = t.getComparisonKey(e)
		return this.queues.get(n)?.size ?? 0
	}
	queueFor(e, t, n = et) {
		let r = n.getComparisonKey(e),
			i = this.queues.get(r)
		if (!i) {
			i = new qE()
			let s = this.drainListenerCount++,
				a = Ee.once(i.onDrained)(() => {
					i?.dispose(),
						this.queues.delete(r),
						this.onDidQueueDrain(),
						this.drainListeners?.deleteAndDispose(s),
						this.drainListeners?.size === 0 &&
							(this.drainListeners.dispose(), (this.drainListeners = void 0))
				})
			this.drainListeners || (this.drainListeners = new Br()),
				this.drainListeners.set(s, a),
				this.queues.set(r, i)
		}
		return i.queue(t)
	}
	onDidQueueDrain() {
		this.isDrained() && this.releaseDrainers()
	}
	releaseDrainers() {
		for (let e of this.drainers) e.complete()
		this.drainers.clear()
	}
	dispose() {
		for (let [, e] of this.queues) e.dispose()
		this.queues.clear(), this.releaseDrainers(), this.drainListeners?.dispose()
	}
}
var _c = class {
		constructor() {
			this.disposable = void 0
			this.isDisposed = !1
		}
		cancel() {
			this.disposable?.dispose(), (this.disposable = void 0)
		}
		cancelAndSet(e, t, n = globalThis) {
			if (this.isDisposed) throw new Gt("Calling 'cancelAndSet' on a disposed IntervalTimer")
			this.cancel()
			let r = n.setInterval(() => {
				e()
			}, t)
			this.disposable = q(() => {
				n.clearInterval(r), (this.disposable = void 0)
			})
		}
		dispose() {
			this.cancel(), (this.isDisposed = !0)
		}
	},
	Wn = class {
		constructor(e, t) {
			;(this.timeoutToken = -1),
				(this.runner = e),
				(this.timeout = t),
				(this.timeoutHandler = this.onTimeout.bind(this))
		}
		dispose() {
			this.cancel(), (this.runner = null)
		}
		cancel() {
			this.isScheduled() && (clearTimeout(this.timeoutToken), (this.timeoutToken = -1))
		}
		schedule(e = this.timeout) {
			this.cancel(), (this.timeoutToken = setTimeout(this.timeoutHandler, e))
		}
		get delay() {
			return this.timeout
		}
		set delay(e) {
			this.timeout = e
		}
		isScheduled() {
			return this.timeoutToken !== -1
		}
		flush() {
			this.isScheduled() && (this.cancel(), this.doRun())
		}
		onTimeout() {
			;(this.timeoutToken = -1), this.runner && this.doRun()
		}
		doRun() {
			this.runner?.()
		}
	},
	Sf = class {
		constructor(e, t) {
			t % 1e3 !== 0 &&
				console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${t}ms is not a multiple of 1000ms.`),
				(this.runner = e),
				(this.timeout = t),
				(this.counter = 0),
				(this.intervalToken = -1),
				(this.intervalHandler = this.onInterval.bind(this))
		}
		dispose() {
			this.cancel(), (this.runner = null)
		}
		cancel() {
			this.isScheduled() && (clearInterval(this.intervalToken), (this.intervalToken = -1))
		}
		schedule(e = this.timeout) {
			e % 1e3 !== 0 &&
				console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${e}ms is not a multiple of 1000ms.`),
				this.cancel(),
				(this.counter = Math.ceil(e / 1e3)),
				(this.intervalToken = setInterval(this.intervalHandler, 1e3))
		}
		isScheduled() {
			return this.intervalToken !== -1
		}
		onInterval() {
			this.counter--,
				!(this.counter > 0) && (clearInterval(this.intervalToken), (this.intervalToken = -1), this.runner?.())
		}
	},
	Xv = class extends Wn {
		constructor(t, n) {
			super(t, n)
			this.units = []
		}
		work(t) {
			this.units.push(t), this.isScheduled() || this.schedule()
		}
		doRun() {
			let t = this.units
			;(this.units = []), this.runner?.(t)
		}
		dispose() {
			;(this.units = []), super.dispose()
		}
	},
	Dc = class extends $ {
		constructor(t, n) {
			super()
			this.options = t
			this.handler = n
			this.pendingWork = []
			this.throttler = this._register(new kn())
			this.disposed = !1
			this.lastExecutionTime = 0
		}
		get pending() {
			return this.pendingWork.length
		}
		work(t) {
			if (this.disposed) return !1
			if (typeof this.options.maxBufferedWork == "number") {
				if (this.throttler.value) {
					if (this.pending + t.length > this.options.maxBufferedWork) return !1
				} else if (this.pending + t.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork)
					return !1
			}
			for (let r of t) this.pendingWork.push(r)
			let n = Date.now() - this.lastExecutionTime
			return (
				!this.throttler.value &&
				(!this.options.waitThrottleDelayBetweenWorkUnits || n >= this.options.throttleDelay)
					? this.doWork()
					: !this.throttler.value &&
						this.options.waitThrottleDelayBetweenWorkUnits &&
						this.scheduleThrottler(Math.max(this.options.throttleDelay - n, 0)),
				!0
			)
		}
		doWork() {
			;(this.lastExecutionTime = Date.now()),
				this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize)),
				this.pendingWork.length > 0 && this.scheduleThrottler()
		}
		scheduleThrottler(t = this.options.throttleDelay) {
			;(this.throttler.value = new Wn(() => {
				this.throttler.clear(), this.doWork()
			}, t)),
				this.throttler.value.schedule()
		}
		dispose() {
			super.dispose(), (this.pendingWork.length = 0), (this.disposed = !0)
		}
	},
	jE,
	Qv
;(function () {
	typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function"
		? (Qv = (o, e, t) => {
				wv(() => {
					if (n) return
					let r = Date.now() + 15
					e(
						Object.freeze({
							didTimeout: !0,
							timeRemaining() {
								return Math.max(0, r - Date.now())
							},
						}),
					)
				})
				let n = !1
				return {
					dispose() {
						n || (n = !0)
					},
				}
			})
		: (Qv = (o, e, t) => {
				let n = o.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0),
					r = !1
				return {
					dispose() {
						r || ((r = !0), o.cancelIdleCallback(n))
					},
				}
			}),
		(jE = (o, e) => Qv(globalThis, o, e))
})()
var KE = class {
		constructor(e, t) {
			this._didRun = !1
			;(this._executor = () => {
				try {
					this._value = t()
				} catch (n) {
					this._error = n
				} finally {
					this._didRun = !0
				}
			}),
				(this._handle = Qv(e, () => this._executor()))
		}
		dispose() {
			this._handle.dispose()
		}
		get value() {
			if ((this._didRun || (this._handle.dispose(), this._executor()), this._error)) throw this._error
			return this._value
		}
		get isInitialized() {
			return this._didRun
		}
	},
	Yv = class extends KE {
		constructor(e) {
			super(globalThis, e)
		}
	}
async function xO(o, e, t) {
	let n
	for (let r = 0; r < t; r++)
		try {
			return await o()
		} catch (i) {
			;(n = i), await Wt(e)
		}
	throw n
}
var Cn = class {
		get isRejected() {
			return this.outcome?.outcome === 1
		}
		get isResolved() {
			return this.outcome?.outcome === 0
		}
		get isSettled() {
			return !!this.outcome
		}
		get value() {
			return this.outcome?.outcome === 0 ? this.outcome?.value : void 0
		}
		constructor() {
			this.p = new Promise((e, t) => {
				;(this.completeCallback = e), (this.errorCallback = t)
			})
		}
		complete(e) {
			return new Promise((t) => {
				this.completeCallback(e), (this.outcome = { outcome: 0, value: e }), t()
			})
		}
		error(e) {
			return new Promise((t) => {
				this.errorCallback(e), (this.outcome = { outcome: 1, value: e }), t()
			})
		}
		cancel() {
			return this.error(new xt())
		}
	},
	lo
;((t) => {
	async function o(n) {
		let r,
			i = await Promise.all(
				n.map((s) =>
					s.then(
						(a) => a,
						(a) => {
							r || (r = a)
						},
					),
				),
			)
		if (typeof r < "u") throw r
		return i
	}
	t.settled = o
	function e(n) {
		return new Promise(async (r, i) => {
			try {
				await n(r, i)
			} catch (s) {
				i(s)
			}
		})
	}
	t.withAsyncBody = e
})((lo ||= {}))
var mi = class o {
	static fromArray(e) {
		return new o((t) => {
			t.emitMany(e)
		})
	}
	static fromPromise(e) {
		return new o(async (t) => {
			t.emitMany(await e)
		})
	}
	static fromPromisesResolveOrder(e) {
		return new o(async (t) => {
			await Promise.all(e.map(async (n) => t.emitOne(await n)))
		})
	}
	static merge(e) {
		return new o(async (t) => {
			await Promise.all(
				e.map(async (n) => {
					for await (let r of n) t.emitOne(r)
				}),
			)
		})
	}
	static {
		this.EMPTY = o.fromArray([])
	}
	constructor(e, t) {
		;(this._state = 0),
			(this._results = []),
			(this._error = null),
			(this._onReturn = t),
			(this._onStateChanged = new E()),
			queueMicrotask(async () => {
				let n = {
					emitOne: (r) => this.emitOne(r),
					emitMany: (r) => this.emitMany(r),
					reject: (r) => this.reject(r),
				}
				try {
					await Promise.resolve(e(n)), this.resolve()
				} catch (r) {
					this.reject(r)
				} finally {
					;(n.emitOne = void 0), (n.emitMany = void 0), (n.reject = void 0)
				}
			})
	}
	[Symbol.asyncIterator]() {
		let e = 0
		return {
			next: async () => {
				do {
					if (this._state === 2) throw this._error
					if (e < this._results.length) return { done: !1, value: this._results[e++] }
					if (this._state === 1) return { done: !0, value: void 0 }
					await Ee.toPromise(this._onStateChanged.event)
				} while (!0)
			},
			return: async () => (this._onReturn?.(), { done: !0, value: void 0 }),
		}
	}
	static map(e, t) {
		return new o(async (n) => {
			for await (let r of e) n.emitOne(t(r))
		})
	}
	map(e) {
		return o.map(this, e)
	}
	static filter(e, t) {
		return new o(async (n) => {
			for await (let r of e) t(r) && n.emitOne(r)
		})
	}
	filter(e) {
		return o.filter(this, e)
	}
	static coalesce(e) {
		return o.filter(e, (t) => !!t)
	}
	coalesce() {
		return o.coalesce(this)
	}
	static async toPromise(e) {
		let t = []
		for await (let n of e) t.push(n)
		return t
	}
	toPromise() {
		return o.toPromise(this)
	}
	emitOne(e) {
		this._state === 0 && (this._results.push(e), this._onStateChanged.fire())
	}
	emitMany(e) {
		this._state === 0 && ((this._results = this._results.concat(e)), this._onStateChanged.fire())
	}
	resolve() {
		this._state === 0 && ((this._state = 1), this._onStateChanged.fire())
	}
	reject(e) {
		this._state === 0 && ((this._state = 2), (this._error = e), this._onStateChanged.fire())
	}
}
var kc = class {
	constructor(e) {
		this._deferred = new Cn()
		this._asyncIterable = new mi((r) => {
			if (t) {
				r.reject(t)
				return
			}
			return (
				n && r.emitMany(n),
				(this._errorFn = (i) => r.reject(i)),
				(this._emitFn = (i) => r.emitOne(i)),
				this._deferred.p
			)
		}, e)
		let t, n
		;(this._emitFn = (r) => {
			n || (n = []), n.push(r)
		}),
			(this._errorFn = (r) => {
				t || (t = r)
			})
	}
	get asyncIterable() {
		return this._asyncIterable
	}
	resolve() {
		this._deferred.complete()
	}
	reject(e) {
		this._errorFn(e), this._deferred.complete()
	}
	emitOne(e) {
		this._emitFn(e)
	}
}
function CO(o) {
	return (e, t, n) => {
		let r = null,
			i = null
		if (
			(typeof n.value == "function"
				? ((r = "value"), (i = n.value))
				: typeof n.get == "function" && ((r = "get"), (i = n.get)),
			!i || typeof t == "symbol")
		)
			throw new Error("not supported")
		n[r] = o(i, t)
	}
}
function eb(o, e, t) {
	let n = null,
		r = null
	if (
		(typeof t.value == "function"
			? ((n = "value"),
				(r = t.value),
				r.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters"))
			: typeof t.get == "function" && ((n = "get"), (r = t.get)),
		!r)
	)
		throw new Error("not supported")
	let i = `$memoize$${e}`
	t[n] = function (...s) {
		return (
			this.hasOwnProperty(i) ||
				Object.defineProperty(this, i, {
					configurable: !1,
					enumerable: !1,
					writable: !1,
					value: r.apply(this, s),
				}),
			this[i]
		)
	}
}
function Wl(o, e, t) {
	return CO((n, r) => {
		let i = `$debounce$${r}`,
			s = `$debounce$result$${r}`
		return function (...a) {
			this[s] || (this[s] = t ? t() : void 0),
				clearTimeout(this[i]),
				e && ((this[s] = e(this[s], ...a)), (a = [this[s]])),
				(this[i] = setTimeout(() => {
					n.apply(this, a), (this[s] = t ? t() : void 0)
				}, o))
		}
	})
}
function SO(o, e, t) {
	return CO((n, r) => {
		let i = `$throttle$timer$${r}`,
			s = `$throttle$result$${r}`,
			a = `$throttle$lastRun$${r}`,
			l = `$throttle$pending$${r}`
		return function (...d) {
			if (
				(this[s] || (this[s] = t ? t() : void 0),
				(this[a] === null || this[a] === void 0) && (this[a] = -Number.MAX_VALUE),
				e && (this[s] = e(this[s], ...d)),
				this[l])
			)
				return
			let c = this[a] + o
			c <= Date.now()
				? ((this[a] = Date.now()), n.apply(this, [this[s]]), (this[s] = t ? t() : void 0))
				: ((this[l] = !0),
					(this[i] = setTimeout(() => {
						;(this[l] = !1), (this[a] = Date.now()), n.apply(this, [this[s]]), (this[s] = t ? t() : void 0)
					}, c - Date.now())))
		}
	})
}
function TO(o) {
	return JSON.stringify(o, X4)
}
function tb(o) {
	let e = JSON.parse(o)
	return (e = ut(e)), e
}
function X4(o, e) {
	return e instanceof RegExp ? { $mid: 2, source: e.source, flags: e.flags } : e
}
function ut(o, e = 0) {
	if (!o || e > 200) return o
	if (typeof o == "object") {
		switch (o.$mid) {
			case 1:
				return b.revive(o)
			case 2:
				return new RegExp(o.source, o.flags)
			case 17:
				return new Date(o.source)
		}
		if (o instanceof z || o instanceof Uint8Array) return o
		if (Array.isArray(o)) for (let t = 0; t < o.length; ++t) o[t] = ut(o[t], e + 1)
		else for (let t in o) Object.hasOwnProperty.call(o, t) && (o[t] = ut(o[t], e + 1))
	}
	return o
}
function EO(o) {
	switch (o) {
		case 100:
			return "req"
		case 101:
			return "cancel"
		case 102:
			return "subscribe"
		case 103:
			return "unsubscribe"
	}
}
function wO(o) {
	switch (o) {
		case 200:
			return "init"
		case 201:
			return "reply:"
		case 202:
		case 203:
			return "replyErr:"
		case 204:
			return "event:"
	}
}
function Rc(o) {
	let e = 0
	for (let t = 0; ; t += 7) {
		let n = o.read(1)
		if (((e |= (n.buffer[0] & 127) << t), !(n.buffer[0] & 128))) return e
	}
}
var Y4 = ua(0)
function Ac(o, e) {
	if (e === 0) {
		o.write(Y4)
		return
	}
	let t = 0
	for (let r = e; r !== 0; r = r >>> 7) t++
	let n = z.alloc(t)
	for (let r = 0; e !== 0; r++) (n.buffer[r] = e & 127), (e = e >>> 7), e > 0 && (n.buffer[r] |= 128)
	o.write(n)
}
var GE = class {
		constructor(e) {
			this.buffer = e
			this.pos = 0
		}
		read(e) {
			let t = this.buffer.slice(this.pos, this.pos + e)
			return (this.pos += t.byteLength), t
		}
	},
	QE = class {
		constructor() {
			this.buffers = []
		}
		get buffer() {
			return z.concat(this.buffers)
		}
		write(e) {
			this.buffers.push(e)
		}
	}
function ua(o) {
	let e = z.alloc(1)
	return e.writeUInt8(o, 0), e
}
var Vl = { Undefined: ua(0), String: ua(1), Buffer: ua(2), VSBuffer: ua(3), Array: ua(4), Object: ua(5), Uint: ua(6) },
	Z4 = typeof Buffer < "u"
function JE(o, e) {
	if (typeof e > "u") o.write(Vl.Undefined)
	else if (typeof e == "string") {
		let t = z.fromString(e)
		o.write(Vl.String), Ac(o, t.byteLength), o.write(t)
	} else if (Z4 && Buffer.isBuffer(e)) {
		let t = z.wrap(e)
		o.write(Vl.Buffer), Ac(o, t.byteLength), o.write(t)
	} else if (e instanceof z) o.write(Vl.VSBuffer), Ac(o, e.byteLength), o.write(e)
	else if (Array.isArray(e)) {
		o.write(Vl.Array), Ac(o, e.length)
		for (let t of e) JE(o, t)
	} else if (typeof e == "number" && (e | 0) === e) o.write(Vl.Uint), Ac(o, e)
	else {
		let t = z.fromString(JSON.stringify(e))
		o.write(Vl.Object), Ac(o, t.byteLength), o.write(t)
	}
}
function XE(o) {
	switch (o.read(1).readUInt8(0)) {
		case 0:
			return
		case 1:
			return o.read(Rc(o)).toString()
		case 2:
			return o.read(Rc(o)).buffer
		case 3:
			return o.read(Rc(o))
		case 4: {
			let t = Rc(o),
				n = []
			for (let r = 0; r < t; r++) n.push(XE(o))
			return n
		}
		case 5:
			return JSON.parse(o.read(Rc(o)).toString())
		case 6:
			return Rc(o)
	}
}
var wf = class {
	constructor(e, t = null) {
		this.protocol = e
		this.isDisposed = !1
		this.state = 0
		this.activeRequests = new Set()
		this.handlers = new Map()
		this.lastRequestId = 0
		this._onDidInitialize = new E()
		this.onDidInitialize = this._onDidInitialize.event
		;(this.protocolListener = this.protocol.onMessage((n) => this.onBuffer(n))), (this.logger = t)
	}
	getChannel(e) {
		let t = this
		return {
			call(n, r, i) {
				return t.isDisposed ? Promise.reject(new xt()) : t.requestPromise(e, n, r, i)
			},
			listen(n, r) {
				return t.isDisposed ? Ee.None : t.requestEvent(e, n, r)
			},
		}
	}
	requestPromise(e, t, n, r = De.None) {
		let i = this.lastRequestId++,
			a = { id: i, type: 100, channelName: e, name: t, arg: n }
		if (r.isCancellationRequested) return Promise.reject(new xt())
		let l, d
		return new Promise((u, m) => {
			if (r.isCancellationRequested) return m(new xt())
			let f = () => {
					let I = (C) => {
						switch (C.type) {
							case 201:
								this.handlers.delete(i), u(C.data)
								break
							case 202: {
								this.handlers.delete(i)
								let T = new Error(C.data.message)
								;(T.stack = Array.isArray(C.data.stack)
									? C.data.stack.join(`
`)
									: C.data.stack),
									(T.name = C.data.name),
									m(T)
								break
							}
							case 203:
								this.handlers.delete(i), m(C.data)
								break
						}
					}
					this.handlers.set(i, I), this.sendRequest(a)
				},
				h = null
			this.state === 1
				? f()
				: ((h = Ar((I) => this.whenInitialized())),
					h.then(() => {
						;(h = null), f()
					}))
			let g = () => {
				h ? (h.cancel(), (h = null)) : this.sendRequest({ id: i, type: 101 }), m(new xt())
			}
			;(l = r.onCancellationRequested(g)),
				(d = {
					dispose: ji(() => {
						g(), l.dispose()
					}),
				}),
				this.activeRequests.add(d)
		}).finally(() => {
			l?.dispose(), this.activeRequests.delete(d)
		})
	}
	requestEvent(e, t, n) {
		let r = this.lastRequestId++,
			s = { id: r, type: 102, channelName: e, name: t, arg: n },
			a = null,
			l = new E({
				onWillAddFirstListener: () => {
					let c = () => {
						this.activeRequests.add(l), this.sendRequest(s)
					}
					this.state === 1
						? c()
						: ((a = Ar((u) => this.whenInitialized())),
							a.then(() => {
								;(a = null), c()
							}))
				},
				onDidRemoveLastListener: () => {
					a
						? (a.cancel(), (a = null))
						: (this.activeRequests.delete(l), this.sendRequest({ id: r, type: 103 }))
				},
			}),
			d = (c) => l.fire(c.data)
		return this.handlers.set(r, d), l.event
	}
	sendRequest(e) {
		switch (e.type) {
			case 100:
			case 102: {
				let t = this.send([e.type, e.id, e.channelName, e.name], e.arg)
				this.logger?.logOutgoing(t, e.id, 0, `${EO(e.type)}: ${e.channelName}.${e.name}`, e.arg)
				return
			}
			case 101:
			case 103: {
				let t = this.send([e.type, e.id])
				this.logger?.logOutgoing(t, e.id, 0, EO(e.type))
				return
			}
		}
	}
	send(e, t = void 0) {
		let n = new QE()
		return JE(n, e), JE(n, t), this.sendBuffer(n.buffer)
	}
	sendBuffer(e) {
		try {
			return this.protocol.send(e), e.byteLength
		} catch {
			return 0
		}
	}
	onBuffer(e) {
		let t = new GE(e),
			n = XE(t),
			r = XE(t),
			i = n[0]
		switch (i) {
			case 200:
				return this.logger?.logIncoming(e.byteLength, 0, 0, wO(i)), this.onResponse({ type: n[0] })
			case 201:
			case 202:
			case 204:
			case 203:
				return (
					this.logger?.logIncoming(e.byteLength, n[1], 0, wO(i), r),
					this.onResponse({ type: n[0], id: n[1], data: r })
				)
		}
	}
	onResponse(e) {
		if (e.type === 200) {
			;(this.state = 1), this._onDidInitialize.fire()
			return
		}
		this.handlers.get(e.id)?.(e)
	}
	get onDidInitializePromise() {
		return Ee.toPromise(this.onDidInitialize)
	}
	whenInitialized() {
		return this.state === 1 ? Promise.resolve() : this.onDidInitializePromise
	}
	dispose() {
		;(this.isDisposed = !0),
			this.protocolListener && (this.protocolListener.dispose(), (this.protocolListener = null)),
			Nn(this.activeRequests.values()),
			this.activeRequests.clear()
	}
}
R([eb], wf.prototype, "onDidInitializePromise", 1)
function PO(o) {
	let e = !1
	return {
		call(t, n, r) {
			return e
				? o.call(t, n, r)
				: Wt(0)
						.then(() => (e = !0))
						.then(() => o.call(t, n, r))
		},
		listen(t, n) {
			if (e) return o.listen(t, n)
			let r = new yv()
			return (
				Wt(0)
					.then(() => (e = !0))
					.then(() => (r.input = o.listen(t, n))),
				r.event
			)
		},
	}
}
var YE
;((r) => {
	function o(i, s, a) {
		let l = i,
			d = a && a.disableMarshalling,
			c = new Map()
		for (let u in l) t(u) && c.set(u, Ee.buffer(l[u], !0, void 0, s))
		return new (class {
			listen(u, m, f) {
				let h = c.get(m)
				if (h) return h
				let g = l[m]
				if (typeof g == "function") {
					if (n(m)) return g.call(l, f)
					if (t(m)) return c.set(m, Ee.buffer(l[m], !0, void 0, s)), c.get(m)
				}
				throw new jn(`Event not found: ${m}`)
			}
			call(u, m, f) {
				let h = l[m]
				if (typeof h == "function") {
					if (!d && Array.isArray(f)) for (let I = 0; I < f.length; I++) f[I] = ut(f[I])
					let g = h.apply(l, f)
					return g instanceof Promise || (g = Promise.resolve(g)), g
				}
				throw new jn(`Method not found: ${m}`)
			}
		})()
	}
	r.fromService = o
	function e(i, s) {
		let a = s && s.disableMarshalling
		return new Proxy(
			{},
			{
				get(l, d) {
					if (typeof d == "string")
						return s?.properties?.has(d)
							? s.properties.get(d)
							: n(d)
								? function (c) {
										return i.listen(d, c)
									}
								: t(d)
									? i.listen(d)
									: async function (...c) {
											let u
											s && !bt(s.context) ? (u = [s.context, ...c]) : (u = c)
											let m = await i.call(d, u)
											return a ? m : ut(m)
										}
					throw new jn(`Property not found: ${String(d)}`)
				},
			},
		)
	}
	r.toService = e
	function t(i) {
		return i[0] === "o" && i[1] === "n" && kE(i.charCodeAt(2))
	}
	function n(i) {
		return /^onDynamic/.test(i) && kE(i.charCodeAt(9))
	}
})((YE ||= {}))
import cH from "net"
import R6 from "minimist"
import * as aH from "net"
function ZE(o) {
	let e = []
	typeof o == "number" && e.push("code/timeOrigin", o)
	function t(r, i) {
		e.push(r, i?.startTime ?? Date.now())
	}
	function n() {
		let r = []
		for (let i = 0; i < e.length; i += 2) r.push({ name: e[i], startTime: e[i + 1] })
		return r
	}
	return { mark: t, getMarks: n }
}
function e5() {
	if (typeof performance == "object" && typeof performance.mark == "function" && !performance.nodeTiming)
		return typeof performance.timeOrigin != "number" && !performance.timing
			? ZE()
			: {
					mark(o, e) {
						performance.mark(o, e)
					},
					getMarks() {
						let o = performance.timeOrigin
						typeof o != "number" &&
							(o =
								performance.timing.navigationStart ||
								performance.timing.redirectStart ||
								performance.timing.fetchStart)
						let e = [{ name: "code/timeOrigin", startTime: Math.round(o) }]
						for (let t of performance.getEntriesByType("mark"))
							e.push({ name: t.name, startTime: Math.round(o + t.startTime) })
						return e
					},
				}
	if (typeof process == "object") {
		let o = performance?.timeOrigin
		return ZE(o)
	} else return console.trace("perf-util loaded in UNKNOWN environment"), ZE()
}
function t5(o) {
	return o.MonacoPerformanceMarks || (o.MonacoPerformanceMarks = e5()), o.MonacoPerformanceMarks
}
var _O = t5(globalThis),
	Ct = _O.mark,
	DO = _O.getMarks
import * as rs from "fs"
var Uo = {}
LH(Uo, {
	Promises: () => Qe,
	RimRafMode: () => nw,
	SymlinkSupport: () => ir,
	configureFlushOnWrite: () => ow,
	readdirSync: () => c5,
	rimrafSync: () => l5,
	whenDeleted: () => p5,
	writeFileSync: () => h5,
})
import * as ke from "fs"
import { tmpdir as s5 } from "os"
import { promisify as Pf } from "util"
var n5 = new ko(1e4)
function Bl(o) {
	return kO(o, "NFC", n5)
}
var r5 = new ko(1e4)
function ew(o) {
	return kO(o, "NFD", r5)
}
var o5 = /[^\u0000-\u0080]/
function kO(o, e, t) {
	if (!o) return o
	let n = t.get(o)
	if (n) return n
	let r
	return o5.test(o) ? (r = o.normalize(e)) : (r = o), t.set(o, r), r
}
var nw = ((t) => ((t[(t.UNLINK = 0)] = "UNLINK"), (t[(t.MOVE = 1)] = "MOVE"), t))(nw || {})
async function AO(o, e = 0, t) {
	if (LE(o)) throw new Error("rimraf - will refuse to recursively delete root")
	return e === 0 ? tw(o) : a5(o, t)
}
async function a5(o, e = sO(s5())) {
	try {
		try {
			await ke.promises.rename(o, e)
		} catch (t) {
			return t.code === "ENOENT" ? void 0 : tw(o)
		}
		tw(e).catch((t) => {})
	} catch (t) {
		if (t.code !== "ENOENT") throw t
	}
}
async function tw(o) {
	return ke.promises.rm(o, { recursive: !0, force: !0, maxRetries: 3 })
}
function l5(o) {
	if (LE(o)) throw new Error("rimraf - will refuse to recursively delete root")
	ke.rmSync(o, { recursive: !0, force: !0, maxRetries: 3 })
}
async function nb(o, e) {
	return OO(await (e ? d5(o) : ke.promises.readdir(o)))
}
async function d5(o) {
	try {
		return await ke.promises.readdir(o, { withFileTypes: !0 })
	} catch (n) {
		console.warn("[node.js fs] readdir with filetypes failed with error: ", n)
	}
	let e = [],
		t = await nb(o)
	for (let n of t) {
		let r = !1,
			i = !1,
			s = !1
		try {
			let a = await ke.promises.lstat(Fe(o, n))
			;(r = a.isFile()), (i = a.isDirectory()), (s = a.isSymbolicLink())
		} catch (a) {
			console.warn("[node.js fs] unexpected error from lstat after readdir: ", a)
		}
		e.push({ name: n, isFile: () => r, isDirectory: () => i, isSymbolicLink: () => s })
	}
	return e
}
function c5(o) {
	return OO(ke.readdirSync(o))
}
function OO(o) {
	return o.map((e) => (typeof e == "string" ? (st ? Bl(e) : e) : ((e.name = st ? Bl(e.name) : e.name), e)))
}
async function u5(o) {
	let e = await nb(o),
		t = []
	for (let n of e) (await ir.existsDirectory(Fe(o, n))) && t.push(n)
	return t
}
function p5(o, e = 1e3) {
	return new Promise((t) => {
		let n = !1,
			r = setInterval(() => {
				n ||
					((n = !0),
					ke.access(o, (i) => {
						;(n = !1), i && (clearInterval(r), t(void 0))
					}))
			}, e)
	})
}
var ir
;((n) => {
	async function o(r) {
		let i
		try {
			if (((i = await ke.promises.lstat(r)), !i.isSymbolicLink())) return { stat: i }
		} catch {}
		try {
			return { stat: await ke.promises.stat(r), symbolicLink: i?.isSymbolicLink() ? { dangling: !1 } : void 0 }
		} catch (s) {
			if (s.code === "ENOENT" && i) return { stat: i, symbolicLink: { dangling: !0 } }
			if (Ie && s.code === "EACCES")
				try {
					return {
						stat: await ke.promises.stat(await ke.promises.readlink(r)),
						symbolicLink: { dangling: !1 },
					}
				} catch (a) {
					if (a.code === "ENOENT" && i) return { stat: i, symbolicLink: { dangling: !0 } }
					throw a
				}
			throw s
		}
	}
	n.stat = o
	async function e(r) {
		try {
			let { stat: i, symbolicLink: s } = await n.stat(r)
			return i.isFile() && s?.dangling !== !0
		} catch {}
		return !1
	}
	n.existsFile = e
	async function t(r) {
		try {
			let { stat: i, symbolicLink: s } = await n.stat(r)
			return i.isDirectory() && s?.dangling !== !0
		} catch {}
		return !1
	}
	n.existsDirectory = t
})((ir ||= {}))
var m5 = new Pc()
function f5(o, e, t) {
	return m5.queueFor(
		b.file(o),
		() => {
			let n = LO(t)
			return new Promise((r, i) => g5(o, e, n, (s) => (s ? i(s) : r())))
		},
		Hl,
	)
}
var rw = !0
function ow(o) {
	rw = o
}
function g5(o, e, t, n) {
	if (!rw) return ke.writeFile(o, e, { mode: t.mode, flag: t.flag }, n)
	ke.open(o, t.flag, t.mode, (r, i) => {
		if (r) return n(r)
		ke.writeFile(i, e, (s) => {
			if (s) return ke.close(i, () => n(s))
			ke.fdatasync(
				i,
				(a) => (
					a &&
						(console.warn("[node.js fs] fdatasync is now disabled for this session because it failed: ", a),
						ow(!1)),
					ke.close(i, (l) => n(l))
				),
			)
		})
	})
}
function h5(o, e, t) {
	let n = LO(t)
	if (!rw) return ke.writeFileSync(o, e, { mode: n.mode, flag: n.flag })
	let r = ke.openSync(o, n.flag, n.mode)
	try {
		ke.writeFileSync(r, e)
		try {
			ke.fdatasyncSync(r)
		} catch (i) {
			console.warn("[node.js fs] fdatasyncSync is now disabled for this session because it failed: ", i), ow(!1)
		}
	} finally {
		ke.closeSync(r)
	}
}
function LO(o) {
	return o
		? { mode: typeof o.mode == "number" ? o.mode : 438, flag: typeof o.flag == "string" ? o.flag : "w" }
		: { mode: 438, flag: "w" }
}
async function v5(o, e, t = 6e4) {
	if (o !== e)
		try {
			Ie && typeof t == "number" ? await MO(o, e, Date.now(), t) : await ke.promises.rename(o, e)
		} catch (n) {
			if ((o.toLowerCase() !== e.toLowerCase() && n.code === "EXDEV") || o.endsWith("."))
				await FO(o, e, { preserveSymlinks: !1 }), await AO(o, 1)
			else throw n
		}
}
async function MO(o, e, t, n, r = 0) {
	try {
		return await ke.promises.rename(o, e)
	} catch (i) {
		if (i.code !== "EACCES" && i.code !== "EPERM" && i.code !== "EBUSY") throw i
		if (Date.now() - t >= n)
			throw (console.error(`[node.js fs] rename failed after ${r} retries with error: ${i}`), i)
		if (r === 0) {
			let s = !1
			try {
				let { stat: a } = await ir.stat(e)
				a.isFile() || (s = !0)
			} catch {}
			if (s) throw i
		}
		return await Wt(Math.min(100, r * 10)), MO(o, e, t, n, r + 1)
	}
}
async function FO(o, e, t) {
	return NO(o, e, { root: { source: o, target: e }, options: t, handledSourcePaths: new Set() })
}
var RO = 511
async function NO(o, e, t) {
	if (t.handledSourcePaths.has(o)) return
	t.handledSourcePaths.add(o)
	let { stat: n, symbolicLink: r } = await ir.stat(o)
	if (r) {
		if (t.options.preserveSymlinks)
			try {
				return await I5(o, e, t)
			} catch {}
		if (r.dangling) return
	}
	return n.isDirectory() ? b5(o, e, n.mode & RO, t) : y5(o, e, n.mode & RO)
}
async function b5(o, e, t, n) {
	await ke.promises.mkdir(e, { recursive: !0, mode: t })
	let r = await nb(o)
	for (let i of r) await NO(Fe(o, i), Fe(e, i), n)
}
async function y5(o, e, t) {
	await ke.promises.copyFile(o, e), await ke.promises.chmod(e, t)
}
async function I5(o, e, t) {
	let n = await ke.promises.readlink(o)
	Kr(n, t.root.source, !Ve) && (n = Fe(t.root.target, n.substr(t.root.source.length + 1))),
		await ke.promises.symlink(n, e)
}
var Qe = new (class {
	get read() {
		return (o, e, t, n, r) =>
			new Promise((i, s) => {
				ke.read(o, e, t, n, r, (a, l, d) => (a ? s(a) : i({ bytesRead: l, buffer: d })))
			})
	}
	get write() {
		return (o, e, t, n, r) =>
			new Promise((i, s) => {
				ke.write(o, e, t, n, r, (a, l, d) => (a ? s(a) : i({ bytesWritten: l, buffer: d })))
			})
	}
	get fdatasync() {
		return Pf(ke.fdatasync)
	}
	get open() {
		return Pf(ke.open)
	}
	get close() {
		return Pf(ke.close)
	}
	get realpath() {
		return Pf(ke.realpath)
	}
	get ftruncate() {
		return Pf(ke.ftruncate)
	}
	async exists(o) {
		try {
			return await ke.promises.access(o), !0
		} catch {
			return !1
		}
	}
	get readdir() {
		return nb
	}
	get readDirsInDir() {
		return u5
	}
	get writeFile() {
		return f5
	}
	get rm() {
		return AO
	}
	get rename() {
		return v5
	}
	get copy() {
		return FO
	}
})()
async function rb(o) {
	try {
		return await Qe.realpath(o)
	} catch {
		let t = HO(o)
		return await rs.promises.access(t, rs.constants.R_OK), t
	}
}
function UO(o) {
	try {
		return rs.realpathSync(o)
	} catch {
		let t = HO(o)
		return rs.accessSync(t, rs.constants.R_OK), t
	}
}
function HO(o) {
	return Rr(Gn(o), at)
}
function je(o) {
	if (!o || typeof o != "object" || o instanceof RegExp) return o
	let e = Array.isArray(o) ? [] : {}
	return (
		Object.entries(o).forEach(([t, n]) => {
			e[t] = n && typeof n == "object" ? je(n) : n
		}),
		e
	)
}
function ob(o) {
	if (!o || typeof o != "object") return o
	let e = [o]
	for (; e.length > 0; ) {
		let t = e.shift()
		Object.freeze(t)
		for (let n in t)
			if (WO.call(t, n)) {
				let r = t[n]
				typeof r == "object" && !Object.isFrozen(r) && !lA(r) && e.push(r)
			}
	}
	return o
}
var WO = Object.prototype.hasOwnProperty
function os(o, e) {
	return iw(o, e, new Set())
}
function iw(o, e, t) {
	if (bt(o)) return o
	let n = e(o)
	if (typeof n < "u") return n
	if (Array.isArray(o)) {
		let r = []
		for (let i of o) r.push(iw(i, e, t))
		return r
	}
	if (dt(o)) {
		if (t.has(o)) throw new Error("Cannot clone recursive data-structure")
		t.add(o)
		let r = {}
		for (let i in o) WO.call(o, i) && (r[i] = iw(o[i], e, t))
		return t.delete(o), r
	}
	return o
}
function gr(o, e, t = !0) {
	return dt(o)
		? (dt(e) &&
				Object.keys(e).forEach((n) => {
					n in o ? t && (dt(o[n]) && dt(e[n]) ? gr(o[n], e[n], t) : (o[n] = e[n])) : (o[n] = e[n])
				}),
			o)
		: e
}
function nn(o, e) {
	if (o === e) return !0
	if (
		o == null ||
		e === null ||
		e === void 0 ||
		typeof o != typeof e ||
		typeof o != "object" ||
		Array.isArray(o) !== Array.isArray(e)
	)
		return !1
	let t, n
	if (Array.isArray(o)) {
		if (o.length !== e.length) return !1
		for (t = 0; t < o.length; t++) if (!nn(o[t], e[t])) return !1
	} else {
		let r = []
		for (n in o) r.push(n)
		r.sort()
		let i = []
		for (n in e) i.push(n)
		if ((i.sort(), !nn(r, i))) return !1
		for (t = 0; t < r.length; t++) if (!nn(o[r[t]], e[r[t]])) return !1
	}
	return !0
}
function sw(o) {
	let e = new Set()
	return JSON.stringify(o, (t, n) => {
		if (dt(n) || Array.isArray(n)) {
			if (e.has(n)) return "[Circular]"
			e.add(n)
		}
		return typeof n == "bigint" ? `[BigInt ${n.toString()}]` : n
	})
}
function aw(o, e) {
	let t = e.toLowerCase(),
		n = Object.keys(o).find((r) => r.toLowerCase() === t)
	return n ? o[n] : o[e]
}
function lw(o, e) {
	let t = Object.create(null)
	for (let [n, r] of Object.entries(o)) e(n, r) && (t[n] = r)
	return t
}
var dw = {
	tabSize: 4,
	indentSize: 4,
	insertSpaces: !0,
	detectIndentation: !0,
	trimAutoWhitespace: !0,
	largeFileOptimizations: !0,
	bracketPairColorizationOptions: { enabled: !0, independentColorPoolPerBracketType: !1 },
}
var cw = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?"
function x5(o = "") {
	let e = "(-?\\d*\\.\\d\\w*)|([^"
	for (let t of cw) o.indexOf(t) >= 0 || (e += "\\" + t)
	return (e += "\\s]+)"), new RegExp(e, "g")
}
var C5 = x5()
function uw(o) {
	let e = C5
	if (o && o instanceof RegExp)
		if (o.global) e = o
		else {
			let t = "g"
			o.ignoreCase && (t += "i"),
				o.multiline && (t += "m"),
				o.unicode && (t += "u"),
				(e = new RegExp(o.source, t))
		}
	return (e.lastIndex = 0), e
}
var VO = new Ao()
VO.unshift({ maxLen: 1e3, windowSize: 15, timeBudget: 150 })
function pw(o, e, t, n, r) {
	if (((e = uw(e)), r || (r = Rt.first(VO)), t.length > r.maxLen)) {
		let d = o - r.maxLen / 2
		return d < 0 ? (d = 0) : (n += d), (t = t.substring(d, o + r.maxLen / 2)), pw(o, e, t, n, r)
	}
	let i = Date.now(),
		s = o - 1 - n,
		a = -1,
		l = null
	for (let d = 1; !(Date.now() - i >= r.timeBudget); d++) {
		let c = s - r.windowSize * d
		e.lastIndex = Math.max(0, c)
		let u = S5(e, t, s, a)
		if ((!u && l) || ((l = u), c <= 0)) break
		a = c
	}
	if (l) {
		let d = { word: l[0], startColumn: n + 1 + l.index, endColumn: n + 1 + l.index + l[0].length }
		return (e.lastIndex = 0), d
	}
	return null
}
function S5(o, e, t, n) {
	let r
	for (; (r = o.exec(e)); ) {
		let i = r.index || 0
		if (i <= t && o.lastIndex >= t) return r
		if (n > 0 && i > n) return null
	}
	return null
}
function mw(...o) {
	switch (o.length) {
		case 1:
			return p("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", o[0])
		case 2:
			return p("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", o[0], o[1])
		case 3:
			return p("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", o[0], o[1], o[2])
		default:
			return
	}
}
var T5 = p("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"),
	E5 = p(
		"contextkey.scanner.hint.didYouForgetToEscapeSlash",
		"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.",
	),
	pa = class o {
		constructor() {
			this._input = ""
			this._start = 0
			this._current = 0
			this._tokens = []
			this._errors = []
			this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy
		}
		static getLexeme(e) {
			switch (e.type) {
				case 0:
					return "("
				case 1:
					return ")"
				case 2:
					return "!"
				case 3:
					return e.isTripleEq ? "===" : "=="
				case 4:
					return e.isTripleEq ? "!==" : "!="
				case 5:
					return "<"
				case 6:
					return "<="
				case 7:
					return ">="
				case 8:
					return ">="
				case 9:
					return "=~"
				case 10:
					return e.lexeme
				case 11:
					return "true"
				case 12:
					return "false"
				case 13:
					return "in"
				case 14:
					return "not"
				case 15:
					return "&&"
				case 16:
					return "||"
				case 17:
					return e.lexeme
				case 18:
					return e.lexeme
				case 19:
					return e.lexeme
				case 20:
					return "EOF"
				default:
					throw uc(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`)
			}
		}
		static {
			this._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0)))
		}
		static {
			this._keywords = new Map([
				["not", 14],
				["in", 13],
				["false", 12],
				["true", 11],
			])
		}
		get errors() {
			return this._errors
		}
		reset(e) {
			return (
				(this._input = e),
				(this._start = 0),
				(this._current = 0),
				(this._tokens = []),
				(this._errors = []),
				this
			)
		}
		scan() {
			for (; !this._isAtEnd(); )
				switch (((this._start = this._current), this._advance())) {
					case 40:
						this._addToken(0)
						break
					case 41:
						this._addToken(1)
						break
					case 33:
						if (this._match(61)) {
							let t = this._match(61)
							this._tokens.push({ type: 4, offset: this._start, isTripleEq: t })
						} else this._addToken(2)
						break
					case 39:
						this._quotedString()
						break
					case 47:
						this._regex()
						break
					case 61:
						if (this._match(61)) {
							let t = this._match(61)
							this._tokens.push({ type: 3, offset: this._start, isTripleEq: t })
						} else this._match(126) ? this._addToken(9) : this._error(mw("==", "=~"))
						break
					case 60:
						this._addToken(this._match(61) ? 6 : 5)
						break
					case 62:
						this._addToken(this._match(61) ? 8 : 7)
						break
					case 38:
						this._match(38) ? this._addToken(15) : this._error(mw("&&"))
						break
					case 124:
						this._match(124) ? this._addToken(16) : this._error(mw("||"))
						break
					case 32:
					case 13:
					case 9:
					case 10:
					case 160:
						break
					default:
						this._string()
				}
			return (this._start = this._current), this._addToken(20), Array.from(this._tokens)
		}
		_match(e) {
			return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0)
		}
		_advance() {
			return this._input.charCodeAt(this._current++)
		}
		_peek() {
			return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current)
		}
		_addToken(e) {
			this._tokens.push({ type: e, offset: this._start })
		}
		_error(e) {
			let t = this._start,
				n = this._input.substring(this._start, this._current),
				r = { type: 19, offset: this._start, lexeme: n }
			this._errors.push({ offset: t, lexeme: n, additionalInfo: e }), this._tokens.push(r)
		}
		_string() {
			this.stringRe.lastIndex = this._start
			let e = this.stringRe.exec(this._input)
			if (e) {
				this._current = this._start + e[0].length
				let t = this._input.substring(this._start, this._current),
					n = o._keywords.get(t)
				n ? this._addToken(n) : this._tokens.push({ type: 17, lexeme: t, offset: this._start })
			}
		}
		_quotedString() {
			for (; this._peek() !== 39 && !this._isAtEnd(); ) this._advance()
			if (this._isAtEnd()) {
				this._error(T5)
				return
			}
			this._advance(),
				this._tokens.push({
					type: 18,
					lexeme: this._input.substring(this._start + 1, this._current - 1),
					offset: this._start + 1,
				})
		}
		_regex() {
			let e = this._current,
				t = !1,
				n = !1
			for (;;) {
				if (e >= this._input.length) {
					;(this._current = e), this._error(E5)
					return
				}
				let i = this._input.charCodeAt(e)
				if (t) t = !1
				else if (i === 47 && !n) {
					e++
					break
				} else i === 91 ? (n = !0) : i === 92 ? (t = !0) : i === 93 && (n = !1)
				e++
			}
			for (; e < this._input.length && o._regexFlags.has(this._input.charCodeAt(e)); ) e++
			this._current = e
			let r = this._input.substring(this._start, this._current)
			this._tokens.push({ type: 10, lexeme: r, offset: this._start })
		}
		_isAtEnd() {
			return this._current >= this._input.length
		}
	}
var Ho
;((r) => {
	;(r.serviceIds = new Map()), (r.DI_TARGET = "$di$target"), (r.DI_DEPENDENCIES = "$di$dependencies")
	function n(i) {
		return i[r.DI_DEPENDENCIES] || []
	}
	r.getServiceDependencies = n
})((Ho ||= {}))
var Wo = O("instantiationService")
function w5(o, e, t) {
	e[Ho.DI_TARGET] === e
		? e[Ho.DI_DEPENDENCIES].push({ id: o, index: t })
		: ((e[Ho.DI_DEPENDENCIES] = [{ id: o, index: t }]), (e[Ho.DI_TARGET] = e))
}
function O(o) {
	if (Ho.serviceIds.has(o)) return Ho.serviceIds.get(o)
	let e = function (t, n, r) {
		if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter")
		w5(e, t, r)
	}
	return (e.toString = () => o), Ho.serviceIds.set(o, e), e
}
var On = new Map()
On.set("false", !1)
On.set("true", !0)
On.set("isMac", st)
On.set("isLinux", Ve)
On.set("isWindows", Ie)
On.set("isWeb", Oo)
On.set("isMacNative", st && !Oo)
On.set("isEdge", _v)
On.set("isFirefox", NA)
On.set("isChrome", gf)
On.set("isSafari", UA)
var P5 = Object.prototype.hasOwnProperty
var _5 = { regexParsingWithErrorRecovery: !0 },
	D5 = p("contextkey.parser.error.emptyString", "Empty context key expression"),
	k5 = p(
		"contextkey.parser.error.emptyString.hint",
		"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.",
	),
	R5 = p("contextkey.parser.error.noInAfterNot", "'in' after 'not'."),
	BO = p("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"),
	A5 = p("contextkey.parser.error.unexpectedToken", "Unexpected token"),
	O5 = p("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"),
	L5 = p("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"),
	M5 = p("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?"),
	ib = class o {
		constructor(e = _5) {
			this._config = e
			this._scanner = new pa()
			this._tokens = []
			this._current = 0
			this._parsingErrors = []
			this._flagsGYRe = /g|y/g
		}
		static {
			this._parseError = new Error()
		}
		get lexingErrors() {
			return this._scanner.errors
		}
		get parsingErrors() {
			return this._parsingErrors
		}
		parse(e) {
			if (e === "") {
				this._parsingErrors.push({ message: D5, offset: 0, lexeme: "", additionalInfo: k5 })
				return
			}
			;(this._tokens = this._scanner.reset(e).scan()), (this._current = 0), (this._parsingErrors = [])
			try {
				let t = this._expr()
				if (!this._isAtEnd()) {
					let n = this._peek(),
						r = n.type === 17 ? O5 : void 0
					throw (
						(this._parsingErrors.push({
							message: A5,
							offset: n.offset,
							lexeme: pa.getLexeme(n),
							additionalInfo: r,
						}),
						o._parseError)
					)
				}
				return t
			} catch (t) {
				if (t !== o._parseError) throw t
				return
			}
		}
		_expr() {
			return this._or()
		}
		_or() {
			let e = [this._and()]
			for (; this._matchOne(16); ) {
				let t = this._and()
				e.push(t)
			}
			return e.length === 1 ? e[0] : Lt.or(...e)
		}
		_and() {
			let e = [this._term()]
			for (; this._matchOne(15); ) {
				let t = this._term()
				e.push(t)
			}
			return e.length === 1 ? e[0] : Lt.and(...e)
		}
		_term() {
			if (this._matchOne(2)) {
				let e = this._peek()
				switch (e.type) {
					case 11:
						return this._advance(), Qn.INSTANCE
					case 12:
						return this._advance(), sr.INSTANCE
					case 0: {
						this._advance()
						let t = this._expr()
						return this._consume(1, BO), t?.negate()
					}
					case 17:
						return this._advance(), ql.create(e.lexeme)
					default:
						throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e)
				}
			}
			return this._primary()
		}
		_primary() {
			let e = this._peek()
			switch (e.type) {
				case 11:
					return this._advance(), Lt.true()
				case 12:
					return this._advance(), Lt.false()
				case 0: {
					this._advance()
					let t = this._expr()
					return this._consume(1, BO), t
				}
				case 17: {
					let t = e.lexeme
					if ((this._advance(), this._matchOne(9))) {
						let r = this._peek()
						if (!this._config.regexParsingWithErrorRecovery) {
							if ((this._advance(), r.type !== 10)) throw this._errExpectedButGot("REGEX", r)
							let i = r.lexeme,
								s = i.lastIndexOf("/"),
								a = s === i.length - 1 ? void 0 : this._removeFlagsGY(i.substring(s + 1)),
								l
							try {
								l = new RegExp(i.substring(1, s), a)
							} catch {
								throw this._errExpectedButGot("REGEX", r)
							}
							return Lf.create(t, l)
						}
						switch (r.type) {
							case 10:
							case 19: {
								let i = [r.lexeme]
								this._advance()
								let s = this._peek(),
									a = 0
								for (let m = 0; m < r.lexeme.length; m++)
									r.lexeme.charCodeAt(m) === 40 ? a++ : r.lexeme.charCodeAt(m) === 41 && a--
								for (; !this._isAtEnd() && s.type !== 15 && s.type !== 16; ) {
									switch (s.type) {
										case 0:
											a++
											break
										case 1:
											a--
											break
										case 10:
										case 18:
											for (let m = 0; m < s.lexeme.length; m++)
												s.lexeme.charCodeAt(m) === 40
													? a++
													: r.lexeme.charCodeAt(m) === 41 && a--
									}
									if (a < 0) break
									i.push(pa.getLexeme(s)), this._advance(), (s = this._peek())
								}
								let l = i.join(""),
									d = l.lastIndexOf("/"),
									c = d === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(d + 1)),
									u
								try {
									u = new RegExp(l.substring(1, d), c)
								} catch {
									throw this._errExpectedButGot("REGEX", r)
								}
								return Lt.regex(t, u)
							}
							case 18: {
								let i = r.lexeme
								this._advance()
								let s = null
								if (!Yi(i)) {
									let a = i.indexOf("/"),
										l = i.lastIndexOf("/")
									if (a !== l && a >= 0) {
										let d = i.slice(a + 1, l),
											c = i[l + 1] === "i" ? "i" : ""
										try {
											s = new RegExp(d, c)
										} catch {
											throw this._errExpectedButGot("REGEX", r)
										}
									}
								}
								if (s === null) throw this._errExpectedButGot("REGEX", r)
								return Lf.create(t, s)
							}
							default:
								throw this._errExpectedButGot("REGEX", this._peek())
						}
					}
					if (this._matchOne(14)) {
						this._consume(13, R5)
						let r = this._value()
						return Lt.notIn(t, r)
					}
					switch (this._peek().type) {
						case 3: {
							this._advance()
							let r = this._value()
							if (this._previous().type === 18) return Lt.equals(t, r)
							switch (r) {
								case "true":
									return Lt.has(t)
								case "false":
									return Lt.not(t)
								default:
									return Lt.equals(t, r)
							}
						}
						case 4: {
							this._advance()
							let r = this._value()
							if (this._previous().type === 18) return Lt.notEquals(t, r)
							switch (r) {
								case "true":
									return Lt.not(t)
								case "false":
									return Lt.has(t)
								default:
									return Lt.notEquals(t, r)
							}
						}
						case 5:
							return this._advance(), Af.create(t, this._value())
						case 6:
							return this._advance(), Of.create(t, this._value())
						case 7:
							return this._advance(), Lc.create(t, this._value())
						case 8:
							return this._advance(), Rf.create(t, this._value())
						case 13:
							return this._advance(), Lt.in(t, this._value())
						default:
							return Lt.has(t)
					}
				}
				case 20:
					throw (
						(this._parsingErrors.push({ message: L5, offset: e.offset, lexeme: "", additionalInfo: M5 }),
						o._parseError)
					)
				default:
					throw this._errExpectedButGot(
						`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,
						this._peek(),
					)
			}
		}
		_value() {
			let e = this._peek()
			switch (e.type) {
				case 17:
				case 18:
					return this._advance(), e.lexeme
				case 11:
					return this._advance(), "true"
				case 12:
					return this._advance(), "false"
				case 13:
					return this._advance(), "in"
				default:
					return ""
			}
		}
		_removeFlagsGY(e) {
			return e.replaceAll(this._flagsGYRe, "")
		}
		_previous() {
			return this._tokens[this._current - 1]
		}
		_matchOne(e) {
			return this._check(e) ? (this._advance(), !0) : !1
		}
		_advance() {
			return this._isAtEnd() || this._current++, this._previous()
		}
		_consume(e, t) {
			if (this._check(e)) return this._advance()
			throw this._errExpectedButGot(t, this._peek())
		}
		_errExpectedButGot(e, t, n) {
			let r = p(
					"contextkey.parser.error.expectedButGot",
					`Expected: {0}
Received: '{1}'.`,
					e,
					pa.getLexeme(t),
				),
				i = t.offset,
				s = pa.getLexeme(t)
			return this._parsingErrors.push({ message: r, offset: i, lexeme: s, additionalInfo: n }), o._parseError
		}
		_check(e) {
			return this._peek().type === e
		}
		_peek() {
			return this._tokens[this._current]
		}
		_isAtEnd() {
			return this._peek().type === 20
		}
	},
	Lt = class {
		static false() {
			return Qn.INSTANCE
		}
		static true() {
			return sr.INSTANCE
		}
		static has(e) {
			return zl.create(e)
		}
		static equals(e, t) {
			return Df.create(e, t)
		}
		static notEquals(e, t) {
			return kf.create(e, t)
		}
		static regex(e, t) {
			return Lf.create(e, t)
		}
		static in(e, t) {
			return sb.create(e, t)
		}
		static notIn(e, t) {
			return ab.create(e, t)
		}
		static not(e) {
			return ql.create(e)
		}
		static and(...e) {
			return lb.create(e, null, !0)
		}
		static or(...e) {
			return Mf.create(e, null, !0)
		}
		static greater(e, t) {
			return Lc.create(e, t)
		}
		static greaterEquals(e, t) {
			return Rf.create(e, t)
		}
		static smaller(e, t) {
			return Af.create(e, t)
		}
		static smallerEquals(e, t) {
			return Of.create(e, t)
		}
		static {
			this._parser = new ib({ regexParsingWithErrorRecovery: !1 })
		}
		static deserialize(e) {
			return e == null ? void 0 : this._parser.parse(e)
		}
	}
function zO(o) {
	let e = new ib({ regexParsingWithErrorRecovery: !1 })
	return o.map(
		(t) => (
			e.parse(t),
			e.lexingErrors.length > 0
				? e.lexingErrors.map((n) => ({
						errorMessage: n.additionalInfo
							? p(
									"contextkey.scanner.errorForLinterWithHint",
									"Unexpected token. Hint: {0}",
									n.additionalInfo,
								)
							: p("contextkey.scanner.errorForLinter", "Unexpected token."),
						offset: n.offset,
						length: n.lexeme.length,
					}))
				: e.parsingErrors.length > 0
					? e.parsingErrors.map((n) => ({
							errorMessage: n.additionalInfo ? `${n.message}. ${n.additionalInfo}` : n.message,
							offset: n.offset,
							length: n.lexeme.length,
						}))
					: []
		),
	)
}
function _f(o, e) {
	return o.cmp(e)
}
var Qn = class o {
		constructor() {
			this.type = 0
		}
		static {
			this.INSTANCE = new o()
		}
		cmp(e) {
			return this.type - e.type
		}
		equals(e) {
			return e.type === this.type
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !1
		}
		serialize() {
			return "false"
		}
		keys() {
			return []
		}
		map(e) {
			return this
		}
		negate() {
			return sr.INSTANCE
		}
	},
	sr = class o {
		constructor() {
			this.type = 1
		}
		static {
			this.INSTANCE = new o()
		}
		cmp(e) {
			return this.type - e.type
		}
		equals(e) {
			return e.type === this.type
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !0
		}
		serialize() {
			return "true"
		}
		keys() {
			return []
		}
		map(e) {
			return this
		}
		negate() {
			return Qn.INSTANCE
		}
	},
	zl = class o {
		constructor(e, t) {
			this.key = e
			this.negated = t
			this.type = 2
		}
		static create(e, t = null) {
			let n = On.get(e)
			return typeof n == "boolean" ? (n ? sr.INSTANCE : Qn.INSTANCE) : new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : KO(this.key, e.key)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key : !1
		}
		substituteConstants() {
			let e = On.get(this.key)
			return typeof e == "boolean" ? (e ? sr.INSTANCE : Qn.INSTANCE) : this
		}
		evaluate(e) {
			return !!e.getValue(this.key)
		}
		serialize() {
			return this.key
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapDefined(this.key)
		}
		negate() {
			return this.negated || (this.negated = ql.create(this.key, this)), this.negated
		}
	},
	Df = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 4
		}
		static create(e, t, n = null) {
			if (typeof t == "boolean") return t ? zl.create(e, n) : ql.create(e, n)
			let r = On.get(e)
			return typeof r == "boolean" ? (t === (r ? "true" : "false") ? sr.INSTANCE : Qn.INSTANCE) : new o(e, t, n)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			let e = On.get(this.key)
			if (typeof e == "boolean") {
				let t = e ? "true" : "false"
				return this.value === t ? sr.INSTANCE : Qn.INSTANCE
			}
			return this
		}
		evaluate(e) {
			return e.getValue(this.key) == this.value
		}
		serialize() {
			return `${this.key} == '${this.value}'`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = kf.create(this.key, this.value, this)), this.negated
		}
	},
	sb = class o {
		constructor(e, t) {
			this.key = e
			this.valueKey = t
			this.type = 10
			this.negated = null
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.valueKey, e.key, e.valueKey)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			let t = e.getValue(this.valueKey),
				n = e.getValue(this.key)
			return Array.isArray(t)
				? t.includes(n)
				: typeof n == "string" && typeof t == "object" && t !== null
					? P5.call(t, n)
					: !1
		}
		serialize() {
			return `${this.key} in '${this.valueKey}'`
		}
		keys() {
			return [this.key, this.valueKey]
		}
		map(e) {
			return e.mapIn(this.key, this.valueKey)
		}
		negate() {
			return this.negated || (this.negated = ab.create(this.key, this.valueKey)), this.negated
		}
	},
	ab = class o {
		constructor(e, t) {
			this.key = e
			this.valueKey = t
			this.type = 11
			this._negated = sb.create(e, t)
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated)
		}
		equals(e) {
			return e.type === this.type ? this._negated.equals(e._negated) : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !this._negated.evaluate(e)
		}
		serialize() {
			return `${this.key} not in '${this.valueKey}'`
		}
		keys() {
			return this._negated.keys()
		}
		map(e) {
			return e.mapNotIn(this.key, this.valueKey)
		}
		negate() {
			return this._negated
		}
	},
	kf = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 5
		}
		static create(e, t, n = null) {
			if (typeof t == "boolean") return t ? ql.create(e, n) : zl.create(e, n)
			let r = On.get(e)
			return typeof r == "boolean" ? (t === (r ? "true" : "false") ? Qn.INSTANCE : sr.INSTANCE) : new o(e, t, n)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			let e = On.get(this.key)
			if (typeof e == "boolean") {
				let t = e ? "true" : "false"
				return this.value === t ? Qn.INSTANCE : sr.INSTANCE
			}
			return this
		}
		evaluate(e) {
			return e.getValue(this.key) != this.value
		}
		serialize() {
			return `${this.key} != '${this.value}'`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapNotEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Df.create(this.key, this.value, this)), this.negated
		}
	},
	ql = class o {
		constructor(e, t) {
			this.key = e
			this.negated = t
			this.type = 3
		}
		static create(e, t = null) {
			let n = On.get(e)
			return typeof n == "boolean" ? (n ? Qn.INSTANCE : sr.INSTANCE) : new o(e, t)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : KO(this.key, e.key)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key : !1
		}
		substituteConstants() {
			let e = On.get(this.key)
			return typeof e == "boolean" ? (e ? Qn.INSTANCE : sr.INSTANCE) : this
		}
		evaluate(e) {
			return !e.getValue(this.key)
		}
		serialize() {
			return `!${this.key}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapNot(this.key)
		}
		negate() {
			return this.negated || (this.negated = zl.create(this.key, this)), this.negated
		}
	}
function db(o, e) {
	if (typeof o == "string") {
		let t = parseFloat(o)
		isNaN(t) || (o = t)
	}
	return typeof o == "string" || typeof o == "number" ? e(o) : Qn.INSTANCE
}
var Lc = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 12
		}
		static create(e, t, n = null) {
			return db(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value
		}
		serialize() {
			return `${this.key} > ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapGreater(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Of.create(this.key, this.value, this)), this.negated
		}
	},
	Rf = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 13
		}
		static create(e, t, n = null) {
			return db(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value
		}
		serialize() {
			return `${this.key} >= ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapGreaterEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Af.create(this.key, this.value, this)), this.negated
		}
	},
	Af = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 14
		}
		static create(e, t, n = null) {
			return db(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value
		}
		serialize() {
			return `${this.key} < ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapSmaller(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Rf.create(this.key, this.value, this)), this.negated
		}
	},
	Of = class o {
		constructor(e, t, n) {
			this.key = e
			this.value = t
			this.negated = n
			this.type = 15
		}
		static create(e, t, n = null) {
			return db(t, (r) => new o(e, r, n))
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : Kl(this.key, this.value, e.key, e.value)
		}
		equals(e) {
			return e.type === this.type ? this.key === e.key && this.value === e.value : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value
		}
		serialize() {
			return `${this.key} <= ${this.value}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapSmallerEquals(this.key, this.value)
		}
		negate() {
			return this.negated || (this.negated = Lc.create(this.key, this.value, this)), this.negated
		}
	},
	Lf = class o {
		constructor(e, t) {
			this.key = e
			this.regexp = t
			this.type = 7
			this.negated = null
		}
		static create(e, t) {
			return new o(e, t)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.key < e.key) return -1
			if (this.key > e.key) return 1
			let t = this.regexp ? this.regexp.source : "",
				n = e.regexp ? e.regexp.source : ""
			return t < n ? -1 : t > n ? 1 : 0
		}
		equals(e) {
			if (e.type === this.type) {
				let t = this.regexp ? this.regexp.source : "",
					n = e.regexp ? e.regexp.source : ""
				return this.key === e.key && t === n
			}
			return !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			let t = e.getValue(this.key)
			return this.regexp ? this.regexp.test(t) : !1
		}
		serialize() {
			let e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/"
			return `${this.key} =~ ${e}`
		}
		keys() {
			return [this.key]
		}
		map(e) {
			return e.mapRegex(this.key, this.regexp)
		}
		negate() {
			return this.negated || (this.negated = fw.create(this)), this.negated
		}
	},
	fw = class o {
		constructor(e) {
			this._actual = e
			this.type = 8
		}
		static create(e) {
			return new o(e)
		}
		cmp(e) {
			return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual)
		}
		equals(e) {
			return e.type === this.type ? this._actual.equals(e._actual) : !1
		}
		substituteConstants() {
			return this
		}
		evaluate(e) {
			return !this._actual.evaluate(e)
		}
		serialize() {
			return `!(${this._actual.serialize()})`
		}
		keys() {
			return this._actual.keys()
		}
		map(e) {
			return new o(this._actual.map(e))
		}
		negate() {
			return this._actual
		}
	}
function qO(o) {
	let e = null
	for (let t = 0, n = o.length; t < n; t++) {
		let r = o[t].substituteConstants()
		if (o[t] !== r && e === null) {
			e = []
			for (let i = 0; i < t; i++) e[i] = o[i]
		}
		e !== null && (e[t] = r)
	}
	return e === null ? o : e
}
var lb = class o {
		constructor(e, t) {
			this.expr = e
			this.negated = t
			this.type = 6
		}
		static create(e, t, n) {
			return o._normalizeArr(e, t, n)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.expr.length < e.expr.length) return -1
			if (this.expr.length > e.expr.length) return 1
			for (let t = 0, n = this.expr.length; t < n; t++) {
				let r = _f(this.expr[t], e.expr[t])
				if (r !== 0) return r
			}
			return 0
		}
		equals(e) {
			if (e.type === this.type) {
				if (this.expr.length !== e.expr.length) return !1
				for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].equals(e.expr[t])) return !1
				return !0
			}
			return !1
		}
		substituteConstants() {
			let e = qO(this.expr)
			return e === this.expr ? this : o.create(e, this.negated, !1)
		}
		evaluate(e) {
			for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].evaluate(e)) return !1
			return !0
		}
		static _normalizeArr(e, t, n) {
			let r = [],
				i = !1
			for (let s of e)
				if (s) {
					if (s.type === 1) {
						i = !0
						continue
					}
					if (s.type === 0) return Qn.INSTANCE
					if (s.type === 6) {
						r.push(...s.expr)
						continue
					}
					r.push(s)
				}
			if (r.length === 0 && i) return sr.INSTANCE
			if (r.length !== 0) {
				if (r.length === 1) return r[0]
				r.sort(_f)
				for (let s = 1; s < r.length; s++) r[s - 1].equals(r[s]) && (r.splice(s, 1), s--)
				if (r.length === 1) return r[0]
				for (; r.length > 1; ) {
					let s = r[r.length - 1]
					if (s.type !== 9) break
					r.pop()
					let a = r.pop(),
						l = r.length === 0,
						d = Mf.create(
							s.expr.map((c) => o.create([c, a], null, n)),
							null,
							l,
						)
					d && (r.push(d), r.sort(_f))
				}
				if (r.length === 1) return r[0]
				if (n) {
					for (let s = 0; s < r.length; s++)
						for (let a = s + 1; a < r.length; a++) if (r[s].negate().equals(r[a])) return Qn.INSTANCE
					if (r.length === 1) return r[0]
				}
				return new o(r, t)
			}
		}
		serialize() {
			return this.expr.map((e) => e.serialize()).join(" && ")
		}
		keys() {
			let e = []
			for (let t of this.expr) e.push(...t.keys())
			return e
		}
		map(e) {
			return new o(
				this.expr.map((t) => t.map(e)),
				null,
			)
		}
		negate() {
			if (!this.negated) {
				let e = []
				for (let t of this.expr) e.push(t.negate())
				this.negated = Mf.create(e, this, !0)
			}
			return this.negated
		}
	},
	Mf = class o {
		constructor(e, t) {
			this.expr = e
			this.negated = t
			this.type = 9
		}
		static create(e, t, n) {
			return o._normalizeArr(e, t, n)
		}
		cmp(e) {
			if (e.type !== this.type) return this.type - e.type
			if (this.expr.length < e.expr.length) return -1
			if (this.expr.length > e.expr.length) return 1
			for (let t = 0, n = this.expr.length; t < n; t++) {
				let r = _f(this.expr[t], e.expr[t])
				if (r !== 0) return r
			}
			return 0
		}
		equals(e) {
			if (e.type === this.type) {
				if (this.expr.length !== e.expr.length) return !1
				for (let t = 0, n = this.expr.length; t < n; t++) if (!this.expr[t].equals(e.expr[t])) return !1
				return !0
			}
			return !1
		}
		substituteConstants() {
			let e = qO(this.expr)
			return e === this.expr ? this : o.create(e, this.negated, !1)
		}
		evaluate(e) {
			for (let t = 0, n = this.expr.length; t < n; t++) if (this.expr[t].evaluate(e)) return !0
			return !1
		}
		static _normalizeArr(e, t, n) {
			let r = [],
				i = !1
			if (e) {
				for (let s = 0, a = e.length; s < a; s++) {
					let l = e[s]
					if (l) {
						if (l.type === 0) {
							i = !0
							continue
						}
						if (l.type === 1) return sr.INSTANCE
						if (l.type === 9) {
							r = r.concat(l.expr)
							continue
						}
						r.push(l)
					}
				}
				if (r.length === 0 && i) return Qn.INSTANCE
				r.sort(_f)
			}
			if (r.length !== 0) {
				if (r.length === 1) return r[0]
				for (let s = 1; s < r.length; s++) r[s - 1].equals(r[s]) && (r.splice(s, 1), s--)
				if (r.length === 1) return r[0]
				if (n) {
					for (let s = 0; s < r.length; s++)
						for (let a = s + 1; a < r.length; a++) if (r[s].negate().equals(r[a])) return sr.INSTANCE
					if (r.length === 1) return r[0]
				}
				return new o(r, t)
			}
		}
		serialize() {
			return this.expr.map((e) => e.serialize()).join(" || ")
		}
		keys() {
			let e = []
			for (let t of this.expr) e.push(...t.keys())
			return e
		}
		map(e) {
			return new o(
				this.expr.map((t) => t.map(e)),
				null,
			)
		}
		negate() {
			if (!this.negated) {
				let e = []
				for (let t of this.expr) e.push(t.negate())
				for (; e.length > 1; ) {
					let t = e.shift(),
						n = e.shift(),
						r = []
					for (let i of $O(t)) for (let s of $O(n)) r.push(lb.create([i, s], null, !1))
					e.unshift(o.create(r, null, !1))
				}
				this.negated = o.create(e, this, !0)
			}
			return this.negated
		}
	},
	D = class o extends zl {
		static {
			this._info = []
		}
		static all() {
			return o._info.values()
		}
		constructor(e, t, n) {
			super(e, null),
				(this._defaultValue = t),
				typeof n == "object"
					? o._info.push({ ...n, key: e })
					: n !== !0 && o._info.push({ key: e, description: n, type: t != null ? typeof t : void 0 })
		}
		bindTo(e) {
			return e.createKey(this.key, this._defaultValue)
		}
		getValue(e) {
			return e.getContextKeyValue(this.key)
		}
		toNegated() {
			return this.negate()
		}
		isEqualTo(e) {
			return Df.create(this.key, e)
		}
		notEqualsTo(e) {
			return kf.create(this.key, e)
		}
		greater(e) {
			return Lc.create(this.key, e)
		}
	},
	ma = O("contextKeyService")
function KO(o, e) {
	return o < e ? -1 : o > e ? 1 : 0
}
function Kl(o, e, t, n) {
	return o < t ? -1 : o > t ? 1 : e < n ? -1 : e > n ? 1 : 0
}
function $O(o) {
	return o.type === 9 ? o.expr : [o]
}
var bK = O("accessibilityService")
var yK = new D("accessibilityModeEnabled", !1)
var Or,
	gw = globalThis.vscode
if (typeof gw < "u" && typeof gw.context < "u") {
	let o = gw.context.configuration()
	if (o) Or = o.product
	else throw new Error("Sandbox: unable to resolve product configuration from preload script.")
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
	if (
		((Or = globalThis._VSCODE_PRODUCT_JSON),
		Pr.VSCODE_DEV &&
			Object.assign(Or, {
				nameShort: `${Or.nameShort} Dev`,
				nameLong: `${Or.nameLong} Dev`,
				dataFolderName: `${Or.dataFolderName}-dev`,
				serverDataFolderName: Or.serverDataFolderName ? `${Or.serverDataFolderName}-dev` : void 0,
			}),
		!Or.version)
	) {
		let o = globalThis._VSCODE_PACKAGE_JSON
		Object.assign(Or, { version: o.version })
	}
} else
	(Or = {}),
		Object.keys(Or).length === 0 &&
			Object.assign(Or, {
				version: "1.95.0-dev",
				nameShort: "Code - OSS Dev",
				nameLong: "Code - OSS Dev",
				applicationName: "code-oss",
				dataFolderName: ".vscode-oss",
				urlProtocol: "code-oss",
				reportIssueUrl: "https://github.com/microsoft/vscode/issues/new",
				licenseName: "MIT",
				licenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
				serverLicenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
			})
var cb = Or
var F5 = 8
var hw = class {
		constructor() {
			;(this.stableMinimapLayoutInput = null),
				(this.stableFitMaxMinimapScale = 0),
				(this.stableFitRemainingWidth = 0)
		}
	},
	pt = class {
		constructor(e, t, n, r) {
			;(this.id = e), (this.name = t), (this.defaultValue = n), (this.schema = r)
		}
		applyUpdate(e, t) {
			return ub(e, t)
		}
		compute(e, t, n) {
			return n
		}
	},
	Mc = class {
		constructor(e, t) {
			this.newValue = e
			this.didChange = t
		}
	}
function ub(o, e) {
	if (typeof o != "object" || typeof e != "object" || !o || !e) return new Mc(e, o !== e)
	if (Array.isArray(o) || Array.isArray(e)) {
		let n = Array.isArray(o) && Array.isArray(e) && mn(o, e)
		return new Mc(e, !n)
	}
	let t = !1
	for (let n in e)
		if (e.hasOwnProperty(n)) {
			let r = ub(o[n], e[n])
			r.didChange && ((o[n] = r.newValue), (t = !0))
		}
	return new Mc(o, t)
}
var ss = class {
		constructor(e) {
			this.schema = void 0
			;(this.id = e), (this.name = "_never_"), (this.defaultValue = void 0)
		}
		applyUpdate(e, t) {
			return ub(e, t)
		}
		validate(e) {
			return this.defaultValue
		}
	},
	fa = class {
		constructor(e, t, n, r) {
			;(this.id = e), (this.name = t), (this.defaultValue = n), (this.schema = r)
		}
		applyUpdate(e, t) {
			return ub(e, t)
		}
		validate(e) {
			return typeof e > "u" ? this.defaultValue : e
		}
		compute(e, t, n) {
			return n
		}
	}
function re(o, e) {
	return typeof o > "u" ? e : o === "false" ? !1 : !!o
}
var Le = class extends fa {
	constructor(e, t, n, r = void 0) {
		typeof r < "u" && ((r.type = "boolean"), (r.default = n)), super(e, t, n, r)
	}
	validate(e) {
		return re(e, this.defaultValue)
	}
}
function N5(o, e, t, n) {
	if (typeof o > "u") return e
	let r = parseInt(o, 10)
	return isNaN(r) ? e : ((r = Math.max(t, r)), (r = Math.min(n, r)), r | 0)
}
var tt = class o extends fa {
	static clampedInt(e, t, n, r) {
		return N5(e, t, n, r)
	}
	constructor(e, t, n, r, i, s = void 0) {
		typeof s < "u" && ((s.type = "integer"), (s.default = n), (s.minimum = r), (s.maximum = i)),
			super(e, t, n, s),
			(this.minimum = r),
			(this.maximum = i)
	}
	validate(e) {
		return o.clampedInt(e, this.defaultValue, this.minimum, this.maximum)
	}
}
var co = class o extends fa {
		static clamp(e, t, n) {
			return e < t ? t : e > n ? n : e
		}
		static float(e, t) {
			if (typeof e == "number") return e
			if (typeof e > "u") return t
			let n = parseFloat(e)
			return isNaN(n) ? t : n
		}
		constructor(e, t, n, r, i) {
			typeof i < "u" && ((i.type = "number"), (i.default = n)), super(e, t, n, i), (this.validationFn = r)
		}
		validate(e) {
			return this.validationFn(o.float(e, this.defaultValue))
		}
	},
	Jn = class o extends fa {
		static string(e, t) {
			return typeof e != "string" ? t : e
		}
		constructor(e, t, n, r = void 0) {
			typeof r < "u" && ((r.type = "string"), (r.default = n)), super(e, t, n, r)
		}
		validate(e) {
			return o.string(e, this.defaultValue)
		}
	}
function St(o, e, t, n) {
	return typeof o != "string" ? e : n && o in n ? n[o] : t.indexOf(o) === -1 ? e : o
}
var gt = class extends fa {
		constructor(e, t, n, r, i = void 0) {
			typeof i < "u" && ((i.type = "string"), (i.enum = r), (i.default = n)),
				super(e, t, n, i),
				(this._allowedValues = r)
		}
		validate(e) {
			return St(e, this.defaultValue, this._allowedValues)
		}
	},
	Gl = class extends pt {
		constructor(e, t, n, r, i, s, a = void 0) {
			typeof a < "u" && ((a.type = "string"), (a.enum = i), (a.default = r)),
				super(e, t, n, a),
				(this._allowedValues = i),
				(this._convert = s)
		}
		validate(e) {
			return typeof e != "string"
				? this.defaultValue
				: this._allowedValues.indexOf(e) === -1
					? this.defaultValue
					: this._convert(e)
		}
	}
function U5(o) {
	switch (o) {
		case "none":
			return 0
		case "keep":
			return 1
		case "brackets":
			return 2
		case "advanced":
			return 3
		case "full":
			return 4
	}
}
var vw = class extends pt {
		constructor() {
			super(2, "accessibilitySupport", 0, {
				type: "string",
				enum: ["auto", "on", "off"],
				enumDescriptions: [
					p("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
					p("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
					p("accessibilitySupport.off", "Assume a screen reader is not attached."),
				],
				default: "auto",
				tags: ["accessibility"],
				description: p(
					"accessibilitySupport",
					"Controls if the UI should run in a mode where it is optimized for screen readers.",
				),
			})
		}
		validate(e) {
			switch (e) {
				case "auto":
					return 0
				case "off":
					return 1
				case "on":
					return 2
			}
			return this.defaultValue
		}
		compute(e, t, n) {
			return n === 0 ? e.accessibilitySupport : n
		}
	},
	bw = class extends pt {
		constructor() {
			let e = { insertSpace: !0, ignoreEmptyLines: !0 }
			super(23, "comments", e, {
				"editor.comments.insertSpace": {
					type: "boolean",
					default: e.insertSpace,
					description: p(
						"comments.insertSpace",
						"Controls whether a space character is inserted when commenting.",
					),
				},
				"editor.comments.ignoreEmptyLines": {
					type: "boolean",
					default: e.ignoreEmptyLines,
					description: p(
						"comments.ignoreEmptyLines",
						"Controls if empty lines should be ignored with toggle, add or remove actions for line comments.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				insertSpace: re(t.insertSpace, this.defaultValue.insertSpace),
				ignoreEmptyLines: re(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),
			}
		}
	}
function H5(o) {
	switch (o) {
		case "blink":
			return 1
		case "smooth":
			return 2
		case "phase":
			return 3
		case "expand":
			return 4
		case "solid":
			return 5
	}
}
var iP = ((s) => (
	(s[(s.Line = 1)] = "Line"),
	(s[(s.Block = 2)] = "Block"),
	(s[(s.Underline = 3)] = "Underline"),
	(s[(s.LineThin = 4)] = "LineThin"),
	(s[(s.BlockOutline = 5)] = "BlockOutline"),
	(s[(s.UnderlineThin = 6)] = "UnderlineThin"),
	s
))(iP || {})
function jO(o) {
	switch (o) {
		case "line":
			return 1
		case "block":
			return 2
		case "underline":
			return 3
		case "line-thin":
			return 4
		case "block-outline":
			return 5
		case "underline-thin":
			return 6
	}
}
var yw = class extends ss {
		constructor() {
			super(148)
		}
		compute(e, t, n) {
			let r = ["monaco-editor"]
			return (
				t.get(41) && r.push(t.get(41)),
				e.extraEditorClassName && r.push(e.extraEditorClassName),
				t.get(75) === "default" ? r.push("mouse-default") : t.get(75) === "copy" && r.push("mouse-copy"),
				t.get(116) && r.push("showUnused"),
				t.get(145) && r.push("showDeprecated"),
				r.join(" ")
			)
		}
	},
	Iw = class extends Le {
		constructor() {
			super(38, "emptySelectionClipboard", !0, {
				description: p(
					"emptySelectionClipboard",
					"Controls whether copying without a selection copies the current line.",
				),
			})
		}
		compute(e, t, n) {
			return n && e.emptySelectionClipboard
		}
	},
	xw = class extends pt {
		constructor() {
			let e = {
				cursorMoveOnType: !0,
				seedSearchStringFromSelection: "always",
				autoFindInSelection: "never",
				globalFindClipboard: !1,
				addExtraSpaceOnTop: !0,
				loop: !0,
				history: "workspace",
				replaceHistory: "workspace",
			}
			super(43, "find", e, {
				"editor.find.cursorMoveOnType": {
					type: "boolean",
					default: e.cursorMoveOnType,
					description: p(
						"find.cursorMoveOnType",
						"Controls whether the cursor should jump to find matches while typing.",
					),
				},
				"editor.find.seedSearchStringFromSelection": {
					type: "string",
					enum: ["never", "always", "selection"],
					default: e.seedSearchStringFromSelection,
					enumDescriptions: [
						p(
							"editor.find.seedSearchStringFromSelection.never",
							"Never seed search string from the editor selection.",
						),
						p(
							"editor.find.seedSearchStringFromSelection.always",
							"Always seed search string from the editor selection, including word at cursor position.",
						),
						p(
							"editor.find.seedSearchStringFromSelection.selection",
							"Only seed search string from the editor selection.",
						),
					],
					description: p(
						"find.seedSearchStringFromSelection",
						"Controls whether the search string in the Find Widget is seeded from the editor selection.",
					),
				},
				"editor.find.autoFindInSelection": {
					type: "string",
					enum: ["never", "always", "multiline"],
					default: e.autoFindInSelection,
					enumDescriptions: [
						p(
							"editor.find.autoFindInSelection.never",
							"Never turn on Find in Selection automatically (default).",
						),
						p("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
						p(
							"editor.find.autoFindInSelection.multiline",
							"Turn on Find in Selection automatically when multiple lines of content are selected.",
						),
					],
					description: p(
						"find.autoFindInSelection",
						"Controls the condition for turning on Find in Selection automatically.",
					),
				},
				"editor.find.globalFindClipboard": {
					type: "boolean",
					default: e.globalFindClipboard,
					description: p(
						"find.globalFindClipboard",
						"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.",
					),
					included: st,
				},
				"editor.find.addExtraSpaceOnTop": {
					type: "boolean",
					default: e.addExtraSpaceOnTop,
					description: p(
						"find.addExtraSpaceOnTop",
						"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.",
					),
				},
				"editor.find.loop": {
					type: "boolean",
					default: e.loop,
					description: p(
						"find.loop",
						"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.",
					),
				},
				"editor.find.history": {
					type: "string",
					enum: ["never", "workspace"],
					default: "workspace",
					enumDescriptions: [
						p("editor.find.history.never", "Do not store search history from the find widget."),
						p("editor.find.history.workspace", "Store search history across the active workspace"),
					],
					description: p("find.history", "Controls how the find widget history should be stored"),
				},
				"editor.find.replaceHistory": {
					type: "string",
					enum: ["never", "workspace"],
					default: "workspace",
					enumDescriptions: [
						p("editor.find.replaceHistory.never", "Do not store history from the replace widget."),
						p("editor.find.replaceHistory.workspace", "Store replace history across the active workspace"),
					],
					description: p("find.replaceHistory", "Controls how the replace widget history should be stored"),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				cursorMoveOnType: re(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
				seedSearchStringFromSelection:
					typeof e.seedSearchStringFromSelection == "boolean"
						? e.seedSearchStringFromSelection
							? "always"
							: "never"
						: St(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, [
								"never",
								"always",
								"selection",
							]),
				autoFindInSelection:
					typeof e.autoFindInSelection == "boolean"
						? e.autoFindInSelection
							? "always"
							: "never"
						: St(t.autoFindInSelection, this.defaultValue.autoFindInSelection, [
								"never",
								"always",
								"multiline",
							]),
				globalFindClipboard: re(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
				addExtraSpaceOnTop: re(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
				loop: re(t.loop, this.defaultValue.loop),
				history: St(t.history, this.defaultValue.history, ["never", "workspace"]),
				replaceHistory: St(t.replaceHistory, this.defaultValue.replaceHistory, ["never", "workspace"]),
			}
		}
	},
	Cw = class o extends pt {
		static {
			this.OFF = '"liga" off, "calt" off'
		}
		static {
			this.ON = '"liga" on, "calt" on'
		}
		constructor() {
			super(53, "fontLigatures", o.OFF, {
				anyOf: [
					{
						type: "boolean",
						description: p(
							"fontLigatures",
							"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.",
						),
					},
					{
						type: "string",
						description: p(
							"fontFeatureSettings",
							"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.",
						),
					},
				],
				description: p(
					"fontLigaturesGeneral",
					"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.",
				),
				default: !1,
			})
		}
		validate(e) {
			return typeof e > "u"
				? this.defaultValue
				: typeof e == "string"
					? e === "false" || e.length === 0
						? o.OFF
						: e === "true"
							? o.ON
							: e
					: e
						? o.ON
						: o.OFF
		}
	},
	Sw = class o extends pt {
		static {
			this.OFF = "normal"
		}
		static {
			this.TRANSLATE = "translate"
		}
		constructor() {
			super(56, "fontVariations", o.OFF, {
				anyOf: [
					{
						type: "boolean",
						description: p(
							"fontVariations",
							"Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.",
						),
					},
					{
						type: "string",
						description: p(
							"fontVariationSettings",
							"Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.",
						),
					},
				],
				description: p(
					"fontVariationsGeneral",
					"Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property.",
				),
				default: !1,
			})
		}
		validate(e) {
			return typeof e > "u"
				? this.defaultValue
				: typeof e == "string"
					? e === "false"
						? o.OFF
						: e === "true"
							? o.TRANSLATE
							: e
					: e
						? o.TRANSLATE
						: o.OFF
		}
		compute(e, t, n) {
			return e.fontInfo.fontVariationSettings
		}
	},
	Tw = class extends ss {
		constructor() {
			super(52)
		}
		compute(e, t, n) {
			return e.fontInfo
		}
	},
	Ew = class extends ss {
		constructor() {
			super(147)
		}
		compute(e, t, n) {
			return e.inputMode === "overtype" ? t.get(84) : t.get(28)
		}
	},
	ww = class extends ss {
		constructor() {
			super(156)
		}
		compute(e, t) {
			return e.editContextSupported && t.get(37)
		}
	},
	Pw = class extends fa {
		constructor() {
			super(54, "fontSize", is.fontSize, {
				type: "number",
				minimum: 6,
				maximum: 100,
				default: is.fontSize,
				description: p("fontSize", "Controls the font size in pixels."),
			})
		}
		validate(e) {
			let t = co.float(e, this.defaultValue)
			return t === 0 ? is.fontSize : co.clamp(t, 6, 100)
		}
		compute(e, t, n) {
			return e.fontInfo.fontSize
		}
	},
	_w = class o extends pt {
		static {
			this.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
		}
		static {
			this.MINIMUM_VALUE = 1
		}
		static {
			this.MAXIMUM_VALUE = 1e3
		}
		constructor() {
			super(55, "fontWeight", is.fontWeight, {
				anyOf: [
					{
						type: "number",
						minimum: o.MINIMUM_VALUE,
						maximum: o.MAXIMUM_VALUE,
						errorMessage: p(
							"fontWeightErrorMessage",
							'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.',
						),
					},
					{ type: "string", pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$" },
					{ enum: o.SUGGESTION_VALUES },
				],
				default: is.fontWeight,
				description: p(
					"fontWeight",
					'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.',
				),
			})
		}
		validate(e) {
			return e === "normal" || e === "bold"
				? e
				: String(tt.clampedInt(e, is.fontWeight, o.MINIMUM_VALUE, o.MAXIMUM_VALUE))
		}
	},
	Dw = class extends pt {
		constructor() {
			let e = {
					multiple: "peek",
					multipleDefinitions: "peek",
					multipleTypeDefinitions: "peek",
					multipleDeclarations: "peek",
					multipleImplementations: "peek",
					multipleReferences: "peek",
					multipleTests: "peek",
					alternativeDefinitionCommand: "editor.action.goToReferences",
					alternativeTypeDefinitionCommand: "editor.action.goToReferences",
					alternativeDeclarationCommand: "editor.action.goToReferences",
					alternativeImplementationCommand: "",
					alternativeReferenceCommand: "",
					alternativeTestsCommand: "",
				},
				t = {
					type: "string",
					enum: ["peek", "gotoAndPeek", "goto"],
					default: e.multiple,
					enumDescriptions: [
						p("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
						p("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
						p(
							"editor.gotoLocation.multiple.goto",
							"Go to the primary result and enable Peek-less navigation to others",
						),
					],
				},
				n = [
					"",
					"editor.action.referenceSearch.trigger",
					"editor.action.goToReferences",
					"editor.action.peekImplementation",
					"editor.action.goToImplementation",
					"editor.action.peekTypeDefinition",
					"editor.action.goToTypeDefinition",
					"editor.action.peekDeclaration",
					"editor.action.revealDeclaration",
					"editor.action.peekDefinition",
					"editor.action.revealDefinitionAside",
					"editor.action.revealDefinition",
				]
			super(60, "gotoLocation", e, {
				"editor.gotoLocation.multiple": {
					deprecationMessage: p(
						"editor.gotoLocation.multiple.deprecated",
						"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.",
					),
				},
				"editor.gotoLocation.multipleDefinitions": {
					description: p(
						"editor.editor.gotoLocation.multipleDefinitions",
						"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleTypeDefinitions": {
					description: p(
						"editor.editor.gotoLocation.multipleTypeDefinitions",
						"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleDeclarations": {
					description: p(
						"editor.editor.gotoLocation.multipleDeclarations",
						"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleImplementations": {
					description: p(
						"editor.editor.gotoLocation.multipleImplemenattions",
						"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.multipleReferences": {
					description: p(
						"editor.editor.gotoLocation.multipleReferences",
						"Controls the behavior the 'Go to References'-command when multiple target locations exist.",
					),
					...t,
				},
				"editor.gotoLocation.alternativeDefinitionCommand": {
					type: "string",
					default: e.alternativeDefinitionCommand,
					enum: n,
					description: p(
						"alternativeDefinitionCommand",
						"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeTypeDefinitionCommand": {
					type: "string",
					default: e.alternativeTypeDefinitionCommand,
					enum: n,
					description: p(
						"alternativeTypeDefinitionCommand",
						"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeDeclarationCommand": {
					type: "string",
					default: e.alternativeDeclarationCommand,
					enum: n,
					description: p(
						"alternativeDeclarationCommand",
						"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeImplementationCommand": {
					type: "string",
					default: e.alternativeImplementationCommand,
					enum: n,
					description: p(
						"alternativeImplementationCommand",
						"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.",
					),
				},
				"editor.gotoLocation.alternativeReferenceCommand": {
					type: "string",
					default: e.alternativeReferenceCommand,
					enum: n,
					description: p(
						"alternativeReferenceCommand",
						"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				multiple: St(t.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
				multipleDefinitions:
					t.multipleDefinitions ?? St(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleTypeDefinitions:
					t.multipleTypeDefinitions ?? St(t.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleDeclarations:
					t.multipleDeclarations ?? St(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleImplementations:
					t.multipleImplementations ?? St(t.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleReferences:
					t.multipleReferences ?? St(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
				multipleTests: t.multipleTests ?? St(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
				alternativeDefinitionCommand: Jn.string(
					t.alternativeDefinitionCommand,
					this.defaultValue.alternativeDefinitionCommand,
				),
				alternativeTypeDefinitionCommand: Jn.string(
					t.alternativeTypeDefinitionCommand,
					this.defaultValue.alternativeTypeDefinitionCommand,
				),
				alternativeDeclarationCommand: Jn.string(
					t.alternativeDeclarationCommand,
					this.defaultValue.alternativeDeclarationCommand,
				),
				alternativeImplementationCommand: Jn.string(
					t.alternativeImplementationCommand,
					this.defaultValue.alternativeImplementationCommand,
				),
				alternativeReferenceCommand: Jn.string(
					t.alternativeReferenceCommand,
					this.defaultValue.alternativeReferenceCommand,
				),
				alternativeTestsCommand: Jn.string(
					t.alternativeTestsCommand,
					this.defaultValue.alternativeTestsCommand,
				),
			}
		}
	},
	kw = class extends pt {
		constructor() {
			let e = { enabled: !0, delay: 300, hidingDelay: 300, sticky: !0, above: !0 }
			super(62, "hover", e, {
				"editor.hover.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p("hover.enabled", "Controls whether the hover is shown."),
				},
				"editor.hover.delay": {
					type: "number",
					default: e.delay,
					minimum: 0,
					maximum: 1e4,
					description: p("hover.delay", "Controls the delay in milliseconds after which the hover is shown."),
				},
				"editor.hover.sticky": {
					type: "boolean",
					default: e.sticky,
					description: p(
						"hover.sticky",
						"Controls whether the hover should remain visible when mouse is moved over it.",
					),
				},
				"editor.hover.hidingDelay": {
					type: "integer",
					minimum: 0,
					default: e.hidingDelay,
					description: p(
						"hover.hidingDelay",
						"Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.",
					),
				},
				"editor.hover.above": {
					type: "boolean",
					default: e.above,
					description: p("hover.above", "Prefer showing hovers above the line, if there's space."),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				delay: tt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
				sticky: re(t.sticky, this.defaultValue.sticky),
				hidingDelay: tt.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
				above: re(t.above, this.defaultValue.above),
			}
		}
	}
var Rw = class o extends ss {
		constructor() {
			super(151)
		}
		compute(e, t, n) {
			return o.computeLayout(t, {
				memory: e.memory,
				outerWidth: e.outerWidth,
				outerHeight: e.outerHeight,
				isDominatedByLongLines: e.isDominatedByLongLines,
				lineHeight: e.fontInfo.lineHeight,
				viewLineCount: e.viewLineCount,
				lineNumbersDigitCount: e.lineNumbersDigitCount,
				typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
				maxDigitWidth: e.fontInfo.maxDigitWidth,
				pixelRatio: e.pixelRatio,
				glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount,
			})
		}
		static computeContainedMinimapLineCount(e) {
			let t = e.height / e.lineHeight,
				n = Math.floor(e.paddingTop / e.lineHeight),
				r = Math.floor(e.paddingBottom / e.lineHeight)
			e.scrollBeyondLastLine && (r = Math.max(r, t - 1))
			let i = (n + e.viewLineCount + r) / (e.pixelRatio * e.height),
				s = Math.floor(e.viewLineCount / i)
			return {
				typicalViewportLineCount: t,
				extraLinesBeforeFirstLine: n,
				extraLinesBeyondLastLine: r,
				desiredRatio: i,
				minimapLineCount: s,
			}
		}
		static _computeMinimapLayout(e, t) {
			let n = e.outerWidth,
				r = e.outerHeight,
				i = e.pixelRatio
			if (!e.minimap.enabled)
				return {
					renderMinimap: 0,
					minimapLeft: 0,
					minimapWidth: 0,
					minimapHeightIsEditorHeight: !1,
					minimapIsSampling: !1,
					minimapScale: 1,
					minimapLineHeight: 1,
					minimapCanvasInnerWidth: 0,
					minimapCanvasInnerHeight: Math.floor(i * r),
					minimapCanvasOuterWidth: 0,
					minimapCanvasOuterHeight: r,
				}
			let s = t.stableMinimapLayoutInput,
				a =
					s &&
					e.outerHeight === s.outerHeight &&
					e.lineHeight === s.lineHeight &&
					e.typicalHalfwidthCharacterWidth === s.typicalHalfwidthCharacterWidth &&
					e.pixelRatio === s.pixelRatio &&
					e.scrollBeyondLastLine === s.scrollBeyondLastLine &&
					e.paddingTop === s.paddingTop &&
					e.paddingBottom === s.paddingBottom &&
					e.minimap.enabled === s.minimap.enabled &&
					e.minimap.side === s.minimap.side &&
					e.minimap.size === s.minimap.size &&
					e.minimap.showSlider === s.minimap.showSlider &&
					e.minimap.renderCharacters === s.minimap.renderCharacters &&
					e.minimap.maxColumn === s.minimap.maxColumn &&
					e.minimap.scale === s.minimap.scale &&
					e.verticalScrollbarWidth === s.verticalScrollbarWidth &&
					e.isViewportWrapping === s.isViewportWrapping,
				l = e.lineHeight,
				d = e.typicalHalfwidthCharacterWidth,
				c = e.scrollBeyondLastLine,
				u = e.minimap.renderCharacters,
				m = i >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale,
				f = e.minimap.maxColumn,
				h = e.minimap.size,
				g = e.minimap.side,
				I = e.verticalScrollbarWidth,
				C = e.viewLineCount,
				T = e.remainingWidth,
				w = e.isViewportWrapping,
				L = u ? 2 : 3,
				A = Math.floor(i * r),
				J = A / i,
				ne = !1,
				oe = !1,
				Y = L * m,
				j = m / i,
				K = 1
			if (h === "fill" || h === "fit") {
				let {
					typicalViewportLineCount: ee,
					extraLinesBeforeFirstLine: fe,
					extraLinesBeyondLastLine: Ae,
					desiredRatio: he,
					minimapLineCount: de,
				} = o.computeContainedMinimapLineCount({
					viewLineCount: C,
					scrollBeyondLastLine: c,
					paddingTop: e.paddingTop,
					paddingBottom: e.paddingBottom,
					height: r,
					lineHeight: l,
					pixelRatio: i,
				})
				if (C / de > 1) (ne = !0), (oe = !0), (m = 1), (Y = 1), (j = m / i)
				else {
					let _t = !1,
						Te = m + 1
					if (h === "fit") {
						let wn = Math.ceil((fe + C + Ae) * Y)
						w && a && T <= t.stableFitRemainingWidth
							? ((_t = !0), (Te = t.stableFitMaxMinimapScale))
							: (_t = wn > A)
					}
					if (h === "fill" || _t) {
						ne = !0
						let wn = m
						;(Y = Math.min(l * i, Math.max(1, Math.floor(1 / he)))),
							w && a && T <= t.stableFitRemainingWidth && (Te = t.stableFitMaxMinimapScale),
							(m = Math.min(Te, Math.max(1, Math.floor(Y / L)))),
							m > wn && (K = Math.min(2, m / wn)),
							(j = m / i / K),
							(A = Math.ceil(Math.max(ee, fe + C + Ae) * Y)),
							w
								? ((t.stableMinimapLayoutInput = e),
									(t.stableFitRemainingWidth = T),
									(t.stableFitMaxMinimapScale = m))
								: ((t.stableMinimapLayoutInput = null), (t.stableFitRemainingWidth = 0))
					}
				}
			}
			let qe = Math.floor(f * j),
				Bt = Math.min(qe, Math.max(0, Math.floor(((T - I - 2) * j) / (d + j))) + F5),
				vt = Math.floor(i * Bt),
				ae = vt / i
			vt = Math.floor(vt * K)
			let Z = u ? 1 : 2,
				se = g === "left" ? 0 : n - Bt - I
			return {
				renderMinimap: Z,
				minimapLeft: se,
				minimapWidth: Bt,
				minimapHeightIsEditorHeight: ne,
				minimapIsSampling: oe,
				minimapScale: m,
				minimapLineHeight: Y,
				minimapCanvasInnerWidth: vt,
				minimapCanvasInnerHeight: A,
				minimapCanvasOuterWidth: ae,
				minimapCanvasOuterHeight: J,
			}
		}
		static computeLayout(e, t) {
			let n = t.outerWidth | 0,
				r = t.outerHeight | 0,
				i = t.lineHeight | 0,
				s = t.lineNumbersDigitCount | 0,
				a = t.typicalHalfwidthCharacterWidth,
				l = t.maxDigitWidth,
				d = t.pixelRatio,
				c = t.viewLineCount,
				u = e.get(142),
				m = u === "inherit" ? e.get(141) : u,
				f = m === "inherit" ? e.get(137) : m,
				h = e.get(140),
				g = t.isDominatedByLongLines,
				I = e.get(59),
				C = e.get(69).renderType !== 0,
				T = e.get(70),
				w = e.get(110),
				L = e.get(88),
				A = e.get(74),
				J = e.get(108),
				ne = J.verticalScrollbarSize,
				oe = J.verticalHasArrows,
				Y = J.arrowSize,
				j = J.horizontalScrollbarSize,
				K = e.get(45),
				qe = e.get(115) !== "never",
				Bt = e.get(67)
			K && qe && (Bt += 16)
			let vt = 0
			if (C) {
				let ro = Math.max(s, T)
				vt = Math.round(ro * l)
			}
			let ae = 0
			I && (ae = i * t.glyphMarginDecorationLaneCount)
			let Z = 0,
				se = Z + ae,
				ee = se + vt,
				fe = ee + Bt,
				Ae = n - ae - vt - Bt,
				he = !1,
				de = !1,
				Et = -1
			m === "inherit" && g
				? ((he = !0), (de = !0))
				: f === "on" || f === "bounded"
					? (de = !0)
					: f === "wordWrapColumn" && (Et = h)
			let _t = o._computeMinimapLayout(
				{
					outerWidth: n,
					outerHeight: r,
					lineHeight: i,
					typicalHalfwidthCharacterWidth: a,
					pixelRatio: d,
					scrollBeyondLastLine: w,
					paddingTop: L.top,
					paddingBottom: L.bottom,
					minimap: A,
					verticalScrollbarWidth: ne,
					viewLineCount: c,
					remainingWidth: Ae,
					isViewportWrapping: de,
				},
				t.memory || new hw(),
			)
			_t.renderMinimap !== 0 &&
				_t.minimapLeft === 0 &&
				((Z += _t.minimapWidth), (se += _t.minimapWidth), (ee += _t.minimapWidth), (fe += _t.minimapWidth))
			let Te = Ae - _t.minimapWidth,
				wn = Math.max(1, Math.floor((Te - ne - 2) / a)),
				Ft = oe ? Y : 0
			return (
				de && ((Et = Math.max(1, wn)), f === "bounded" && (Et = Math.min(Et, h))),
				{
					width: n,
					height: r,
					glyphMarginLeft: Z,
					glyphMarginWidth: ae,
					glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
					lineNumbersLeft: se,
					lineNumbersWidth: vt,
					decorationsLeft: ee,
					decorationsWidth: Bt,
					contentLeft: fe,
					contentWidth: Te,
					minimap: _t,
					viewportColumn: wn,
					isWordWrapMinified: he,
					isViewportWrapping: de,
					wrappingColumn: Et,
					verticalScrollbarWidth: ne,
					horizontalScrollbarHeight: j,
					overviewRuler: { top: Ft, width: ne, height: r - 2 * Ft, right: 0 },
				}
			)
		}
	},
	Aw = class extends pt {
		constructor() {
			super(144, "wrappingStrategy", "simple", {
				"editor.wrappingStrategy": {
					enumDescriptions: [
						p(
							"wrappingStrategy.simple",
							"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.",
						),
						p(
							"wrappingStrategy.advanced",
							"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.",
						),
					],
					type: "string",
					enum: ["simple", "advanced"],
					default: "simple",
					description: p(
						"wrappingStrategy",
						"Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.",
					),
				},
			})
		}
		validate(e) {
			return St(e, "simple", ["simple", "advanced"])
		}
		compute(e, t, n) {
			return t.get(2) === 2 ? "advanced" : n
		}
	}
var Ow = class extends pt {
		constructor() {
			let e = { enabled: "onCode" }
			super(66, "lightbulb", e, {
				"editor.lightbulb.enabled": {
					type: "string",
					enum: ["off", "onCode", "on"],
					default: e.enabled,
					enumDescriptions: [
						p("editor.lightbulb.enabled.off", "Disable the code action menu."),
						p(
							"editor.lightbulb.enabled.onCode",
							"Show the code action menu when the cursor is on lines with code.",
						),
						p(
							"editor.lightbulb.enabled.on",
							"Show the code action menu when the cursor is on lines with code or on empty lines.",
						),
					],
					description: p("enabled", "Enables the Code Action lightbulb in the editor."),
				},
			})
		}
		validate(e) {
			return !e || typeof e != "object"
				? this.defaultValue
				: { enabled: St(e.enabled, this.defaultValue.enabled, ["off", "onCode", "on"]) }
		}
	},
	Lw = class extends pt {
		constructor() {
			let e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 }
			super(120, "stickyScroll", e, {
				"editor.stickyScroll.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"editor.stickyScroll.enabled",
						"Shows the nested current scopes during the scroll at the top of the editor.",
					),
				},
				"editor.stickyScroll.maxLineCount": {
					type: "number",
					default: e.maxLineCount,
					minimum: 1,
					maximum: 20,
					description: p(
						"editor.stickyScroll.maxLineCount",
						"Defines the maximum number of sticky lines to show.",
					),
				},
				"editor.stickyScroll.defaultModel": {
					type: "string",
					enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
					default: e.defaultModel,
					description: p(
						"editor.stickyScroll.defaultModel",
						"Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.",
					),
				},
				"editor.stickyScroll.scrollWithEditor": {
					type: "boolean",
					default: e.scrollWithEditor,
					description: p(
						"editor.stickyScroll.scrollWithEditor",
						"Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				maxLineCount: tt.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
				defaultModel: St(t.defaultModel, this.defaultValue.defaultModel, [
					"outlineModel",
					"foldingProviderModel",
					"indentationModel",
				]),
				scrollWithEditor: re(t.scrollWithEditor, this.defaultValue.scrollWithEditor),
			}
		}
	},
	Mw = class extends pt {
		constructor() {
			let e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1, maximumLength: 43 }
			super(146, "inlayHints", e, {
				"editor.inlayHints.enabled": {
					type: "string",
					default: e.enabled,
					description: p("inlayHints.enable", "Enables the inlay hints in the editor."),
					enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
					markdownEnumDescriptions: [
						p("editor.inlayHints.on", "Inlay hints are enabled"),
						p(
							"editor.inlayHints.onUnlessPressed",
							"Inlay hints are showing by default and hide when holding {0}",
							st ? "Ctrl+Option" : "Ctrl+Alt",
						),
						p(
							"editor.inlayHints.offUnlessPressed",
							"Inlay hints are hidden by default and show when holding {0}",
							st ? "Ctrl+Option" : "Ctrl+Alt",
						),
						p("editor.inlayHints.off", "Inlay hints are disabled"),
					],
				},
				"editor.inlayHints.fontSize": {
					type: "number",
					default: e.fontSize,
					markdownDescription: p(
						"inlayHints.fontSize",
						"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.",
						"`#editor.fontSize#`",
						"`5`",
					),
				},
				"editor.inlayHints.fontFamily": {
					type: "string",
					default: e.fontFamily,
					markdownDescription: p(
						"inlayHints.fontFamily",
						"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.",
						"`#editor.fontFamily#`",
					),
				},
				"editor.inlayHints.padding": {
					type: "boolean",
					default: e.padding,
					description: p("inlayHints.padding", "Enables the padding around the inlay hints in the editor."),
				},
				"editor.inlayHints.maximumLength": {
					type: "number",
					default: e.maximumLength,
					markdownDescription: p(
						"inlayHints.maximumLength",
						"Maximum overall length of inlay hints, for a single line, before they get truncated by the editor. Set to `0` to never truncate",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return (
				typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"),
				{
					enabled: St(t.enabled, this.defaultValue.enabled, [
						"on",
						"off",
						"offUnlessPressed",
						"onUnlessPressed",
					]),
					fontSize: tt.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
					fontFamily: Jn.string(t.fontFamily, this.defaultValue.fontFamily),
					padding: re(t.padding, this.defaultValue.padding),
					maximumLength: tt.clampedInt(
						t.maximumLength,
						this.defaultValue.maximumLength,
						0,
						Number.MAX_SAFE_INTEGER,
					),
				}
			)
		}
	},
	Fw = class extends pt {
		constructor() {
			super(67, "lineDecorationsWidth", 10)
		}
		validate(e) {
			return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e)
				? -parseFloat(e.substring(0, e.length - 2))
				: tt.clampedInt(e, this.defaultValue, 0, 1e3)
		}
		compute(e, t, n) {
			return n < 0 ? tt.clampedInt(-n * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : n
		}
	},
	Nw = class extends co {
		constructor() {
			super(68, "lineHeight", is.lineHeight, (e) => co.clamp(e, 0, 150), {
				markdownDescription: p(
					"lineHeight",
					`Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`,
				),
			})
		}
		compute(e, t, n) {
			return e.fontInfo.lineHeight
		}
	},
	Uw = class extends pt {
		constructor() {
			let e = {
				enabled: !0,
				size: "proportional",
				side: "right",
				showSlider: "mouseover",
				autohide: !1,
				renderCharacters: !0,
				maxColumn: 120,
				scale: 1,
				showRegionSectionHeaders: !0,
				showMarkSectionHeaders: !0,
				markSectionHeaderRegex: "\\bMARK:\\s*(?<separator>-?)\\s*(?<label>.*)$",
				sectionHeaderFontSize: 9,
				sectionHeaderLetterSpacing: 1,
			}
			super(74, "minimap", e, {
				"editor.minimap.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p("minimap.enabled", "Controls whether the minimap is shown."),
				},
				"editor.minimap.autohide": {
					type: "boolean",
					default: e.autohide,
					description: p("minimap.autohide", "Controls whether the minimap is hidden automatically."),
				},
				"editor.minimap.size": {
					type: "string",
					enum: ["proportional", "fill", "fit"],
					enumDescriptions: [
						p(
							"minimap.size.proportional",
							"The minimap has the same size as the editor contents (and might scroll).",
						),
						p(
							"minimap.size.fill",
							"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).",
						),
						p(
							"minimap.size.fit",
							"The minimap will shrink as necessary to never be larger than the editor (no scrolling).",
						),
					],
					default: e.size,
					description: p("minimap.size", "Controls the size of the minimap."),
				},
				"editor.minimap.side": {
					type: "string",
					enum: ["left", "right"],
					default: e.side,
					description: p("minimap.side", "Controls the side where to render the minimap."),
				},
				"editor.minimap.showSlider": {
					type: "string",
					enum: ["always", "mouseover"],
					default: e.showSlider,
					description: p("minimap.showSlider", "Controls when the minimap slider is shown."),
				},
				"editor.minimap.scale": {
					type: "number",
					default: e.scale,
					minimum: 1,
					maximum: 3,
					enum: [1, 2, 3],
					description: p("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3."),
				},
				"editor.minimap.renderCharacters": {
					type: "boolean",
					default: e.renderCharacters,
					description: p(
						"minimap.renderCharacters",
						"Render the actual characters on a line as opposed to color blocks.",
					),
				},
				"editor.minimap.maxColumn": {
					type: "number",
					default: e.maxColumn,
					description: p(
						"minimap.maxColumn",
						"Limit the width of the minimap to render at most a certain number of columns.",
					),
				},
				"editor.minimap.showRegionSectionHeaders": {
					type: "boolean",
					default: e.showRegionSectionHeaders,
					description: p(
						"minimap.showRegionSectionHeaders",
						"Controls whether named regions are shown as section headers in the minimap.",
					),
				},
				"editor.minimap.showMarkSectionHeaders": {
					type: "boolean",
					default: e.showMarkSectionHeaders,
					description: p(
						"minimap.showMarkSectionHeaders",
						"Controls whether MARK: comments are shown as section headers in the minimap.",
					),
				},
				"editor.minimap.markSectionHeaderRegex": {
					type: "string",
					default: e.markSectionHeaderRegex,
					description: p(
						"minimap.markSectionHeaderRegex",
						"Defines the regular expression used to find section headers in comments. The regex must contain a named match group `label` (written as `(?<label>.+)`) that encapsulates the section header, otherwise it will not work. Optionally you can include another match group named `separator`. Use \\n in the pattern to match multi-line headers.",
					),
				},
				"editor.minimap.sectionHeaderFontSize": {
					type: "number",
					default: e.sectionHeaderFontSize,
					description: p(
						"minimap.sectionHeaderFontSize",
						"Controls the font size of section headers in the minimap.",
					),
				},
				"editor.minimap.sectionHeaderLetterSpacing": {
					type: "number",
					default: e.sectionHeaderLetterSpacing,
					description: p(
						"minimap.sectionHeaderLetterSpacing",
						"Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e,
				n = this.defaultValue.markSectionHeaderRegex,
				r = e.markSectionHeaderRegex
			if (typeof r == "string")
				try {
					new RegExp(r, "d"), (n = r)
				} catch {}
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				autohide: re(t.autohide, this.defaultValue.autohide),
				size: St(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
				side: St(t.side, this.defaultValue.side, ["right", "left"]),
				showSlider: St(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
				renderCharacters: re(t.renderCharacters, this.defaultValue.renderCharacters),
				scale: tt.clampedInt(t.scale, 1, 1, 3),
				maxColumn: tt.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
				showRegionSectionHeaders: re(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
				showMarkSectionHeaders: re(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
				markSectionHeaderRegex: n,
				sectionHeaderFontSize: co.clamp(
					t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize,
					4,
					32,
				),
				sectionHeaderLetterSpacing: co.clamp(
					t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing,
					0,
					5,
				),
			}
		}
	}
function W5(o) {
	return o === "ctrlCmd" ? (st ? "metaKey" : "ctrlKey") : "altKey"
}
var Hw = class extends pt {
		constructor() {
			super(
				88,
				"padding",
				{ top: 0, bottom: 0 },
				{
					"editor.padding.top": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1e3,
						description: p(
							"padding.top",
							"Controls the amount of space between the top edge of the editor and the first line.",
						),
					},
					"editor.padding.bottom": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1e3,
						description: p(
							"padding.bottom",
							"Controls the amount of space between the bottom edge of the editor and the last line.",
						),
					},
				},
			)
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return { top: tt.clampedInt(t.top, 0, 0, 1e3), bottom: tt.clampedInt(t.bottom, 0, 0, 1e3) }
		}
	},
	Ww = class extends pt {
		constructor() {
			let e = { enabled: !0, cycle: !0 }
			super(90, "parameterHints", e, {
				"editor.parameterHints.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"parameterHints.enabled",
						"Enables a pop-up that shows parameter documentation and type information as you type.",
					),
				},
				"editor.parameterHints.cycle": {
					type: "boolean",
					default: e.cycle,
					description: p(
						"parameterHints.cycle",
						"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return { enabled: re(t.enabled, this.defaultValue.enabled), cycle: re(t.cycle, this.defaultValue.cycle) }
		}
	},
	Vw = class extends ss {
		constructor() {
			super(149)
		}
		compute(e, t, n) {
			return e.pixelRatio
		}
	},
	Bw = class extends pt {
		constructor() {
			super(92, "placeholder", void 0)
		}
		validate(e) {
			return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue
		}
	},
	$w = class extends pt {
		constructor() {
			let e = { other: "on", comments: "off", strings: "off" },
				t = [
					{ type: "boolean" },
					{
						type: "string",
						enum: ["on", "inline", "off"],
						enumDescriptions: [
							p("on", "Quick suggestions show inside the suggest widget"),
							p("inline", "Quick suggestions show as ghost text"),
							p("off", "Quick suggestions are disabled"),
						],
					},
				]
			super(94, "quickSuggestions", e, {
				type: "object",
				additionalProperties: !1,
				properties: {
					strings: {
						anyOf: t,
						default: e.strings,
						description: p("quickSuggestions.strings", "Enable quick suggestions inside strings."),
					},
					comments: {
						anyOf: t,
						default: e.comments,
						description: p("quickSuggestions.comments", "Enable quick suggestions inside comments."),
					},
					other: {
						anyOf: t,
						default: e.other,
						description: p(
							"quickSuggestions.other",
							"Enable quick suggestions outside of strings and comments.",
						),
					},
				},
				default: e,
				markdownDescription: p(
					"quickSuggestions",
					"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.",
					"`#editor.suggestOnTriggerCharacters#`",
				),
			}),
				(this.defaultValue = e)
		}
		validate(e) {
			if (typeof e == "boolean") {
				let d = e ? "on" : "off"
				return { comments: d, strings: d, other: d }
			}
			if (!e || typeof e != "object") return this.defaultValue
			let { other: t, comments: n, strings: r } = e,
				i = ["on", "inline", "off"],
				s,
				a,
				l
			return (
				typeof t == "boolean" ? (s = t ? "on" : "off") : (s = St(t, this.defaultValue.other, i)),
				typeof n == "boolean" ? (a = n ? "on" : "off") : (a = St(n, this.defaultValue.comments, i)),
				typeof r == "boolean" ? (l = r ? "on" : "off") : (l = St(r, this.defaultValue.strings, i)),
				{ other: s, comments: a, strings: l }
			)
		}
	}
var zw = class extends pt {
	constructor() {
		super(
			69,
			"lineNumbers",
			{ renderType: 1, renderFn: null },
			{
				type: "string",
				enum: ["off", "on", "relative", "interval"],
				enumDescriptions: [
					p("lineNumbers.off", "Line numbers are not rendered."),
					p("lineNumbers.on", "Line numbers are rendered as absolute number."),
					p("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
					p("lineNumbers.interval", "Line numbers are rendered every 10 lines."),
				],
				default: "on",
				description: p("lineNumbers", "Controls the display of line numbers."),
			},
		)
	}
	validate(e) {
		let t = this.defaultValue.renderType,
			n = this.defaultValue.renderFn
		return (
			typeof e < "u" &&
				(typeof e == "function"
					? ((t = 4), (n = e))
					: e === "interval"
						? (t = 3)
						: e === "relative"
							? (t = 2)
							: e === "on"
								? (t = 1)
								: (t = 0)),
			{ renderType: t, renderFn: n }
		)
	}
}
var qw = class extends pt {
		constructor() {
			let e = [],
				t = {
					type: "number",
					description: p(
						"rulers.size",
						"Number of monospace characters at which this editor ruler will render.",
					),
				}
			super(107, "rulers", e, {
				type: "array",
				items: {
					anyOf: [
						t,
						{
							type: ["object"],
							properties: {
								column: t,
								color: {
									type: "string",
									description: p("rulers.color", "Color of this editor ruler."),
									format: "color-hex",
								},
							},
						},
					],
				},
				default: e,
				description: p(
					"rulers",
					"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.",
				),
			})
		}
		validate(e) {
			if (Array.isArray(e)) {
				let t = []
				for (let n of e)
					if (typeof n == "number") t.push({ column: tt.clampedInt(n, 0, 0, 1e4), color: null })
					else if (n && typeof n == "object") {
						let r = n
						t.push({ column: tt.clampedInt(r.column, 0, 0, 1e4), color: r.color })
					}
				return t.sort((n, r) => n.column - r.column), t
			}
			return this.defaultValue
		}
	},
	Kw = class extends pt {
		constructor() {
			super(97, "readOnlyMessage", void 0)
		}
		validate(e) {
			return !e || typeof e != "object" ? this.defaultValue : e
		}
	}
function GO(o, e) {
	if (typeof o != "string") return e
	switch (o) {
		case "hidden":
			return 2
		case "visible":
			return 3
		default:
			return 1
	}
}
var jw = class extends pt {
		constructor() {
			let e = {
				vertical: 1,
				horizontal: 1,
				arrowSize: 11,
				useShadows: !0,
				verticalHasArrows: !1,
				horizontalHasArrows: !1,
				horizontalScrollbarSize: 12,
				horizontalSliderSize: 12,
				verticalScrollbarSize: 14,
				verticalSliderSize: 14,
				handleMouseWheel: !0,
				alwaysConsumeMouseWheel: !0,
				scrollByPage: !1,
				ignoreHorizontalScrollbarInContentHeight: !1,
			}
			super(108, "scrollbar", e, {
				"editor.scrollbar.vertical": {
					type: "string",
					enum: ["auto", "visible", "hidden"],
					enumDescriptions: [
						p("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
						p("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
						p("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden."),
					],
					default: "auto",
					description: p("scrollbar.vertical", "Controls the visibility of the vertical scrollbar."),
				},
				"editor.scrollbar.horizontal": {
					type: "string",
					enum: ["auto", "visible", "hidden"],
					enumDescriptions: [
						p("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
						p("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
						p("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden."),
					],
					default: "auto",
					description: p("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar."),
				},
				"editor.scrollbar.verticalScrollbarSize": {
					type: "number",
					default: e.verticalScrollbarSize,
					description: p("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar."),
				},
				"editor.scrollbar.horizontalScrollbarSize": {
					type: "number",
					default: e.horizontalScrollbarSize,
					description: p("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar."),
				},
				"editor.scrollbar.scrollByPage": {
					type: "boolean",
					default: e.scrollByPage,
					description: p(
						"scrollbar.scrollByPage",
						"Controls whether clicks scroll by page or jump to click position.",
					),
				},
				"editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
					type: "boolean",
					default: e.ignoreHorizontalScrollbarInContentHeight,
					description: p(
						"scrollbar.ignoreHorizontalScrollbarInContentHeight",
						"When set, the horizontal scrollbar will not increase the size of the editor's content.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e,
				n = tt.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3),
				r = tt.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3)
			return {
				arrowSize: tt.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
				vertical: GO(t.vertical, this.defaultValue.vertical),
				horizontal: GO(t.horizontal, this.defaultValue.horizontal),
				useShadows: re(t.useShadows, this.defaultValue.useShadows),
				verticalHasArrows: re(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
				horizontalHasArrows: re(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
				handleMouseWheel: re(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
				alwaysConsumeMouseWheel: re(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
				horizontalScrollbarSize: n,
				horizontalSliderSize: tt.clampedInt(t.horizontalSliderSize, n, 0, 1e3),
				verticalScrollbarSize: r,
				verticalSliderSize: tt.clampedInt(t.verticalSliderSize, r, 0, 1e3),
				scrollByPage: re(t.scrollByPage, this.defaultValue.scrollByPage),
				ignoreHorizontalScrollbarInContentHeight: re(
					t.ignoreHorizontalScrollbarInContentHeight,
					this.defaultValue.ignoreHorizontalScrollbarInContentHeight,
				),
			}
		}
	},
	Vo = "inUntrustedWorkspace",
	jl = {
		allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
		invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
		nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
		ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
		includeComments: "editor.unicodeHighlight.includeComments",
		includeStrings: "editor.unicodeHighlight.includeStrings",
		allowedLocales: "editor.unicodeHighlight.allowedLocales",
	},
	Gw = class extends pt {
		constructor() {
			let e = {
				nonBasicASCII: Vo,
				invisibleCharacters: !0,
				ambiguousCharacters: !0,
				includeComments: Vo,
				includeStrings: !0,
				allowedCharacters: {},
				allowedLocales: { _os: !0, _vscode: !0 },
			}
			super(130, "unicodeHighlight", e, {
				[jl.nonBasicASCII]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Vo],
					default: e.nonBasicASCII,
					description: p(
						"unicodeHighlight.nonBasicASCII",
						"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.",
					),
				},
				[jl.invisibleCharacters]: {
					restricted: !0,
					type: "boolean",
					default: e.invisibleCharacters,
					description: p(
						"unicodeHighlight.invisibleCharacters",
						"Controls whether characters that just reserve space or have no width at all are highlighted.",
					),
				},
				[jl.ambiguousCharacters]: {
					restricted: !0,
					type: "boolean",
					default: e.ambiguousCharacters,
					description: p(
						"unicodeHighlight.ambiguousCharacters",
						"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.",
					),
				},
				[jl.includeComments]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Vo],
					default: e.includeComments,
					description: p(
						"unicodeHighlight.includeComments",
						"Controls whether characters in comments should also be subject to Unicode highlighting.",
					),
				},
				[jl.includeStrings]: {
					restricted: !0,
					type: ["boolean", "string"],
					enum: [!0, !1, Vo],
					default: e.includeStrings,
					description: p(
						"unicodeHighlight.includeStrings",
						"Controls whether characters in strings should also be subject to Unicode highlighting.",
					),
				},
				[jl.allowedCharacters]: {
					restricted: !0,
					type: "object",
					default: e.allowedCharacters,
					description: p(
						"unicodeHighlight.allowedCharacters",
						"Defines allowed characters that are not being highlighted.",
					),
					additionalProperties: { type: "boolean" },
				},
				[jl.allowedLocales]: {
					restricted: !0,
					type: "object",
					additionalProperties: { type: "boolean" },
					default: e.allowedLocales,
					description: p(
						"unicodeHighlight.allowedLocales",
						"Unicode characters that are common in allowed locales are not being highlighted.",
					),
				},
			})
		}
		applyUpdate(e, t) {
			let n = !1
			t.allowedCharacters &&
				e &&
				(nn(e.allowedCharacters, t.allowedCharacters) ||
					((e = { ...e, allowedCharacters: t.allowedCharacters }), (n = !0))),
				t.allowedLocales &&
					e &&
					(nn(e.allowedLocales, t.allowedLocales) ||
						((e = { ...e, allowedLocales: t.allowedLocales }), (n = !0)))
			let r = super.applyUpdate(e, t)
			return n ? new Mc(r.newValue, !0) : r
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				nonBasicASCII: Fc(t.nonBasicASCII, Vo, [!0, !1, Vo]),
				invisibleCharacters: re(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
				ambiguousCharacters: re(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
				includeComments: Fc(t.includeComments, Vo, [!0, !1, Vo]),
				includeStrings: Fc(t.includeStrings, Vo, [!0, !1, Vo]),
				allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
				allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales),
			}
		}
		validateBooleanMap(e, t) {
			if (typeof e != "object" || !e) return t
			let n = {}
			for (let [r, i] of Object.entries(e)) i === !0 && (n[r] = !0)
			return n
		}
	},
	Qw = class extends pt {
		constructor() {
			let e = {
				enabled: !0,
				mode: "subwordSmart",
				showToolbar: "onHover",
				suppressSuggestions: !1,
				keepOnBlur: !1,
				fontFamily: "default",
				syntaxHighlightingEnabled: !0,
				edits: {
					enabled: !0,
					showCollapsed: !1,
					renderSideBySide: "auto",
					allowCodeShifting: "always",
					useMultiLineGhostText: !0,
				},
			}
			super(64, "inlineSuggest", e, {
				"editor.inlineSuggest.enabled": {
					type: "boolean",
					default: e.enabled,
					description: p(
						"inlineSuggest.enabled",
						"Controls whether to automatically show inline suggestions in the editor.",
					),
				},
				"editor.inlineSuggest.showToolbar": {
					type: "string",
					default: e.showToolbar,
					enum: ["always", "onHover", "never"],
					enumDescriptions: [
						p(
							"inlineSuggest.showToolbar.always",
							"Show the inline suggestion toolbar whenever an inline suggestion is shown.",
						),
						p(
							"inlineSuggest.showToolbar.onHover",
							"Show the inline suggestion toolbar when hovering over an inline suggestion.",
						),
						p("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar."),
					],
					description: p("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar."),
				},
				"editor.inlineSuggest.syntaxHighlightingEnabled": {
					type: "boolean",
					default: e.syntaxHighlightingEnabled,
					description: p(
						"inlineSuggest.syntaxHighlightingEnabled",
						"Controls whether to show syntax highlighting for inline suggestions in the editor.",
					),
				},
				"editor.inlineSuggest.suppressSuggestions": {
					type: "boolean",
					default: e.suppressSuggestions,
					description: p(
						"inlineSuggest.suppressSuggestions",
						"Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.",
					),
				},
				"editor.inlineSuggest.fontFamily": {
					type: "string",
					default: e.fontFamily,
					description: p("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions."),
				},
				"editor.inlineSuggest.edits.allowCodeShifting": {
					type: "string",
					default: e.edits.allowCodeShifting,
					description: p(
						"inlineSuggest.edits.allowCodeShifting",
						"Controls whether showing a suggestion will shift the code to make space for the suggestion inline.",
					),
					enum: ["always", "horizontal", "never"],
					tags: ["nextEditSuggestions"],
				},
				"editor.inlineSuggest.edits.renderSideBySide": {
					type: "string",
					default: e.edits.renderSideBySide,
					description: p(
						"inlineSuggest.edits.renderSideBySide",
						"Controls whether larger suggestions can be shown side by side.",
					),
					enum: ["auto", "never"],
					enumDescriptions: [
						p(
							"editor.inlineSuggest.edits.renderSideBySide.auto",
							"Larger suggestions will show side by side if there is enough space, otherwise they will be shown below.",
						),
						p(
							"editor.inlineSuggest.edits.renderSideBySide.never",
							"Larger suggestions are never shown side by side and will always be shown below.",
						),
					],
					tags: ["nextEditSuggestions"],
				},
				"editor.inlineSuggest.edits.showCollapsed": {
					type: "boolean",
					default: e.edits.showCollapsed,
					description: p(
						"inlineSuggest.edits.showCollapsed",
						"Controls whether the suggestion will show as collapsed until jumping to it.",
					),
					tags: ["nextEditSuggestions"],
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				mode: St(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
				showToolbar: St(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
				suppressSuggestions: re(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
				keepOnBlur: re(t.keepOnBlur, this.defaultValue.keepOnBlur),
				fontFamily: Jn.string(t.fontFamily, this.defaultValue.fontFamily),
				syntaxHighlightingEnabled: re(t.syntaxHighlightingEnabled, this.defaultValue.syntaxHighlightingEnabled),
				edits: {
					enabled: re(t.edits?.enabled, this.defaultValue.edits.enabled),
					showCollapsed: re(t.edits?.showCollapsed, this.defaultValue.edits.showCollapsed),
					allowCodeShifting: St(t.edits?.allowCodeShifting, this.defaultValue.edits.allowCodeShifting, [
						"always",
						"horizontal",
						"never",
					]),
					renderSideBySide: St(t.edits?.renderSideBySide, this.defaultValue.edits.renderSideBySide, [
						"never",
						"auto",
					]),
					useMultiLineGhostText: re(
						t.edits?.useMultiLineGhostText,
						this.defaultValue.edits.useMultiLineGhostText,
					),
				},
			}
		}
	},
	Jw = class extends pt {
		constructor() {
			let e = {
				enabled: dw.bracketPairColorizationOptions.enabled,
				independentColorPoolPerBracketType:
					dw.bracketPairColorizationOptions.independentColorPoolPerBracketType,
			}
			super(15, "bracketPairColorization", e, {
				"editor.bracketPairColorization.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"bracketPairColorization.enabled",
						"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.",
						"`#workbench.colorCustomizations#`",
					),
				},
				"editor.bracketPairColorization.independentColorPoolPerBracketType": {
					type: "boolean",
					default: e.independentColorPoolPerBracketType,
					description: p(
						"bracketPairColorization.independentColorPoolPerBracketType",
						"Controls whether each bracket type has its own independent color pool.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				independentColorPoolPerBracketType: re(
					t.independentColorPoolPerBracketType,
					this.defaultValue.independentColorPoolPerBracketType,
				),
			}
		}
	},
	Xw = class extends pt {
		constructor() {
			let e = {
				bracketPairs: !1,
				bracketPairsHorizontal: "active",
				highlightActiveBracketPair: !0,
				indentation: !0,
				highlightActiveIndentation: !0,
			}
			super(16, "guides", e, {
				"editor.guides.bracketPairs": {
					type: ["boolean", "string"],
					enum: [!0, "active", !1],
					enumDescriptions: [
						p("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
						p(
							"editor.guides.bracketPairs.active",
							"Enables bracket pair guides only for the active bracket pair.",
						),
						p("editor.guides.bracketPairs.false", "Disables bracket pair guides."),
					],
					default: e.bracketPairs,
					description: p(
						"editor.guides.bracketPairs",
						"Controls whether bracket pair guides are enabled or not.",
					),
				},
				"editor.guides.bracketPairsHorizontal": {
					type: ["boolean", "string"],
					enum: [!0, "active", !1],
					enumDescriptions: [
						p(
							"editor.guides.bracketPairsHorizontal.true",
							"Enables horizontal guides as addition to vertical bracket pair guides.",
						),
						p(
							"editor.guides.bracketPairsHorizontal.active",
							"Enables horizontal guides only for the active bracket pair.",
						),
						p("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides."),
					],
					default: e.bracketPairsHorizontal,
					description: p(
						"editor.guides.bracketPairsHorizontal",
						"Controls whether horizontal bracket pair guides are enabled or not.",
					),
				},
				"editor.guides.highlightActiveBracketPair": {
					type: "boolean",
					default: e.highlightActiveBracketPair,
					description: p(
						"editor.guides.highlightActiveBracketPair",
						"Controls whether the editor should highlight the active bracket pair.",
					),
				},
				"editor.guides.indentation": {
					type: "boolean",
					default: e.indentation,
					description: p(
						"editor.guides.indentation",
						"Controls whether the editor should render indent guides.",
					),
				},
				"editor.guides.highlightActiveIndentation": {
					type: ["boolean", "string"],
					enum: [!0, "always", !1],
					enumDescriptions: [
						p("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
						p(
							"editor.guides.highlightActiveIndentation.always",
							"Highlights the active indent guide even if bracket guides are highlighted.",
						),
						p(
							"editor.guides.highlightActiveIndentation.false",
							"Do not highlight the active indent guide.",
						),
					],
					default: e.highlightActiveIndentation,
					description: p(
						"editor.guides.highlightActiveIndentation",
						"Controls whether the editor should highlight the active indent guide.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				bracketPairs: Fc(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
				bracketPairsHorizontal: Fc(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [
					!0,
					!1,
					"active",
				]),
				highlightActiveBracketPair: re(
					t.highlightActiveBracketPair,
					this.defaultValue.highlightActiveBracketPair,
				),
				indentation: re(t.indentation, this.defaultValue.indentation),
				highlightActiveIndentation: Fc(
					t.highlightActiveIndentation,
					this.defaultValue.highlightActiveIndentation,
					[!0, !1, "always"],
				),
			}
		}
	}
function Fc(o, e, t) {
	let n = t.indexOf(o)
	return n === -1 ? e : t[n]
}
var Yw = class extends pt {
		constructor() {
			let e = {
				insertMode: "insert",
				filterGraceful: !0,
				snippetsPreventQuickSuggestions: !1,
				localityBonus: !1,
				shareSuggestSelections: !1,
				selectionMode: "always",
				showIcons: !0,
				showStatusBar: !1,
				preview: !1,
				previewMode: "subwordSmart",
				showInlineDetails: !0,
				showMethods: !0,
				showFunctions: !0,
				showConstructors: !0,
				showDeprecated: !0,
				matchOnWordStartOnly: !0,
				showFields: !0,
				showVariables: !0,
				showClasses: !0,
				showStructs: !0,
				showInterfaces: !0,
				showModules: !0,
				showProperties: !0,
				showEvents: !0,
				showOperators: !0,
				showUnits: !0,
				showValues: !0,
				showConstants: !0,
				showEnums: !0,
				showEnumMembers: !0,
				showKeywords: !0,
				showWords: !0,
				showColors: !0,
				showFiles: !0,
				showReferences: !0,
				showFolders: !0,
				showTypeParameters: !0,
				showSnippets: !0,
				showUsers: !0,
				showIssues: !0,
			}
			super(123, "suggest", e, {
				"editor.suggest.insertMode": {
					type: "string",
					enum: ["insert", "replace"],
					enumDescriptions: [
						p(
							"suggest.insertMode.insert",
							"Insert suggestion without overwriting text right of the cursor.",
						),
						p("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor."),
					],
					default: e.insertMode,
					description: p(
						"suggest.insertMode",
						"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.",
					),
				},
				"editor.suggest.filterGraceful": {
					type: "boolean",
					default: e.filterGraceful,
					description: p(
						"suggest.filterGraceful",
						"Controls whether filtering and sorting suggestions accounts for small typos.",
					),
				},
				"editor.suggest.localityBonus": {
					type: "boolean",
					default: e.localityBonus,
					description: p(
						"suggest.localityBonus",
						"Controls whether sorting favors words that appear close to the cursor.",
					),
				},
				"editor.suggest.shareSuggestSelections": {
					type: "boolean",
					default: e.shareSuggestSelections,
					markdownDescription: p(
						"suggest.shareSuggestSelections",
						"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).",
					),
				},
				"editor.suggest.selectionMode": {
					type: "string",
					enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
					enumDescriptions: [
						p(
							"suggest.insertMode.always",
							"Always select a suggestion when automatically triggering IntelliSense.",
						),
						p(
							"suggest.insertMode.never",
							"Never select a suggestion when automatically triggering IntelliSense.",
						),
						p(
							"suggest.insertMode.whenTriggerCharacter",
							"Select a suggestion only when triggering IntelliSense from a trigger character.",
						),
						p(
							"suggest.insertMode.whenQuickSuggestion",
							"Select a suggestion only when triggering IntelliSense as you type.",
						),
					],
					default: e.selectionMode,
					markdownDescription: p(
						"suggest.selectionMode",
						"Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.",
						"`#editor.quickSuggestions#`",
						"`#editor.suggestOnTriggerCharacters#`",
					),
				},
				"editor.suggest.snippetsPreventQuickSuggestions": {
					type: "boolean",
					default: e.snippetsPreventQuickSuggestions,
					description: p(
						"suggest.snippetsPreventQuickSuggestions",
						"Controls whether an active snippet prevents quick suggestions.",
					),
				},
				"editor.suggest.showIcons": {
					type: "boolean",
					default: e.showIcons,
					description: p("suggest.showIcons", "Controls whether to show or hide icons in suggestions."),
				},
				"editor.suggest.showStatusBar": {
					type: "boolean",
					default: e.showStatusBar,
					description: p(
						"suggest.showStatusBar",
						"Controls the visibility of the status bar at the bottom of the suggest widget.",
					),
				},
				"editor.suggest.preview": {
					type: "boolean",
					default: e.preview,
					description: p(
						"suggest.preview",
						"Controls whether to preview the suggestion outcome in the editor.",
					),
				},
				"editor.suggest.showInlineDetails": {
					type: "boolean",
					default: e.showInlineDetails,
					description: p(
						"suggest.showInlineDetails",
						"Controls whether suggest details show inline with the label or only in the details widget.",
					),
				},
				"editor.suggest.maxVisibleSuggestions": {
					type: "number",
					deprecationMessage: p(
						"suggest.maxVisibleSuggestions.dep",
						"This setting is deprecated. The suggest widget can now be resized.",
					),
				},
				"editor.suggest.filteredTypes": {
					type: "object",
					deprecationMessage: p(
						"deprecated",
						"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.",
					),
				},
				"editor.suggest.showMethods": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showMethods",
						"When enabled IntelliSense shows `method`-suggestions.",
					),
				},
				"editor.suggest.showFunctions": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFunctions",
						"When enabled IntelliSense shows `function`-suggestions.",
					),
				},
				"editor.suggest.showConstructors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showConstructors",
						"When enabled IntelliSense shows `constructor`-suggestions.",
					),
				},
				"editor.suggest.showDeprecated": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showDeprecated",
						"When enabled IntelliSense shows `deprecated`-suggestions.",
					),
				},
				"editor.suggest.matchOnWordStartOnly": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.matchOnWordStartOnly",
						"When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.",
					),
				},
				"editor.suggest.showFields": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFields",
						"When enabled IntelliSense shows `field`-suggestions.",
					),
				},
				"editor.suggest.showVariables": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showVariables",
						"When enabled IntelliSense shows `variable`-suggestions.",
					),
				},
				"editor.suggest.showClasses": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showClasss",
						"When enabled IntelliSense shows `class`-suggestions.",
					),
				},
				"editor.suggest.showStructs": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showStructs",
						"When enabled IntelliSense shows `struct`-suggestions.",
					),
				},
				"editor.suggest.showInterfaces": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showInterfaces",
						"When enabled IntelliSense shows `interface`-suggestions.",
					),
				},
				"editor.suggest.showModules": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showModules",
						"When enabled IntelliSense shows `module`-suggestions.",
					),
				},
				"editor.suggest.showProperties": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showPropertys",
						"When enabled IntelliSense shows `property`-suggestions.",
					),
				},
				"editor.suggest.showEvents": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEvents",
						"When enabled IntelliSense shows `event`-suggestions.",
					),
				},
				"editor.suggest.showOperators": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showOperators",
						"When enabled IntelliSense shows `operator`-suggestions.",
					),
				},
				"editor.suggest.showUnits": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showUnits",
						"When enabled IntelliSense shows `unit`-suggestions.",
					),
				},
				"editor.suggest.showValues": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showValues",
						"When enabled IntelliSense shows `value`-suggestions.",
					),
				},
				"editor.suggest.showConstants": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showConstants",
						"When enabled IntelliSense shows `constant`-suggestions.",
					),
				},
				"editor.suggest.showEnums": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEnums",
						"When enabled IntelliSense shows `enum`-suggestions.",
					),
				},
				"editor.suggest.showEnumMembers": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showEnumMembers",
						"When enabled IntelliSense shows `enumMember`-suggestions.",
					),
				},
				"editor.suggest.showKeywords": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showKeywords",
						"When enabled IntelliSense shows `keyword`-suggestions.",
					),
				},
				"editor.suggest.showWords": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showTexts",
						"When enabled IntelliSense shows `text`-suggestions.",
					),
				},
				"editor.suggest.showColors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showColors",
						"When enabled IntelliSense shows `color`-suggestions.",
					),
				},
				"editor.suggest.showFiles": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFiles",
						"When enabled IntelliSense shows `file`-suggestions.",
					),
				},
				"editor.suggest.showReferences": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showReferences",
						"When enabled IntelliSense shows `reference`-suggestions.",
					),
				},
				"editor.suggest.showCustomcolors": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showCustomcolors",
						"When enabled IntelliSense shows `customcolor`-suggestions.",
					),
				},
				"editor.suggest.showFolders": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showFolders",
						"When enabled IntelliSense shows `folder`-suggestions.",
					),
				},
				"editor.suggest.showTypeParameters": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showTypeParameters",
						"When enabled IntelliSense shows `typeParameter`-suggestions.",
					),
				},
				"editor.suggest.showSnippets": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showSnippets",
						"When enabled IntelliSense shows `snippet`-suggestions.",
					),
				},
				"editor.suggest.showUsers": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showUsers",
						"When enabled IntelliSense shows `user`-suggestions.",
					),
				},
				"editor.suggest.showIssues": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"editor.suggest.showIssues",
						"When enabled IntelliSense shows `issues`-suggestions.",
					),
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				insertMode: St(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
				filterGraceful: re(t.filterGraceful, this.defaultValue.filterGraceful),
				snippetsPreventQuickSuggestions: re(
					t.snippetsPreventQuickSuggestions,
					this.defaultValue.filterGraceful,
				),
				localityBonus: re(t.localityBonus, this.defaultValue.localityBonus),
				shareSuggestSelections: re(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
				selectionMode: St(t.selectionMode, this.defaultValue.selectionMode, [
					"always",
					"never",
					"whenQuickSuggestion",
					"whenTriggerCharacter",
				]),
				showIcons: re(t.showIcons, this.defaultValue.showIcons),
				showStatusBar: re(t.showStatusBar, this.defaultValue.showStatusBar),
				preview: re(t.preview, this.defaultValue.preview),
				previewMode: St(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
				showInlineDetails: re(t.showInlineDetails, this.defaultValue.showInlineDetails),
				showMethods: re(t.showMethods, this.defaultValue.showMethods),
				showFunctions: re(t.showFunctions, this.defaultValue.showFunctions),
				showConstructors: re(t.showConstructors, this.defaultValue.showConstructors),
				showDeprecated: re(t.showDeprecated, this.defaultValue.showDeprecated),
				matchOnWordStartOnly: re(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
				showFields: re(t.showFields, this.defaultValue.showFields),
				showVariables: re(t.showVariables, this.defaultValue.showVariables),
				showClasses: re(t.showClasses, this.defaultValue.showClasses),
				showStructs: re(t.showStructs, this.defaultValue.showStructs),
				showInterfaces: re(t.showInterfaces, this.defaultValue.showInterfaces),
				showModules: re(t.showModules, this.defaultValue.showModules),
				showProperties: re(t.showProperties, this.defaultValue.showProperties),
				showEvents: re(t.showEvents, this.defaultValue.showEvents),
				showOperators: re(t.showOperators, this.defaultValue.showOperators),
				showUnits: re(t.showUnits, this.defaultValue.showUnits),
				showValues: re(t.showValues, this.defaultValue.showValues),
				showConstants: re(t.showConstants, this.defaultValue.showConstants),
				showEnums: re(t.showEnums, this.defaultValue.showEnums),
				showEnumMembers: re(t.showEnumMembers, this.defaultValue.showEnumMembers),
				showKeywords: re(t.showKeywords, this.defaultValue.showKeywords),
				showWords: re(t.showWords, this.defaultValue.showWords),
				showColors: re(t.showColors, this.defaultValue.showColors),
				showFiles: re(t.showFiles, this.defaultValue.showFiles),
				showReferences: re(t.showReferences, this.defaultValue.showReferences),
				showFolders: re(t.showFolders, this.defaultValue.showFolders),
				showTypeParameters: re(t.showTypeParameters, this.defaultValue.showTypeParameters),
				showSnippets: re(t.showSnippets, this.defaultValue.showSnippets),
				showUsers: re(t.showUsers, this.defaultValue.showUsers),
				showIssues: re(t.showIssues, this.defaultValue.showIssues),
			}
		}
	},
	Zw = class extends pt {
		constructor() {
			super(
				118,
				"smartSelect",
				{ selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 },
				{
					"editor.smartSelect.selectLeadingAndTrailingWhitespace": {
						description: p(
							"selectLeadingAndTrailingWhitespace",
							"Whether leading and trailing whitespace should always be selected.",
						),
						default: !0,
						type: "boolean",
					},
					"editor.smartSelect.selectSubwords": {
						description: p(
							"selectSubwords",
							"Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected.",
						),
						default: !0,
						type: "boolean",
					},
				},
			)
		}
		validate(e) {
			return !e || typeof e != "object"
				? this.defaultValue
				: {
						selectLeadingAndTrailingWhitespace: re(
							e.selectLeadingAndTrailingWhitespace,
							this.defaultValue.selectLeadingAndTrailingWhitespace,
						),
						selectSubwords: re(e.selectSubwords, this.defaultValue.selectSubwords),
					}
		}
	},
	eP = class extends pt {
		constructor() {
			let e = []
			super(135, "wordSegmenterLocales", e, {
				anyOf: [
					{
						description: p(
							"wordSegmenterLocales",
							"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).",
						),
						type: "string",
					},
					{
						description: p(
							"wordSegmenterLocales",
							"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).",
						),
						type: "array",
						items: { type: "string" },
					},
				],
			})
		}
		validate(e) {
			if ((typeof e == "string" && (e = [e]), Array.isArray(e))) {
				let t = []
				for (let n of e)
					if (typeof n == "string")
						try {
							Intl.Segmenter.supportedLocalesOf(n).length > 0 && t.push(n)
						} catch {}
				return t
			}
			return this.defaultValue
		}
	}
var tP = class extends pt {
		constructor() {
			super(143, "wrappingIndent", 1, {
				"editor.wrappingIndent": {
					type: "string",
					enum: ["none", "same", "indent", "deepIndent"],
					enumDescriptions: [
						p("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
						p("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
						p("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
						p("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent."),
					],
					description: p("wrappingIndent", "Controls the indentation of wrapped lines."),
					default: "same",
				},
			})
		}
		validate(e) {
			switch (e) {
				case "none":
					return 0
				case "same":
					return 1
				case "indent":
					return 2
				case "deepIndent":
					return 3
			}
			return 1
		}
		compute(e, t, n) {
			return t.get(2) === 2 ? 0 : n
		}
	},
	nP = class extends ss {
		constructor() {
			super(152)
		}
		compute(e, t, n) {
			let r = t.get(151)
			return {
				isDominatedByLongLines: e.isDominatedByLongLines,
				isWordWrapMinified: r.isWordWrapMinified,
				isViewportWrapping: r.isViewportWrapping,
				wrappingColumn: r.wrappingColumn,
			}
		}
	},
	rP = class extends pt {
		constructor() {
			let e = { enabled: !0, showDropSelector: "afterDrop" }
			super(36, "dropIntoEditor", e, {
				"editor.dropIntoEditor.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"dropIntoEditor.enabled",
						"Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).",
					),
				},
				"editor.dropIntoEditor.showDropSelector": {
					type: "string",
					markdownDescription: p(
						"dropIntoEditor.showDropSelector",
						"Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped.",
					),
					enum: ["afterDrop", "never"],
					enumDescriptions: [
						p(
							"dropIntoEditor.showDropSelector.afterDrop",
							"Show the drop selector widget after a file is dropped into the editor.",
						),
						p(
							"dropIntoEditor.showDropSelector.never",
							"Never show the drop selector widget. Instead the default drop provider is always used.",
						),
					],
					default: "afterDrop",
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				showDropSelector: St(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"]),
			}
		}
	},
	oP = class extends pt {
		constructor() {
			let e = { enabled: !0, showPasteSelector: "afterPaste" }
			super(89, "pasteAs", e, {
				"editor.pasteAs.enabled": {
					type: "boolean",
					default: e.enabled,
					markdownDescription: p(
						"pasteAs.enabled",
						"Controls whether you can paste content in different ways.",
					),
				},
				"editor.pasteAs.showPasteSelector": {
					type: "string",
					markdownDescription: p(
						"pasteAs.showPasteSelector",
						"Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted.",
					),
					enum: ["afterPaste", "never"],
					enumDescriptions: [
						p(
							"pasteAs.showPasteSelector.afterPaste",
							"Show the paste selector widget after content is pasted into the editor.",
						),
						p(
							"pasteAs.showPasteSelector.never",
							"Never show the paste selector widget. Instead the default pasting behavior is always used.",
						),
					],
					default: "afterPaste",
				},
			})
		}
		validate(e) {
			if (!e || typeof e != "object") return this.defaultValue
			let t = e
			return {
				enabled: re(t.enabled, this.defaultValue.enabled),
				showPasteSelector: St(t.showPasteSelector, this.defaultValue.showPasteSelector, [
					"afterPaste",
					"never",
				]),
			}
		}
	},
	V5 = "Consolas, 'Courier New', monospace",
	B5 = "Menlo, Monaco, 'Courier New', monospace",
	$5 = "'Droid Sans Mono', 'monospace', monospace",
	is = {
		fontFamily: st ? B5 : Ve ? $5 : V5,
		fontWeight: "normal",
		fontSize: st ? 12 : 14,
		lineHeight: 0,
		letterSpacing: 0,
	},
	z5 = []
function N(o) {
	return (z5[o.id] = o), o
}
var RK = {
	acceptSuggestionOnCommitCharacter: N(
		new Le(0, "acceptSuggestionOnCommitCharacter", !0, {
			markdownDescription: p(
				"acceptSuggestionOnCommitCharacter",
				"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.",
			),
		}),
	),
	acceptSuggestionOnEnter: N(
		new gt(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
			markdownEnumDescriptions: [
				"",
				p(
					"acceptSuggestionOnEnterSmart",
					"Only accept a suggestion with `Enter` when it makes a textual change.",
				),
				"",
			],
			markdownDescription: p(
				"acceptSuggestionOnEnter",
				"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.",
			),
		}),
	),
	accessibilitySupport: N(new vw()),
	accessibilityPageSize: N(
		new tt(3, "accessibilityPageSize", 500, 1, 1073741824, {
			description: p(
				"accessibilityPageSize",
				"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.",
			),
			tags: ["accessibility"],
		}),
	),
	ariaLabel: N(new Jn(4, "ariaLabel", p("editorViewAccessibleLabel", "Editor content"))),
	ariaRequired: N(new Le(5, "ariaRequired", !1, void 0)),
	screenReaderAnnounceInlineSuggestion: N(
		new Le(8, "screenReaderAnnounceInlineSuggestion", !0, {
			description: p(
				"screenReaderAnnounceInlineSuggestion",
				"Control whether inline suggestions are announced by a screen reader.",
			),
			tags: ["accessibility"],
		}),
	),
	autoClosingBrackets: N(
		new gt(
			6,
			"autoClosingBrackets",
			"languageDefined",
			["always", "languageDefined", "beforeWhitespace", "never"],
			{
				enumDescriptions: [
					"",
					p(
						"editor.autoClosingBrackets.languageDefined",
						"Use language configurations to determine when to autoclose brackets.",
					),
					p(
						"editor.autoClosingBrackets.beforeWhitespace",
						"Autoclose brackets only when the cursor is to the left of whitespace.",
					),
					"",
				],
				description: p(
					"autoClosingBrackets",
					"Controls whether the editor should automatically close brackets after the user adds an opening bracket.",
				),
			},
		),
	),
	autoClosingComments: N(
		new gt(
			7,
			"autoClosingComments",
			"languageDefined",
			["always", "languageDefined", "beforeWhitespace", "never"],
			{
				enumDescriptions: [
					"",
					p(
						"editor.autoClosingComments.languageDefined",
						"Use language configurations to determine when to autoclose comments.",
					),
					p(
						"editor.autoClosingComments.beforeWhitespace",
						"Autoclose comments only when the cursor is to the left of whitespace.",
					),
					"",
				],
				description: p(
					"autoClosingComments",
					"Controls whether the editor should automatically close comments after the user adds an opening comment.",
				),
			},
		),
	),
	autoClosingDelete: N(
		new gt(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingDelete.auto",
					"Remove adjacent closing quotes or brackets only if they were automatically inserted.",
				),
				"",
			],
			description: p(
				"autoClosingDelete",
				"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.",
			),
		}),
	),
	autoClosingOvertype: N(
		new gt(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingOvertype.auto",
					"Type over closing quotes or brackets only if they were automatically inserted.",
				),
				"",
			],
			description: p(
				"autoClosingOvertype",
				"Controls whether the editor should type over closing quotes or brackets.",
			),
		}),
	),
	autoClosingQuotes: N(
		new gt(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
			enumDescriptions: [
				"",
				p(
					"editor.autoClosingQuotes.languageDefined",
					"Use language configurations to determine when to autoclose quotes.",
				),
				p(
					"editor.autoClosingQuotes.beforeWhitespace",
					"Autoclose quotes only when the cursor is to the left of whitespace.",
				),
				"",
			],
			description: p(
				"autoClosingQuotes",
				"Controls whether the editor should automatically close quotes after the user adds an opening quote.",
			),
		}),
	),
	autoIndent: N(
		new Gl(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], U5, {
			enumDescriptions: [
				p("editor.autoIndent.none", "The editor will not insert indentation automatically."),
				p("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
				p(
					"editor.autoIndent.brackets",
					"The editor will keep the current line's indentation and honor language defined brackets.",
				),
				p(
					"editor.autoIndent.advanced",
					"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.",
				),
				p(
					"editor.autoIndent.full",
					"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.",
				),
			],
			description: p(
				"autoIndent",
				"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.",
			),
		}),
	),
	automaticLayout: N(new Le(13, "automaticLayout", !1)),
	autoSurround: N(
		new gt(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
			enumDescriptions: [
				p(
					"editor.autoSurround.languageDefined",
					"Use language configurations to determine when to automatically surround selections.",
				),
				p("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
				p("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
				"",
			],
			description: p(
				"autoSurround",
				"Controls whether the editor should automatically surround selections when typing quotes or brackets.",
			),
		}),
	),
	bracketPairColorization: N(new Jw()),
	bracketPairGuides: N(new Xw()),
	stickyTabStops: N(
		new Le(121, "stickyTabStops", !1, {
			description: p(
				"stickyTabStops",
				"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.",
			),
		}),
	),
	codeLens: N(
		new Le(17, "codeLens", !0, { description: p("codeLens", "Controls whether the editor shows CodeLens.") }),
	),
	codeLensFontFamily: N(
		new Jn(18, "codeLensFontFamily", "", {
			description: p("codeLensFontFamily", "Controls the font family for CodeLens."),
		}),
	),
	codeLensFontSize: N(
		new tt(19, "codeLensFontSize", 0, 0, 100, {
			type: "number",
			default: 0,
			minimum: 0,
			maximum: 100,
			markdownDescription: p(
				"codeLensFontSize",
				"Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.",
			),
		}),
	),
	colorDecorators: N(
		new Le(20, "colorDecorators", !0, {
			description: p(
				"colorDecorators",
				"Controls whether the editor should render the inline color decorators and color picker.",
			),
		}),
	),
	colorDecoratorActivatedOn: N(
		new gt(154, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
			enumDescriptions: [
				p(
					"editor.colorDecoratorActivatedOn.clickAndHover",
					"Make the color picker appear both on click and hover of the color decorator",
				),
				p(
					"editor.colorDecoratorActivatedOn.hover",
					"Make the color picker appear on hover of the color decorator",
				),
				p(
					"editor.colorDecoratorActivatedOn.click",
					"Make the color picker appear on click of the color decorator",
				),
			],
			description: p(
				"colorDecoratorActivatedOn",
				"Controls the condition to make a color picker appear from a color decorator.",
			),
		}),
	),
	colorDecoratorsLimit: N(
		new tt(21, "colorDecoratorsLimit", 500, 1, 1e6, {
			markdownDescription: p(
				"colorDecoratorsLimit",
				"Controls the max number of color decorators that can be rendered in an editor at once.",
			),
		}),
	),
	columnSelection: N(
		new Le(22, "columnSelection", !1, {
			description: p(
				"columnSelection",
				"Enable that the selection with the mouse and keys is doing column selection.",
			),
		}),
	),
	comments: N(new bw()),
	contextmenu: N(new Le(24, "contextmenu", !0)),
	copyWithSyntaxHighlighting: N(
		new Le(25, "copyWithSyntaxHighlighting", !0, {
			description: p(
				"copyWithSyntaxHighlighting",
				"Controls whether syntax highlighting should be copied into the clipboard.",
			),
		}),
	),
	cursorBlinking: N(
		new Gl(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], H5, {
			description: p("cursorBlinking", "Control the cursor animation style."),
		}),
	),
	cursorSmoothCaretAnimation: N(
		new gt(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
			enumDescriptions: [
				p("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
				p(
					"cursorSmoothCaretAnimation.explicit",
					"Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture.",
				),
				p("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled."),
			],
			description: p(
				"cursorSmoothCaretAnimation",
				"Controls whether the smooth caret animation should be enabled.",
			),
		}),
	),
	cursorStyle: N(
		new Gl(
			28,
			"cursorStyle",
			1,
			"line",
			["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
			jO,
			{ description: p("cursorStyle", "Controls the cursor style in insert input mode.") },
		),
	),
	overtypeCursorStyle: N(
		new Gl(
			84,
			"overtypeCursorStyle",
			2,
			"block",
			["line", "block", "underline", "line-thin", "block-outline", "underline-thin"],
			jO,
			{ description: p("overtypeCursorStyle", "Controls the cursor style in overtype input mode.") },
		),
	),
	cursorSurroundingLines: N(
		new tt(29, "cursorSurroundingLines", 0, 0, 1073741824, {
			description: p(
				"cursorSurroundingLines",
				"Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.",
			),
		}),
	),
	cursorSurroundingLinesStyle: N(
		new gt(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
			enumDescriptions: [
				p(
					"cursorSurroundingLinesStyle.default",
					"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.",
				),
				p("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always."),
			],
			markdownDescription: p(
				"cursorSurroundingLinesStyle",
				"Controls when `#editor.cursorSurroundingLines#` should be enforced.",
			),
		}),
	),
	cursorWidth: N(
		new tt(31, "cursorWidth", 0, 0, 1073741824, {
			markdownDescription: p(
				"cursorWidth",
				"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.",
			),
		}),
	),
	disableLayerHinting: N(new Le(32, "disableLayerHinting", !1)),
	disableMonospaceOptimizations: N(new Le(33, "disableMonospaceOptimizations", !1)),
	domReadOnly: N(new Le(34, "domReadOnly", !1)),
	dragAndDrop: N(
		new Le(35, "dragAndDrop", !0, {
			description: p(
				"dragAndDrop",
				"Controls whether the editor should allow moving selections via drag and drop.",
			),
		}),
	),
	emptySelectionClipboard: N(new Iw()),
	dropIntoEditor: N(new rP()),
	experimentalEditContextEnabled: N(
		new Le(37, "experimentalEditContextEnabled", cb.quality !== "stable", {
			description: p(
				"experimentalEditContextEnabled",
				"Sets whether the new experimental edit context should be used instead of the text area.",
			),
			included: gf || _v || Tv,
		}),
	),
	stickyScroll: N(new Lw()),
	experimentalGpuAcceleration: N(
		new gt(39, "experimentalGpuAcceleration", "off", ["off", "on"], {
			tags: ["experimental"],
			enumDescriptions: [
				p("experimentalGpuAcceleration.off", "Use regular DOM-based rendering."),
				p("experimentalGpuAcceleration.on", "Use GPU acceleration."),
			],
			description: p(
				"experimentalGpuAcceleration",
				"Controls whether to use the experimental GPU acceleration to render the editor.",
			),
		}),
	),
	experimentalWhitespaceRendering: N(
		new gt(40, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
			enumDescriptions: [
				p("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
				p("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
				p("experimentalWhitespaceRendering.off", "Use the stable rendering method."),
			],
			description: p(
				"experimentalWhitespaceRendering",
				"Controls whether whitespace is rendered with a new, experimental method.",
			),
		}),
	),
	extraEditorClassName: N(new Jn(41, "extraEditorClassName", "")),
	fastScrollSensitivity: N(
		new co(42, "fastScrollSensitivity", 5, (o) => (o <= 0 ? 5 : o), {
			markdownDescription: p("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`."),
		}),
	),
	find: N(new xw()),
	fixedOverflowWidgets: N(new Le(44, "fixedOverflowWidgets", !1)),
	folding: N(
		new Le(45, "folding", !0, {
			description: p("folding", "Controls whether the editor has code folding enabled."),
		}),
	),
	foldingStrategy: N(
		new gt(46, "foldingStrategy", "auto", ["auto", "indentation"], {
			enumDescriptions: [
				p(
					"foldingStrategy.auto",
					"Use a language-specific folding strategy if available, else the indentation-based one.",
				),
				p("foldingStrategy.indentation", "Use the indentation-based folding strategy."),
			],
			description: p("foldingStrategy", "Controls the strategy for computing folding ranges."),
		}),
	),
	foldingHighlight: N(
		new Le(47, "foldingHighlight", !0, {
			description: p("foldingHighlight", "Controls whether the editor should highlight folded ranges."),
		}),
	),
	foldingImportsByDefault: N(
		new Le(48, "foldingImportsByDefault", !1, {
			description: p(
				"foldingImportsByDefault",
				"Controls whether the editor automatically collapses import ranges.",
			),
		}),
	),
	foldingMaximumRegions: N(
		new tt(49, "foldingMaximumRegions", 5e3, 10, 65e3, {
			description: p(
				"foldingMaximumRegions",
				"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.",
			),
		}),
	),
	unfoldOnClickAfterEndOfLine: N(
		new Le(50, "unfoldOnClickAfterEndOfLine", !1, {
			description: p(
				"unfoldOnClickAfterEndOfLine",
				"Controls whether clicking on the empty content after a folded line will unfold the line.",
			),
		}),
	),
	fontFamily: N(
		new Jn(51, "fontFamily", is.fontFamily, { description: p("fontFamily", "Controls the font family.") }),
	),
	fontInfo: N(new Tw()),
	fontLigatures2: N(new Cw()),
	fontSize: N(new Pw()),
	fontWeight: N(new _w()),
	fontVariations: N(new Sw()),
	formatOnPaste: N(
		new Le(57, "formatOnPaste", !1, {
			description: p(
				"formatOnPaste",
				"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.",
			),
		}),
	),
	formatOnType: N(
		new Le(58, "formatOnType", !1, {
			description: p(
				"formatOnType",
				"Controls whether the editor should automatically format the line after typing.",
			),
		}),
	),
	glyphMargin: N(
		new Le(59, "glyphMargin", !0, {
			description: p(
				"glyphMargin",
				"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.",
			),
		}),
	),
	gotoLocation: N(new Dw()),
	hideCursorInOverviewRuler: N(
		new Le(61, "hideCursorInOverviewRuler", !1, {
			description: p(
				"hideCursorInOverviewRuler",
				"Controls whether the cursor should be hidden in the overview ruler.",
			),
		}),
	),
	hover: N(new kw()),
	inDiffEditor: N(new Le(63, "inDiffEditor", !1)),
	letterSpacing: N(
		new co(65, "letterSpacing", is.letterSpacing, (o) => co.clamp(o, -5, 20), {
			description: p("letterSpacing", "Controls the letter spacing in pixels."),
		}),
	),
	lightbulb: N(new Ow()),
	lineDecorationsWidth: N(new Fw()),
	lineHeight: N(new Nw()),
	lineNumbers: N(new zw()),
	lineNumbersMinChars: N(new tt(70, "lineNumbersMinChars", 5, 1, 300)),
	linkedEditing: N(
		new Le(71, "linkedEditing", !1, {
			description: p(
				"linkedEditing",
				"Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.",
			),
		}),
	),
	links: N(
		new Le(72, "links", !0, {
			description: p("links", "Controls whether the editor should detect links and make them clickable."),
		}),
	),
	matchBrackets: N(
		new gt(73, "matchBrackets", "always", ["always", "near", "never"], {
			description: p("matchBrackets", "Highlight matching brackets."),
		}),
	),
	minimap: N(new Uw()),
	mouseStyle: N(new gt(75, "mouseStyle", "text", ["text", "default", "copy"])),
	mouseWheelScrollSensitivity: N(
		new co(76, "mouseWheelScrollSensitivity", 1, (o) => (o === 0 ? 1 : o), {
			markdownDescription: p(
				"mouseWheelScrollSensitivity",
				"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.",
			),
		}),
	),
	mouseWheelZoom: N(
		new Le(77, "mouseWheelZoom", !1, {
			markdownDescription: st
				? p("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.")
				: p("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`."),
		}),
	),
	multiCursorMergeOverlapping: N(
		new Le(78, "multiCursorMergeOverlapping", !0, {
			description: p("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping."),
		}),
	),
	multiCursorModifier: N(
		new Gl(79, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], W5, {
			markdownEnumDescriptions: [
				p("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
				p("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS."),
			],
			markdownDescription: p(
				{
					key: "multiCursorModifier",
					comment: [
						"- `ctrlCmd` refers to a value the setting can take and should not be localized.",
						"- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.",
					],
				},
				"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).",
			),
		}),
	),
	multiCursorPaste: N(
		new gt(80, "multiCursorPaste", "spread", ["spread", "full"], {
			markdownEnumDescriptions: [
				p("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
				p("multiCursorPaste.full", "Each cursor pastes the full text."),
			],
			markdownDescription: p(
				"multiCursorPaste",
				"Controls pasting when the line count of the pasted text matches the cursor count.",
			),
		}),
	),
	multiCursorLimit: N(
		new tt(81, "multiCursorLimit", 1e4, 1, 1e5, {
			markdownDescription: p(
				"multiCursorLimit",
				"Controls the max number of cursors that can be in an active editor at once.",
			),
		}),
	),
	occurrencesHighlight: N(
		new gt(82, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
			markdownEnumDescriptions: [
				p("occurrencesHighlight.off", "Does not highlight occurrences."),
				p("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
				p(
					"occurrencesHighlight.multiFile",
					"Experimental: Highlights occurrences across all valid open files.",
				),
			],
			markdownDescription: p(
				"occurrencesHighlight",
				"Controls whether occurrences should be highlighted across open files.",
			),
		}),
	),
	occurrencesHighlightDelay: N(
		new tt(83, "occurrencesHighlightDelay", 0, 0, 2e3, {
			description: p(
				"occurrencesHighlightDelay",
				"Controls the delay in milliseconds after which occurrences are highlighted.",
			),
			tags: ["preview"],
		}),
	),
	overtypeOnPaste: N(
		new Le(85, "overtypeOnPaste", !0, {
			description: p("overtypeOnPaste", "Controls whether pasting should overtype."),
		}),
	),
	overviewRulerBorder: N(
		new Le(86, "overviewRulerBorder", !0, {
			description: p(
				"overviewRulerBorder",
				"Controls whether a border should be drawn around the overview ruler.",
			),
		}),
	),
	overviewRulerLanes: N(new tt(87, "overviewRulerLanes", 3, 0, 3)),
	padding: N(new Hw()),
	pasteAs: N(new oP()),
	parameterHints: N(new Ww()),
	peekWidgetDefaultFocus: N(
		new gt(91, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
			enumDescriptions: [
				p("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
				p("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek"),
			],
			description: p(
				"peekWidgetDefaultFocus",
				"Controls whether to focus the inline editor or the tree in the peek widget.",
			),
		}),
	),
	placeholder: N(new Bw()),
	definitionLinkOpensInPeek: N(
		new Le(93, "definitionLinkOpensInPeek", !1, {
			description: p(
				"definitionLinkOpensInPeek",
				"Controls whether the Go to Definition mouse gesture always opens the peek widget.",
			),
		}),
	),
	quickSuggestions: N(new $w()),
	quickSuggestionsDelay: N(
		new tt(95, "quickSuggestionsDelay", 10, 0, 1073741824, {
			description: p(
				"quickSuggestionsDelay",
				"Controls the delay in milliseconds after which quick suggestions will show up.",
			),
		}),
	),
	readOnly: N(new Le(96, "readOnly", !1)),
	readOnlyMessage: N(new Kw()),
	renameOnType: N(
		new Le(98, "renameOnType", !1, {
			description: p("renameOnType", "Controls whether the editor auto renames on type."),
			markdownDeprecationMessage: p("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead."),
		}),
	),
	renderControlCharacters: N(
		new Le(99, "renderControlCharacters", !0, {
			description: p("renderControlCharacters", "Controls whether the editor should render control characters."),
			restricted: !0,
		}),
	),
	renderFinalNewline: N(
		new gt(100, "renderFinalNewline", Ve ? "dimmed" : "on", ["off", "on", "dimmed"], {
			description: p("renderFinalNewline", "Render last line number when the file ends with a newline."),
		}),
	),
	renderLineHighlight: N(
		new gt(101, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
			enumDescriptions: [
				"",
				"",
				"",
				p("renderLineHighlight.all", "Highlights both the gutter and the current line."),
			],
			description: p("renderLineHighlight", "Controls how the editor should render the current line highlight."),
		}),
	),
	renderLineHighlightOnlyWhenFocus: N(
		new Le(102, "renderLineHighlightOnlyWhenFocus", !1, {
			description: p(
				"renderLineHighlightOnlyWhenFocus",
				"Controls if the editor should render the current line highlight only when the editor is focused.",
			),
		}),
	),
	renderValidationDecorations: N(new gt(103, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
	renderWhitespace: N(
		new gt(104, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
			enumDescriptions: [
				"",
				p("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
				p("renderWhitespace.selection", "Render whitespace characters only on selected text."),
				p("renderWhitespace.trailing", "Render only trailing whitespace characters."),
				"",
			],
			description: p("renderWhitespace", "Controls how the editor should render whitespace characters."),
		}),
	),
	revealHorizontalRightPadding: N(new tt(105, "revealHorizontalRightPadding", 15, 0, 1e3)),
	roundedSelection: N(
		new Le(106, "roundedSelection", !0, {
			description: p("roundedSelection", "Controls whether selections should have rounded corners."),
		}),
	),
	rulers: N(new qw()),
	scrollbar: N(new jw()),
	scrollBeyondLastColumn: N(
		new tt(109, "scrollBeyondLastColumn", 4, 0, 1073741824, {
			description: p(
				"scrollBeyondLastColumn",
				"Controls the number of extra characters beyond which the editor will scroll horizontally.",
			),
		}),
	),
	scrollBeyondLastLine: N(
		new Le(110, "scrollBeyondLastLine", !0, {
			description: p("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line."),
		}),
	),
	scrollPredominantAxis: N(
		new Le(111, "scrollPredominantAxis", !0, {
			description: p(
				"scrollPredominantAxis",
				"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.",
			),
		}),
	),
	selectionClipboard: N(
		new Le(112, "selectionClipboard", !0, {
			description: p("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
			included: Ve,
		}),
	),
	selectionHighlight: N(
		new Le(113, "selectionHighlight", !0, {
			description: p(
				"selectionHighlight",
				"Controls whether the editor should highlight matches similar to the selection.",
			),
		}),
	),
	selectOnLineNumbers: N(new Le(114, "selectOnLineNumbers", !0)),
	showFoldingControls: N(
		new gt(115, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
			enumDescriptions: [
				p("showFoldingControls.always", "Always show the folding controls."),
				p("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
				p("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter."),
			],
			description: p("showFoldingControls", "Controls when the folding controls on the gutter are shown."),
		}),
	),
	showUnused: N(
		new Le(116, "showUnused", !0, { description: p("showUnused", "Controls fading out of unused code.") }),
	),
	showDeprecated: N(
		new Le(145, "showDeprecated", !0, {
			description: p("showDeprecated", "Controls strikethrough deprecated variables."),
		}),
	),
	inlayHints: N(new Mw()),
	snippetSuggestions: N(
		new gt(117, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
			enumDescriptions: [
				p("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
				p("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
				p("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
				p("snippetSuggestions.none", "Do not show snippet suggestions."),
			],
			description: p(
				"snippetSuggestions",
				"Controls whether snippets are shown with other suggestions and how they are sorted.",
			),
		}),
	),
	smartSelect: N(new Zw()),
	smoothScrolling: N(
		new Le(119, "smoothScrolling", !1, {
			description: p("smoothScrolling", "Controls whether the editor will scroll using an animation."),
		}),
	),
	stopRenderingLineAfter: N(new tt(122, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
	suggest: N(new Yw()),
	inlineSuggest: N(new Qw()),
	inlineCompletionsAccessibilityVerbose: N(
		new Le(155, "inlineCompletionsAccessibilityVerbose", !1, {
			description: p(
				"inlineCompletionsAccessibilityVerbose",
				"Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.",
			),
		}),
	),
	suggestFontSize: N(
		new tt(124, "suggestFontSize", 0, 0, 1e3, {
			markdownDescription: p(
				"suggestFontSize",
				"Font size for the suggest widget. When set to {0}, the value of {1} is used.",
				"`0`",
				"`#editor.fontSize#`",
			),
		}),
	),
	suggestLineHeight: N(
		new tt(125, "suggestLineHeight", 0, 0, 1e3, {
			markdownDescription: p(
				"suggestLineHeight",
				"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.",
				"`0`",
				"`#editor.lineHeight#`",
			),
		}),
	),
	suggestOnTriggerCharacters: N(
		new Le(126, "suggestOnTriggerCharacters", !0, {
			description: p(
				"suggestOnTriggerCharacters",
				"Controls whether suggestions should automatically show up when typing trigger characters.",
			),
		}),
	),
	suggestSelection: N(
		new gt(127, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
			markdownEnumDescriptions: [
				p("suggestSelection.first", "Always select the first suggestion."),
				p(
					"suggestSelection.recentlyUsed",
					"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.",
				),
				p(
					"suggestSelection.recentlyUsedByPrefix",
					"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.",
				),
			],
			description: p(
				"suggestSelection",
				"Controls how suggestions are pre-selected when showing the suggest list.",
			),
		}),
	),
	tabCompletion: N(
		new gt(128, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
			enumDescriptions: [
				p("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
				p("tabCompletion.off", "Disable tab completions."),
				p(
					"tabCompletion.onlySnippets",
					"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.",
				),
			],
			description: p("tabCompletion", "Enables tab completions."),
		}),
	),
	tabIndex: N(new tt(129, "tabIndex", 0, -1, 1073741824)),
	unicodeHighlight: N(new Gw()),
	unusualLineTerminators: N(
		new gt(131, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
			enumDescriptions: [
				p("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
				p("unusualLineTerminators.off", "Unusual line terminators are ignored."),
				p("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed."),
			],
			description: p("unusualLineTerminators", "Remove unusual line terminators that might cause problems."),
		}),
	),
	useShadowDOM: N(new Le(132, "useShadowDOM", !0)),
	useTabStops: N(
		new Le(133, "useTabStops", !0, {
			description: p("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops."),
		}),
	),
	wordBreak: N(
		new gt(134, "wordBreak", "normal", ["normal", "keepAll"], {
			markdownEnumDescriptions: [
				p("wordBreak.normal", "Use the default line break rule."),
				p(
					"wordBreak.keepAll",
					"Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.",
				),
			],
			description: p("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text."),
		}),
	),
	wordSegmenterLocales: N(new eP()),
	wordSeparators: N(
		new Jn(136, "wordSeparators", cw, {
			description: p(
				"wordSeparators",
				"Characters that will be used as word separators when doing word related navigations or operations.",
			),
		}),
	),
	wordWrap: N(
		new gt(137, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
			markdownEnumDescriptions: [
				p("wordWrap.off", "Lines will never wrap."),
				p("wordWrap.on", "Lines will wrap at the viewport width."),
				p(
					{
						key: "wordWrap.wordWrapColumn",
						comment: [
							"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
						],
					},
					"Lines will wrap at `#editor.wordWrapColumn#`.",
				),
				p(
					{
						key: "wordWrap.bounded",
						comment: [
							"- viewport means the edge of the visible window size.",
							"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
						],
					},
					"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.",
				),
			],
			description: p(
				{
					key: "wordWrap",
					comment: [
						"- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
						"- `editor.wordWrapColumn` refers to a different setting and should not be localized.",
					],
				},
				"Controls how lines should wrap.",
			),
		}),
	),
	wordWrapBreakAfterCharacters: N(
		new Jn(
			138,
			"wordWrapBreakAfterCharacters",
			" 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63",
		),
	),
	wordWrapBreakBeforeCharacters: N(
		new Jn(
			139,
			"wordWrapBreakBeforeCharacters",
			"([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B",
		),
	),
	wordWrapColumn: N(
		new tt(140, "wordWrapColumn", 80, 1, 1073741824, {
			markdownDescription: p(
				{
					key: "wordWrapColumn",
					comment: [
						"- `editor.wordWrap` refers to a different setting and should not be localized.",
						"- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized.",
					],
				},
				"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.",
			),
		}),
	),
	wordWrapOverride1: N(new gt(141, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
	wordWrapOverride2: N(new gt(142, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
	effectiveCursorStyle: N(new Ew()),
	editorClassName: N(new yw()),
	defaultColorDecorators: N(
		new gt(153, "defaultColorDecorators", "auto", ["auto", "always", "never"], {
			enumDescriptions: [
				p(
					"editor.defaultColorDecorators.auto",
					"Show default color decorators only when no extension provides colors decorators.",
				),
				p("editor.defaultColorDecorators.always", "Always show default color decorators."),
				p("editor.defaultColorDecorators.never", "Never show default color decorators."),
			],
			description: p(
				"defaultColorDecorators",
				"Controls whether inline color decorations should be shown using the default document color provider.",
			),
		}),
	),
	pixelRatio: N(new Vw()),
	tabFocusMode: N(
		new Le(150, "tabFocusMode", !1, {
			markdownDescription: p(
				"tabFocusMode",
				"Controls whether the editor receives tabs or defers them to the workbench for navigation.",
			),
		}),
	),
	layoutInfo: N(new Rw()),
	wrappingInfo: N(new nP()),
	wrappingIndent: N(new tP()),
	wrappingStrategy: N(new Aw()),
	effectiveExperimentalEditContextEnabled: N(new ww()),
}
var Ff = class o {
		constructor(e) {
			this._proxyIdentifierBrand = void 0
			;(this.sid = e), (this.nid = ++o.count)
		}
		static {
			this.count = 0
		}
	},
	QO = []
function V(o) {
	let e = new Ff(o)
	return (QO[e.nid] = e), e
}
function Nf(o) {
	return QO[o].sid
}
var Xt = class {
	constructor(e) {
		this.value = e
	}
}
var sP = ((r) => (
		(r[(r.None = 0)] = "None"),
		(r[(r.Process = 1)] = "Process"),
		(r[(r.Output = 2)] = "Output"),
		(r[(r.Hybrid = 3)] = "Hybrid"),
		r
	))(sP || {}),
	JO = class o {
		static {
			this._n = 0
		}
		static mixin(e) {
			return (e._id = o._n++), e
		}
	}
var M = {
		MainThreadAuthentication: V("MainThreadAuthentication"),
		MainThreadBulkEdits: V("MainThreadBulkEdits"),
		MainThreadLanguageModels: V("MainThreadLanguageModels"),
		MainThreadEmbeddings: V("MainThreadEmbeddings"),
		MainThreadChatAgents2: V("MainThreadChatAgents2"),
		MainThreadCodeMapper: V("MainThreadCodeMapper"),
		MainThreadLanguageModelTools: V("MainThreadChatSkills"),
		MainThreadClipboard: V("MainThreadClipboard"),
		MainThreadCommands: V("MainThreadCommands"),
		MainThreadComments: V("MainThreadComments"),
		MainThreadConfiguration: V("MainThreadConfiguration"),
		MainThreadConsole: V("MainThreadConsole"),
		MainThreadDebugService: V("MainThreadDebugService"),
		MainThreadDecorations: V("MainThreadDecorations"),
		MainThreadDiagnostics: V("MainThreadDiagnostics"),
		MainThreadDialogs: V("MainThreadDiaglogs"),
		MainThreadDocuments: V("MainThreadDocuments"),
		MainThreadDocumentContentProviders: V("MainThreadDocumentContentProviders"),
		MainThreadTextEditors: V("MainThreadTextEditors"),
		MainThreadEditorInsets: V("MainThreadEditorInsets"),
		MainThreadEditorTabs: V("MainThreadEditorTabs"),
		MainThreadErrors: V("MainThreadErrors"),
		MainThreadTreeViews: V("MainThreadTreeViews"),
		MainThreadDownloadService: V("MainThreadDownloadService"),
		MainThreadLanguageFeatures: V("MainThreadLanguageFeatures"),
		MainThreadLanguages: V("MainThreadLanguages"),
		MainThreadLogger: V("MainThreadLogger"),
		MainThreadMessageService: V("MainThreadMessageService"),
		MainThreadOutputService: V("MainThreadOutputService"),
		MainThreadProgress: V("MainThreadProgress"),
		MainThreadQuickDiff: V("MainThreadQuickDiff"),
		MainThreadQuickOpen: V("MainThreadQuickOpen"),
		MainThreadStatusBar: V("MainThreadStatusBar"),
		MainThreadSecretState: V("MainThreadSecretState"),
		MainThreadStorage: V("MainThreadStorage"),
		MainThreadSpeech: V("MainThreadSpeechProvider"),
		MainThreadTelemetry: V("MainThreadTelemetry"),
		MainThreadTerminalService: V("MainThreadTerminalService"),
		MainThreadTerminalShellIntegration: V("MainThreadTerminalShellIntegration"),
		MainThreadWebviews: V("MainThreadWebviews"),
		MainThreadWebviewPanels: V("MainThreadWebviewPanels"),
		MainThreadWebviewViews: V("MainThreadWebviewViews"),
		MainThreadCustomEditors: V("MainThreadCustomEditors"),
		MainThreadUrls: V("MainThreadUrls"),
		MainThreadUriOpeners: V("MainThreadUriOpeners"),
		MainThreadProfileContentHandlers: V("MainThreadProfileContentHandlers"),
		MainThreadWorkspace: V("MainThreadWorkspace"),
		MainThreadFileSystem: V("MainThreadFileSystem"),
		MainThreadFileSystemEventService: V("MainThreadFileSystemEventService"),
		MainThreadExtensionService: V("MainThreadExtensionService"),
		MainThreadSCM: V("MainThreadSCM"),
		MainThreadSearch: V("MainThreadSearch"),
		MainThreadShare: V("MainThreadShare"),
		MainThreadTask: V("MainThreadTask"),
		MainThreadWindow: V("MainThreadWindow"),
		MainThreadLabelService: V("MainThreadLabelService"),
		MainThreadNotebook: V("MainThreadNotebook"),
		MainThreadNotebookDocuments: V("MainThreadNotebookDocumentsShape"),
		MainThreadNotebookEditors: V("MainThreadNotebookEditorsShape"),
		MainThreadNotebookKernels: V("MainThreadNotebookKernels"),
		MainThreadNotebookRenderers: V("MainThreadNotebookRenderers"),
		MainThreadInteractive: V("MainThreadInteractive"),
		MainThreadTheming: V("MainThreadTheming"),
		MainThreadTunnelService: V("MainThreadTunnelService"),
		MainThreadManagedSockets: V("MainThreadManagedSockets"),
		MainThreadTimeline: V("MainThreadTimeline"),
		MainThreadTesting: V("MainThreadTesting"),
		MainThreadLocalization: V("MainThreadLocalizationShape"),
		MainThreadMcp: V("MainThreadMcpShape"),
		MainThreadAiRelatedInformation: V("MainThreadAiRelatedInformation"),
		MainThreadAiEmbeddingVector: V("MainThreadAiEmbeddingVector"),
		MainThreadChatStatus: V("MainThreadChatStatus"),
	},
	le = {
		ExtHostCodeMapper: V("ExtHostCodeMapper"),
		ExtHostCommands: V("ExtHostCommands"),
		ExtHostConfiguration: V("ExtHostConfiguration"),
		ExtHostDiagnostics: V("ExtHostDiagnostics"),
		ExtHostDebugService: V("ExtHostDebugService"),
		ExtHostDecorations: V("ExtHostDecorations"),
		ExtHostDocumentsAndEditors: V("ExtHostDocumentsAndEditors"),
		ExtHostDocuments: V("ExtHostDocuments"),
		ExtHostDocumentContentProviders: V("ExtHostDocumentContentProviders"),
		ExtHostDocumentSaveParticipant: V("ExtHostDocumentSaveParticipant"),
		ExtHostEditors: V("ExtHostEditors"),
		ExtHostTreeViews: V("ExtHostTreeViews"),
		ExtHostFileSystem: V("ExtHostFileSystem"),
		ExtHostFileSystemInfo: V("ExtHostFileSystemInfo"),
		ExtHostFileSystemEventService: V("ExtHostFileSystemEventService"),
		ExtHostLanguages: V("ExtHostLanguages"),
		ExtHostLanguageFeatures: V("ExtHostLanguageFeatures"),
		ExtHostQuickOpen: V("ExtHostQuickOpen"),
		ExtHostQuickDiff: V("ExtHostQuickDiff"),
		ExtHostStatusBar: V("ExtHostStatusBar"),
		ExtHostShare: V("ExtHostShare"),
		ExtHostExtensionService: V("ExtHostExtensionService"),
		ExtHostLogLevelServiceShape: V("ExtHostLogLevelServiceShape"),
		ExtHostTerminalService: V("ExtHostTerminalService"),
		ExtHostTerminalShellIntegration: V("ExtHostTerminalShellIntegration"),
		ExtHostSCM: V("ExtHostSCM"),
		ExtHostSearch: V("ExtHostSearch"),
		ExtHostTask: V("ExtHostTask"),
		ExtHostWorkspace: V("ExtHostWorkspace"),
		ExtHostWindow: V("ExtHostWindow"),
		ExtHostWebviews: V("ExtHostWebviews"),
		ExtHostWebviewPanels: V("ExtHostWebviewPanels"),
		ExtHostCustomEditors: V("ExtHostCustomEditors"),
		ExtHostWebviewViews: V("ExtHostWebviewViews"),
		ExtHostEditorInsets: V("ExtHostEditorInsets"),
		ExtHostEditorTabs: V("ExtHostEditorTabs"),
		ExtHostProgress: V("ExtHostProgress"),
		ExtHostComments: V("ExtHostComments"),
		ExtHostSecretState: V("ExtHostSecretState"),
		ExtHostStorage: V("ExtHostStorage"),
		ExtHostUrls: V("ExtHostUrls"),
		ExtHostUriOpeners: V("ExtHostUriOpeners"),
		ExtHostProfileContentHandlers: V("ExtHostProfileContentHandlers"),
		ExtHostOutputService: V("ExtHostOutputService"),
		ExtHostLabelService: V("ExtHostLabelService"),
		ExtHostNotebook: V("ExtHostNotebook"),
		ExtHostNotebookDocuments: V("ExtHostNotebookDocuments"),
		ExtHostNotebookEditors: V("ExtHostNotebookEditors"),
		ExtHostNotebookKernels: V("ExtHostNotebookKernels"),
		ExtHostNotebookRenderers: V("ExtHostNotebookRenderers"),
		ExtHostNotebookDocumentSaveParticipant: V("ExtHostNotebookDocumentSaveParticipant"),
		ExtHostInteractive: V("ExtHostInteractive"),
		ExtHostChatAgents2: V("ExtHostChatAgents"),
		ExtHostLanguageModelTools: V("ExtHostChatSkills"),
		ExtHostChatProvider: V("ExtHostChatProvider"),
		ExtHostSpeech: V("ExtHostSpeech"),
		ExtHostEmbeddings: V("ExtHostEmbeddings"),
		ExtHostAiRelatedInformation: V("ExtHostAiRelatedInformation"),
		ExtHostAiEmbeddingVector: V("ExtHostAiEmbeddingVector"),
		ExtHostTheming: V("ExtHostTheming"),
		ExtHostTunnelService: V("ExtHostTunnelService"),
		ExtHostManagedSockets: V("ExtHostManagedSockets"),
		ExtHostAuthentication: V("ExtHostAuthentication"),
		ExtHostTimeline: V("ExtHostTimeline"),
		ExtHostTesting: V("ExtHostTesting"),
		ExtHostTelemetry: V("ExtHostTelemetry"),
		ExtHostLocalization: V("ExtHostLocalization"),
		ExtHostMcp: V("ExtHostMcp"),
	}
function XO(o) {
	return o.toJSON()
}
var pb = class {
		constructor(e) {
			this._uriTransformer = e
		}
		transformIncoming(e) {
			let t = this._uriTransformer.transformIncoming(e)
			return t === e ? e : XO(b.from(t))
		}
		transformOutgoing(e) {
			let t = this._uriTransformer.transformOutgoing(e)
			return t === e ? e : XO(b.from(t))
		}
		transformOutgoingURI(e) {
			let t = this._uriTransformer.transformOutgoing(e)
			return t === e ? e : b.from(t)
		}
		transformOutgoingScheme(e) {
			return this._uriTransformer.transformOutgoingScheme(e)
		}
	},
	BK = new (class {
		transformIncoming(o) {
			return o
		}
		transformOutgoing(o) {
			return o
		}
		transformOutgoingURI(o) {
			return o
		}
		transformOutgoingScheme(o) {
			return o
		}
	})()
function YO(o, e, t, n) {
	if (!o || n > 200) return null
	if (typeof o == "object") {
		if (o.$mid === 1) return t ? b.revive(e.transformIncoming(o)) : e.transformIncoming(o)
		if (o instanceof z) return null
		for (let r in o)
			if (Object.hasOwnProperty.call(o, r)) {
				let i = YO(o[r], e, t, n + 1)
				i !== null && (o[r] = i)
			}
	}
	return null
}
function Nc(o, e) {
	let t = YO(o, e, !1, 0)
	return t === null ? o : t
}
var Uf = class {
		constructor() {
			;(this._actual = null),
				(this._actualOk = null),
				(this._actualErr = null),
				(this._hasValue = !1),
				(this._value = null),
				(this._hasErr = !1),
				(this._err = null)
		}
		get [Symbol.toStringTag]() {
			return this.toString()
		}
		_ensureActual() {
			return (
				this._actual ||
					(this._actual = new Promise((e, t) => {
						;(this._actualOk = e),
							(this._actualErr = t),
							this._hasValue && this._actualOk(this._value),
							this._hasErr && this._actualErr(this._err)
					})),
				this._actual
			)
		}
		resolveOk(e) {
			this._hasValue ||
				this._hasErr ||
				((this._hasValue = !0), (this._value = e), this._actual && this._actualOk(e))
		}
		resolveErr(e) {
			this._hasValue ||
				this._hasErr ||
				((this._hasErr = !0), (this._err = e), this._actual ? this._actualErr(e) : Be(e))
		}
		then(e, t) {
			return this._ensureActual().then(e, t)
		}
		catch(e) {
			return this._ensureActual().then(void 0, e)
		}
		finally(e) {
			return this._ensureActual().finally(e)
		}
	},
	mb = class extends Uf {
		constructor() {
			super(), (this._hasErr = !0), (this._err = new xt())
		}
	}
function aP(o, e) {
	try {
		return JSON.stringify(o, e)
	} catch {
		return "null"
	}
}
var dP = "$$ref$$",
	q5 = { [dP]: -1 }
function ZO(o, e = null, t = !1) {
	let n = []
	return {
		jsonString: (t ? aP : JSON.stringify)(o, (i, s) => {
			if (typeof s > "u") return q5
			if (typeof s == "object") {
				if (s instanceof z) {
					let a = n.push(s) - 1
					return { [dP]: a }
				}
				if (e) return e(i, s)
			}
			return s
		}),
		referencedBuffers: n,
	}
}
function rL(o, e, t) {
	return JSON.parse(o, (n, r) => {
		if (r) {
			let i = r[dP]
			if (typeof i == "number") return e[i]
			if (t && r.$mid === 1) return t.transformIncoming(r)
		}
		return r
	})
}
function eL(o, e) {
	return JSON.stringify(o, e)
}
function K5(o) {
	return o ? (e, t) => (t && t.$mid === 1 ? o.transformOutgoing(t) : t) : null
}
var j5 = () => {},
	G5 = Symbol.for("rpcProtocol"),
	Q5 = Symbol.for("rpcProxy"),
	tL,
	nL,
	Uc = class o extends ((nL = $), (tL = G5), nL) {
		constructor(t, n = null, r = null) {
			super()
			this[tL] = !0
			this._onDidChangeResponsiveState = this._register(new E())
			this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event
			;(this._protocol = t),
				(this._logger = n),
				(this._uriTransformer = r),
				(this._uriReplacer = K5(this._uriTransformer)),
				(this._isDisposed = !1),
				(this._locals = []),
				(this._proxies = [])
			for (let i = 0, s = Ff.count; i < s; i++) (this._locals[i] = null), (this._proxies[i] = null)
			;(this._lastMessageId = 0),
				(this._cancelInvokedHandlers = Object.create(null)),
				(this._pendingRPCReplies = {}),
				(this._responsiveState = 0),
				(this._unacknowledgedCount = 0),
				(this._unresponsiveTime = 0),
				(this._asyncCheckUresponsive = this._register(new Wn(() => this._checkUnresponsive(), 1e3))),
				this._register(this._protocol.onMessage((i) => this._receiveOneMessage(i)))
		}
		static {
			this.UNRESPONSIVE_TIME = 3 * 1e3
		}
		dispose() {
			;(this._isDisposed = !0),
				Object.keys(this._pendingRPCReplies).forEach((t) => {
					let n = this._pendingRPCReplies[t]
					delete this._pendingRPCReplies[t], n.resolveErr(Ki())
				}),
				super.dispose()
		}
		drain() {
			return typeof this._protocol.drain == "function" ? this._protocol.drain() : Promise.resolve()
		}
		_onWillSendRequest(t) {
			this._unacknowledgedCount === 0 && (this._unresponsiveTime = Date.now() + o.UNRESPONSIVE_TIME),
				this._unacknowledgedCount++,
				this._asyncCheckUresponsive.isScheduled() || this._asyncCheckUresponsive.schedule()
		}
		_onDidReceiveAcknowledge(t) {
			;(this._unresponsiveTime = Date.now() + o.UNRESPONSIVE_TIME),
				this._unacknowledgedCount--,
				this._unacknowledgedCount === 0 && this._asyncCheckUresponsive.cancel(),
				this._setResponsiveState(0)
		}
		_checkUnresponsive() {
			this._unacknowledgedCount !== 0 &&
				(Date.now() > this._unresponsiveTime
					? this._setResponsiveState(1)
					: this._asyncCheckUresponsive.schedule())
		}
		_setResponsiveState(t) {
			this._responsiveState !== t &&
				((this._responsiveState = t), this._onDidChangeResponsiveState.fire(this._responsiveState))
		}
		get responsiveState() {
			return this._responsiveState
		}
		transformIncomingURIs(t) {
			return this._uriTransformer ? Nc(t, this._uriTransformer) : t
		}
		getProxy(t) {
			let { nid: n, sid: r } = t
			return this._proxies[n] || (this._proxies[n] = this._createProxy(n, r)), this._proxies[n]
		}
		_createProxy(t, n) {
			let r = {
				get: (i, s) => (
					typeof s == "string" &&
						!i[s] &&
						s.charCodeAt(0) === 36 &&
						(i[s] = (...a) => this._remoteCall(t, s, a)),
					s === Q5 ? n : i[s]
				),
			}
			return new Proxy(Object.create(null), r)
		}
		set(t, n) {
			return (this._locals[t.nid] = n), n
		}
		assertRegistered(t) {
			for (let n = 0, r = t.length; n < r; n++) {
				let i = t[n]
				if (!this._locals[i.nid]) throw new Error(`Missing proxy instance ${i.sid}`)
			}
		}
		_receiveOneMessage(t) {
			if (this._isDisposed) return
			let n = t.byteLength,
				r = Kt.read(t, 0),
				i = r.readUInt8(),
				s = r.readUInt32()
			switch ((this._logger?.logIncoming(n, s, 1, `receiveMessage: ${i}, req: ${s}, msgType: ${i}`), i)) {
				case 1:
				case 2: {
					let { rpcId: a, method: l, args: d } = Lr.deserializeRequestJSONArgs(r)
					this._uriTransformer && (d = Nc(d, this._uriTransformer)),
						this._receiveRequest(n, s, a, l, d, i === 2)
					break
				}
				case 3:
				case 4: {
					let { rpcId: a, method: l, args: d } = Lr.deserializeRequestMixedArgs(r)
					this._uriTransformer && (d = Nc(d, this._uriTransformer)),
						this._receiveRequest(n, s, a, l, d, i === 4)
					break
				}
				case 5: {
					this._onDidReceiveAcknowledge(s)
					break
				}
				case 6: {
					this._receiveCancel(n, s)
					break
				}
				case 7: {
					this._receiveReply(n, s, void 0)
					break
				}
				case 9: {
					let a = Lr.deserializeReplyOKJSON(r)
					this._uriTransformer && (a = Nc(a, this._uriTransformer)), this._receiveReply(n, s, a)
					break
				}
				case 10: {
					let a = Lr.deserializeReplyOKJSONWithBuffers(r, this._uriTransformer)
					this._receiveReply(n, s, a)
					break
				}
				case 8: {
					let a = Lr.deserializeReplyOKVSBuffer(r)
					this._receiveReply(n, s, a)
					break
				}
				case 11: {
					let a = Lr.deserializeReplyErrError(r)
					this._uriTransformer && (a = Nc(a, this._uriTransformer)), this._receiveReplyErr(n, s, a)
					break
				}
				case 12: {
					this._receiveReplyErr(n, s, void 0)
					break
				}
				default:
					console.error("received unexpected message"), console.error(t)
			}
		}
		_receiveRequest(t, n, r, i, s, a) {
			this._logger?.logIncoming(t, n, 1, `receiveRequest ${Nf(r)}.${i}(`, s)
			let l = String(n),
				d,
				c
			if (a) {
				let m = new _e()
				s.push(m.token), (d = this._invokeHandler(r, i, s)), (c = () => m.cancel())
			} else (d = this._invokeHandler(r, i, s)), (c = j5)
			this._cancelInvokedHandlers[l] = c
			let u = Lr.serializeAcknowledged(n)
			this._logger?.logOutgoing(u.byteLength, n, 1, "ack"),
				this._protocol.send(u),
				d.then(
					(m) => {
						delete this._cancelInvokedHandlers[l]
						let f = Lr.serializeReplyOK(n, m, this._uriReplacer)
						this._logger?.logOutgoing(f.byteLength, n, 1, "reply:", m), this._protocol.send(f)
					},
					(m) => {
						delete this._cancelInvokedHandlers[l]
						let f = Lr.serializeReplyErr(n, m)
						this._logger?.logOutgoing(f.byteLength, n, 1, "replyErr:", m), this._protocol.send(f)
					},
				)
		}
		_receiveCancel(t, n) {
			this._logger?.logIncoming(t, n, 1, "receiveCancel")
			let r = String(n)
			this._cancelInvokedHandlers[r]?.()
		}
		_receiveReply(t, n, r) {
			this._logger?.logIncoming(t, n, 0, "receiveReply:", r)
			let i = String(n)
			if (!this._pendingRPCReplies.hasOwnProperty(i)) return
			let s = this._pendingRPCReplies[i]
			delete this._pendingRPCReplies[i], s.resolveOk(r)
		}
		_receiveReplyErr(t, n, r) {
			this._logger?.logIncoming(t, n, 0, "receiveReplyErr:", r)
			let i = String(n)
			if (!this._pendingRPCReplies.hasOwnProperty(i)) return
			let s = this._pendingRPCReplies[i]
			delete this._pendingRPCReplies[i]
			let a
			r &&
				(r.$isError
					? ((a = new Error()), (a.name = r.name), (a.message = r.message), (a.stack = r.stack))
					: (a = r)),
				s.resolveErr(a)
		}
		_invokeHandler(t, n, r) {
			try {
				return Promise.resolve(this._doInvokeHandler(t, n, r))
			} catch (i) {
				return console.error("invokeHandler error:", i), Promise.reject(i)
			}
		}
		_doInvokeHandler(t, n, r) {
			let i = this._locals[t]
			if (!i) throw new Error("Unknown actor " + Nf(t))
			let s = i[n]
			if (typeof s != "function") throw new Error("Unknown method " + n + " on actor " + Nf(t))
			return s.apply(i, r)
		}
		_remoteCall(t, n, r) {
			if (this._isDisposed) return new mb()
			let i = null
			if (
				(r.length > 0 && De.isCancellationToken(r[r.length - 1]) && (i = r.pop()),
				i && i.isCancellationRequested)
			)
				return Promise.reject(Ki())
			let s = Lr.serializeRequestArguments(r, this._uriReplacer),
				a = ++this._lastMessageId,
				l = String(a),
				d = new Uf(),
				c = new Q()
			i &&
				c.add(
					i.onCancellationRequested(() => {
						let m = Lr.serializeCancel(a)
						this._logger?.logOutgoing(m.byteLength, a, 0, "cancel"), this._protocol.send(m)
					}),
				),
				(this._pendingRPCReplies[l] = new lP(d, c)),
				this._onWillSendRequest(a)
			let u = Lr.serializeRequest(a, t, n, s, !!i)
			return (
				this._logger?.logOutgoing(u.byteLength, a, 0, `request: ${Nf(t)}.${n}(`, r), this._protocol.send(u), d
			)
		}
	},
	lP = class {
		constructor(e, t) {
			this._promise = e
			this._disposable = t
		}
		resolveOk(e) {
			this._promise.resolveOk(e), this._disposable.dispose()
		}
		resolveErr(e) {
			this._promise.resolveErr(e), this._disposable.dispose()
		}
	},
	Kt = class o {
		static alloc(e, t, n) {
			let r = new o(z.alloc(n + 1 + 4), 0)
			return r.writeUInt8(e), r.writeUInt32(t), r
		}
		static read(e, t) {
			return new o(e, t)
		}
		get buffer() {
			return this._buff
		}
		constructor(e, t) {
			;(this._buff = e), (this._offset = t)
		}
		static sizeUInt8() {
			return 1
		}
		static {
			this.sizeUInt32 = 4
		}
		writeUInt8(e) {
			this._buff.writeUInt8(e, this._offset), (this._offset += 1)
		}
		readUInt8() {
			let e = this._buff.readUInt8(this._offset)
			return (this._offset += 1), e
		}
		writeUInt32(e) {
			this._buff.writeUInt32BE(e, this._offset), (this._offset += 4)
		}
		readUInt32() {
			let e = this._buff.readUInt32BE(this._offset)
			return (this._offset += 4), e
		}
		static sizeShortString(e) {
			return 1 + e.byteLength
		}
		writeShortString(e) {
			this._buff.writeUInt8(e.byteLength, this._offset),
				(this._offset += 1),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readShortString() {
			let e = this._buff.readUInt8(this._offset)
			this._offset += 1
			let n = this._buff.slice(this._offset, this._offset + e).toString()
			return (this._offset += e), n
		}
		static sizeLongString(e) {
			return 4 + e.byteLength
		}
		writeLongString(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readLongString() {
			let e = this._buff.readUInt32BE(this._offset)
			this._offset += 4
			let n = this._buff.slice(this._offset, this._offset + e).toString()
			return (this._offset += e), n
		}
		writeBuffer(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		static sizeVSBuffer(e) {
			return 4 + e.byteLength
		}
		writeVSBuffer(e) {
			this._buff.writeUInt32BE(e.byteLength, this._offset),
				(this._offset += 4),
				this._buff.set(e, this._offset),
				(this._offset += e.byteLength)
		}
		readVSBuffer() {
			let e = this._buff.readUInt32BE(this._offset)
			this._offset += 4
			let t = this._buff.slice(this._offset, this._offset + e)
			return (this._offset += e), t
		}
		static sizeMixedArray(e) {
			let t = 0
			t += 1
			for (let n = 0, r = e.length; n < r; n++) {
				let i = e[n]
				switch (((t += 1), i.type)) {
					case 1:
						t += this.sizeLongString(i.value)
						break
					case 2:
						t += this.sizeVSBuffer(i.value)
						break
					case 3:
						;(t += this.sizeUInt32), (t += this.sizeLongString(i.value))
						for (let s = 0; s < i.buffers.length; ++s) t += this.sizeVSBuffer(i.buffers[s])
						break
					case 4:
						break
				}
			}
			return t
		}
		writeMixedArray(e) {
			this._buff.writeUInt8(e.length, this._offset), (this._offset += 1)
			for (let t = 0, n = e.length; t < n; t++) {
				let r = e[t]
				switch (r.type) {
					case 1:
						this.writeUInt8(1), this.writeLongString(r.value)
						break
					case 2:
						this.writeUInt8(2), this.writeVSBuffer(r.value)
						break
					case 3:
						this.writeUInt8(3), this.writeUInt32(r.buffers.length), this.writeLongString(r.value)
						for (let i = 0; i < r.buffers.length; ++i) this.writeBuffer(r.buffers[i])
						break
					case 4:
						this.writeUInt8(4)
						break
				}
			}
		}
		readMixedArray() {
			let e = this._buff.readUInt8(this._offset)
			this._offset += 1
			let t = new Array(e)
			for (let n = 0; n < e; n++)
				switch (this.readUInt8()) {
					case 1:
						t[n] = this.readLongString()
						break
					case 2:
						t[n] = this.readVSBuffer()
						break
					case 3: {
						let i = this.readUInt32(),
							s = this.readLongString(),
							a = []
						for (let l = 0; l < i; ++l) a.push(this.readVSBuffer())
						t[n] = new Xt(rL(s, a, null))
						break
					}
					case 4:
						t[n] = void 0
						break
				}
			return t
		}
	}
var Lr = class {
	static _useMixedArgSerialization(e) {
		for (let t = 0, n = e.length; t < n; t++)
			if (e[t] instanceof z || e[t] instanceof Xt || typeof e[t] > "u") return !0
		return !1
	}
	static serializeRequestArguments(e, t) {
		if (this._useMixedArgSerialization(e)) {
			let n = []
			for (let r = 0, i = e.length; r < i; r++) {
				let s = e[r]
				if (s instanceof z) n[r] = { type: 2, value: s }
				else if (typeof s > "u") n[r] = { type: 4 }
				else if (s instanceof Xt) {
					let { jsonString: a, referencedBuffers: l } = ZO(s.value, t)
					n[r] = { type: 3, value: z.fromString(a), buffers: l }
				} else n[r] = { type: 1, value: z.fromString(eL(s, t)) }
			}
			return { type: 1, args: n }
		}
		return { type: 0, args: eL(e, t) }
	}
	static serializeRequest(e, t, n, r, i) {
		switch (r.type) {
			case 0:
				return this._requestJSONArgs(e, t, n, r.args, i)
			case 1:
				return this._requestMixedArgs(e, t, n, r.args, i)
		}
	}
	static _requestJSONArgs(e, t, n, r, i) {
		let s = z.fromString(n),
			a = z.fromString(r),
			l = 0
		;(l += Kt.sizeUInt8()), (l += Kt.sizeShortString(s)), (l += Kt.sizeLongString(a))
		let d = Kt.alloc(i ? 2 : 1, e, l)
		return d.writeUInt8(t), d.writeShortString(s), d.writeLongString(a), d.buffer
	}
	static deserializeRequestJSONArgs(e) {
		let t = e.readUInt8(),
			n = e.readShortString(),
			r = e.readLongString()
		return { rpcId: t, method: n, args: JSON.parse(r) }
	}
	static _requestMixedArgs(e, t, n, r, i) {
		let s = z.fromString(n),
			a = 0
		;(a += Kt.sizeUInt8()), (a += Kt.sizeShortString(s)), (a += Kt.sizeMixedArray(r))
		let l = Kt.alloc(i ? 4 : 3, e, a)
		return l.writeUInt8(t), l.writeShortString(s), l.writeMixedArray(r), l.buffer
	}
	static deserializeRequestMixedArgs(e) {
		let t = e.readUInt8(),
			n = e.readShortString(),
			r = e.readMixedArray(),
			i = new Array(r.length)
		for (let s = 0, a = r.length; s < a; s++) {
			let l = r[s]
			typeof l == "string" ? (i[s] = JSON.parse(l)) : (i[s] = l)
		}
		return { rpcId: t, method: n, args: i }
	}
	static serializeAcknowledged(e) {
		return Kt.alloc(5, e, 0).buffer
	}
	static serializeCancel(e) {
		return Kt.alloc(6, e, 0).buffer
	}
	static serializeReplyOK(e, t, n) {
		if (typeof t > "u") return this._serializeReplyOKEmpty(e)
		if (t instanceof z) return this._serializeReplyOKVSBuffer(e, t)
		if (t instanceof Xt) {
			let { jsonString: r, referencedBuffers: i } = ZO(t.value, n, !0)
			return this._serializeReplyOKJSONWithBuffers(e, r, i)
		} else return this._serializeReplyOKJSON(e, aP(t, n))
	}
	static _serializeReplyOKEmpty(e) {
		return Kt.alloc(7, e, 0).buffer
	}
	static _serializeReplyOKVSBuffer(e, t) {
		let n = 0
		n += Kt.sizeVSBuffer(t)
		let r = Kt.alloc(8, e, n)
		return r.writeVSBuffer(t), r.buffer
	}
	static deserializeReplyOKVSBuffer(e) {
		return e.readVSBuffer()
	}
	static _serializeReplyOKJSON(e, t) {
		let n = z.fromString(t),
			r = 0
		r += Kt.sizeLongString(n)
		let i = Kt.alloc(9, e, r)
		return i.writeLongString(n), i.buffer
	}
	static _serializeReplyOKJSONWithBuffers(e, t, n) {
		let r = z.fromString(t),
			i = 0
		;(i += Kt.sizeUInt32), (i += Kt.sizeLongString(r))
		for (let a of n) i += Kt.sizeVSBuffer(a)
		let s = Kt.alloc(10, e, i)
		s.writeUInt32(n.length), s.writeLongString(r)
		for (let a of n) s.writeBuffer(a)
		return s.buffer
	}
	static deserializeReplyOKJSON(e) {
		let t = e.readLongString()
		return JSON.parse(t)
	}
	static deserializeReplyOKJSONWithBuffers(e, t) {
		let n = e.readUInt32(),
			r = e.readLongString(),
			i = []
		for (let s = 0; s < n; ++s) i.push(e.readVSBuffer())
		return new Xt(rL(r, i, t))
	}
	static serializeReplyErr(e, t) {
		let n = t ? aP(Do(t), null) : void 0
		if (typeof n != "string") return this._serializeReplyErrEmpty(e)
		let r = z.fromString(n),
			i = 0
		i += Kt.sizeLongString(r)
		let s = Kt.alloc(11, e, i)
		return s.writeLongString(r), s.buffer
	}
	static deserializeReplyErrError(e) {
		let t = e.readLongString()
		return JSON.parse(t)
	}
	static _serializeReplyErrEmpty(e) {
		return Kt.alloc(12, e, 0).buffer
	}
}
function Ql(o) {
	if (!o) return
	let e = o.indexOf("+")
	return e < 0 ? o : o.substr(0, e)
}
var oL = [
	"AI",
	"Azure",
	"Chat",
	"Data Science",
	"Debuggers",
	"Extension Packs",
	"Education",
	"Formatters",
	"Keymaps",
	"Language Packs",
	"Linters",
	"Machine Learning",
	"Notebooks",
	"Programming Languages",
	"SCM Providers",
	"Snippets",
	"Testing",
	"Themes",
	"Visualization",
	"Other",
]
var Ce = class {
		constructor(e) {
			;(this.value = e), (this._lower = e.toLowerCase())
		}
		static equals(e, t) {
			if (typeof e > "u" || e === null) return typeof t > "u" || t === null
			if (typeof t > "u" || t === null) return !1
			if (typeof e == "string" || typeof t == "string") {
				let n = typeof e == "string" ? e : e.value,
					r = typeof t == "string" ? t : t.value
				return xn(n, r)
			}
			return e._lower === t._lower
		}
		static toKey(e) {
			return typeof e == "string" ? e.toLowerCase() : e._lower
		}
	},
	ar = class {
		constructor(e) {
			this._set = new Set()
			if (e) for (let t of e) this.add(t)
		}
		get size() {
			return this._set.size
		}
		add(e) {
			this._set.add(Ce.toKey(e))
		}
		delete(e) {
			return this._set.delete(Ce.toKey(e))
		}
		has(e) {
			return this._set.has(Ce.toKey(e))
		}
	},
	Ln = class {
		constructor() {
			this._map = new Map()
		}
		clear() {
			this._map.clear()
		}
		delete(e) {
			this._map.delete(Ce.toKey(e))
		}
		get(e) {
			return this._map.get(Ce.toKey(e))
		}
		has(e) {
			return this._map.has(Ce.toKey(e))
		}
		set(e, t) {
			this._map.set(Ce.toKey(e), t)
		}
		values() {
			return this._map.values()
		}
		forEach(e) {
			this._map.forEach(e)
		}
		[Symbol.iterator]() {
			return this._map[Symbol.iterator]()
		}
	},
	Hc = class extends Error {
		constructor(e, t, n) {
			super(`Error in extension ${Ce.toKey(e)}: ${n ?? t.message}`, { cause: t }),
				(this.name = "ExtensionError"),
				(this.extension = e)
		}
	}
var mj = O("IBuiltinExtensionsScannerService")
function cP(o, e) {
	return e && (o.stack || o.stacktrace)
		? p("stackTrace.format", "{0}: {1}", sL(o), iL(o.stack) || iL(o.stacktrace))
		: sL(o)
}
function iL(o) {
	return Array.isArray(o)
		? o.join(`
`)
		: o
}
function sL(o) {
	return o.code === "ERR_UNC_HOST_NOT_ALLOWED"
		? `${o.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`
		: typeof o.code == "string" && typeof o.errno == "number" && typeof o.syscall == "string"
			? p("nodeExceptionMessage", "A system error occurred ({0})", o.message)
			: o.message ||
				p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
}
function Xn(o = null, e = !1) {
	if (!o) return p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
	if (Array.isArray(o)) {
		let t = Ye(o),
			n = Xn(t[0], e)
		return t.length > 1 ? p("error.moreErrors", "{0} ({1} errors in total)", n, t.length) : n
	}
	if (we(o)) return o
	if (o.detail) {
		let t = o.detail
		if (t.error) return cP(t.error, e)
		if (t.exception) return cP(t.exception, e)
	}
	return o.stack
		? cP(o, e)
		: o.message
			? o.message
			: p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.")
}
function lr(o) {
	return pP(o, 0)
}
function pP(o, e) {
	switch (typeof o) {
		case "object":
			return o === null ? ls(349, e) : Array.isArray(o) ? X5(o, e) : Y5(o, e)
		case "string":
			return lL(o, e)
		case "boolean":
			return J5(o, e)
		case "number":
			return ls(o, e)
		case "undefined":
			return ls(937, e)
		default:
			return ls(617, e)
	}
}
function ls(o, e) {
	return ((e << 5) - e + o) | 0
}
function J5(o, e) {
	return ls(o ? 433 : 863, e)
}
function lL(o, e) {
	e = ls(149417, e)
	for (let t = 0, n = o.length; t < n; t++) e = ls(o.charCodeAt(t), e)
	return e
}
function X5(o, e) {
	return (e = ls(104579, e)), o.reduce((t, n) => pP(n, t), e)
}
function Y5(o, e) {
	return (
		(e = ls(181387, e)),
		Object.keys(o)
			.sort()
			.reduce((t, n) => ((t = lL(n, t)), pP(o[n], t)), e)
	)
}
function uP(o, e, t = 32) {
	let n = t - e,
		r = ~((1 << n) - 1)
	return ((o << e) | ((r & o) >>> n)) >>> 0
}
function Hf(o, e = 32) {
	return o instanceof ArrayBuffer
		? Array.from(new Uint8Array(o))
				.map((t) => t.toString(16).padStart(2, "0"))
				.join("")
		: (o >>> 0).toString(16).padStart(e / 4, "0")
}
var aL = class o {
	constructor() {
		this._h0 = 1732584193
		this._h1 = 4023233417
		this._h2 = 2562383102
		this._h3 = 271733878
		this._h4 = 3285377520
		;(this._buff = new Uint8Array(67)),
			(this._buffDV = new DataView(this._buff.buffer)),
			(this._buffLen = 0),
			(this._totalLen = 0),
			(this._leftoverHighSurrogate = 0),
			(this._finished = !1)
	}
	static {
		this._bigBlock32 = new DataView(new ArrayBuffer(320))
	}
	update(e) {
		let t = e.length
		if (t === 0) return
		let n = this._buff,
			r = this._buffLen,
			i = this._leftoverHighSurrogate,
			s,
			a
		for (i !== 0 ? ((s = i), (a = -1), (i = 0)) : ((s = e.charCodeAt(0)), (a = 0)); ; ) {
			let l = s
			if (Ul(s))
				if (a + 1 < t) {
					let d = e.charCodeAt(a + 1)
					hf(d) ? (a++, (l = Vv(s, d))) : (l = 65533)
				} else {
					i = s
					break
				}
			else hf(s) && (l = 65533)
			if (((r = this._push(n, r, l)), a++, a < t)) s = e.charCodeAt(a)
			else break
		}
		;(this._buffLen = r), (this._leftoverHighSurrogate = i)
	}
	_push(e, t, n) {
		return (
			n < 128
				? (e[t++] = n)
				: n < 2048
					? ((e[t++] = 192 | ((n & 1984) >>> 6)), (e[t++] = 128 | ((n & 63) >>> 0)))
					: n < 65536
						? ((e[t++] = 224 | ((n & 61440) >>> 12)),
							(e[t++] = 128 | ((n & 4032) >>> 6)),
							(e[t++] = 128 | ((n & 63) >>> 0)))
						: ((e[t++] = 240 | ((n & 1835008) >>> 18)),
							(e[t++] = 128 | ((n & 258048) >>> 12)),
							(e[t++] = 128 | ((n & 4032) >>> 6)),
							(e[t++] = 128 | ((n & 63) >>> 0))),
			t >= 64 &&
				(this._step(), (t -= 64), (this._totalLen += 64), (e[0] = e[64]), (e[1] = e[65]), (e[2] = e[66])),
			t
		)
	}
	digest() {
		return (
			this._finished ||
				((this._finished = !0),
				this._leftoverHighSurrogate &&
					((this._leftoverHighSurrogate = 0), (this._buffLen = this._push(this._buff, this._buffLen, 65533))),
				(this._totalLen += this._buffLen),
				this._wrapUp()),
			Hf(this._h0) + Hf(this._h1) + Hf(this._h2) + Hf(this._h3) + Hf(this._h4)
		)
	}
	_wrapUp() {
		;(this._buff[this._buffLen++] = 128),
			this._buff.subarray(this._buffLen).fill(0),
			this._buffLen > 56 && (this._step(), this._buff.fill(0))
		let e = 8 * this._totalLen
		this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1),
			this._buffDV.setUint32(60, e % 4294967296, !1),
			this._step()
	}
	_step() {
		let e = o._bigBlock32,
			t = this._buffDV
		for (let u = 0; u < 64; u += 4) e.setUint32(u, t.getUint32(u, !1), !1)
		for (let u = 64; u < 320; u += 4)
			e.setUint32(
				u,
				uP(
					e.getUint32(u - 12, !1) ^
						e.getUint32(u - 32, !1) ^
						e.getUint32(u - 56, !1) ^
						e.getUint32(u - 64, !1),
					1,
				),
				!1,
			)
		let n = this._h0,
			r = this._h1,
			i = this._h2,
			s = this._h3,
			a = this._h4,
			l,
			d,
			c
		for (let u = 0; u < 80; u++)
			u < 20
				? ((l = (r & i) | (~r & s)), (d = 1518500249))
				: u < 40
					? ((l = r ^ i ^ s), (d = 1859775393))
					: u < 60
						? ((l = (r & i) | (r & s) | (i & s)), (d = 2400959708))
						: ((l = r ^ i ^ s), (d = 3395469782)),
				(c = (uP(n, 5) + l + a + d + e.getUint32(u * 4, !1)) & 4294967295),
				(a = s),
				(s = i),
				(i = uP(r, 30)),
				(r = n),
				(n = c)
		;(this._h0 = (this._h0 + n) & 4294967295),
			(this._h1 = (this._h1 + r) & 4294967295),
			(this._h2 = (this._h2 + i) & 4294967295),
			(this._h3 = (this._h3 + s) & 4294967295),
			(this._h4 = (this._h4 + a) & 4294967295)
	}
}
var te = O("logService"),
	uo = O("loggerService")
var ha = ((s) => (
		(s[(s.Off = 0)] = "Off"),
		(s[(s.Trace = 1)] = "Trace"),
		(s[(s.Debug = 2)] = "Debug"),
		(s[(s.Info = 3)] = "Info"),
		(s[(s.Warning = 4)] = "Warning"),
		(s[(s.Error = 5)] = "Error"),
		s
	))(ha || {}),
	Z5 = 3
function eW(o, e) {
	return o !== 0 && o <= e
}
function dL(o, e, t) {
	switch (e) {
		case 1:
			o.trace(t)
			break
		case 2:
			o.debug(t)
			break
		case 3:
			o.info(t)
			break
		case 4:
			o.warn(t)
			break
		case 5:
			o.error(t)
			break
		case 0:
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
function Wc(o, e = !1) {
	let t = ""
	for (let n = 0; n < o.length; n++) {
		let r = o[n]
		if ((r instanceof Error && (r = Xn(r, e)), typeof r == "object"))
			try {
				r = JSON.stringify(r)
			} catch {}
		t += (n > 0 ? " " : "") + r
	}
	return t
}
var fb = class extends $ {
		constructor() {
			super(...arguments)
			this.level = Z5
			this._onDidChangeLogLevel = this._register(new E())
			this.onDidChangeLogLevel = this._onDidChangeLogLevel.event
		}
		setLevel(t) {
			this.level !== t && ((this.level = t), this._onDidChangeLogLevel.fire(this.level))
		}
		getLevel() {
			return this.level
		}
		checkLogLevel(t) {
			return eW(this.level, t)
		}
		canLog(t) {
			return this._store.isDisposed ? !1 : this.checkLogLevel(t)
		}
	},
	ga = class extends fb {
		constructor(t) {
			super()
			this.logAlways = t
		}
		checkLogLevel(t) {
			return this.logAlways || super.checkLogLevel(t)
		}
		trace(t, ...n) {
			this.canLog(1) && this.log(1, Wc([t, ...n], !0))
		}
		debug(t, ...n) {
			this.canLog(2) && this.log(2, Wc([t, ...n]))
		}
		info(t, ...n) {
			this.canLog(3) && this.log(3, Wc([t, ...n]))
		}
		warn(t, ...n) {
			this.canLog(4) && this.log(4, Wc([t, ...n]))
		}
		error(t, ...n) {
			if (this.canLog(5))
				if (t instanceof Error) {
					let r = Array.prototype.slice.call(arguments)
					;(r[0] = t.stack), this.log(5, Wc(r))
				} else this.log(5, Wc([t, ...n]))
		}
		flush() {}
	}
var gb = class extends fb {
		constructor(t) {
			super()
			this.loggers = t
			t.length && this.setLevel(t[0].getLevel())
		}
		setLevel(t) {
			for (let n of this.loggers) n.setLevel(t)
			super.setLevel(t)
		}
		trace(t, ...n) {
			for (let r of this.loggers) r.trace(t, ...n)
		}
		debug(t, ...n) {
			for (let r of this.loggers) r.debug(t, ...n)
		}
		info(t, ...n) {
			for (let r of this.loggers) r.info(t, ...n)
		}
		warn(t, ...n) {
			for (let r of this.loggers) r.warn(t, ...n)
		}
		error(t, ...n) {
			for (let r of this.loggers) r.error(t, ...n)
		}
		flush() {
			for (let t of this.loggers) t.flush()
		}
		dispose() {
			for (let t of this.loggers) t.dispose()
			super.dispose()
		}
	},
	hb = class extends $ {
		constructor(t, n, r) {
			super()
			this.logLevel = t
			this.logsHome = n
			this._loggers = new ft()
			this._onDidChangeLoggers = this._register(new E())
			this.onDidChangeLoggers = this._onDidChangeLoggers.event
			this._onDidChangeLogLevel = this._register(new E())
			this.onDidChangeLogLevel = this._onDidChangeLogLevel.event
			this._onDidChangeVisibility = this._register(new E())
			this.onDidChangeVisibility = this._onDidChangeVisibility.event
			if (r) for (let i of r) this._loggers.set(i.resource, { logger: void 0, info: i })
		}
		getLoggerEntry(t) {
			return we(t) ? [...this._loggers.values()].find((n) => n.info.id === t) : this._loggers.get(t)
		}
		getLogger(t) {
			return this.getLoggerEntry(t)?.logger
		}
		createLogger(t, n) {
			let r = this.toResource(t),
				i = we(t) ? t : (n?.id ?? lr(r.toString()).toString(16)),
				s = this._loggers.get(r)?.logger,
				a = n?.logLevel === "always" ? 1 : n?.logLevel
			s || (s = this.doCreateLogger(r, a ?? this.getLogLevel(r) ?? this.logLevel, { ...n, id: i }))
			let l = {
				logger: s,
				info: {
					resource: r,
					id: i,
					logLevel: a,
					name: n?.name,
					hidden: n?.hidden,
					group: n?.group,
					extensionId: n?.extensionId,
					when: n?.when,
				},
			}
			return this.registerLogger(l.info), this._loggers.set(r, l), s
		}
		toResource(t) {
			return we(t) ? ct(this.logsHome, `${t}.log`) : t
		}
		setLogLevel(t, n) {
			if (b.isUri(t)) {
				let r = t,
					i = n,
					s = this._loggers.get(r)
				s &&
					i !== s.info.logLevel &&
					((s.info.logLevel = i === this.logLevel ? void 0 : i),
					s.logger?.setLevel(i),
					this._loggers.set(s.info.resource, s),
					this._onDidChangeLogLevel.fire([r, i]))
			} else {
				this.logLevel = t
				for (let [r, i] of this._loggers.entries())
					this._loggers.get(r)?.info.logLevel === void 0 && i.logger?.setLevel(this.logLevel)
				this._onDidChangeLogLevel.fire(this.logLevel)
			}
		}
		setVisibility(t, n) {
			let r = this.getLoggerEntry(t)
			r &&
				n !== !r.info.hidden &&
				((r.info.hidden = !n),
				this._loggers.set(r.info.resource, r),
				this._onDidChangeVisibility.fire([r.info.resource, n]))
		}
		getLogLevel(t) {
			let n
			return t && (n = this._loggers.get(t)?.info.logLevel), n ?? this.logLevel
		}
		registerLogger(t) {
			let n = this._loggers.get(t.resource)
			n
				? n.info.hidden !== t.hidden && this.setVisibility(t.resource, !t.hidden)
				: (this._loggers.set(t.resource, { info: t, logger: void 0 }),
					this._onDidChangeLoggers.fire({ added: [t], removed: [] }))
		}
		deregisterLogger(t) {
			let n = this.toResource(t),
				r = this._loggers.get(n)
			r &&
				(r.logger && r.logger.dispose(),
				this._loggers.delete(n),
				this._onDidChangeLoggers.fire({ added: [], removed: [r.info] }))
		}
		*getRegisteredLoggers() {
			for (let t of this._loggers.values()) yield t.info
		}
		getRegisteredLogger(t) {
			return this._loggers.get(t)?.info
		}
		dispose() {
			this._loggers.forEach((t) => t.logger?.dispose()), this._loggers.clear(), super.dispose()
		}
	},
	mP = class {
		constructor() {
			this.onDidChangeLogLevel = new E().event
		}
		setLevel(e) {}
		getLevel() {
			return 3
		}
		trace(e, ...t) {}
		debug(e, ...t) {}
		info(e, ...t) {}
		warn(e, ...t) {}
		error(e, ...t) {}
		critical(e, ...t) {}
		dispose() {}
		flush() {}
	},
	ds = class extends mP {}
function tW(o) {
	switch (o) {
		case 1:
			return "trace"
		case 2:
			return "debug"
		case 3:
			return "info"
		case 4:
			return "warn"
		case 5:
			return "error"
		case 0:
			return "off"
	}
}
function cL(o) {
	switch (o) {
		case "trace":
			return 1
		case "debug":
			return 2
		case "info":
			return 3
		case "warn":
			return 4
		case "error":
			return 5
		case "critical":
			return 5
		case "off":
			return 0
	}
}
var Aj = new D("logLevel", tW(3))
var hr = class {
	constructor(e, t = [], n = !1) {
		;(this.ctor = e), (this.staticArguments = t), (this.supportsDelayedInstantiation = n)
	}
}
var uL = []
function Ke(o, e, t) {
	e instanceof hr || (e = new hr(e, [], !!t)), uL.push([o, e])
}
function pL() {
	return uL
}
var va = class {
	constructor(...e) {
		this._entries = new Map()
		for (let [t, n] of e) this.set(t, n)
	}
	set(e, t) {
		let n = this._entries.get(e)
		return this._entries.set(e, t), n
	}
	has(e) {
		return this._entries.has(e)
	}
	get(e) {
		return this._entries.get(e)
	}
}
var Xe = O("IExtHostInitDataService")
var fP = class {
		constructor(e, t) {
			this.key = e
			this.data = t
			this.incoming = new Map()
			this.outgoing = new Map()
		}
	},
	Wf = class {
		constructor(e) {
			this._hashFn = e
			this._nodes = new Map()
		}
		roots() {
			let e = []
			for (let t of this._nodes.values()) t.outgoing.size === 0 && e.push(t)
			return e
		}
		insertEdge(e, t) {
			let n = this.lookupOrInsertNode(e),
				r = this.lookupOrInsertNode(t)
			n.outgoing.set(r.key, r), r.incoming.set(n.key, n)
		}
		removeNode(e) {
			let t = this._hashFn(e)
			this._nodes.delete(t)
			for (let n of this._nodes.values()) n.outgoing.delete(t), n.incoming.delete(t)
		}
		lookupOrInsertNode(e) {
			let t = this._hashFn(e),
				n = this._nodes.get(t)
			return n || ((n = new fP(t, e)), this._nodes.set(t, n)), n
		}
		lookup(e) {
			return this._nodes.get(this._hashFn(e))
		}
		isEmpty() {
			return this._nodes.size === 0
		}
		toString() {
			let e = []
			for (let [t, n] of this._nodes)
				e.push(`${t}
	(-> incoming)[${[...n.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...n.outgoing.keys()].join(",")}]
`)
			return e.join(`
`)
		}
		findCycleSlow() {
			for (let [e, t] of this._nodes) {
				let n = new Set([e]),
					r = this._findCycle(t, n)
				if (r) return r
			}
		}
		_findCycle(e, t) {
			for (let [n, r] of e.outgoing) {
				if (t.has(n)) return [...t, n].join(" -> ")
				t.add(n)
				let i = this._findCycle(r, t)
				if (i) return i
				t.delete(n)
			}
		}
	}
var nW = !1,
	vb = class extends Error {
		constructor(e) {
			super("cyclic dependency between services"),
				(this.message =
					e.findCycleSlow() ??
					`UNABLE to detect cycle, dumping graph: 
${e.toString()}`)
		}
	},
	bb = class o {
		constructor(e = new va(), t = !1, n, r = nW) {
			this._services = e
			this._strict = t
			this._parent = n
			this._enableTracing = r
			this._isDisposed = !1
			this._servicesToMaybeDispose = new Set()
			this._children = new Set()
			this._activeInstantiations = new Set()
			this._services.set(Wo, this), (this._globalGraph = r ? (n?._globalGraph ?? new Wf((i) => i)) : void 0)
		}
		dispose() {
			if (!this._isDisposed) {
				;(this._isDisposed = !0), Nn(this._children), this._children.clear()
				for (let e of this._servicesToMaybeDispose) mv(e) && e.dispose()
				this._servicesToMaybeDispose.clear()
			}
		}
		_throwIfDisposed() {
			if (this._isDisposed) throw new Error("InstantiationService has been disposed")
		}
		createChild(e, t) {
			this._throwIfDisposed()
			let n = this,
				r = new (class extends o {
					dispose() {
						n._children.delete(r), super.dispose()
					}
				})(e, this._strict, this, this._enableTracing)
			return this._children.add(r), t?.add(r), r
		}
		invokeFunction(e, ...t) {
			this._throwIfDisposed()
			let n = Vf.traceInvocation(this._enableTracing, e),
				r = !1
			try {
				return e(
					{
						get: (s) => {
							if (r) throw uc("service accessor is only valid during the invocation of its target method")
							let a = this._getOrCreateServiceInstance(s, n)
							if (!a) throw new Error(`[invokeFunction] unknown service '${s}'`)
							return a
						},
					},
					...t,
				)
			} finally {
				;(r = !0), n.stop()
			}
		}
		createInstance(e, ...t) {
			this._throwIfDisposed()
			let n, r
			return (
				e instanceof hr
					? ((n = Vf.traceCreation(this._enableTracing, e.ctor)),
						(r = this._createInstance(e.ctor, e.staticArguments.concat(t), n)))
					: ((n = Vf.traceCreation(this._enableTracing, e)), (r = this._createInstance(e, t, n))),
				n.stop(),
				r
			)
		}
		_createInstance(e, t = [], n) {
			let r = Ho.getServiceDependencies(e).sort((a, l) => a.index - l.index),
				i = []
			for (let a of r) {
				let l = this._getOrCreateServiceInstance(a.id, n)
				l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1),
					i.push(l)
			}
			let s = r.length > 0 ? r[0].index : t.length
			if (t.length !== s) {
				console.trace(
					`[createInstance] First service dependency of ${e.name} at position ${s + 1} conflicts with ${t.length} static arguments`,
				)
				let a = s - t.length
				a > 0 ? (t = t.concat(new Array(a))) : (t = t.slice(0, s))
			}
			return Reflect.construct(e, t.concat(i))
		}
		_setCreatedServiceInstance(e, t) {
			if (this._services.get(e) instanceof hr) this._services.set(e, t)
			else if (this._parent) this._parent._setCreatedServiceInstance(e, t)
			else throw new Error("illegalState - setting UNKNOWN service instance")
		}
		_getServiceInstanceOrDescriptor(e) {
			let t = this._services.get(e)
			return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t
		}
		_getOrCreateServiceInstance(e, t) {
			this._globalGraph &&
				this._globalGraphImplicitDependency &&
				this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e))
			let n = this._getServiceInstanceOrDescriptor(e)
			return n instanceof hr
				? this._safeCreateAndCacheServiceInstance(e, n, t.branch(e, !0))
				: (t.branch(e, !1), n)
		}
		_safeCreateAndCacheServiceInstance(e, t, n) {
			if (this._activeInstantiations.has(e))
				throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`)
			this._activeInstantiations.add(e)
			try {
				return this._createAndCacheServiceInstance(e, t, n)
			} finally {
				this._activeInstantiations.delete(e)
			}
		}
		_createAndCacheServiceInstance(e, t, n) {
			let r = new Wf((l) => l.id.toString()),
				i = 0,
				s = [{ id: e, desc: t, _trace: n }],
				a = new Set()
			for (; s.length; ) {
				let l = s.pop()
				if (!a.has(String(l.id))) {
					if ((a.add(String(l.id)), r.lookupOrInsertNode(l), i++ > 1e3)) throw new vb(r)
					for (let d of Ho.getServiceDependencies(l.desc.ctor)) {
						let c = this._getServiceInstanceOrDescriptor(d.id)
						if (
							(c ||
								this._throwIfStrict(
									`[createInstance] ${e} depends on ${d.id} which is NOT registered.`,
									!0,
								),
							this._globalGraph?.insertEdge(String(l.id), String(d.id)),
							c instanceof hr)
						) {
							let u = { id: d.id, desc: c, _trace: l._trace.branch(d.id, !0) }
							r.insertEdge(l, u), s.push(u)
						}
					}
				}
			}
			for (;;) {
				let l = r.roots()
				if (l.length === 0) {
					if (!r.isEmpty()) throw new vb(r)
					break
				}
				for (let { data: d } of l) {
					if (this._getServiceInstanceOrDescriptor(d.id) instanceof hr) {
						let u = this._createServiceInstanceWithOwner(
							d.id,
							d.desc.ctor,
							d.desc.staticArguments,
							d.desc.supportsDelayedInstantiation,
							d._trace,
						)
						this._setCreatedServiceInstance(d.id, u)
					}
					r.removeNode(d)
				}
			}
			return this._getServiceInstanceOrDescriptor(e)
		}
		_createServiceInstanceWithOwner(e, t, n = [], r, i) {
			if (this._services.get(e) instanceof hr)
				return this._createServiceInstance(e, t, n, r, i, this._servicesToMaybeDispose)
			if (this._parent) return this._parent._createServiceInstanceWithOwner(e, t, n, r, i)
			throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)
		}
		_createServiceInstance(e, t, n = [], r, i, s) {
			if (r) {
				let a = new o(void 0, this._strict, this, this._enableTracing)
				a._globalGraphImplicitDependency = String(e)
				let l = new Map(),
					d = new Yv(() => {
						let c = a._createInstance(t, n, i)
						for (let [u, m] of l) {
							let f = c[u]
							if (typeof f == "function") for (let h of m) h.disposable = f.apply(c, h.listener)
						}
						return l.clear(), s.add(c), c
					})
				return new Proxy(Object.create(null), {
					get(c, u) {
						if (
							!d.isInitialized &&
							typeof u == "string" &&
							(u.startsWith("onDid") || u.startsWith("onWill"))
						) {
							let h = l.get(u)
							return (
								h || ((h = new Ao()), l.set(u, h)),
								(I, C, T) => {
									if (d.isInitialized) return d.value[u](I, C, T)
									{
										let w = { listener: [I, C, T], disposable: void 0 },
											L = h.push(w)
										return q(() => {
											L(), w.disposable?.dispose()
										})
									}
								}
							)
						}
						if (u in c) return c[u]
						let m = d.value,
							f = m[u]
						return typeof f != "function" || ((f = f.bind(m)), (c[u] = f)), f
					},
					set(c, u, m) {
						return (d.value[u] = m), !0
					},
					getPrototypeOf(c) {
						return t.prototype
					},
				})
			} else {
				let a = this._createInstance(t, n, i)
				return s.add(a), a
			}
		}
		_throwIfStrict(e, t) {
			if ((t && console.warn(e), this._strict)) throw new Error(e)
		}
	}
var Vf = class o {
	constructor(e, t) {
		this.type = e
		this.name = t
		this._start = Date.now()
		this._dep = []
	}
	static {
		this.all = new Set()
	}
	static {
		this._None = new (class extends o {
			constructor() {
				super(0, null)
			}
			stop() {}
			branch() {
				return this
			}
		})()
	}
	static traceInvocation(e, t) {
		return e
			? new o(
					2,
					t.name ||
						new Error().stack
							.split(
								`
`,
							)
							.slice(3, 4).join(`
`),
				)
			: o._None
	}
	static traceCreation(e, t) {
		return e ? new o(1, t.name) : o._None
	}
	static {
		this._totals = 0
	}
	branch(e, t) {
		let n = new o(3, e.toString())
		return this._dep.push([e, t, n]), n
	}
	stop() {
		let e = Date.now() - this._start
		o._totals += e
		let t = !1
		function n(i, s) {
			let a = [],
				l = new Array(i + 1).join("	")
			for (let [d, c, u] of s._dep)
				if (c && u) {
					;(t = !0), a.push(`${l}CREATES -> ${d}`)
					let m = n(i + 1, u)
					m && a.push(m)
				} else a.push(`${l}uses -> ${d}`)
			return a.join(`
`)
		}
		let r = [
			`${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
			`${n(1, this)}`,
			`DONE, took ${e.toFixed(2)}ms (grand total ${o._totals.toFixed(2)}ms)`,
		]
		;(e > 2 || t) &&
			o.all.add(
				r.join(`
`),
			)
	}
}
var ie = O("IExtHostRpcService"),
	yb = class {
		constructor(e) {
			;(this.getProxy = e.getProxy.bind(e)),
				(this.set = e.set.bind(e)),
				(this.dispose = e.dispose.bind(e)),
				(this.assertRegistered = e.assertRegistered.bind(e)),
				(this.drain = e.drain.bind(e))
		}
	}
var fi = O("IURITransformerService"),
	Ib = class {
		constructor(e) {
			e
				? ((this.transformIncoming = e.transformIncoming.bind(e)),
					(this.transformOutgoing = e.transformOutgoing.bind(e)),
					(this.transformOutgoingURI = e.transformOutgoingURI.bind(e)),
					(this.transformOutgoingScheme = e.transformOutgoingScheme.bind(e)))
				: ((this.transformIncoming = (t) => t),
					(this.transformOutgoing = (t) => t),
					(this.transformOutgoingURI = (t) => t),
					(this.transformOutgoingScheme = (t) => t))
		}
	}
var gP = class {
		constructor() {
			this._value = ""
			this._pos = 0
		}
		reset(e) {
			return (this._value = e), (this._pos = 0), this
		}
		next() {
			return (this._pos += 1), this
		}
		hasNext() {
			return this._pos < this._value.length - 1
		}
		cmp(e) {
			let t = e.charCodeAt(0),
				n = this._value.charCodeAt(this._pos)
			return t - n
		}
		value() {
			return this._value[this._pos]
		}
	},
	hP = class {
		constructor(e = !0) {
			this._caseSensitive = e
		}
		reset(e) {
			return (this._value = e), (this._from = 0), (this._to = 0), this.next()
		}
		hasNext() {
			return this._to < this._value.length
		}
		next() {
			this._from = this._to
			let e = !0
			for (; this._to < this._value.length; this._to++)
				if (this._value.charCodeAt(this._to) === 46)
					if (e) this._from++
					else break
				else e = !1
			return this
		}
		cmp(e) {
			return this._caseSensitive
				? Hv(e, this._value, 0, e.length, this._from, this._to)
				: Sc(e, this._value, 0, e.length, this._from, this._to)
		}
		value() {
			return this._value.substring(this._from, this._to)
		}
	},
	xb = class {
		constructor(e = !0, t = !0) {
			this._splitOnBackslash = e
			this._caseSensitive = t
		}
		reset(e) {
			;(this._from = 0), (this._to = 0), (this._value = e), (this._valueLen = e.length)
			for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
				let n = this._value.charCodeAt(t)
				if (!(n === 47 || (this._splitOnBackslash && n === 92))) break
			}
			return this.next()
		}
		hasNext() {
			return this._to < this._valueLen
		}
		next() {
			this._from = this._to
			let e = !0
			for (; this._to < this._valueLen; this._to++) {
				let t = this._value.charCodeAt(this._to)
				if (t === 47 || (this._splitOnBackslash && t === 92))
					if (e) this._from++
					else break
				else e = !1
			}
			return this
		}
		cmp(e) {
			return this._caseSensitive
				? Hv(e, this._value, 0, e.length, this._from, this._to)
				: Sc(e, this._value, 0, e.length, this._from, this._to)
		}
		value() {
			return this._value.substring(this._from, this._to)
		}
	}
var Bf = class {
		constructor(e, t) {
			this._ignorePathCasing = e
			this._ignoreQueryAndFragment = t
			this._states = []
			this._stateIdx = 0
		}
		reset(e) {
			return (
				(this._value = e),
				(this._states = []),
				this._value.scheme && this._states.push(1),
				this._value.authority && this._states.push(2),
				this._value.path &&
					((this._pathIterator = new xb(!1, !this._ignorePathCasing(e))),
					this._pathIterator.reset(e.path),
					this._pathIterator.value() && this._states.push(3)),
				this._ignoreQueryAndFragment(e) ||
					(this._value.query && this._states.push(4), this._value.fragment && this._states.push(5)),
				(this._stateIdx = 0),
				this
			)
		}
		next() {
			return (
				this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()
					? this._pathIterator.next()
					: (this._stateIdx += 1),
				this
			)
		}
		hasNext() {
			return (
				(this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) ||
				this._stateIdx < this._states.length - 1
			)
		}
		cmp(e) {
			if (this._states[this._stateIdx] === 1) return Wv(e, this._value.scheme)
			if (this._states[this._stateIdx] === 2) return Wv(e, this._value.authority)
			if (this._states[this._stateIdx] === 3) return this._pathIterator.cmp(e)
			if (this._states[this._stateIdx] === 4) return Fo(e, this._value.query)
			if (this._states[this._stateIdx] === 5) return Fo(e, this._value.fragment)
			throw new Error()
		}
		value() {
			if (this._states[this._stateIdx] === 1) return this._value.scheme
			if (this._states[this._stateIdx] === 2) return this._value.authority
			if (this._states[this._stateIdx] === 3) return this._pathIterator.value()
			if (this._states[this._stateIdx] === 4) return this._value.query
			if (this._states[this._stateIdx] === 5) return this._value.fragment
			throw new Error()
		}
	},
	cs = class o {
		static {
			this.Val = Symbol("undefined_placeholder")
		}
		static wrap(e) {
			return e === void 0 ? o.Val : e
		}
		static unwrap(e) {
			return e === o.Val ? void 0 : e
		}
	},
	Vc = class {
		constructor() {
			this.height = 1
			this.value = void 0
			this.key = void 0
			this.left = void 0
			this.mid = void 0
			this.right = void 0
		}
		isEmpty() {
			return !this.left && !this.mid && !this.right && this.value === void 0
		}
		rotateLeft() {
			let e = this.right
			return (this.right = e.left), (e.left = this), this.updateHeight(), e.updateHeight(), e
		}
		rotateRight() {
			let e = this.left
			return (this.left = e.right), (e.right = this), this.updateHeight(), e.updateHeight(), e
		}
		updateHeight() {
			this.height = 1 + Math.max(this.heightLeft, this.heightRight)
		}
		balanceFactor() {
			return this.heightRight - this.heightLeft
		}
		get heightLeft() {
			return this.left?.height ?? 0
		}
		get heightRight() {
			return this.right?.height ?? 0
		}
	}
var vr = class o {
	static forUris(e = () => !1, t = () => !1) {
		return new o(new Bf(e, t))
	}
	static forPaths(e = !1) {
		return new o(new xb(void 0, !e))
	}
	static forStrings() {
		return new o(new gP())
	}
	static forConfigKeys() {
		return new o(new hP())
	}
	constructor(e) {
		this._iter = e
	}
	clear() {
		this._root = void 0
	}
	fill(e, t) {
		if (t) {
			let n = t.slice(0)
			nE(n)
			for (let r of n) this.set(r, e)
		} else {
			let n = e.slice(0)
			nE(n)
			for (let r of n) this.set(r[0], r[1])
		}
	}
	set(e, t) {
		let n = this._iter.reset(e),
			r
		this._root || ((this._root = new Vc()), (this._root.segment = n.value()))
		let i = []
		for (r = this._root; ; ) {
			let a = n.cmp(r.segment)
			if (a > 0) r.left || ((r.left = new Vc()), (r.left.segment = n.value())), i.push([-1, r]), (r = r.left)
			else if (a < 0)
				r.right || ((r.right = new Vc()), (r.right.segment = n.value())), i.push([1, r]), (r = r.right)
			else if (n.hasNext())
				n.next(), r.mid || ((r.mid = new Vc()), (r.mid.segment = n.value())), i.push([0, r]), (r = r.mid)
			else break
		}
		let s = cs.unwrap(r.value)
		;(r.value = cs.wrap(t)), (r.key = e)
		for (let a = i.length - 1; a >= 0; a--) {
			let l = i[a][1]
			l.updateHeight()
			let d = l.balanceFactor()
			if (d < -1 || d > 1) {
				let c = i[a][0],
					u = i[a + 1][0]
				if (c === 1 && u === 1) i[a][1] = l.rotateLeft()
				else if (c === -1 && u === -1) i[a][1] = l.rotateRight()
				else if (c === 1 && u === -1)
					(l.right = i[a + 1][1] = i[a + 1][1].rotateRight()), (i[a][1] = l.rotateLeft())
				else if (c === -1 && u === 1)
					(l.left = i[a + 1][1] = i[a + 1][1].rotateLeft()), (i[a][1] = l.rotateRight())
				else throw new Error()
				if (a > 0)
					switch (i[a - 1][0]) {
						case -1:
							i[a - 1][1].left = i[a][1]
							break
						case 1:
							i[a - 1][1].right = i[a][1]
							break
						case 0:
							i[a - 1][1].mid = i[a][1]
							break
					}
				else this._root = i[0][1]
			}
		}
		return s
	}
	get(e) {
		return cs.unwrap(this._getNode(e)?.value)
	}
	_getNode(e) {
		let t = this._iter.reset(e),
			n = this._root
		for (; n; ) {
			let r = t.cmp(n.segment)
			if (r > 0) n = n.left
			else if (r < 0) n = n.right
			else if (t.hasNext()) t.next(), (n = n.mid)
			else break
		}
		return n
	}
	has(e) {
		let t = this._getNode(e)
		return !(t?.value === void 0 && t?.mid === void 0)
	}
	delete(e) {
		return this._delete(e, !1)
	}
	deleteSuperstr(e) {
		return this._delete(e, !0)
	}
	_delete(e, t) {
		let n = this._iter.reset(e),
			r = [],
			i = this._root
		for (; i; ) {
			let s = n.cmp(i.segment)
			if (s > 0) r.push([-1, i]), (i = i.left)
			else if (s < 0) r.push([1, i]), (i = i.right)
			else if (n.hasNext()) n.next(), r.push([0, i]), (i = i.mid)
			else break
		}
		if (i) {
			if (
				(t
					? ((i.left = void 0), (i.mid = void 0), (i.right = void 0), (i.height = 1))
					: ((i.key = void 0), (i.value = void 0)),
				!i.mid && !i.value)
			)
				if (i.left && i.right) {
					let s = [[1, i]],
						a = this._min(i.right, s)
					if (a.key) {
						;(i.key = a.key), (i.value = a.value), (i.segment = a.segment)
						let l = a.right
						if (s.length > 1) {
							let [c, u] = s[s.length - 1]
							switch (c) {
								case -1:
									u.left = l
									break
								case 0:
									hc(!1)
								case 1:
									hc(!1)
							}
						} else i.right = l
						let d = this._balanceByStack(s)
						if (r.length > 0) {
							let [c, u] = r[r.length - 1]
							switch (c) {
								case -1:
									u.left = d
									break
								case 0:
									u.mid = d
									break
								case 1:
									u.right = d
									break
							}
						} else this._root = d
					}
				} else {
					let s = i.left ?? i.right
					if (r.length > 0) {
						let [a, l] = r[r.length - 1]
						switch (a) {
							case -1:
								l.left = s
								break
							case 0:
								l.mid = s
								break
							case 1:
								l.right = s
								break
						}
					} else this._root = s
				}
			this._root = this._balanceByStack(r) ?? this._root
		}
	}
	_min(e, t) {
		for (; e.left; ) t.push([-1, e]), (e = e.left)
		return e
	}
	_balanceByStack(e) {
		for (let t = e.length - 1; t >= 0; t--) {
			let n = e[t][1]
			n.updateHeight()
			let r = n.balanceFactor()
			if (
				(r > 1
					? (n.right.balanceFactor() >= 0 || (n.right = n.right.rotateRight()), (e[t][1] = n.rotateLeft()))
					: r < -1 &&
						(n.left.balanceFactor() <= 0 || (n.left = n.left.rotateLeft()), (e[t][1] = n.rotateRight())),
				t > 0)
			)
				switch (e[t - 1][0]) {
					case -1:
						e[t - 1][1].left = e[t][1]
						break
					case 1:
						e[t - 1][1].right = e[t][1]
						break
					case 0:
						e[t - 1][1].mid = e[t][1]
						break
				}
			else return e[0][1]
		}
	}
	findSubstr(e) {
		let t = this._iter.reset(e),
			n = this._root,
			r
		for (; n; ) {
			let i = t.cmp(n.segment)
			if (i > 0) n = n.left
			else if (i < 0) n = n.right
			else if (t.hasNext()) t.next(), (r = cs.unwrap(n.value) || r), (n = n.mid)
			else break
		}
		return (n && cs.unwrap(n.value)) || r
	}
	findSuperstr(e) {
		return this._findSuperstrOrElement(e, !1)
	}
	_findSuperstrOrElement(e, t) {
		let n = this._iter.reset(e),
			r = this._root
		for (; r; ) {
			let i = n.cmp(r.segment)
			if (i > 0) r = r.left
			else if (i < 0) r = r.right
			else if (n.hasNext()) n.next(), (r = r.mid)
			else return r.mid ? this._entries(r.mid) : t ? cs.unwrap(r.value) : void 0
		}
	}
	hasElementOrSubtree(e) {
		return this._findSuperstrOrElement(e, !0) !== void 0
	}
	forEach(e) {
		for (let [t, n] of this) e(n, t)
	}
	*[Symbol.iterator]() {
		yield* this._entries(this._root)
	}
	_entries(e) {
		let t = []
		return this._dfsEntries(e, t), t[Symbol.iterator]()
	}
	_dfsEntries(e, t) {
		e &&
			(e.left && this._dfsEntries(e.left, t),
			e.value !== void 0 && t.push([e.key, cs.unwrap(e.value)]),
			e.mid && this._dfsEntries(e.mid, t),
			e.right && this._dfsEntries(e.right, t))
	}
	_isBalanced() {
		let e = (t) => {
			if (!t) return !0
			let n = t.balanceFactor()
			return n < -1 || n > 1 ? !1 : e(t.left) && e(t.right)
		}
		return e(this._root)
	}
}
function mL(o, e, t) {
	return Math.min(Math.max(o, e), t)
}
var Cb = class {
		constructor() {
			this._next = 0
		}
		getNext() {
			return this._next++
		}
	},
	Sb = class {
		constructor() {
			this._n = 1
			this._val = 0
		}
		update(e) {
			return (this._val = this._val + (e - this._val) / this._n), (this._n += 1), this._val
		}
		get value() {
			return this._val
		}
	}
var Tb = O("fileService")
function Xl(o) {
	return o.create === !0
}
var ya = ((r) => (
		(r[(r.Unknown = 0)] = "Unknown"),
		(r[(r.File = 1)] = "File"),
		(r[(r.Directory = 2)] = "Directory"),
		(r[(r.SymbolicLink = 64)] = "SymbolicLink"),
		r
	))(ya || {}),
	Ia = ((t) => ((t[(t.Readonly = 1)] = "Readonly"), (t[(t.Locked = 2)] = "Locked"), t))(Ia || {})
var ba = class o extends Error {
	constructor(t, n) {
		super(t)
		this.code = n
	}
	static create(t, n) {
		let r = new o(t.toString(), n)
		return vP(r, n), r
	}
}
function Bo(o, e) {
	return ba.create(o, e)
}
function gL(o) {
	return o || Bo(p("unknownError", "Unknown Error"), "Unknown")
}
function vP(o, e) {
	return (o.name = e ? `${e} (FileSystemError)` : "FileSystemError"), o
}
function $c(o) {
	if (!o) return "Unknown"
	if (o instanceof ba) return o.code
	let e = /^(.+) \(FileSystemError\)$/.exec(o.name)
	if (!e) return "Unknown"
	switch (e[1]) {
		case "EntryExists":
			return "EntryExists"
		case "EntryIsADirectory":
			return "EntryIsADirectory"
		case "EntryNotADirectory":
			return "EntryNotADirectory"
		case "EntryNotFound":
			return "EntryNotFound"
		case "EntryTooLarge":
			return "EntryTooLarge"
		case "EntryWriteLocked":
			return "EntryWriteLocked"
		case "NoPermissions":
			return "NoPermissions"
		case "Unavailable":
			return "Unavailable"
	}
	return "Unknown"
}
function hL(o) {
	if (o instanceof Jl) return o.fileOperationResult
	switch ($c(o)) {
		case "EntryNotFound":
			return 1
		case "EntryIsADirectory":
			return 0
		case "EntryNotADirectory":
			return 9
		case "EntryWriteLocked":
			return 5
		case "NoPermissions":
			return 6
		case "EntryExists":
			return 4
		case "EntryTooLarge":
			return 7
		default:
			return 10
	}
}
var fL = class o {
	constructor(e, t) {
		this.ignorePathCasing = t
		this.correlationId = void 0
		this.added = new kt(() => {
			let e = vr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawAdded.map((t) => [t, !0])), e
		})
		this.updated = new kt(() => {
			let e = vr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawUpdated.map((t) => [t, !0])), e
		})
		this.deleted = new kt(() => {
			let e = vr.forUris(() => this.ignorePathCasing)
			return e.fill(this.rawDeleted.map((t) => [t, !0])), e
		})
		this.rawAdded = []
		this.rawUpdated = []
		this.rawDeleted = []
		for (let n of e) {
			switch (n.type) {
				case 1:
					this.rawAdded.push(n.resource)
					break
				case 0:
					this.rawUpdated.push(n.resource)
					break
				case 2:
					this.rawDeleted.push(n.resource)
					break
			}
			this.correlationId !== o.MIXED_CORRELATION &&
				(typeof n.cId == "number"
					? this.correlationId === void 0
						? (this.correlationId = n.cId)
						: this.correlationId !== n.cId && (this.correlationId = o.MIXED_CORRELATION)
					: this.correlationId !== void 0 && (this.correlationId = o.MIXED_CORRELATION))
		}
	}
	static {
		this.MIXED_CORRELATION = null
	}
	contains(e, ...t) {
		return this.doContains(e, { includeChildren: !1 }, ...t)
	}
	affects(e, ...t) {
		return this.doContains(e, { includeChildren: !0 }, ...t)
	}
	doContains(e, t, ...n) {
		if (!e) return !1
		let r = n.length > 0
		return !!(
			((!r || n.includes(1)) &&
				(this.added.value.get(e) || (t.includeChildren && this.added.value.findSuperstr(e)))) ||
			((!r || n.includes(0)) &&
				(this.updated.value.get(e) || (t.includeChildren && this.updated.value.findSuperstr(e)))) ||
			((!r || n.includes(2)) &&
				(this.deleted.value.findSubstr(e) || (t.includeChildren && this.deleted.value.findSuperstr(e))))
		)
	}
	gotAdded() {
		return this.rawAdded.length > 0
	}
	gotDeleted() {
		return this.rawDeleted.length > 0
	}
	gotUpdated() {
		return this.rawUpdated.length > 0
	}
	correlates(e) {
		return this.correlationId === e
	}
	hasCorrelation() {
		return typeof this.correlationId == "number"
	}
}
function vL(o, e, t) {
	return !o || !e || o === e || e.length > o.length
		? !1
		: (e.charAt(e.length - 1) !== at && (e += at), t ? Zi(o, e) : o.indexOf(e) === 0)
}
var Jl = class extends Error {
	constructor(t, n, r) {
		super(t)
		this.fileOperationResult = n
		this.options = r
	}
}
var bL = ""
function bP(o) {
	if (!(typeof o.size != "number" || typeof o.mtime != "number")) return o.mtime.toString(29) + o.size.toString(31)
}
var Bc = class o {
	static {
		this.KB = 1024
	}
	static {
		this.MB = o.KB * o.KB
	}
	static {
		this.GB = o.MB * o.KB
	}
	static {
		this.TB = o.GB * o.KB
	}
	static formatSize(e) {
		return (
			fn(e) || (e = 0),
			e < o.KB
				? p("sizeB", "{0}B", e.toFixed(0))
				: e < o.MB
					? p("sizeKB", "{0}KB", (e / o.KB).toFixed(2))
					: e < o.GB
						? p("sizeMB", "{0}MB", (e / o.MB).toFixed(2))
						: e < o.TB
							? p("sizeGB", "{0}GB", (e / o.GB).toFixed(2))
							: p("sizeTB", "{0}TB", (e / o.TB).toFixed(2))
		)
	}
}
var wb = ((r) => (
	(r[(r.Ignore = 0)] = "Ignore"),
	(r[(r.Info = 1)] = "Info"),
	(r[(r.Warning = 2)] = "Warning"),
	(r[(r.Error = 3)] = "Error"),
	r
))(wb || {})
;((a) => {
	let o = "error",
		e = "warning",
		t = "warn",
		n = "info",
		r = "ignore"
	function i(l) {
		return l ? (xn(o, l) ? 3 : xn(e, l) || xn(t, l) ? 2 : xn(n, l) ? 1 : 0) : 0
	}
	a.fromValue = i
	function s(l) {
		switch (l) {
			case 3:
				return o
			case 2:
				return e
			case 1:
				return n
			default:
				return r
		}
	}
	a.toString = s
})((wb ||= {}))
var It = wb
var yL = It,
	DG = O("notificationService")
var gi = O("contextService")
function IL(o) {
	let e = o
	return typeof e?.id == "string" && b.isUri(e.uri)
}
function xL(o) {
	let e = o
	return typeof e?.id == "string" && b.isUri(e.configPath)
}
var Pb = class {
		constructor(e, t, n, r, i) {
			this._id = e
			this._transient = n
			this._configuration = r
			this.ignorePathCasing = i
			;(this.foldersMap = vr.forUris(this.ignorePathCasing, () => !0)), (this.folders = t)
		}
		get folders() {
			return this._folders
		}
		set folders(e) {
			;(this._folders = e), this.updateFoldersMap()
		}
		update(e) {
			;(this._id = e.id),
				(this._configuration = e.configuration),
				(this._transient = e.transient),
				(this.ignorePathCasing = e.ignorePathCasing),
				(this.folders = e.folders)
		}
		get id() {
			return this._id
		}
		get transient() {
			return this._transient
		}
		get configuration() {
			return this._configuration
		}
		set configuration(e) {
			this._configuration = e
		}
		getFolder(e) {
			return (e && this.foldersMap.findSubstr(e)) || null
		}
		updateFoldersMap() {
			this.foldersMap = vr.forUris(this.ignorePathCasing, () => !0)
			for (let e of this.folders) this.foldersMap.set(e.uri, e)
		}
		toJSON() {
			return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration }
		}
	},
	Yl = class {
		constructor(e, t) {
			this.raw = t
			;(this.uri = e.uri), (this.index = e.index), (this.name = e.name)
		}
		toResource(e) {
			return ct(this.uri, e)
		}
		toJSON() {
			return { uri: this.uri, name: this.name, index: this.index }
		}
	}
function $f(o) {
	return new Yl({ uri: o, index: 0, name: If(o) }, { uri: o.toString() })
}
var CL = "code-workspace",
	rW = `.${CL}`,
	HG = [{ name: p("codeWorkspace", "Code Workspace"), extensions: [CL] }]
function SL(o) {
	return (typeof o == "string" ? la(o) : Gv(o)) === rW
}
var _b = class {
		constructor() {
			this._systemSchemes = new Set(Object.keys(W))
			this._providerInfo = new Map()
			this.extUri = new es((e) => {
				let t = this._providerInfo.get(e.scheme)
				return !(t === void 0 || t & 1024)
			})
		}
		$acceptProviderInfos(e, t) {
			t === null ? this._providerInfo.delete(e.scheme) : this._providerInfo.set(e.scheme, t)
		}
		isFreeScheme(e) {
			return !this._providerInfo.has(e) && !this._systemSchemes.has(e)
		}
		getCapabilities(e) {
			return this._providerInfo.get(e)
		}
	},
	po = O("IExtHostFileSystemInfo")
var kb = Object.freeze({
	create: (o) =>
		ai(o.map((e) => e.toString())).join(`\r
`),
	split: (o) =>
		o.split(`\r
`),
	parse: (o) => kb.split(o).filter((e) => !e.startsWith("#")),
})
var XG = new Uint32Array(10)
var YG = new Uint8Array([114, 82, 115, 101, 69, 102, 97, 113, 81, 116, 84, 100, 119, 87, 99, 122, 120, 118, 103]),
	ZG = new Uint16Array([
		107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520, 27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757,
		108,
	]),
	eQ = new Uint16Array([
		114, 82, 29810, 115, 30579, 26483, 101, 102, 29286, 24934, 29030, 29798, 30822, 30310, 26470, 97, 113, 29809,
		116, 84, 100, 119, 99, 122, 120, 118, 103,
	]),
	tQ = new Uint16Array([
		114, 82, 29810, 115, 30579, 26483, 101, 69, 102, 29286, 24934, 29030, 29798, 30822, 30310, 26470, 97, 113, 81,
		29809, 116, 84, 100, 119, 87, 99, 122, 120, 118, 103, 107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520,
		27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757, 108,
	])
function EL(...o) {
	return function (e, t) {
		for (let n = 0, r = o.length; n < r; n++) {
			let i = o[n](e, t)
			if (i) return i
		}
		return null
	}
}
var dQ = wL.bind(void 0, !1),
	Ab = wL.bind(void 0, !0)
function wL(o, e, t) {
	if (!t || t.length < e.length) return null
	let n
	return o ? (n = Zi(t, e)) : (n = t.indexOf(e) === 0), n ? (e.length > 0 ? [{ start: 0, end: e.length }] : []) : null
}
function oW(o, e) {
	let t = e.toLowerCase().indexOf(o.toLowerCase())
	return t === -1 ? null : [{ start: t, end: t + o.length }]
}
function iW(o, e) {
	return yP(o.toLowerCase(), e.toLowerCase(), 0, 0)
}
function yP(o, e, t, n) {
	if (t === o.length) return []
	if (n === e.length) return null
	if (o[t] === e[n]) {
		let r = null
		return (r = yP(o, e, t + 1, n + 1)) ? _L({ start: n, end: n + 1 }, r) : null
	}
	return yP(o, e, t, n + 1)
}
function xP(o) {
	return 97 <= o && o <= 122
}
function zc(o) {
	return 65 <= o && o <= 90
}
function CP(o) {
	return 48 <= o && o <= 57
}
function sW(o) {
	return o === 32 || o === 9 || o === 10 || o === 13
}
var aW = new Set()
"()[]{}<>`'\"-/;:,.?!".split("").forEach((o) => aW.add(o.charCodeAt(0)))
function PL(o) {
	return xP(o) || zc(o) || CP(o)
}
function _L(o, e) {
	return e.length === 0 ? (e = [o]) : o.end === e[0].start ? (e[0].start = o.start) : e.unshift(o), e
}
function DL(o, e) {
	for (let t = e; t < o.length; t++) {
		let n = o.charCodeAt(t)
		if (zc(n) || CP(n) || (t > 0 && !PL(o.charCodeAt(t - 1)))) return t
	}
	return o.length
}
function IP(o, e, t, n) {
	if (t === o.length) return []
	if (n === e.length) return null
	if (o[t] !== e[n].toLowerCase()) return null
	{
		let r = null,
			i = n + 1
		for (r = IP(o, e, t + 1, n + 1); !r && (i = DL(e, i)) < e.length; ) (r = IP(o, e, t + 1, i)), i++
		return r === null ? null : _L({ start: n, end: n + 1 }, r)
	}
}
function lW(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0,
		i = 0
	for (let c = 0; c < o.length; c++) (i = o.charCodeAt(c)), zc(i) && e++, xP(i) && t++, PL(i) && n++, CP(i) && r++
	let s = e / o.length,
		a = t / o.length,
		l = n / o.length,
		d = r / o.length
	return { upperPercent: s, lowerPercent: a, alphaPercent: l, numericPercent: d }
}
function dW(o) {
	let { upperPercent: e, lowerPercent: t } = o
	return t === 0 && e > 0.6
}
function cW(o) {
	let { upperPercent: e, lowerPercent: t, alphaPercent: n, numericPercent: r } = o
	return t > 0.2 && e < 0.8 && n > 0.6 && r < 0.2
}
function uW(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0
	for (let i = 0; i < o.length; i++) (n = o.charCodeAt(i)), zc(n) && e++, xP(n) && t++, sW(n) && r++
	return (e === 0 || t === 0) && r === 0 ? o.length <= 30 : e <= 5
}
function kL(o, e) {
	if (!e || ((e = e.trim()), e.length === 0) || !uW(o)) return null
	e.length > 60 && (e = e.substring(0, 60))
	let t = lW(e)
	if (!cW(t)) {
		if (!dW(t)) return null
		e = e.toLowerCase()
	}
	let n = null,
		r = 0
	for (o = o.toLowerCase(); r < e.length && (n = IP(o, e, 0, r)) === null; ) r = DL(e, r + 1)
	return n
}
var cQ = EL(Ab, kL, oW),
	uQ = EL(Ab, kL, iW),
	pQ = new ko(1e4)
var Rb = 128
function SP() {
	let o = [],
		e = []
	for (let t = 0; t <= Rb; t++) e[t] = 0
	for (let t = 0; t <= Rb; t++) o.push(e.slice(0))
	return o
}
function RL(o) {
	let e = []
	for (let t = 0; t <= o; t++) e[t] = 0
	return e
}
var mQ = RL(2 * Rb),
	fQ = RL(2 * Rb),
	gQ = SP(),
	hQ = SP(),
	vQ = SP()
var pW
;((t) => {
	t.Default = [-100, 0]
	function e(n) {
		return !n || (n.length === 2 && n[0] === -100 && n[1] === 0)
	}
	t.isDefault = e
})((pW ||= {}))
var TL = class {
	constructor(e, t) {
		this.firstMatchCanBeWeak = e
		this.boostFullMatch = t
	}
	static {
		this.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 }
	}
}
var TP = Object.create(null)
function v(o, e) {
	if (we(e)) {
		let t = TP[e]
		if (t === void 0) throw new Error(`${o} references an unknown codicon: ${e}`)
		e = t
	}
	return (TP[o] = e), { id: o }
}
function AL() {
	return TP
}
var OL = {
	add: v("add", 6e4),
	plus: v("plus", 6e4),
	gistNew: v("gist-new", 6e4),
	repoCreate: v("repo-create", 6e4),
	lightbulb: v("lightbulb", 60001),
	lightBulb: v("light-bulb", 60001),
	repo: v("repo", 60002),
	repoDelete: v("repo-delete", 60002),
	gistFork: v("gist-fork", 60003),
	repoForked: v("repo-forked", 60003),
	gitPullRequest: v("git-pull-request", 60004),
	gitPullRequestAbandoned: v("git-pull-request-abandoned", 60004),
	recordKeys: v("record-keys", 60005),
	keyboard: v("keyboard", 60005),
	tag: v("tag", 60006),
	gitPullRequestLabel: v("git-pull-request-label", 60006),
	tagAdd: v("tag-add", 60006),
	tagRemove: v("tag-remove", 60006),
	person: v("person", 60007),
	personFollow: v("person-follow", 60007),
	personOutline: v("person-outline", 60007),
	personFilled: v("person-filled", 60007),
	gitBranch: v("git-branch", 60008),
	gitBranchCreate: v("git-branch-create", 60008),
	gitBranchDelete: v("git-branch-delete", 60008),
	sourceControl: v("source-control", 60008),
	mirror: v("mirror", 60009),
	mirrorPublic: v("mirror-public", 60009),
	star: v("star", 60010),
	starAdd: v("star-add", 60010),
	starDelete: v("star-delete", 60010),
	starEmpty: v("star-empty", 60010),
	comment: v("comment", 60011),
	commentAdd: v("comment-add", 60011),
	alert: v("alert", 60012),
	warning: v("warning", 60012),
	search: v("search", 60013),
	searchSave: v("search-save", 60013),
	logOut: v("log-out", 60014),
	signOut: v("sign-out", 60014),
	logIn: v("log-in", 60015),
	signIn: v("sign-in", 60015),
	eye: v("eye", 60016),
	eyeUnwatch: v("eye-unwatch", 60016),
	eyeWatch: v("eye-watch", 60016),
	circleFilled: v("circle-filled", 60017),
	primitiveDot: v("primitive-dot", 60017),
	closeDirty: v("close-dirty", 60017),
	debugBreakpoint: v("debug-breakpoint", 60017),
	debugBreakpointDisabled: v("debug-breakpoint-disabled", 60017),
	debugHint: v("debug-hint", 60017),
	terminalDecorationSuccess: v("terminal-decoration-success", 60017),
	primitiveSquare: v("primitive-square", 60018),
	edit: v("edit", 60019),
	pencil: v("pencil", 60019),
	info: v("info", 60020),
	issueOpened: v("issue-opened", 60020),
	gistPrivate: v("gist-private", 60021),
	gitForkPrivate: v("git-fork-private", 60021),
	lock: v("lock", 60021),
	mirrorPrivate: v("mirror-private", 60021),
	close: v("close", 60022),
	removeClose: v("remove-close", 60022),
	x: v("x", 60022),
	repoSync: v("repo-sync", 60023),
	sync: v("sync", 60023),
	clone: v("clone", 60024),
	desktopDownload: v("desktop-download", 60024),
	beaker: v("beaker", 60025),
	microscope: v("microscope", 60025),
	vm: v("vm", 60026),
	deviceDesktop: v("device-desktop", 60026),
	file: v("file", 60027),
	fileText: v("file-text", 60027),
	more: v("more", 60028),
	ellipsis: v("ellipsis", 60028),
	kebabHorizontal: v("kebab-horizontal", 60028),
	mailReply: v("mail-reply", 60029),
	reply: v("reply", 60029),
	organization: v("organization", 60030),
	organizationFilled: v("organization-filled", 60030),
	organizationOutline: v("organization-outline", 60030),
	newFile: v("new-file", 60031),
	fileAdd: v("file-add", 60031),
	newFolder: v("new-folder", 60032),
	fileDirectoryCreate: v("file-directory-create", 60032),
	trash: v("trash", 60033),
	trashcan: v("trashcan", 60033),
	history: v("history", 60034),
	clock: v("clock", 60034),
	folder: v("folder", 60035),
	fileDirectory: v("file-directory", 60035),
	symbolFolder: v("symbol-folder", 60035),
	logoGithub: v("logo-github", 60036),
	markGithub: v("mark-github", 60036),
	github: v("github", 60036),
	terminal: v("terminal", 60037),
	console: v("console", 60037),
	repl: v("repl", 60037),
	zap: v("zap", 60038),
	symbolEvent: v("symbol-event", 60038),
	error: v("error", 60039),
	stop: v("stop", 60039),
	variable: v("variable", 60040),
	symbolVariable: v("symbol-variable", 60040),
	array: v("array", 60042),
	symbolArray: v("symbol-array", 60042),
	symbolModule: v("symbol-module", 60043),
	symbolPackage: v("symbol-package", 60043),
	symbolNamespace: v("symbol-namespace", 60043),
	symbolObject: v("symbol-object", 60043),
	symbolMethod: v("symbol-method", 60044),
	symbolFunction: v("symbol-function", 60044),
	symbolConstructor: v("symbol-constructor", 60044),
	symbolBoolean: v("symbol-boolean", 60047),
	symbolNull: v("symbol-null", 60047),
	symbolNumeric: v("symbol-numeric", 60048),
	symbolNumber: v("symbol-number", 60048),
	symbolStructure: v("symbol-structure", 60049),
	symbolStruct: v("symbol-struct", 60049),
	symbolParameter: v("symbol-parameter", 60050),
	symbolTypeParameter: v("symbol-type-parameter", 60050),
	symbolKey: v("symbol-key", 60051),
	symbolText: v("symbol-text", 60051),
	symbolReference: v("symbol-reference", 60052),
	goToFile: v("go-to-file", 60052),
	symbolEnum: v("symbol-enum", 60053),
	symbolValue: v("symbol-value", 60053),
	symbolRuler: v("symbol-ruler", 60054),
	symbolUnit: v("symbol-unit", 60054),
	activateBreakpoints: v("activate-breakpoints", 60055),
	archive: v("archive", 60056),
	arrowBoth: v("arrow-both", 60057),
	arrowDown: v("arrow-down", 60058),
	arrowLeft: v("arrow-left", 60059),
	arrowRight: v("arrow-right", 60060),
	arrowSmallDown: v("arrow-small-down", 60061),
	arrowSmallLeft: v("arrow-small-left", 60062),
	arrowSmallRight: v("arrow-small-right", 60063),
	arrowSmallUp: v("arrow-small-up", 60064),
	arrowUp: v("arrow-up", 60065),
	bell: v("bell", 60066),
	bold: v("bold", 60067),
	book: v("book", 60068),
	bookmark: v("bookmark", 60069),
	debugBreakpointConditionalUnverified: v("debug-breakpoint-conditional-unverified", 60070),
	debugBreakpointConditional: v("debug-breakpoint-conditional", 60071),
	debugBreakpointConditionalDisabled: v("debug-breakpoint-conditional-disabled", 60071),
	debugBreakpointDataUnverified: v("debug-breakpoint-data-unverified", 60072),
	debugBreakpointData: v("debug-breakpoint-data", 60073),
	debugBreakpointDataDisabled: v("debug-breakpoint-data-disabled", 60073),
	debugBreakpointLogUnverified: v("debug-breakpoint-log-unverified", 60074),
	debugBreakpointLog: v("debug-breakpoint-log", 60075),
	debugBreakpointLogDisabled: v("debug-breakpoint-log-disabled", 60075),
	briefcase: v("briefcase", 60076),
	broadcast: v("broadcast", 60077),
	browser: v("browser", 60078),
	bug: v("bug", 60079),
	calendar: v("calendar", 60080),
	caseSensitive: v("case-sensitive", 60081),
	check: v("check", 60082),
	checklist: v("checklist", 60083),
	chevronDown: v("chevron-down", 60084),
	chevronLeft: v("chevron-left", 60085),
	chevronRight: v("chevron-right", 60086),
	chevronUp: v("chevron-up", 60087),
	chromeClose: v("chrome-close", 60088),
	chromeMaximize: v("chrome-maximize", 60089),
	chromeMinimize: v("chrome-minimize", 60090),
	chromeRestore: v("chrome-restore", 60091),
	circleOutline: v("circle-outline", 60092),
	circle: v("circle", 60092),
	debugBreakpointUnverified: v("debug-breakpoint-unverified", 60092),
	terminalDecorationIncomplete: v("terminal-decoration-incomplete", 60092),
	circleSlash: v("circle-slash", 60093),
	circuitBoard: v("circuit-board", 60094),
	clearAll: v("clear-all", 60095),
	clippy: v("clippy", 60096),
	closeAll: v("close-all", 60097),
	cloudDownload: v("cloud-download", 60098),
	cloudUpload: v("cloud-upload", 60099),
	code: v("code", 60100),
	collapseAll: v("collapse-all", 60101),
	colorMode: v("color-mode", 60102),
	commentDiscussion: v("comment-discussion", 60103),
	creditCard: v("credit-card", 60105),
	dash: v("dash", 60108),
	dashboard: v("dashboard", 60109),
	database: v("database", 60110),
	debugContinue: v("debug-continue", 60111),
	debugDisconnect: v("debug-disconnect", 60112),
	debugPause: v("debug-pause", 60113),
	debugRestart: v("debug-restart", 60114),
	debugStart: v("debug-start", 60115),
	debugStepInto: v("debug-step-into", 60116),
	debugStepOut: v("debug-step-out", 60117),
	debugStepOver: v("debug-step-over", 60118),
	debugStop: v("debug-stop", 60119),
	debug: v("debug", 60120),
	deviceCameraVideo: v("device-camera-video", 60121),
	deviceCamera: v("device-camera", 60122),
	deviceMobile: v("device-mobile", 60123),
	diffAdded: v("diff-added", 60124),
	diffIgnored: v("diff-ignored", 60125),
	diffModified: v("diff-modified", 60126),
	diffRemoved: v("diff-removed", 60127),
	diffRenamed: v("diff-renamed", 60128),
	diff: v("diff", 60129),
	diffSidebyside: v("diff-sidebyside", 60129),
	discard: v("discard", 60130),
	editorLayout: v("editor-layout", 60131),
	emptyWindow: v("empty-window", 60132),
	exclude: v("exclude", 60133),
	extensions: v("extensions", 60134),
	eyeClosed: v("eye-closed", 60135),
	fileBinary: v("file-binary", 60136),
	fileCode: v("file-code", 60137),
	fileMedia: v("file-media", 60138),
	filePdf: v("file-pdf", 60139),
	fileSubmodule: v("file-submodule", 60140),
	fileSymlinkDirectory: v("file-symlink-directory", 60141),
	fileSymlinkFile: v("file-symlink-file", 60142),
	fileZip: v("file-zip", 60143),
	files: v("files", 60144),
	filter: v("filter", 60145),
	flame: v("flame", 60146),
	foldDown: v("fold-down", 60147),
	foldUp: v("fold-up", 60148),
	fold: v("fold", 60149),
	folderActive: v("folder-active", 60150),
	folderOpened: v("folder-opened", 60151),
	gear: v("gear", 60152),
	gift: v("gift", 60153),
	gistSecret: v("gist-secret", 60154),
	gist: v("gist", 60155),
	gitCommit: v("git-commit", 60156),
	gitCompare: v("git-compare", 60157),
	compareChanges: v("compare-changes", 60157),
	gitMerge: v("git-merge", 60158),
	githubAction: v("github-action", 60159),
	githubAlt: v("github-alt", 60160),
	globe: v("globe", 60161),
	grabber: v("grabber", 60162),
	graph: v("graph", 60163),
	gripper: v("gripper", 60164),
	heart: v("heart", 60165),
	home: v("home", 60166),
	horizontalRule: v("horizontal-rule", 60167),
	hubot: v("hubot", 60168),
	inbox: v("inbox", 60169),
	issueReopened: v("issue-reopened", 60171),
	issues: v("issues", 60172),
	italic: v("italic", 60173),
	jersey: v("jersey", 60174),
	json: v("json", 60175),
	kebabVertical: v("kebab-vertical", 60176),
	key: v("key", 60177),
	law: v("law", 60178),
	lightbulbAutofix: v("lightbulb-autofix", 60179),
	linkExternal: v("link-external", 60180),
	link: v("link", 60181),
	listOrdered: v("list-ordered", 60182),
	listUnordered: v("list-unordered", 60183),
	liveShare: v("live-share", 60184),
	loading: v("loading", 60185),
	location: v("location", 60186),
	mailRead: v("mail-read", 60187),
	mail: v("mail", 60188),
	markdown: v("markdown", 60189),
	megaphone: v("megaphone", 60190),
	mention: v("mention", 60191),
	milestone: v("milestone", 60192),
	gitPullRequestMilestone: v("git-pull-request-milestone", 60192),
	mortarBoard: v("mortar-board", 60193),
	move: v("move", 60194),
	multipleWindows: v("multiple-windows", 60195),
	mute: v("mute", 60196),
	noNewline: v("no-newline", 60197),
	note: v("note", 60198),
	octoface: v("octoface", 60199),
	openPreview: v("open-preview", 60200),
	package: v("package", 60201),
	paintcan: v("paintcan", 60202),
	pin: v("pin", 60203),
	play: v("play", 60204),
	run: v("run", 60204),
	plug: v("plug", 60205),
	preserveCase: v("preserve-case", 60206),
	preview: v("preview", 60207),
	project: v("project", 60208),
	pulse: v("pulse", 60209),
	question: v("question", 60210),
	quote: v("quote", 60211),
	radioTower: v("radio-tower", 60212),
	reactions: v("reactions", 60213),
	references: v("references", 60214),
	refresh: v("refresh", 60215),
	regex: v("regex", 60216),
	remoteExplorer: v("remote-explorer", 60217),
	remote: v("remote", 60218),
	remove: v("remove", 60219),
	replaceAll: v("replace-all", 60220),
	replace: v("replace", 60221),
	repoClone: v("repo-clone", 60222),
	repoForcePush: v("repo-force-push", 60223),
	repoPull: v("repo-pull", 60224),
	repoPush: v("repo-push", 60225),
	report: v("report", 60226),
	requestChanges: v("request-changes", 60227),
	rocket: v("rocket", 60228),
	rootFolderOpened: v("root-folder-opened", 60229),
	rootFolder: v("root-folder", 60230),
	rss: v("rss", 60231),
	ruby: v("ruby", 60232),
	saveAll: v("save-all", 60233),
	saveAs: v("save-as", 60234),
	save: v("save", 60235),
	screenFull: v("screen-full", 60236),
	screenNormal: v("screen-normal", 60237),
	searchStop: v("search-stop", 60238),
	server: v("server", 60240),
	settingsGear: v("settings-gear", 60241),
	settings: v("settings", 60242),
	shield: v("shield", 60243),
	smiley: v("smiley", 60244),
	sortPrecedence: v("sort-precedence", 60245),
	splitHorizontal: v("split-horizontal", 60246),
	splitVertical: v("split-vertical", 60247),
	squirrel: v("squirrel", 60248),
	starFull: v("star-full", 60249),
	starHalf: v("star-half", 60250),
	symbolClass: v("symbol-class", 60251),
	symbolColor: v("symbol-color", 60252),
	symbolConstant: v("symbol-constant", 60253),
	symbolEnumMember: v("symbol-enum-member", 60254),
	symbolField: v("symbol-field", 60255),
	symbolFile: v("symbol-file", 60256),
	symbolInterface: v("symbol-interface", 60257),
	symbolKeyword: v("symbol-keyword", 60258),
	symbolMisc: v("symbol-misc", 60259),
	symbolOperator: v("symbol-operator", 60260),
	symbolProperty: v("symbol-property", 60261),
	wrench: v("wrench", 60261),
	wrenchSubaction: v("wrench-subaction", 60261),
	symbolSnippet: v("symbol-snippet", 60262),
	tasklist: v("tasklist", 60263),
	telescope: v("telescope", 60264),
	textSize: v("text-size", 60265),
	threeBars: v("three-bars", 60266),
	thumbsdown: v("thumbsdown", 60267),
	thumbsup: v("thumbsup", 60268),
	tools: v("tools", 60269),
	triangleDown: v("triangle-down", 60270),
	triangleLeft: v("triangle-left", 60271),
	triangleRight: v("triangle-right", 60272),
	triangleUp: v("triangle-up", 60273),
	twitter: v("twitter", 60274),
	unfold: v("unfold", 60275),
	unlock: v("unlock", 60276),
	unmute: v("unmute", 60277),
	unverified: v("unverified", 60278),
	verified: v("verified", 60279),
	versions: v("versions", 60280),
	vmActive: v("vm-active", 60281),
	vmOutline: v("vm-outline", 60282),
	vmRunning: v("vm-running", 60283),
	watch: v("watch", 60284),
	whitespace: v("whitespace", 60285),
	wholeWord: v("whole-word", 60286),
	window: v("window", 60287),
	wordWrap: v("word-wrap", 60288),
	zoomIn: v("zoom-in", 60289),
	zoomOut: v("zoom-out", 60290),
	listFilter: v("list-filter", 60291),
	listFlat: v("list-flat", 60292),
	listSelection: v("list-selection", 60293),
	selection: v("selection", 60293),
	listTree: v("list-tree", 60294),
	debugBreakpointFunctionUnverified: v("debug-breakpoint-function-unverified", 60295),
	debugBreakpointFunction: v("debug-breakpoint-function", 60296),
	debugBreakpointFunctionDisabled: v("debug-breakpoint-function-disabled", 60296),
	debugStackframeActive: v("debug-stackframe-active", 60297),
	circleSmallFilled: v("circle-small-filled", 60298),
	debugStackframeDot: v("debug-stackframe-dot", 60298),
	terminalDecorationMark: v("terminal-decoration-mark", 60298),
	debugStackframe: v("debug-stackframe", 60299),
	debugStackframeFocused: v("debug-stackframe-focused", 60299),
	debugBreakpointUnsupported: v("debug-breakpoint-unsupported", 60300),
	symbolString: v("symbol-string", 60301),
	debugReverseContinue: v("debug-reverse-continue", 60302),
	debugStepBack: v("debug-step-back", 60303),
	debugRestartFrame: v("debug-restart-frame", 60304),
	debugAlt: v("debug-alt", 60305),
	callIncoming: v("call-incoming", 60306),
	callOutgoing: v("call-outgoing", 60307),
	menu: v("menu", 60308),
	expandAll: v("expand-all", 60309),
	feedback: v("feedback", 60310),
	gitPullRequestReviewer: v("git-pull-request-reviewer", 60310),
	groupByRefType: v("group-by-ref-type", 60311),
	ungroupByRefType: v("ungroup-by-ref-type", 60312),
	account: v("account", 60313),
	gitPullRequestAssignee: v("git-pull-request-assignee", 60313),
	bellDot: v("bell-dot", 60314),
	debugConsole: v("debug-console", 60315),
	library: v("library", 60316),
	output: v("output", 60317),
	runAll: v("run-all", 60318),
	syncIgnored: v("sync-ignored", 60319),
	pinned: v("pinned", 60320),
	githubInverted: v("github-inverted", 60321),
	serverProcess: v("server-process", 60322),
	serverEnvironment: v("server-environment", 60323),
	pass: v("pass", 60324),
	issueClosed: v("issue-closed", 60324),
	stopCircle: v("stop-circle", 60325),
	playCircle: v("play-circle", 60326),
	record: v("record", 60327),
	debugAltSmall: v("debug-alt-small", 60328),
	vmConnect: v("vm-connect", 60329),
	cloud: v("cloud", 60330),
	merge: v("merge", 60331),
	export: v("export", 60332),
	graphLeft: v("graph-left", 60333),
	magnet: v("magnet", 60334),
	notebook: v("notebook", 60335),
	redo: v("redo", 60336),
	checkAll: v("check-all", 60337),
	pinnedDirty: v("pinned-dirty", 60338),
	passFilled: v("pass-filled", 60339),
	circleLargeFilled: v("circle-large-filled", 60340),
	circleLarge: v("circle-large", 60341),
	circleLargeOutline: v("circle-large-outline", 60341),
	combine: v("combine", 60342),
	gather: v("gather", 60342),
	table: v("table", 60343),
	variableGroup: v("variable-group", 60344),
	typeHierarchy: v("type-hierarchy", 60345),
	typeHierarchySub: v("type-hierarchy-sub", 60346),
	typeHierarchySuper: v("type-hierarchy-super", 60347),
	gitPullRequestCreate: v("git-pull-request-create", 60348),
	runAbove: v("run-above", 60349),
	runBelow: v("run-below", 60350),
	notebookTemplate: v("notebook-template", 60351),
	debugRerun: v("debug-rerun", 60352),
	workspaceTrusted: v("workspace-trusted", 60353),
	workspaceUntrusted: v("workspace-untrusted", 60354),
	workspaceUnknown: v("workspace-unknown", 60355),
	terminalCmd: v("terminal-cmd", 60356),
	terminalDebian: v("terminal-debian", 60357),
	terminalLinux: v("terminal-linux", 60358),
	terminalPowershell: v("terminal-powershell", 60359),
	terminalTmux: v("terminal-tmux", 60360),
	terminalUbuntu: v("terminal-ubuntu", 60361),
	terminalBash: v("terminal-bash", 60362),
	arrowSwap: v("arrow-swap", 60363),
	copy: v("copy", 60364),
	personAdd: v("person-add", 60365),
	filterFilled: v("filter-filled", 60366),
	wand: v("wand", 60367),
	debugLineByLine: v("debug-line-by-line", 60368),
	inspect: v("inspect", 60369),
	layers: v("layers", 60370),
	layersDot: v("layers-dot", 60371),
	layersActive: v("layers-active", 60372),
	compass: v("compass", 60373),
	compassDot: v("compass-dot", 60374),
	compassActive: v("compass-active", 60375),
	azure: v("azure", 60376),
	issueDraft: v("issue-draft", 60377),
	gitPullRequestClosed: v("git-pull-request-closed", 60378),
	gitPullRequestDraft: v("git-pull-request-draft", 60379),
	debugAll: v("debug-all", 60380),
	debugCoverage: v("debug-coverage", 60381),
	runErrors: v("run-errors", 60382),
	folderLibrary: v("folder-library", 60383),
	debugContinueSmall: v("debug-continue-small", 60384),
	beakerStop: v("beaker-stop", 60385),
	graphLine: v("graph-line", 60386),
	graphScatter: v("graph-scatter", 60387),
	pieChart: v("pie-chart", 60388),
	bracket: v("bracket", 60175),
	bracketDot: v("bracket-dot", 60389),
	bracketError: v("bracket-error", 60390),
	lockSmall: v("lock-small", 60391),
	azureDevops: v("azure-devops", 60392),
	verifiedFilled: v("verified-filled", 60393),
	newline: v("newline", 60394),
	layout: v("layout", 60395),
	layoutActivitybarLeft: v("layout-activitybar-left", 60396),
	layoutActivitybarRight: v("layout-activitybar-right", 60397),
	layoutPanelLeft: v("layout-panel-left", 60398),
	layoutPanelCenter: v("layout-panel-center", 60399),
	layoutPanelJustify: v("layout-panel-justify", 60400),
	layoutPanelRight: v("layout-panel-right", 60401),
	layoutPanel: v("layout-panel", 60402),
	layoutSidebarLeft: v("layout-sidebar-left", 60403),
	layoutSidebarRight: v("layout-sidebar-right", 60404),
	layoutStatusbar: v("layout-statusbar", 60405),
	layoutMenubar: v("layout-menubar", 60406),
	layoutCentered: v("layout-centered", 60407),
	target: v("target", 60408),
	indent: v("indent", 60409),
	recordSmall: v("record-small", 60410),
	errorSmall: v("error-small", 60411),
	terminalDecorationError: v("terminal-decoration-error", 60411),
	arrowCircleDown: v("arrow-circle-down", 60412),
	arrowCircleLeft: v("arrow-circle-left", 60413),
	arrowCircleRight: v("arrow-circle-right", 60414),
	arrowCircleUp: v("arrow-circle-up", 60415),
	layoutSidebarRightOff: v("layout-sidebar-right-off", 60416),
	layoutPanelOff: v("layout-panel-off", 60417),
	layoutSidebarLeftOff: v("layout-sidebar-left-off", 60418),
	blank: v("blank", 60419),
	heartFilled: v("heart-filled", 60420),
	map: v("map", 60421),
	mapHorizontal: v("map-horizontal", 60421),
	foldHorizontal: v("fold-horizontal", 60421),
	mapFilled: v("map-filled", 60422),
	mapHorizontalFilled: v("map-horizontal-filled", 60422),
	foldHorizontalFilled: v("fold-horizontal-filled", 60422),
	circleSmall: v("circle-small", 60423),
	bellSlash: v("bell-slash", 60424),
	bellSlashDot: v("bell-slash-dot", 60425),
	commentUnresolved: v("comment-unresolved", 60426),
	gitPullRequestGoToChanges: v("git-pull-request-go-to-changes", 60427),
	gitPullRequestNewChanges: v("git-pull-request-new-changes", 60428),
	searchFuzzy: v("search-fuzzy", 60429),
	commentDraft: v("comment-draft", 60430),
	send: v("send", 60431),
	sparkle: v("sparkle", 60432),
	insert: v("insert", 60433),
	mic: v("mic", 60434),
	thumbsdownFilled: v("thumbsdown-filled", 60435),
	thumbsupFilled: v("thumbsup-filled", 60436),
	coffee: v("coffee", 60437),
	snake: v("snake", 60438),
	game: v("game", 60439),
	vr: v("vr", 60440),
	chip: v("chip", 60441),
	piano: v("piano", 60442),
	music: v("music", 60443),
	micFilled: v("mic-filled", 60444),
	repoFetch: v("repo-fetch", 60445),
	copilot: v("copilot", 60446),
	lightbulbSparkle: v("lightbulb-sparkle", 60447),
	robot: v("robot", 60448),
	sparkleFilled: v("sparkle-filled", 60449),
	diffSingle: v("diff-single", 60450),
	diffMultiple: v("diff-multiple", 60451),
	surroundWith: v("surround-with", 60452),
	share: v("share", 60453),
	gitStash: v("git-stash", 60454),
	gitStashApply: v("git-stash-apply", 60455),
	gitStashPop: v("git-stash-pop", 60456),
	vscode: v("vscode", 60457),
	vscodeInsiders: v("vscode-insiders", 60458),
	codeOss: v("code-oss", 60459),
	runCoverage: v("run-coverage", 60460),
	runAllCoverage: v("run-all-coverage", 60461),
	coverage: v("coverage", 60462),
	githubProject: v("github-project", 60463),
	mapVertical: v("map-vertical", 60464),
	foldVertical: v("fold-vertical", 60464),
	mapVerticalFilled: v("map-vertical-filled", 60465),
	foldVerticalFilled: v("fold-vertical-filled", 60465),
	goToSearch: v("go-to-search", 60466),
	percentage: v("percentage", 60467),
	sortPercentage: v("sort-percentage", 60467),
	attach: v("attach", 60468),
	goToEditingSession: v("go-to-editing-session", 60469),
	editSession: v("edit-session", 60470),
	codeReview: v("code-review", 60471),
	copilotWarning: v("copilot-warning", 60472),
	python: v("python", 60473),
	copilotLarge: v("copilot-large", 60474),
	copilotWarningLarge: v("copilot-warning-large", 60475),
	keyboardTab: v("keyboard-tab", 60476),
	copilotBlocked: v("copilot-blocked", 60477),
	copilotNotConnected: v("copilot-not-connected", 60478),
	flag: v("flag", 60479),
	lightbulbEmpty: v("lightbulb-empty", 60480),
	symbolMethodArrow: v("symbol-method-arrow", 60481),
	copilotUnavailable: v("copilot-unavailable", 60482),
	repoPinned: v("repo-pinned", 60483),
	keyboardTabAbove: v("keyboard-tab-above", 60484),
	keyboardTabBelow: v("keyboard-tab-below", 60485),
}
var mW = {
		dialogError: v("dialog-error", "error"),
		dialogWarning: v("dialog-warning", "warning"),
		dialogInfo: v("dialog-info", "info"),
		dialogClose: v("dialog-close", "close"),
		treeItemExpanded: v("tree-item-expanded", "chevron-down"),
		treeFilterOnTypeOn: v("tree-filter-on-type-on", "list-filter"),
		treeFilterOnTypeOff: v("tree-filter-on-type-off", "list-selection"),
		treeFilterClear: v("tree-filter-clear", "close"),
		treeItemLoading: v("tree-item-loading", "loading"),
		menuSelection: v("menu-selection", "check"),
		menuSubmenu: v("menu-submenu", "chevron-right"),
		menuBarMore: v("menubar-more", "more"),
		scrollbarButtonLeft: v("scrollbar-button-left", "triangle-left"),
		scrollbarButtonRight: v("scrollbar-button-right", "triangle-right"),
		scrollbarButtonUp: v("scrollbar-button-up", "triangle-up"),
		scrollbarButtonDown: v("scrollbar-button-down", "triangle-down"),
		toolBarMore: v("toolbar-more", "more"),
		quickInputBack: v("quick-input-back", "arrow-left"),
		dropDownButton: v("drop-down-button", 60084),
		symbolCustomColor: v("symbol-customcolor", 60252),
		exportIcon: v("export", 60332),
		workspaceUnspecified: v("workspace-unspecified", 60355),
		newLine: v("newline", 60394),
		thumbsDownFilled: v("thumbsdown-filled", 60435),
		thumbsUpFilled: v("thumbsup-filled", 60436),
		gitFetch: v("git-fetch", 60445),
		lightbulbSparkleAutofix: v("lightbulb-sparkle-autofix", 60447),
		debugBreakpointPending: v("debug-breakpoint-pending", 60377),
	},
	ce = { ...OL, ...mW }
var qc
;((e) => {
	function o(t) {
		return t && typeof t == "object" && typeof t.id == "string"
	}
	e.isThemeColor = o
})((qc ||= {}))
var Yt
;((g) => {
	;(g.iconNameSegment = "[A-Za-z0-9]+"),
		(g.iconNameExpression = "[A-Za-z0-9-]+"),
		(g.iconModifierExpression = "~[A-Za-z]+"),
		(g.iconNameCharacter = "[A-Za-z0-9~-]")
	let r = new RegExp(`^(${g.iconNameExpression})(${g.iconModifierExpression})?$`)
	function i(I) {
		let C = r.exec(I.id)
		if (!C) return i(ce.error)
		let [, T, w] = C,
			L = ["codicon", "codicon-" + T]
		return w && L.push("codicon-modifier-" + w.substring(1)), L
	}
	g.asClassNameArray = i
	function s(I) {
		return i(I).join(" ")
	}
	g.asClassName = s
	function a(I) {
		return "." + i(I).join(".")
	}
	g.asCSSSelector = a
	function l(I) {
		return (
			I && typeof I == "object" && typeof I.id == "string" && (typeof I.color > "u" || qc.isThemeColor(I.color))
		)
	}
	g.isThemeIcon = l
	let d = new RegExp(`^\\$\\((${g.iconNameExpression}(?:${g.iconModifierExpression})?)\\)$`)
	function c(I) {
		let C = d.exec(I)
		if (!C) return
		let [, T] = C
		return { id: T }
	}
	g.fromString = c
	function u(I) {
		return { id: I }
	}
	g.fromId = u
	function m(I, C) {
		let T = I.id,
			w = T.lastIndexOf("~")
		return w !== -1 && (T = T.substring(0, w)), C && (T = `${T}~${C}`), { id: T }
	}
	g.modify = m
	function f(I) {
		let C = I.id.lastIndexOf("~")
		if (C !== -1) return I.id.substring(C + 1)
	}
	g.getModifier = f
	function h(I, C) {
		return I.id === C.id && I.color?.id === C.color?.id
	}
	g.isEqual = h
})((Yt ||= {}))
var EP = new RegExp(`\\$\\(${Yt.iconNameExpression}(?:${Yt.iconModifierExpression})?\\)`, "g"),
	fW = new RegExp(`(\\\\)?${EP.source}`, "g")
function LL(o) {
	return o.replace(fW, (e, t) => (t ? e : `\\${e}`))
}
var OQ = new RegExp(`\\\\${EP.source}`, "g")
var LQ = new RegExp(`(\\s)?(\\\\)?${EP.source}(\\s)?`, "g")
var MQ = new RegExp(`\\$\\(${Yt.iconNameCharacter}+\\)`, "g")
var $o = class o {
	static lift(e) {
		let t = new o(e.value, e)
		return (t.uris = e.uris), (t.baseUri = e.baseUri ? b.revive(e.baseUri) : void 0), t
	}
	constructor(e = "", t = !1) {
		if (((this.value = e), typeof this.value != "string")) throw We("value")
		typeof t == "boolean"
			? ((this.isTrusted = t), (this.supportThemeIcons = !1), (this.supportHtml = !1))
			: ((this.isTrusted = t.isTrusted ?? void 0),
				(this.supportThemeIcons = t.supportThemeIcons ?? !1),
				(this.supportHtml = t.supportHtml ?? !1))
	}
	appendText(e, t = 0) {
		return (
			(this.value += gW(this.supportThemeIcons ? LL(e) : e)
				.replace(/([ \t]+)/g, (n, r) => "&nbsp;".repeat(r.length))
				.replace(/\>/gm, "\\>")
				.replace(
					/\n/g,
					t === 1
						? `\\
`
						: `

`,
				)),
			this
		)
	}
	appendMarkdown(e) {
		return (this.value += e), this
	}
	appendCodeblock(e, t) {
		return (
			(this.value += `
${hW(t, e)}
`),
			this
		)
	}
	appendLink(e, t, n) {
		return (
			(this.value += "["),
			(this.value += this._escape(t, "]")),
			(this.value += "]("),
			(this.value += this._escape(String(e), ")")),
			n && (this.value += ` "${this._escape(this._escape(n, '"'), ")")}"`),
			(this.value += ")"),
			this
		)
	}
	_escape(e, t) {
		let n = new RegExp(kr(t), "g")
		return e.replace(n, (r, i) => (e.charAt(i - 1) !== "\\" ? `\\${r}` : r))
	}
}
function Gr(o) {
	return o instanceof $o
		? !0
		: o && typeof o == "object"
			? typeof o.value == "string" &&
				(typeof o.isTrusted == "boolean" || typeof o.isTrusted == "object" || o.isTrusted === void 0) &&
				(typeof o.supportThemeIcons == "boolean" || o.supportThemeIcons === void 0)
			: !1
}
function gW(o) {
	return o.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&")
}
function hW(o, e) {
	let t = o.match(/^`+/gm)?.reduce((r, i) => (r.length > i.length ? r : i)).length ?? 0,
		n = t >= 3 ? t + 1 : 3
	return [`${"`".repeat(n)}${e}`, o, `${"`".repeat(n)}`].join(`
`)
}
function ML(o) {
	let e = [],
		t = o.split("|").map((r) => r.trim())
	o = t[0]
	let n = t[1]
	if (n) {
		let r = /height=(\d+)/.exec(n),
			i = /width=(\d+)/.exec(n),
			s = r ? r[1] : "",
			a = i ? i[1] : "",
			l = isFinite(parseInt(a)),
			d = isFinite(parseInt(s))
		l && e.push(`width="${a}"`), d && e.push(`height="${s}"`)
	}
	return { href: o, dimensions: e }
}
function _P() {
	return {
		async: !1,
		breaks: !1,
		extensions: null,
		gfm: !0,
		hooks: null,
		pedantic: !1,
		renderer: null,
		silent: !1,
		tokenizer: null,
		walkTokens: null,
	}
}
var ed = _P()
function VL(o) {
	ed = o
}
var BL = /[&<>"']/,
	bW = new RegExp(BL.source, "g"),
	$L = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
	yW = new RegExp($L.source, "g"),
	IW = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
	FL = (o) => IW[o]
function Qr(o, e) {
	if (e) {
		if (BL.test(o)) return o.replace(bW, FL)
	} else if ($L.test(o)) return o.replace(yW, FL)
	return o
}
var xW = /(^|[^\[])\^/g
function At(o, e) {
	let t = typeof o == "string" ? o : o.source
	e = e || ""
	let n = {
		replace: (r, i) => {
			let s = typeof i == "string" ? i : i.source
			return (s = s.replace(xW, "$1")), (t = t.replace(r, s)), n
		},
		getRegex: () => new RegExp(t, e),
	}
	return n
}
function NL(o) {
	try {
		o = encodeURI(o).replace(/%25/g, "%")
	} catch {
		return null
	}
	return o
}
var Kf = { exec: () => null }
function UL(o, e) {
	let t = o.replace(/\|/g, (i, s, a) => {
			let l = !1,
				d = s
			for (; --d >= 0 && a[d] === "\\"; ) l = !l
			return l ? "|" : " |"
		}),
		n = t.split(/ \|/),
		r = 0
	if ((n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e))
		if (n.length > e) n.splice(e)
		else for (; n.length < e; ) n.push("")
	for (; r < n.length; r++) n[r] = n[r].trim().replace(/\\\|/g, "|")
	return n
}
function zf(o, e, t) {
	let n = o.length
	if (n === 0) return ""
	let r = 0
	for (; r < n; ) {
		let i = o.charAt(n - r - 1)
		if (i === e && !t) r++
		else if (i !== e && t) r++
		else break
	}
	return o.slice(0, n - r)
}
function CW(o, e) {
	if (o.indexOf(e[1]) === -1) return -1
	let t = 0
	for (let n = 0; n < o.length; n++)
		if (o[n] === "\\") n++
		else if (o[n] === e[0]) t++
		else if (o[n] === e[1] && (t--, t < 0)) return n
	return -1
}
function HL(o, e, t, n) {
	let r = e.href,
		i = e.title ? Qr(e.title) : null,
		s = o[1].replace(/\\([\[\]])/g, "$1")
	if (o[0].charAt(0) !== "!") {
		n.state.inLink = !0
		let a = { type: "link", raw: t, href: r, title: i, text: s, tokens: n.inlineTokens(s) }
		return (n.state.inLink = !1), a
	}
	return { type: "image", raw: t, href: r, title: i, text: Qr(s) }
}
function SW(o, e) {
	let t = o.match(/^(\s+)(?:```)/)
	if (t === null) return e
	let n = t[1]
	return e
		.split(
			`
`,
		)
		.map((r) => {
			let i = r.match(/^\s+/)
			if (i === null) return r
			let [s] = i
			return s.length >= n.length ? r.slice(n.length) : r
		}).join(`
`)
}
var jc = class {
		options
		rules
		lexer
		constructor(e) {
			this.options = e || ed
		}
		space(e) {
			let t = this.rules.block.newline.exec(e)
			if (t && t[0].length > 0) return { type: "space", raw: t[0] }
		}
		code(e) {
			let t = this.rules.block.code.exec(e)
			if (t) {
				let n = t[0].replace(/^ {1,4}/gm, "")
				return {
					type: "code",
					raw: t[0],
					codeBlockStyle: "indented",
					text: this.options.pedantic
						? n
						: zf(
								n,
								`
`,
							),
				}
			}
		}
		fences(e) {
			let t = this.rules.block.fences.exec(e)
			if (t) {
				let n = t[0],
					r = SW(n, t[3] || "")
				return {
					type: "code",
					raw: n,
					lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
					text: r,
				}
			}
		}
		heading(e) {
			let t = this.rules.block.heading.exec(e)
			if (t) {
				let n = t[2].trim()
				if (/#$/.test(n)) {
					let r = zf(n, "#")
					;(this.options.pedantic || !r || / $/.test(r)) && (n = r.trim())
				}
				return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) }
			}
		}
		hr(e) {
			let t = this.rules.block.hr.exec(e)
			if (t)
				return {
					type: "hr",
					raw: zf(
						t[0],
						`
`,
					),
				}
		}
		blockquote(e) {
			let t = this.rules.block.blockquote.exec(e)
			if (t) {
				let n = zf(
						t[0],
						`
`,
					).split(`
`),
					r = "",
					i = "",
					s = []
				for (; n.length > 0; ) {
					let a = !1,
						l = [],
						d
					for (d = 0; d < n.length; d++)
						if (/^ {0,3}>/.test(n[d])) l.push(n[d]), (a = !0)
						else if (!a) l.push(n[d])
						else break
					n = n.slice(d)
					let c = l.join(`
`),
						u = c
							.replace(
								/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
								`
    $1`,
							)
							.replace(/^ {0,3}>[ \t]?/gm, "")
					;(r = r
						? `${r}
${c}`
						: c),
						(i = i
							? `${i}
${u}`
							: u)
					let m = this.lexer.state.top
					if (
						((this.lexer.state.top = !0),
						this.lexer.blockTokens(u, s, !0),
						(this.lexer.state.top = m),
						n.length === 0)
					)
						break
					let f = s[s.length - 1]
					if (f?.type === "code") break
					if (f?.type === "blockquote") {
						let h = f,
							g =
								h.raw +
								`
` +
								n.join(`
`),
							I = this.blockquote(g)
						;(s[s.length - 1] = I),
							(r = r.substring(0, r.length - h.raw.length) + I.raw),
							(i = i.substring(0, i.length - h.text.length) + I.text)
						break
					} else if (f?.type === "list") {
						let h = f,
							g =
								h.raw +
								`
` +
								n.join(`
`),
							I = this.list(g)
						;(s[s.length - 1] = I),
							(r = r.substring(0, r.length - f.raw.length) + I.raw),
							(i = i.substring(0, i.length - h.raw.length) + I.raw),
							(n = g.substring(s[s.length - 1].raw.length).split(`
`))
						continue
					}
				}
				return { type: "blockquote", raw: r, tokens: s, text: i }
			}
		}
		list(e) {
			let t = this.rules.block.list.exec(e)
			if (t) {
				let n = t[1].trim(),
					r = n.length > 1,
					i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: !1, items: [] }
				;(n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`), this.options.pedantic && (n = r ? n : "[*+-]")
				let s = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`),
					a = !1
				for (; e; ) {
					let l = !1,
						d = "",
						c = ""
					if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break
					;(d = t[0]), (e = e.substring(d.length))
					let u = t[2]
							.split(
								`
`,
								1,
							)[0]
							.replace(/^\t+/, (C) => " ".repeat(3 * C.length)),
						m = e.split(
							`
`,
							1,
						)[0],
						f = !u.trim(),
						h = 0
					if (
						(this.options.pedantic
							? ((h = 2), (c = u.trimStart()))
							: f
								? (h = t[1].length + 1)
								: ((h = t[2].search(/[^ ]/)),
									(h = h > 4 ? 1 : h),
									(c = u.slice(h)),
									(h += t[1].length)),
						f &&
							/^ *$/.test(m) &&
							((d +=
								m +
								`
`),
							(e = e.substring(m.length + 1)),
							(l = !0)),
						!l)
					) {
						let C = new RegExp(
								`^ {0,${Math.min(3, h - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`,
							),
							T = new RegExp(
								`^ {0,${Math.min(3, h - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`,
							),
							w = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:\`\`\`|~~~)`),
							L = new RegExp(`^ {0,${Math.min(3, h - 1)}}#`)
						for (; e; ) {
							let A = e.split(
								`
`,
								1,
							)[0]
							if (
								((m = A),
								this.options.pedantic && (m = m.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
								w.test(m) || L.test(m) || C.test(m) || T.test(e))
							)
								break
							if (m.search(/[^ ]/) >= h || !m.trim())
								c +=
									`
` + m.slice(h)
							else {
								if (f || u.search(/[^ ]/) >= 4 || w.test(u) || L.test(u) || T.test(u)) break
								c +=
									`
` + m
							}
							!f && !m.trim() && (f = !0),
								(d +=
									A +
									`
`),
								(e = e.substring(A.length + 1)),
								(u = m.slice(h))
						}
					}
					i.loose || (a ? (i.loose = !0) : /\n *\n *$/.test(d) && (a = !0))
					let g = null,
						I
					this.options.gfm &&
						((g = /^\[[ xX]\] /.exec(c)),
						g && ((I = g[0] !== "[ ] "), (c = c.replace(/^\[[ xX]\] +/, "")))),
						i.items.push({
							type: "list_item",
							raw: d,
							task: !!g,
							checked: I,
							loose: !1,
							text: c,
							tokens: [],
						}),
						(i.raw += d)
				}
				;(i.items[i.items.length - 1].raw = i.items[i.items.length - 1].raw.trimEnd()),
					(i.items[i.items.length - 1].text = i.items[i.items.length - 1].text.trimEnd()),
					(i.raw = i.raw.trimEnd())
				for (let l = 0; l < i.items.length; l++)
					if (
						((this.lexer.state.top = !1),
						(i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, [])),
						!i.loose)
					) {
						let d = i.items[l].tokens.filter((u) => u.type === "space"),
							c = d.length > 0 && d.some((u) => /\n.*\n/.test(u.raw))
						i.loose = c
					}
				if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = !0
				return i
			}
		}
		html(e) {
			let t = this.rules.block.html.exec(e)
			if (t)
				return {
					type: "html",
					block: !0,
					raw: t[0],
					pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
					text: t[0],
				}
		}
		def(e) {
			let t = this.rules.block.def.exec(e)
			if (t) {
				let n = t[1].toLowerCase().replace(/\s+/g, " "),
					r = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "",
					i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3]
				return { type: "def", tag: n, raw: t[0], href: r, title: i }
			}
		}
		table(e) {
			let t = this.rules.block.table.exec(e)
			if (!t || !/[:|]/.test(t[2])) return
			let n = UL(t[1]),
				r = t[2].replace(/^\||\| *$/g, "").split("|"),
				i =
					t[3] && t[3].trim()
						? t[3].replace(/\n[ \t]*$/, "").split(`
`)
						: [],
				s = { type: "table", raw: t[0], header: [], align: [], rows: [] }
			if (n.length === r.length) {
				for (let a of r)
					/^ *-+: *$/.test(a)
						? s.align.push("right")
						: /^ *:-+: *$/.test(a)
							? s.align.push("center")
							: /^ *:-+ *$/.test(a)
								? s.align.push("left")
								: s.align.push(null)
				for (let a = 0; a < n.length; a++)
					s.header.push({ text: n[a], tokens: this.lexer.inline(n[a]), header: !0, align: s.align[a] })
				for (let a of i)
					s.rows.push(
						UL(a, s.header.length).map((l, d) => ({
							text: l,
							tokens: this.lexer.inline(l),
							header: !1,
							align: s.align[d],
						})),
					)
				return s
			}
		}
		lheading(e) {
			let t = this.rules.block.lheading.exec(e)
			if (t)
				return {
					type: "heading",
					raw: t[0],
					depth: t[2].charAt(0) === "=" ? 1 : 2,
					text: t[1],
					tokens: this.lexer.inline(t[1]),
				}
		}
		paragraph(e) {
			let t = this.rules.block.paragraph.exec(e)
			if (t) {
				let n =
					t[1].charAt(t[1].length - 1) ===
					`
`
						? t[1].slice(0, -1)
						: t[1]
				return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) }
			}
		}
		text(e) {
			let t = this.rules.block.text.exec(e)
			if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) }
		}
		escape(e) {
			let t = this.rules.inline.escape.exec(e)
			if (t) return { type: "escape", raw: t[0], text: Qr(t[1]) }
		}
		tag(e) {
			let t = this.rules.inline.tag.exec(e)
			if (t)
				return (
					!this.lexer.state.inLink && /^<a /i.test(t[0])
						? (this.lexer.state.inLink = !0)
						: this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1),
					!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0])
						? (this.lexer.state.inRawBlock = !0)
						: this.lexer.state.inRawBlock &&
							/^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) &&
							(this.lexer.state.inRawBlock = !1),
					{
						type: "html",
						raw: t[0],
						inLink: this.lexer.state.inLink,
						inRawBlock: this.lexer.state.inRawBlock,
						block: !1,
						text: t[0],
					}
				)
		}
		link(e) {
			let t = this.rules.inline.link.exec(e)
			if (t) {
				let n = t[2].trim()
				if (!this.options.pedantic && /^</.test(n)) {
					if (!/>$/.test(n)) return
					let s = zf(n.slice(0, -1), "\\")
					if ((n.length - s.length) % 2 === 0) return
				} else {
					let s = CW(t[2], "()")
					if (s > -1) {
						let l = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s
						;(t[2] = t[2].substring(0, s)), (t[0] = t[0].substring(0, l).trim()), (t[3] = "")
					}
				}
				let r = t[2],
					i = ""
				if (this.options.pedantic) {
					let s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r)
					s && ((r = s[1]), (i = s[3]))
				} else i = t[3] ? t[3].slice(1, -1) : ""
				return (
					(r = r.trim()),
					/^</.test(r) && (this.options.pedantic && !/>$/.test(n) ? (r = r.slice(1)) : (r = r.slice(1, -1))),
					HL(
						t,
						{
							href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
							title: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
						},
						t[0],
						this.lexer,
					)
				)
			}
		}
		reflink(e, t) {
			let n
			if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
				let r = (n[2] || n[1]).replace(/\s+/g, " "),
					i = t[r.toLowerCase()]
				if (!i) {
					let s = n[0].charAt(0)
					return { type: "text", raw: s, text: s }
				}
				return HL(n, i, n[0], this.lexer)
			}
		}
		emStrong(e, t, n = "") {
			let r = this.rules.inline.emStrongLDelim.exec(e)
			if (!r || (r[3] && n.match(/[\p{L}\p{N}]/u))) return
			if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
				let s = [...r[0]].length - 1,
					a,
					l,
					d = s,
					c = 0,
					u = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd
				for (u.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = u.exec(t)) != null; ) {
					if (((a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6]), !a)) continue
					if (((l = [...a].length), r[3] || r[4])) {
						d += l
						continue
					} else if ((r[5] || r[6]) && s % 3 && !((s + l) % 3)) {
						c += l
						continue
					}
					if (((d -= l), d > 0)) continue
					l = Math.min(l, l + d + c)
					let m = [...r[0]][0].length,
						f = e.slice(0, s + r.index + m + l)
					if (Math.min(s, l) % 2) {
						let g = f.slice(1, -1)
						return { type: "em", raw: f, text: g, tokens: this.lexer.inlineTokens(g) }
					}
					let h = f.slice(2, -2)
					return { type: "strong", raw: f, text: h, tokens: this.lexer.inlineTokens(h) }
				}
			}
		}
		codespan(e) {
			let t = this.rules.inline.code.exec(e)
			if (t) {
				let n = t[2].replace(/\n/g, " "),
					r = /[^ ]/.test(n),
					i = /^ /.test(n) && / $/.test(n)
				return (
					r && i && (n = n.substring(1, n.length - 1)),
					(n = Qr(n, !0)),
					{ type: "codespan", raw: t[0], text: n }
				)
			}
		}
		br(e) {
			let t = this.rules.inline.br.exec(e)
			if (t) return { type: "br", raw: t[0] }
		}
		del(e) {
			let t = this.rules.inline.del.exec(e)
			if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) }
		}
		autolink(e) {
			let t = this.rules.inline.autolink.exec(e)
			if (t) {
				let n, r
				return (
					t[2] === "@" ? ((n = Qr(t[1])), (r = "mailto:" + n)) : ((n = Qr(t[1])), (r = n)),
					{ type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] }
				)
			}
		}
		url(e) {
			let t
			if ((t = this.rules.inline.url.exec(e))) {
				let n, r
				if (t[2] === "@") (n = Qr(t[0])), (r = "mailto:" + n)
				else {
					let i
					do (i = t[0]), (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "")
					while (i !== t[0])
					;(n = Qr(t[0])), t[1] === "www." ? (r = "http://" + t[0]) : (r = t[0])
				}
				return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] }
			}
		}
		inlineText(e) {
			let t = this.rules.inline.text.exec(e)
			if (t) {
				let n
				return this.lexer.state.inRawBlock ? (n = t[0]) : (n = Qr(t[0])), { type: "text", raw: t[0], text: n }
			}
		}
	},
	TW = /^(?: *(?:\n|$))+/,
	EW = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
	wW = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
	Gf = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
	PW = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
	zL = /(?:[*+-]|\d{1,9}[.)])/,
	qL = At(
		/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
	)
		.replace(/bull/g, zL)
		.replace(/blockCode/g, / {4}/)
		.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
		.replace(/blockquote/g, / {0,3}>/)
		.replace(/heading/g, / {0,3}#{1,6}/)
		.replace(/html/g, / {0,3}<[^\n>]+>\n/)
		.getRegex(),
	DP = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
	_W = /^[^\n]+/,
	kP = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
	DW = At(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
		.replace("label", kP)
		.replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
		.getRegex(),
	kW = At(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
		.replace(/bull/g, zL)
		.getRegex(),
	Mb =
		"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
	RP = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
	RW = At(
		"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
		"i",
	)
		.replace("comment", RP)
		.replace("tag", Mb)
		.replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
		.getRegex(),
	KL = At(DP)
		.replace("hr", Gf)
		.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
		.replace("|lheading", "")
		.replace("|table", "")
		.replace("blockquote", " {0,3}>")
		.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
		.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
		.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
		.replace("tag", Mb)
		.getRegex(),
	AW = At(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
		.replace("paragraph", KL)
		.getRegex(),
	AP = {
		blockquote: AW,
		code: EW,
		def: DW,
		fences: wW,
		heading: PW,
		hr: Gf,
		html: RW,
		lheading: qL,
		list: kW,
		newline: TW,
		paragraph: KL,
		table: Kf,
		text: _W,
	},
	WL = At(
		"^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
	)
		.replace("hr", Gf)
		.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
		.replace("blockquote", " {0,3}>")
		.replace("code", " {4}[^\\n]")
		.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
		.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
		.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
		.replace("tag", Mb)
		.getRegex(),
	OW = {
		...AP,
		table: WL,
		paragraph: At(DP)
			.replace("hr", Gf)
			.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
			.replace("|lheading", "")
			.replace("table", WL)
			.replace("blockquote", " {0,3}>")
			.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
			.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
			.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
			.replace("tag", Mb)
			.getRegex(),
	},
	LW = {
		...AP,
		html: At(
			`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
		)
			.replace("comment", RP)
			.replace(
				/tag/g,
				"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
			)
			.getRegex(),
		def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
		heading: /^(#{1,6})(.*)(?:\n+|$)/,
		fences: Kf,
		lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
		paragraph: At(DP)
			.replace("hr", Gf)
			.replace(
				"heading",
				` *#{1,6} *[^
]`,
			)
			.replace("lheading", qL)
			.replace("|table", "")
			.replace("blockquote", " {0,3}>")
			.replace("|fences", "")
			.replace("|list", "")
			.replace("|html", "")
			.replace("|tag", "")
			.getRegex(),
	},
	jL = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
	MW = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
	GL = /^( {2,}|\\)\n(?!\s*$)/,
	FW = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
	Qf = "\\p{P}\\p{S}",
	NW = At(/^((?![*_])[\spunctuation])/, "u")
		.replace(/punctuation/g, Qf)
		.getRegex(),
	UW = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
	HW = At(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u")
		.replace(/punct/g, Qf)
		.getRegex(),
	WW = At(
		"^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])",
		"gu",
	)
		.replace(/punct/g, Qf)
		.getRegex(),
	VW = At(
		"^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
		"gu",
	)
		.replace(/punct/g, Qf)
		.getRegex(),
	BW = At(/\\([punct])/, "gu")
		.replace(/punct/g, Qf)
		.getRegex(),
	$W = At(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
		.replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
		.replace(
			"email",
			/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
		)
		.getRegex(),
	zW = At(RP).replace("(?:-->|$)", "-->").getRegex(),
	qW = At(
		"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
	)
		.replace("comment", zW)
		.replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
		.getRegex(),
	Lb = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
	KW = At(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
		.replace("label", Lb)
		.replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
		.replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
		.getRegex(),
	QL = At(/^!?\[(label)\]\[(ref)\]/)
		.replace("label", Lb)
		.replace("ref", kP)
		.getRegex(),
	JL = At(/^!?\[(ref)\](?:\[\])?/)
		.replace("ref", kP)
		.getRegex(),
	jW = At("reflink|nolink(?!\\()", "g").replace("reflink", QL).replace("nolink", JL).getRegex(),
	OP = {
		_backpedal: Kf,
		anyPunctuation: BW,
		autolink: $W,
		blockSkip: UW,
		br: GL,
		code: MW,
		del: Kf,
		emStrongLDelim: HW,
		emStrongRDelimAst: WW,
		emStrongRDelimUnd: VW,
		escape: jL,
		link: KW,
		nolink: JL,
		punctuation: NW,
		reflink: QL,
		reflinkSearch: jW,
		tag: qW,
		text: FW,
		url: Kf,
	},
	GW = {
		...OP,
		link: At(/^!?\[(label)\]\((.*?)\)/)
			.replace("label", Lb)
			.getRegex(),
		reflink: At(/^!?\[(label)\]\s*\[([^\]]*)\]/)
			.replace("label", Lb)
			.getRegex(),
	},
	wP = {
		...OP,
		escape: At(jL).replace("])", "~|])").getRegex(),
		url: At(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i")
			.replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
			.getRegex(),
		_backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
		del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
		text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
	},
	QW = {
		...wP,
		br: At(GL).replace("{2,}", "*").getRegex(),
		text: At(wP.text)
			.replace("\\b_", "\\b_| {2,}\\n")
			.replace(/\{2,\}/g, "*")
			.getRegex(),
	},
	Ob = { normal: AP, gfm: OW, pedantic: LW },
	qf = { normal: OP, gfm: wP, breaks: QW, pedantic: GW },
	us = class o {
		tokens
		options
		state
		tokenizer
		inlineQueue
		constructor(e) {
			;(this.tokens = []),
				(this.tokens.links = Object.create(null)),
				(this.options = e || ed),
				(this.options.tokenizer = this.options.tokenizer || new jc()),
				(this.tokenizer = this.options.tokenizer),
				(this.tokenizer.options = this.options),
				(this.tokenizer.lexer = this),
				(this.inlineQueue = []),
				(this.state = { inLink: !1, inRawBlock: !1, top: !0 })
			let t = { block: Ob.normal, inline: qf.normal }
			this.options.pedantic
				? ((t.block = Ob.pedantic), (t.inline = qf.pedantic))
				: this.options.gfm &&
					((t.block = Ob.gfm), this.options.breaks ? (t.inline = qf.breaks) : (t.inline = qf.gfm)),
				(this.tokenizer.rules = t)
		}
		static get rules() {
			return { block: Ob, inline: qf }
		}
		static lex(e, t) {
			return new o(t).lex(e)
		}
		static lexInline(e, t) {
			return new o(t).inlineTokens(e)
		}
		lex(e) {
			;(e = e.replace(
				/\r\n|\r/g,
				`
`,
			)),
				this.blockTokens(e, this.tokens)
			for (let t = 0; t < this.inlineQueue.length; t++) {
				let n = this.inlineQueue[t]
				this.inlineTokens(n.src, n.tokens)
			}
			return (this.inlineQueue = []), this.tokens
		}
		blockTokens(e, t = [], n = !1) {
			this.options.pedantic
				? (e = e.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
				: (e = e.replace(/^( *)(\t+)/gm, (a, l, d) => l + "    ".repeat(d.length)))
			let r, i, s
			for (; e; )
				if (
					!(
						this.options.extensions &&
						this.options.extensions.block &&
						this.options.extensions.block.some((a) =>
							(r = a.call({ lexer: this }, e, t)) ? ((e = e.substring(r.raw.length)), t.push(r), !0) : !1,
						)
					)
				) {
					if ((r = this.tokenizer.space(e))) {
						;(e = e.substring(r.raw.length)),
							r.raw.length === 1 && t.length > 0
								? (t[t.length - 1].raw += `
`)
								: t.push(r)
						continue
					}
					if ((r = this.tokenizer.code(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && (i.type === "paragraph" || i.type === "text")
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r)
						continue
					}
					if ((r = this.tokenizer.fences(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.heading(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.hr(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.blockquote(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.list(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.html(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.def(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && (i.type === "paragraph" || i.type === "text")
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.raw),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: this.tokens.links[r.tag] ||
									(this.tokens.links[r.tag] = { href: r.href, title: r.title })
						continue
					}
					if ((r = this.tokenizer.table(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if ((r = this.tokenizer.lheading(e))) {
						;(e = e.substring(r.raw.length)), t.push(r)
						continue
					}
					if (((s = e), this.options.extensions && this.options.extensions.startBlock)) {
						let a = 1 / 0,
							l = e.slice(1),
							d
						this.options.extensions.startBlock.forEach((c) => {
							;(d = c.call({ lexer: this }, l)), typeof d == "number" && d >= 0 && (a = Math.min(a, d))
						}),
							a < 1 / 0 && a >= 0 && (s = e.substring(0, a + 1))
					}
					if (this.state.top && (r = this.tokenizer.paragraph(s))) {
						;(i = t[t.length - 1]),
							n && i?.type === "paragraph"
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r),
							(n = s.length !== e.length),
							(e = e.substring(r.raw.length))
						continue
					}
					if ((r = this.tokenizer.text(e))) {
						;(e = e.substring(r.raw.length)),
							(i = t[t.length - 1]),
							i && i.type === "text"
								? ((i.raw +=
										`
` + r.raw),
									(i.text +=
										`
` + r.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = i.text))
								: t.push(r)
						continue
					}
					if (e) {
						let a = "Infinite loop on byte: " + e.charCodeAt(0)
						if (this.options.silent) {
							console.error(a)
							break
						} else throw new Error(a)
					}
				}
			return (this.state.top = !0), t
		}
		inline(e, t = []) {
			return this.inlineQueue.push({ src: e, tokens: t }), t
		}
		inlineTokens(e, t = []) {
			let n,
				r,
				i,
				s = e,
				a,
				l,
				d
			if (this.tokens.links) {
				let c = Object.keys(this.tokens.links)
				if (c.length > 0)
					for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null; )
						c.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) &&
							(s =
								s.slice(0, a.index) +
								"[" +
								"a".repeat(a[0].length - 2) +
								"]" +
								s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
			}
			for (; (a = this.tokenizer.rules.inline.blockSkip.exec(s)) != null; )
				s =
					s.slice(0, a.index) +
					"[" +
					"a".repeat(a[0].length - 2) +
					"]" +
					s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
			for (; (a = this.tokenizer.rules.inline.anyPunctuation.exec(s)) != null; )
				s = s.slice(0, a.index) + "++" + s.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex)
			for (; e; )
				if (
					(l || (d = ""),
					(l = !1),
					!(
						this.options.extensions &&
						this.options.extensions.inline &&
						this.options.extensions.inline.some((c) =>
							(n = c.call({ lexer: this }, e, t)) ? ((e = e.substring(n.raw.length)), t.push(n), !0) : !1,
						)
					))
				) {
					if ((n = this.tokenizer.escape(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.tag(e))) {
						;(e = e.substring(n.raw.length)),
							(r = t[t.length - 1]),
							r && n.type === "text" && r.type === "text"
								? ((r.raw += n.raw), (r.text += n.text))
								: t.push(n)
						continue
					}
					if ((n = this.tokenizer.link(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.reflink(e, this.tokens.links))) {
						;(e = e.substring(n.raw.length)),
							(r = t[t.length - 1]),
							r && n.type === "text" && r.type === "text"
								? ((r.raw += n.raw), (r.text += n.text))
								: t.push(n)
						continue
					}
					if ((n = this.tokenizer.emStrong(e, s, d))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.codespan(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.br(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.del(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if ((n = this.tokenizer.autolink(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if (!this.state.inLink && (n = this.tokenizer.url(e))) {
						;(e = e.substring(n.raw.length)), t.push(n)
						continue
					}
					if (((i = e), this.options.extensions && this.options.extensions.startInline)) {
						let c = 1 / 0,
							u = e.slice(1),
							m
						this.options.extensions.startInline.forEach((f) => {
							;(m = f.call({ lexer: this }, u)), typeof m == "number" && m >= 0 && (c = Math.min(c, m))
						}),
							c < 1 / 0 && c >= 0 && (i = e.substring(0, c + 1))
					}
					if ((n = this.tokenizer.inlineText(i))) {
						;(e = e.substring(n.raw.length)),
							n.raw.slice(-1) !== "_" && (d = n.raw.slice(-1)),
							(l = !0),
							(r = t[t.length - 1]),
							r && r.type === "text" ? ((r.raw += n.raw), (r.text += n.text)) : t.push(n)
						continue
					}
					if (e) {
						let c = "Infinite loop on byte: " + e.charCodeAt(0)
						if (this.options.silent) {
							console.error(c)
							break
						} else throw new Error(c)
					}
				}
			return t
		}
	},
	Gc = class {
		options
		parser
		constructor(e) {
			this.options = e || ed
		}
		space(e) {
			return ""
		}
		code({ text: e, lang: t, escaped: n }) {
			let r = (t || "").match(/^\S*/)?.[0],
				i =
					e.replace(/\n$/, "") +
					`
`
			return r
				? '<pre><code class="language-' +
						Qr(r) +
						'">' +
						(n ? i : Qr(i, !0)) +
						`</code></pre>
`
				: "<pre><code>" +
						(n ? i : Qr(i, !0)) +
						`</code></pre>
`
		}
		blockquote({ tokens: e }) {
			return `<blockquote>
${this.parser.parse(e)}</blockquote>
`
		}
		html({ text: e }) {
			return e
		}
		heading({ tokens: e, depth: t }) {
			return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`
		}
		hr(e) {
			return `<hr>
`
		}
		list(e) {
			let t = e.ordered,
				n = e.start,
				r = ""
			for (let a = 0; a < e.items.length; a++) {
				let l = e.items[a]
				r += this.listitem(l)
			}
			let i = t ? "ol" : "ul",
				s = t && n !== 1 ? ' start="' + n + '"' : ""
			return (
				"<" +
				i +
				s +
				`>
` +
				r +
				"</" +
				i +
				`>
`
			)
		}
		listitem(e) {
			let t = ""
			if (e.task) {
				let n = this.checkbox({ checked: !!e.checked })
				e.loose
					? e.tokens.length > 0 && e.tokens[0].type === "paragraph"
						? ((e.tokens[0].text = n + " " + e.tokens[0].text),
							e.tokens[0].tokens &&
								e.tokens[0].tokens.length > 0 &&
								e.tokens[0].tokens[0].type === "text" &&
								(e.tokens[0].tokens[0].text = n + " " + e.tokens[0].tokens[0].text))
						: e.tokens.unshift({ type: "text", raw: n + " ", text: n + " " })
					: (t += n + " ")
			}
			return (
				(t += this.parser.parse(e.tokens, !!e.loose)),
				`<li>${t}</li>
`
			)
		}
		checkbox({ checked: e }) {
			return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
		}
		paragraph({ tokens: e }) {
			return `<p>${this.parser.parseInline(e)}</p>
`
		}
		table(e) {
			let t = "",
				n = ""
			for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i])
			t += this.tablerow({ text: n })
			let r = ""
			for (let i = 0; i < e.rows.length; i++) {
				let s = e.rows[i]
				n = ""
				for (let a = 0; a < s.length; a++) n += this.tablecell(s[a])
				r += this.tablerow({ text: n })
			}
			return (
				r && (r = `<tbody>${r}</tbody>`),
				`<table>
<thead>
` +
					t +
					`</thead>
` +
					r +
					`</table>
`
			)
		}
		tablerow({ text: e }) {
			return `<tr>
${e}</tr>
`
		}
		tablecell(e) {
			let t = this.parser.parseInline(e.tokens),
				n = e.header ? "th" : "td"
			return (
				(e.align ? `<${n} align="${e.align}">` : `<${n}>`) +
				t +
				`</${n}>
`
			)
		}
		strong({ tokens: e }) {
			return `<strong>${this.parser.parseInline(e)}</strong>`
		}
		em({ tokens: e }) {
			return `<em>${this.parser.parseInline(e)}</em>`
		}
		codespan({ text: e }) {
			return `<code>${e}</code>`
		}
		br(e) {
			return "<br>"
		}
		del({ tokens: e }) {
			return `<del>${this.parser.parseInline(e)}</del>`
		}
		link({ href: e, title: t, tokens: n }) {
			let r = this.parser.parseInline(n),
				i = NL(e)
			if (i === null) return r
			e = i
			let s = '<a href="' + e + '"'
			return t && (s += ' title="' + t + '"'), (s += ">" + r + "</a>"), s
		}
		image({ href: e, title: t, text: n }) {
			let r = NL(e)
			if (r === null) return n
			e = r
			let i = `<img src="${e}" alt="${n}"`
			return t && (i += ` title="${t}"`), (i += ">"), i
		}
		text(e) {
			return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : e.text
		}
	},
	jf = class {
		strong({ text: e }) {
			return e
		}
		em({ text: e }) {
			return e
		}
		codespan({ text: e }) {
			return e
		}
		del({ text: e }) {
			return e
		}
		html({ text: e }) {
			return e
		}
		text({ text: e }) {
			return e
		}
		link({ text: e }) {
			return "" + e
		}
		image({ text: e }) {
			return "" + e
		}
		br() {
			return ""
		}
	},
	ps = class o {
		options
		renderer
		textRenderer
		constructor(e) {
			;(this.options = e || ed),
				(this.options.renderer = this.options.renderer || new Gc()),
				(this.renderer = this.options.renderer),
				(this.renderer.options = this.options),
				(this.renderer.parser = this),
				(this.textRenderer = new jf())
		}
		static parse(e, t) {
			return new o(t).parse(e)
		}
		static parseInline(e, t) {
			return new o(t).parseInline(e)
		}
		parse(e, t = !0) {
			let n = ""
			for (let r = 0; r < e.length; r++) {
				let i = e[r]
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					let a = i,
						l = this.options.extensions.renderers[a.type].call({ parser: this }, a)
					if (
						l !== !1 ||
						![
							"space",
							"hr",
							"heading",
							"code",
							"table",
							"blockquote",
							"list",
							"html",
							"paragraph",
							"text",
						].includes(a.type)
					) {
						n += l || ""
						continue
					}
				}
				let s = i
				switch (s.type) {
					case "space": {
						n += this.renderer.space(s)
						continue
					}
					case "hr": {
						n += this.renderer.hr(s)
						continue
					}
					case "heading": {
						n += this.renderer.heading(s)
						continue
					}
					case "code": {
						n += this.renderer.code(s)
						continue
					}
					case "table": {
						n += this.renderer.table(s)
						continue
					}
					case "blockquote": {
						n += this.renderer.blockquote(s)
						continue
					}
					case "list": {
						n += this.renderer.list(s)
						continue
					}
					case "html": {
						n += this.renderer.html(s)
						continue
					}
					case "paragraph": {
						n += this.renderer.paragraph(s)
						continue
					}
					case "text": {
						let a = s,
							l = this.renderer.text(a)
						for (; r + 1 < e.length && e[r + 1].type === "text"; )
							(a = e[++r]),
								(l +=
									`
` + this.renderer.text(a))
						t
							? (n += this.renderer.paragraph({
									type: "paragraph",
									raw: l,
									text: l,
									tokens: [{ type: "text", raw: l, text: l }],
								}))
							: (n += l)
						continue
					}
					default: {
						let a = 'Token with "' + s.type + '" type was not found.'
						if (this.options.silent) return console.error(a), ""
						throw new Error(a)
					}
				}
			}
			return n
		}
		parseInline(e, t) {
			t = t || this.renderer
			let n = ""
			for (let r = 0; r < e.length; r++) {
				let i = e[r]
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					let a = this.options.extensions.renderers[i.type].call({ parser: this }, i)
					if (
						a !== !1 ||
						!["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(
							i.type,
						)
					) {
						n += a || ""
						continue
					}
				}
				let s = i
				switch (s.type) {
					case "escape": {
						n += t.text(s)
						break
					}
					case "html": {
						n += t.html(s)
						break
					}
					case "link": {
						n += t.link(s)
						break
					}
					case "image": {
						n += t.image(s)
						break
					}
					case "strong": {
						n += t.strong(s)
						break
					}
					case "em": {
						n += t.em(s)
						break
					}
					case "codespan": {
						n += t.codespan(s)
						break
					}
					case "br": {
						n += t.br(s)
						break
					}
					case "del": {
						n += t.del(s)
						break
					}
					case "text": {
						n += t.text(s)
						break
					}
					default: {
						let a = 'Token with "' + s.type + '" type was not found.'
						if (this.options.silent) return console.error(a), ""
						throw new Error(a)
					}
				}
			}
			return n
		}
	},
	Kc = class {
		options
		constructor(e) {
			this.options = e || ed
		}
		static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens"])
		preprocess(e) {
			return e
		}
		postprocess(e) {
			return e
		}
		processAllTokens(e) {
			return e
		}
	},
	PP = class {
		defaults = _P()
		options = this.setOptions
		parse = this.parseMarkdown(us.lex, ps.parse)
		parseInline = this.parseMarkdown(us.lexInline, ps.parseInline)
		Parser = ps
		Renderer = Gc
		TextRenderer = jf
		Lexer = us
		Tokenizer = jc
		Hooks = Kc
		constructor(...e) {
			this.use(...e)
		}
		walkTokens(e, t) {
			let n = []
			for (let r of e)
				switch (((n = n.concat(t.call(this, r))), r.type)) {
					case "table": {
						let i = r
						for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t))
						for (let s of i.rows) for (let a of s) n = n.concat(this.walkTokens(a.tokens, t))
						break
					}
					case "list": {
						let i = r
						n = n.concat(this.walkTokens(i.items, t))
						break
					}
					default: {
						let i = r
						this.defaults.extensions?.childTokens?.[i.type]
							? this.defaults.extensions.childTokens[i.type].forEach((s) => {
									let a = i[s].flat(1 / 0)
									n = n.concat(this.walkTokens(a, t))
								})
							: i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)))
					}
				}
			return n
		}
		use(...e) {
			let t = this.defaults.extensions || { renderers: {}, childTokens: {} }
			return (
				e.forEach((n) => {
					let r = { ...n }
					if (
						((r.async = this.defaults.async || r.async || !1),
						n.extensions &&
							(n.extensions.forEach((i) => {
								if (!i.name) throw new Error("extension name required")
								if ("renderer" in i) {
									let s = t.renderers[i.name]
									s
										? (t.renderers[i.name] = function (...a) {
												let l = i.renderer.apply(this, a)
												return l === !1 && (l = s.apply(this, a)), l
											})
										: (t.renderers[i.name] = i.renderer)
								}
								if ("tokenizer" in i) {
									if (!i.level || (i.level !== "block" && i.level !== "inline"))
										throw new Error("extension level must be 'block' or 'inline'")
									let s = t[i.level]
									s ? s.unshift(i.tokenizer) : (t[i.level] = [i.tokenizer]),
										i.start &&
											(i.level === "block"
												? t.startBlock
													? t.startBlock.push(i.start)
													: (t.startBlock = [i.start])
												: i.level === "inline" &&
													(t.startInline
														? t.startInline.push(i.start)
														: (t.startInline = [i.start])))
								}
								"childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens)
							}),
							(r.extensions = t)),
						n.renderer)
					) {
						let i = this.defaults.renderer || new Gc(this.defaults)
						for (let s in n.renderer) {
							if (!(s in i)) throw new Error(`renderer '${s}' does not exist`)
							if (["options", "parser"].includes(s)) continue
							let a = s,
								l = n.renderer[a],
								d = i[a]
							i[a] = (...c) => {
								let u = l.apply(i, c)
								return u === !1 && (u = d.apply(i, c)), u || ""
							}
						}
						r.renderer = i
					}
					if (n.tokenizer) {
						let i = this.defaults.tokenizer || new jc(this.defaults)
						for (let s in n.tokenizer) {
							if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`)
							if (["options", "rules", "lexer"].includes(s)) continue
							let a = s,
								l = n.tokenizer[a],
								d = i[a]
							i[a] = (...c) => {
								let u = l.apply(i, c)
								return u === !1 && (u = d.apply(i, c)), u
							}
						}
						r.tokenizer = i
					}
					if (n.hooks) {
						let i = this.defaults.hooks || new Kc()
						for (let s in n.hooks) {
							if (!(s in i)) throw new Error(`hook '${s}' does not exist`)
							if (s === "options") continue
							let a = s,
								l = n.hooks[a],
								d = i[a]
							Kc.passThroughHooks.has(s)
								? (i[a] = (c) => {
										if (this.defaults.async)
											return Promise.resolve(l.call(i, c)).then((m) => d.call(i, m))
										let u = l.call(i, c)
										return d.call(i, u)
									})
								: (i[a] = (...c) => {
										let u = l.apply(i, c)
										return u === !1 && (u = d.apply(i, c)), u
									})
						}
						r.hooks = i
					}
					if (n.walkTokens) {
						let i = this.defaults.walkTokens,
							s = n.walkTokens
						r.walkTokens = function (a) {
							let l = []
							return l.push(s.call(this, a)), i && (l = l.concat(i.call(this, a))), l
						}
					}
					this.defaults = { ...this.defaults, ...r }
				}),
				this
			)
		}
		setOptions(e) {
			return (this.defaults = { ...this.defaults, ...e }), this
		}
		lexer(e, t) {
			return us.lex(e, t ?? this.defaults)
		}
		parser(e, t) {
			return ps.parse(e, t ?? this.defaults)
		}
		parseMarkdown(e, t) {
			return (r, i) => {
				let s = { ...i },
					a = { ...this.defaults, ...s },
					l = this.onError(!!a.silent, !!a.async)
				if (this.defaults.async === !0 && s.async === !1)
					return l(
						new Error(
							"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
						),
					)
				if (typeof r > "u" || r === null) return l(new Error("marked(): input parameter is undefined or null"))
				if (typeof r != "string")
					return l(
						new Error(
							"marked(): input parameter is of type " +
								Object.prototype.toString.call(r) +
								", string expected",
						),
					)
				if ((a.hooks && (a.hooks.options = a), a.async))
					return Promise.resolve(a.hooks ? a.hooks.preprocess(r) : r)
						.then((d) => e(d, a))
						.then((d) => (a.hooks ? a.hooks.processAllTokens(d) : d))
						.then((d) => (a.walkTokens ? Promise.all(this.walkTokens(d, a.walkTokens)).then(() => d) : d))
						.then((d) => t(d, a))
						.then((d) => (a.hooks ? a.hooks.postprocess(d) : d))
						.catch(l)
				try {
					a.hooks && (r = a.hooks.preprocess(r))
					let d = e(r, a)
					a.hooks && (d = a.hooks.processAllTokens(d)), a.walkTokens && this.walkTokens(d, a.walkTokens)
					let c = t(d, a)
					return a.hooks && (c = a.hooks.postprocess(c)), c
				} catch (d) {
					return l(d)
				}
			}
		}
		onError(e, t) {
			return (n) => {
				if (
					((n.message += `
Please report this to https://github.com/markedjs/marked.`),
					e)
				) {
					let r = "<p>An error occurred:</p><pre>" + Qr(n.message + "", !0) + "</pre>"
					return t ? Promise.resolve(r) : r
				}
				if (t) return Promise.reject(n)
				throw n
			}
		}
	},
	Zl = new PP()
function Tt(o, e) {
	return Zl.parse(o, e)
}
Tt.options = Tt.setOptions = function (o) {
	return Zl.setOptions(o), (Tt.defaults = Zl.defaults), VL(Tt.defaults), Tt
}
Tt.getDefaults = _P
Tt.defaults = ed
Tt.use = function (...o) {
	return Zl.use(...o), (Tt.defaults = Zl.defaults), VL(Tt.defaults), Tt
}
Tt.walkTokens = function (o, e) {
	return Zl.walkTokens(o, e)
}
Tt.parseInline = Zl.parseInline
Tt.Parser = ps
Tt.parser = ps.parse
Tt.Renderer = Gc
Tt.TextRenderer = jf
Tt.Lexer = us
Tt.lexer = us.lex
Tt.Tokenizer = jc
Tt.Hooks = Kc
Tt.parse = Tt
var zQ = Tt.options,
	qQ = Tt.setOptions,
	KQ = Tt.use,
	jQ = Tt.walkTokens,
	GQ = Tt.parseInline
var QQ = ps.parse,
	JQ = us.lex
var mo = Object.freeze({
	text: "text/plain",
	binary: "application/octet-stream",
	unknown: "application/unknown",
	markdown: "text/markdown",
	latex: "text/latex",
	uriList: "text/uri-list",
	html: "text/html",
})
var XW = /^(.+)\/(.+?)(;.+)?$/
function LP(o, e) {
	let t = XW.exec(o)
	return t ? `${t[1].toLowerCase()}/${t[2].toLowerCase()}${t[3] ?? ""}` : e ? void 0 : o
}
var dr = Symbol("unset"),
	Fb = class {
		constructor() {
			this.root = new Jf()
			this._size = 0
		}
		get size() {
			return this._size
		}
		get nodes() {
			return this.root.children?.values() || Rt.empty()
		}
		get entries() {
			return this.root.children?.entries() || Rt.empty()
		}
		insert(e, t, n) {
			this.opNode(e, (r) => (r._value = t), n)
		}
		mutate(e, t) {
			this.opNode(e, (n) => (n._value = t(n._value === dr ? void 0 : n._value)))
		}
		mutatePath(e, t) {
			this.opNode(
				e,
				() => {},
				(n) => t(n),
			)
		}
		delete(e) {
			let t = this.getPathToKey(e)
			if (!t) return
			let n = t.length - 1,
				r = t[n].node._value
			if (r !== dr) {
				for (this._size--, t[n].node._value = dr; n > 0; n--) {
					let { node: i, part: s } = t[n]
					if (i.children?.size || i._value !== dr) break
					t[n - 1].node.children.delete(s)
				}
				return r
			}
		}
		*deleteRecursive(e) {
			let t = this.getPathToKey(e)
			if (!t) return
			let n = t[t.length - 1].node
			for (let r = t.length - 1; r > 0; r--) {
				let i = t[r - 1]
				if ((i.node.children.delete(t[r].part), i.node.children.size > 0 || i.node._value !== dr)) break
			}
			for (let r of XL(n)) r._value !== dr && (this._size--, yield r._value)
			n === this.root && ((this.root._value = dr), (this.root.children = void 0))
		}
		find(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return
				t = r
			}
			return t._value === dr ? void 0 : t._value
		}
		hasKeyOrParent(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				if (r._value !== dr) return !0
				t = r
			}
			return !1
		}
		hasKeyOrChildren(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				t = r
			}
			return !0
		}
		hasKey(e) {
			let t = this.root
			for (let n of e) {
				let r = t.children?.get(n)
				if (!r) return !1
				t = r
			}
			return t._value !== dr
		}
		getPathToKey(e) {
			let t = [{ part: "", node: this.root }],
				n = 0
			for (let r of e) {
				let i = t[n].node.children?.get(r)
				if (!i) return
				t.push({ part: r, node: i }), n++
			}
			return t
		}
		opNode(e, t, n) {
			let r = this.root
			for (let a of e) {
				if (r.children)
					if (r.children.has(a)) r = r.children.get(a)
					else {
						let l = new Jf()
						r.children.set(a, l), (r = l)
					}
				else {
					let l = new Jf()
					;(r.children = new Map([[a, l]])), (r = l)
				}
				n?.(r)
			}
			let i = r._value === dr ? 0 : 1
			t(r)
			let s = r._value === dr ? 0 : 1
			this._size += s - i
		}
		*values() {
			for (let { _value: e } of XL(this.root)) e !== dr && (yield e)
		}
	}
function* XL(o) {
	let e = [o]
	for (; e.length > 0; ) {
		let t = e.pop()
		if ((yield t, t.children)) for (let n of t.children.values()) e.push(n)
	}
}
var Jf = class {
	constructor() {
		this._value = dr
	}
	get value() {
		return this._value === dr ? void 0 : this._value
	}
	set value(e) {
		this._value = e === void 0 ? dr : e
	}
}
var cn = class o {
	constructor(e, t) {
		;(this.lineNumber = e), (this.column = t)
	}
	with(e = this.lineNumber, t = this.column) {
		return e === this.lineNumber && t === this.column ? this : new o(e, t)
	}
	delta(e = 0, t = 0) {
		return this.with(Math.max(1, this.lineNumber + e), Math.max(1, this.column + t))
	}
	equals(e) {
		return o.equals(this, e)
	}
	static equals(e, t) {
		return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column
	}
	isBefore(e) {
		return o.isBefore(this, e)
	}
	static isBefore(e, t) {
		return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column
	}
	isBeforeOrEqual(e) {
		return o.isBeforeOrEqual(this, e)
	}
	static isBeforeOrEqual(e, t) {
		return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column
	}
	static compare(e, t) {
		let n = e.lineNumber | 0,
			r = t.lineNumber | 0
		if (n === r) {
			let i = e.column | 0,
				s = t.column | 0
			return i - s
		}
		return n - r
	}
	clone() {
		return new o(this.lineNumber, this.column)
	}
	toString() {
		return "(" + this.lineNumber + "," + this.column + ")"
	}
	static lift(e) {
		return new o(e.lineNumber, e.column)
	}
	static isIPosition(e) {
		return e && typeof e.lineNumber == "number" && typeof e.column == "number"
	}
	toJSON() {
		return { lineNumber: this.lineNumber, column: this.column }
	}
}
var Re = class o {
	constructor(e, t, n, r) {
		e > n || (e === n && t > r)
			? ((this.startLineNumber = n), (this.startColumn = r), (this.endLineNumber = e), (this.endColumn = t))
			: ((this.startLineNumber = e), (this.startColumn = t), (this.endLineNumber = n), (this.endColumn = r))
	}
	isEmpty() {
		return o.isEmpty(this)
	}
	static isEmpty(e) {
		return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn
	}
	containsPosition(e) {
		return o.containsPosition(this, e)
	}
	static containsPosition(e, t) {
		return !(
			t.lineNumber < e.startLineNumber ||
			t.lineNumber > e.endLineNumber ||
			(t.lineNumber === e.startLineNumber && t.column < e.startColumn) ||
			(t.lineNumber === e.endLineNumber && t.column > e.endColumn)
		)
	}
	static strictContainsPosition(e, t) {
		return !(
			t.lineNumber < e.startLineNumber ||
			t.lineNumber > e.endLineNumber ||
			(t.lineNumber === e.startLineNumber && t.column <= e.startColumn) ||
			(t.lineNumber === e.endLineNumber && t.column >= e.endColumn)
		)
	}
	containsRange(e) {
		return o.containsRange(this, e)
	}
	static containsRange(e, t) {
		return !(
			t.startLineNumber < e.startLineNumber ||
			t.endLineNumber < e.startLineNumber ||
			t.startLineNumber > e.endLineNumber ||
			t.endLineNumber > e.endLineNumber ||
			(t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn) ||
			(t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn)
		)
	}
	strictContainsRange(e) {
		return o.strictContainsRange(this, e)
	}
	static strictContainsRange(e, t) {
		return !(
			t.startLineNumber < e.startLineNumber ||
			t.endLineNumber < e.startLineNumber ||
			t.startLineNumber > e.endLineNumber ||
			t.endLineNumber > e.endLineNumber ||
			(t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn) ||
			(t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn)
		)
	}
	plusRange(e) {
		return o.plusRange(this, e)
	}
	static plusRange(e, t) {
		let n, r, i, s
		return (
			t.startLineNumber < e.startLineNumber
				? ((n = t.startLineNumber), (r = t.startColumn))
				: t.startLineNumber === e.startLineNumber
					? ((n = t.startLineNumber), (r = Math.min(t.startColumn, e.startColumn)))
					: ((n = e.startLineNumber), (r = e.startColumn)),
			t.endLineNumber > e.endLineNumber
				? ((i = t.endLineNumber), (s = t.endColumn))
				: t.endLineNumber === e.endLineNumber
					? ((i = t.endLineNumber), (s = Math.max(t.endColumn, e.endColumn)))
					: ((i = e.endLineNumber), (s = e.endColumn)),
			new o(n, r, i, s)
		)
	}
	intersectRanges(e) {
		return o.intersectRanges(this, e)
	}
	static intersectRanges(e, t) {
		let n = e.startLineNumber,
			r = e.startColumn,
			i = e.endLineNumber,
			s = e.endColumn,
			a = t.startLineNumber,
			l = t.startColumn,
			d = t.endLineNumber,
			c = t.endColumn
		return (
			n < a ? ((n = a), (r = l)) : n === a && (r = Math.max(r, l)),
			i > d ? ((i = d), (s = c)) : i === d && (s = Math.min(s, c)),
			n > i || (n === i && r > s) ? null : new o(n, r, i, s)
		)
	}
	equalsRange(e) {
		return o.equalsRange(this, e)
	}
	static equalsRange(e, t) {
		return !e && !t
			? !0
			: !!e &&
					!!t &&
					e.startLineNumber === t.startLineNumber &&
					e.startColumn === t.startColumn &&
					e.endLineNumber === t.endLineNumber &&
					e.endColumn === t.endColumn
	}
	getEndPosition() {
		return o.getEndPosition(this)
	}
	static getEndPosition(e) {
		return new cn(e.endLineNumber, e.endColumn)
	}
	getStartPosition() {
		return o.getStartPosition(this)
	}
	static getStartPosition(e) {
		return new cn(e.startLineNumber, e.startColumn)
	}
	toString() {
		return (
			"[" +
			this.startLineNumber +
			"," +
			this.startColumn +
			" -> " +
			this.endLineNumber +
			"," +
			this.endColumn +
			"]"
		)
	}
	setEndPosition(e, t) {
		return new o(this.startLineNumber, this.startColumn, e, t)
	}
	setStartPosition(e, t) {
		return new o(e, t, this.endLineNumber, this.endColumn)
	}
	collapseToStart() {
		return o.collapseToStart(this)
	}
	static collapseToStart(e) {
		return new o(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn)
	}
	collapseToEnd() {
		return o.collapseToEnd(this)
	}
	static collapseToEnd(e) {
		return new o(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn)
	}
	delta(e) {
		return new o(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn)
	}
	isSingleLine() {
		return this.startLineNumber === this.endLineNumber
	}
	static fromPositions(e, t = e) {
		return new o(e.lineNumber, e.column, t.lineNumber, t.column)
	}
	static lift(e) {
		return e ? new o(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null
	}
	static isIRange(e) {
		return (
			e &&
			typeof e.startLineNumber == "number" &&
			typeof e.startColumn == "number" &&
			typeof e.endLineNumber == "number" &&
			typeof e.endColumn == "number"
		)
	}
	static areIntersectingOrTouching(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber ||
			(e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn) ||
			t.endLineNumber < e.startLineNumber ||
			(t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn)
		)
	}
	static areIntersecting(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber ||
			(e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn) ||
			t.endLineNumber < e.startLineNumber ||
			(t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn)
		)
	}
	static areOnlyIntersecting(e, t) {
		return !(
			e.endLineNumber < t.startLineNumber - 1 ||
			(e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn - 1) ||
			t.endLineNumber < e.startLineNumber - 1 ||
			(t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn - 1)
		)
	}
	static compareRangesUsingStarts(e, t) {
		if (e && t) {
			let i = e.startLineNumber | 0,
				s = t.startLineNumber | 0
			if (i === s) {
				let a = e.startColumn | 0,
					l = t.startColumn | 0
				if (a === l) {
					let d = e.endLineNumber | 0,
						c = t.endLineNumber | 0
					if (d === c) {
						let u = e.endColumn | 0,
							m = t.endColumn | 0
						return u - m
					}
					return d - c
				}
				return a - l
			}
			return i - s
		}
		return (e ? 1 : 0) - (t ? 1 : 0)
	}
	static compareRangesUsingEnds(e, t) {
		return e.endLineNumber === t.endLineNumber
			? e.endColumn === t.endColumn
				? e.startLineNumber === t.startLineNumber
					? e.startColumn - t.startColumn
					: e.startLineNumber - t.startLineNumber
				: e.endColumn - t.endColumn
			: e.endLineNumber - t.endLineNumber
	}
	static spansMultipleLines(e) {
		return e.endLineNumber > e.startLineNumber
	}
	toJSON() {
		return this
	}
}
var Nb = class {
	static insert(e, t) {
		return { range: new Re(e.lineNumber, e.column, e.lineNumber, e.column), text: t, forceMoveMarkers: !0 }
	}
	static delete(e) {
		return { range: e, text: null }
	}
	static replace(e, t) {
		return { range: e, text: t }
	}
	static replaceMove(e, t) {
		return { range: e, text: t, forceMoveMarkers: !0 }
	}
}
var Xf = class {
		constructor() {
			this._tokenizationSupports = new Map()
			this._factories = new Map()
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this._colorMap = null
		}
		handleChange(e) {
			this._onDidChange.fire({ changedLanguages: e, changedColorMap: !1 })
		}
		register(e, t) {
			return (
				this._tokenizationSupports.set(e, t),
				this.handleChange([e]),
				q(() => {
					this._tokenizationSupports.get(e) === t &&
						(this._tokenizationSupports.delete(e), this.handleChange([e]))
				})
			)
		}
		get(e) {
			return this._tokenizationSupports.get(e) || null
		}
		registerFactory(e, t) {
			this._factories.get(e)?.dispose()
			let n = new MP(this, e, t)
			return (
				this._factories.set(e, n),
				q(() => {
					let r = this._factories.get(e)
					!r || r !== n || (this._factories.delete(e), r.dispose())
				})
			)
		}
		async getOrCreate(e) {
			let t = this.get(e)
			if (t) return t
			let n = this._factories.get(e)
			return !n || n.isResolved ? null : (await n.resolve(), this.get(e))
		}
		isResolved(e) {
			if (this.get(e)) return !0
			let n = this._factories.get(e)
			return !!(!n || n.isResolved)
		}
		setColorMap(e) {
			;(this._colorMap = e),
				this._onDidChange.fire({
					changedLanguages: Array.from(this._tokenizationSupports.keys()),
					changedColorMap: !0,
				})
		}
		getColorMap() {
			return this._colorMap
		}
		getDefaultBackground() {
			return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null
		}
	},
	MP = class extends $ {
		constructor(t, n, r) {
			super()
			this._registry = t
			this._languageId = n
			this._factory = r
			this._isDisposed = !1
			this._resolvePromise = null
			this._isResolved = !1
		}
		get isResolved() {
			return this._isResolved
		}
		dispose() {
			;(this._isDisposed = !0), super.dispose()
		}
		async resolve() {
			return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise
		}
		async _create() {
			let t = await this._factory.tokenizationSupport
			;(this._isResolved = !0),
				t && !this._isDisposed && this._register(this._registry.register(this._languageId, t))
		}
	}
var ZW
;((i) => {
	let o = new Map()
	o.set(0, ce.symbolMethod),
		o.set(1, ce.symbolFunction),
		o.set(2, ce.symbolConstructor),
		o.set(3, ce.symbolField),
		o.set(4, ce.symbolVariable),
		o.set(5, ce.symbolClass),
		o.set(6, ce.symbolStruct),
		o.set(7, ce.symbolInterface),
		o.set(8, ce.symbolModule),
		o.set(9, ce.symbolProperty),
		o.set(10, ce.symbolEvent),
		o.set(11, ce.symbolOperator),
		o.set(12, ce.symbolUnit),
		o.set(13, ce.symbolValue),
		o.set(15, ce.symbolEnum),
		o.set(14, ce.symbolConstant),
		o.set(15, ce.symbolEnum),
		o.set(16, ce.symbolEnumMember),
		o.set(17, ce.symbolKeyword),
		o.set(27, ce.symbolSnippet),
		o.set(18, ce.symbolText),
		o.set(19, ce.symbolColor),
		o.set(20, ce.symbolFile),
		o.set(21, ce.symbolReference),
		o.set(22, ce.symbolCustomColor),
		o.set(23, ce.symbolFolder),
		o.set(24, ce.symbolTypeParameter),
		o.set(25, ce.account),
		o.set(26, ce.issues)
	function e(s) {
		let a = o.get(s)
		return a || (console.info("No codicon found for CompletionItemKind " + s), (a = ce.symbolProperty)), a
	}
	i.toIcon = e
	function t(s) {
		switch (s) {
			case 0:
				return p("suggestWidget.kind.method", "Method")
			case 1:
				return p("suggestWidget.kind.function", "Function")
			case 2:
				return p("suggestWidget.kind.constructor", "Constructor")
			case 3:
				return p("suggestWidget.kind.field", "Field")
			case 4:
				return p("suggestWidget.kind.variable", "Variable")
			case 5:
				return p("suggestWidget.kind.class", "Class")
			case 6:
				return p("suggestWidget.kind.struct", "Struct")
			case 7:
				return p("suggestWidget.kind.interface", "Interface")
			case 8:
				return p("suggestWidget.kind.module", "Module")
			case 9:
				return p("suggestWidget.kind.property", "Property")
			case 10:
				return p("suggestWidget.kind.event", "Event")
			case 11:
				return p("suggestWidget.kind.operator", "Operator")
			case 12:
				return p("suggestWidget.kind.unit", "Unit")
			case 13:
				return p("suggestWidget.kind.value", "Value")
			case 14:
				return p("suggestWidget.kind.constant", "Constant")
			case 15:
				return p("suggestWidget.kind.enum", "Enum")
			case 16:
				return p("suggestWidget.kind.enumMember", "Enum Member")
			case 17:
				return p("suggestWidget.kind.keyword", "Keyword")
			case 18:
				return p("suggestWidget.kind.text", "Text")
			case 19:
				return p("suggestWidget.kind.color", "Color")
			case 20:
				return p("suggestWidget.kind.file", "File")
			case 21:
				return p("suggestWidget.kind.reference", "Reference")
			case 22:
				return p("suggestWidget.kind.customcolor", "Custom Color")
			case 23:
				return p("suggestWidget.kind.folder", "Folder")
			case 24:
				return p("suggestWidget.kind.typeParameter", "Type Parameter")
			case 25:
				return p("suggestWidget.kind.user", "User")
			case 26:
				return p("suggestWidget.kind.issue", "Issue")
			case 27:
				return p("suggestWidget.kind.snippet", "Snippet")
			default:
				return ""
		}
	}
	i.toLabel = t
	let n = new Map()
	n.set("method", 0),
		n.set("function", 1),
		n.set("constructor", 2),
		n.set("field", 3),
		n.set("variable", 4),
		n.set("class", 5),
		n.set("struct", 6),
		n.set("interface", 7),
		n.set("module", 8),
		n.set("property", 9),
		n.set("event", 10),
		n.set("operator", 11),
		n.set("unit", 12),
		n.set("value", 13),
		n.set("constant", 14),
		n.set("enum", 15),
		n.set("enum-member", 16),
		n.set("enumMember", 16),
		n.set("keyword", 17),
		n.set("snippet", 27),
		n.set("text", 18),
		n.set("color", 19),
		n.set("file", 20),
		n.set("reference", 21),
		n.set("customcolor", 22),
		n.set("folder", 23),
		n.set("type-parameter", 24),
		n.set("typeParameter", 24),
		n.set("account", 25),
		n.set("issue", 26)
	function r(s, a) {
		let l = n.get(s)
		return typeof l > "u" && !a && (l = 9), l
	}
	i.fromString = r
})((ZW ||= {}))
function ZL(o) {
	return (
		o &&
		b.isUri(o.uri) &&
		Re.isIRange(o.range) &&
		(Re.isIRange(o.originSelectionRange) || Re.isIRange(o.targetSelectionRange))
	)
}
var SJ = {
	17: p("Array", "array"),
	16: p("Boolean", "boolean"),
	4: p("Class", "class"),
	13: p("Constant", "constant"),
	8: p("Constructor", "constructor"),
	9: p("Enum", "enumeration"),
	21: p("EnumMember", "enumeration member"),
	23: p("Event", "event"),
	7: p("Field", "field"),
	0: p("File", "file"),
	11: p("Function", "function"),
	10: p("Interface", "interface"),
	19: p("Key", "key"),
	5: p("Method", "method"),
	1: p("Module", "module"),
	2: p("Namespace", "namespace"),
	20: p("Null", "null"),
	15: p("Number", "number"),
	18: p("Object", "object"),
	24: p("Operator", "operator"),
	3: p("Package", "package"),
	6: p("Property", "property"),
	14: p("String", "string"),
	22: p("Struct", "struct"),
	25: p("TypeParameter", "type parameter"),
	12: p("Variable", "variable"),
}
var eV
;((r) => {
	let o = new Map()
	o.set(0, ce.symbolFile),
		o.set(1, ce.symbolModule),
		o.set(2, ce.symbolNamespace),
		o.set(3, ce.symbolPackage),
		o.set(4, ce.symbolClass),
		o.set(5, ce.symbolMethod),
		o.set(6, ce.symbolProperty),
		o.set(7, ce.symbolField),
		o.set(8, ce.symbolConstructor),
		o.set(9, ce.symbolEnum),
		o.set(10, ce.symbolInterface),
		o.set(11, ce.symbolFunction),
		o.set(12, ce.symbolVariable),
		o.set(13, ce.symbolConstant),
		o.set(14, ce.symbolString),
		o.set(15, ce.symbolNumber),
		o.set(16, ce.symbolBoolean),
		o.set(17, ce.symbolArray),
		o.set(18, ce.symbolObject),
		o.set(19, ce.symbolKey),
		o.set(20, ce.symbolNull),
		o.set(21, ce.symbolEnumMember),
		o.set(22, ce.symbolStruct),
		o.set(23, ce.symbolEvent),
		o.set(24, ce.symbolOperator),
		o.set(25, ce.symbolTypeParameter)
	function e(i) {
		let s = o.get(i)
		return s || (console.info("No codicon found for SymbolKind " + i), (s = ce.symbolProperty)), s
	}
	r.toIcon = e
	let t = new Map()
	t.set(0, 20),
		t.set(1, 8),
		t.set(2, 8),
		t.set(3, 8),
		t.set(4, 5),
		t.set(5, 0),
		t.set(6, 9),
		t.set(7, 3),
		t.set(8, 2),
		t.set(9, 15),
		t.set(10, 7),
		t.set(11, 1),
		t.set(12, 4),
		t.set(13, 14),
		t.set(14, 18),
		t.set(15, 13),
		t.set(16, 13),
		t.set(17, 13),
		t.set(18, 13),
		t.set(19, 17),
		t.set(20, 13),
		t.set(21, 16),
		t.set(22, 6),
		t.set(23, 10),
		t.set(24, 11),
		t.set(25, 24)
	function n(i) {
		let s = t.get(i)
		return s === void 0 && (console.info("No completion kind found for SymbolKind " + i), (s = 20)), s
	}
	r.toCompletionKind = n
})((eV ||= {}))
var Ub = class {
		static asEditOperation(e) {
			return Nb.replace(Re.lift(e.range), e.text)
		}
		static isTextEdit(e) {
			let t = e
			return typeof t.text == "string" && Re.isIRange(t.range)
		}
	},
	ms = class o {
		constructor(e) {
			this.value = e
		}
		static {
			this.Comment = new o("comment")
		}
		static {
			this.Imports = new o("imports")
		}
		static {
			this.Region = new o("region")
		}
		static fromValue(e) {
			switch (e) {
				case "comment":
					return o.Comment
				case "imports":
					return o.Imports
				case "region":
					return o.Region
			}
			return new o(e)
		}
	}
var FP
;((e) => {
	function o(t) {
		return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string"
	}
	e.is = o
})((FP ||= {}))
var TJ = new Xf(),
	EJ = new Xf()
var NP = ((r) => (
	(r[(r.Left = 1)] = "Left"),
	(r[(r.Center = 2)] = "Center"),
	(r[(r.Right = 4)] = "Right"),
	(r[(r.Full = 7)] = "Full"),
	r
))(NP || {})
var td = class {
	constructor(e, t) {
		this._findMatchBrand = void 0
		;(this.range = e), (this.matches = t)
	}
}
var Wb = class {
		constructor(e, t, n) {
			;(this.regex = e), (this.wordSeparators = t), (this.simpleSearch = n)
		}
	},
	Vb = class {
		constructor(e, t, n) {
			this.reverseEdits = e
			this.changes = t
			this.trimAutoWhitespaceLineNumbers = n
		}
	}
var Qc = ((r) => (
	(r[(r.Hint = 1)] = "Hint"),
	(r[(r.Info = 2)] = "Info"),
	(r[(r.Warning = 4)] = "Warning"),
	(r[(r.Error = 8)] = "Error"),
	r
))(Qc || {})
;((a) => {
	function o(l, d) {
		return d - l
	}
	a.compare = o
	let e = Object.create(null)
	;(e[8] = p("sev.error", "Error")), (e[4] = p("sev.warning", "Warning")), (e[2] = p("sev.info", "Info"))
	function t(l) {
		return e[l] || ""
	}
	a.toString = t
	let n = Object.create(null)
	;(n[8] = p("sev.errors", "Errors")), (n[4] = p("sev.warnings", "Warnings")), (n[2] = p("sev.infos", "Infos"))
	function r(l) {
		return n[l] || ""
	}
	a.toStringPlural = r
	function i(l) {
		switch (l) {
			case It.Error:
				return 8
			case It.Warning:
				return 4
			case It.Info:
				return 2
			case It.Ignore:
				return 1
		}
	}
	a.fromSeverity = i
	function s(l) {
		switch (l) {
			case 8:
				return It.Error
			case 4:
				return It.Warning
			case 2:
				return It.Info
			case 1:
				return It.Ignore
		}
	}
	a.toSeverity = s
})((Qc ||= {}))
var tV
;((n) => {
	function e(r) {
		return t(r, !0)
	}
	n.makeKey = e
	function t(r, i) {
		let s = [""]
		return (
			r.source ? s.push(r.source.replace("\xA6", "\\\xA6")) : s.push(""),
			r.code
				? typeof r.code == "string"
					? s.push(r.code.replace("\xA6", "\\\xA6"))
					: s.push(r.code.value.replace("\xA6", "\\\xA6"))
				: s.push(""),
			r.severity !== void 0 && r.severity !== null ? s.push(Qc.toString(r.severity)) : s.push(""),
			r.message && i ? s.push(r.message.replace("\xA6", "\\\xA6")) : s.push(""),
			r.startLineNumber !== void 0 && r.startLineNumber !== null
				? s.push(r.startLineNumber.toString())
				: s.push(""),
			r.startColumn !== void 0 && r.startColumn !== null ? s.push(r.startColumn.toString()) : s.push(""),
			r.endLineNumber !== void 0 && r.endLineNumber !== null ? s.push(r.endLineNumber.toString()) : s.push(""),
			r.endColumn !== void 0 && r.endColumn !== null ? s.push(r.endColumn.toString()) : s.push(""),
			s.push(""),
			s.join("\xA6")
		)
	}
	n.makeKeyOptionalMessage = t
})((tV ||= {}))
var RJ = O("markerService")
var nV = O("progressService")
var UJ = Object.freeze({ total() {}, worked() {}, done() {} }),
	xa = class {
		constructor(e) {
			this.callback = e
		}
		static {
			this.None = Object.freeze({ report() {} })
		}
		get value() {
			return this._value
		}
		report(e) {
			;(this._value = e), this.callback(this._value)
		}
	}
var Bb = class extends $ {
	constructor(t, n) {
		super()
		this.deferred = new Cn()
		n.withProgress(t, (r) => ((this.reporter = r), this.lastStep && r.report(this.lastStep), this.deferred.p)),
			this._register(q(() => this.deferred.complete()))
	}
	report(t) {
		this.reporter ? this.reporter.report(t) : (this.lastStep = t)
	}
}
Bb = R([S(1, nV)], Bb)
var HJ = O("editorProgressService")
var UP = class {
		constructor() {
			this.data = new Map()
		}
		add(e, t) {
			yn(we(e)),
				yn(dt(t)),
				yn(!this.data.has(e), "There is already an extension with this id"),
				this.data.set(e, t)
		}
		knows(e) {
			return this.data.has(e)
		}
		as(e) {
			return this.data.get(e) || null
		}
	},
	yt = new UP()
var HP = class extends $ {
	constructor(t, n = "", r = "", i = !0, s) {
		super()
		this._onDidChange = this._register(new E())
		this.onDidChange = this._onDidChange.event
		this._enabled = !0
		;(this._id = t), (this._label = n), (this._cssClass = r), (this._enabled = i), (this._actionCallback = s)
	}
	get id() {
		return this._id
	}
	get label() {
		return this._label
	}
	set label(t) {
		this._setLabel(t)
	}
	_setLabel(t) {
		this._label !== t && ((this._label = t), this._onDidChange.fire({ label: t }))
	}
	get tooltip() {
		return this._tooltip || ""
	}
	set tooltip(t) {
		this._setTooltip(t)
	}
	_setTooltip(t) {
		this._tooltip !== t && ((this._tooltip = t), this._onDidChange.fire({ tooltip: t }))
	}
	get class() {
		return this._cssClass
	}
	set class(t) {
		this._setClass(t)
	}
	_setClass(t) {
		this._cssClass !== t && ((this._cssClass = t), this._onDidChange.fire({ class: t }))
	}
	get enabled() {
		return this._enabled
	}
	set enabled(t) {
		this._setEnabled(t)
	}
	_setEnabled(t) {
		this._enabled !== t && ((this._enabled = t), this._onDidChange.fire({ enabled: t }))
	}
	get checked() {
		return this._checked
	}
	set checked(t) {
		this._setChecked(t)
	}
	_setChecked(t) {
		this._checked !== t && ((this._checked = t), this._onDidChange.fire({ checked: t }))
	}
	async run(t, n) {
		this._actionCallback && (await this._actionCallback(t))
	}
}
var tM = class o {
	constructor() {
		this.id = o.ID
		this.label = ""
		this.tooltip = ""
		this.class = "separator"
		this.enabled = !1
		this.checked = !1
	}
	static join(...e) {
		let t = []
		for (let n of e) n.length && (t.length ? (t = [...t, new o(), ...n]) : (t = n))
		return t
	}
	static {
		this.ID = "vs.actions.separator"
	}
	async run() {}
}
var nM = class o extends HP {
	static {
		this.ID = "vs.actions.empty"
	}
	constructor() {
		super(o.ID, p("submenu.empty", "(empty)"), void 0, !1)
	}
}
var rV = {
		EditorPane: "workbench.contributions.editors",
		EditorFactory: "workbench.contributions.editor.inputFactories",
	},
	qP = {
		id: "default",
		displayName: p("promptOpenWith.defaultEditor.displayName", "Text Editor"),
		providerDisplayName: p("builtinProviderDisplayName", "Built-in"),
	}
function zb(o) {
	if (fs(o)) return !1
	let e = o
	return e?.original !== void 0 && e.modified !== void 0
}
function rM(o) {
	if (fs(o)) return !1
	let e = o
	return !e || (e.resources && !Array.isArray(e.resources)) ? !1 : !!e.resources || !!e.multiDiffSource
}
function WP(o) {
	if (fs(o) || zb(o)) return !1
	let e = o
	return e?.primary !== void 0 && e.secondary !== void 0
}
function $b(o) {
	if (fs(o)) return !1
	let e = o
	return (
		b.isUri(e?.base?.resource) &&
		b.isUri(e?.input1?.resource) &&
		b.isUri(e?.input2?.resource) &&
		b.isUri(e?.result?.resource)
	)
}
var VP = class {
		constructor() {
			this.mapIdToSaveSource = new Map()
		}
		registerSource(e, t) {
			let n = this.mapIdToSaveSource.get(e)
			return n || ((n = { source: e, label: t }), this.mapIdToSaveSource.set(e, n)), n.source
		}
		getSourceLabel(e) {
			return this.mapIdToSaveSource.get(e)?.label ?? e
		}
	},
	hX = new VP()
var BP = class extends $ {}
function fs(o) {
	return o instanceof BP
}
function oV(o) {
	let e = o
	return b.isUri(e?.preferredResource)
}
function iV(o) {
	let e = o
	return fs(e?.primary) && fs(e?.secondary)
}
function sV(o) {
	let e = o
	return fs(e?.modified) && fs(e?.original)
}
var $P = class {
	getOriginalUri(e, t) {
		if (!e) return
		if ($b(e)) return oM.getOriginalUri(e.result, t)
		if (t?.supportSideBySide) {
			let { primary: r, secondary: i } = this.getSideEditors(e)
			if (r && i) {
				if (t?.supportSideBySide === 3)
					return {
						primary: this.getOriginalUri(r, { filterByScheme: t.filterByScheme }),
						secondary: this.getOriginalUri(i, { filterByScheme: t.filterByScheme }),
					}
				if (t?.supportSideBySide === 4)
					return (
						this.getOriginalUri(r, { filterByScheme: t.filterByScheme }) ??
						this.getOriginalUri(i, { filterByScheme: t.filterByScheme })
					)
				e = t.supportSideBySide === 1 ? r : i
			}
		}
		if (zb(e) || rM(e) || WP(e) || $b(e)) return
		let n = oV(e) ? e.preferredResource : e.resource
		return !n || !t || !t.filterByScheme ? n : this.filterUri(n, t.filterByScheme)
	}
	getSideEditors(e) {
		return iV(e) || WP(e)
			? { primary: e.primary, secondary: e.secondary }
			: sV(e) || zb(e)
				? { primary: e.modified, secondary: e.original }
				: { primary: void 0, secondary: void 0 }
	}
	getCanonicalUri(e, t) {
		if (!e) return
		if ($b(e)) return oM.getCanonicalUri(e.result, t)
		if (t?.supportSideBySide) {
			let { primary: r, secondary: i } = this.getSideEditors(e)
			if (r && i) {
				if (t?.supportSideBySide === 3)
					return {
						primary: this.getCanonicalUri(r, { filterByScheme: t.filterByScheme }),
						secondary: this.getCanonicalUri(i, { filterByScheme: t.filterByScheme }),
					}
				if (t?.supportSideBySide === 4)
					return (
						this.getCanonicalUri(r, { filterByScheme: t.filterByScheme }) ??
						this.getCanonicalUri(i, { filterByScheme: t.filterByScheme })
					)
				e = t.supportSideBySide === 1 ? r : i
			}
		}
		if (zb(e) || rM(e) || WP(e) || $b(e)) return
		let n = e.resource
		return !n || !t || !t.filterByScheme ? n : this.filterUri(n, t.filterByScheme)
	}
	filterUri(e, t) {
		if (Array.isArray(t)) {
			if (t.some((n) => e.scheme === n)) return e
		} else if (t === e.scheme) return e
	}
}
var oM = new $P()
var zP = class {
	constructor() {
		this.editorSerializerConstructors = new Map()
		this.editorSerializerInstances = new Map()
	}
	start(e) {
		let t = (this.instantiationService = e.get(Wo))
		for (let [n, r] of this.editorSerializerConstructors) this.createEditorSerializer(n, r, t)
		this.editorSerializerConstructors.clear()
	}
	createEditorSerializer(e, t, n) {
		let r = n.createInstance(t)
		this.editorSerializerInstances.set(e, r)
	}
	registerFileEditorFactory(e) {
		if (this.fileEditorFactory) throw new Error("Can only register one file editor factory.")
		this.fileEditorFactory = e
	}
	getFileEditorFactory() {
		return Ro(this.fileEditorFactory)
	}
	registerEditorSerializer(e, t) {
		if (this.editorSerializerConstructors.has(e) || this.editorSerializerInstances.has(e))
			throw new Error(`A editor serializer with type ID '${e}' was already registered.`)
		return (
			this.instantiationService
				? this.createEditorSerializer(e, t, this.instantiationService)
				: this.editorSerializerConstructors.set(e, t),
			q(() => {
				this.editorSerializerConstructors.delete(e), this.editorSerializerInstances.delete(e)
			})
		)
	}
	getEditorSerializer(e) {
		return this.editorSerializerInstances.get(typeof e == "string" ? e : e.typeId)
	}
}
yt.add(rV.EditorFactory, new zP())
var Jr = class {
		constructor(e, t, n) {
			this.owner = e
			this.debugNameSource = t
			this.referenceFn = n
		}
		getDebugName(e) {
			return lM(e, this)
		}
	},
	iM = new Map(),
	KP = new WeakMap()
function lM(o, e) {
	let t = KP.get(o)
	if (t) return t
	let n = aV(o, e)
	if (n) {
		let r = iM.get(n) ?? 0
		r++, iM.set(n, r)
		let i = r === 1 ? n : `${n}#${r}`
		return KP.set(o, i), i
	}
}
function aV(o, e) {
	let t = KP.get(o)
	if (t) return t
	let n = e.owner ? dV(e.owner) + "." : "",
		r,
		i = e.debugNameSource
	if (i !== void 0)
		if (typeof i == "function") {
			if (((r = i()), r !== void 0)) return n + r
		} else return n + i
	let s = e.referenceFn
	if (s !== void 0 && ((r = qb(s)), r !== void 0)) return n + r
	if (e.owner !== void 0) {
		let a = lV(e.owner, o)
		if (a !== void 0) return n + a
	}
}
function lV(o, e) {
	for (let t in o) if (o[t] === e) return t
}
var sM = new Map(),
	aM = new WeakMap()
function dV(o) {
	let e = aM.get(o)
	if (e) return e
	let t = jP(o) ?? "Object",
		n = sM.get(t) ?? 0
	n++, sM.set(t, n)
	let r = n === 1 ? t : `${t}#${n}`
	return aM.set(o, r), r
}
function jP(o) {
	let e = o.constructor
	if (e) return e.name === "Object" ? void 0 : e.name
}
function qb(o) {
	let e = o.toString(),
		n = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e)
	return (n ? n[1] : void 0)?.trim()
}
var gs = (o, e) => o === e
function Kb(o, e) {
	if (o === e) return !0
	if (Array.isArray(o) && Array.isArray(e)) {
		if (o.length !== e.length) return !1
		for (let t = 0; t < o.length; t++) if (!Kb(o[t], e[t])) return !1
		return !0
	}
	if (
		o &&
		typeof o == "object" &&
		e &&
		typeof e == "object" &&
		Object.getPrototypeOf(o) === Object.prototype &&
		Object.getPrototypeOf(e) === Object.prototype
	) {
		let t = o,
			n = e,
			r = Object.keys(t),
			i = Object.keys(n),
			s = new Set(i)
		if (r.length !== i.length) return !1
		for (let a of r) if (!s.has(a) || !Kb(t[a], n[a])) return !1
		return !0
	}
	return !1
}
var nd
function Yf(o) {
	nd ? (nd instanceof jb ? nd.loggers.push(o) : (nd = new jb([nd, o]))) : (nd = o)
}
function Zt() {
	return nd
}
var GP
function dM(o) {
	GP = o
}
function cM(o) {
	GP && GP(o)
}
var jb = class {
	constructor(e) {
		this.loggers = e
	}
	handleObservableCreated(e) {
		for (let t of this.loggers) t.handleObservableCreated(e)
	}
	handleOnListenerCountChanged(e, t) {
		for (let n of this.loggers) n.handleOnListenerCountChanged(e, t)
	}
	handleObservableUpdated(e, t) {
		for (let n of this.loggers) n.handleObservableUpdated(e, t)
	}
	handleAutorunCreated(e) {
		for (let t of this.loggers) t.handleAutorunCreated(e)
	}
	handleAutorunDisposed(e) {
		for (let t of this.loggers) t.handleAutorunDisposed(e)
	}
	handleAutorunDependencyChanged(e, t, n) {
		for (let r of this.loggers) r.handleAutorunDependencyChanged(e, t, n)
	}
	handleAutorunStarted(e) {
		for (let t of this.loggers) t.handleAutorunStarted(e)
	}
	handleAutorunFinished(e) {
		for (let t of this.loggers) t.handleAutorunFinished(e)
	}
	handleDerivedDependencyChanged(e, t, n) {
		for (let r of this.loggers) r.handleDerivedDependencyChanged(e, t, n)
	}
	handleDerivedCleared(e) {
		for (let t of this.loggers) t.handleDerivedCleared(e)
	}
	handleBeginTransaction(e) {
		for (let t of this.loggers) t.handleBeginTransaction(e)
	}
	handleEndTransaction(e) {
		for (let t of this.loggers) t.handleEndTransaction(e)
	}
}
var pM
function mM(o) {
	pM = o
}
var fM
function gM(o) {
	fM = o
}
var QP
function hM(o) {
	QP = o
}
var Gb = class {
		get TChange() {
			return null
		}
		reportChanges() {
			this.get()
		}
		read(e) {
			return e ? e.readObservable(this) : this.get()
		}
		map(e, t) {
			let n = t === void 0 ? void 0 : e,
				r = t === void 0 ? e : t
			return QP(
				{
					owner: n,
					debugName: () => {
						let i = qb(r)
						if (i !== void 0) return i
						let a =
							/^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(
								r.toString(),
							)
						if (a) return `${this.debugName}.${a[2]}`
						if (!n) return `${this.debugName} (mapped)`
					},
					debugReferenceFn: r,
				},
				(i) => r(this.read(i), i),
			)
		}
		flatten() {
			return QP({ owner: void 0, debugName: () => `${this.debugName} (flattened)` }, (e) => this.read(e).read(e))
		}
		recomputeInitiallyAndOnChange(e, t) {
			return e.add(pM(this, t)), this
		}
		keepObserved(e) {
			return e.add(fM(this)), this
		}
		get debugValue() {
			return this.get()
		}
	},
	Ca = class extends Gb {
		constructor() {
			super()
			this._observers = new Set()
			Zt()?.handleObservableCreated(this)
		}
		addObserver(t) {
			let n = this._observers.size
			this._observers.add(t),
				n === 0 && this.onFirstObserverAdded(),
				n !== this._observers.size && Zt()?.handleOnListenerCountChanged(this, this._observers.size)
		}
		removeObserver(t) {
			let n = this._observers.delete(t)
			n && this._observers.size === 0 && this.onLastObserverRemoved(),
				n && Zt()?.handleOnListenerCountChanged(this, this._observers.size)
		}
		onFirstObserverAdded() {}
		onLastObserverRemoved() {}
		log() {
			let t = !!Zt()
			return cM(this), t || Zt()?.handleObservableCreated(this), this
		}
		debugGetObservers() {
			return this._observers
		}
	}
function od(o, e) {
	let t = new Jc(o, e)
	try {
		o(t)
	} finally {
		t.finish()
	}
}
function JP(o, e, t) {
	o ? e(o) : od(e, t)
}
var Jc = class {
	constructor(e, t) {
		this._fn = e
		this._getDebugName = t
		this._updatingObservers = []
		Zt()?.handleBeginTransaction(this)
	}
	getDebugName() {
		return this._getDebugName ? this._getDebugName() : qb(this._fn)
	}
	updateObserver(e, t) {
		if (!this._updatingObservers) {
			uM("Transaction already finished!"),
				od((n) => {
					n.updateObserver(e, t)
				})
			return
		}
		this._updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t)
	}
	finish() {
		let e = this._updatingObservers
		if (!e) {
			uM("transaction.finish() has already been called!")
			return
		}
		for (let t = 0; t < e.length; t++) {
			let { observer: n, observable: r } = e[t]
			n.endUpdate(r)
		}
		;(this._updatingObservers = null), Zt()?.handleEndTransaction(this)
	}
	debugGetUpdatingObservers() {
		return this._updatingObservers
	}
}
function uM(o) {
	let e = new Error("BugIndicatingErrorRecovery: " + o)
	Be(e), console.error("recovered from an error that indicates a bug", e)
}
function Sa(o, e) {
	let t
	return typeof o == "string" ? (t = new Jr(void 0, o, void 0)) : (t = new Jr(o, void 0, void 0)), new rd(t, e, gs)
}
var rd = class extends Ca {
	constructor(t, n, r) {
		super()
		this._debugNameData = t
		this._equalityComparator = r
		;(this._value = n),
			Zt()?.handleObservableUpdated(this, {
				hadValue: !1,
				newValue: n,
				change: void 0,
				didChange: !0,
				oldValue: void 0,
			})
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "ObservableValue"
	}
	get() {
		return this._value
	}
	set(t, n, r) {
		if (r === void 0 && this._equalityComparator(this._value, t)) return
		let i
		n ||
			(n = i =
				new Jc(
					() => {},
					() => `Setting ${this.debugName}`,
				))
		try {
			let s = this._value
			this._setValue(t),
				Zt()?.handleObservableUpdated(this, {
					oldValue: s,
					newValue: t,
					change: r,
					didChange: !0,
					hadValue: !0,
				})
			for (let a of this._observers) n.updateObserver(a, this), a.handleChange(this, r)
		} finally {
			i && i.finish()
		}
	}
	toString() {
		return `${this.debugName}: ${this._value}`
	}
	_setValue(t) {
		this._value = t
	}
	debugGetState() {
		return { value: this._value }
	}
	debugSetValue(t) {
		this._value = t
	}
}
function id(o) {
	return new Xc(new Jr(void 0, void 0, o), o, void 0)
}
var Xc = class {
	constructor(e, t, n) {
		this._debugNameData = e
		this._runFn = t
		this._changeTracker = n
		this._state = 2
		this._updateCount = 0
		this._disposed = !1
		this._dependencies = new Set()
		this._dependenciesToBeRemoved = new Set()
		this._isRunning = !1
		;(this._changeSummary = this._changeTracker?.createChangeSummary(void 0)),
			Zt()?.handleAutorunCreated(this),
			this._run(),
			oa(this)
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "(anonymous)"
	}
	dispose() {
		if (!this._disposed) {
			this._disposed = !0
			for (let e of this._dependencies) e.removeObserver(this)
			this._dependencies.clear(), Zt()?.handleAutorunDisposed(this), ia(this)
		}
	}
	_run() {
		let e = this._dependenciesToBeRemoved
		;(this._dependenciesToBeRemoved = this._dependencies), (this._dependencies = e), (this._state = 3)
		try {
			if (!this._disposed) {
				Zt()?.handleAutorunStarted(this)
				let t = this._changeSummary
				try {
					;(this._isRunning = !0),
						this._changeTracker &&
							(this._changeTracker.beforeUpdate?.(this, t),
							(this._changeSummary = this._changeTracker.createChangeSummary(t))),
						this._runFn(this, t)
				} catch (n) {
					kl(n)
				} finally {
					this._isRunning = !1
				}
			}
		} finally {
			this._disposed || Zt()?.handleAutorunFinished(this)
			for (let t of this._dependenciesToBeRemoved) t.removeObserver(this)
			this._dependenciesToBeRemoved.clear()
		}
	}
	toString() {
		return `Autorun<${this.debugName}>`
	}
	beginUpdate(e) {
		this._state === 3 && (this._state = 1), this._updateCount++
	}
	endUpdate(e) {
		try {
			if (this._updateCount === 1)
				do {
					if (this._state === 1) {
						this._state = 3
						for (let t of this._dependencies) if ((t.reportChanges(), this._state === 2)) break
					}
					this._state !== 3 && this._run()
				} while (this._state !== 3)
		} finally {
			this._updateCount--
		}
		of(() => this._updateCount >= 0)
	}
	handlePossibleChange(e) {
		this._state === 3 && this._isDependency(e) && (this._state = 1)
	}
	handleChange(e, t) {
		if (this._isDependency(e)) {
			Zt()?.handleAutorunDependencyChanged(this, e, t)
			try {
				;(this._changeTracker
					? this._changeTracker.handleChange(
							{ changedObservable: e, change: t, didChange: (r) => r === e },
							this._changeSummary,
						)
					: !0) && (this._state = 2)
			} catch (n) {
				kl(n)
			}
		}
	}
	_isDependency(e) {
		return this._dependencies.has(e) && !this._dependenciesToBeRemoved.has(e)
	}
	readObservable(e) {
		if (!this._isRunning) throw new Gt("The reader object cannot be used outside its compute function!")
		if (this._disposed) return e.get()
		e.addObserver(this)
		let t = e.get()
		return this._dependencies.add(e), this._dependenciesToBeRemoved.delete(e), t
	}
	debugGetState() {
		return {
			isRunning: this._isRunning,
			updateCount: this._updateCount,
			dependencies: this._dependencies,
			state: this._state,
		}
	}
	debugRerun() {
		this._isRunning ? (this._state = 2) : this._run()
	}
}
;((e) => (e.Observer = Xc))((id ||= {}))
function XP(o, e) {
	return new Mr(
		new Jr(o.owner, o.debugName, o.debugReferenceFn),
		e,
		void 0,
		o.onLastObserverRemoved,
		o.equalsFn ?? gs,
	)
}
hM(XP)
var Mr = class extends Ca {
	constructor(t, n, r, i = void 0, s) {
		super()
		this._debugNameData = t
		this._computeFn = n
		this._changeTracker = r
		this._handleLastObserverRemoved = i
		this._equalityComparator = s
		this._state = 0
		this._value = void 0
		this._updateCount = 0
		this._dependencies = new Set()
		this._dependenciesToBeRemoved = new Set()
		this._changeSummary = void 0
		this._isUpdating = !1
		this._isComputing = !1
		this._didReportChange = !1
		this._removedObserverToCallEndUpdateOn = null
		this._isReaderValid = !1
		this._changeSummary = this._changeTracker?.createChangeSummary(void 0)
	}
	get debugName() {
		return this._debugNameData.getDebugName(this) ?? "(anonymous)"
	}
	onLastObserverRemoved() {
		;(this._state = 0), (this._value = void 0), Zt()?.handleDerivedCleared(this)
		for (let t of this._dependencies) t.removeObserver(this)
		this._dependencies.clear(), this._handleLastObserverRemoved?.()
	}
	get() {
		if ((this._isComputing, this._observers.size === 0)) {
			let n
			try {
				this._isReaderValid = !0
				let r
				this._changeTracker &&
					((r = this._changeTracker.createChangeSummary(void 0)),
					this._changeTracker.beforeUpdate?.(this, r)),
					(n = this._computeFn(this, r))
			} finally {
				this._isReaderValid = !1
			}
			return this.onLastObserverRemoved(), n
		} else {
			do {
				if (this._state === 1) {
					for (let n of this._dependencies) if ((n.reportChanges(), this._state === 2)) break
				}
				this._state === 1 && (this._state = 3), this._state !== 3 && this._recompute()
			} while (this._state !== 3)
			return this._value
		}
	}
	_recompute() {
		let t = this._dependenciesToBeRemoved
		;(this._dependenciesToBeRemoved = this._dependencies), (this._dependencies = t)
		let n = this._state !== 0,
			r = this._value
		this._state = 3
		let i = !1
		;(this._isComputing = !0), (this._didReportChange = !1)
		try {
			let s = this._changeSummary
			try {
				;(this._isReaderValid = !0),
					this._changeTracker &&
						(this._changeTracker.beforeUpdate?.(this, s),
						(this._changeSummary = this._changeTracker?.createChangeSummary(s))),
					(this._value = this._computeFn(this, s))
			} finally {
				this._isReaderValid = !1
				for (let a of this._dependenciesToBeRemoved) a.removeObserver(this)
				this._dependenciesToBeRemoved.clear()
			}
			;(i = this._didReportChange || (n && !this._equalityComparator(r, this._value))),
				Zt()?.handleObservableUpdated(this, {
					oldValue: r,
					newValue: this._value,
					change: void 0,
					didChange: i,
					hadValue: n,
				})
		} catch (s) {
			kl(s)
		}
		if (((this._isComputing = !1), !this._didReportChange && i))
			for (let s of this._observers) s.handleChange(this, void 0)
		else this._didReportChange = !1
	}
	toString() {
		return `LazyDerived<${this.debugName}>`
	}
	beginUpdate(t) {
		if (this._isUpdating) throw new Gt("Cyclic deriveds are not supported yet!")
		this._updateCount++, (this._isUpdating = !0)
		try {
			let n = this._updateCount === 1
			if (this._state === 3 && ((this._state = 1), !n))
				for (let r of this._observers) r.handlePossibleChange(this)
			if (n) for (let r of this._observers) r.beginUpdate(this)
		} finally {
			this._isUpdating = !1
		}
	}
	endUpdate(t) {
		if ((this._updateCount--, this._updateCount === 0)) {
			let n = [...this._observers]
			for (let r of n) r.endUpdate(this)
			if (this._removedObserverToCallEndUpdateOn) {
				let r = [...this._removedObserverToCallEndUpdateOn]
				this._removedObserverToCallEndUpdateOn = null
				for (let i of r) i.endUpdate(this)
			}
		}
		of(() => this._updateCount >= 0)
	}
	handlePossibleChange(t) {
		if (this._state === 3 && this._dependencies.has(t) && !this._dependenciesToBeRemoved.has(t)) {
			this._state = 1
			for (let n of this._observers) n.handlePossibleChange(this)
		}
	}
	handleChange(t, n) {
		if (this._dependencies.has(t) && !this._dependenciesToBeRemoved.has(t)) {
			Zt()?.handleDerivedDependencyChanged(this, t, n)
			let r = !1
			try {
				r = this._changeTracker
					? this._changeTracker.handleChange(
							{ changedObservable: t, change: n, didChange: (s) => s === t },
							this._changeSummary,
						)
					: !0
			} catch (s) {
				kl(s)
			}
			let i = this._state === 3
			if (r && (this._state === 1 || i) && ((this._state = 2), i))
				for (let s of this._observers) s.handlePossibleChange(this)
		}
	}
	readObservable(t) {
		if (!this._isReaderValid) throw new Gt("The reader object cannot be used outside its compute function!")
		t.addObserver(this)
		let n = t.get()
		return this._dependencies.add(t), this._dependenciesToBeRemoved.delete(t), n
	}
	reportChange(t) {
		if (!this._isReaderValid) throw new Gt("The reader object cannot be used outside its compute function!")
		this._didReportChange = !0
		for (let n of this._observers) n.handleChange(this, t)
	}
	addObserver(t) {
		let n = !this._observers.has(t) && this._updateCount > 0
		super.addObserver(t),
			n &&
				(this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(t)
					? this._removedObserverToCallEndUpdateOn.delete(t)
					: t.beginUpdate(this))
	}
	removeObserver(t) {
		this._observers.has(t) &&
			this._updateCount > 0 &&
			(this._removedObserverToCallEndUpdateOn || (this._removedObserverToCallEndUpdateOn = new Set()),
			this._removedObserverToCallEndUpdateOn.add(t)),
			super.removeObserver(t)
	}
	debugGetState() {
		return {
			state: this._state,
			updateCount: this._updateCount,
			isComputing: this._isComputing,
			dependencies: this._dependencies,
			value: this._value,
		}
	}
	debugSetValue(t) {
		this._value = t
	}
	setValue(t, n, r) {
		this._value = t
		let i = this._observers
		n.updateObserver(this, this)
		for (let s of i) s.handleChange(this, r)
	}
}
var Zf = class o {
		constructor(e) {
			this._value = Sa(this, void 0)
			this.promiseResult = this._value
			this.promise = e.then(
				(t) => (
					od((n) => {
						this._value.set(new eg(t, void 0), n)
					}),
					t
				),
				(t) => {
					throw (
						(od((n) => {
							this._value.set(new eg(void 0, t), n)
						}),
						t)
					)
				},
			)
		}
		static fromFn(e) {
			return new o(e())
		}
	},
	eg = class {
		constructor(e, t) {
			this.data = e
			this.error = t
		}
		getDataOrThrow() {
			if (this.error) throw this.error
			return this.data
		}
	}
function YP(...o) {
	let e, t, n
	return (
		o.length === 3 ? ([e, t, n] = o) : ([t, n] = o),
		new hi(new Jr(e, void 0, n), t, n, () => hi.globalTransaction, gs)
	)
}
var hi = class extends Ca {
	constructor(t, n, r, i, s) {
		super()
		this._debugNameData = t
		this.event = n
		this._getValue = r
		this._getTransaction = i
		this._equalityComparator = s
		this._hasValue = !1
		this.handleEvent = (t) => {
			let n = this._getValue(t),
				r = this._value,
				i = !this._hasValue || !this._equalityComparator(r, n),
				s = !1
			i &&
				((this._value = n),
				this._hasValue &&
					((s = !0),
					JP(
						this._getTransaction(),
						(a) => {
							Zt()?.handleObservableUpdated(this, {
								oldValue: r,
								newValue: n,
								change: void 0,
								didChange: i,
								hadValue: this._hasValue,
							})
							for (let l of this._observers) a.updateObserver(l, this), l.handleChange(this, void 0)
						},
						() => {
							let a = this.getDebugName()
							return "Event fired" + (a ? `: ${a}` : "")
						},
					)),
				(this._hasValue = !0)),
				s ||
					Zt()?.handleObservableUpdated(this, {
						oldValue: r,
						newValue: n,
						change: void 0,
						didChange: i,
						hadValue: this._hasValue,
					})
		}
	}
	getDebugName() {
		return this._debugNameData.getDebugName(this)
	}
	get debugName() {
		let t = this.getDebugName()
		return "From Event" + (t ? `: ${t}` : "")
	}
	onFirstObserverAdded() {
		this._subscription = this.event(this.handleEvent)
	}
	onLastObserverRemoved() {
		this._subscription.dispose(), (this._subscription = void 0), (this._hasValue = !1), (this._value = void 0)
	}
	get() {
		return this._subscription ? (this._hasValue || this.handleEvent(void 0), this._value) : this._getValue(void 0)
	}
	debugSetValue(t) {
		this._value = t
	}
}
;((t) => {
	t.Observer = hi
	function e(n, r) {
		let i = !1
		hi.globalTransaction === void 0 && ((hi.globalTransaction = n), (i = !0))
		try {
			r()
		} finally {
			i && (hi.globalTransaction = void 0)
		}
	}
	t.batchEventsGlobally = e
})((YP ||= {}))
function bM(o) {
	let e = new Qb(!1, void 0)
	return (
		o.addObserver(e),
		q(() => {
			o.removeObserver(e)
		})
	)
}
gM(bM)
function yM(o, e) {
	let t = new Qb(!0, e)
	o.addObserver(t)
	try {
		t.beginUpdate(o)
	} finally {
		t.endUpdate(o)
	}
	return q(() => {
		o.removeObserver(t)
	})
}
mM(yM)
var Qb = class {
	constructor(e, t) {
		this._forceRecompute = e
		this._handleValue = t
		this._counter = 0
	}
	beginUpdate(e) {
		this._counter++
	}
	endUpdate(e) {
		this._counter === 1 &&
			this._forceRecompute &&
			(this._handleValue ? this._handleValue(e.get()) : e.reportChanges()),
			this._counter--
	}
	handlePossibleChange(e) {}
	handleChange(e, t) {}
}
var Jb
function IM(o) {
	Jb || ((Jb = new tg()), Yf(Jb)), Jb.addFilteredObj(o)
}
var tg = class {
	constructor() {
		this.indentation = 0
		this.changedObservablesSets = new WeakMap()
	}
	addFilteredObj(e) {
		this._filteredObjects || (this._filteredObjects = new Set()), this._filteredObjects.add(e)
	}
	_isIncluded(e) {
		return this._filteredObjects?.has(e) ?? !0
	}
	textToConsoleArgs(e) {
		return pV([Yc(gV("|  ", this.indentation)), e])
	}
	formatInfo(e) {
		return e.hadValue
			? e.didChange
				? [
						Yc(" "),
						fo(vi(e.oldValue, 70), { color: "red", strikeThrough: !0 }),
						Yc(" "),
						fo(vi(e.newValue, 60), { color: "green" }),
					]
				: [Yc(" (unchanged)")]
			: [Yc(" "), fo(vi(e.newValue, 60), { color: "green" }), Yc(" (initial)")]
	}
	handleObservableCreated(e) {
		if (e instanceof Mr) {
			let t = e
			if ((this.changedObservablesSets.set(t, new Set()), !1)) {
				let r = []
				t.__debugUpdating = r
				let i = t.beginUpdate
				t.beginUpdate = (a) => (r.push(a), i.apply(t, [a]))
				let s = t.endUpdate
				t.endUpdate = (a) => {
					let l = r.indexOf(a)
					return (
						l === -1 && console.error("endUpdate called without beginUpdate", t.debugName, a.debugName),
						r.splice(l, 1),
						s.apply(t, [a])
					)
				}
			}
		}
	}
	handleOnListenerCountChanged(e, t) {}
	handleObservableUpdated(e, t) {
		if (this._isIncluded(e)) {
			if (e instanceof Mr) {
				this._handleDerivedRecomputed(e, t)
				return
			}
			console.log(
				...this.textToConsoleArgs([
					Zc("observable value changed"),
					fo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
				]),
			)
		}
	}
	formatChanges(e) {
		if (e.size !== 0)
			return fo(" (changed deps: " + [...e].map((t) => t.debugName).join(", ") + ")", { color: "gray" })
	}
	handleDerivedDependencyChanged(e, t, n) {
		this._isIncluded(e) && this.changedObservablesSets.get(e)?.add(t)
	}
	_handleDerivedRecomputed(e, t) {
		if (!this._isIncluded(e)) return
		let n = this.changedObservablesSets.get(e)
		n &&
			(console.log(
				...this.textToConsoleArgs([
					Zc("derived recomputed"),
					fo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
					this.formatChanges(n),
					{ data: [{ fn: e._debugNameData.referenceFn ?? e._computeFn }] },
				]),
			),
			n.clear())
	}
	handleDerivedCleared(e) {
		this._isIncluded(e) &&
			console.log(...this.textToConsoleArgs([Zc("derived cleared"), fo(e.debugName, { color: "BlueViolet" })]))
	}
	handleFromEventObservableTriggered(e, t) {
		this._isIncluded(e) &&
			console.log(
				...this.textToConsoleArgs([
					Zc("observable from event triggered"),
					fo(e.debugName, { color: "BlueViolet" }),
					...this.formatInfo(t),
					{ data: [{ fn: e._getValue }] },
				]),
			)
	}
	handleAutorunCreated(e) {
		this._isIncluded(e) && this.changedObservablesSets.set(e, new Set())
	}
	handleAutorunDisposed(e) {}
	handleAutorunDependencyChanged(e, t, n) {
		this._isIncluded(e) && this.changedObservablesSets.get(e).add(t)
	}
	handleAutorunStarted(e) {
		let t = this.changedObservablesSets.get(e)
		t &&
			(this._isIncluded(e) &&
				console.log(
					...this.textToConsoleArgs([
						Zc("autorun"),
						fo(e.debugName, { color: "BlueViolet" }),
						this.formatChanges(t),
						{ data: [{ fn: e._debugNameData.referenceFn ?? e._runFn }] },
					]),
				),
			t.clear(),
			this.indentation++)
	}
	handleAutorunFinished(e) {
		this.indentation--
	}
	handleBeginTransaction(e) {
		let t = e.getDebugName()
		t === void 0 && (t = ""),
			this._isIncluded(e) &&
				console.log(
					...this.textToConsoleArgs([
						Zc("transaction"),
						fo(t, { color: "BlueViolet" }),
						{ data: [{ fn: e._fn }] },
					]),
				),
			this.indentation++
	}
	handleEndTransaction() {
		this.indentation--
	}
}
function pV(o) {
	let e = new Array(),
		t = [],
		n = ""
	function r(s) {
		if ("length" in s) for (let a of s) a && r(a)
		else
			"text" in s
				? ((n += `%c${s.text}`), e.push(s.style), s.data && t.push(...s.data))
				: "data" in s && t.push(...s.data)
	}
	r(o)
	let i = [n, ...e]
	return i.push(...t), i
}
function Yc(o) {
	return fo(o, { color: "black" })
}
function Zc(o) {
	return fo(hV(`${o}: `, 10), { color: "black", bold: !0 })
}
function fo(o, e = { color: "black" }) {
	function t(r) {
		return Object.entries(r).reduce((i, [s, a]) => `${i}${s}:${a};`, "")
	}
	let n = { color: e.color }
	return (
		e.strikeThrough && (n["text-decoration"] = "line-through"),
		e.bold && (n["font-weight"] = "bold"),
		{ text: o, style: t(n) }
	)
}
function vi(o, e) {
	switch (typeof o) {
		case "number":
			return "" + o
		case "string":
			return o.length + 2 <= e ? `"${o}"` : `"${o.substr(0, e - 7)}"+...`
		case "boolean":
			return o ? "true" : "false"
		case "undefined":
			return "undefined"
		case "object":
			return o === null ? "null" : Array.isArray(o) ? mV(o, e) : fV(o, e)
		case "symbol":
			return o.toString()
		case "function":
			return `[[Function${o.name ? " " + o.name : ""}]]`
		default:
			return "" + o
	}
}
function mV(o, e) {
	let t = "[ ",
		n = !0
	for (let r of o) {
		if ((n || (t += ", "), t.length - 5 > e)) {
			t += "..."
			break
		}
		;(n = !1), (t += `${vi(r, e - t.length)}`)
	}
	return (t += " ]"), t
}
function fV(o, e) {
	if (typeof o.toString == "function" && o.toString !== Object.prototype.toString) {
		let i = o.toString()
		return i.length <= e ? i : i.substring(0, e - 3) + "..."
	}
	let t = jP(o),
		n = t ? t + "(" : "{ ",
		r = !0
	for (let [i, s] of Object.entries(o)) {
		if ((r || (n += ", "), n.length - 5 > e)) {
			n += "..."
			break
		}
		;(r = !1), (n += `${i}: ${vi(s, e - n.length)}`)
	}
	return (n += t ? ")" : " }"), n
}
function gV(o, e) {
	let t = ""
	for (let n = 1; n <= e; n++) t += o
	return t
}
function hV(o, e) {
	for (; o.length < e; ) o += " "
	return o
}
var Xb = class o {
	constructor(e, t) {
		this._channelFactory = e
		this._getHandler = t
		this._channel = this._channelFactory({
			handleNotification: (i) => {
				let s = i,
					a = this._getHandler().notifications[s[0]]
				if (!a) throw new Error(`Unknown notification "${s[0]}"!`)
				a(...s[1])
			},
			handleRequest: (i) => {
				let s = i
				try {
					return { type: "result", value: this._getHandler().requests[s[0]](...s[1]) }
				} catch (a) {
					return { type: "error", value: a }
				}
			},
		})
		let n = new Proxy(
				{},
				{
					get:
						(i, s) =>
						async (...a) => {
							let l = await this._channel.sendRequest([s, a])
							if (l.type === "error") throw l.value
							return l.value
						},
				},
			),
			r = new Proxy(
				{},
				{
					get:
						(i, s) =>
						(...a) => {
							this._channel.sendNotification([s, a])
						},
				},
			)
		this.api = { notifications: r, requests: n }
	}
	static createHost(e, t) {
		return new o(e, t)
	}
	static createClient(e, t) {
		return new o(e, t)
	}
}
function xM(o, e) {
	let t = globalThis,
		n = [],
		r,
		{ channel: i, handler: s } = vV({
			sendNotification: (l) => {
				r ? r.sendNotification(l) : n.push(l)
			},
		}),
		a
	return (
		((t.$$debugValueEditor_debugChannels ?? (t.$$debugValueEditor_debugChannels = {}))[o] = (l) => {
			;(a = e()), (r = l)
			for (let d of n) l.sendNotification(d)
			return (n = []), s
		}),
		Xb.createClient(i, () => {
			if (!a) throw new Error("Not supported")
			return a
		})
	)
}
function vV(o) {
	let e
	return {
		channel: (n) => (
			(e = n),
			{
				sendNotification: (r) => {
					o.sendNotification(r)
				},
				sendRequest: (r) => {
					throw new Error("not supported")
				},
			}
		),
		handler: {
			handleRequest: (n) =>
				n.type === "notification" ? e?.handleNotification(n.data) : e?.handleRequest(n.data),
		},
	}
}
function ZP(o, e) {
	let t = o.split(`
`),
		n = -1
	for (let r of t.slice(1)) {
		if ((n++, e && e.test(r))) continue
		let i = bV(r)
		if (i) return i
	}
}
function bV(o) {
	let e = o.match(/\((.*):(\d+):(\d+)\)/)
	if (e) return { fileName: e[1], line: parseInt(e[2]), column: parseInt(e[3]), id: o }
	let t = o.match(/at ([^\(\)]*):(\d+):(\d+)/)
	if (t) return { fileName: t[1], line: parseInt(t[2]), column: parseInt(t[3]), id: o }
}
var Yb = class {
	constructor() {
		this._timeout = void 0
	}
	throttle(e, t) {
		this._timeout === void 0 &&
			(this._timeout = setTimeout(() => {
				;(this._timeout = void 0), e()
			}, t))
	}
	dispose() {
		this._timeout !== void 0 && clearTimeout(this._timeout)
	}
}
function e_(o, e) {
	for (let t in e) o[t] && typeof o[t] == "object" && e[t] && typeof e[t] == "object" ? e_(o[t], e[t]) : (o[t] = e[t])
}
function t_(o, e) {
	for (let t in e)
		e[t] === null
			? delete o[t]
			: o[t] && typeof o[t] == "object" && e[t] && typeof e[t] == "object"
				? t_(o[t], e[t])
				: (o[t] = e[t])
}
var Zb = class o {
	constructor() {
		this._declarationId = 0
		this._instanceId = 0
		this._declarations = new Map()
		this._instanceInfos = new WeakMap()
		this._aliveInstances = new Map()
		this._activeTransactions = new Set()
		this._channel = xM("observableDevTools", () => ({
			notifications: {
				setDeclarationIdFilter: (e) => {},
				logObservableValue: (e) => {
					console.log("logObservableValue", e)
				},
				flushUpdates: () => {
					this._flushUpdates()
				},
				resetUpdates: () => {
					;(this._pendingChanges = null), this._channel.api.notifications.handleChange(this._fullState, !0)
				},
			},
			requests: {
				getDeclarations: () => {
					let e = {}
					for (let t of this._declarations.values()) e[t.id] = t
					return { decls: e }
				},
				getSummarizedInstances: () => null,
				getObservableValueInfo: (e) => ({
					observers: [...this._aliveInstances.get(e).debugGetObservers()]
						.map((n) => this._formatObserver(n))
						.filter(or),
				}),
				getDerivedInfo: (e) => {
					let t = this._aliveInstances.get(e)
					return {
						dependencies: [...t.debugGetState().dependencies]
							.map((n) => this._formatObservable(n))
							.filter(or),
						observers: [...t.debugGetObservers()].map((n) => this._formatObserver(n)).filter(or),
					}
				},
				getAutorunInfo: (e) => ({
					dependencies: [...this._aliveInstances.get(e).debugGetState().dependencies]
						.map((n) => this._formatObservable(n))
						.filter(or),
				}),
				getTransactionState: () => this.getTransactionState(),
				setValue: (e, t) => {
					let n = this._aliveInstances.get(e)
					if (n instanceof Mr) n.debugSetValue(t)
					else if (n instanceof rd) n.debugSetValue(t)
					else if (n instanceof hi) n.debugSetValue(t)
					else throw new Gt("Observable is not supported")
					let r = [...n.debugGetObservers()]
					for (let i of r) i.beginUpdate(n)
					for (let i of r) i.handleChange(n, void 0)
					for (let i of r) i.endUpdate(n)
				},
				getValue: (e) => {
					let t = this._aliveInstances.get(e)
					if (t instanceof Mr) return vi(t.debugGetState().value, 200)
					if (t instanceof rd) return vi(t.debugGetState().value, 200)
				},
			},
		}))
		this._pendingChanges = null
		this._changeThrottler = new Yb()
		this._fullState = {}
		this._flushUpdates = () => {
			this._pendingChanges !== null &&
				(this._channel.api.notifications.handleChange(this._pendingChanges, !1), (this._pendingChanges = null))
		}
	}
	static {
		this._instance = void 0
	}
	static getInstance() {
		return o._instance === void 0 && (o._instance = new o()), o._instance
	}
	getTransactionState() {
		let e = [],
			t = [...this._activeTransactions]
		if (t.length === 0) return
		let n = t.flatMap((i) => i.debugGetUpdatingObservers() ?? []).map((i) => i.observer),
			r = new Set()
		for (; n.length > 0; ) {
			let i = n.shift()
			if (r.has(i)) continue
			r.add(i)
			let s = this._getInfo(i, (a) => {
				r.has(a) || n.push(a)
			})
			s && e.push(s)
		}
		return { names: t.map((i) => i.getDebugName() ?? "tx"), affected: e }
	}
	_getObservableInfo(e) {
		let t = this._instanceInfos.get(e)
		if (!t) {
			Be(new Gt("No info found"))
			return
		}
		return t
	}
	_getAutorunInfo(e) {
		let t = this._instanceInfos.get(e)
		if (!t) {
			Be(new Gt("No info found"))
			return
		}
		return t
	}
	_getInfo(e, t) {
		if (e instanceof Mr) {
			let n = [...e.debugGetObservers()]
			for (let l of n) t(l)
			let r = this._getObservableInfo(e)
			if (!r) return
			let i = e.debugGetState(),
				s = { name: e.debugName, instanceId: r.instanceId, updateCount: i.updateCount },
				a = [...r.changedObservables].map((l) => this._instanceInfos.get(l)?.instanceId).filter(or)
			if (i.isComputing)
				return {
					...s,
					type: "observable/derived",
					state: "updating",
					changedDependencies: a,
					initialComputation: !1,
				}
			switch (i.state) {
				case 0:
					return { ...s, type: "observable/derived", state: "noValue" }
				case 3:
					return { ...s, type: "observable/derived", state: "upToDate" }
				case 2:
					return { ...s, type: "observable/derived", state: "stale", changedDependencies: a }
				case 1:
					return { ...s, type: "observable/derived", state: "possiblyStale" }
			}
		} else if (e instanceof Xc) {
			let n = this._getAutorunInfo(e)
			if (!n) return
			let r = { name: e.debugName, instanceId: n.instanceId, updateCount: n.updateCount },
				i = [...n.changedObservables].map((s) => this._instanceInfos.get(s).instanceId)
			if (e.debugGetState().isRunning) return { ...r, type: "autorun", state: "updating", changedDependencies: i }
			switch (e.debugGetState().state) {
				case 3:
					return { ...r, type: "autorun", state: "upToDate" }
				case 2:
					return { ...r, type: "autorun", state: "stale", changedDependencies: i }
				case 1:
					return { ...r, type: "autorun", state: "possiblyStale" }
			}
		}
	}
	_formatObservable(e) {
		let t = this._getObservableInfo(e)
		if (t) return { name: e.debugName, instanceId: t.instanceId }
	}
	_formatObserver(e) {
		if (e instanceof Mr) return { name: e.toString(), instanceId: this._getObservableInfo(e)?.instanceId }
		let t = this._getAutorunInfo(e)
		if (t) return { name: e.toString(), instanceId: t.instanceId }
	}
	_handleChange(e) {
		t_(this._fullState, e),
			this._pendingChanges === null ? (this._pendingChanges = e) : e_(this._pendingChanges, e),
			this._changeThrottler.throttle(this._flushUpdates, 10)
	}
	_getDeclarationId(e) {
		let t = !0,
			n,
			r = Error
		for (;;) {
			let s = r.stackTraceLimit
			r.stackTraceLimit = t ? 6 : 20
			let a = new Error().stack
			r.stackTraceLimit = s
			let l = ZP(a, /[/\\]observableInternal[/\\]|\.observe|[/\\]util(s)?\./)
			if ((!t && !l && (l = ZP(a, /[/\\]observableInternal[/\\]|\.observe/)), l)) {
				n = l
				break
			}
			if (!t) {
				console.error("Could not find location for declaration", new Error().stack),
					(n = { fileName: "unknown", line: 0, column: 0, id: "unknown" })
				break
			}
			t = !1
		}
		let i = this._declarations.get(n.id)
		return (
			i === void 0 &&
				((i = { id: this._declarationId++, type: e, url: n.fileName, line: n.line, column: n.column }),
				this._declarations.set(n.id, i),
				this._handleChange({ decls: { [i.id]: i } })),
			i.id
		)
	}
	handleObservableCreated(e) {
		let n = {
			declarationId: this._getDeclarationId("observable/value"),
			instanceId: this._instanceId++,
			listenerCount: 0,
			lastValue: void 0,
			updateCount: 0,
			changedObservables: new Set(),
		}
		this._instanceInfos.set(e, n)
	}
	handleOnListenerCountChanged(e, t) {
		let n = this._getObservableInfo(e)
		if (n) {
			if (n.listenerCount === 0 && t > 0) {
				let r = e instanceof Mr ? "observable/derived" : "observable/value"
				this._aliveInstances.set(n.instanceId, e),
					this._handleChange({
						instances: {
							[n.instanceId]: {
								instanceId: n.instanceId,
								declarationId: n.declarationId,
								formattedValue: n.lastValue,
								type: r,
								name: e.debugName,
							},
						},
					})
			} else
				n.listenerCount > 0 &&
					t === 0 &&
					(this._handleChange({ instances: { [n.instanceId]: null } }),
					this._aliveInstances.delete(n.instanceId))
			n.listenerCount = t
		}
	}
	handleObservableUpdated(e, t) {
		if (e instanceof Mr) {
			this._handleDerivedRecomputed(e, t)
			return
		}
		let n = this._getObservableInfo(e)
		n &&
			t.didChange &&
			((n.lastValue = vi(t.newValue, 30)),
			n.listenerCount > 0 &&
				this._handleChange({ instances: { [n.instanceId]: { formattedValue: n.lastValue } } }))
	}
	handleAutorunCreated(e) {
		let n = {
			declarationId: this._getDeclarationId("autorun"),
			instanceId: this._instanceId++,
			updateCount: 0,
			changedObservables: new Set(),
		}
		this._instanceInfos.set(e, n),
			this._aliveInstances.set(n.instanceId, e),
			n &&
				this._handleChange({
					instances: {
						[n.instanceId]: {
							instanceId: n.instanceId,
							declarationId: n.declarationId,
							runCount: 0,
							type: "autorun",
							name: e.debugName,
						},
					},
				})
	}
	handleAutorunDisposed(e) {
		let t = this._getAutorunInfo(e)
		t &&
			(this._handleChange({ instances: { [t.instanceId]: null } }),
			this._instanceInfos.delete(e),
			this._aliveInstances.delete(t.instanceId))
	}
	handleAutorunDependencyChanged(e, t, n) {
		let r = this._getAutorunInfo(e)
		r && r.changedObservables.add(t)
	}
	handleAutorunStarted(e) {}
	handleAutorunFinished(e) {
		let t = this._getAutorunInfo(e)
		t &&
			(t.changedObservables.clear(),
			t.updateCount++,
			this._handleChange({ instances: { [t.instanceId]: { runCount: t.updateCount } } }))
	}
	handleDerivedDependencyChanged(e, t, n) {
		let r = this._getObservableInfo(e)
		r && r.changedObservables.add(t)
	}
	_handleDerivedRecomputed(e, t) {
		let n = this._getObservableInfo(e)
		if (!n) return
		let r = vi(t.newValue, 30)
		n.updateCount++,
			n.changedObservables.clear(),
			(n.lastValue = r),
			n.listenerCount > 0 &&
				this._handleChange({
					instances: { [n.instanceId]: { formattedValue: r, recomputationCount: n.updateCount } },
				})
	}
	handleDerivedCleared(e) {
		let t = this._getObservableInfo(e)
		t &&
			((t.lastValue = void 0),
			t.changedObservables.clear(),
			t.listenerCount > 0 && this._handleChange({ instances: { [t.instanceId]: { formattedValue: void 0 } } }))
	}
	handleBeginTransaction(e) {
		this._activeTransactions.add(e)
	}
	handleEndTransaction(e) {
		this._activeTransactions.delete(e)
	}
}
dM(IM)
var yV = !1
yV && Yf(new tg())
Pr && Pr.VSCODE_DEV_DEBUG && Yf(Zb.getInstance())
var Xr = class o {
	constructor(e, t) {
		this.start = e
		this.endExclusive = t
		if (e > t) throw new Gt(`Invalid range: ${this.toString()}`)
	}
	static fromTo(e, t) {
		return new o(e, t)
	}
	static addRange(e, t) {
		let n = 0
		for (; n < t.length && t[n].endExclusive < e.start; ) n++
		let r = n
		for (; r < t.length && t[r].start <= e.endExclusive; ) r++
		if (n === r) t.splice(n, 0, e)
		else {
			let i = Math.min(e.start, t[n].start),
				s = Math.max(e.endExclusive, t[r - 1].endExclusive)
			t.splice(n, r - n, new o(i, s))
		}
	}
	static tryCreate(e, t) {
		if (!(e > t)) return new o(e, t)
	}
	static ofLength(e) {
		return new o(0, e)
	}
	static ofStartAndLength(e, t) {
		return new o(e, e + t)
	}
	static emptyAt(e) {
		return new o(e, e)
	}
	get isEmpty() {
		return this.start === this.endExclusive
	}
	delta(e) {
		return new o(this.start + e, this.endExclusive + e)
	}
	deltaStart(e) {
		return new o(this.start + e, this.endExclusive)
	}
	deltaEnd(e) {
		return new o(this.start, this.endExclusive + e)
	}
	get length() {
		return this.endExclusive - this.start
	}
	toString() {
		return `[${this.start}, ${this.endExclusive})`
	}
	equals(e) {
		return this.start === e.start && this.endExclusive === e.endExclusive
	}
	containsRange(e) {
		return this.start <= e.start && e.endExclusive <= this.endExclusive
	}
	contains(e) {
		return this.start <= e && e < this.endExclusive
	}
	join(e) {
		return new o(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive))
	}
	intersect(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		if (t <= n) return new o(t, n)
	}
	intersectionLength(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return Math.max(0, n - t)
	}
	intersects(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return t < n
	}
	intersectsOrTouches(e) {
		let t = Math.max(this.start, e.start),
			n = Math.min(this.endExclusive, e.endExclusive)
		return t <= n
	}
	isBefore(e) {
		return this.endExclusive <= e.start
	}
	isAfter(e) {
		return this.start >= e.endExclusive
	}
	slice(e) {
		return e.slice(this.start, this.endExclusive)
	}
	substring(e) {
		return e.substring(this.start, this.endExclusive)
	}
	clip(e) {
		if (this.isEmpty) throw new Gt(`Invalid clipping range: ${this.toString()}`)
		return Math.max(this.start, Math.min(this.endExclusive - 1, e))
	}
	clipCyclic(e) {
		if (this.isEmpty) throw new Gt(`Invalid clipping range: ${this.toString()}`)
		return e < this.start
			? this.endExclusive - ((this.start - e) % this.length)
			: e >= this.endExclusive
				? this.start + ((e - this.start) % this.length)
				: e
	}
	map(e) {
		let t = []
		for (let n = this.start; n < this.endExclusive; n++) t.push(e(n))
		return t
	}
	forEach(e) {
		for (let t = this.start; t < this.endExclusive; t++) e(t)
	}
}
function r_() {
	return Object.create(null)
}
var hs = "**",
	ny = "/",
	ey = "[/\\\\]",
	ty = "[^/\\\\]",
	IV = /\//g
function CM(o, e) {
	switch (o) {
		case 0:
			return ""
		case 1:
			return `${ty}*?`
		default:
			return `(?:${ey}|${ty}+${ey}${e ? `|${ey}${ty}+` : ""})*?`
	}
}
function sd(o, e) {
	if (!o) return []
	let t = [],
		n = !1,
		r = !1,
		i = ""
	for (let s of o) {
		switch (s) {
			case e:
				if (!n && !r) {
					t.push(i), (i = "")
					continue
				}
				break
			case "{":
				n = !0
				break
			case "}":
				n = !1
				break
			case "[":
				r = !0
				break
			case "]":
				r = !1
				break
		}
		i += s
	}
	return i && t.push(i), t
}
function PM(o) {
	if (!o) return ""
	let e = "",
		t = sd(o, ny)
	if (t.every((n) => n === hs)) e = ".*"
	else {
		let n = !1
		t.forEach((r, i) => {
			if (r === hs) {
				if (n) return
				e += CM(2, i === t.length - 1)
			} else {
				let s = !1,
					a = "",
					l = !1,
					d = ""
				for (let c of r) {
					if (c !== "}" && s) {
						a += c
						continue
					}
					if (l && (c !== "]" || !d)) {
						let u
						c === "-"
							? (u = c)
							: (c === "^" || c === "!") && !d
								? (u = "^")
								: c === ny
									? (u = "")
									: (u = kr(c)),
							(d += u)
						continue
					}
					switch (c) {
						case "{":
							s = !0
							continue
						case "[":
							l = !0
							continue
						case "}": {
							let m = `(?:${sd(a, ",")
								.map((f) => PM(f))
								.join("|")})`
							;(e += m), (s = !1), (a = "")
							break
						}
						case "]": {
							;(e += "[" + d + "]"), (l = !1), (d = "")
							break
						}
						case "?":
							e += ty
							continue
						case "*":
							e += CM(1)
							continue
						default:
							e += kr(c)
					}
				}
				i < t.length - 1 && (t[i + 1] !== hs || i + 2 < t.length) && (e += ey)
			}
			n = r === hs
		})
	}
	return e
}
var xV = /^\*\*\/\*\.[\w\.-]+$/,
	CV = /^\*\*\/([\w\.-]+)\/?$/,
	SV = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,
	TV = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,
	EV = /^\*\*((\/[\w\.-]+)+)\/?$/,
	wV = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
	SM = new ko(1e4),
	TM = function () {
		return !1
	},
	bi = function () {
		return null
	}
function o_(o, e) {
	if (!o) return bi
	let t
	typeof o != "string" ? (t = o.pattern) : (t = o), (t = t.trim())
	let n = `${t}_${!!e.trimForExclusions}`,
		r = SM.get(n)
	if (r) return EM(r, o)
	let i
	return (
		xV.test(t)
			? (r = PV(t.substr(4), t))
			: (i = CV.exec(n_(t, e)))
				? (r = _V(i[1], t))
				: (e.trimForExclusions ? TV : SV).test(t)
					? (r = DV(t, e))
					: (i = EV.exec(n_(t, e)))
						? (r = wM(i[1].substr(1), t, !0))
						: (i = wV.exec(n_(t, e)))
							? (r = wM(i[1], t, !1))
							: (r = kV(t)),
		SM.set(n, r),
		EM(r, o)
	)
}
function EM(o, e) {
	if (typeof e == "string") return o
	let t = function (n, r) {
		return Kr(n, e.base, !Ve) ? o(DE(n.substr(e.base.length), at), r) : null
	}
	return (
		(t.allBasenames = o.allBasenames),
		(t.allPaths = o.allPaths),
		(t.basenames = o.basenames),
		(t.patterns = o.patterns),
		t
	)
}
function n_(o, e) {
	return e.trimForExclusions && o.endsWith("/**") ? o.substr(0, o.length - 2) : o
}
function PV(o, e) {
	return function (t, n) {
		return typeof t == "string" && t.endsWith(o) ? e : null
	}
}
function _V(o, e) {
	let t = `/${o}`,
		n = `\\${o}`,
		r = function (s, a) {
			return typeof s != "string"
				? null
				: a
					? a === o
						? e
						: null
					: s === o || s.endsWith(t) || s.endsWith(n)
						? e
						: null
		},
		i = [o]
	return (r.basenames = i), (r.patterns = [e]), (r.allBasenames = i), r
}
function DV(o, e) {
	let t = DM(
			o
				.slice(1, -1)
				.split(",")
				.map((a) => o_(a, e))
				.filter((a) => a !== bi),
			o,
		),
		n = t.length
	if (!n) return bi
	if (n === 1) return t[0]
	let r = function (a, l) {
			for (let d = 0, c = t.length; d < c; d++) if (t[d](a, l)) return o
			return null
		},
		i = t.find((a) => !!a.allBasenames)
	i && (r.allBasenames = i.allBasenames)
	let s = t.reduce((a, l) => (l.allPaths ? a.concat(l.allPaths) : a), [])
	return s.length && (r.allPaths = s), r
}
function wM(o, e, t) {
	let n = at === Ue.sep,
		r = n ? o : o.replace(IV, at),
		i = at + r,
		s = Ue.sep + o,
		a
	return (
		t
			? (a = function (l, d) {
					return typeof l == "string" && (l === r || l.endsWith(i) || (!n && (l === o || l.endsWith(s))))
						? e
						: null
				})
			: (a = function (l, d) {
					return typeof l == "string" && (l === r || (!n && l === o)) ? e : null
				}),
		(a.allPaths = [(t ? "*/" : "./") + o]),
		a
	)
}
function kV(o) {
	try {
		let e = new RegExp(`^${PM(o)}$`)
		return function (t) {
			return (e.lastIndex = 0), typeof t == "string" && e.test(t) ? o : null
		}
	} catch {
		return bi
	}
}
function yi(o, e, t) {
	return !o || typeof e != "string" ? !1 : Yn(o)(e, void 0, t)
}
function Yn(o, e = {}) {
	if (!o) return TM
	if (typeof o == "string" || _M(o)) {
		let t = o_(o, e)
		if (t === bi) return TM
		let n = function (r, i) {
			return !!t(r, i)
		}
		return t.allBasenames && (n.allBasenames = t.allBasenames), t.allPaths && (n.allPaths = t.allPaths), n
	}
	return RV(o, e)
}
function _M(o) {
	let e = o
	return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1
}
function i_(o) {
	return o.allBasenames || []
}
function s_(o) {
	return o.allPaths || []
}
function RV(o, e) {
	let t = DM(
			Object.getOwnPropertyNames(o)
				.map((a) => AV(a, o[a], e))
				.filter((a) => a !== bi),
		),
		n = t.length
	if (!n) return bi
	if (!t.some((a) => !!a.requiresSiblings)) {
		if (n === 1) return t[0]
		let a = function (c, u) {
				let m
				for (let f = 0, h = t.length; f < h; f++) {
					let g = t[f](c, u)
					if (typeof g == "string") return g
					ao(g) && (m || (m = []), m.push(g))
				}
				return m
					? (async () => {
							for (let f of m) {
								let h = await f
								if (typeof h == "string") return h
							}
							return null
						})()
					: null
			},
			l = t.find((c) => !!c.allBasenames)
		l && (a.allBasenames = l.allBasenames)
		let d = t.reduce((c, u) => (u.allPaths ? c.concat(u.allPaths) : c), [])
		return d.length && (a.allPaths = d), a
	}
	let r = function (a, l, d) {
			let c, u
			for (let m = 0, f = t.length; m < f; m++) {
				let h = t[m]
				h.requiresSiblings && d && (l || (l = Ze(a)), c || (c = l.substr(0, l.length - la(a).length)))
				let g = h(a, l, c, d)
				if (typeof g == "string") return g
				ao(g) && (u || (u = []), u.push(g))
			}
			return u
				? (async () => {
						for (let m of u) {
							let f = await m
							if (typeof f == "string") return f
						}
						return null
					})()
				: null
		},
		i = t.find((a) => !!a.allBasenames)
	i && (r.allBasenames = i.allBasenames)
	let s = t.reduce((a, l) => (l.allPaths ? a.concat(l.allPaths) : a), [])
	return s.length && (r.allPaths = s), r
}
function AV(o, e, t) {
	if (e === !1) return bi
	let n = o_(o, t)
	if (n === bi) return bi
	if (typeof e == "boolean") return n
	if (e) {
		let r = e.when
		if (typeof r == "string") {
			let i = (s, a, l, d) => {
				if (!d || !n(s, a)) return null
				let c = r.replace("$(basename)", () => l),
					u = d(c)
				return ao(u) ? u.then((m) => (m ? o : null)) : u ? o : null
			}
			return (i.requiresSiblings = !0), i
		}
	}
	return n
}
function DM(o, e) {
	let t = o.filter((a) => !!a.basenames)
	if (t.length < 2) return o
	let n = t.reduce((a, l) => {
			let d = l.basenames
			return d ? a.concat(d) : a
		}, []),
		r
	if (e) {
		r = []
		for (let a = 0, l = n.length; a < l; a++) r.push(e)
	} else
		r = t.reduce((a, l) => {
			let d = l.patterns
			return d ? a.concat(d) : a
		}, [])
	let i = function (a, l) {
		if (typeof a != "string") return null
		if (!l) {
			let c
			for (c = a.length; c > 0; c--) {
				let u = a.charCodeAt(c - 1)
				if (u === 47 || u === 92) break
			}
			l = a.substr(c)
		}
		let d = n.indexOf(l)
		return d !== -1 ? r[d] : null
	}
	;(i.basenames = n), (i.patterns = r), (i.allBasenames = n)
	let s = o.filter((a) => !a.basenames)
	return s.push(i), s
}
function a_(o, e) {
	return mn(o, e, (t, n) =>
		typeof t == "string" && typeof n == "string"
			? t === n
			: typeof t != "string" && typeof n != "string"
				? t.base === n.base && t.pattern === n.pattern
				: !1,
	)
}
var OV = O("notebookDocumentService"),
	l_ = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"],
	LV = new RegExp(`^[${l_.join("")}]+`),
	RM = 7
function ry(o) {
	if (o.scheme !== W.vscodeNotebookCell) return
	let e = o.fragment.indexOf("s")
	if (e < 0) return
	let t = parseInt(o.fragment.substring(0, e).replace(LV, ""), RM),
		n = Ic(o.fragment.substring(e + 1)).toString()
	if (!isNaN(t)) return { handle: t, notebook: o.with({ scheme: n, fragment: null }) }
}
function AM(o, e) {
	let t = e.toString(RM),
		r = `${t.length < l_.length ? l_[t.length - 1] : "z"}${t}s${Ol(z.fromString(o.scheme), !0, !0)}`
	return o.with({ scheme: W.vscodeNotebookCell, fragment: r })
}
function OM(o) {
	if (o.scheme !== W.vscodeNotebookMetadata) return
	let e = Ic(o.fragment).toString()
	return o.with({ scheme: e, fragment: null })
}
function LM(o) {
	let e = `${Ol(z.fromString(o.scheme), !0, !0)}`
	return o.with({ scheme: W.vscodeNotebookMetadata, fragment: e })
}
function c_(o) {
	if (o.scheme !== W.vscodeNotebookCellOutput) return
	let e = new URLSearchParams(o.query),
		t = e.get("openIn")
	if (!t) return
	let n = e.get("outputId") ?? void 0,
		r = ry(o.with({ scheme: W.vscodeNotebookCell, query: null })),
		i = e.get("outputIndex") ? parseInt(e.get("outputIndex") || "", 10) : void 0
	return {
		notebook: r ? r.notebook : o.with({ scheme: e.get("notebookScheme") || W.file, fragment: null, query: null }),
		openIn: t,
		outputId: n,
		outputIndex: i,
		cellHandle: r?.handle,
		cellFragment: o.fragment,
	}
}
var d_ = class {
	constructor() {
		this._documents = new ft()
	}
	getNotebook(e) {
		if (e.scheme === W.vscodeNotebookCell) {
			let t = ry(e)
			if (t) {
				let n = this._documents.get(t.notebook)
				if (n) return n
			}
		}
		if (e.scheme === W.vscodeNotebookCellOutput) {
			let t = c_(e)
			if (t) {
				let n = this._documents.get(t.notebook)
				if (n) return n
			}
		}
		return this._documents.get(e)
	}
	addNotebookDocument(e) {
		this._documents.set(e.uri, e)
	}
	removeNotebookDocument(e) {
		this._documents.delete(e.uri)
	}
}
Ke(OV, d_, 1)
var Zee = [
		"application/json",
		"application/javascript",
		"text/html",
		"image/svg+xml",
		mo.latex,
		mo.markdown,
		"image/png",
		"image/jpeg",
		mo.text,
	],
	ete = [mo.latex, mo.markdown, "application/json", "text/html", "image/svg+xml", "image/png", "image/jpeg", mo.text]
var MV
;((n) => {
	n.scheme = W.vscodeNotebookMetadata
	function e(r) {
		return LM(r)
	}
	n.generate = e
	function t(r) {
		return OM(r)
	}
	n.parse = t
})((MV ||= {}))
var ng
;((l) => {
	l.scheme = W.vscodeNotebookCell
	function e(d, c) {
		return AM(d, c)
	}
	l.generate = e
	function t(d) {
		return ry(d)
	}
	l.parse = t
	function n(d, c) {
		return d.with({
			scheme: W.vscodeNotebookCellOutput,
			query: new URLSearchParams({
				openIn: "editor",
				outputId: c ?? "",
				notebookScheme: d.scheme !== W.file ? d.scheme : "",
			}).toString(),
		})
	}
	l.generateCellOutputUriWithId = n
	function r(d, c, u) {
		return d.with({
			scheme: W.vscodeNotebookCellOutput,
			fragment: c.fragment,
			query: new URLSearchParams({ openIn: "notebook", outputIndex: String(u) }).toString(),
		})
	}
	l.generateCellOutputUriWithIndex = r
	function i(d) {
		return c_(d)
	}
	l.parseCellOutputUri = i
	function s(d, c, u) {
		return l.generate(d, c).with({ scheme: u })
	}
	l.generateCellPropertyUri = s
	function a(d, c) {
		if (d.scheme === c) return l.parse(d.with({ scheme: l.scheme }))
	}
	l.parseCellPropertyUri = a
})((ng ||= {}))
var tte = new D("notebookEditorCursorAtBoundary", "none"),
	nte = new D("notebookEditorCursorAtLineBoundary", "none")
var MM = class o {
	static {
		this._prefix = "notebook/"
	}
	static create(e, t) {
		return `${o._prefix}${e}/${t ?? e}`
	}
	static parse(e) {
		if (e.startsWith(o._prefix)) {
			let t = e.substring(o._prefix.length).split("/")
			if (t.length === 2) return { notebookType: t[0], viewType: t[1] }
		}
	}
}
function iy(o) {
	return ["application/vnd.code.notebook.stdout", "application/vnd.code.notebook.stderr"].includes(o)
}
var FV = new TextDecoder()
function FM(o) {
	let e = [],
		t = !1
	for (let s of o) (e.length === 0 || t) && (e.push(s), (t = !0))
	let n = UV(e),
		r = z.concat(e.map((s) => z.wrap(s))),
		i = $V(r)
	return (n = n || i.byteLength !== r.byteLength), { data: i, didCompression: n }
}
var oy = "\x1B[A",
	u_ = oy.split("").map((o) => o.charCodeAt(0)),
	NV = 10
function UV(o) {
	let e = !1
	return (
		o.forEach((t, n) => {
			if (n === 0 || t.length < oy.length) return
			let r = o[n - 1],
				i = t.subarray(0, oy.length)
			if (i[0] === u_[0] && i[1] === u_[1] && i[2] === u_[2]) {
				let s = r.lastIndexOf(NV)
				if (s === -1) return
				;(e = !0), (o[n - 1] = r.subarray(0, s)), (o[n] = t.subarray(oy.length))
			}
		}),
		e
	)
}
function HV(o) {
	let e = o
	do (o = e), (e = o.replace(/[^\n]\x08/gm, ""))
	while (e.length < o.length)
	return o
}
function WV(o) {
	for (
		o = o.replace(
			/\r+\n/gm,
			`
`,
		);
		o.search(/\r[^$]/g) > -1;

	) {
		let e = o.match(/^(.*)\r+/m)[1],
			t = o.match(/\r+(.*)$/m)[1]
		;(t = t + e.slice(t.length, e.length)), (o = o.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, t))
	}
	return o
}
var VV = 8,
	BV = 13
function $V(o) {
	return !o.buffer.includes(VV) && !o.buffer.includes(BV) ? o : z.fromString(WV(HV(FV.decode(o.buffer))))
}
var tu = O("productService"),
	UM = "vscode://schemas/vscode-product"
var br = O("configurationService")
function sy(o, e) {
	let t = Object.create(null)
	for (let n in o) p_(t, n, o[n], e)
	return t
}
function p_(o, e, t, n) {
	let r = e.split("."),
		i = r.pop(),
		s = o
	for (let a = 0; a < r.length; a++) {
		let l = r[a],
			d = s[l]
		switch (typeof d) {
			case "undefined":
				d = s[l] = Object.create(null)
				break
			case "object":
				if (d === null) {
					n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is null`)
					return
				}
				break
			default:
				n(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(d)}`)
				return
		}
		s = d
	}
	if (typeof s == "object" && s !== null)
		try {
			s[i] = t
		} catch {
			n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`)
		}
	else n(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`)
}
function HM(o, e) {
	let t = e.split(".")
	WM(o, t)
}
function WM(o, e) {
	if (!o) return
	let t = e.shift()
	if (e.length === 0) {
		delete o[t]
		return
	}
	if (Object.keys(o).indexOf(t) !== -1) {
		let n = o[t]
		typeof n == "object" && !Array.isArray(n) && (WM(n, e), Object.keys(n).length === 0 && delete o[t])
	}
}
function rg(o, e, t) {
	function n(s, a) {
		let l = s
		for (let d of a) {
			if (typeof l != "object" || l === null) return
			l = l[d]
		}
		return l
	}
	let r = e.split("."),
		i = n(o, r)
	return typeof i > "u" ? t : i
}
function VM(o) {
	return o.replace(/[\[\]]/g, "")
}
function BM(o) {
	let e = !1,
		t = new Map(),
		n = new Map()
	if (
		(zV(o, (c) => {
			if (o === c) return !0
			let u = JSON.stringify(c)
			if (u.length < 30) return !0
			let m = t.get(u)
			if (!m) {
				let f = { schemas: [c] }
				return t.set(u, f), n.set(c, f), !0
			}
			return m.schemas.push(c), n.set(c, m), (e = !0), !1
		}),
		t.clear(),
		!e)
	)
		return JSON.stringify(o)
	let i = "$defs"
	for (; o.hasOwnProperty(i); ) i += "_"
	let s = []
	function a(c) {
		return JSON.stringify(c, (u, m) => {
			if (m !== c) {
				let f = n.get(m)
				if (f && f.schemas.length > 1)
					return f.id || ((f.id = `_${s.length}`), s.push(f.schemas[0])), { $ref: `#/${i}/${f.id}` }
			}
			return m
		})
	}
	let l = a(o),
		d = []
	for (let c = 0; c < s.length; c++) d.push(`"_${c}":${a(s[c])}`)
	return d.length ? `${l.substring(0, l.length - 1)},"${i}":{${d.join(",")}}}` : l
}
function nu(o) {
	return typeof o == "object" && o !== null
}
function zV(o, e) {
	if (!o || typeof o != "object") return
	let t = (...l) => {
			for (let d of l) nu(d) && s.push(d)
		},
		n = (...l) => {
			for (let d of l)
				if (nu(d))
					for (let c in d) {
						let u = d[c]
						nu(u) && s.push(u)
					}
		},
		r = (...l) => {
			for (let d of l) if (Array.isArray(d)) for (let c of d) nu(c) && s.push(c)
		},
		i = (l) => {
			if (Array.isArray(l)) for (let d of l) nu(d) && s.push(d)
			else nu(l) && s.push(l)
		},
		s = [o],
		a = s.pop()
	for (; a; )
		e(a) &&
			(t(
				a.additionalItems,
				a.additionalProperties,
				a.not,
				a.contains,
				a.propertyNames,
				a.if,
				a.then,
				a.else,
				a.unevaluatedItems,
				a.unevaluatedProperties,
			),
			n(a.definitions, a.$defs, a.properties, a.patternProperties, a.dependencies, a.dependentSchemas),
			r(a.anyOf, a.allOf, a.oneOf, a.prefixItems),
			i(a.items)),
			(a = s.pop())
}
var ad = { JSONContribution: "base.contributions.json" }
function $M(o) {
	return o.length > 0 && o.charAt(o.length - 1) === "#" ? o.substring(0, o.length - 1) : o
}
var m_ = class {
		constructor() {
			this.schemasById = {}
			this.schemaAssociations = {}
			this._onDidChangeSchema = new E()
			this.onDidChangeSchema = this._onDidChangeSchema.event
			this._onDidChangeSchemaAssociations = new E()
			this.onDidChangeSchemaAssociations = this._onDidChangeSchemaAssociations.event
		}
		registerSchema(e, t, n) {
			let r = $M(e)
			;(this.schemasById[r] = t),
				this._onDidChangeSchema.fire(e),
				n &&
					n.add(
						q(() => {
							delete this.schemasById[r], this._onDidChangeSchema.fire(e)
						}),
					)
		}
		registerSchemaAssociation(e, t) {
			let n = $M(e)
			return (
				this.schemaAssociations[n] || (this.schemaAssociations[n] = []),
				this.schemaAssociations[n].includes(t) ||
					(this.schemaAssociations[n].push(t), this._onDidChangeSchemaAssociations.fire()),
				q(() => {
					let r = this.schemaAssociations[n]
					if (r) {
						let i = r.indexOf(t)
						i !== -1 &&
							(r.splice(i, 1),
							r.length === 0 && delete this.schemaAssociations[n],
							this._onDidChangeSchemaAssociations.fire())
					}
				})
			)
		}
		notifySchemaChanged(e) {
			this._onDidChangeSchema.fire(e)
		}
		getSchemaContributions() {
			return { schemas: this.schemasById }
		}
		getSchemaContent(e) {
			let t = this.schemasById[e]
			return t ? BM(t) : void 0
		}
		hasSchemaContent(e) {
			return !!this.schemasById[e]
		}
		getSchemaAssociations() {
			return this.schemaAssociations
		}
	},
	qV = new m_()
yt.add(ad.JSONContribution, qV)
var ho = { Configuration: "base.contributions.configuration" }
var ay = { properties: {}, patternProperties: {} },
	ly = { properties: {}, patternProperties: {} },
	dy = { properties: {}, patternProperties: {} },
	cy = { properties: {}, patternProperties: {} },
	uy = { properties: {}, patternProperties: {} },
	py = { properties: {}, patternProperties: {} },
	og = { properties: {}, patternProperties: {} },
	ld = "vscode://schemas/settings/resourceLanguage"
var my = yt.as(ad.JSONContribution),
	f_ = class {
		constructor() {
			this.registeredConfigurationDefaults = []
			this.overrideIdentifiers = new Set()
			this._onDidSchemaChange = new E()
			this.onDidSchemaChange = this._onDidSchemaChange.event
			this._onDidUpdateConfiguration = new E()
			this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event
			;(this.configurationDefaultsOverrides = new Map()),
				(this.defaultLanguageConfigurationOverridesNode = {
					id: "defaultOverrides",
					title: p("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
					properties: {},
				}),
				(this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode]),
				(this.resourceLanguageSettingsSchema = {
					properties: {},
					patternProperties: {},
					additionalProperties: !0,
					allowTrailingCommas: !0,
					allowComments: !0,
				}),
				(this.configurationProperties = {}),
				(this.policyConfigurations = new Map()),
				(this.excludedConfigurationProperties = {}),
				my.registerSchema(ld, this.resourceLanguageSettingsSchema),
				this.registerOverridePropertyPatternKey()
		}
		registerConfiguration(e, t = !0) {
			return this.registerConfigurations([e], t), e
		}
		registerConfigurations(e, t = !0) {
			let n = new Set()
			this.doRegisterConfigurations(e, t, n),
				my.registerSchema(ld, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n })
		}
		deregisterConfigurations(e) {
			let t = new Set()
			this.doDeregisterConfigurations(e, t),
				my.registerSchema(ld, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t })
		}
		updateConfigurations({ add: e, remove: t }) {
			let n = new Set()
			this.doDeregisterConfigurations(t, n),
				this.doRegisterConfigurations(e, !1, n),
				my.registerSchema(ld, this.resourceLanguageSettingsSchema),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n })
		}
		registerDefaultConfigurations(e) {
			let t = new Set()
			this.doRegisterDefaultConfigurations(e, t),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 })
		}
		doRegisterDefaultConfigurations(e, t) {
			this.registeredConfigurationDefaults.push(...e)
			let n = []
			for (let { overrides: r, source: i } of e)
				for (let s in r) {
					t.add(s)
					let a =
							this.configurationDefaultsOverrides.get(s) ??
							this.configurationDefaultsOverrides.set(s, { configurationDefaultOverrides: [] }).get(s),
						l = r[s]
					if ((a.configurationDefaultOverrides.push({ value: l, source: i }), go.test(s))) {
						let d = this.mergeDefaultConfigurationsForOverrideIdentifier(
							s,
							l,
							i,
							a.configurationDefaultOverrideValue,
						)
						if (!d) continue
						;(a.configurationDefaultOverrideValue = d),
							this.updateDefaultOverrideProperty(s, d, i),
							n.push(...ru(s))
					} else {
						let d = this.mergeDefaultConfigurationsForConfigurationProperty(
							s,
							l,
							i,
							a.configurationDefaultOverrideValue,
						)
						if (!d) continue
						a.configurationDefaultOverrideValue = d
						let c = this.configurationProperties[s]
						c && (this.updatePropertyDefaultValue(s, c), this.updateSchema(s, c))
					}
				}
			this.doRegisterOverrideIdentifiers(n)
		}
		deregisterDefaultConfigurations(e) {
			let t = new Set()
			this.doDeregisterDefaultConfigurations(e, t),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 })
		}
		doDeregisterDefaultConfigurations(e, t) {
			for (let n of e) {
				let r = this.registeredConfigurationDefaults.indexOf(n)
				r !== -1 && this.registeredConfigurationDefaults.splice(r, 1)
			}
			for (let { overrides: n, source: r } of e)
				for (let i in n) {
					let s = this.configurationDefaultsOverrides.get(i)
					if (!s) continue
					let a = s.configurationDefaultOverrides.findIndex((l) =>
						r ? l.source?.id === r.id : l.value === n[i],
					)
					if (a !== -1) {
						if (
							(s.configurationDefaultOverrides.splice(a, 1),
							s.configurationDefaultOverrides.length === 0 &&
								this.configurationDefaultsOverrides.delete(i),
							go.test(i))
						) {
							let l
							for (let d of s.configurationDefaultOverrides)
								l = this.mergeDefaultConfigurationsForOverrideIdentifier(i, d.value, d.source, l)
							l && !pv(l.value)
								? ((s.configurationDefaultOverrideValue = l),
									this.updateDefaultOverrideProperty(i, l, r))
								: (this.configurationDefaultsOverrides.delete(i),
									delete this.configurationProperties[i],
									delete this.defaultLanguageConfigurationOverridesNode.properties[i])
						} else {
							let l
							for (let c of s.configurationDefaultOverrides)
								l = this.mergeDefaultConfigurationsForConfigurationProperty(i, c.value, c.source, l)
							s.configurationDefaultOverrideValue = l
							let d = this.configurationProperties[i]
							d && (this.updatePropertyDefaultValue(i, d), this.updateSchema(i, d))
						}
						t.add(i)
					}
				}
			this.updateOverridePropertyPatternKey()
		}
		updateDefaultOverrideProperty(e, t, n) {
			let r = {
				type: "object",
				default: t.value,
				description: p(
					"defaultLanguageConfiguration.description",
					"Configure settings to be overridden for the {0} language.",
					VM(e),
				),
				$ref: ld,
				defaultDefaultValue: t.value,
				source: n,
				defaultValueSource: n,
			}
			;(this.configurationProperties[e] = r), (this.defaultLanguageConfigurationOverridesNode.properties[e] = r)
		}
		mergeDefaultConfigurationsForOverrideIdentifier(e, t, n, r) {
			let i = r?.value || {},
				s = r?.source ?? new Map()
			if (!(s instanceof Map)) {
				console.error("objectConfigurationSources is not a Map")
				return
			}
			for (let a of Object.keys(t)) {
				let l = t[a]
				if (dt(l) && (vc(i[a]) || dt(i[a]))) {
					if (((i[a] = { ...(i[a] ?? {}), ...l }), n)) for (let c in l) s.set(`${a}.${c}`, n)
				} else (i[a] = l), n ? s.set(a, n) : s.delete(a)
			}
			return { value: i, source: s }
		}
		mergeDefaultConfigurationsForConfigurationProperty(e, t, n, r) {
			let i = this.configurationProperties[e],
				s = r?.value ?? i?.defaultDefaultValue,
				a = n
			if (dt(t) && ((i !== void 0 && i.type === "object") || (i === void 0 && (vc(s) || dt(s))))) {
				if (((a = r?.source ?? new Map()), !(a instanceof Map))) {
					console.error("defaultValueSource is not a Map")
					return
				}
				for (let d in t) n && a.set(`${e}.${d}`, n)
				t = { ...(dt(s) ? s : {}), ...t }
			}
			return { value: t, source: a }
		}
		deltaConfiguration(e) {
			let t = !1,
				n = new Set()
			e.removedDefaults && (this.doDeregisterDefaultConfigurations(e.removedDefaults, n), (t = !0)),
				e.addedDefaults && (this.doRegisterDefaultConfigurations(e.addedDefaults, n), (t = !0)),
				e.removedConfigurations && this.doDeregisterConfigurations(e.removedConfigurations, n),
				e.addedConfigurations && this.doRegisterConfigurations(e.addedConfigurations, !1, n),
				this._onDidSchemaChange.fire(),
				this._onDidUpdateConfiguration.fire({ properties: n, defaultsOverrides: t })
		}
		notifyConfigurationSchemaUpdated(...e) {
			this._onDidSchemaChange.fire()
		}
		registerOverrideIdentifiers(e) {
			this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire()
		}
		doRegisterOverrideIdentifiers(e) {
			for (let t of e) this.overrideIdentifiers.add(t)
			this.updateOverridePropertyPatternKey()
		}
		doRegisterConfigurations(e, t, n) {
			e.forEach((r) => {
				this.validateAndRegisterProperties(r, t, r.extensionInfo, r.restrictedProperties, void 0, n),
					this.configurationContributors.push(r),
					this.registerJSONConfiguration(r)
			})
		}
		doDeregisterConfigurations(e, t) {
			let n = (r) => {
				if (r.properties)
					for (let i in r.properties) {
						t.add(i)
						let s = this.configurationProperties[i]
						s?.policy?.name && this.policyConfigurations.delete(s.policy.name),
							delete this.configurationProperties[i],
							this.removeFromSchema(i, r.properties[i])
					}
				r.allOf?.forEach((i) => n(i))
			}
			for (let r of e) {
				n(r)
				let i = this.configurationContributors.indexOf(r)
				i !== -1 && this.configurationContributors.splice(i, 1)
			}
		}
		validateAndRegisterProperties(e, t = !0, n, r, i = 4, s) {
			i = bt(e.scope) ? i : e.scope
			let a = e.properties
			if (a)
				for (let d in a) {
					let c = a[d]
					if (t && jV(d, c)) {
						delete a[d]
						continue
					}
					;(c.source = n),
						(c.defaultDefaultValue = a[d].default),
						this.updatePropertyDefaultValue(d, c),
						go.test(d)
							? (c.scope = void 0)
							: ((c.scope = bt(c.scope) ? i : c.scope),
								(c.restricted = bt(c.restricted) ? !!r?.includes(d) : c.restricted))
					let u = a[d].hasOwnProperty("included") && !a[d].included,
						m = a[d].policy?.name
					u
						? ((this.excludedConfigurationProperties[d] = a[d]),
							m && (this.policyConfigurations.set(m, d), s.add(d)),
							delete a[d])
						: (s.add(d),
							m && this.policyConfigurations.set(m, d),
							(this.configurationProperties[d] = a[d]),
							!a[d].deprecationMessage &&
								a[d].markdownDeprecationMessage &&
								(a[d].deprecationMessage = a[d].markdownDeprecationMessage))
				}
			let l = e.allOf
			if (l) for (let d of l) this.validateAndRegisterProperties(d, t, n, r, i, s)
		}
		getConfigurations() {
			return this.configurationContributors
		}
		getConfigurationProperties() {
			return this.configurationProperties
		}
		getPolicyConfigurations() {
			return this.policyConfigurations
		}
		getExcludedConfigurationProperties() {
			return this.excludedConfigurationProperties
		}
		getRegisteredDefaultConfigurations() {
			return [...this.registeredConfigurationDefaults]
		}
		getConfigurationDefaultsOverrides() {
			let e = new Map()
			for (let [t, n] of this.configurationDefaultsOverrides)
				n.configurationDefaultOverrideValue && e.set(t, n.configurationDefaultOverrideValue)
			return e
		}
		registerJSONConfiguration(e) {
			let t = (n) => {
				let r = n.properties
				if (r) for (let s in r) this.updateSchema(s, r[s])
				n.allOf?.forEach(t)
			}
			t(e)
		}
		updateSchema(e, t) {
			switch (((ay.properties[e] = t), t.scope)) {
				case 1:
					ly.properties[e] = t
					break
				case 2:
					cy.properties[e] = t
					break
				case 3:
					dy.properties[e] = t
					break
				case 7:
					uy.properties[e] = t
					break
				case 4:
					py.properties[e] = t
					break
				case 5:
					og.properties[e] = t
					break
				case 6:
					;(og.properties[e] = t), (this.resourceLanguageSettingsSchema.properties[e] = t)
					break
			}
		}
		removeFromSchema(e, t) {
			switch ((delete ay.properties[e], t.scope)) {
				case 1:
					delete ly.properties[e]
					break
				case 2:
					delete cy.properties[e]
					break
				case 3:
					delete dy.properties[e]
					break
				case 7:
					delete uy.properties[e]
					break
				case 4:
					delete py.properties[e]
					break
				case 5:
				case 6:
					delete og.properties[e], delete this.resourceLanguageSettingsSchema.properties[e]
					break
			}
		}
		updateOverridePropertyPatternKey() {
			for (let e of this.overrideIdentifiers.values()) {
				let t = `[${e}]`,
					n = {
						type: "object",
						description: p(
							"overrideSettings.defaultDescription",
							"Configure editor settings to be overridden for a language.",
						),
						errorMessage: p(
							"overrideSettings.errorMessage",
							"This setting does not support per-language configuration.",
						),
						$ref: ld,
					}
				this.updatePropertyDefaultValue(t, n),
					(ay.properties[t] = n),
					(ly.properties[t] = n),
					(dy.properties[t] = n),
					(cy.properties[t] = n),
					(uy.properties[t] = n),
					(py.properties[t] = n),
					(og.properties[t] = n)
			}
		}
		registerOverridePropertyPatternKey() {
			let e = {
				type: "object",
				description: p(
					"overrideSettings.defaultDescription",
					"Configure editor settings to be overridden for a language.",
				),
				errorMessage: p(
					"overrideSettings.errorMessage",
					"This setting does not support per-language configuration.",
				),
				$ref: ld,
			}
			;(ay.patternProperties[Ta] = e),
				(ly.patternProperties[Ta] = e),
				(dy.patternProperties[Ta] = e),
				(cy.patternProperties[Ta] = e),
				(uy.patternProperties[Ta] = e),
				(py.patternProperties[Ta] = e),
				(og.patternProperties[Ta] = e),
				this._onDidSchemaChange.fire()
		}
		updatePropertyDefaultValue(e, t) {
			let n = this.configurationDefaultsOverrides.get(e)?.configurationDefaultOverrideValue,
				r,
				i
			n && (!t.disallowConfigurationDefault || !n.source) && ((r = n.value), (i = n.source)),
				vc(r) && ((r = t.defaultDefaultValue), (i = void 0)),
				vc(r) && (r = KV(t.type)),
				(t.default = r),
				(t.defaultValueSource = i)
		}
	},
	qM = "\\[([^\\]]+)\\]",
	zM = new RegExp(qM, "g"),
	Ta = `^(${qM})+$`,
	go = new RegExp(Ta)
function ru(o) {
	let e = []
	if (go.test(o)) {
		let t = zM.exec(o)
		for (; t?.length; ) {
			let n = t[1].trim()
			n && e.push(n), (t = zM.exec(o))
		}
	}
	return ai(e)
}
function KV(o) {
	switch (Array.isArray(o) ? o[0] : o) {
		case "boolean":
			return !1
		case "integer":
		case "number":
			return 0
		case "string":
			return ""
		case "array":
			return []
		case "object":
			return {}
		default:
			return null
	}
}
var fy = new f_()
yt.add(ho.Configuration, fy)
function jV(o, e) {
	return o.trim()
		? go.test(o)
			? p(
					"config.property.languageDefault",
					"Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.",
					o,
				)
			: fy.getConfigurationProperties()[o] !== void 0
				? p("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", o)
				: e.policy?.name && fy.getPolicyConfigurations().get(e.policy?.name) !== void 0
					? p(
							"config.policy.duplicate",
							"Cannot register '{0}'. The associated policy {1} is already registered with {2}.",
							o,
							e.policy?.name,
							fy.getPolicyConfigurations().get(e.policy?.name),
						)
					: null
		: p("config.property.empty", "Cannot register an empty property")
}
var GM = O("requestService"),
	h_ = class {
		constructor(e) {
			this.original = e
		}
		toJSON() {
			if (!this.headers) {
				let e = Object.create(null)
				for (let t in this.original)
					t.toLowerCase() === "authorization" || t.toLowerCase() === "proxy-authorization"
						? (e[t] = "*****")
						: (e[t] = this.original[t])
				this.headers = e
			}
			return this.headers
		}
	},
	gy = class extends $ {
		constructor(t) {
			super()
			this.logService = t
			this.counter = 0
		}
		async logAndRequest(t, n) {
			let r = `#${++this.counter}: ${t.url}`
			this.logService.trace(`${r} - begin`, t.type, new h_(t.headers ?? {}))
			try {
				let i = await n()
				return this.logService.trace(`${r} - end`, t.type, i.res.statusCode, i.res.headers), i
			} catch (i) {
				throw (this.logService.error(`${r} - error`, t.type, nf(i)), i)
			}
		}
	}
function GV(o) {
	return (o.res.statusCode && o.res.statusCode >= 200 && o.res.statusCode < 300) || o.res.statusCode === 1223
}
function QV(o) {
	return o.res.statusCode === 204
}
async function QM(o) {
	if (!GV(o)) throw new Error("Server returned " + o.res.statusCode)
	if (QV(o)) return null
	let t = (await yA(o.stream)).toString()
	try {
		return JSON.parse(t)
	} catch (n) {
		throw (
			((n.message +=
				`:
` + t),
			n)
		)
	}
}
var g_ = [],
	KM,
	jM
function JV(o = !0, e = !0) {
	if (KM === o && jM === e) return
	;(KM = o), (jM = e)
	let t = yt.as(ho.Configuration),
		n = g_
	;(g_ = [
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: 2,
			properties: {
				"http.useLocalProxyConfiguration": {
					type: "boolean",
					default: e,
					markdownDescription: p(
						"useLocalProxy",
						"Controls whether in the remote extension host the local proxy configuration should be used. This setting only applies as a remote setting during [remote development](https://aka.ms/vscode-remote).",
					),
					restricted: !0,
				},
			},
		},
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: 1,
			properties: {
				"http.electronFetch": {
					type: "boolean",
					default: !1,
					description: p(
						"electronFetch",
						"Controls whether use of Electron's fetch implementation instead of Node.js' should be enabled. All local extensions will get Electron's fetch implementation for the global fetch API.",
					),
					restricted: !0,
				},
			},
		},
		{
			id: "http",
			order: 15,
			title: p("httpConfigurationTitle", "HTTP"),
			type: "object",
			scope: o ? 1 : 2,
			properties: {
				"http.proxy": {
					type: "string",
					pattern:
						"^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
					markdownDescription: p(
						"proxy",
						"The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyStrictSSL": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"strictSSL",
						"Controls whether the proxy server certificate should be verified against the list of supplied CAs. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyKerberosServicePrincipal": {
					type: "string",
					markdownDescription: p(
						"proxyKerberosServicePrincipal",
						"Overrides the principal service name for Kerberos authentication with the HTTP proxy. A default based on the proxy hostname is used when this is not set. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.noProxy": {
					type: "array",
					items: { type: "string" },
					markdownDescription: p(
						"noProxy",
						"Specifies domain names for which proxy settings should be ignored for HTTP/HTTPS requests. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxyAuthorization": {
					type: ["null", "string"],
					default: null,
					markdownDescription: p(
						"proxyAuthorization",
						"The value to send as the `Proxy-Authorization` header for every network request. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.proxySupport": {
					type: "string",
					enum: ["off", "on", "fallback", "override"],
					enumDescriptions: [
						p("proxySupportOff", "Disable proxy support for extensions."),
						p("proxySupportOn", "Enable proxy support for extensions."),
						p(
							"proxySupportFallback",
							"Enable proxy support for extensions, fall back to request options, when no proxy found.",
						),
						p("proxySupportOverride", "Enable proxy support for extensions, override request options."),
					],
					default: "override",
					markdownDescription: p(
						"proxySupport",
						"Use the proxy support for extensions. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.systemCertificates": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"systemCertificates",
						"Controls whether CA certificates should be loaded from the OS. On Windows and macOS, a reload of the window is required after turning this off. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.experimental.systemCertificatesV2": {
					type: "boolean",
					tags: ["experimental"],
					default: !1,
					markdownDescription: p(
						"systemCertificatesV2",
						"Controls whether experimental loading of CA certificates from the OS should be enabled. This uses a more general approach than the default implementation. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
					),
					restricted: !0,
				},
				"http.fetchAdditionalSupport": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"fetchAdditionalSupport",
						"Controls whether Node.js' fetch implementation should be extended with additional support. Currently proxy support ({1}) and system certificates ({2}) are added when the corresponding settings are enabled. When during [remote development](https://aka.ms/vscode-remote) the {0} setting is disabled this setting can be configured in the local and the remote settings separately.",
						"`#http.useLocalProxyConfiguration#`",
						"`#http.proxySupport#`",
						"`#http.systemCertificates#`",
					),
					restricted: !0,
				},
			},
		},
	]),
		t.updateConfigurations({ add: g_, remove: n })
}
JV()
var v_ = class o extends $ {
	constructor(t, n = Object.create(null)) {
		super()
		this.database = t
		this.options = n
		this._onDidChangeStorage = this._register(new ci())
		this.onDidChangeStorage = this._onDidChangeStorage.event
		this.state = 0
		this.cache = new Map()
		this.flushDelayer = this._register(new ns(o.DEFAULT_FLUSH_DELAY))
		this.pendingDeletes = new Set()
		this.pendingInserts = new Map()
		this.pendingClose = void 0
		this.whenFlushedCallbacks = []
		this.registerListeners()
	}
	static {
		this.DEFAULT_FLUSH_DELAY = 100
	}
	registerListeners() {
		this._register(this.database.onDidChangeItemsExternal((t) => this.onDidChangeItemsExternal(t)))
	}
	onDidChangeItemsExternal(t) {
		this._onDidChangeStorage.pause()
		try {
			t.changed?.forEach((n, r) => this.acceptExternal(r, n)),
				t.deleted?.forEach((n) => this.acceptExternal(n, void 0))
		} finally {
			this._onDidChangeStorage.resume()
		}
	}
	acceptExternal(t, n) {
		if (this.state === 2) return
		let r = !1
		bt(n) ? (r = this.cache.delete(t)) : this.cache.get(t) !== n && (this.cache.set(t, n), (r = !0)),
			r && this._onDidChangeStorage.fire({ key: t, external: !0 })
	}
	get items() {
		return this.cache
	}
	get size() {
		return this.cache.size
	}
	async init() {
		this.state === 0 && ((this.state = 1), this.options.hint !== 0 && (this.cache = await this.database.getItems()))
	}
	get(t, n) {
		let r = this.cache.get(t)
		return bt(r) ? n : r
	}
	getBoolean(t, n) {
		let r = this.get(t)
		return bt(r) ? n : r === "true"
	}
	getNumber(t, n) {
		let r = this.get(t)
		return bt(r) ? n : parseInt(r, 10)
	}
	getObject(t, n) {
		let r = this.get(t)
		return bt(r) ? n : tb(r)
	}
	async set(t, n, r = !1) {
		if (this.state === 2) return
		if (bt(n)) return this.delete(t, r)
		let i = dt(n) || Array.isArray(n) ? TO(n) : String(n)
		if (this.cache.get(t) !== i)
			return (
				this.cache.set(t, i),
				this.pendingInserts.set(t, i),
				this.pendingDeletes.delete(t),
				this._onDidChangeStorage.fire({ key: t, external: r }),
				this.doFlush()
			)
	}
	async delete(t, n = !1) {
		if (!(this.state === 2 || !this.cache.delete(t)))
			return (
				this.pendingDeletes.has(t) || this.pendingDeletes.add(t),
				this.pendingInserts.delete(t),
				this._onDidChangeStorage.fire({ key: t, external: n }),
				this.doFlush()
			)
	}
	async optimize() {
		if (this.state !== 2) return await this.flush(0), this.database.optimize()
	}
	async close() {
		return this.pendingClose || (this.pendingClose = this.doClose()), this.pendingClose
	}
	async doClose() {
		this.state = 2
		try {
			await this.doFlush(0)
		} catch {}
		await this.database.close(() => this.cache)
	}
	get hasPending() {
		return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0
	}
	async flushPending() {
		if (!this.hasPending) return
		let t = { insert: this.pendingInserts, delete: this.pendingDeletes }
		return (
			(this.pendingDeletes = new Set()),
			(this.pendingInserts = new Map()),
			this.database.updateItems(t).finally(() => {
				if (!this.hasPending) for (; this.whenFlushedCallbacks.length; ) this.whenFlushedCallbacks.pop()?.()
			})
		)
	}
	async flush(t) {
		if (!(this.state === 2 || this.pendingClose)) return this.doFlush(t)
	}
	async doFlush(t) {
		return this.options.hint === 1 ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), t)
	}
	async whenFlushed() {
		if (this.hasPending) return new Promise((t) => this.whenFlushedCallbacks.push(t))
	}
	isInMemory() {
		return this.options.hint === 1
	}
}
var ig = O("environmentService"),
	JM = ig
var vy = O("IUriIdentityService")
function XM(o) {
	let e = o
	return !!(
		e &&
		typeof e == "object" &&
		typeof e.id == "string" &&
		typeof e.isDefault == "boolean" &&
		typeof e.name == "string" &&
		b.isUri(e.location) &&
		b.isUri(e.globalStorageHome) &&
		b.isUri(e.settingsResource) &&
		b.isUri(e.keybindingsResource) &&
		b.isUri(e.tasksResource) &&
		b.isUri(e.snippetsHome) &&
		b.isUri(e.promptsHome) &&
		b.isUri(e.extensionsResource)
	)
}
var YM = O("IUserDataProfilesService")
function by(o, e, t, n, r, i) {
	return {
		id: o,
		name: e,
		location: t,
		isDefault: !1,
		icon: r?.icon,
		globalStorageHome: i && r?.useDefaultFlags?.globalState ? i.globalStorageHome : ct(t, "globalStorage"),
		settingsResource: i && r?.useDefaultFlags?.settings ? i.settingsResource : ct(t, "settings.json"),
		keybindingsResource: i && r?.useDefaultFlags?.keybindings ? i.keybindingsResource : ct(t, "keybindings.json"),
		tasksResource: i && r?.useDefaultFlags?.tasks ? i.tasksResource : ct(t, "tasks.json"),
		snippetsHome: i && r?.useDefaultFlags?.snippets ? i.snippetsHome : ct(t, "snippets"),
		promptsHome: i && r?.useDefaultFlags?.prompts ? i.promptsHome : ct(t, "prompts"),
		extensionsResource: i && r?.useDefaultFlags?.extensions ? i.extensionsResource : ct(t, "extensions.json"),
		cacheHome: ct(n, o),
		useDefaultFlags: r?.useDefaultFlags,
		isTransient: r?.transient,
		workspaces: r?.workspaces,
	}
}
var yy = class extends $ {
	constructor(t, n, r, i) {
		super()
		this.environmentService = t
		this.fileService = n
		this.uriIdentityService = r
		this.logService = i
		this._onDidChangeProfiles = this._register(new E())
		this.onDidChangeProfiles = this._onDidChangeProfiles.event
		this._onWillCreateProfile = this._register(new E())
		this.onWillCreateProfile = this._onWillCreateProfile.event
		this._onWillRemoveProfile = this._register(new E())
		this.onWillRemoveProfile = this._onWillRemoveProfile.event
		this._onDidResetWorkspaces = this._register(new E())
		this.onDidResetWorkspaces = this._onDidResetWorkspaces.event
		this.profileCreationPromises = new Map()
		this.transientProfilesObject = { profiles: [], emptyWindows: new Map() }
		;(this.profilesHome = ct(this.environmentService.userRoamingDataHome, "profiles")),
			(this.profilesCacheHome = ct(this.environmentService.cacheHome, "CachedProfilesData"))
	}
	static {
		this.PROFILES_KEY = "userDataProfiles"
	}
	static {
		this.PROFILE_ASSOCIATIONS_KEY = "profileAssociations"
	}
	get defaultProfile() {
		return this.profiles[0]
	}
	get profiles() {
		return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles]
	}
	init() {
		this._profilesObject = void 0
	}
	get profilesObject() {
		if (!this._profilesObject) {
			let t = this.createDefaultProfile(),
				n = [t]
			try {
				for (let i of this.getStoredProfiles()) {
					if (!i.name || !we(i.name) || !i.location) {
						this.logService.warn("Skipping the invalid stored profile", i.location || i.name)
						continue
					}
					n.push(
						by(
							Ht(i.location),
							i.name,
							i.location,
							this.profilesCacheHome,
							{ icon: i.icon, useDefaultFlags: i.useDefaultFlags },
							t,
						),
					)
				}
			} catch (i) {
				this.logService.error(i)
			}
			let r = new Map()
			if (n.length)
				try {
					let i = this.getStoredProfileAssociations()
					if (i.workspaces)
						for (let [s, a] of Object.entries(i.workspaces)) {
							let l = b.parse(s),
								d = n.find((c) => c.id === a)
							if (d) {
								let c = d.workspaces ? d.workspaces.slice(0) : []
								c.push(l), (d.workspaces = c)
							}
						}
					if (i.emptyWindows)
						for (let [s, a] of Object.entries(i.emptyWindows)) {
							let l = n.find((d) => d.id === a)
							l && r.set(s, l)
						}
				} catch (i) {
					this.logService.error(i)
				}
			this._profilesObject = { profiles: n, emptyWindows: r }
		}
		return this._profilesObject
	}
	createDefaultProfile() {
		let t = by(
			"__default__profile__",
			p("defaultProfile", "Default"),
			this.environmentService.userRoamingDataHome,
			this.profilesCacheHome,
		)
		return {
			...t,
			extensionsResource: this.getDefaultProfileExtensionsLocation() ?? t.extensionsResource,
			isDefault: !0,
		}
	}
	async createTransientProfile(t) {
		let n = "Temp",
			r = new RegExp(`${kr(n)}\\s(\\d+)`),
			i = 0
		for (let a of this.profiles) {
			let l = r.exec(a.name),
				d = l ? parseInt(l[1]) : 0
			i = d > i ? d : i
		}
		let s = `${n} ${i + 1}`
		return this.createProfile(lr(He()).toString(16), s, { transient: !0 }, t)
	}
	async createNamedProfile(t, n, r) {
		return this.createProfile(lr(He()).toString(16), t, n, r)
	}
	async createProfile(t, n, r, i) {
		return await this.doCreateProfile(t, n, r, i)
	}
	async doCreateProfile(t, n, r, i) {
		if (!we(n) || !n) throw new Error("Name of the profile is mandatory and must be of type `string`")
		let s = this.profileCreationPromises.get(n)
		return (
			s ||
				((s = (async () => {
					try {
						if (this.profiles.find((u) => u.id === t || (!u.isTransient && !r?.transient && u.name === n)))
							throw new Error(`Profile with ${n} name already exists`)
						let l = i ? this.getWorkspace(i) : void 0
						b.isUri(l) && (r = { ...r, workspaces: [l] })
						let d = by(t, n, ct(this.profilesHome, t), this.profilesCacheHome, r, this.defaultProfile)
						await this.fileService.createFolder(d.location)
						let c = []
						return (
							this._onWillCreateProfile.fire({
								profile: d,
								join(u) {
									c.push(u)
								},
							}),
							await lo.settled(c),
							l && !b.isUri(l) && this.updateEmptyWindowAssociation(l, d, !!d.isTransient),
							this.updateProfiles([d], [], []),
							d
						)
					} finally {
						this.profileCreationPromises.delete(n)
					}
				})()),
				this.profileCreationPromises.set(n, s)),
			s
		)
	}
	async updateProfile(t, n) {
		let r = []
		for (let s of this.profiles) {
			let a
			if (t.id === s.id)
				s.isDefault
					? n.workspaces && ((a = s), (a.workspaces = n.workspaces))
					: (a = by(
							s.id,
							n.name ?? s.name,
							s.location,
							this.profilesCacheHome,
							{
								icon: n.icon === null ? void 0 : (n.icon ?? s.icon),
								transient: n.transient ?? s.isTransient,
								useDefaultFlags: n.useDefaultFlags ?? s.useDefaultFlags,
								workspaces: n.workspaces ?? s.workspaces,
							},
							this.defaultProfile,
						))
			else if (n.workspaces) {
				let l = s.workspaces?.filter(
					(d) => !n.workspaces?.some((c) => this.uriIdentityService.extUri.isEqual(d, c)),
				)
				s.workspaces?.length !== l?.length && ((a = s), (a.workspaces = l))
			}
			a && r.push(a)
		}
		if (!r.length)
			throw t.isDefault
				? new Error("Cannot update default profile")
				: new Error(`Profile '${t.name}' does not exist`)
		this.updateProfiles([], [], r)
		let i = this.profiles.find((s) => s.id === t.id)
		if (!i) throw new Error(`Profile '${t.name}' was not updated`)
		return i
	}
	async removeProfile(t) {
		if (t.isDefault) throw new Error("Cannot remove default profile")
		let n = this.profiles.find((i) => i.id === t.id)
		if (!n) throw new Error(`Profile '${t.name}' does not exist`)
		let r = []
		this._onWillRemoveProfile.fire({
			profile: n,
			join(i) {
				r.push(i)
			},
		})
		try {
			await Promise.allSettled(r)
		} catch (i) {
			this.logService.error(i)
		}
		this.updateProfiles([], [n], [])
		try {
			await this.fileService.del(n.cacheHome, { recursive: !0 })
		} catch (i) {
			hL(i) !== 1 && this.logService.error(i)
		}
	}
	async setProfileForWorkspace(t, n) {
		let r = this.profiles.find((s) => s.id === n.id)
		if (!r) throw new Error(`Profile '${n.name}' does not exist`)
		let i = this.getWorkspace(t)
		if (b.isUri(i)) {
			let s = r.workspaces ? [...r.workspaces] : []
			s.some((a) => this.uriIdentityService.extUri.isEqual(a, i)) ||
				(s.push(i), await this.updateProfile(r, { workspaces: s }))
		} else this.updateEmptyWindowAssociation(i, r, !1), this.updateStoredProfiles(this.profiles)
	}
	unsetWorkspace(t, n = !1) {
		let r = this.getWorkspace(t)
		if (b.isUri(r)) {
			let i = this.getProfileForWorkspace(t)
			i &&
				this.updateProfile(i, {
					workspaces: i.workspaces?.filter((s) => !this.uriIdentityService.extUri.isEqual(s, r)),
				})
		} else this.updateEmptyWindowAssociation(r, void 0, n), this.updateStoredProfiles(this.profiles)
	}
	async resetWorkspaces() {
		this.transientProfilesObject.emptyWindows.clear(), this.profilesObject.emptyWindows.clear()
		for (let t of this.profiles) t.workspaces = void 0
		this.updateProfiles([], [], this.profiles), this._onDidResetWorkspaces.fire()
	}
	async cleanUp() {
		if (await this.fileService.exists(this.profilesHome)) {
			let t = await this.fileService.resolve(this.profilesHome)
			await Promise.all(
				(t.children || [])
					.filter(
						(n) =>
							n.isDirectory &&
							this.profiles.every((r) => !this.uriIdentityService.extUri.isEqual(r.location, n.resource)),
					)
					.map((n) => this.fileService.del(n.resource, { recursive: !0 })),
			)
		}
	}
	async cleanUpTransientProfiles() {
		let t = this.transientProfilesObject.profiles.filter((n) => !this.isProfileAssociatedToWorkspace(n))
		await Promise.allSettled(t.map((n) => this.removeProfile(n)))
	}
	getProfileForWorkspace(t) {
		let n = this.getWorkspace(t)
		return b.isUri(n)
			? this.profiles.find((r) => r.workspaces?.some((i) => this.uriIdentityService.extUri.isEqual(i, n)))
			: (this.profilesObject.emptyWindows.get(n) ?? this.transientProfilesObject.emptyWindows.get(n))
	}
	getWorkspace(t) {
		return IL(t) ? t.uri : xL(t) ? t.configPath : t.id
	}
	isProfileAssociatedToWorkspace(t) {
		return !!(
			t.workspaces?.length ||
			[...this.profilesObject.emptyWindows.values()].some((n) =>
				this.uriIdentityService.extUri.isEqual(n.location, t.location),
			) ||
			[...this.transientProfilesObject.emptyWindows.values()].some((n) =>
				this.uriIdentityService.extUri.isEqual(n.location, t.location),
			)
		)
	}
	updateProfiles(t, n, r) {
		let i = [...this.profiles, ...t],
			s = this.transientProfilesObject.profiles
		this.transientProfilesObject.profiles = []
		let a = []
		for (let l of i) {
			if (n.some((d) => l.id === d.id)) {
				for (let d of [...this.profilesObject.emptyWindows.keys()])
					l.id === this.profilesObject.emptyWindows.get(d)?.id && this.profilesObject.emptyWindows.delete(d)
				continue
			}
			if (!l.isDefault) {
				l = r.find((c) => l.id === c.id) ?? l
				let d = s.find((c) => l.id === c.id)
				if (l.isTransient) this.transientProfilesObject.profiles.push(l)
				else if (d) {
					for (let [c, u] of this.transientProfilesObject.emptyWindows.entries())
						if (l.id === u.id) {
							this.transientProfilesObject.emptyWindows.delete(c),
								this.profilesObject.emptyWindows.set(c, l)
							break
						}
				}
			}
			l.workspaces?.length === 0 && (l.workspaces = void 0), a.push(l)
		}
		this.updateStoredProfiles(a), this.triggerProfilesChanges(t, n, r)
	}
	triggerProfilesChanges(t, n, r) {
		this._onDidChangeProfiles.fire({ added: t, removed: n, updated: r, all: this.profiles })
	}
	updateEmptyWindowAssociation(t, n, r) {
		;(r = n?.isTransient ? !0 : r),
			r
				? n
					? this.transientProfilesObject.emptyWindows.set(t, n)
					: this.transientProfilesObject.emptyWindows.delete(t)
				: (this.transientProfilesObject.emptyWindows.delete(t),
					n ? this.profilesObject.emptyWindows.set(t, n) : this.profilesObject.emptyWindows.delete(t))
	}
	updateStoredProfiles(t) {
		let n = [],
			r = {},
			i = {}
		for (let s of t)
			if (
				!s.isTransient &&
				(s.isDefault ||
					n.push({ location: s.location, name: s.name, icon: s.icon, useDefaultFlags: s.useDefaultFlags }),
				s.workspaces)
			)
				for (let a of s.workspaces) r[a.toString()] = s.id
		for (let [s, a] of this.profilesObject.emptyWindows.entries()) i[s.toString()] = a.id
		this.saveStoredProfileAssociations({ workspaces: r, emptyWindows: i }),
			this.saveStoredProfiles(n),
			(this._profilesObject = void 0)
	}
	getStoredProfiles() {
		return []
	}
	saveStoredProfiles(t) {
		throw new Error("not implemented")
	}
	getStoredProfileAssociations() {
		return {}
	}
	saveStoredProfileAssociations(t) {
		throw new Error("not implemented")
	}
	getDefaultProfileExtensionsLocation() {}
}
yy = R([S(0, ig), S(1, Tb), S(2, vy), S(3, te)], yy)
var YV = "__$__isNewStorageMarker",
	Iy = "__$__targetStorageMarker",
	xy = O("storageService")
function ZV(o) {
	let e = o.get(Iy)
	if (e)
		try {
			return JSON.parse(e)
		} catch {}
	return Object.create(null)
}
var ZM = class o extends $ {
	constructor(t = { flushInterval: o.DEFAULT_FLUSH_INTERVAL }) {
		super()
		this._onDidChangeValue = this._register(new ci())
		this._onDidChangeTarget = this._register(new ci())
		this.onDidChangeTarget = this._onDidChangeTarget.event
		this._onWillSaveState = this._register(new E())
		this.onWillSaveState = this._onWillSaveState.event
		this.runFlushWhenIdle = this._register(new kn())
		this._workspaceKeyTargets = void 0
		this._profileKeyTargets = void 0
		this._applicationKeyTargets = void 0
		this.flushWhenIdleScheduler = this._register(new Wn(() => this.doFlushWhenIdle(), t.flushInterval))
	}
	static {
		this.DEFAULT_FLUSH_INTERVAL = 60 * 1e3
	}
	onDidChangeValue(t, n, r) {
		return Ee.filter(this._onDidChangeValue.event, (i) => i.scope === t && (n === void 0 || i.key === n), r)
	}
	doFlushWhenIdle() {
		this.runFlushWhenIdle.value = jE(() => {
			this.shouldFlushWhenIdle() && this.flush(), this.flushWhenIdleScheduler.schedule()
		})
	}
	shouldFlushWhenIdle() {
		return !0
	}
	stopFlushWhenIdle() {
		Nn([this.runFlushWhenIdle, this.flushWhenIdleScheduler])
	}
	initialize() {
		return (
			this.initializationPromise ||
				(this.initializationPromise = (async () => {
					Ct("code/willInitStorage")
					try {
						await this.doInitialize()
					} finally {
						Ct("code/didInitStorage")
					}
					this.flushWhenIdleScheduler.schedule()
				})()),
			this.initializationPromise
		)
	}
	emitDidChangeValue(t, n) {
		let { key: r, external: i } = n
		if (r === Iy) {
			switch (t) {
				case -1:
					this._applicationKeyTargets = void 0
					break
				case 0:
					this._profileKeyTargets = void 0
					break
				case 1:
					this._workspaceKeyTargets = void 0
					break
			}
			this._onDidChangeTarget.fire({ scope: t })
		} else this._onDidChangeValue.fire({ scope: t, key: r, target: this.getKeyTargets(t)[r], external: i })
	}
	emitWillSaveState(t) {
		this._onWillSaveState.fire({ reason: t })
	}
	get(t, n, r) {
		return this.getStorage(n)?.get(t, r)
	}
	getBoolean(t, n, r) {
		return this.getStorage(n)?.getBoolean(t, r)
	}
	getNumber(t, n, r) {
		return this.getStorage(n)?.getNumber(t, r)
	}
	getObject(t, n, r) {
		return this.getStorage(n)?.getObject(t, r)
	}
	storeAll(t, n) {
		this.withPausedEmitters(() => {
			for (let r of t) this.store(r.key, r.value, r.scope, r.target, n)
		})
	}
	store(t, n, r, i, s = !1) {
		if (bt(n)) {
			this.remove(t, r, s)
			return
		}
		this.withPausedEmitters(() => {
			this.updateKeyTarget(t, r, i), this.getStorage(r)?.set(t, n, s)
		})
	}
	remove(t, n, r = !1) {
		this.withPausedEmitters(() => {
			this.updateKeyTarget(t, n, void 0), this.getStorage(n)?.delete(t, r)
		})
	}
	withPausedEmitters(t) {
		this._onDidChangeValue.pause(), this._onDidChangeTarget.pause()
		try {
			t()
		} finally {
			this._onDidChangeValue.resume(), this._onDidChangeTarget.resume()
		}
	}
	keys(t, n) {
		let r = [],
			i = this.getKeyTargets(t)
		for (let s of Object.keys(i)) i[s] === n && r.push(s)
		return r
	}
	updateKeyTarget(t, n, r, i = !1) {
		let s = this.getKeyTargets(n)
		typeof r == "number"
			? s[t] !== r && ((s[t] = r), this.getStorage(n)?.set(Iy, JSON.stringify(s), i))
			: typeof s[t] == "number" && (delete s[t], this.getStorage(n)?.set(Iy, JSON.stringify(s), i))
	}
	get workspaceKeyTargets() {
		return (
			this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(1)), this._workspaceKeyTargets
		)
	}
	get profileKeyTargets() {
		return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(0)), this._profileKeyTargets
	}
	get applicationKeyTargets() {
		return (
			this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(-1)),
			this._applicationKeyTargets
		)
	}
	getKeyTargets(t) {
		switch (t) {
			case -1:
				return this.applicationKeyTargets
			case 0:
				return this.profileKeyTargets
			default:
				return this.workspaceKeyTargets
		}
	}
	loadKeyTargets(t) {
		let n = this.getStorage(t)
		return n ? ZV(n) : Object.create(null)
	}
	isNew(t) {
		return this.getBoolean(YV, t) === !0
	}
	async flush(t = 0) {
		this._onWillSaveState.fire({ reason: t })
		let n = this.getStorage(-1),
			r = this.getStorage(0),
			i = this.getStorage(1)
		switch (t) {
			case 0:
				await lo.settled([
					n?.whenFlushed() ?? Promise.resolve(),
					r?.whenFlushed() ?? Promise.resolve(),
					i?.whenFlushed() ?? Promise.resolve(),
				])
				break
			case 1:
				await lo.settled([
					n?.flush(0) ?? Promise.resolve(),
					r?.flush(0) ?? Promise.resolve(),
					i?.flush(0) ?? Promise.resolve(),
				])
				break
		}
	}
	async log() {
		let t = this.getStorage(-1)?.items ?? new Map(),
			n = this.getStorage(0)?.items ?? new Map(),
			r = this.getStorage(1)?.items ?? new Map()
		return e7(t, n, r, this.getLogDetails(-1) ?? "", this.getLogDetails(0) ?? "", this.getLogDetails(1) ?? "")
	}
	async optimize(t) {
		return await this.flush(), this.getStorage(t)?.optimize()
	}
	async switch(t, n) {
		return this.emitWillSaveState(0), XM(t) ? this.switchToProfile(t, n) : this.switchToWorkspace(t, n)
	}
	canSwitchProfile(t, n) {
		return !(t.id === n.id || (eF(n) && eF(t)))
	}
	switchData(t, n, r) {
		this.withPausedEmitters(() => {
			let i = new Set()
			for (let [s, a] of t) i.add(s), n.get(s) !== a && this.emitDidChangeValue(r, { key: s, external: !0 })
			for (let [s] of n.items) i.has(s) || this.emitDidChangeValue(r, { key: s, external: !0 })
		})
	}
}
function eF(o) {
	return o.isDefault || !!o.useDefaultFlags?.globalState
}
async function e7(o, e, t, n, r, i) {
	let s = (g) => {
			try {
				return JSON.parse(g)
			} catch {
				return g
			}
		},
		a = new Map(),
		l = new Map()
	o.forEach((g, I) => {
		a.set(I, g), l.set(I, s(g))
	})
	let d = new Map(),
		c = new Map()
	e.forEach((g, I) => {
		d.set(I, g), c.set(I, s(g))
	})
	let u = new Map(),
		m = new Map()
	t.forEach((g, I) => {
		u.set(I, g), m.set(I, s(g))
	}),
		console.group(
			n !== r
				? `Storage: Application (path: ${n})`
				: `Storage: Application & Profile (path: ${n}, default profile)`,
		)
	let f = []
	if (
		(a.forEach((g, I) => {
			f.push({ key: I, value: g })
		}),
		console.table(f),
		console.groupEnd(),
		console.log(l),
		n !== r)
	) {
		console.group(`Storage: Profile (path: ${r}, profile specific)`)
		let g = []
		d.forEach((I, C) => {
			g.push({ key: C, value: I })
		}),
			console.table(g),
			console.groupEnd(),
			console.log(c)
	}
	console.group(`Storage: Workspace (path: ${i})`)
	let h = []
	u.forEach((g, I) => {
		h.push({ key: I, value: g })
	}),
		console.table(h),
		console.groupEnd(),
		console.log(m)
}
var Mne = new D("isMac", st, p("isMac", "Whether the operating system is macOS")),
	Fne = new D("isLinux", Ve, p("isLinux", "Whether the operating system is Linux")),
	Nne = new D("isWindows", Ie, p("isWindows", "Whether the operating system is Windows")),
	tF = new D("isWeb", Oo, p("isWeb", "Whether the platform is a web browser")),
	Une = new D(
		"isMacNative",
		st && !Oo,
		p("isMacNative", "Whether the operating system is macOS on a non-browser platform"),
	),
	Hne = new D("isIOS", MA, p("isIOS", "Whether the operating system is iOS")),
	Wne = new D("isMobile", FA, p("isMobile", "Whether the platform is a mobile web browser")),
	Vne = new D("isDevelopment", !1, !0),
	Bne = new D("productQualityType", "", p("productQualityType", "Quality type of VS Code")),
	t7 = "inputFocus",
	$ne = new D(t7, !1, p("inputFocus", "Whether keyboard focus is inside an input box"))
var nF = O("languageService")
var rF = O("modelService")
var ire = new D("workbenchState", void 0, {
		type: "string",
		description: p(
			"workbenchState",
			"The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)",
		),
	}),
	sre = new D("workspaceFolderCount", 0, p("workspaceFolderCount", "The number of root folders in the workspace")),
	are = new D("openFolderWorkspaceSupport", !0, !0),
	lre = new D("enterMultiRootWorkspaceSupport", !0, !0),
	dre = new D("emptyWorkspaceSupport", !0, !0),
	cre = new D(
		"dirtyWorkingCopies",
		!1,
		p("dirtyWorkingCopies", "Whether there are any working copies with unsaved changes"),
	),
	oF = new D(
		"remoteName",
		"",
		p(
			"remoteName",
			"The name of the remote the window is connected to or an empty string if not connected to any remote",
		),
	),
	ure = new D(
		"virtualWorkspace",
		"",
		p("virtualWorkspace", "The scheme of the current workspace is from a virtual file system or an empty string."),
	),
	pre = new D(
		"temporaryWorkspace",
		!1,
		p("temporaryWorkspace", "The scheme of the current workspace is from a temporary file system."),
	),
	mre = new D("isFullscreen", !1, p("isFullscreen", "Whether the main window is in fullscreen mode")),
	fre = new D(
		"isAuxiliaryWindowFocusedContext",
		!1,
		p("isAuxiliaryWindowFocusedContext", "Whether an auxiliary window is focused"),
	),
	gre = new D("hasWebFileSystemAccess", !1, !0),
	hre = new D(
		"embedderIdentifier",
		void 0,
		p("embedderIdentifier", "The identifier of the embedder according to the product service, if one is defined"),
	),
	vre = new D("activeEditorIsDirty", !1, p("activeEditorIsDirty", "Whether the active editor has unsaved changes")),
	bre = new D(
		"activeEditorIsNotPreview",
		!1,
		p("activeEditorIsNotPreview", "Whether the active editor is not in preview mode"),
	),
	yre = new D(
		"activeEditorIsFirstInGroup",
		!1,
		p("activeEditorIsFirstInGroup", "Whether the active editor is the first one in its group"),
	),
	Ire = new D(
		"activeEditorIsLastInGroup",
		!1,
		p("activeEditorIsLastInGroup", "Whether the active editor is the last one in its group"),
	),
	xre = new D("activeEditorIsPinned", !1, p("activeEditorIsPinned", "Whether the active editor is pinned")),
	Cre = new D("activeEditorIsReadonly", !1, p("activeEditorIsReadonly", "Whether the active editor is read-only")),
	Sre = new D(
		"activeCompareEditorCanSwap",
		!1,
		p("activeCompareEditorCanSwap", "Whether the active compare editor can swap sides"),
	),
	Tre = new D(
		"activeEditorCanToggleReadonly",
		!0,
		p("activeEditorCanToggleReadonly", "Whether the active editor can toggle between being read-only or writeable"),
	),
	Ere = new D("activeEditorCanRevert", !1, p("activeEditorCanRevert", "Whether the active editor can revert")),
	wre = new D("activeEditorCanSplitInGroup", !0),
	Pre = new D("activeEditor", null, {
		type: "string",
		description: p("activeEditor", "The identifier of the active editor"),
	}),
	_re = new D(
		"activeEditorAvailableEditorIds",
		"",
		p("activeEditorAvailableEditorIds", "The available editor identifiers that are usable for the active editor"),
	),
	Dre = new D(
		"textCompareEditorVisible",
		!1,
		p("textCompareEditorVisible", "Whether a text compare editor is visible"),
	),
	kre = new D("textCompareEditorActive", !1, p("textCompareEditorActive", "Whether a text compare editor is active")),
	Rre = new D("sideBySideEditorActive", !1, p("sideBySideEditorActive", "Whether a side by side editor is active")),
	Are = new D("groupEditorsCount", 0, p("groupEditorsCount", "The number of opened editor groups")),
	Ore = new D("activeEditorGroupEmpty", !1, p("activeEditorGroupEmpty", "Whether the active editor group is empty")),
	Lre = new D("activeEditorGroupIndex", 0, p("activeEditorGroupIndex", "The index of the active editor group")),
	Mre = new D(
		"activeEditorGroupLast",
		!1,
		p("activeEditorGroupLast", "Whether the active editor group is the last group"),
	),
	Fre = new D(
		"activeEditorGroupLocked",
		!1,
		p("activeEditorGroupLocked", "Whether the active editor group is locked"),
	),
	n7 = new D(
		"multipleEditorGroups",
		!1,
		p("multipleEditorGroups", "Whether there are multiple editor groups opened"),
	),
	Nre = n7.toNegated(),
	Ure = new D(
		"multipleEditorsSelectedInGroup",
		!1,
		p("multipleEditorsSelectedInGroup", "Whether multiple editors have been selected in an editor group"),
	),
	Hre = new D(
		"twoEditorsSelectedInGroup",
		!1,
		p("twoEditorsSelectedInGroup", "Whether exactly two editors have been selected in an editor group"),
	),
	Wre = new D(
		"SelectedEditorsInGroupFileOrUntitledResourceContextKey",
		!0,
		p(
			"SelectedEditorsInGroupFileOrUntitledResourceContextKey",
			"Whether all selected editors in a group have a file or untitled resource associated",
		),
	),
	r7 = new D(
		"editorPartMultipleEditorGroups",
		!1,
		p("editorPartMultipleEditorGroups", "Whether there are multiple editor groups opened in an editor part"),
	),
	Vre = r7.toNegated(),
	Bre = new D(
		"editorPartMaximizedEditorGroup",
		!1,
		p("editorPartEditorGroupMaximized", "Editor Part has a maximized group"),
	),
	$re = new D("isAuxiliaryEditorPart", !1, p("isAuxiliaryEditorPart", "Editor Part is in an auxiliary window")),
	zre = new D("editorIsOpen", !1, p("editorIsOpen", "Whether an editor is open")),
	qre = new D("inZenMode", !1, p("inZenMode", "Whether Zen mode is enabled")),
	Kre = new D(
		"isCenteredLayout",
		!1,
		p("isMainEditorCenteredLayout", "Whether centered layout is enabled for the main editor"),
	),
	jre = new D("splitEditorsVertically", !1, p("splitEditorsVertically", "Whether editors split vertically")),
	Gre = new D(
		"mainEditorAreaVisible",
		!0,
		p("mainEditorAreaVisible", "Whether the editor area in the main window is visible"),
	),
	Qre = new D("editorTabsVisible", !0, p("editorTabsVisible", "Whether editor tabs are visible")),
	Jre = new D("sideBarVisible", !1, p("sideBarVisible", "Whether the sidebar is visible")),
	Xre = new D("sideBarFocus", !1, p("sideBarFocus", "Whether the sidebar has keyboard focus")),
	Yre = new D("activeViewlet", "", p("activeViewlet", "The identifier of the active viewlet")),
	Zre = new D("statusBarFocused", !1, p("statusBarFocused", "Whether the status bar has keyboard focus")),
	eoe = new D("titleBarStyle", "custom", p("titleBarStyle", "Style of the window title bar")),
	toe = new D("titleBarVisible", !1, p("titleBarVisible", "Whether the title bar is visible")),
	noe = new D("bannerFocused", !1, p("bannerFocused", "Whether the banner has keyboard focus")),
	roe = new D("notificationFocus", !0, p("notificationFocus", "Whether a notification has keyboard focus")),
	ooe = new D(
		"notificationCenterVisible",
		!1,
		p("notificationCenterVisible", "Whether the notifications center is visible"),
	),
	ioe = new D(
		"notificationToastsVisible",
		!1,
		p("notificationToastsVisible", "Whether a notification toast is visible"),
	),
	soe = new D("activeAuxiliary", "", p("activeAuxiliary", "The identifier of the active auxiliary panel")),
	aoe = new D("auxiliaryBarFocus", !1, p("auxiliaryBarFocus", "Whether the auxiliary bar has keyboard focus")),
	loe = new D("auxiliaryBarVisible", !1, p("auxiliaryBarVisible", "Whether the auxiliary bar is visible")),
	doe = new D("activePanel", "", p("activePanel", "The identifier of the active panel")),
	coe = new D("panelFocus", !1, p("panelFocus", "Whether the panel has keyboard focus")),
	uoe = new D("panelPosition", "bottom", p("panelPosition", "The position of the panel, always 'bottom'")),
	poe = new D(
		"panelAlignment",
		"center",
		p("panelAlignment", "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"),
	),
	moe = new D("panelVisible", !1, p("panelVisible", "Whether the panel is visible")),
	foe = new D("panelMaximized", !1, p("panelMaximized", "Whether the panel is maximized")),
	goe = new D("focusedView", "", p("focusedView", "The identifier of the view that has keyboard focus"))
var Fr = class {
	constructor(e, t, n, r) {
		this._contextKeyService = e
		this._fileService = t
		this._languageService = n
		this._modelService = r
		this._disposables = new Q()
		;(this._schemeKey = Fr.Scheme.bindTo(this._contextKeyService)),
			(this._filenameKey = Fr.Filename.bindTo(this._contextKeyService)),
			(this._dirnameKey = Fr.Dirname.bindTo(this._contextKeyService)),
			(this._pathKey = Fr.Path.bindTo(this._contextKeyService)),
			(this._langIdKey = Fr.LangId.bindTo(this._contextKeyService)),
			(this._resourceKey = Fr.Resource.bindTo(this._contextKeyService)),
			(this._extensionKey = Fr.Extension.bindTo(this._contextKeyService)),
			(this._hasResource = Fr.HasResource.bindTo(this._contextKeyService)),
			(this._isFileSystemResource = Fr.IsFileSystemResource.bindTo(this._contextKeyService)),
			this._disposables.add(
				t.onDidChangeFileSystemProviderRegistrations(() => {
					let i = this.get()
					this._isFileSystemResource.set(!!(i && t.hasProvider(i)))
				}),
			),
			this._disposables.add(
				r.onModelAdded((i) => {
					jr(i.uri, this.get()) && this._setLangId()
				}),
			),
			this._disposables.add(
				r.onModelLanguageChanged((i) => {
					jr(i.model.uri, this.get()) && this._setLangId()
				}),
			)
	}
	static {
		this.Scheme = new D("resourceScheme", void 0, {
			type: "string",
			description: p("resourceScheme", "The scheme of the resource"),
		})
	}
	static {
		this.Filename = new D("resourceFilename", void 0, {
			type: "string",
			description: p("resourceFilename", "The file name of the resource"),
		})
	}
	static {
		this.Dirname = new D("resourceDirname", void 0, {
			type: "string",
			description: p("resourceDirname", "The folder name the resource is contained in"),
		})
	}
	static {
		this.Path = new D("resourcePath", void 0, {
			type: "string",
			description: p("resourcePath", "The full path of the resource"),
		})
	}
	static {
		this.LangId = new D("resourceLangId", void 0, {
			type: "string",
			description: p("resourceLangId", "The language identifier of the resource"),
		})
	}
	static {
		this.Resource = new D("resource", void 0, {
			type: "URI",
			description: p("resource", "The full value of the resource including scheme and path"),
		})
	}
	static {
		this.Extension = new D("resourceExtname", void 0, {
			type: "string",
			description: p("resourceExtname", "The extension name of the resource"),
		})
	}
	static {
		this.HasResource = new D("resourceSet", void 0, {
			type: "boolean",
			description: p("resourceSet", "Whether a resource is present or not"),
		})
	}
	static {
		this.IsFileSystemResource = new D("isFileSystemResource", void 0, {
			type: "boolean",
			description: p("isFileSystemResource", "Whether the resource is backed by a file system provider"),
		})
	}
	dispose() {
		this._disposables.dispose()
	}
	_setLangId() {
		let e = this.get()
		if (!e) {
			this._langIdKey.set(null)
			return
		}
		let t =
			this._modelService.getModel(e)?.getLanguageId() ??
			this._languageService.guessLanguageIdByFilepathOrFirstLine(e)
		this._langIdKey.set(t)
	}
	set(e) {
		;(e = e ?? void 0),
			!jr(this._value, e) &&
				((this._value = e),
				this._contextKeyService.bufferChangeEvents(() => {
					this._resourceKey.set(e ? e.toString() : null),
						this._schemeKey.set(e ? e.scheme : null),
						this._filenameKey.set(e ? Ht(e) : null),
						this._dirnameKey.set(e ? this.uriToPath(ts(e)) : null),
						this._pathKey.set(e ? this.uriToPath(e) : null),
						this._setLangId(),
						this._extensionKey.set(e ? Gv(e) : null),
						this._hasResource.set(!!e),
						this._isFileSystemResource.set(e ? this._fileService.hasProvider(e) : !1)
				}))
	}
	uriToPath(e) {
		return e.scheme === W.file ? e.fsPath : e.path
	}
	reset() {
		;(this._value = void 0),
			this._contextKeyService.bufferChangeEvents(() => {
				this._resourceKey.reset(),
					this._schemeKey.reset(),
					this._filenameKey.reset(),
					this._dirnameKey.reset(),
					this._pathKey.reset(),
					this._langIdKey.reset(),
					this._extensionKey.reset(),
					this._hasResource.reset(),
					this._isFileSystemResource.reset()
			})
	}
	get() {
		return this._value
	}
}
Fr = R([S(0, ma), S(1, Tb), S(2, nF), S(3, rF)], Fr)
var dd = ((r) => ((r.Panel = "panel"), (r.Terminal = "terminal"), (r.Notebook = "notebook"), (r.Editor = "editor"), r))(
	dd || {},
)
;((e) => {
	function o(t) {
		switch (t) {
			case "panel":
				return "panel"
			case "terminal":
				return "terminal"
			case "notebook":
				return "notebook"
			case "editor":
				return "editor"
		}
		return "panel"
	}
	e.fromRaw = o
})((dd ||= {}))
var vs
;((de) => (
	(de.responseVote = new D("chatSessionResponseVote", "", {
		type: "string",
		description: p(
			"interactiveSessionResponseVote",
			"When the response has been voted up, is set to 'up'. When voted down, is set to 'down'. Otherwise an empty string.",
		),
	})),
	(de.responseDetectedAgentCommand = new D("chatSessionResponseDetectedAgentOrCommand", !1, {
		type: "boolean",
		description: p(
			"chatSessionResponseDetectedAgentOrCommand",
			"When the agent or command was automatically detected",
		),
	})),
	(de.responseSupportsIssueReporting = new D("chatResponseSupportsIssueReporting", !1, {
		type: "boolean",
		description: p(
			"chatResponseSupportsIssueReporting",
			"True when the current chat response supports issue reporting.",
		),
	})),
	(de.responseIsFiltered = new D("chatSessionResponseFiltered", !1, {
		type: "boolean",
		description: p("chatResponseFiltered", "True when the chat response was filtered out by the server."),
	})),
	(de.responseHasError = new D("chatSessionResponseError", !1, {
		type: "boolean",
		description: p("chatResponseErrored", "True when the chat response resulted in an error."),
	})),
	(de.requestInProgress = new D("chatSessionRequestInProgress", !1, {
		type: "boolean",
		description: p("interactiveSessionRequestInProgress", "True when the current request is still in progress."),
	})),
	(de.isRequestPaused = new D("chatRequestIsPaused", !1, {
		type: "boolean",
		description: p("chatRequestIsPaused", "True when the current request is paused."),
	})),
	(de.canRequestBePaused = new D("chatCanRequestBePaused", !1, {
		type: "boolean",
		description: p("chatCanRequestBePaused", "True when the current request can be paused."),
	})),
	(de.isResponse = new D("chatResponse", !1, {
		type: "boolean",
		description: p("chatResponse", "The chat item is a response."),
	})),
	(de.isRequest = new D("chatRequest", !1, {
		type: "boolean",
		description: p("chatRequest", "The chat item is a request"),
	})),
	(de.itemId = new D("chatItemId", "", { type: "string", description: p("chatItemId", "The id of the chat item.") })),
	(de.lastItemId = new D("chatLastItemId", [], {
		type: "string",
		description: p("chatLastItemId", "The id of the last chat item."),
	})),
	(de.editApplied = new D("chatEditApplied", !1, {
		type: "boolean",
		description: p("chatEditApplied", "True when the chat text edits have been applied."),
	})),
	(de.inputHasText = new D("chatInputHasText", !1, {
		type: "boolean",
		description: p("interactiveInputHasText", "True when the chat input has text."),
	})),
	(de.inputHasFocus = new D("chatInputHasFocus", !1, {
		type: "boolean",
		description: p("interactiveInputHasFocus", "True when the chat input has focus."),
	})),
	(de.inChatInput = new D("inChatInput", !1, {
		type: "boolean",
		description: p("inInteractiveInput", "True when focus is in the chat input, false otherwise."),
	})),
	(de.inChatSession = new D("inChat", !1, {
		type: "boolean",
		description: p("inChat", "True when focus is in the chat widget, false otherwise."),
	})),
	(de.instructionsAttached = new D("chatInstructionsAttached", !1, {
		type: "boolean",
		description: p(
			"chatInstructionsAttachedContextDescription",
			"True when the chat has a prompt instructions attached.",
		),
	})),
	(de.chatMode = new D("chatMode", "ask", { type: "string", description: p("chatMode", "The current chat mode.") })),
	(de.supported = Lt.or(tF.toNegated(), oF.notEqualsTo(""))),
	(de.enabled = new D("chatIsEnabled", !1, {
		type: "boolean",
		description: p(
			"chatIsEnabled",
			"True when chat is enabled because a default chat participant is activated with an implementation.",
		),
	})),
	(de.panelParticipantRegistered = new D("chatPanelParticipantRegistered", !1, {
		type: "boolean",
		description: p(
			"chatParticipantRegistered",
			"True when a default chat participant is registered for the panel.",
		),
	})),
	(de.editingParticipantRegistered = new D("chatEditingParticipantRegistered", !1, {
		type: "boolean",
		description: p(
			"chatEditingParticipantRegistered",
			"True when a default chat participant is registered for editing.",
		),
	})),
	(de.chatEditingCanUndo = new D("chatEditingCanUndo", !1, {
		type: "boolean",
		description: p("chatEditingCanUndo", "True when it is possible to undo an interaction in the editing panel."),
	})),
	(de.chatEditingCanRedo = new D("chatEditingCanRedo", !1, {
		type: "boolean",
		description: p("chatEditingCanRedo", "True when it is possible to redo an interaction in the editing panel."),
	})),
	(de.extensionInvalid = new D("chatExtensionInvalid", !1, {
		type: "boolean",
		description: p(
			"chatExtensionInvalid",
			"True when the installed chat extension is invalid and needs to be updated.",
		),
	})),
	(de.inputCursorAtTop = new D("chatCursorAtTop", !1)),
	(de.inputHasAgent = new D("chatInputHasAgent", !1)),
	(de.location = new D("chatLocation", void 0)),
	(de.inQuickChat = new D("quickChatHasFocus", !1, {
		type: "boolean",
		description: p("inQuickChat", "True when the quick chat UI has focus, false otherwise."),
	})),
	(de.hasFileAttachments = new D("chatHasFileAttachments", !1, {
		type: "boolean",
		description: p("chatHasFileAttachments", "True when the chat has file attachments."),
	})),
	(de.languageModelsAreUserSelectable = new D("chatModelsAreUserSelectable", !1, {
		type: "boolean",
		description: p("chatModelsAreUserSelectable", "True when the chat model can be selected manually by the user."),
	})),
	(de.Setup = { hidden: new D("chatSetupHidden", !1, !0), installed: new D("chatSetupInstalled", !1, !0) }),
	(de.Entitlement = {
		signedOut: new D("chatSetupSignedOut", !1, !0),
		canSignUp: new D("chatPlanCanSignUp", !1, !0),
		limited: new D("chatPlanLimited", !1, !0),
		pro: new D("chatPlanPro", !1, !0),
	}),
	(de.chatQuotaExceeded = new D("chatQuotaExceeded", !1, !0)),
	(de.completionsQuotaExceeded = new D("completionsQuotaExceeded", !1, !0)),
	(de.Editing = {
		agentModeDisallowed: new D("chatAgentModeDisallowed", void 0, {
			type: "boolean",
			description: p("chatAgentModeDisallowed", "True when agent mode is not allowed."),
		}),
		hasToolConfirmation: new D("chatHasToolConfirmation", !1, {
			type: "boolean",
			description: p("chatEditingHasToolConfirmation", "True when a tool confirmation is present."),
		}),
	}),
	(de.Tools = {
		toolsCount: new D("toolsCount", 0, {
			type: "number",
			description: p("toolsCount", "The count of tools available in the chat."),
		}),
	})
))((vs ||= {}))
var o7
;((e) => (e.inEditingMode = Lt.or(vs.chatMode.isEqualTo("edit"), vs.chatMode.isEqualTo("agent"))))((o7 ||= {}))
var aF = O("chatAgentService"),
	Cy = class extends $ {
		constructor(t) {
			super()
			this.contextKeyService = t
			this._agents = new Map()
			this._onDidChangeAgents = new E()
			this.onDidChangeAgents = this._onDidChangeAgents.event
			this._agentsContextKeys = new Set()
			this._hasToolsAgent = !1
			this._chatParticipantDetectionProviders = new Map()
			this._agentCompletionProviders = new Map()
			;(this._hasDefaultAgent = vs.enabled.bindTo(this.contextKeyService)),
				(this._defaultAgentRegistered = vs.panelParticipantRegistered.bindTo(this.contextKeyService)),
				(this._editingAgentRegistered = vs.editingParticipantRegistered.bindTo(this.contextKeyService)),
				this._register(
					t.onDidChangeContext((n) => {
						n.affectsSome(this._agentsContextKeys) && this._updateContextKeys()
					}),
				)
		}
		static {
			this.AGENT_LEADER = "@"
		}
		registerAgent(t, n) {
			if (this.getAgent(t)) throw new Error(`Agent already registered: ${JSON.stringify(t)}`)
			let i = this,
				s = n.slashCommands
			n = {
				...n,
				get slashCommands() {
					return s.filter((l) => !l.when || i.contextKeyService.contextMatchesRules(Lt.deserialize(l.when)))
				},
			}
			let a = { data: n }
			return (
				this._agents.set(t, a),
				this._updateAgentsContextKeys(),
				this._updateContextKeys(),
				this._onDidChangeAgents.fire(void 0),
				q(() => {
					this._agents.delete(t),
						this._updateAgentsContextKeys(),
						this._updateContextKeys(),
						this._onDidChangeAgents.fire(void 0)
				})
			)
		}
		_updateAgentsContextKeys() {
			this._agentsContextKeys.clear()
			for (let t of this._agents.values())
				if (t.data.when) {
					let n = Lt.deserialize(t.data.when)
					for (let r of n?.keys() || []) this._agentsContextKeys.add(r)
				}
		}
		_updateContextKeys() {
			let t = !1,
				n = !1,
				r = !1
			for (let i of this.getAgents())
				i.isDefault && (i.modes.includes("agent") ? (r = !0) : i.modes.includes("edit") ? (t = !0) : (n = !0))
			this._editingAgentRegistered.set(t),
				this._defaultAgentRegistered.set(n),
				r !== this._hasToolsAgent &&
					((this._hasToolsAgent = r), this._onDidChangeAgents.fire(this.getDefaultAgent("panel", "agent")))
		}
		registerAgentImplementation(t, n) {
			let r = this._agents.get(t)
			if (!r) throw new Error(`Unknown agent: ${JSON.stringify(t)}`)
			if (r.impl) throw new Error(`Agent already has implementation: ${JSON.stringify(t)}`)
			return (
				r.data.isDefault && this._hasDefaultAgent.set(!0),
				(r.impl = n),
				this._onDidChangeAgents.fire(new ou(r.data, n)),
				q(() => {
					;(r.impl = void 0),
						this._onDidChangeAgents.fire(void 0),
						r.data.isDefault && this._hasDefaultAgent.set(!1)
				})
			)
		}
		registerDynamicAgent(t, n) {
			t.isDynamic = !0
			let r = { data: t, impl: n }
			return (
				this._agents.set(t.id, r),
				this._onDidChangeAgents.fire(new ou(t, n)),
				q(() => {
					this._agents.delete(t.id), this._onDidChangeAgents.fire(void 0)
				})
			)
		}
		registerAgentCompletionProvider(t, n) {
			return (
				this._agentCompletionProviders.set(t, n),
				{
					dispose: () => {
						this._agentCompletionProviders.delete(t)
					},
				}
			)
		}
		async getAgentCompletionItems(t, n, r) {
			return (await this._agentCompletionProviders.get(t)?.(n, r)) ?? []
		}
		updateAgent(t, n) {
			let r = this._agents.get(t)
			if (!r?.impl) throw new Error(`No activated agent with id ${JSON.stringify(t)} registered`)
			;(r.data.metadata = { ...r.data.metadata, ...n }), this._onDidChangeAgents.fire(new ou(r.data, r.impl))
		}
		getDefaultAgent(t, n = "ask") {
			return this._preferExtensionAgent(
				this.getActivatedAgents().filter((r) =>
					n && !r.modes.includes(n) ? !1 : !!r.isDefault && r.locations.includes(t),
				),
			)
		}
		get hasToolsAgent() {
			return !!this._hasToolsAgent
		}
		getContributedDefaultAgent(t) {
			return this._preferExtensionAgent(this.getAgents().filter((n) => !!n.isDefault && n.locations.includes(t)))
		}
		_preferExtensionAgent(t) {
			return z0(t, (n) => !n.isCore) ?? t.at(-1)
		}
		getAgent(t, n = !1) {
			if (!(!this._agentIsEnabled(t) && !n)) return this._agents.get(t)?.data
		}
		_agentIsEnabled(t) {
			let n = typeof t == "string" ? this._agents.get(t) : t
			return !n?.data.when || this.contextKeyService.contextMatchesRules(Lt.deserialize(n.data.when))
		}
		getAgentByFullyQualifiedId(t) {
			let n = Rt.find(this._agents.values(), (r) => s7(r.data) === t)?.data
			if (!(n && !this._agentIsEnabled(n.id))) return n
		}
		getAgents() {
			return Array.from(this._agents.values())
				.map((t) => t.data)
				.filter((t) => this._agentIsEnabled(t.id))
		}
		getActivatedAgents() {
			return Array.from(this._agents.values())
				.filter((t) => !!t.impl)
				.filter((t) => this._agentIsEnabled(t.data.id))
				.map((t) => new ou(t.data, t.impl))
		}
		getAgentsByName(t) {
			return this._preferExtensionAgents(this.getAgents().filter((n) => n.name === t))
		}
		_preferExtensionAgents(t) {
			let n = t.filter((r) => !r.isCore)
			return n.length > 0 ? n : t
		}
		agentHasDupeName(t) {
			let n = this.getAgent(t)
			return n
				? this.getAgentsByName(n.name).filter((r) => r.extensionId.value !== n.extensionId.value).length > 0
				: !1
		}
		async invokeAgent(t, n, r, i, s) {
			let a = this._agents.get(t)
			if (!a?.impl) throw new Error(`No activated agent with id "${t}"`)
			return await a.impl.invoke(n, r, i, s)
		}
		setRequestPaused(t, n, r) {
			let i = this._agents.get(t)
			if (!i?.impl) throw new Error(`No activated agent with id "${t}"`)
			i.impl.setRequestPaused?.(n, r)
		}
		async getFollowups(t, n, r, i, s) {
			let a = this._agents.get(t)
			if (!a?.impl) throw new Error(`No activated agent with id "${t}"`)
			return a.impl?.provideFollowups ? a.impl.provideFollowups(n, r, i, s) : []
		}
		async getChatTitle(t, n, r) {
			let i = this._agents.get(t)
			if (!i?.impl) throw new Error(`No activated agent with id "${t}"`)
			if (i.impl?.provideChatTitle) return i.impl.provideChatTitle(n, r)
		}
		registerChatParticipantDetectionProvider(t, n) {
			return (
				this._chatParticipantDetectionProviders.set(t, n),
				q(() => {
					this._chatParticipantDetectionProviders.delete(t)
				})
			)
		}
		hasChatParticipantDetectionProviders() {
			return this._chatParticipantDetectionProviders.size > 0
		}
		async detectAgentOrCommand(t, n, r, i) {
			let s = Rt.first(this._chatParticipantDetectionProviders.values())
			if (!s) return
			let a = this.getAgents().reduce((u, m) => {
					if (m.locations.includes(r.location)) {
						u.push({ participant: m.id, disambiguation: m.disambiguation ?? [] })
						for (let f of m.slashCommands)
							u.push({ participant: m.id, command: f.name, disambiguation: f.disambiguation ?? [] })
					}
					return u
				}, []),
				l = await s.provideParticipantDetection(t, n, { ...r, participants: a }, i)
			if (!l) return
			let d = this.getAgent(l.participant)
			if (!d) return
			if (!l.command) return { agent: d }
			let c = d?.slashCommands.find((u) => u.name === l.command)
			if (c) return { agent: d, command: c }
		}
	}
Cy = R([S(0, ma)], Cy)
var ou = class {
		constructor(e, t) {
			this.data = e
			this.impl = t
		}
		get id() {
			return this.data.id
		}
		get name() {
			return this.data.name ?? ""
		}
		get fullName() {
			return this.data.fullName ?? ""
		}
		get description() {
			return this.data.description ?? ""
		}
		get extensionId() {
			return this.data.extensionId
		}
		get extensionPublisherId() {
			return this.data.extensionPublisherId
		}
		get extensionPublisherDisplayName() {
			return this.data.publisherDisplayName
		}
		get extensionDisplayName() {
			return this.data.extensionDisplayName
		}
		get isDefault() {
			return this.data.isDefault
		}
		get isCore() {
			return this.data.isCore
		}
		get metadata() {
			return this.data.metadata
		}
		get slashCommands() {
			return this.data.slashCommands
		}
		get locations() {
			return this.data.locations
		}
		get modes() {
			return this.data.modes
		}
		get disambiguation() {
			return this.data.disambiguation
		}
		async invoke(e, t, n, r) {
			return this.impl.invoke(e, t, n, r)
		}
		setRequestPaused(e, t) {
			this.impl.setRequestPaused && this.impl.setRequestPaused(e, t)
		}
		async provideFollowups(e, t, n, r) {
			return this.impl.provideFollowups ? this.impl.provideFollowups(e, t, n, r) : []
		}
		provideSampleQuestions(e, t) {
			if (this.impl.provideSampleQuestions) return this.impl.provideSampleQuestions(e, t)
		}
		toJSON() {
			return this.data
		}
	},
	Goe = O("chatAgentNameService"),
	Ea = class {
		constructor(e, t, n, r) {
			this.requestService = t
			this.logService = n
			this.storageService = r
			this.registry = Sa(this, Object.create(null))
			this.disposed = !1
			if (!e.chatParticipantRegistry) return
			this.url = e.chatParticipantRegistry
			let i = r.get(Ea.StorageKey, -1)
			try {
				this.registry.set(JSON.parse(i ?? "{}"), void 0)
			} catch {
				r.remove(Ea.StorageKey, -1)
			}
			this.refresh()
		}
		static {
			this.StorageKey = "chat.participantNameRegistry"
		}
		refresh() {
			this.disposed ||
				this.update()
					.catch((e) => this.logService.warn("Failed to fetch chat participant registry", e))
					.then(() => Wt(300 * 1e3))
					.then(() => this.refresh())
		}
		async update() {
			let e = await this.requestService.request({ type: "GET", url: this.url }, De.None)
			if (e.res.statusCode !== 200) throw new Error("Could not get extensions report.")
			let t = await QM(e)
			if (!t || t.version !== 1) throw new Error("Unexpected chat participant registry response.")
			let n = t.restrictedChatParticipants
			this.registry.set(n, void 0), this.storageService.store(Ea.StorageKey, JSON.stringify(n), -1, 1)
		}
		getAgentNameRestriction(e) {
			if (e.isCore) return !0
			let t = this.checkAgentNameRestriction(e.name, e).get(),
				n = !e.fullName || this.checkAgentNameRestriction(e.fullName.replace(/\s/g, ""), e).get()
			return t && n
		}
		checkAgentNameRestriction(e, t) {
			return this.registry
				.map((r) => r[e.toLowerCase()])
				.map((r) =>
					r ? r.some((i) => xn(i, i.includes(".") ? t.extensionId.value : t.extensionPublisherId)) : !0,
				)
		}
		dispose() {
			this.disposed = !0
		}
	}
Ea = R([S(0, tu), S(1, GM), S(2, te), S(3, xy)], Ea)
function s7(o) {
	return `${o.extensionId.value}.${o.id}`
}
function Sy(o) {
	let e = "name" in o ? o : { ...o, name: o.id }
	return (
		"extensionPublisherId" in e || (e.extensionPublisherId = e.extensionPublisher ?? ""),
		"extensionDisplayName" in e || (e.extensionDisplayName = ""),
		"extensionId" in e || (e.extensionId = new Ce("")),
		ut(e)
	)
}
var lF = O("chatEditingService")
var tie = new D(
		"chatEditingWidgetFileState",
		void 0,
		p("chatEditingWidgetFileState", "The current state of the file in the chat editing widget"),
	),
	nie = new D(
		"chatEditingAgentSupportsReadonlyReferences",
		void 0,
		p(
			"chatEditingAgentSupportsReadonlyReferences",
			"Whether the chat editing agent supports readonly references (temporary)",
		),
	),
	rie = new D("decidedChatEditingResource", []),
	oie = new D("chatEditingResource", void 0),
	iie = new D("inChatEditingSession", void 0),
	sie = new D("hasUndecidedChatEditingResource", !1),
	aie = new D("hasAppliedChatEdits", !1),
	lie = new D("applyingChatEditsFailed", !1)
var iu = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.text = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "text"
		}
		get promptText() {
			return this.text
		}
	},
	I_ = "#",
	a7 = "@",
	y_ = "/",
	Ty = class o {
		constructor(e, t, n, r, i) {
			this.range = e
			this.editorRange = t
			this.variableName = n
			this.variableArg = r
			this.variableId = i
			this.kind = o.Kind
		}
		static {
			this.Kind = "var"
		}
		get text() {
			let e = this.variableArg ? `:${this.variableArg}` : ""
			return `${I_}${this.variableName}${e}`
		}
		get promptText() {
			return this.text
		}
	},
	Ey = class o {
		constructor(e, t, n, r, i, s) {
			this.range = e
			this.editorRange = t
			this.toolName = n
			this.toolId = r
			this.displayName = i
			this.icon = s
			this.kind = o.Kind
		}
		static {
			this.Kind = "tool"
		}
		get text() {
			return `${I_}${this.toolName}`
		}
		get promptText() {
			return this.text
		}
		toVariableEntry() {
			return {
				id: this.toolId,
				name: this.toolName,
				range: this.range,
				value: void 0,
				isTool: !0,
				icon: Yt.isThemeIcon(this.icon) ? this.icon : void 0,
				fullName: this.displayName,
			}
		}
	},
	wy = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.agent = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "agent"
		}
		get text() {
			return `${a7}${this.agent.name}`
		}
		get promptText() {
			return ""
		}
	},
	Py = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.command = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "subcommand"
		}
		get text() {
			return `${y_}${this.command.name}`
		}
		get promptText() {
			return ""
		}
	},
	_y = class o {
		constructor(e, t, n) {
			this.range = e
			this.editorRange = t
			this.slashCommand = n
			this.kind = o.Kind
		}
		static {
			this.Kind = "slash"
		}
		get text() {
			return `${y_}${this.slashCommand.command}`
		}
		get promptText() {
			return `${y_}${this.slashCommand.command}`
		}
	},
	Dy = class o {
		constructor(e, t, n, r, i, s, a, l, d, c) {
			this.range = e
			this.editorRange = t
			this.text = n
			this.id = r
			this.modelDescription = i
			this.data = s
			this.fullName = a
			this.icon = l
			this.isFile = d
			this.isDirectory = c
			this.kind = o.Kind
		}
		static {
			this.Kind = "dynamic"
		}
		get referenceText() {
			return this.text.replace(I_, "")
		}
		get promptText() {
			return this.text
		}
		toVariableEntry() {
			return this.id === "vscode.problems"
				? x_.toEntry(this.data.filter)
				: {
						id: this.id,
						name: this.referenceText,
						range: this.range,
						value: this.data,
						fullName: this.fullName,
						icon: this.icon,
						isFile: this.isFile,
						isDirectory: this.isDirectory,
					}
		}
	}
function dF(o) {
	return {
		text: o.text,
		parts: o.parts.map((e) => {
			if (e.kind === iu.Kind) return new iu(new Xr(e.range.start, e.range.endExclusive), e.editorRange, e.text)
			if (e.kind === Ty.Kind)
				return new Ty(
					new Xr(e.range.start, e.range.endExclusive),
					e.editorRange,
					e.variableName,
					e.variableArg,
					e.variableId || "",
				)
			if (e.kind === Ey.Kind)
				return new Ey(
					new Xr(e.range.start, e.range.endExclusive),
					e.editorRange,
					e.toolName,
					e.toolId,
					e.displayName,
					e.icon,
				)
			if (e.kind === wy.Kind) {
				let t = e.agent
				return (t = Sy(t)), new wy(new Xr(e.range.start, e.range.endExclusive), e.editorRange, t)
			} else {
				if (e.kind === Py.Kind)
					return new Py(new Xr(e.range.start, e.range.endExclusive), e.editorRange, e.command)
				if (e.kind === _y.Kind)
					return new _y(new Xr(e.range.start, e.range.endExclusive), e.editorRange, e.slashCommand)
				if (e.kind === Dy.Kind)
					return new Dy(
						new Xr(e.range.start, e.range.endExclusive),
						e.editorRange,
						e.text,
						e.id,
						e.modelDescription,
						ut(e.data),
						e.fullName,
						e.icon,
						e.isFile,
						e.isDirectory,
					)
				throw new Error(`Unknown chat request part: ${e.kind}`)
			}
		}),
	}
}
function l7(o) {
	return (
		!!o &&
		typeof o == "object" &&
		"uri" in o &&
		o.uri instanceof b &&
		"version" in o &&
		typeof o.version == "number" &&
		"ranges" in o &&
		Array.isArray(o.ranges) &&
		o.ranges.every(Re.isIRange)
	)
}
function cF(o) {
	return !!o && typeof o == "object" && "documents" in o && Array.isArray(o.documents) && o.documents.every(l7)
}
var uF = O("IChatService")
var x_
;((i) => {
	i.icon = ce.error
	function e(s) {
		return {
			filterUri: s.resource,
			owner: s.owner,
			problemMessage: s.message,
			filterRange: {
				startLineNumber: s.startLineNumber,
				endLineNumber: s.endLineNumber,
				startColumn: s.startColumn,
				endColumn: s.endColumn,
			},
		}
	}
	i.fromMarker = e
	function t(s) {
		return {
			id: n(s),
			name: r(s),
			icon: i.icon,
			value: s,
			kind: "diagnostic",
			range: s.filterRange ? new Xr(s.filterRange.startLineNumber, s.filterRange.endLineNumber) : void 0,
			...s,
		}
	}
	i.toEntry = t
	function n(s) {
		return [s.filterUri, s.owner, s.filterSeverity, s.filterRange?.startLineNumber].join(":")
	}
	i.id = n
	function r(s) {
		let a
		if (
			(((u) => ((u[(u.MaxChars = 30)] = "MaxChars"), (u[(u.MaxSpaceLookback = 10)] = "MaxSpaceLookback")))(
				(a ||= {}),
			),
			s.problemMessage)
		) {
			if (s.problemMessage.length < 30) return s.problemMessage
			let d = s.problemMessage.lastIndexOf(" ", 30)
			return d === -1 || d + 10 < 30
				? s.problemMessage.substring(0, 30) + "\u2026"
				: s.problemMessage.substring(0, d) + "\u2026"
		}
		let l = p("chat.attachment.problems.all", "All Problems")
		return s.filterUri && (l = p("chat.attachment.problems.inFile", "Problems in {0}", Ht(s.filterUri))), l
	}
	i.label = r
})((x_ ||= {}))
function pF(o) {
	return o.kind === "image"
}
var Nr = { reason: "other" },
	Ry = class {
		get session() {
			return this._session
		}
		get username() {
			return this.session.requesterUsername
		}
		get avatarIconUri() {
			return this.session.requesterAvatarIconUri
		}
		get attempt() {
			return this._attempt
		}
		get variableData() {
			return this._variableData
		}
		set variableData(e) {
			this._variableData = e
		}
		get confirmation() {
			return this._confirmation
		}
		get locationData() {
			return this._locationData
		}
		get attachedContext() {
			return this._attachedContext
		}
		constructor(e) {
			;(this._session = e.session),
				(this.message = e.message),
				(this._variableData = e.variableData),
				(this.timestamp = e.timestamp),
				(this._attempt = e.attempt ?? 0),
				(this._confirmation = e.confirmation),
				(this._locationData = e.locationData),
				(this._attachedContext = e.attachedContext),
				(this.isCompleteAddedRequest = e.isCompleteAddedRequest ?? !1),
				(this.modelId = e.modelId),
				(this.id = e.restoredId ?? "request_" + He())
		}
		adoptTo(e) {
			this._session = e
		}
	},
	Ay = class {
		constructor(e) {
			this._responseRepr = ""
			this._markdownContent = ""
			;(this._responseParts = e), this._updateRepr()
		}
		get value() {
			return this._responseParts
		}
		toString() {
			return this._responseRepr
		}
		getMarkdown() {
			return this._markdownContent
		}
		_updateRepr() {
			;(this._responseRepr = this.partsToRepr(this._responseParts)),
				(this._markdownContent = this._responseParts
					.map((e) =>
						e.kind === "inlineReference"
							? this.inlineRefToRepr(e)
							: e.kind === "markdownContent" || e.kind === "markdownVuln"
								? e.content.value
								: "",
					)
					.filter((e) => e.length > 0)
					.join(""))
		}
		partsToRepr(e) {
			let t = [],
				n = []
			for (let r of e) {
				let i
				switch (r.kind) {
					case "treeData":
					case "progressMessage":
					case "codeblockUri":
					case "toolInvocation":
					case "toolInvocationSerialized":
					case "undoStop":
						continue
					case "inlineReference":
						i = { text: this.inlineRefToRepr(r) }
						break
					case "command":
						i = { text: r.command.title, isBlock: !0 }
						break
					case "textEditGroup":
					case "notebookEditGroup":
						i = { text: p("editsSummary", "Made changes."), isBlock: !0 }
						break
					case "confirmation":
						i = {
							text: `${r.title}
${r.message}`,
							isBlock: !0,
						}
						break
					default:
						i = { text: r.content.value }
						break
				}
				i.isBlock ? (n.length && (t.push(n.join("")), (n = [])), t.push(i.text)) : n.push(i.text)
			}
			return (
				n.length && t.push(n.join("")),
				t.join(`

`)
			)
		}
		inlineRefToRepr(e) {
			return "uri" in e.inlineReference
				? this.uriToRepr(e.inlineReference.uri)
				: "name" in e.inlineReference
					? "`" + e.inlineReference.name + "`"
					: this.uriToRepr(e.inlineReference)
		}
		uriToRepr(e) {
			return e.scheme === W.http || e.scheme === W.https ? e.toString(!1) : Ht(e)
		}
	},
	C_ = class extends Ay {
		constructor(t, n) {
			let r = t.value.findIndex((i) => i.kind === "undoStop" && i.id === n)
			super(r === -1 ? t.value.slice() : t.value.slice(0, r))
			this.undoStop = n
		}
	},
	S_ = class extends Ay {
		constructor(t) {
			super(
				an(t).map((n) =>
					Gr(n)
						? { content: n, kind: "markdownContent" }
						: "kind" in n
							? n
							: { kind: "treeData", treeData: n },
				),
			)
			this._onDidChangeValue = new E()
			this._citations = []
		}
		get onDidChangeValue() {
			return this._onDidChangeValue.event
		}
		dispose() {
			this._onDidChangeValue.dispose()
		}
		clear() {
			;(this._responseParts = []), this._updateRepr(!0)
		}
		updateContent(t, n) {
			if (t.kind === "markdownContent") {
				let r = this._responseParts.filter((i) => i.kind !== "textEditGroup").at(-1)
				if (!r || r.kind !== "markdownContent" || !u7(r.content, t.content)) this._responseParts.push(t)
				else {
					let i = this._responseParts.indexOf(r)
					this._responseParts[i] = { ...r, content: p7(r.content, t.content) }
				}
				this._updateRepr(n)
			} else if (t.kind === "textEdit" || t.kind === "notebookEdit") {
				let i =
						t.uri.scheme === W.vscodeNotebookCell &&
						!this._responseParts.find((c) => c.kind === "notebookEditGroup")
							? void 0
							: ng.parse(t.uri)?.notebook,
					s = i ?? t.uri,
					a = !1,
					l = t.kind === "textEdit" && !i ? "textEditGroup" : "notebookEditGroup",
					d =
						l === "textEditGroup"
							? t.edits
							: t.edits.map((c) => (Ub.isTextEdit(c) ? { uri: t.uri, edit: c } : c))
				for (let c = 0; !a && c < this._responseParts.length; c++) {
					let u = this._responseParts[c]
					u.kind === l && !u.done && jr(u.uri, s) && (u.edits.push(d), (u.done = t.done), (a = !0))
				}
				a ||
					this._responseParts.push({ kind: l, uri: s, edits: l === "textEditGroup" ? [d] : d, done: t.done }),
					this._updateRepr(n)
			} else if (t.kind === "progressTask") {
				let r = this._responseParts.push(t) - 1
				this._updateRepr(n)
				let i = t.onDidAddProgress(() => {
					this._updateRepr(!1)
				})
				t.task?.().then((s) => {
					i.dispose(),
						typeof s == "string" && (this._responseParts[r].content = new $o(s)),
						this._updateRepr(!1)
				})
			} else
				t.kind === "toolInvocation"
					? (t.confirmationMessages &&
							t.confirmed.p.then(() => {
								this._updateRepr(!1)
							}),
						t.isCompletePromise.then(() => {
							this._updateRepr(!1)
						}),
						this._responseParts.push(t),
						this._updateRepr(n))
					: (this._responseParts.push(t), this._updateRepr(n))
		}
		addCitation(t) {
			this._citations.push(t), this._updateRepr()
		}
		_updateRepr(t) {
			super._updateRepr(),
				this._onDidChangeValue &&
					((this._responseRepr += this._citations.length
						? `

` + m7(this._citations)
						: ""),
					t || this._onDidChangeValue.fire())
		}
	},
	su = class extends $ {
		constructor(t) {
			super()
			this._onDidChange = this._register(new E())
			this.onDidChange = this._onDidChange.event
			this._contentReferences = []
			this._codeCitations = []
			this._progressMessages = []
			this._isStale = !1
			this._isPaused = Sa("isPaused", !1)
			;(this._session = t.session),
				(this._agent = t.agent),
				(this._slashCommand = t.slashCommand),
				(this.requestId = t.requestId),
				(this._isComplete = t.isComplete ?? !1),
				(this._isCanceled = t.isCanceled ?? !1),
				(this._vote = t.vote),
				(this._voteDownReason = t.voteDownReason),
				(this._result = t.result),
				(this._followups = t.followups ? [...t.followups] : void 0),
				(this.isCompleteAddedRequest = t.isCompleteAddedRequest ?? !1),
				(this._shouldBeRemovedOnSend = t.shouldBeRemovedOnSend),
				(this._isStale =
					Array.isArray(t.responseContent) &&
					(t.responseContent.length !== 0 ||
						(Gr(t.responseContent) && t.responseContent.value.length !== 0))),
				(this._response = this._register(new S_(t.responseContent))),
				this._register(this._response.onDidChangeValue(() => this._onDidChange.fire(Nr))),
				(this.id = t.restoredId ?? "response_" + He())
		}
		get session() {
			return this._session
		}
		get shouldBeRemovedOnSend() {
			return this._shouldBeRemovedOnSend
		}
		get isComplete() {
			return this._isComplete
		}
		set shouldBeRemovedOnSend(t) {
			;(this._shouldBeRemovedOnSend = t), this._onDidChange.fire(Nr)
		}
		get isCanceled() {
			return this._isCanceled
		}
		get vote() {
			return this._vote
		}
		get voteDownReason() {
			return this._voteDownReason
		}
		get followups() {
			return this._followups
		}
		get entireResponse() {
			return this._finalizedResponse || this._response
		}
		get result() {
			return this._result
		}
		get username() {
			return this.session.responderUsername
		}
		get avatarIcon() {
			return this.session.responderAvatarIcon
		}
		get agent() {
			return this._agent
		}
		get slashCommand() {
			return this._slashCommand
		}
		get agentOrSlashCommandDetected() {
			return this._agentOrSlashCommandDetected ?? !1
		}
		get usedContext() {
			return this._usedContext
		}
		get contentReferences() {
			return Array.from(this._contentReferences)
		}
		get codeCitations() {
			return this._codeCitations
		}
		get progressMessages() {
			return this._progressMessages
		}
		get isStale() {
			return this._isStale
		}
		get isPaused() {
			return this._isPaused
		}
		get isPendingConfirmation() {
			return this._response.value.some(
				(t) =>
					(t.kind === "toolInvocation" && t.isConfirmed === void 0) ||
					(t.kind === "confirmation" && t.isUsed === !1),
			)
		}
		get response() {
			let t = this._shouldBeRemovedOnSend?.afterUndoStop
			return t
				? (this._responseView?.undoStop !== t && (this._responseView = new C_(this._response, t)),
					this._responseView)
				: this._finalizedResponse || this._response
		}
		updateContent(t, n) {
			this.bufferWhenPaused(() => this._response.updateContent(t, n))
		}
		addUndoStop(t) {
			this.bufferWhenPaused(() => {
				this._onDidChange.fire({ reason: "undoStop", id: t.id }), this._response.updateContent(t, !0)
			})
		}
		applyReference(t) {
			t.kind === "usedContext"
				? (this._usedContext = t)
				: t.kind === "reference" && (this._contentReferences.push(t), this._onDidChange.fire(Nr))
		}
		applyCodeCitation(t) {
			this._codeCitations.push(t), this._response.addCitation(t), this._onDidChange.fire(Nr)
		}
		setAgent(t, n) {
			;(this._agent = t),
				(this._slashCommand = n),
				(this._agentOrSlashCommandDetected = !t.isDefault || !!n),
				this._onDidChange.fire(Nr)
		}
		setResult(t) {
			;(this._result = t), this._onDidChange.fire(Nr)
		}
		complete() {
			this._result?.errorDetails?.responseIsRedacted && this._response.clear(),
				(this._isComplete = !0),
				this._onDidChange.fire(Nr)
		}
		cancel() {
			;(this._isComplete = !0), (this._isCanceled = !0), this._onDidChange.fire(Nr)
		}
		setFollowups(t) {
			;(this._followups = t), this._onDidChange.fire(Nr)
		}
		setVote(t) {
			;(this._vote = t), this._onDidChange.fire(Nr)
		}
		setVoteDownReason(t) {
			;(this._voteDownReason = t), this._onDidChange.fire(Nr)
		}
		setEditApplied(t, n) {
			return !this.response.value.includes(t) || !t.state
				? !1
				: ((t.state.applied = n), this._onDidChange.fire(Nr), !0)
		}
		adoptTo(t) {
			;(this._session = t), this._onDidChange.fire(Nr)
		}
		setPaused(t, n) {
			this._isPaused.set(t, n),
				this._onDidChange.fire(Nr),
				this.bufferedPauseContent?.forEach((r) => r()),
				(this.bufferedPauseContent = void 0)
		}
		finalizeUndoState() {
			;(this._finalizedResponse = this.response),
				(this._responseView = void 0),
				(this._shouldBeRemovedOnSend = void 0)
		}
		bufferWhenPaused(t) {
			this._isPaused.get() ? ((this.bufferedPauseContent ??= []), this.bufferedPauseContent.push(t)) : t()
		}
	}
function d7(o) {
	let e = o
	return typeof e == "object" && typeof e.requesterUsername == "string"
}
function c7(o) {
	let e = o
	return (
		d7(o) &&
		typeof e.creationDate == "number" &&
		typeof e.sessionId == "string" &&
		o.requests.every((t) => !t.usedContext || cF(t.usedContext))
	)
}
var ky = ((n) => (
		(n[(n.Created = 0)] = "Created"),
		(n[(n.Initializing = 1)] = "Initializing"),
		(n[(n.Initialized = 2)] = "Initialized"),
		n
	))(ky || {}),
	au = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.initialData = t
			this._initialLocation = n
			this.logService = r
			this.chatAgentService = i
			this.chatEditingService = s
			this._onDidDispose = this._register(new E())
			this.onDidDispose = this._onDidDispose.event
			this._onDidChange = this._register(new E())
			this.onDidChange = this._onDidChange.event
			this._initState = 0
			this._isInitializedDeferred = new Cn()
			this._isImported = !1
			this._checkpoint = void 0
			let a = c7(t)
			t &&
				!a &&
				this.logService.warn(`ChatModel#constructor: Loaded malformed session data: ${JSON.stringify(t)}`),
				(this._isImported = (!!t && !a) || (t?.isImported ?? !1)),
				(this._sessionId = (a && t.sessionId) || He()),
				(this._requests = t ? this._deserialize(t) : []),
				(this._creationDate = (a && t.creationDate) || Date.now()),
				(this._lastMessageDate = (a && t.lastMessageDate) || this._creationDate),
				(this._customTitle = a ? t.customTitle : void 0),
				(this._initialRequesterAvatarIconUri = t?.requesterAvatarIconUri && b.revive(t.requesterAvatarIconUri)),
				(this._initialResponderAvatarIconUri = yf(t?.responderAvatarIconUri)
					? b.revive(t.responderAvatarIconUri)
					: t?.responderAvatarIconUri)
		}
		static getDefaultTitle(t) {
			let n = t.at(0)?.message ?? ""
			return (typeof n == "string" ? n : n.text)
				.split(
					`
`,
				)[0]
				.substring(0, 50)
		}
		get sampleQuestions() {
			return this._sampleQuestions
		}
		get sessionId() {
			return this._sessionId
		}
		get requestInProgress() {
			let t = this.lastRequest
			return !t?.response || t.response.isPendingConfirmation ? !1 : !t.response.isComplete
		}
		get requestPausibility() {
			let t = this.lastRequest
			return !t?.response?.agent || t.response.isComplete || t.response.isPendingConfirmation
				? 0
				: t.response.isPaused.get()
					? 1
					: 2
		}
		get hasRequests() {
			return this._requests.length > 0
		}
		get lastRequest() {
			return this._requests.at(-1)
		}
		get creationDate() {
			return this._creationDate
		}
		get lastMessageDate() {
			return this._lastMessageDate
		}
		get _defaultAgent() {
			return this.chatAgentService.getDefaultAgent("panel", "ask")
		}
		get requesterUsername() {
			return this._defaultAgent?.metadata.requester?.name ?? this.initialData?.requesterUsername ?? ""
		}
		get responderUsername() {
			return this._defaultAgent?.fullName ?? this.initialData?.responderUsername ?? ""
		}
		get requesterAvatarIconUri() {
			return this._defaultAgent?.metadata.requester?.icon ?? this._initialRequesterAvatarIconUri
		}
		get responderAvatarIcon() {
			return this._defaultAgent?.metadata.themeIcon ?? this._initialResponderAvatarIconUri
		}
		get initState() {
			return this._initState
		}
		get isImported() {
			return this._isImported
		}
		get customTitle() {
			return this._customTitle
		}
		get title() {
			return this._customTitle || au.getDefaultTitle(this._requests)
		}
		get initialLocation() {
			return this._initialLocation
		}
		get editingSessionObs() {
			return this._editingSession
		}
		get editingSession() {
			return this._editingSession?.promiseResult.get()?.data
		}
		startEditingSession(t) {
			let n = t
				? this.chatEditingService.startOrContinueGlobalEditingSession(this)
				: this.chatEditingService.createEditingSession(this)
			;(this._editingSession = new Zf(n)),
				this._editingSession.promise.then((r) => (this._store.isDisposed ? r.dispose() : this._register(r)))
		}
		_deserialize(t) {
			let n = t.requests
			if (!Array.isArray(n))
				return this.logService.error(`Ignoring malformed session data: ${JSON.stringify(t)}`), []
			try {
				return n.map((r) => {
					let i = typeof r.message == "string" ? this.getParsedRequestFromString(r.message) : dF(r.message),
						s = this.reviveVariableData(r.variableData),
						a = new Ry({
							session: this,
							message: i,
							variableData: s,
							timestamp: r.timestamp ?? -1,
							restoredId: r.requestId,
						})
					if (
						((a.shouldBeRemovedOnSend = r.isHidden ? { requestId: r.requestId } : r.shouldBeRemovedOnSend),
						r.response || r.result || r.responseErrorDetails)
					) {
						let l = r.agent && "metadata" in r.agent ? Sy(r.agent) : void 0,
							d = "responseErrorDetails" in r ? { errorDetails: r.responseErrorDetails } : r.result
						;(a.response = new su({
							responseContent: r.response ?? [new $o(r.response)],
							session: this,
							agent: l,
							slashCommand: r.slashCommand,
							requestId: a.id,
							isComplete: !0,
							isCanceled: r.isCanceled,
							vote: r.vote,
							voteDownReason: r.voteDownReason,
							result: d,
							followups: r.followups,
							restoredId: r.responseId,
						})),
							(a.response.shouldBeRemovedOnSend = r.isHidden
								? { requestId: r.requestId }
								: r.shouldBeRemovedOnSend),
							r.usedContext && a.response.applyReference(ut(r.usedContext)),
							r.contentReferences?.forEach((c) => a.response.applyReference(ut(c))),
							r.codeCitations?.forEach((c) => a.response.applyCodeCitation(ut(c)))
					}
					return a
				})
			} catch (r) {
				return this.logService.error("Failed to parse chat data", r), []
			}
		}
		reviveVariableData(t) {
			let n = t && Array.isArray(t.variables) ? t : { variables: [] }
			return (
				(n.variables = n.variables.map((r) =>
					r && "values" in r && Array.isArray(r.values)
						? {
								id: r.id ?? "",
								name: r.name,
								value: r.values[0]?.value,
								range: r.range,
								modelDescription: r.modelDescription,
								references: r.references,
							}
						: r,
				)),
				n
			)
		}
		getParsedRequestFromString(t) {
			let n = [
				new iu(new Xr(0, t.length), { startColumn: 1, startLineNumber: 1, endColumn: 1, endLineNumber: 1 }, t),
			]
			return { text: t, parts: n }
		}
		toggleLastRequestPaused(t) {
			if (this.requestPausibility !== 0 && this.lastRequest?.response?.agent) {
				let n = t ?? !this.lastRequest.response.isPaused.get()
				this.lastRequest.response.setPaused(n),
					this.chatAgentService.setRequestPaused(this.lastRequest.response.agent.id, this.lastRequest.id, n),
					this._onDidChange.fire({ kind: "changedRequest", request: this.lastRequest })
			}
		}
		startInitialize() {
			if (this.initState !== 0)
				throw new Error(`ChatModel is in the wrong state for startInitialize: ${ky[this.initState]}`)
			this._initState = 1
		}
		deinitialize() {
			;(this._initState = 0), (this._isInitializedDeferred = new Cn())
		}
		initialize(t) {
			if (this.initState !== 1)
				throw new Error(`ChatModel is in the wrong state for initialize: ${ky[this.initState]}`)
			;(this._initState = 2),
				(this._sampleQuestions = t),
				this._isInitializedDeferred.complete(),
				this._onDidChange.fire({ kind: "initialize" })
		}
		setInitializationError(t) {
			if (this.initState !== 1)
				throw new Error(`ChatModel is in the wrong state for setInitializationError: ${ky[this.initState]}`)
			this._isInitializedDeferred.isSettled || this._isInitializedDeferred.error(t)
		}
		waitForInitialization() {
			return this._isInitializedDeferred.p
		}
		getRequests() {
			return this._requests
		}
		get checkpoint() {
			return this._checkpoint
		}
		setDisabledRequests(t) {
			this._requests.forEach((n) => {
				let r = t.find((i) => i.requestId === n.id)
				;(n.shouldBeRemovedOnSend = r), n.response && (n.response.shouldBeRemovedOnSend = r)
			}),
				this._onDidChange.fire({ kind: "setHidden", hiddenRequestIds: t })
		}
		addRequest(t, n, r, i, s, a, l, d, c, u) {
			let m = new Ry({
				session: this,
				message: t,
				variableData: n,
				timestamp: Date.now(),
				attempt: r,
				confirmation: a,
				locationData: l,
				attachedContext: d,
				isCompleteAddedRequest: c,
				modelId: u,
			})
			return (
				(m.response = new su({
					responseContent: [],
					session: this,
					agent: i,
					slashCommand: s,
					requestId: m.id,
					isCompleteAddedRequest: c,
				})),
				this._requests.push(m),
				(this._lastMessageDate = Date.now()),
				this._onDidChange.fire({ kind: "addRequest", request: m }),
				m
			)
		}
		setCustomTitle(t) {
			this._customTitle = t
		}
		updateRequest(t, n) {
			;(t.variableData = n), this._onDidChange.fire({ kind: "changedRequest", request: t })
		}
		adoptRequest(t) {
			let n = t.session,
				r = n._requests.findIndex((i) => i.id === t.id)
			r !== -1 &&
				(n._requests.splice(r, 1),
				t.adoptTo(this),
				t.response?.adoptTo(this),
				this._requests.push(t),
				n._onDidChange.fire({ kind: "removeRequest", requestId: t.id, responseId: t.response?.id, reason: 2 }),
				this._onDidChange.fire({ kind: "addRequest", request: t }))
		}
		acceptResponseProgress(t, n, r) {
			if (
				(t.response || (t.response = new su({ responseContent: [], session: this, requestId: t.id })),
				t.response.isComplete)
			)
				throw new Error("acceptResponseProgress: Adding progress to a completed response")
			n.kind === "markdownContent" ||
			n.kind === "treeData" ||
			n.kind === "inlineReference" ||
			n.kind === "codeblockUri" ||
			n.kind === "markdownVuln" ||
			n.kind === "progressMessage" ||
			n.kind === "command" ||
			n.kind === "textEdit" ||
			n.kind === "notebookEdit" ||
			n.kind === "warning" ||
			n.kind === "progressTask" ||
			n.kind === "confirmation" ||
			n.kind === "toolInvocation"
				? t.response.updateContent(n, r)
				: n.kind === "usedContext" || n.kind === "reference"
					? t.response.applyReference(n)
					: n.kind === "codeCitation"
						? t.response.applyCodeCitation(n)
						: n.kind === "move"
							? this._onDidChange.fire({ kind: "move", target: n.uri, range: n.range })
							: n.kind === "undoStop"
								? t.response.addUndoStop(n)
								: this.logService.error(`Couldn't handle progress: ${JSON.stringify(n)}`)
		}
		removeRequest(t, n = 0) {
			let r = this._requests.findIndex((s) => s.id === t),
				i = this._requests[r]
			r !== -1 &&
				(this._onDidChange.fire({
					kind: "removeRequest",
					requestId: i.id,
					responseId: i.response?.id,
					reason: n,
				}),
				this._requests.splice(r, 1),
				i.response?.dispose())
		}
		cancelRequest(t) {
			t.response && t.response.cancel()
		}
		setResponse(t, n) {
			t.response || (t.response = new su({ responseContent: [], session: this, requestId: t.id })),
				t.response.setResult(n)
		}
		completeResponse(t) {
			if (!t.response) throw new Error("Call setResponse before completeResponse")
			t.response.complete(), this._onDidChange.fire({ kind: "completedRequest", request: t })
		}
		setFollowups(t, n) {
			t.response && t.response.setFollowups(n)
		}
		setResponseModel(t, n) {
			;(t.response = n), this._onDidChange.fire({ kind: "addResponse", response: n })
		}
		toExport() {
			return {
				requesterUsername: this.requesterUsername,
				requesterAvatarIconUri: this.requesterAvatarIconUri,
				responderUsername: this.responderUsername,
				responderAvatarIconUri: this.responderAvatarIcon,
				initialLocation: this.initialLocation,
				requests: this._requests.map((t) => {
					let n = { ...t.message, parts: t.message.parts.map((s) => (s && "toJSON" in s ? s.toJSON() : s)) },
						r = t.response?.agent,
						i = r && "toJSON" in r ? r.toJSON() : r ? { ...r } : void 0
					return {
						requestId: t.id,
						message: n,
						variableData: t.variableData,
						response: t.response
							? t.response.entireResponse.value.map((s) =>
									s.kind === "treeData" ? s.treeData : s.kind === "markdownContent" ? s.content : s,
								)
							: void 0,
						responseId: t.response?.id,
						shouldBeRemovedOnSend: t.shouldBeRemovedOnSend,
						result: t.response?.result,
						followups: t.response?.followups,
						isCanceled: t.response?.isCanceled,
						vote: t.response?.vote,
						voteDownReason: t.response?.voteDownReason,
						agent: i,
						slashCommand: t.response?.slashCommand,
						usedContext: t.response?.usedContext,
						contentReferences: t.response?.contentReferences,
						codeCitations: t.response?.codeCitations,
						timestamp: t.timestamp,
					}
				}),
			}
		}
		toJSON() {
			return {
				version: 3,
				...this.toExport(),
				sessionId: this.sessionId,
				creationDate: this._creationDate,
				isImported: this._isImported,
				lastMessageDate: this._lastMessageDate,
				customTitle: this._customTitle,
			}
		}
		dispose() {
			this._requests.forEach((t) => t.response?.dispose()), this._onDidDispose.fire(), super.dispose()
		}
	}
au = R([S(2, te), S(3, aF), S(4, lF)], au)
function u7(o, e) {
	if (o.baseUri && e.baseUri) {
		if (
			!(
				o.baseUri.scheme === e.baseUri.scheme &&
				o.baseUri.authority === e.baseUri.authority &&
				o.baseUri.path === e.baseUri.path &&
				o.baseUri.query === e.baseUri.query &&
				o.baseUri.fragment === e.baseUri.fragment
			)
		)
			return !1
	} else if (o.baseUri || e.baseUri) return !1
	return (
		nn(o.isTrusted, e.isTrusted) && o.supportHtml === e.supportHtml && o.supportThemeIcons === e.supportThemeIcons
	)
}
function p7(o, e) {
	let t = typeof e == "string" ? e : e.value
	return {
		value: o.value + t,
		isTrusted: o.isTrusted,
		supportThemeIcons: o.supportThemeIcons,
		supportHtml: o.supportHtml,
		baseUri: o.baseUri,
	}
}
function m7(o) {
	if (o.length === 0) return ""
	let e = o.reduce((n, r) => n.add(r.license), new Set())
	return e.size === 1
		? p("codeCitation", "Similar code found with 1 license type", e.size)
		: p("codeCitations", "Similar code found with {0} license types", e.size)
}
var Oy = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$",
	Xse = new RegExp(Oy)
var Yse = O("extensionGalleryService")
var Zse = O("extensionManagementService")
var eae = O("IGlobalExtensionEnablementService"),
	tae = O("IExtensionTipsService"),
	nae = O("IAllowedExtensionsService")
var rae = uf("extensions", "Extensions"),
	oae = uf("preferences", "Preferences")
var f7 = "extensions.allowed"
yt.as(ho.Configuration).registerConfiguration({
	id: "extensions",
	order: 30,
	title: p("extensionsConfigurationTitle", "Extensions"),
	type: "object",
	properties: {
		[f7]: {
			type: "object",
			markdownDescription: p(
				"extensions.allowed",
				"Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. For more information on how to configure this setting, please visit the [Configure Allowed Extensions](https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions) section.",
			),
			default: "*",
			defaultSnippets: [
				{ body: {}, description: p("extensions.allowed.none", "No extensions are allowed.") },
				{ body: { "*": !0 }, description: p("extensions.allowed.all", "All extensions are allowed.") },
			],
			scope: 1,
			policy: {
				name: "AllowedExtensions",
				minimumVersion: "1.96",
				description: p(
					"extensions.allowed.policy",
					"Specify a list of extensions that are allowed to use. This helps maintain a secure and consistent development environment by restricting the use of unauthorized extensions. More information: https://code.visualstudio.com/docs/setup/enterprise#_configure-allowed-extensions",
				),
			},
			additionalProperties: !1,
			patternProperties: {
				"([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
					anyOf: [
						{
							type: ["boolean", "string"],
							enum: [!0, !1, "stable"],
							description: p("extensions.allow.description", "Allow or disallow the extension."),
							enumDescriptions: [
								p("extensions.allowed.enable.desc", "Extension is allowed."),
								p("extensions.allowed.disable.desc", "Extension is not allowed."),
								p(
									"extensions.allowed.disable.stable.desc",
									"Allow only stable versions of the extension.",
								),
							],
						},
						{
							type: "array",
							items: { type: "string" },
							description: p(
								"extensions.allow.version.description",
								"Allow or disallow specific versions of the extension. To specifcy a platform specific version, use the format `platform@1.2.3`, e.g. `win32-x64@1.2.3`. Supported platforms are `win32-x64`, `win32-arm64`, `linux-x64`, `linux-arm64`, `linux-armhf`, `alpine-x64`, `alpine-arm64`, `darwin-x64`, `darwin-arm64`",
							),
						},
					],
				},
				"([a-z0-9A-Z][a-z0-9-A-Z]*)$": {
					type: ["boolean", "string"],
					enum: [!0, !1, "stable"],
					description: p(
						"extension.publisher.allow.description",
						"Allow or disallow all extensions from the publisher.",
					),
					enumDescriptions: [
						p("extensions.publisher.allowed.enable.desc", "All extensions from the publisher are allowed."),
						p(
							"extensions.publisher.allowed.disable.desc",
							"All extensions from the publisher are not allowed.",
						),
						p(
							"extensions.publisher.allowed.disable.stable.desc",
							"Allow only stable versions of the extensions from the publisher.",
						),
					],
				},
				"\\*": {
					type: "boolean",
					enum: [!0, !1],
					description: p("extensions.allow.all.description", "Allow or disallow all extensions."),
					enumDescriptions: [
						p("extensions.allow.all.enable", "Allow all extensions."),
						p("extensions.allow.all.disable", "Disallow all extensions."),
					],
				},
			},
		},
	},
})
var pae = O("telemetryService"),
	mae = O("customEndpointTelemetryService")
var wa = class {
		constructor(e) {
			this.value = e
			this.isTrustedTelemetryValue = !0
		}
	},
	w_ = class {
		constructor() {
			this.telemetryLevel = 0
			this.sessionId = "someValue.sessionId"
			this.machineId = "someValue.machineId"
			this.sqmId = "someValue.sqmId"
			this.devDeviceId = "someValue.devDeviceId"
			this.firstSessionDate = "someValue.firstSessionDate"
			this.sendErrorTelemetry = !1
		}
		publicLog() {}
		publicLog2() {}
		publicLogError() {}
		publicLogError2() {}
		setExperimentProperty() {}
	},
	kae = new w_()
var h7 = "telemetry",
	mF = { id: h7, name: p("telemetryLogName", "Telemetry") }
var v7 = new Set(["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"])
function fF(o) {
	if (!o) return "none"
	let e = Ql(o)
	return v7.has(e) ? e : "other"
}
function b7(o, e) {
	if (!o || (!o.includes("/") && !o.includes("\\"))) return o
	let t = o,
		n = []
	for (let a of e)
		for (;;) {
			let l = a.exec(o)
			if (!l) break
			n.push([l.index, a.lastIndex])
		}
	let r = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
		i = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g,
		s = 0
	for (t = ""; ; ) {
		let a = i.exec(o)
		if (!a) break
		let l = n.some(([d, c]) => a.index < c && d < i.lastIndex)
		!r.test(a[0]) && !l && ((t += o.substring(s, a.index) + "<REDACTED: user-file-path>"), (s = i.lastIndex))
	}
	return s < o.length && (t += o.substr(s)), t
}
function y7(o) {
	if (!o) return o
	let e = [
		{ label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
		{ label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
		{ label: "GitHub Token", regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
		{
			label: "Generic Secret",
			regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i,
		},
		{
			label: "CLI Credentials",
			regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/,
		},
		{ label: "Microsoft Entra ID", regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/ },
		{ label: "Email", regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ },
	]
	for (let t of e) if (t.regex.test(o)) return `<REDACTED: ${t.label}>`
	return o
}
function P_(o, e) {
	return os(o, (t) => {
		if (t instanceof wa || Object.hasOwnProperty.call(t, "isTrustedTelemetryValue")) return t.value
		if (typeof t == "string") {
			let n = t.replaceAll("%20", " ")
			n = b7(n, e)
			for (let r of e) n = n.replace(r, "")
			return (n = y7(n)), n
		}
	})
}
var jae = new Ce("pprice.better-merge")
var __ = class {
		constructor() {
			this._generators = new Map()
			this._cache = new WeakMap()
		}
		register(e, t) {
			this._generators.set(e, t)
		}
		readActivationEvents(e) {
			return this._cache.has(e) || this._cache.set(e, this._readActivationEvents(e)), this._cache.get(e)
		}
		createActivationEventsMap(e) {
			let t = Object.create(null)
			for (let n of e) {
				let r = this.readActivationEvents(n)
				r.length > 0 && (t[Ce.toKey(n.identifier)] = r)
			}
			return t
		}
		_readActivationEvents(e) {
			if (typeof e.main > "u" && typeof e.browser > "u") return []
			let t = Array.isArray(e.activationEvents) ? e.activationEvents.slice(0) : []
			for (let n = 0; n < t.length; n++) t[n] === "onUri" && (t[n] = `onUri:${Ce.toKey(e.identifier)}`)
			if (!e.contributes) return t
			for (let n in e.contributes) {
				let r = this._generators.get(n)
				if (!r) continue
				let i = e.contributes[n],
					s = Array.isArray(i) ? i : [i]
				try {
					r(s, t)
				} catch (a) {
					Be(a)
				}
			}
			return t
		}
	},
	D_ = new __()
var gF = Object.freeze({
	identifier: new Ce("nullExtensionDescription"),
	name: "Null Extension Description",
	version: "0.0.0",
	publisher: "vscode",
	engines: { vscode: "" },
	extensionLocation: b.parse("void:location"),
	isBuiltin: !1,
	targetPlatform: "undefined",
	isUserBuiltin: !1,
	isUnderDevelopment: !1,
	preRelease: !1,
})
var Ly = O("extensionService"),
	sg = class {
		constructor(e) {
			this.dependency = e
		}
	}
function nt(o, e) {
	return o.enabledApiProposals ? o.enabledApiProposals.includes(e) : !1
}
function F(o, e) {
	if (!nt(o, e))
		throw new Error(`Extension '${o.identifier.value}' CANNOT use API proposal: ${e}.
Its package.json#enabledApiProposals-property declares: ${o.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${e}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${o.identifier.value}`)
}
var I7 = {
		activeComment: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts",
		},
		aiRelatedInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts",
		},
		aiTextSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
			version: 2,
		},
		authLearnMore: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts",
		},
		authSession: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts",
		},
		canonicalUriProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts",
		},
		chatEditing: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts",
		},
		chatParticipantAdditions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts",
		},
		chatParticipantPrivate: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
			version: 7,
		},
		chatProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
		},
		chatReferenceBinaryData: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts",
		},
		chatReferenceDiagnostic: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceDiagnostic.d.ts",
		},
		chatStatusItem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatStatusItem.d.ts",
		},
		chatTab: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts",
		},
		codeActionAI: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts",
		},
		codeActionRanges: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts",
		},
		codiconDecoration: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts",
		},
		commentReactor: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts",
		},
		commentReveal: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts",
		},
		commentThreadApplicability: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts",
		},
		commentingRangeHint: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts",
		},
		commentsDraftState: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts",
		},
		contribAccessibilityHelpContent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts",
		},
		contribCommentEditorActionsMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts",
		},
		contribCommentPeekContext: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts",
		},
		contribCommentThreadAdditionalMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts",
		},
		contribCommentsViewThreadMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts",
		},
		contribDebugCreateConfiguration: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts",
		},
		contribDiffEditorGutterToolBarMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts",
		},
		contribEditSessions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts",
		},
		contribEditorContentMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts",
		},
		contribLabelFormatterWorkspaceTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts",
		},
		contribMenuBarHome: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts",
		},
		contribMergeEditorMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts",
		},
		contribMultiDiffEditorMenus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts",
		},
		contribNotebookStaticPreloads: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts",
		},
		contribRemoteHelp: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts",
		},
		contribShareMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts",
		},
		contribSourceControlHistoryItemMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts",
		},
		contribSourceControlHistoryTitleMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts",
		},
		contribSourceControlInputBoxMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts",
		},
		contribSourceControlTitleMenu: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts",
		},
		contribStatusBarItems: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts",
		},
		contribViewContainerTitle: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts",
		},
		contribViewsRemote: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts",
		},
		contribViewsWelcome: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts",
		},
		customEditorMove: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts",
		},
		debugVisualization: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts",
		},
		defaultChatParticipant: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
			version: 4,
		},
		diffCommand: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts",
		},
		diffContentOptions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts",
		},
		documentFiltersExclusive: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts",
		},
		editSessionIdentityProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts",
		},
		editorHoverVerbosityLevel: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts",
		},
		editorInsets: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts",
		},
		embeddings: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts",
		},
		extensionRuntime: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts",
		},
		extensionsAny: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts",
		},
		externalUriOpener: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts",
		},
		fileSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts",
		},
		fileSearchProvider2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts",
		},
		findFiles2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
			version: 2,
		},
		findTextInFiles: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts",
		},
		findTextInFiles2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts",
		},
		fsChunks: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts",
		},
		idToken: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts",
		},
		inlineCompletionsAdditions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts",
		},
		inlineEdit: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts",
		},
		interactive: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts",
		},
		interactiveWindow: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts",
		},
		ipc: {
			proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts",
		},
		languageModelCapabilities: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelCapabilities.d.ts",
		},
		languageModelDataPart: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelDataPart.d.ts",
		},
		languageModelSystem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts",
		},
		languageStatusText: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts",
		},
		mappedEditsProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts",
		},
		mcpConfigurationProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mcpConfigurationProvider.d.ts",
		},
		multiDocumentHighlightProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts",
		},
		nativeWindowHandle: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts",
		},
		newSymbolNamesProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts",
		},
		notebookCellExecution: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts",
		},
		notebookCellExecutionState: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts",
		},
		notebookControllerAffinityHidden: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts",
		},
		notebookDeprecated: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts",
		},
		notebookExecution: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts",
		},
		notebookKernelSource: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts",
		},
		notebookLiveShare: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts",
		},
		notebookMessaging: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts",
		},
		notebookMime: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts",
		},
		notebookReplDocument: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts",
		},
		notebookVariableProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts",
		},
		portsAttributes: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts",
		},
		profileContentHandlers: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts",
		},
		quickDiffProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts",
		},
		quickInputButtonLocation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts",
		},
		quickPickItemTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts",
		},
		quickPickSortByLabel: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts",
		},
		resolvers: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts",
		},
		scmActionButton: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts",
		},
		scmHistoryProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts",
		},
		scmMultiDiffEditor: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts",
		},
		scmSelectedProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts",
		},
		scmTextDocument: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts",
		},
		scmValidation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts",
		},
		shareProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts",
		},
		speech: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts",
		},
		statusBarItemTooltip: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.statusBarItemTooltip.d.ts",
		},
		tabInputMultiDiff: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts",
		},
		tabInputTextMerge: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts",
		},
		taskPresentationGroup: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts",
		},
		taskProblemMatcherStatus: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskProblemMatcherStatus.d.ts",
		},
		telemetry: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts",
		},
		terminalCompletionProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts",
		},
		terminalDataWriteEvent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts",
		},
		terminalDimensions: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts",
		},
		terminalExecuteCommandEvent: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts",
		},
		terminalQuickFixProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts",
		},
		terminalSelection: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts",
		},
		terminalShellEnv: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalShellEnv.d.ts",
		},
		testObserver: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts",
		},
		testRelatedCode: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts",
		},
		textDocumentEncoding: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textDocumentEncoding.d.ts",
		},
		textEditorDiffInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts",
		},
		textSearchComplete2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts",
		},
		textSearchProvider: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts",
		},
		textSearchProvider2: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts",
		},
		timeline: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts",
		},
		tokenInformation: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts",
		},
		treeViewActiveItem: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts",
		},
		treeViewMarkdownMessage: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts",
		},
		treeViewReveal: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts",
		},
		tunnelFactory: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts",
		},
		tunnels: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts",
		},
		valueSelectionInQuickPick: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts",
		},
		workspaceTrust: {
			proposal:
				"https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts",
		},
	},
	lu = Object.freeze(I7)
var L_ = yt.as(ad.JSONContribution)
var k_ = class o {
		constructor(e, t) {
			this.added = e
			this.removed = t
		}
		static _toSet(e) {
			let t = new ar()
			for (let n = 0, r = e.length; n < r; n++) t.add(e[n].description.identifier)
			return t
		}
		static compute(e, t) {
			if (!e || !e.length) return new o(t, [])
			if (!t || !t.length) return new o([], e)
			let n = this._toSet(e),
				r = this._toSet(t),
				i = t.filter((a) => !n.has(a.description.identifier)),
				s = e.filter((a) => !r.has(a.description.identifier))
			return new o(i, s)
		}
	},
	R_ = class {
		constructor(e, t, n) {
			;(this.name = e),
				(this.defaultExtensionKind = t),
				(this.canHandleResolver = n),
				(this._handler = null),
				(this._users = null),
				(this._delta = null)
		}
		setHandler(e) {
			if (this._handler !== null) throw new Error("Handler already set!")
			return (
				(this._handler = e),
				this._handle(),
				{
					dispose: () => {
						this._handler = null
					},
				}
			)
		}
		acceptUsers(e) {
			;(this._delta = k_.compute(this._users, e)), (this._users = e), this._handle()
		}
		_handle() {
			if (!(this._handler === null || this._users === null || this._delta === null))
				try {
					this._handler(this._users, this._delta)
				} catch (e) {
					Be(e)
				}
		}
	},
	x7 = {
		type: "string",
		enum: ["ui", "workspace"],
		enumDescriptions: [
			p(
				"ui",
				"UI extension kind. In a remote window, such extensions are enabled only when available on the local machine.",
			),
			p(
				"workspace",
				"Workspace extension kind. In a remote window, such extensions are enabled only when available on the remote.",
			),
		],
	},
	hF = "vscode://schemas/vscode-extensions",
	A_ = {
		properties: {
			engines: {
				type: "object",
				description: p("vscode.extension.engines", "Engine compatibility."),
				properties: {
					vscode: {
						type: "string",
						description: p(
							"vscode.extension.engines.vscode",
							"For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.",
						),
						default: "^1.22.0",
					},
				},
			},
			publisher: {
				description: p("vscode.extension.publisher", "The publisher of the VS Code extension."),
				type: "string",
			},
			displayName: {
				description: p(
					"vscode.extension.displayName",
					"The display name for the extension used in the VS Code gallery.",
				),
				type: "string",
			},
			categories: {
				description: p(
					"vscode.extension.categories",
					"The categories used by the VS Code gallery to categorize the extension.",
				),
				type: "array",
				uniqueItems: !0,
				items: {
					oneOf: [
						{ type: "string", enum: oL },
						{
							type: "string",
							const: "Languages",
							deprecationMessage: p(
								"vscode.extension.category.languages.deprecated",
								"Use 'Programming  Languages' instead",
							),
						},
					],
				},
			},
			galleryBanner: {
				type: "object",
				description: p("vscode.extension.galleryBanner", "Banner used in the VS Code marketplace."),
				properties: {
					color: {
						description: p(
							"vscode.extension.galleryBanner.color",
							"The banner color on the VS Code marketplace page header.",
						),
						type: "string",
					},
					theme: {
						description: p(
							"vscode.extension.galleryBanner.theme",
							"The color theme for the font used in the banner.",
						),
						type: "string",
						enum: ["dark", "light"],
					},
				},
			},
			contributes: {
				description: p(
					"vscode.extension.contributes",
					"All contributions of the VS Code extension represented by this package.",
				),
				type: "object",
				properties: {},
				default: {},
			},
			preview: {
				type: "boolean",
				description: p(
					"vscode.extension.preview",
					"Sets the extension to be flagged as a Preview in the Marketplace.",
				),
			},
			enableProposedApi: {
				type: "boolean",
				deprecationMessage: p(
					"vscode.extension.enableProposedApi.deprecated",
					"Use `enabledApiProposals` instead.",
				),
			},
			enabledApiProposals: {
				markdownDescription: p(
					"vscode.extension.enabledApiProposals",
					"Enable API proposals to try them out. Only valid **during development**. Extensions **cannot be published** with this property. For more details visit: https://code.visualstudio.com/api/advanced-topics/using-proposed-api",
				),
				type: "array",
				uniqueItems: !0,
				items: {
					type: "string",
					enum: Object.keys(lu).map((o) => o),
					markdownEnumDescriptions: Object.values(lu).map((o) => o.proposal),
				},
			},
			api: {
				markdownDescription: p(
					"vscode.extension.api",
					"Describe the API provided by this extension. For more details visit: https://code.visualstudio.com/api/advanced-topics/remote-extensions#handling-dependencies-with-remote-extensions",
				),
				type: "string",
				enum: ["none"],
				enumDescriptions: [
					p(
						"vscode.extension.api.none",
						"Give up entirely the ability to export any APIs. This allows other extensions that depend on this extension to run in a separate extension host process or in a remote machine.",
					),
				],
			},
			activationEvents: {
				description: p("vscode.extension.activationEvents", "Activation events for the VS Code extension."),
				type: "array",
				items: {
					type: "string",
					defaultSnippets: [
						{
							label: "onWebviewPanel",
							description: p(
								"vscode.extension.activationEvents.onWebviewPanel",
								"An activation event emmited when a webview is loaded of a certain viewType",
							),
							body: "onWebviewPanel:viewType",
						},
						{
							label: "onLanguage",
							description: p(
								"vscode.extension.activationEvents.onLanguage",
								"An activation event emitted whenever a file that resolves to the specified language gets opened.",
							),
							body: "onLanguage:${1:languageId}",
						},
						{
							label: "onCommand",
							description: p(
								"vscode.extension.activationEvents.onCommand",
								"An activation event emitted whenever the specified command gets invoked.",
							),
							body: "onCommand:${2:commandId}",
						},
						{
							label: "onDebug",
							description: p(
								"vscode.extension.activationEvents.onDebug",
								"An activation event emitted whenever a user is about to start debugging or about to setup debug configurations.",
							),
							body: "onDebug",
						},
						{
							label: "onDebugInitialConfigurations",
							description: p(
								"vscode.extension.activationEvents.onDebugInitialConfigurations",
								'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).',
							),
							body: "onDebugInitialConfigurations",
						},
						{
							label: "onDebugDynamicConfigurations",
							description: p(
								"vscode.extension.activationEvents.onDebugDynamicConfigurations",
								'An activation event emitted whenever a list of all debug configurations needs to be created (and all provideDebugConfigurations methods for the "dynamic" scope need to be called).',
							),
							body: "onDebugDynamicConfigurations",
						},
						{
							label: "onDebugResolve",
							description: p(
								"vscode.extension.activationEvents.onDebugResolve",
								"An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called).",
							),
							body: "onDebugResolve:${6:type}",
						},
						{
							label: "onDebugAdapterProtocolTracker",
							description: p(
								"vscode.extension.activationEvents.onDebugAdapterProtocolTracker",
								"An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed.",
							),
							body: "onDebugAdapterProtocolTracker:${6:type}",
						},
						{
							label: "workspaceContains",
							description: p(
								"vscode.extension.activationEvents.workspaceContains",
								"An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern.",
							),
							body: "workspaceContains:${4:filePattern}",
						},
						{
							label: "onStartupFinished",
							description: p(
								"vscode.extension.activationEvents.onStartupFinished",
								"An activation event emitted after the start-up finished (after all `*` activated extensions have finished activating).",
							),
							body: "onStartupFinished",
						},
						{
							label: "onTaskType",
							description: p(
								"vscode.extension.activationEvents.onTaskType",
								"An activation event emitted whenever tasks of a certain type need to be listed or resolved.",
							),
							body: "onTaskType:${1:taskType}",
						},
						{
							label: "onFileSystem",
							description: p(
								"vscode.extension.activationEvents.onFileSystem",
								"An activation event emitted whenever a file or folder is accessed with the given scheme.",
							),
							body: "onFileSystem:${1:scheme}",
						},
						{
							label: "onEditSession",
							description: p(
								"vscode.extension.activationEvents.onEditSession",
								"An activation event emitted whenever an edit session is accessed with the given scheme.",
							),
							body: "onEditSession:${1:scheme}",
						},
						{
							label: "onSearch",
							description: p(
								"vscode.extension.activationEvents.onSearch",
								"An activation event emitted whenever a search is started in the folder with the given scheme.",
							),
							body: "onSearch:${7:scheme}",
						},
						{
							label: "onView",
							body: "onView:${5:viewId}",
							description: p(
								"vscode.extension.activationEvents.onView",
								"An activation event emitted whenever the specified view is expanded.",
							),
						},
						{
							label: "onUri",
							body: "onUri",
							description: p(
								"vscode.extension.activationEvents.onUri",
								"An activation event emitted whenever a system-wide Uri directed towards this extension is open.",
							),
						},
						{
							label: "onOpenExternalUri",
							body: "onOpenExternalUri",
							description: p(
								"vscode.extension.activationEvents.onOpenExternalUri",
								"An activation event emitted whenever a external uri (such as an http or https link) is being opened.",
							),
						},
						{
							label: "onCustomEditor",
							body: "onCustomEditor:${9:viewType}",
							description: p(
								"vscode.extension.activationEvents.onCustomEditor",
								"An activation event emitted whenever the specified custom editor becomes visible.",
							),
						},
						{
							label: "onNotebook",
							body: "onNotebook:${1:type}",
							description: p(
								"vscode.extension.activationEvents.onNotebook",
								"An activation event emitted whenever the specified notebook document is opened.",
							),
						},
						{
							label: "onAuthenticationRequest",
							body: "onAuthenticationRequest:${11:authenticationProviderId}",
							description: p(
								"vscode.extension.activationEvents.onAuthenticationRequest",
								"An activation event emitted whenever sessions are requested from the specified authentication provider.",
							),
						},
						{
							label: "onRenderer",
							description: p(
								"vscode.extension.activationEvents.onRenderer",
								"An activation event emitted whenever a notebook output renderer is used.",
							),
							body: "onRenderer:${11:rendererId}",
						},
						{
							label: "onTerminalProfile",
							body: "onTerminalProfile:${1:terminalId}",
							description: p(
								"vscode.extension.activationEvents.onTerminalProfile",
								"An activation event emitted when a specific terminal profile is launched.",
							),
						},
						{
							label: "onTerminalQuickFixRequest",
							body: "onTerminalQuickFixRequest:${1:quickFixId}",
							description: p(
								"vscode.extension.activationEvents.onTerminalQuickFixRequest",
								"An activation event emitted when a command matches the selector associated with this ID",
							),
						},
						{
							label: "onWalkthrough",
							body: "onWalkthrough:${1:walkthroughID}",
							description: p(
								"vscode.extension.activationEvents.onWalkthrough",
								"An activation event emitted when a specified walkthrough is opened.",
							),
						},
						{
							label: "onIssueReporterOpened",
							body: "onIssueReporterOpened",
							description: p(
								"vscode.extension.activationEvents.onIssueReporterOpened",
								"An activation event emitted when the issue reporter is opened.",
							),
						},
						{
							label: "onChatParticipant",
							body: "onChatParticipant:${1:participantId}",
							description: p(
								"vscode.extension.activationEvents.onChatParticipant",
								"An activation event emitted when the specified chat participant is invoked.",
							),
						},
						{
							label: "onLanguageModelTool",
							body: "onLanguageModelTool:${1:toolId}",
							description: p(
								"vscode.extension.activationEvents.onLanguageModelTool",
								"An activation event emitted when the specified language model tool is invoked.",
							),
						},
						{
							label: "onTerminalCompletionsRequested",
							body: "onTerminalCompletionsRequested",
							description: p(
								"vscode.extension.activationEvents.onTerminalCompletionsRequested",
								"An activation event emitted when terminal completions are requested.",
							),
						},
						{
							label: "onMcpCollection",
							description: p(
								"vscode.extension.activationEvents.onMcpCollection",
								"An activation event emitted whenver a tool from the MCP server is requested.",
							),
							body: "onMcpCollection:${2:collectionId}",
						},
						{
							label: "*",
							description: p(
								"vscode.extension.activationEvents.star",
								"An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case.",
							),
							body: "*",
						},
					],
				},
			},
			badges: {
				type: "array",
				description: p(
					"vscode.extension.badges",
					"Array of badges to display in the sidebar of the Marketplace's extension page.",
				),
				items: {
					type: "object",
					required: ["url", "href", "description"],
					properties: {
						url: { type: "string", description: p("vscode.extension.badges.url", "Badge image URL.") },
						href: { type: "string", description: p("vscode.extension.badges.href", "Badge link.") },
						description: {
							type: "string",
							description: p("vscode.extension.badges.description", "Badge description."),
						},
					},
				},
			},
			markdown: {
				type: "string",
				description: p(
					"vscode.extension.markdown",
					"Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.",
				),
				enum: ["github", "standard"],
				default: "github",
			},
			qna: {
				default: "marketplace",
				description: p(
					"vscode.extension.qna",
					"Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether.",
				),
				anyOf: [{ type: ["string", "boolean"], enum: ["marketplace", !1] }, { type: "string" }],
			},
			extensionDependencies: {
				description: p(
					"vscode.extension.extensionDependencies",
					"Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.",
				),
				type: "array",
				uniqueItems: !0,
				items: { type: "string", pattern: Oy },
			},
			extensionPack: {
				description: p(
					"vscode.extension.contributes.extensionPack",
					"A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.",
				),
				type: "array",
				uniqueItems: !0,
				items: { type: "string", pattern: Oy },
			},
			extensionKind: {
				description: p(
					"extensionKind",
					"Define the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions run on the remote.",
				),
				type: "array",
				items: x7,
				default: ["workspace"],
				defaultSnippets: [
					{
						body: ["ui"],
						description: p(
							"extensionKind.ui",
							"Define an extension which can run only on the local machine when connected to remote window.",
						),
					},
					{
						body: ["workspace"],
						description: p(
							"extensionKind.workspace",
							"Define an extension which can run only on the remote machine when connected remote window.",
						),
					},
					{
						body: ["ui", "workspace"],
						description: p(
							"extensionKind.ui-workspace",
							"Define an extension which can run on either side, with a preference towards running on the local machine.",
						),
					},
					{
						body: ["workspace", "ui"],
						description: p(
							"extensionKind.workspace-ui",
							"Define an extension which can run on either side, with a preference towards running on the remote machine.",
						),
					},
					{
						body: [],
						description: p(
							"extensionKind.empty",
							"Define an extension which cannot run in a remote context, neither on the local, nor on the remote machine.",
						),
					},
				],
			},
			capabilities: {
				description: p(
					"vscode.extension.capabilities",
					"Declare the set of supported capabilities by the extension.",
				),
				type: "object",
				properties: {
					virtualWorkspaces: {
						description: p(
							"vscode.extension.capabilities.virtualWorkspaces",
							"Declares whether the extension should be enabled in virtual workspaces. A virtual workspace is a workspace which is not backed by any on-disk resources. When false, this extension will be automatically disabled in virtual workspaces. Default is true.",
						),
						type: ["boolean", "object"],
						defaultSnippets: [
							{ label: "limited", body: { supported: "${1:limited}", description: "${2}" } },
							{ label: "false", body: { supported: !1, description: "${2}" } },
						],
						default: (!0).valueOf,
						properties: {
							supported: {
								markdownDescription: p(
									"vscode.extension.capabilities.virtualWorkspaces.supported",
									"Declares the level of support for virtual workspaces by the extension.",
								),
								type: ["string", "boolean"],
								enum: ["limited", !0, !1],
								enumDescriptions: [
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.limited",
										"The extension will be enabled in virtual workspaces with some functionality disabled.",
									),
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.true",
										"The extension will be enabled in virtual workspaces with all functionality enabled.",
									),
									p(
										"vscode.extension.capabilities.virtualWorkspaces.supported.false",
										"The extension will not be enabled in virtual workspaces.",
									),
								],
							},
							description: {
								type: "string",
								markdownDescription: p(
									"vscode.extension.capabilities.virtualWorkspaces.description",
									"A description of how virtual workspaces affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.",
								),
							},
						},
					},
					untrustedWorkspaces: {
						description: p(
							"vscode.extension.capabilities.untrustedWorkspaces",
							"Declares how the extension should be handled in untrusted workspaces.",
						),
						type: "object",
						required: ["supported"],
						defaultSnippets: [{ body: { supported: "${1:limited}", description: "${2}" } }],
						properties: {
							supported: {
								markdownDescription: p(
									"vscode.extension.capabilities.untrustedWorkspaces.supported",
									"Declares the level of support for untrusted workspaces by the extension.",
								),
								type: ["string", "boolean"],
								enum: ["limited", !0, !1],
								enumDescriptions: [
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.limited",
										"The extension will be enabled in untrusted workspaces with some functionality disabled.",
									),
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.true",
										"The extension will be enabled in untrusted workspaces with all functionality enabled.",
									),
									p(
										"vscode.extension.capabilities.untrustedWorkspaces.supported.false",
										"The extension will not be enabled in untrusted workspaces.",
									),
								],
							},
							restrictedConfigurations: {
								description: p(
									"vscode.extension.capabilities.untrustedWorkspaces.restrictedConfigurations",
									"A list of configuration keys contributed by the extension that should not use workspace values in untrusted workspaces.",
								),
								type: "array",
								items: { type: "string" },
							},
							description: {
								type: "string",
								markdownDescription: p(
									"vscode.extension.capabilities.untrustedWorkspaces.description",
									"A description of how workspace trust affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.",
								),
							},
						},
					},
				},
			},
			sponsor: {
				description: p(
					"vscode.extension.contributes.sponsor",
					"Specify the location from where users can sponsor your extension.",
				),
				type: "object",
				defaultSnippets: [{ body: { url: "${1:https:}" } }],
				properties: {
					url: {
						description: p(
							"vscode.extension.contributes.sponsor.url",
							"URL from where users can sponsor your extension. It must be a valid URL with a HTTP or HTTPS protocol. Example value: https://github.com/sponsors/nvaccess",
						),
						type: "string",
					},
				},
			},
			scripts: {
				type: "object",
				properties: {
					"vscode:prepublish": {
						description: p(
							"vscode.extension.scripts.prepublish",
							"Script executed before the package is published as a VS Code extension.",
						),
						type: "string",
					},
					"vscode:uninstall": {
						description: p(
							"vscode.extension.scripts.uninstall",
							"Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported.",
						),
						type: "string",
					},
				},
			},
			icon: { type: "string", description: p("vscode.extension.icon", "The path to a 128x128 pixel icon.") },
			l10n: {
				type: "string",
				description: p(
					{
						key: "vscode.extension.l10n",
						comment: ['{Locked="bundle.l10n._locale_.json"}', '{Locked="vscode.l10n API"}'],
					},
					"The relative path to a folder containing localization (bundle.l10n.*.json) files. Must be specified if you are using the vscode.l10n API.",
				),
			},
			pricing: {
				type: "string",
				markdownDescription: p(
					"vscode.extension.pricing",
					"The pricing information for the extension. Can be Free (default) or Trial. For more details visit: https://code.visualstudio.com/api/working-with-extensions/publishing-extension#extension-pricing-label",
				),
				enum: ["Free", "Trial"],
				default: "Free",
			},
		},
	},
	O_ = class {
		constructor() {
			this._extensionPoints = new Map()
		}
		registerExtensionPoint(e) {
			if (this._extensionPoints.has(e.extensionPoint))
				throw new Error("Duplicate extension point: " + e.extensionPoint)
			let t = new R_(e.extensionPoint, e.defaultExtensionKind, e.canHandleResolver)
			return (
				this._extensionPoints.set(e.extensionPoint, t),
				e.activationEventsGenerator && D_.register(e.extensionPoint, e.activationEventsGenerator),
				(A_.properties.contributes.properties[e.extensionPoint] = e.jsonSchema),
				L_.registerSchema(hF, A_),
				t
			)
		}
		getExtensionPoints() {
			return Array.from(this._extensionPoints.values())
		}
	},
	vF = { ExtensionsRegistry: "ExtensionsRegistry" }
yt.add(vF.ExtensionsRegistry, new O_())
var My = yt.as(vF.ExtensionsRegistry)
L_.registerSchema(hF, A_)
L_.registerSchema(UM, {
	properties: {
		extensionEnabledApiProposals: {
			description: p(
				"product.extensionEnabledApiProposals",
				"API proposals that the respective extensions can freely use.",
			),
			type: "object",
			properties: {},
			additionalProperties: {
				anyOf: [
					{
						type: "array",
						uniqueItems: !0,
						items: {
							type: "string",
							enum: Object.keys(lu),
							markdownEnumDescriptions: Object.values(lu).map((o) => o.proposal),
						},
					},
				],
			},
		},
	},
})
var Vle = O("ILanguageModelsService"),
	bF = {
		type: "object",
		properties: {
			vendor: {
				type: "string",
				description: p(
					"vscode.extension.contributes.languageModels.vendor",
					"A globally unique vendor of language models.",
				),
			},
		},
	},
	C7 = My.registerExtensionPoint({
		extensionPoint: "languageModels",
		jsonSchema: {
			description: p(
				"vscode.extension.contributes.languageModels",
				"Contribute language models of a specific vendor.",
			),
			oneOf: [bF, { type: "array", items: bF }],
		},
		activationEventsGenerator: (o, e) => {
			for (let t of o) e.push(`onLanguageModelChat:${t.vendor}`)
		},
	}),
	Fy = class {
		constructor(e, t, n) {
			this._extensionService = e
			this._logService = t
			this._contextKeyService = n
			this._store = new Q()
			this._providers = new Map()
			this._vendors = new Set()
			this._onDidChangeProviders = this._store.add(new E())
			this.onDidChangeLanguageModels = this._onDidChangeProviders.event
			;(this._hasUserSelectableModels = vs.languageModelsAreUserSelectable.bindTo(this._contextKeyService)),
				this._store.add(
					C7.setHandler((r) => {
						this._vendors.clear()
						for (let s of r) {
							if (!nt(s.description, "chatProvider")) {
								s.collector.error(
									p(
										"vscode.extension.contributes.languageModels.chatProviderRequired",
										"This contribution point requires the 'chatProvider' proposal.",
									),
								)
								continue
							}
							for (let a of Rt.wrap(s.value)) {
								if (this._vendors.has(a.vendor)) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.vendorAlreadyRegistered",
											"The vendor '{0}' is already registered and cannot be registered twice",
											a.vendor,
										),
									)
									continue
								}
								if (Yi(a.vendor)) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.emptyVendor",
											"The vendor field cannot be empty.",
										),
									)
									continue
								}
								if (a.vendor.trim() !== a.vendor) {
									s.collector.error(
										p(
											"vscode.extension.contributes.languageModels.whitespaceVendor",
											"The vendor field cannot start or end with whitespace.",
										),
									)
									continue
								}
								this._vendors.add(a.vendor)
							}
						}
						let i = []
						for (let [s, a] of this._providers)
							this._vendors.has(a.metadata.vendor) || (this._providers.delete(s), i.push(s))
						i.length > 0 && this._onDidChangeProviders.fire({ removed: i })
					}),
				)
		}
		dispose() {
			this._store.dispose(), this._providers.clear()
		}
		getLanguageModelIds() {
			return Array.from(this._providers.keys())
		}
		lookupLanguageModel(e) {
			return this._providers.get(e)?.metadata
		}
		async selectLanguageModels(e) {
			if (e.vendor) await this._extensionService.activateByEvent(`onLanguageModelChat:${e.vendor}}`)
			else {
				let n = Array.from(this._vendors).map((r) =>
					this._extensionService.activateByEvent(`onLanguageModelChat:${r}`),
				)
				await Promise.all(n)
			}
			let t = []
			for (let [n, r] of this._providers)
				(e.vendor === void 0 || r.metadata.vendor === e.vendor) &&
					(e.family === void 0 || r.metadata.family === e.family) &&
					(e.version === void 0 || r.metadata.version === e.version) &&
					(e.id === void 0 || r.metadata.id === e.id) &&
					(!r.metadata.targetExtensions ||
						r.metadata.targetExtensions.some((i) => Ce.equals(i, e.extension))) &&
					t.push(n)
			return this._logService.trace("[LM] selected language models", e, t), t
		}
		registerLanguageModelChat(e, t) {
			if (
				(this._logService.trace("[LM] registering language model chat", e, t.metadata),
				!this._vendors.has(t.metadata.vendor))
			)
				throw new Error(`Chat response provider uses UNKNOWN vendor ${t.metadata.vendor}.`)
			if (this._providers.has(e))
				throw new Error(`Chat response provider with identifier ${e} is already registered.`)
			return (
				this._providers.set(e, t),
				this._onDidChangeProviders.fire({ added: [{ identifier: e, metadata: t.metadata }] }),
				this.updateUserSelectableModelsContext(),
				q(() => {
					this.updateUserSelectableModelsContext(),
						this._providers.delete(e) &&
							(this._onDidChangeProviders.fire({ removed: [e] }),
							this._logService.trace("[LM] UNregistered language model chat", e, t.metadata))
				})
			)
		}
		updateUserSelectableModelsContext() {
			let e = Array.from(this._providers.values()).some(
					(n) => n.metadata.isUserSelectable && !n.metadata.isDefault,
				),
				t = Array.from(this._providers.values()).some((n) => n.metadata.isDefault)
			this._hasUserSelectableModels.set(e && t)
		}
		async sendChatRequest(e, t, n, r, i) {
			let s = this._providers.get(e)
			if (!s) throw new Error(`Chat response provider with identifier ${e} is not registered.`)
			return s.sendChatRequest(n, t, r, i)
		}
		computeTokenLength(e, t, n) {
			let r = this._providers.get(e)
			if (!r) throw new Error(`Chat response provider with identifier ${e} is not registered.`)
			return r.provideTokenCount(t, n)
		}
	}
Fy = R([S(0, Ly), S(1, te), S(2, ma)], Fy)
var Gle = new D("debugType", void 0, {
		type: "string",
		description: p("debugType", "Debug type of the active debug session. For example 'python'."),
	}),
	Qle = new D("debugConfigurationType", void 0, {
		type: "string",
		description: p(
			"debugConfigurationType",
			"Debug type of the selected launch configuration. For example 'python'.",
		),
	}),
	Jle = new D("debugState", "inactive", {
		type: "string",
		description: p(
			"debugState",
			"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.",
		),
	}),
	T7 = "debugUx",
	Xle = new D(T7, "default", {
		type: "string",
		description: p(
			"debugUX",
			"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.",
		),
	}),
	Yle = new D("hasDebugged", !1, {
		type: "boolean",
		description: p("hasDebugged", "True when a debug session has been started at least once, false otherwise."),
	}),
	Zle = new D("inDebugMode", !1, {
		type: "boolean",
		description: p("inDebugMode", "True when debugging, false otherwise."),
	}),
	ede = new D("inDebugRepl", !1, {
		type: "boolean",
		description: p("inDebugRepl", "True when focus is in the debug console, false otherwise."),
	}),
	tde = new D("breakpointWidgetVisible", !1, {
		type: "boolean",
		description: p(
			"breakpointWidgetVisibile",
			"True when breakpoint editor zone widget is visible, false otherwise.",
		),
	}),
	nde = new D("inBreakpointWidget", !1, {
		type: "boolean",
		description: p(
			"inBreakpointWidget",
			"True when focus is in the breakpoint editor zone widget, false otherwise.",
		),
	}),
	rde = new D("breakpointsFocused", !0, {
		type: "boolean",
		description: p("breakpointsFocused", "True when the BREAKPOINTS view is focused, false otherwise."),
	}),
	ode = new D("watchExpressionsFocused", !0, {
		type: "boolean",
		description: p("watchExpressionsFocused", "True when the WATCH view is focused, false otherwise."),
	}),
	ide = new D("watchExpressionsExist", !1, {
		type: "boolean",
		description: p("watchExpressionsExist", "True when at least one watch expression exists, false otherwise."),
	}),
	sde = new D("variablesFocused", !0, {
		type: "boolean",
		description: p("variablesFocused", "True when the VARIABLES views is focused, false otherwise"),
	}),
	ade = new D("expressionSelected", !1, {
		type: "boolean",
		description: p(
			"expressionSelected",
			"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.",
		),
	}),
	lde = new D("breakpointInputFocused", !1, {
		type: "boolean",
		description: p("breakpointInputFocused", "True when the input box has focus in the BREAKPOINTS view."),
	}),
	dde = new D("callStackItemType", void 0, {
		type: "string",
		description: p(
			"callStackItemType",
			"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'",
		),
	}),
	cde = new D("callStackSessionIsAttach", !1, {
		type: "boolean",
		description: p(
			"callStackSessionIsAttach",
			"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.",
		),
	}),
	ude = new D("callStackItemStopped", !1, {
		type: "boolean",
		description: p(
			"callStackItemStopped",
			"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.",
		),
	}),
	pde = new D("callStackSessionHasOneThread", !1, {
		type: "boolean",
		description: p(
			"callStackSessionHasOneThread",
			"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.",
		),
	}),
	mde = new D("callStackFocused", !0, {
		type: "boolean",
		description: p("callStackFocused", "True when the CALLSTACK view is focused, false otherwise."),
	}),
	fde = new D("watchItemType", void 0, {
		type: "string",
		description: p(
			"watchItemType",
			"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'",
		),
	}),
	gde = new D("canViewMemory", void 0, {
		type: "boolean",
		description: p("canViewMemory", "Indicates whether the item in the view has an associated memory refrence."),
	}),
	hde = new D("breakpointItemType", void 0, {
		type: "string",
		description: p(
			"breakpointItemType",
			"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'",
		),
	}),
	vde = new D("breakpointItemBytes", void 0, {
		type: "boolean",
		description: p(
			"breakpointItemIsDataBytes",
			"Whether the breakpoint item is a data breakpoint on a byte range.",
		),
	}),
	bde = new D("breakpointHasModes", !1, {
		type: "boolean",
		description: p("breakpointHasModes", "Whether the breakpoint has multiple modes it can switch to."),
	}),
	yde = new D("breakpointSupportsCondition", !1, {
		type: "boolean",
		description: p("breakpointSupportsCondition", "True when the focused breakpoint supports conditions."),
	}),
	Ide = new D("loadedScriptsSupported", !1, {
		type: "boolean",
		description: p("loadedScriptsSupported", "True when the focused sessions supports the LOADED SCRIPTS view"),
	}),
	xde = new D("loadedScriptsItemType", void 0, {
		type: "string",
		description: p(
			"loadedScriptsItemType",
			"Represents the item type of the focused element in the LOADED SCRIPTS view.",
		),
	}),
	Cde = new D("focusedSessionIsAttach", !1, {
		type: "boolean",
		description: p("focusedSessionIsAttach", "True when the focused session is 'attach'."),
	}),
	Sde = new D("focusedSessionIsNoDebug", !1, {
		type: "boolean",
		description: p("focusedSessionIsNoDebug", "True when the focused session is run without debugging."),
	}),
	Tde = new D("stepBackSupported", !1, {
		type: "boolean",
		description: p("stepBackSupported", "True when the focused session supports 'stepBack' requests."),
	}),
	Ede = new D("restartFrameSupported", !1, {
		type: "boolean",
		description: p("restartFrameSupported", "True when the focused session supports 'restartFrame' requests."),
	}),
	wde = new D("stackFrameSupportsRestart", !1, {
		type: "boolean",
		description: p("stackFrameSupportsRestart", "True when the focused stack frame supports 'restartFrame'."),
	}),
	Pde = new D("jumpToCursorSupported", !1, {
		type: "boolean",
		description: p("jumpToCursorSupported", "True when the focused session supports 'jumpToCursor' request."),
	}),
	_de = new D("stepIntoTargetsSupported", !1, {
		type: "boolean",
		description: p("stepIntoTargetsSupported", "True when the focused session supports 'stepIntoTargets' request."),
	}),
	Dde = new D("breakpointsExist", !1, {
		type: "boolean",
		description: p("breakpointsExist", "True when at least one breakpoint exists."),
	}),
	kde = new D("debuggersAvailable", !1, {
		type: "boolean",
		description: p("debuggersAvailable", "True when there is at least one debug extensions active."),
	}),
	Rde = new D("debugExtensionAvailable", !0, {
		type: "boolean",
		description: p(
			"debugExtensionsAvailable",
			"True when there is at least one debug extension installed and enabled.",
		),
	}),
	Ade = new D("debugProtocolVariableMenuContext", void 0, {
		type: "string",
		description: p(
			"debugProtocolVariableMenuContext",
			"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.",
		),
	}),
	Ode = new D("debugSetVariableSupported", !1, {
		type: "boolean",
		description: p("debugSetVariableSupported", "True when the focused session supports 'setVariable' request."),
	}),
	Lde = new D("debugSetDataBreakpointAddressSupported", !1, {
		type: "boolean",
		description: p(
			"debugSetDataBreakpointAddressSupported",
			"True when the focused session supports 'getBreakpointInfo' request on an address.",
		),
	}),
	Mde = new D("debugSetExpressionSupported", !1, {
		type: "boolean",
		description: p(
			"debugSetExpressionSupported",
			"True when the focused session supports 'setExpression' request.",
		),
	}),
	Fde = new D("breakWhenValueChangesSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueChangesSupported",
			"True when the focused session supports to break when value changes.",
		),
	}),
	Nde = new D("breakWhenValueIsAccessedSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueIsAccessedSupported",
			"True when the focused breakpoint supports to break when value is accessed.",
		),
	}),
	Ude = new D("breakWhenValueIsReadSupported", !1, {
		type: "boolean",
		description: p(
			"breakWhenValueIsReadSupported",
			"True when the focused breakpoint supports to break when value is read.",
		),
	}),
	Hde = new D("terminateDebuggeeSupported", !1, {
		type: "boolean",
		description: p(
			"terminateDebuggeeSupported",
			"True when the focused session supports the terminate debuggee capability.",
		),
	}),
	Wde = new D("suspendDebuggeeSupported", !1, {
		type: "boolean",
		description: p(
			"suspendDebuggeeSupported",
			"True when the focused session supports the suspend debuggee capability.",
		),
	}),
	Vde = new D("variableEvaluateNamePresent", !1, {
		type: "boolean",
		description: p(
			"variableEvaluateNamePresent",
			"True when the focused variable has an 'evalauteName' field set.",
		),
	}),
	Bde = new D("variableIsReadonly", !1, {
		type: "boolean",
		description: p("variableIsReadonly", "True when the focused variable is read-only."),
	}),
	$de = new D("variableValue", !1, {
		type: "string",
		description: p("variableValue", "Value of the variable, present for debug visualization clauses."),
	}),
	zde = new D("variableType", !1, {
		type: "string",
		description: p("variableType", "Type of the variable, present for debug visualization clauses."),
	}),
	qde = new D("variableInterfaces", !1, {
		type: "array",
		description: p(
			"variableInterfaces",
			"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.",
		),
	}),
	Kde = new D("variableName", !1, {
		type: "string",
		description: p("variableName", "Name of the variable, present for debug visualization clauses."),
	}),
	jde = new D("variableLanguage", !1, {
		type: "string",
		description: p("variableLanguage", "Language of the variable source, present for debug visualization clauses."),
	}),
	Gde = new D("variableExtensionId", !1, {
		type: "string",
		description: p(
			"variableExtensionId",
			"Extension ID of the variable source, present for debug visualization clauses.",
		),
	}),
	Qde = new D("exceptionWidgetVisible", !1, {
		type: "boolean",
		description: p("exceptionWidgetVisible", "True when the exception widget is visible."),
	}),
	Jde = new D("multiSessionRepl", !1, {
		type: "boolean",
		description: p("multiSessionRepl", "True when there is more than 1 debug console."),
	}),
	Xde = new D("multiSessionDebug", !1, {
		type: "boolean",
		description: p("multiSessionDebug", "True when there is more than 1 active debug session."),
	}),
	Yde = new D("disassembleRequestSupported", !1, {
		type: "boolean",
		description: p("disassembleRequestSupported", "True when the focused sessions supports disassemble request."),
	}),
	Zde = new D("disassemblyViewFocus", !1, {
		type: "boolean",
		description: p("disassemblyViewFocus", "True when the Disassembly View is focused."),
	}),
	ece = new D("languageSupportsDisassembleRequest", !1, {
		type: "boolean",
		description: p(
			"languageSupportsDisassembleRequest",
			"True when the language in the current editor supports disassemble request.",
		),
	}),
	tce = new D("focusedStackFrameHasInstructionReference", !1, {
		type: "boolean",
		description: p(
			"focusedStackFrameHasInstructionReference",
			"True when the focused stack frame has instruction pointer reference.",
		),
	})
var nce = {
	enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
	default: "openOnFirstSessionStart",
	description: p("internalConsoleOptions", "Controls when the internal Debug Console should open."),
}
var M_ = ((t) => ((t[(t.Initial = 1)] = "Initial"), (t[(t.Dynamic = 2)] = "Dynamic"), t))(M_ || {})
var rce = O("debugService")
var E7
;((t) => ((t.deserialize = (n) => n), (t.serialize = (n) => n)))((E7 ||= {}))
var w7
;((t) => (
	(t.deserialize = (n) => ({
		id: n.id,
		name: n.name,
		iconPath: n.iconPath && { light: b.revive(n.iconPath.light), dark: b.revive(n.iconPath.dark) },
		iconClass: n.iconClass,
		visualization: n.visualization,
	})),
	(t.serialize = (n) => n)
))((w7 ||= {}))
var ze = class o {
	constructor(e, t = e.length) {
		this.path = e
		this.viewEnd = t
		if (e.length === 0 || t < 1) throw new Error("cannot create test with empty path")
	}
	static fromExtHostTestItem(e, t, n = e.parent) {
		if (e._isRoot) return new o([t])
		let r = [e.id]
		for (let i = n; i && i.id !== t; i = i.parent) r.push(i.id)
		return r.push(t), new o(r.reverse())
	}
	static isRoot(e) {
		return !e.includes("\0")
	}
	static root(e) {
		let t = e.indexOf("\0")
		return t === -1 ? e : e.slice(0, t)
	}
	static fromString(e) {
		return new o(e.split("\0"))
	}
	static join(e, t) {
		return new o([...e.path, t])
	}
	static split(e) {
		return e.split("\0")
	}
	static joinToString(e, t) {
		return e.toString() + "\0" + t
	}
	static parentId(e) {
		let t = e.lastIndexOf("\0")
		return t === -1 ? void 0 : e.slice(0, t)
	}
	static localId(e) {
		let t = e.lastIndexOf("\0")
		return t === -1 ? e : e.slice(t + 1)
	}
	static isChild(e, t) {
		return t[e.length] === "\0" && t.startsWith(e)
	}
	static compare(e, t) {
		return e === t ? 0 : o.isChild(e, t) ? 2 : o.isChild(t, e) ? 3 : 1
	}
	static getLengthOfCommonPrefix(e, t) {
		if (e === 0) return 0
		let n = 0
		for (; n < e - 1; ) {
			for (let r = 1; r < e; r++) {
				let i = t(r - 1),
					s = t(r)
				if (i.path[n] !== s.path[n]) return n
			}
			n++
		}
		return n
	}
	get rootId() {
		return new o(this.path, 1)
	}
	get parentId() {
		return this.viewEnd > 1 ? new o(this.path, this.viewEnd - 1) : void 0
	}
	get localId() {
		return this.path[this.viewEnd - 1]
	}
	get controllerId() {
		return this.path[0]
	}
	get isRoot() {
		return this.viewEnd === 1
	}
	*idsFromRoot() {
		for (let e = 1; e <= this.viewEnd; e++) yield new o(this.path, e)
	}
	*idsToRoot() {
		for (let e = this.viewEnd; e > 0; e--) yield new o(this.path, e)
	}
	compare(e) {
		if (typeof e == "string") return o.compare(this.toString(), e)
		for (let t = 0; t < e.viewEnd && t < this.viewEnd; t++) if (e.path[t] !== this.path[t]) return 1
		return e.viewEnd > this.viewEnd ? 2 : e.viewEnd < this.viewEnd ? 3 : 0
	}
	toJSON() {
		return this.toString()
	}
	toString() {
		if (!this.stringifed) {
			this.stringifed = this.path[0]
			for (let e = 1; e < this.viewEnd; e++) (this.stringifed += "\0"), (this.stringifed += this.path[e])
		}
		return this.stringifed
	}
}
var fce = {
	2: p("testing.runProfileBitset.run", "Run"),
	4: p("testing.runProfileBitset.debug", "Debug"),
	8: p("testing.runProfileBitset.coverage", "Coverage"),
}
var yF = (o) => "runId" in o,
	ag
;((t) => (
	(t.serialize = (n) => ({ range: n.range.toJSON(), uri: n.uri.toJSON() })),
	(t.deserialize = (n, r) => ({ range: Re.lift(r.range), uri: n.asCanonicalUri(b.revive(r.uri)) }))
))((ag ||= {}))
var F_
;((t) => (
	(t.serialize = (n) => ({ label: n.label, uri: n.uri?.toJSON(), position: n.position?.toJSON() })),
	(t.deserialize = (n, r) => ({
		label: r.label,
		uri: r.uri ? n.asCanonicalUri(b.revive(r.uri)) : void 0,
		position: r.position ? cn.lift(r.position) : void 0,
	}))
))((F_ ||= {}))
var N_
;((t) => (
	(t.serialize = (n) => ({
		message: n.message,
		type: 0,
		expected: n.expected,
		actual: n.actual,
		contextValue: n.contextValue,
		location: n.location && ag.serialize(n.location),
		stackTrace: n.stackTrace?.map(F_.serialize),
	})),
	(t.deserialize = (n, r) => ({
		message: r.message,
		type: 0,
		expected: r.expected,
		actual: r.actual,
		contextValue: r.contextValue,
		location: r.location && ag.deserialize(n, r.location),
		stackTrace: r.stackTrace && r.stackTrace.map((i) => F_.deserialize(n, i)),
	}))
))((N_ ||= {}))
var U_
;((t) => (
	(t.serialize = (n) => ({
		message: n.message,
		type: 1,
		offset: n.offset,
		length: n.length,
		location: n.location && ag.serialize(n.location),
	})),
	(t.deserialize = (n, r) => ({
		message: r.message,
		type: 1,
		offset: r.offset,
		length: r.length,
		location: r.location && ag.deserialize(n, r.location),
	}))
))((U_ ||= {}))
var H_
;((n) => (
	(n.serialize = (r) => (r.type === 0 ? N_.serialize(r) : U_.serialize(r))),
	(n.deserialize = (r, i) => (i.type === 0 ? N_.deserialize(r, i) : U_.deserialize(r, i))),
	(n.isDiffable = (r) => r.type === 0 && r.actual !== void 0 && r.expected !== void 0)
))((H_ ||= {}))
var Ny
;((n) => (
	(n.serializeWithoutMessages = (r) => ({ state: r.state, duration: r.duration, messages: [] })),
	(n.serialize = (r) => ({ state: r.state, duration: r.duration, messages: r.messages.map(H_.serialize) })),
	(n.deserialize = (r, i) => ({
		state: i.state,
		duration: i.duration,
		messages: i.messages.map((s) => H_.deserialize(r, s)),
	}))
))((Ny ||= {}))
var IF = "\0",
	du = (o, e) => o + IF + e,
	Wy = (o) => {
		let e = o.indexOf(IF)
		return { ctrlId: o.slice(0, e), tagId: o.slice(e + 1) }
	},
	W_
;((t) => (
	(t.serialize = (n) => ({
		extId: n.extId,
		label: n.label,
		tags: n.tags,
		busy: n.busy,
		children: void 0,
		uri: n.uri?.toJSON(),
		range: n.range?.toJSON() || null,
		description: n.description,
		error: n.error,
		sortText: n.sortText,
	})),
	(t.deserialize = (n, r) => ({
		extId: r.extId,
		label: r.label,
		tags: r.tags,
		busy: r.busy,
		children: void 0,
		uri: r.uri ? n.asCanonicalUri(b.revive(r.uri)) : void 0,
		range: r.range ? Re.lift(r.range) : null,
		description: r.description,
		error: r.error,
		sortText: r.sortText,
	}))
))((W_ ||= {}))
var cd
;((t) => (
	(t.serialize = (n) => ({ expand: n.expand, item: W_.serialize(n.item) })),
	(t.deserialize = (n, r) => ({
		controllerId: ze.root(r.item.extId),
		expand: r.expand,
		item: W_.deserialize(n, r.item),
	}))
))((cd ||= {}))
var Uy
;((t) => (
	(t.serialize = (n) => {
		let r
		return (
			n.item &&
				((r = {}),
				n.item.label !== void 0 && (r.label = n.item.label),
				n.item.tags !== void 0 && (r.tags = n.item.tags),
				n.item.busy !== void 0 && (r.busy = n.item.busy),
				n.item.uri !== void 0 && (r.uri = n.item.uri?.toJSON()),
				n.item.range !== void 0 && (r.range = n.item.range?.toJSON()),
				n.item.description !== void 0 && (r.description = n.item.description),
				n.item.error !== void 0 && (r.error = n.item.error),
				n.item.sortText !== void 0 && (r.sortText = n.item.sortText)),
			{ extId: n.extId, expand: n.expand, item: r }
		)
	}),
	(t.deserialize = (n) => {
		let r
		return (
			n.item &&
				((r = {}),
				n.item.label !== void 0 && (r.label = n.item.label),
				n.item.tags !== void 0 && (r.tags = n.item.tags),
				n.item.busy !== void 0 && (r.busy = n.item.busy),
				n.item.range !== void 0 && (r.range = n.item.range ? Re.lift(n.item.range) : null),
				n.item.description !== void 0 && (r.description = n.item.description),
				n.item.error !== void 0 && (r.error = n.item.error),
				n.item.sortText !== void 0 && (r.sortText = n.item.sortText)),
			{ extId: n.extId, expand: n.expand, item: r }
		)
	})
))((Uy ||= {}))
var Vy = (o, e) => {
		e.expand !== void 0 && (o.expand = e.expand),
			e.item !== void 0 && (o.item = o.item ? Object.assign(o.item, e.item) : e.item)
	},
	P7
;((n) => (
	(n.serializeWithoutMessages = (r) => ({
		...cd.serialize(r),
		ownComputedState: r.ownComputedState,
		computedState: r.computedState,
		tasks: r.tasks.map(Ny.serializeWithoutMessages),
	})),
	(n.serialize = (r) => ({
		...cd.serialize(r),
		ownComputedState: r.ownComputedState,
		computedState: r.computedState,
		tasks: r.tasks.map(Ny.serialize),
	})),
	(n.deserialize = (r, i) => ({
		...cd.deserialize(r, i),
		ownComputedState: i.ownComputedState,
		computedState: i.computedState,
		tasks: i.tasks.map((s) => Ny.deserialize(r, s)),
		retired: !0,
	}))
))((P7 ||= {}))
var xF
;((t) => (
	(t.empty = () => ({ covered: 0, total: 0 })),
	(t.sum = (n, r) => {
		;(n.covered += r.covered), (n.total += r.total)
	})
))((xF ||= {}))
var _7
;((n) => (
	(n.serialize = (r) => ({
		id: r.id,
		statement: r.statement,
		branch: r.branch,
		declaration: r.declaration,
		testIds: r.testIds,
		uri: r.uri.toJSON(),
	})),
	(n.deserialize = (r, i) => ({
		id: i.id,
		statement: i.statement,
		branch: i.branch,
		declaration: i.declaration,
		testIds: i.testIds,
		uri: r.asCanonicalUri(b.revive(i.uri)),
	})),
	(n.empty = (r, i) => ({ id: r, uri: i, statement: xF.empty() }))
))((_7 ||= {}))
function z_(o) {
	return { ...o, location: o.location?.toJSON() }
}
function q_(o) {
	return (
		(o.location = o.location ? (cn.isIPosition(o.location) ? cn.lift(o.location) : Re.lift(o.location)) : void 0), o
	)
}
var D7
;((t) => (
	(t.serialize = (n) => (n.type === 0 ? B_.serialize(n) : $_.serialize(n))),
	(t.deserialize = (n) => (n.type === 0 ? B_.deserialize(n) : $_.deserialize(n)))
))((D7 ||= {}))
var V_
;((t) => ((t.serialize = z_), (t.deserialize = q_)))((V_ ||= {}))
var B_
;((t) => ((t.serialize = z_), (t.deserialize = q_)))((B_ ||= {}))
var $_
;((t) => (
	(t.serialize = (n) => ({ ...z_(n), branches: n.branches?.map(V_.serialize) })),
	(t.deserialize = (n) => ({ ...q_(n), branches: n.branches?.map(V_.deserialize) }))
))(($_ ||= {}))
var By
;((t) => (
	(t.deserialize = (n, r) =>
		r.op === 0
			? { op: r.op, item: cd.deserialize(n, r.item) }
			: r.op === 1
				? { op: r.op, item: Uy.deserialize(r.item) }
				: r.op === 2
					? { op: r.op, uri: n.asCanonicalUri(b.revive(r.uri)), docv: r.docv }
					: r),
	(t.serialize = (n) =>
		n.op === 0
			? { op: n.op, item: cd.serialize(n.item) }
			: n.op === 1
				? { op: n.op, item: Uy.serialize(n.item) }
				: n)
))((By ||= {}))
var Hy = class {
	constructor(e) {
		this.uriIdentity = e
		this._tags = new Map()
		this.items = new Map()
		this.roots = new Set()
		this.busyControllerCount = 0
		this.pendingRootCount = 0
		this.tags = this._tags
	}
	apply(e) {
		let t = this.createChangeCollector()
		for (let n of e)
			switch (n.op) {
				case 0:
					this.add(cd.deserialize(this.uriIdentity, n.item), t)
					break
				case 1:
					this.update(Uy.deserialize(n.item), t)
					break
				case 3:
					this.remove(n.itemId, t)
					break
				case 5:
					this.retireTest(n.itemId)
					break
				case 4:
					this.updatePendingRoots(n.amount)
					break
				case 6:
					this._tags.set(n.tag.id, n.tag)
					break
				case 7:
					this._tags.delete(n.id)
					break
			}
		t.complete?.()
	}
	add(e, t) {
		let n = ze.parentId(e.item.extId)?.toString(),
			r
		if (!n) (r = this.createItem(e)), this.roots.add(r), this.items.set(e.item.extId, r)
		else if (this.items.has(n)) {
			let i = this.items.get(n)
			i.children.add(e.item.extId), (r = this.createItem(e, i)), this.items.set(e.item.extId, r)
		} else {
			console.error(`Test with unknown parent ID: ${JSON.stringify(e)}`)
			return
		}
		return t.add?.(r), e.expand === 2 && this.busyControllerCount++, r
	}
	update(e, t) {
		let n = this.items.get(e.extId)
		if (n)
			return (
				e.expand !== void 0 &&
					(n.expand === 2 && this.busyControllerCount--, e.expand === 2 && this.busyControllerCount++),
				Vy(n, e),
				t.update?.(n),
				n
			)
	}
	remove(e, t) {
		let n = this.items.get(e)
		if (!n) return
		let r = ze.parentId(n.item.extId)?.toString()
		r ? this.items.get(r).children.delete(n.item.extId) : this.roots.delete(n)
		let i = [[e]]
		for (; i.length; )
			for (let s of i.pop()) {
				let a = this.items.get(s)
				a &&
					(i.push(a.children),
					this.items.delete(s),
					t.remove?.(a, a !== n),
					a.expand === 2 && this.busyControllerCount--)
			}
	}
	retireTest(e) {}
	updatePendingRoots(e) {
		this.pendingRootCount += e
	}
	createChangeCollector() {
		return {}
	}
}
var $y = O("editorGroupsService")
var Vce = O("editorService"),
	CF = -1,
	SF = -2
var lg = (o, e) => o === e,
	k7 = {
		range: (o, e) => (o === e ? !0 : !o || !e ? !1 : o.equalsRange(e)),
		busy: lg,
		label: lg,
		description: lg,
		error: lg,
		sortText: lg,
		tags: (o, e) => !(o.length !== e.length || o.some((t) => !e.includes(t))),
	},
	R7 = Object.entries(k7),
	A7 = (o, e) => {
		let t
		for (let [n, r] of R7) r(o[n], e[n]) || (t ? (t[n] = e[n]) : (t = { [n]: e[n] }))
		return t
	},
	zy = class extends $ {
		constructor(t) {
			super()
			this.options = t
			this.debounceSendDiff = this._register(new Wn(() => this.flushDiff(), 200))
			this.diffOpEmitter = this._register(new E())
			this.tree = new Map()
			this.tags = new Map()
			this.diff = []
			this.onDidGenerateDiff = this.diffOpEmitter.event
			;(this.root.canResolveChildren = !0), this.upsertItem(this.root, void 0)
		}
		get root() {
			return this.options.root
		}
		set resolveHandler(t) {
			this._resolveHandler = t
			for (let n of this.tree.values()) this.updateExpandability(n)
		}
		get resolveHandler() {
			return this._resolveHandler
		}
		collectDiff() {
			let t = this.diff
			return (this.diff = []), t
		}
		pushDiff(t) {
			switch (t.op) {
				case 2: {
					for (let n of this.diff)
						if (n.op === 2 && n.uri === t.uri) {
							n.docv = t.docv
							return
						}
					break
				}
				case 1: {
					let n = this.diff[this.diff.length - 1]
					if (n) {
						if (n.op === 1 && n.item.extId === t.item.extId) {
							Vy(n.item, t.item)
							return
						}
						if (n.op === 0 && n.item.item.extId === t.item.extId) {
							Vy(n.item, t.item)
							return
						}
					}
					break
				}
			}
			this.diff.push(t), this.debounceSendDiff.isScheduled() || this.debounceSendDiff.schedule()
		}
		expand(t, n) {
			let r = this.tree.get(t)
			if (r) {
				if (((r.expandLevels === void 0 || n > r.expandLevels) && (r.expandLevels = n), r.expand === 1)) {
					let i = this.resolveChildren(r)
					return i.isOpen()
						? this.expandChildren(r, n - 1)
						: i.wait().then(() => this.expandChildren(r, n - 1))
				} else if (r.expand === 3)
					return r.resolveBarrier?.isOpen() === !1
						? r.resolveBarrier.wait().then(() => this.expandChildren(r, n - 1))
						: this.expandChildren(r, n - 1)
			}
		}
		dispose() {
			for (let t of this.tree.values()) this.options.getApiFor(t.actual).listener = void 0
			this.tree.clear(), (this.diff = []), super.dispose()
		}
		onTestItemEvent(t, n) {
			switch (n.op) {
				case 3:
					this.removeItem(ze.joinToString(t.fullId, n.id))
					break
				case 0:
					this.upsertItem(n.item, t)
					break
				case 5:
					for (let r of n.ops) this.onTestItemEvent(t, r)
					break
				case 1:
					this.diffTagRefs(n.new, n.old, t.fullId.toString())
					break
				case 2:
					this.updateExpandability(t)
					break
				case 4:
					this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), item: n.update } })
					break
				case 6:
					this.documentSynced(t.actual.uri)
					break
				default:
					gc(n)
			}
		}
		documentSynced(t) {
			t && this.pushDiff({ op: 2, uri: t, docv: this.options.getDocumentVersion(t) })
		}
		upsertItem(t, n) {
			let r = ze.fromExtHostTestItem(t, this.root.id, n?.actual),
				i = this.options.getApiFor(t)
			i.parent && i.parent !== n?.actual && this.options.getChildren(i.parent).delete(t.id)
			let s = this.tree.get(r.toString())
			if (!s) {
				;(s = { fullId: r, actual: t, expandLevels: n?.expandLevels ? n.expandLevels - 1 : void 0, expand: 0 }),
					t.tags.forEach(this.incrementTagRefs, this),
					this.tree.set(s.fullId.toString(), s),
					this.setItemParent(t, n),
					this.pushDiff({
						op: 0,
						item: {
							controllerId: this.options.controllerId,
							expand: s.expand,
							item: this.options.toITestItem(t),
						},
					}),
					this.connectItemAndChildren(t, s, n)
				return
			}
			if (s.actual === t) {
				this.connectItem(t, s, n)
				return
			}
			if (s.actual.uri?.toString() !== t.uri?.toString())
				return this.removeItem(r.toString()), this.upsertItem(t, n)
			let a = this.options.getChildren(s.actual),
				l = s.actual,
				d = A7(this.options.toITestItem(l), this.options.toITestItem(t))
			;(this.options.getApiFor(l).listener = void 0),
				(s.actual = t),
				(s.resolveBarrier = void 0),
				(s.expand = 0),
				d &&
					(d.hasOwnProperty("tags") && (this.diffTagRefs(t.tags, l.tags, r.toString()), delete d.tags),
					this.onTestItemEvent(s, { op: 4, update: d })),
				this.connectItemAndChildren(t, s, n)
			for (let [u, m] of a) this.options.getChildren(t).get(m.id) || this.removeItem(ze.joinToString(r, m.id))
			let c = s.expandLevels
			c !== void 0 &&
				queueMicrotask(() => {
					s.expand === 1 && ((s.expandLevels = void 0), this.expand(r.toString(), c))
				}),
				this.documentSynced(s.actual.uri)
		}
		diffTagRefs(t, n, r) {
			let i = new Set(n.map((s) => s.id))
			for (let s of t) i.delete(s.id) || this.incrementTagRefs(s)
			this.pushDiff({
				op: 1,
				item: { extId: r, item: { tags: t.map((s) => du(this.options.controllerId, s.id)) } },
			}),
				i.forEach(this.decrementTagRefs, this)
		}
		incrementTagRefs(t) {
			let n = this.tags.get(t.id)
			n
				? n.refCount++
				: (this.tags.set(t.id, { refCount: 1 }),
					this.pushDiff({ op: 6, tag: { id: du(this.options.controllerId, t.id) } }))
		}
		decrementTagRefs(t) {
			let n = this.tags.get(t)
			n && !--n.refCount && (this.tags.delete(t), this.pushDiff({ op: 7, id: du(this.options.controllerId, t) }))
		}
		setItemParent(t, n) {
			this.options.getApiFor(t).parent = n && n.actual !== this.root ? n.actual : void 0
		}
		connectItem(t, n, r) {
			this.setItemParent(t, r)
			let i = this.options.getApiFor(t)
			;(i.parent = r?.actual), (i.listener = (s) => this.onTestItemEvent(n, s)), this.updateExpandability(n)
		}
		connectItemAndChildren(t, n, r) {
			this.connectItem(t, n, r)
			for (let [i, s] of this.options.getChildren(t)) this.upsertItem(s, n)
		}
		updateExpandability(t) {
			let n
			this._resolveHandler
				? t.resolveBarrier
					? (n = t.resolveBarrier.isOpen() ? 3 : 2)
					: (n = t.actual.canResolveChildren ? 1 : 0)
				: (n = 0),
				n !== t.expand &&
					((t.expand = n),
					this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), expand: n } }),
					n === 1 && t.expandLevels !== void 0 && this.resolveChildren(t))
		}
		expandChildren(t, n) {
			if (n < 0) return
			let r = []
			for (let [i, s] of this.options.getChildren(t.actual)) {
				let a = this.expand(ze.joinToString(t.fullId, s.id), n)
				ao(a) && r.push(a)
			}
			if (r.length) return Promise.all(r).then(() => {})
		}
		resolveChildren(t) {
			if (t.resolveBarrier) return t.resolveBarrier
			if (!this._resolveHandler) {
				let s = new dn()
				return s.open(), s
			}
			;(t.expand = 2), this.pushExpandStateUpdate(t)
			let n = (t.resolveBarrier = new dn()),
				r = (s) => {
					console.error(
						`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`,
						s,
					)
				},
				i
			try {
				i = this._resolveHandler(t.actual === this.root ? void 0 : t.actual)
			} catch (s) {
				r(s)
			}
			return (
				ao(i)
					? i.catch(r).then(() => {
							n.open(), this.updateExpandability(t)
						})
					: (n.open(), this.updateExpandability(t)),
				t.resolveBarrier
			)
		}
		pushExpandStateUpdate(t) {
			this.pushDiff({ op: 1, item: { extId: t.fullId.toString(), expand: t.expand } })
		}
		removeItem(t) {
			let n = this.tree.get(t)
			if (!n) throw new Error("attempting to remove non-existent child")
			this.pushDiff({ op: 3, itemId: t })
			let r = [n]
			for (; r.length; ) {
				let i = r.pop()
				if (i) {
					this.options.getApiFor(i.actual).listener = void 0
					for (let s of i.actual.tags) this.decrementTagRefs(s.id)
					this.tree.delete(i.fullId.toString())
					for (let [s, a] of this.options.getChildren(i.actual))
						r.push(this.tree.get(ze.joinToString(i.fullId, a.id)))
				}
			}
		}
		flushDiff() {
			let t = this.collectDiff()
			t.length && this.diffOpEmitter.fire(t)
		}
	},
	K_ = class extends Error {
		constructor(e) {
			super(`Attempted to insert a duplicate test item ID ${e}`)
		}
	},
	Pa = class extends Error {
		constructor(e) {
			super(`TestItem with ID "${e}" is invalid. Make sure to create it from the createTestItem method.`)
		}
	},
	j_ = class extends Error {
		constructor(e, t, n) {
			super(
				`TestItem with ID "${e}" is from controller "${t}" and cannot be added as a child of an item from controller "${n}".`,
			)
		}
	},
	TF = (o, e, t) => {
		let n = new Map()
		return {
			get size() {
				return n.size
			},
			forEach(r, i) {
				for (let s of n.values()) r.call(i, s, this)
			},
			[Symbol.iterator]() {
				return n.entries()
			},
			replace(r) {
				let i = new Map(),
					s = new Set(n.keys()),
					a = { op: 5, ops: [] }
				for (let l of r) {
					if (!(l instanceof t)) throw new Pa(l.id)
					let d = e(l).controllerId
					if (d !== o.controllerId) throw new j_(l.id, d, o.controllerId)
					if (i.has(l.id)) throw new K_(l.id)
					i.set(l.id, l), s.delete(l.id), a.ops.push({ op: 0, item: l })
				}
				for (let l of s.keys()) a.ops.push({ op: 3, id: l })
				o.listener?.(a), (n = i)
			},
			add(r) {
				if (!(r instanceof t)) throw new Pa(r.id)
				n.set(r.id, r), o.listener?.({ op: 0, item: r })
			},
			delete(r) {
				n.delete(r) && o.listener?.({ op: 3, id: r })
			},
			get(r) {
				return n.get(r)
			},
			toJSON() {
				return Array.from(n.values())
			},
		}
	}
var EF = new WeakMap(),
	wF = (o, e) => {
		let t = { controllerId: e }
		return EF.set(o, t), t
	},
	cu = (o) => {
		let e = EF.get(o)
		if (!e) throw new Pa(o?.id || "<unknown>")
		return e
	}
var PF = O("remoteAuthorityResolverService")
var uu = class {
		constructor(e) {
			this.id = e
			this.type = 1
		}
		toString() {
			return `Managed(${this.id})`
		}
	},
	qy = class {
		constructor(e, t) {
			this.host = e
			this.port = t
			this.type = 0
		}
		toString() {
			return `WebSocket(${this.host}:${this.port})`
		}
	}
var pu = class o extends jn {
	static isNotAvailable(e) {
		return e instanceof o && e._code === "NotAvailable"
	}
	static isTemporarilyNotAvailable(e) {
		return e instanceof o && e._code === "TemporarilyNotAvailable"
	}
	static isNoResolverFound(e) {
		return e instanceof o && e._code === "NoResolverFound"
	}
	static isInvalidAuthority(e) {
		return e instanceof o && e._code === "InvalidAuthority"
	}
	static isHandled(e) {
		return e instanceof o && e.isHandled
	}
	constructor(e, t = "Unknown", n) {
		super(e),
			(this._message = e),
			(this._code = t),
			(this._detail = n),
			(this.isHandled = t === "NotAvailable" && n === !0),
			Object.setPrototypeOf(this, o.prototype)
	}
}
function G_(o) {
	let e = o.indexOf("+")
	return e === -1 ? o : o.substring(0, e)
}
function me(o) {
	return Object.assign(o, {
		apply: function (...t) {
			if (t.length === 0) return Reflect.construct(o, [])
			{
				let n = t.length === 1 ? [] : t[1]
				return Reflect.construct(o, n, t[0].constructor)
			}
		},
		call: function (...t) {
			if (t.length === 0) return Reflect.construct(o, [])
			{
				let [n, ...r] = t
				return Reflect.construct(o, r, n.constructor)
			}
		},
	})
}
var Q_ = ((t) => ((t[(t.Top = 0)] = "Top"), (t[(t.Bottom = 1)] = "Bottom"), t))(Q_ || {})
var gd,
	ye = class {
		constructor(e) {
			Ym(this, gd)
			sv(this, gd, e)
		}
		static from(...e) {
			let t = e
			return new ye(function () {
				if (t) {
					for (let n of t) n && typeof n.dispose == "function" && n.dispose()
					t = void 0
				}
			})
		}
		dispose() {
			typeof sn(this, gd) == "function" && (sn(this, gd).call(this), sv(this, gd, void 0))
		}
	}
;(gd = new WeakMap()), (ye = R([me], ye))
var Pe = class {
	static Min(...e) {
		if (e.length === 0) throw new TypeError()
		let t = e[0]
		for (let n = 1; n < e.length; n++) {
			let r = e[n]
			r.isBefore(t) && (t = r)
		}
		return t
	}
	static Max(...e) {
		if (e.length === 0) throw new TypeError()
		let t = e[0]
		for (let n = 1; n < e.length; n++) {
			let r = e[n]
			r.isAfter(t) && (t = r)
		}
		return t
	}
	static isPosition(e) {
		if (!e) return !1
		if (e instanceof Pe) return !0
		let { line: t, character: n } = e
		return typeof t == "number" && typeof n == "number"
	}
	static of(e) {
		if (e instanceof Pe) return e
		if (this.isPosition(e)) return new Pe(e.line, e.character)
		throw new Error("Invalid argument, is NOT a position-like object")
	}
	get line() {
		return this._line
	}
	get character() {
		return this._character
	}
	constructor(e, t) {
		if (e < 0) throw We("line must be non-negative")
		if (t < 0) throw We("character must be non-negative")
		;(this._line = e), (this._character = t)
	}
	isBefore(e) {
		return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character < e._character
	}
	isBeforeOrEqual(e) {
		return this._line < e._line ? !0 : e._line < this._line ? !1 : this._character <= e._character
	}
	isAfter(e) {
		return !this.isBeforeOrEqual(e)
	}
	isAfterOrEqual(e) {
		return !this.isBefore(e)
	}
	isEqual(e) {
		return this._line === e._line && this._character === e._character
	}
	compareTo(e) {
		return this._line < e._line
			? -1
			: this._line > e.line
				? 1
				: this._character < e._character
					? -1
					: this._character > e._character
						? 1
						: 0
	}
	translate(e, t = 0) {
		if (e === null || t === null) throw We()
		let n
		return (
			typeof e > "u"
				? (n = 0)
				: typeof e == "number"
					? (n = e)
					: ((n = typeof e.lineDelta == "number" ? e.lineDelta : 0),
						(t = typeof e.characterDelta == "number" ? e.characterDelta : 0)),
			n === 0 && t === 0 ? this : new Pe(this.line + n, this.character + t)
		)
	}
	with(e, t = this.character) {
		if (e === null || t === null) throw We()
		let n
		return (
			typeof e > "u"
				? (n = this.line)
				: typeof e == "number"
					? (n = e)
					: ((n = typeof e.line == "number" ? e.line : this.line),
						(t = typeof e.character == "number" ? e.character : this.character)),
			n === this.line && t === this.character ? this : new Pe(n, t)
		)
	}
	toJSON() {
		return { line: this.line, character: this.character }
	}
	[Symbol.for("debug.description")]() {
		return `(${this.line}:${this.character})`
	}
}
Pe = R([me], Pe)
var pe = class {
	static isRange(e) {
		return e instanceof pe ? !0 : e ? Pe.isPosition(e.start) && Pe.isPosition(e.end) : !1
	}
	static of(e) {
		if (e instanceof pe) return e
		if (this.isRange(e)) return new pe(e.start, e.end)
		throw new Error("Invalid argument, is NOT a range-like object")
	}
	get start() {
		return this._start
	}
	get end() {
		return this._end
	}
	constructor(e, t, n, r) {
		let i, s
		if (
			(typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof r == "number"
				? ((i = new Pe(e, t)), (s = new Pe(n, r)))
				: Pe.isPosition(e) && Pe.isPosition(t) && ((i = Pe.of(e)), (s = Pe.of(t))),
			!i || !s)
		)
			throw new Error("Invalid arguments")
		i.isBefore(s) ? ((this._start = i), (this._end = s)) : ((this._start = s), (this._end = i))
	}
	contains(e) {
		return pe.isRange(e)
			? this.contains(e.start) && this.contains(e.end)
			: Pe.isPosition(e)
				? !(Pe.of(e).isBefore(this._start) || this._end.isBefore(e))
				: !1
	}
	isEqual(e) {
		return this._start.isEqual(e._start) && this._end.isEqual(e._end)
	}
	intersection(e) {
		let t = Pe.Max(e.start, this._start),
			n = Pe.Min(e.end, this._end)
		if (!t.isAfter(n)) return new pe(t, n)
	}
	union(e) {
		if (this.contains(e)) return this
		if (e.contains(this)) return e
		let t = Pe.Min(e.start, this._start),
			n = Pe.Max(e.end, this.end)
		return new pe(t, n)
	}
	get isEmpty() {
		return this._start.isEqual(this._end)
	}
	get isSingleLine() {
		return this._start.line === this._end.line
	}
	with(e, t = this.end) {
		if (e === null || t === null) throw We()
		let n
		return (
			e
				? Pe.isPosition(e)
					? (n = e)
					: ((n = e.start || this.start), (t = e.end || this.end))
				: (n = this.start),
			n.isEqual(this._start) && t.isEqual(this.end) ? this : new pe(n, t)
		)
	}
	toJSON() {
		return [this.start, this.end]
	}
	[Symbol.for("debug.description")]() {
		return DF(this)
	}
}
pe = R([me], pe)
var Bn = class extends pe {
	static isSelection(e) {
		return e instanceof Bn
			? !0
			: e
				? pe.isRange(e) &&
					Pe.isPosition(e.anchor) &&
					Pe.isPosition(e.active) &&
					typeof e.isReversed == "boolean"
				: !1
	}
	get anchor() {
		return this._anchor
	}
	get active() {
		return this._active
	}
	constructor(e, t, n, r) {
		let i, s
		if (
			(typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof r == "number"
				? ((i = new Pe(e, t)), (s = new Pe(n, r)))
				: Pe.isPosition(e) && Pe.isPosition(t) && ((i = Pe.of(e)), (s = Pe.of(t))),
			!i || !s)
		)
			throw new Error("Invalid arguments")
		super(i, s), (this._anchor = i), (this._active = s)
	}
	get isReversed() {
		return this._anchor === this._end
	}
	toJSON() {
		return { start: this.start, end: this.end, active: this.active, anchor: this.anchor }
	}
	[Symbol.for("debug.description")]() {
		return L7(this)
	}
}
Bn = R([me], Bn)
function DF(o) {
	return o.isEmpty
		? `[${o.start.line}:${o.start.character})`
		: `[${o.start.line}:${o.start.character} -> ${o.end.line}:${o.end.character})`
}
function L7(o) {
	let e = DF(o)
	return o.isEmpty || (o.active.isEqual(o.start) ? (e = `|${e}`) : (e = `${e}|`)), e
}
var kF = (o) => {
		if (typeof o != "string" || o.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(o)) throw We("connectionToken")
	},
	Ky = class {
		static isResolvedAuthority(e) {
			return (
				e &&
				typeof e == "object" &&
				typeof e.host == "string" &&
				typeof e.port == "number" &&
				(e.connectionToken === void 0 || typeof e.connectionToken == "string")
			)
		}
		constructor(e, t, n) {
			if (typeof e != "string" || e.length === 0) throw We("host")
			if (typeof t != "number" || t === 0 || Math.round(t) !== t) throw We("port")
			typeof n < "u" && kF(n), (this.host = e), (this.port = Math.round(t)), (this.connectionToken = n)
		}
	},
	za = class {
		constructor(e, t) {
			this.makeConnection = e
			this.connectionToken = t
			typeof t < "u" && kF(t)
		}
		static isManagedResolvedAuthority(e) {
			return (
				e &&
				typeof e == "object" &&
				typeof e.makeConnection == "function" &&
				(e.connectionToken === void 0 || typeof e.connectionToken == "string")
			)
		}
	},
	_i = class o extends Error {
		static NotAvailable(e, t) {
			return new o(e, "NotAvailable", t)
		}
		static TemporarilyNotAvailable(e) {
			return new o(e, "TemporarilyNotAvailable")
		}
		constructor(e, t = "Unknown", n) {
			super(e),
				(this._message = e),
				(this._code = t),
				(this._detail = n),
				Object.setPrototypeOf(this, o.prototype)
		}
	},
	Gu = ((t) => ((t[(t.LF = 1)] = "LF"), (t[(t.CRLF = 2)] = "CRLF"), t))(Gu || {}),
	vI = ((n) => (
		(n[(n.Replace = 1)] = "Replace"), (n[(n.Append = 2)] = "Append"), (n[(n.Prepend = 3)] = "Prepend"), n
	))(vI || {}),
	Mn = class {
		static isTextEdit(e) {
			return e instanceof Mn ? !0 : e ? pe.isRange(e) && typeof e.newText == "string" : !1
		}
		static replace(e, t) {
			return new Mn(e, t)
		}
		static insert(e, t) {
			return Mn.replace(new pe(e, e), t)
		}
		static delete(e) {
			return Mn.replace(e, "")
		}
		static setEndOfLine(e) {
			let t = new Mn(new pe(new Pe(0, 0), new Pe(0, 0)), "")
			return (t.newEol = e), t
		}
		get range() {
			return this._range
		}
		set range(e) {
			if (e && !pe.isRange(e)) throw We("range")
			this._range = e
		}
		get newText() {
			return this._newText || ""
		}
		set newText(e) {
			if (e && typeof e != "string") throw We("newText")
			this._newText = e
		}
		get newEol() {
			return this._newEol
		}
		set newEol(e) {
			if (e && typeof e != "number") throw We("newEol")
			this._newEol = e
		}
		constructor(e, t) {
			;(this._range = e), (this._newText = t)
		}
		toJSON() {
			return { range: this.range, newText: this.newText, newEol: this._newEol }
		}
	}
Mn = R([me], Mn)
var Ur = class {
	static isNotebookCellEdit(e) {
		return e instanceof Ur ? !0 : e ? cr.isNotebookRange(e) && Array.isArray(e.newCells) : !1
	}
	static replaceCells(e, t) {
		return new Ur(e, t)
	}
	static insertCells(e, t) {
		return new Ur(new cr(e, e), t)
	}
	static deleteCells(e) {
		return new Ur(e, [])
	}
	static updateCellMetadata(e, t) {
		let n = new Ur(new cr(e, e), [])
		return (n.newCellMetadata = t), n
	}
	static updateNotebookMetadata(e) {
		let t = new Ur(new cr(0, 0), [])
		return (t.newNotebookMetadata = e), t
	}
	constructor(e, t) {
		;(this.range = e), (this.newCells = t)
	}
}
Ur = R([me], Ur)
var bd = class o {
	static isSnippetTextEdit(e) {
		return e instanceof o ? !0 : e ? pe.isRange(e.range) && Vn.isSnippetString(e.snippet) : !1
	}
	static replace(e, t) {
		return new o(e, t)
	}
	static insert(e, t) {
		return o.replace(new pe(e, e), t)
	}
	constructor(e, t) {
		;(this.range = e), (this.snippet = t)
	}
}
var Yr = class {
	constructor() {
		this._edits = []
	}
	_allEntries() {
		return this._edits
	}
	renameFile(e, t, n, r) {
		this._edits.push({ _type: 1, from: e, to: t, options: n, metadata: r })
	}
	createFile(e, t, n) {
		this._edits.push({ _type: 1, from: void 0, to: e, options: t, metadata: n })
	}
	deleteFile(e, t, n) {
		this._edits.push({ _type: 1, from: e, to: void 0, options: t, metadata: n })
	}
	replaceNotebookMetadata(e, t, n) {
		this._edits.push({ _type: 3, metadata: n, uri: e, edit: { editType: 5, metadata: t } })
	}
	replaceNotebookCells(e, t, n, r) {
		let i = t.start,
			s = t.end
		;(i !== s || n.length > 0) &&
			this._edits.push({ _type: 5, uri: e, index: i, count: s - i, cells: n, metadata: r })
	}
	replaceNotebookCellMetadata(e, t, n, r) {
		this._edits.push({ _type: 3, metadata: r, uri: e, edit: { editType: 3, index: t, metadata: n } })
	}
	replace(e, t, n, r) {
		this._edits.push({ _type: 2, uri: e, edit: new Mn(t, n), metadata: r })
	}
	insert(e, t, n, r) {
		this.replace(e, new pe(t, t), n, r)
	}
	delete(e, t, n) {
		this.replace(e, t, "", n)
	}
	has(e) {
		return this._edits.some((t) => t._type === 2 && t.uri.toString() === e.toString())
	}
	set(e, t) {
		if (t)
			for (let n of t) {
				if (!n) continue
				let r, i
				Array.isArray(n) ? ((r = n[0]), (i = n[1])) : (r = n),
					Ur.isNotebookCellEdit(r)
						? r.newCellMetadata
							? this.replaceNotebookCellMetadata(e, r.range.start, r.newCellMetadata, i)
							: r.newNotebookMetadata
								? this.replaceNotebookMetadata(e, r.newNotebookMetadata, i)
								: this.replaceNotebookCells(e, r.range, r.newCells, i)
						: bd.isSnippetTextEdit(r)
							? this._edits.push({
									_type: 6,
									uri: e,
									range: r.range,
									edit: r.snippet,
									metadata: i,
									keepWhitespace: r.keepWhitespace,
								})
							: this._edits.push({ _type: 2, uri: e, edit: r, metadata: i })
			}
		else {
			for (let n = 0; n < this._edits.length; n++) {
				let r = this._edits[n]
				switch (r._type) {
					case 2:
					case 6:
					case 3:
					case 5:
						r.uri.toString() === e.toString() && (this._edits[n] = void 0)
						break
				}
			}
			J0(this._edits)
		}
	}
	get(e) {
		let t = []
		for (let n of this._edits) n._type === 2 && n.uri.toString() === e.toString() && t.push(n.edit)
		return t
	}
	entries() {
		let e = new ft()
		for (let t of this._edits)
			if (t._type === 2) {
				let n = e.get(t.uri)
				n || ((n = [t.uri, []]), e.set(t.uri, n)), n[1].push(t.edit)
			}
		return [...e.values()]
	}
	get size() {
		return this.entries().length
	}
	toJSON() {
		return this.entries()
	}
}
Yr = R([me], Yr)
var Vn = class {
	constructor(e) {
		this._tabstop = 1
		this.value = e || ""
	}
	static isSnippetString(e) {
		return e instanceof Vn ? !0 : e ? typeof e.value == "string" : !1
	}
	static _escape(e) {
		return e.replace(/\$|}|\\/g, "\\$&")
	}
	appendText(e) {
		return (this.value += Vn._escape(e)), this
	}
	appendTabstop(e = this._tabstop++) {
		return (this.value += "$"), (this.value += e), this
	}
	appendPlaceholder(e, t = this._tabstop++) {
		if (typeof e == "function") {
			let n = new Vn()
			;(n._tabstop = this._tabstop), e(n), (this._tabstop = n._tabstop), (e = n.value)
		} else e = Vn._escape(e)
		return (
			(this.value += "${"), (this.value += t), (this.value += ":"), (this.value += e), (this.value += "}"), this
		)
	}
	appendChoice(e, t = this._tabstop++) {
		let n = e.map((r) => r.replaceAll(/[|\\,]/g, "\\$&")).join(",")
		return (
			(this.value += "${"), (this.value += t), (this.value += "|"), (this.value += n), (this.value += "|}"), this
		)
	}
	appendVariable(e, t) {
		if (typeof t == "function") {
			let n = new Vn()
			;(n._tabstop = this._tabstop), t(n), (this._tabstop = n._tabstop), (t = n.value)
		} else typeof t == "string" && (t = t.replace(/\$|}/g, "\\$&"))
		return (
			(this.value += "${"),
			(this.value += e),
			t && ((this.value += ":"), (this.value += t)),
			(this.value += "}"),
			this
		)
	}
}
Vn = R([me], Vn)
var bI = ((t) => ((t[(t.Unnecessary = 1)] = "Unnecessary"), (t[(t.Deprecated = 2)] = "Deprecated"), t))(bI || {}),
	Qu = ((r) => (
		(r[(r.Hint = 3)] = "Hint"),
		(r[(r.Information = 2)] = "Information"),
		(r[(r.Warning = 1)] = "Warning"),
		(r[(r.Error = 0)] = "Error"),
		r
	))(Qu || {}),
	rn = class {
		static isLocation(e) {
			return e instanceof rn ? !0 : e ? pe.isRange(e.range) && b.isUri(e.uri) : !1
		}
		constructor(e, t) {
			if (((this.uri = e), t))
				if (pe.isRange(t)) this.range = pe.of(t)
				else if (Pe.isPosition(t)) this.range = new pe(t, t)
				else throw new Error("Illegal argument")
		}
		toJSON() {
			return { uri: this.uri, range: this.range }
		}
	}
rn = R([me], rn)
var ys = class {
	static is(e) {
		return e
			? typeof e.message == "string" && e.location && pe.isRange(e.location.range) && b.isUri(e.location.uri)
			: !1
	}
	constructor(e, t) {
		;(this.location = e), (this.message = t)
	}
	static isEqual(e, t) {
		return e === t
			? !0
			: !e || !t
				? !1
				: e.message === t.message &&
					e.location.range.isEqual(t.location.range) &&
					e.location.uri.toString() === t.location.uri.toString()
	}
}
ys = R([me], ys)
var _a = class {
	constructor(e, t, n = 0) {
		if (!pe.isRange(e)) throw new TypeError("range must be set")
		if (!t) throw new TypeError("message must be set")
		;(this.range = e), (this.message = t), (this.severity = n)
	}
	toJSON() {
		return {
			severity: Qu[this.severity],
			message: this.message,
			range: this.range,
			source: this.source,
			code: this.code,
		}
	}
	static isEqual(e, t) {
		return e === t
			? !0
			: !e || !t
				? !1
				: e.message === t.message &&
					e.severity === t.severity &&
					e.code === t.code &&
					e.severity === t.severity &&
					e.source === t.source &&
					e.range.isEqual(t.range) &&
					mn(e.tags, t.tags) &&
					mn(e.relatedInformation, t.relatedInformation, ys.isEqual)
	}
}
_a = R([me], _a)
var ud = class {
	constructor(e, t) {
		if (!e) throw new Error("Illegal argument, contents must be defined")
		Array.isArray(e) ? (this.contents = e) : (this.contents = [e]), (this.range = t)
	}
}
ud = R([me], ud)
var Da = class extends ud {
	constructor(e, t, n, r) {
		super(e, t), (this.canIncreaseVerbosity = n), (this.canDecreaseVerbosity = r)
	}
}
Da = R([me], Da)
var J_ = ((t) => ((t[(t.Increase = 0)] = "Increase"), (t[(t.Decrease = 1)] = "Decrease"), t))(J_ || {}),
	yI = ((n) => ((n[(n.Text = 0)] = "Text"), (n[(n.Read = 1)] = "Read"), (n[(n.Write = 2)] = "Write"), n))(yI || {}),
	ka = class {
		constructor(e, t = 0) {
			;(this.range = e), (this.kind = t)
		}
		toJSON() {
			return { range: this.range, kind: yI[this.kind] }
		}
	}
ka = R([me], ka)
var Ra = class {
	constructor(e, t) {
		;(this.uri = e), (this.highlights = t)
	}
	toJSON() {
		return { uri: this.uri, highlights: this.highlights.map((e) => e.toJSON()) }
	}
}
Ra = R([me], Ra)
var ug = ((j) => (
		(j[(j.File = 0)] = "File"),
		(j[(j.Module = 1)] = "Module"),
		(j[(j.Namespace = 2)] = "Namespace"),
		(j[(j.Package = 3)] = "Package"),
		(j[(j.Class = 4)] = "Class"),
		(j[(j.Method = 5)] = "Method"),
		(j[(j.Property = 6)] = "Property"),
		(j[(j.Field = 7)] = "Field"),
		(j[(j.Constructor = 8)] = "Constructor"),
		(j[(j.Enum = 9)] = "Enum"),
		(j[(j.Interface = 10)] = "Interface"),
		(j[(j.Function = 11)] = "Function"),
		(j[(j.Variable = 12)] = "Variable"),
		(j[(j.Constant = 13)] = "Constant"),
		(j[(j.String = 14)] = "String"),
		(j[(j.Number = 15)] = "Number"),
		(j[(j.Boolean = 16)] = "Boolean"),
		(j[(j.Array = 17)] = "Array"),
		(j[(j.Object = 18)] = "Object"),
		(j[(j.Key = 19)] = "Key"),
		(j[(j.Null = 20)] = "Null"),
		(j[(j.EnumMember = 21)] = "EnumMember"),
		(j[(j.Struct = 22)] = "Struct"),
		(j[(j.Event = 23)] = "Event"),
		(j[(j.Operator = 24)] = "Operator"),
		(j[(j.TypeParameter = 25)] = "TypeParameter"),
		j
	))(ug || {}),
	II = ((e) => ((e[(e.Deprecated = 1)] = "Deprecated"), e))(II || {}),
	vo = class {
		static validate(e) {
			if (!e.name) throw new Error("name must not be falsy")
		}
		constructor(e, t, n, r, i) {
			;(this.name = e),
				(this.kind = t),
				(this.containerName = i),
				typeof n == "string" && (this.containerName = n),
				r instanceof rn ? (this.location = r) : n instanceof pe && (this.location = new rn(r, n)),
				vo.validate(this)
		}
		toJSON() {
			return { name: this.name, kind: ug[this.kind], location: this.location, containerName: this.containerName }
		}
	}
vo = R([me], vo)
var Zr = class {
	static validate(e) {
		if (!e.name) throw new Error("name must not be falsy")
		if (!e.range.contains(e.selectionRange)) throw new Error("selectionRange must be contained in fullRange")
		e.children?.forEach(Zr.validate)
	}
	constructor(e, t, n, r, i) {
		;(this.name = e),
			(this.detail = t),
			(this.kind = n),
			(this.range = r),
			(this.selectionRange = i),
			(this.children = []),
			Zr.validate(this)
	}
}
Zr = R([me], Zr)
var xI = ((t) => ((t[(t.Invoke = 1)] = "Invoke"), (t[(t.Automatic = 2)] = "Automatic"), t))(xI || {}),
	xi = class {
		constructor(e, t) {
			;(this.title = e), (this.kind = t)
		}
	}
xi = R([me], xi)
var lt = class {
	constructor(e) {
		this.value = e
	}
	append(e) {
		return new lt(this.value ? this.value + lt.sep + e : e)
	}
	intersects(e) {
		return this.contains(e) || e.contains(this)
	}
	contains(e) {
		return this.value === e.value || e.value.startsWith(this.value + lt.sep)
	}
}
;(lt.sep = "."), (lt = R([me], lt))
lt.Empty = new lt("")
lt.QuickFix = lt.Empty.append("quickfix")
lt.Refactor = lt.Empty.append("refactor")
lt.RefactorExtract = lt.Refactor.append("extract")
lt.RefactorInline = lt.Refactor.append("inline")
lt.RefactorMove = lt.Refactor.append("move")
lt.RefactorRewrite = lt.Refactor.append("rewrite")
lt.Source = lt.Empty.append("source")
lt.SourceOrganizeImports = lt.Source.append("organizeImports")
lt.SourceFixAll = lt.Source.append("fixAll")
lt.Notebook = lt.Empty.append("notebook")
var Ci = class {
	constructor(e, t) {
		if (((this.range = e), (this.parent = t), t && !t.range.contains(this.range)))
			throw new Error("Invalid argument: parent must contain this range")
	}
}
Ci = R([me], Ci)
var qa = class {
		constructor(e, t, n, r, i, s) {
			;(this.kind = e),
				(this.name = t),
				(this.detail = n),
				(this.uri = r),
				(this.range = i),
				(this.selectionRange = s)
		}
	},
	Cu = class {
		constructor(e, t) {
			;(this.fromRanges = t), (this.from = e)
		}
	},
	Su = class {
		constructor(e, t) {
			;(this.fromRanges = t), (this.to = e)
		}
	},
	CI = ((n) => (
		(n[(n.Information = 0)] = "Information"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Error = 2)] = "Error"), n
	))(CI || {}),
	Aa = class {
		constructor(e, t) {
			;(this.range = e), (this.command = t)
		}
		get isResolved() {
			return !!this.command
		}
	}
Aa = R([me], Aa)
var Zn,
	en = class {
		constructor(e, t = !1) {
			Ym(this, Zn)
			sv(this, Zn, new $o(e, { supportThemeIcons: t }))
		}
		static isMarkdownString(e) {
			return e instanceof en
				? !0
				: e && e.appendCodeblock && e.appendMarkdown && e.appendText && e.value !== void 0
		}
		get value() {
			return sn(this, Zn).value
		}
		set value(e) {
			sn(this, Zn).value = e
		}
		get isTrusted() {
			return sn(this, Zn).isTrusted
		}
		set isTrusted(e) {
			sn(this, Zn).isTrusted = e
		}
		get supportThemeIcons() {
			return sn(this, Zn).supportThemeIcons
		}
		set supportThemeIcons(e) {
			sn(this, Zn).supportThemeIcons = e
		}
		get supportHtml() {
			return sn(this, Zn).supportHtml
		}
		set supportHtml(e) {
			sn(this, Zn).supportHtml = e
		}
		get baseUri() {
			return sn(this, Zn).baseUri
		}
		set baseUri(e) {
			sn(this, Zn).baseUri = e
		}
		appendText(e) {
			return sn(this, Zn).appendText(e), this
		}
		appendMarkdown(e) {
			return sn(this, Zn).appendMarkdown(e), this
		}
		appendCodeblock(e, t) {
			return sn(this, Zn).appendCodeblock(t ?? "", e), this
		}
	}
;(Zn = new WeakMap()), (en = R([me], en))
var mu = class {
	constructor(e, t) {
		;(this.label = e), (this.documentation = t)
	}
}
mu = R([me], mu)
var fu = class {
	constructor(e, t) {
		;(this.label = e), (this.documentation = t), (this.parameters = [])
	}
}
fu = R([me], fu)
var gu = class {
	constructor() {
		this.activeSignature = 0
		this.activeParameter = 0
		this.signatures = []
	}
}
gu = R([me], gu)
var X_ = ((n) => (
		(n[(n.Invoke = 1)] = "Invoke"),
		(n[(n.TriggerCharacter = 2)] = "TriggerCharacter"),
		(n[(n.ContentChange = 3)] = "ContentChange"),
		n
	))(X_ || {}),
	Y_ = ((t) => ((t[(t.Type = 1)] = "Type"), (t[(t.Parameter = 2)] = "Parameter"), t))(Y_ || {}),
	Oa = class {
		constructor(e) {
			this.value = e
		}
	}
Oa = R([me], Oa)
var La = class {
	constructor(e, t, n) {
		;(this.position = e), (this.label = t), (this.kind = n)
	}
}
La = R([me], La)
var SI = ((n) => (
		(n[(n.Invoke = 0)] = "Invoke"),
		(n[(n.TriggerCharacter = 1)] = "TriggerCharacter"),
		(n[(n.TriggerForIncompleteCompletions = 2)] = "TriggerForIncompleteCompletions"),
		n
	))(SI || {}),
	pg = ((K) => (
		(K[(K.Text = 0)] = "Text"),
		(K[(K.Method = 1)] = "Method"),
		(K[(K.Function = 2)] = "Function"),
		(K[(K.Constructor = 3)] = "Constructor"),
		(K[(K.Field = 4)] = "Field"),
		(K[(K.Variable = 5)] = "Variable"),
		(K[(K.Class = 6)] = "Class"),
		(K[(K.Interface = 7)] = "Interface"),
		(K[(K.Module = 8)] = "Module"),
		(K[(K.Property = 9)] = "Property"),
		(K[(K.Unit = 10)] = "Unit"),
		(K[(K.Value = 11)] = "Value"),
		(K[(K.Enum = 12)] = "Enum"),
		(K[(K.Keyword = 13)] = "Keyword"),
		(K[(K.Snippet = 14)] = "Snippet"),
		(K[(K.Color = 15)] = "Color"),
		(K[(K.File = 16)] = "File"),
		(K[(K.Reference = 17)] = "Reference"),
		(K[(K.Folder = 18)] = "Folder"),
		(K[(K.EnumMember = 19)] = "EnumMember"),
		(K[(K.Constant = 20)] = "Constant"),
		(K[(K.Struct = 21)] = "Struct"),
		(K[(K.Event = 22)] = "Event"),
		(K[(K.Operator = 23)] = "Operator"),
		(K[(K.TypeParameter = 24)] = "TypeParameter"),
		(K[(K.User = 25)] = "User"),
		(K[(K.Issue = 26)] = "Issue"),
		K
	))(pg || {}),
	TI = ((e) => ((e[(e.Deprecated = 1)] = "Deprecated"), e))(TI || {}),
	Ma = class {
		constructor(e, t) {
			;(this.label = e), (this.kind = t)
		}
		toJSON() {
			return {
				label: this.label,
				kind: this.kind && pg[this.kind],
				detail: this.detail,
				documentation: this.documentation,
				sortText: this.sortText,
				filterText: this.filterText,
				preselect: this.preselect,
				insertText: this.insertText,
				textEdit: this.textEdit,
			}
		}
	}
Ma = R([me], Ma)
var zo = class {
	constructor(e = [], t = !1) {
		;(this.items = e), (this.isIncomplete = t)
	}
}
zo = R([me], zo)
var hu = class {
	constructor(e, t, n) {
		;(this.insertText = e), (this.range = t), (this.command = n)
	}
}
hu = R([me], hu)
var vu = class {
	constructor(e) {
		this.commands = void 0
		this.suppressSuggestions = void 0
		this.items = e
	}
}
vu = R([me], vu)
var EI = ((r) => (
		(r[(r.Unknown = 0)] = "Unknown"),
		(r[(r.Word = 1)] = "Word"),
		(r[(r.Line = 2)] = "Line"),
		(r[(r.Suggest = 3)] = "Suggest"),
		r
	))(EI || {}),
	wI = ((u) => (
		(u[(u.Active = -1)] = "Active"),
		(u[(u.Beside = -2)] = "Beside"),
		(u[(u.One = 1)] = "One"),
		(u[(u.Two = 2)] = "Two"),
		(u[(u.Three = 3)] = "Three"),
		(u[(u.Four = 4)] = "Four"),
		(u[(u.Five = 5)] = "Five"),
		(u[(u.Six = 6)] = "Six"),
		(u[(u.Seven = 7)] = "Seven"),
		(u[(u.Eight = 8)] = "Eight"),
		(u[(u.Nine = 9)] = "Nine"),
		u
	))(wI || {}),
	PI = ((t) => ((t[(t.Left = 1)] = "Left"), (t[(t.Right = 2)] = "Right"), t))(PI || {})
function RF(o, e) {
	return `${Ce.toKey(o)}.${e}`
}
var _I = ((r) => (
		(r[(r.Off = 0)] = "Off"),
		(r[(r.On = 1)] = "On"),
		(r[(r.Relative = 2)] = "Relative"),
		(r[(r.Interval = 3)] = "Interval"),
		r
	))(_I || {}),
	DI = ((n) => (
		(n[(n.Manual = 1)] = "Manual"), (n[(n.AfterDelay = 2)] = "AfterDelay"), (n[(n.FocusOut = 3)] = "FocusOut"), n
	))(DI || {}),
	kI = ((r) => (
		(r[(r.Default = 0)] = "Default"),
		(r[(r.InCenter = 1)] = "InCenter"),
		(r[(r.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
		(r[(r.AtTop = 3)] = "AtTop"),
		r
	))(kI || {}),
	Td = ((n) => (
		(n[(n.Keyboard = 1)] = "Keyboard"), (n[(n.Mouse = 2)] = "Mouse"), (n[(n.Command = 3)] = "Command"), n
	))(Td || {}),
	RI = ((n) => (
		(n[(n.Addition = 1)] = "Addition"),
		(n[(n.Deletion = 2)] = "Deletion"),
		(n[(n.Modification = 3)] = "Modification"),
		n
	))(RI || {}),
	AI = ((t) => ((t[(t.Undo = 1)] = "Undo"), (t[(t.Redo = 2)] = "Redo"), t))(AI || {}),
	OI = ((r) => (
		(r[(r.OpenOpen = 0)] = "OpenOpen"),
		(r[(r.ClosedClosed = 1)] = "ClosedClosed"),
		(r[(r.OpenClosed = 2)] = "OpenClosed"),
		(r[(r.ClosedOpen = 3)] = "ClosedOpen"),
		r
	))(OI || {})
;((e) => {
	function o(t) {
		switch (t) {
			case "keyboard":
				return 1
			case "mouse":
				return 2
			case "api":
			case "code.jump":
			case "code.navigation":
				return 3
		}
	}
	e.fromValue = o
})((Td ||= {}))
var Ed = ((r) => (
	(r[(r.Other = 0)] = "Other"),
	(r[(r.Comment = 1)] = "Comment"),
	(r[(r.String = 2)] = "String"),
	(r[(r.RegEx = 3)] = "RegEx"),
	r
))(Ed || {})
;((e) => {
	function o(t) {
		switch (t) {
			case 0:
				return "other"
			case 1:
				return "comment"
			case 2:
				return "string"
			case 3:
				return "regex"
		}
		return "other"
	}
	e.toString = o
})((Ed ||= {}))
var Fa = class {
	constructor(e, t) {
		if (t && !b.isUri(t)) throw We("target")
		if (!pe.isRange(e) || e.isEmpty) throw We("range")
		;(this.range = e), (this.target = t)
	}
}
Fa = R([me], Fa)
var qo = class {
	constructor(e, t, n, r) {
		;(this.red = e), (this.green = t), (this.blue = n), (this.alpha = r)
	}
}
qo = R([me], qo)
var Na = class {
	constructor(e, t) {
		if (t && !(t instanceof qo)) throw We("color")
		if (!pe.isRange(e) || e.isEmpty) throw We("range")
		;(this.range = e), (this.color = t)
	}
}
Na = R([me], Na)
var Ua = class {
	constructor(e) {
		if (!e || typeof e != "string") throw We("label")
		this.label = e
	}
}
Ua = R([me], Ua)
var Z_ = ((n) => (
		(n[(n.Error = 0)] = "Error"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Information = 2)] = "Information"), n
	))(Z_ || {}),
	eD = ((i) => (
		(i[(i.Unknown = 0)] = "Unknown"),
		(i[(i.Shutdown = 1)] = "Shutdown"),
		(i[(i.Process = 2)] = "Process"),
		(i[(i.User = 3)] = "User"),
		(i[(i.Extension = 4)] = "Extension"),
		i
	))(eD || {}),
	LI = ((n) => ((n[(n.Low = 0)] = "Low"), (n[(n.Medium = 1)] = "Medium"), (n[(n.High = 2)] = "High"), n))(LI || {}),
	tD = ((f) => (
		(f[(f.Sh = 1)] = "Sh"),
		(f[(f.Bash = 2)] = "Bash"),
		(f[(f.Fish = 3)] = "Fish"),
		(f[(f.Csh = 4)] = "Csh"),
		(f[(f.Ksh = 5)] = "Ksh"),
		(f[(f.Zsh = 6)] = "Zsh"),
		(f[(f.CommandPrompt = 7)] = "CommandPrompt"),
		(f[(f.GitBash = 8)] = "GitBash"),
		(f[(f.PowerShell = 9)] = "PowerShell"),
		(f[(f.Python = 10)] = "Python"),
		(f[(f.Julia = 11)] = "Julia"),
		(f[(f.NuShell = 12)] = "NuShell"),
		(f[(f.Node = 13)] = "Node"),
		f
	))(tD || {}),
	jy = class {
		constructor(e, t, n) {
			this.startIndex = e
			this.length = t
			this.tooltip = n
			if (typeof e != "number" || e < 0) throw We("startIndex")
			if (typeof t != "number" || t < 1) throw We("length")
			if (n !== void 0 && typeof n != "string") throw We("tooltip")
		}
	},
	Gy = class {
		constructor(e) {
			this.uri = e
		}
	},
	Qy = class {
		constructor(e) {
			this.terminalCommand = e
		}
	},
	nD = ((t) => ((t[(t.Panel = 1)] = "Panel"), (t[(t.Editor = 2)] = "Editor"), t))(nD || {}),
	Jy = class {
		constructor(e) {
			this.options = e
			if (typeof e != "object") throw We("options")
		}
	},
	rD = ((l) => (
		(l[(l.File = 0)] = "File"),
		(l[(l.Folder = 1)] = "Folder"),
		(l[(l.Method = 2)] = "Method"),
		(l[(l.Alias = 3)] = "Alias"),
		(l[(l.Argument = 4)] = "Argument"),
		(l[(l.Option = 5)] = "Option"),
		(l[(l.OptionValue = 6)] = "OptionValue"),
		(l[(l.Flag = 7)] = "Flag"),
		l
	))(rD || {}),
	Xy = class {
		constructor(e, t, n, r, i, s, a, l, d) {
			;(this.label = e),
				(this.icon = t),
				(this.detail = n),
				(this.documentation = r),
				(this.isFile = i),
				(this.isDirectory = s),
				(this.isKeyword = a),
				(this.replacementIndex = l ?? 0),
				(this.replacementLength = d ?? 0)
		}
	},
	Yy = class {
		constructor(e, t) {
			;(this.items = e ?? []), (this.resourceRequestConfig = t)
		}
	},
	oD = ((n) => ((n[(n.Always = 1)] = "Always"), (n[(n.Silent = 2)] = "Silent"), (n[(n.Never = 3)] = "Never"), n))(
		oD || {},
	),
	iD = ((f) => (
		(f.Changed = "changed"),
		(f.ProcessStarted = "processStarted"),
		(f.ProcessEnded = "processEnded"),
		(f.Terminated = "terminated"),
		(f.Start = "start"),
		(f.AcquiredInput = "acquiredInput"),
		(f.DependsOnStarted = "dependsOnStarted"),
		(f.Active = "active"),
		(f.Inactive = "inactive"),
		(f.End = "end"),
		(f.ProblemMatcherStarted = "problemMatcherStarted"),
		(f.ProblemMatcherEnded = "problemMatcherEnded"),
		(f.ProblemMatcherFoundErrors = "problemMatcherFoundErrors"),
		f
	))(iD || {}),
	sD = ((n) => ((n[(n.Shared = 1)] = "Shared"), (n[(n.Dedicated = 2)] = "Dedicated"), (n[(n.New = 3)] = "New"), n))(
		sD || {},
	),
	un = class {
		constructor(e, t) {
			this.label = t
			if (typeof e != "string") throw We("name")
			if (typeof t != "string") throw We("name")
			this._id = e
		}
		static from(e) {
			switch (e) {
				case "clean":
					return un.Clean
				case "build":
					return un.Build
				case "rebuild":
					return un.Rebuild
				case "test":
					return un.Test
				default:
					return
			}
		}
		get id() {
			return this._id
		}
	}
;(un.Clean = new un("clean", "Clean")),
	(un.Build = new un("build", "Build")),
	(un.Rebuild = new un("rebuild", "Rebuild")),
	(un.Test = new un("test", "Test")),
	(un = R([me], un))
function AF(o) {
	let e = ""
	for (let t = 0; t < o.length; t++) e += o[t].replace(/,/g, ",,") + ","
	return e
}
var Si = class {
	constructor(e, t, n) {
		if (typeof e != "string") throw We("process")
		;(this._args = []),
			(this._process = e),
			t !== void 0 && (Array.isArray(t) ? ((this._args = t), (this._options = n)) : (this._options = t))
	}
	get process() {
		return this._process
	}
	set process(e) {
		if (typeof e != "string") throw We("process")
		this._process = e
	}
	get args() {
		return this._args
	}
	set args(e) {
		Array.isArray(e) || (e = []), (this._args = e)
	}
	get options() {
		return this._options
	}
	set options(e) {
		this._options = e
	}
	computeId() {
		let e = []
		if ((e.push("process"), this._process !== void 0 && e.push(this._process), this._args && this._args.length > 0))
			for (let t of this._args) e.push(t)
		return AF(e)
	}
}
Si = R([me], Si)
var Ko = class {
	constructor(e, t, n) {
		this._args = []
		if (Array.isArray(t)) {
			if (!e) throw We("command can't be undefined or null")
			if (typeof e != "string" && typeof e.value != "string") throw We("command")
			;(this._command = e), t && (this._args = t), (this._options = n)
		} else {
			if (typeof e != "string") throw We("commandLine")
			;(this._commandLine = e), (this._options = t)
		}
	}
	get commandLine() {
		return this._commandLine
	}
	set commandLine(e) {
		if (typeof e != "string") throw We("commandLine")
		this._commandLine = e
	}
	get command() {
		return this._command ? this._command : ""
	}
	set command(e) {
		if (typeof e != "string" && typeof e.value != "string") throw We("command")
		this._command = e
	}
	get args() {
		return this._args
	}
	set args(e) {
		this._args = e || []
	}
	get options() {
		return this._options
	}
	set options(e) {
		this._options = e
	}
	computeId() {
		let e = []
		if (
			(e.push("shell"),
			this._commandLine !== void 0 && e.push(this._commandLine),
			this._command !== void 0 && e.push(typeof this._command == "string" ? this._command : this._command.value),
			this._args && this._args.length > 0)
		)
			for (let t of this._args) e.push(typeof t == "string" ? t : t.value)
		return AF(e)
	}
}
Ko = R([me], Ko)
var aD = ((n) => ((n[(n.Escape = 1)] = "Escape"), (n[(n.Strong = 2)] = "Strong"), (n[(n.Weak = 3)] = "Weak"), n))(
		aD || {},
	),
	MI = ((t) => ((t[(t.Global = 1)] = "Global"), (t[(t.Workspace = 2)] = "Workspace"), t))(MI || {}),
	yd = class {
		constructor(e) {
			this._callback = e
		}
		computeId() {
			return "customExecution" + He()
		}
		set callback(e) {
			this._callback = e
		}
		get callback() {
			return this._callback
		}
	},
	gn = class {
		constructor(e, t, n, r, i, s) {
			this.__deprecated = !1
			this._definition = this.definition = e
			let a
			typeof t == "string"
				? ((this._name = this.name = t),
					(this._source = this.source = n),
					(this.execution = r),
					(a = i),
					(this.__deprecated = !0))
				: t === 1 || t === 2
					? ((this.target = t),
						(this._name = this.name = n),
						(this._source = this.source = r),
						(this.execution = i),
						(a = s))
					: ((this.target = t),
						(this._name = this.name = n),
						(this._source = this.source = r),
						(this.execution = i),
						(a = s)),
				typeof a == "string"
					? ((this._problemMatchers = [a]), (this._hasDefinedMatchers = !0))
					: Array.isArray(a)
						? ((this._problemMatchers = a), (this._hasDefinedMatchers = !0))
						: ((this._problemMatchers = []), (this._hasDefinedMatchers = !1)),
				(this._isBackground = !1),
				(this._presentationOptions = Object.create(null)),
				(this._runOptions = Object.create(null))
		}
		get _id() {
			return this.__id
		}
		set _id(e) {
			this.__id = e
		}
		get _deprecated() {
			return this.__deprecated
		}
		clear() {
			this.__id !== void 0 &&
				((this.__id = void 0), (this._scope = void 0), this.computeDefinitionBasedOnExecution())
		}
		computeDefinitionBasedOnExecution() {
			this._execution instanceof Si
				? (this._definition = { type: gn.ProcessType, id: this._execution.computeId() })
				: this._execution instanceof Ko
					? (this._definition = { type: gn.ShellType, id: this._execution.computeId() })
					: this._execution instanceof yd
						? (this._definition = { type: gn.ExtensionCallbackType, id: this._execution.computeId() })
						: (this._definition = { type: gn.EmptyType, id: He() })
		}
		get definition() {
			return this._definition
		}
		set definition(e) {
			if (e == null) throw We("Kind can't be undefined or null")
			this.clear(), (this._definition = e)
		}
		get scope() {
			return this._scope
		}
		set target(e) {
			this.clear(), (this._scope = e)
		}
		get name() {
			return this._name
		}
		set name(e) {
			if (typeof e != "string") throw We("name")
			this.clear(), (this._name = e)
		}
		get execution() {
			return this._execution
		}
		set execution(e) {
			e === null && (e = void 0), this.clear(), (this._execution = e)
			let t = this._definition.type
			;(gn.EmptyType === t || gn.ProcessType === t || gn.ShellType === t || gn.ExtensionCallbackType === t) &&
				this.computeDefinitionBasedOnExecution()
		}
		get problemMatchers() {
			return this._problemMatchers
		}
		set problemMatchers(e) {
			if (Array.isArray(e)) this.clear(), (this._problemMatchers = e), (this._hasDefinedMatchers = !0)
			else {
				this.clear(), (this._problemMatchers = []), (this._hasDefinedMatchers = !1)
				return
			}
		}
		get hasDefinedMatchers() {
			return this._hasDefinedMatchers
		}
		get isBackground() {
			return this._isBackground
		}
		set isBackground(e) {
			e !== !0 && e !== !1 && (e = !1), this.clear(), (this._isBackground = e)
		}
		get source() {
			return this._source
		}
		set source(e) {
			if (typeof e != "string" || e.length === 0) throw We("source must be a string of length > 0")
			this.clear(), (this._source = e)
		}
		get group() {
			return this._group
		}
		set group(e) {
			e === null && (e = void 0), this.clear(), (this._group = e)
		}
		get detail() {
			return this._detail
		}
		set detail(e) {
			e === null && (e = void 0), (this._detail = e)
		}
		get presentationOptions() {
			return this._presentationOptions
		}
		set presentationOptions(e) {
			e == null && (e = Object.create(null)), this.clear(), (this._presentationOptions = e)
		}
		get runOptions() {
			return this._runOptions
		}
		set runOptions(e) {
			e == null && (e = Object.create(null)), this.clear(), (this._runOptions = e)
		}
	}
;(gn.ExtensionCallbackType = "customExecution"),
	(gn.ProcessType = "process"),
	(gn.ShellType = "shell"),
	(gn.EmptyType = "$empty"),
	(gn = R([me], gn))
var FI = ((n) => (
		(n[(n.SourceControl = 1)] = "SourceControl"),
		(n[(n.Window = 10)] = "Window"),
		(n[(n.Notification = 15)] = "Notification"),
		n
	))(FI || {}),
	lD
;((e) => {
	function o(t) {
		let n = t
		return fn(n.value)
			? n.tooltip && !we(n.tooltip)
				? (console.log("INVALID view badge, invalid tooltip", n.tooltip), !1)
				: !0
			: (console.log("INVALID view badge, invalid value", n.value), !1)
	}
	e.isViewBadge = o
})((lD ||= {}))
var Ti = class {
	constructor(e, t = 0) {
		this.collapsibleState = t
		b.isUri(e) ? (this.resourceUri = e) : (this.label = e)
	}
	static isTreeItem(e, t) {
		let n = e
		if (n.checkboxState !== void 0) {
			let r = fn(n.checkboxState)
					? n.checkboxState
					: dt(n.checkboxState) && fn(n.checkboxState.state)
						? n.checkboxState.state
						: void 0,
				i = !fn(n.checkboxState) && dt(n.checkboxState) ? n.checkboxState.tooltip : void 0
			if (r === void 0 || (r !== 1 && r !== 0) || (i !== void 0 && !we(i)))
				return console.log("INVALID tree item, invalid checkboxState", n.checkboxState), !1
		}
		if (e instanceof Ti) return !0
		if (n.label !== void 0 && !we(n.label) && !n.label?.label)
			return console.log("INVALID tree item, invalid label", n.label), !1
		if (n.id !== void 0 && !we(n.id)) return console.log("INVALID tree item, invalid id", n.id), !1
		if (n.iconPath !== void 0 && !we(n.iconPath) && !b.isUri(n.iconPath) && (!n.iconPath || !we(n.iconPath.id))) {
			let r = n.iconPath
			if (!r || (!we(r.light) && !b.isUri(r.light) && !we(r.dark) && !b.isUri(r.dark)))
				return console.log("INVALID tree item, invalid iconPath", n.iconPath), !1
		}
		return n.description !== void 0 && !we(n.description) && typeof n.description != "boolean"
			? (console.log("INVALID tree item, invalid description", n.description), !1)
			: n.resourceUri !== void 0 && !b.isUri(n.resourceUri)
				? (console.log("INVALID tree item, invalid resourceUri", n.resourceUri), !1)
				: n.tooltip !== void 0 && !we(n.tooltip) && !(n.tooltip instanceof en)
					? (console.log("INVALID tree item, invalid tooltip", n.tooltip), !1)
					: n.command !== void 0 && !n.command.command
						? (console.log("INVALID tree item, invalid command", n.command), !1)
						: n.collapsibleState !== void 0 && n.collapsibleState < 0 && n.collapsibleState > 2
							? (console.log("INVALID tree item, invalid collapsibleState", n.collapsibleState), !1)
							: n.contextValue !== void 0 && !we(n.contextValue)
								? (console.log("INVALID tree item, invalid contextValue", n.contextValue), !1)
								: n.accessibilityInformation !== void 0 && !n.accessibilityInformation?.label
									? (console.log(
											"INVALID tree item, invalid accessibilityInformation",
											n.accessibilityInformation,
										),
										!1)
									: !0
	}
}
Ti = R([me], Ti)
var NI = ((n) => (
		(n[(n.None = 0)] = "None"), (n[(n.Collapsed = 1)] = "Collapsed"), (n[(n.Expanded = 2)] = "Expanded"), n
	))(NI || {}),
	UI = ((t) => ((t[(t.Unchecked = 0)] = "Unchecked"), (t[(t.Checked = 1)] = "Checked"), t))(UI || {}),
	pd = class {
		constructor(e) {
			this.value = e
		}
		async asString() {
			return typeof this.value == "string" ? this.value : JSON.stringify(this.value)
		}
		asFile() {}
	}
pd = R([me], pd)
var Ka = class extends pd {},
	Zy = class extends Ka {
		#e
		constructor(e) {
			super(""), (this.#e = e)
		}
		asFile() {
			return this.#e
		}
	},
	eI = class {
		constructor(e, t, n, r) {
			;(this.name = e), (this.uri = t), (this._itemId = n), (this._getData = r)
		}
		data() {
			return this._getData()
		}
	},
	bs,
	hd,
	dg,
	bo = class {
		constructor(e) {
			Ym(this, hd)
			Ym(this, bs, new Map())
			for (let [t, n] of e ?? []) {
				let r = sn(this, bs).get(Zm(this, hd, dg).call(this, t))
				r ? r.push(n) : sn(this, bs).set(Zm(this, hd, dg).call(this, t), [n])
			}
		}
		get(e) {
			return sn(this, bs).get(Zm(this, hd, dg).call(this, e))?.[0]
		}
		set(e, t) {
			sn(this, bs).set(Zm(this, hd, dg).call(this, e), [t])
		}
		forEach(e, t) {
			for (let [n, r] of sn(this, bs)) for (let i of r) e.call(t, i, n, this)
		}
		*[Symbol.iterator]() {
			for (let [e, t] of sn(this, bs)) for (let n of t) yield [e, n]
		}
	}
;(bs = new WeakMap()),
	(hd = new WeakSet()),
	(dg = function (e) {
		return e.toLowerCase()
	}),
	(bo = R([me], bo))
var bu = class {
	constructor(e, t, n) {
		;(this.insertText = e), (this.title = t), (this.kind = n)
	}
}
bu = R([me], bu)
var dD = ((t) => ((t[(t.Automatic = 0)] = "Automatic"), (t[(t.PasteAs = 1)] = "PasteAs"), t))(dD || {}),
	yo = class o {
		constructor(e) {
			this.value = e
		}
		static {
			this.sep = "."
		}
		append(...e) {
			return new o((this.value ? [this.value, ...e] : e).join(o.sep))
		}
		intersects(e) {
			return this.contains(e) || e.contains(this)
		}
		contains(e) {
			return this.value === e.value || e.value.startsWith(this.value + o.sep)
		}
	}
yo.Empty = new yo("")
yo.Text = new yo("text")
yo.TextUpdateImports = yo.Text.append("updateImports")
var tI = class {
		constructor(e, t, n) {
			;(this.title = t), (this.insertText = e), (this.kind = n)
		}
	},
	Vt = class {
		constructor(e, t) {
			;(this.id = e), (this.color = t)
		}
		static isThemeIcon(e) {
			return typeof e.id != "string" ? (console.log("INVALID ThemeIcon, invalid id", e.id), !1) : !0
		}
	}
Vt = R([me], Vt)
Vt.File = new Vt("file")
Vt.Folder = new Vt("folder")
var Is = class {
	constructor(e) {
		this.id = e
	}
}
Is = R([me], Is)
var HI = ((n) => (
		(n[(n.Global = 1)] = "Global"),
		(n[(n.Workspace = 2)] = "Workspace"),
		(n[(n.WorkspaceFolder = 3)] = "WorkspaceFolder"),
		n
	))(HI || {}),
	Ei = class {
		get base() {
			return this._base
		}
		set base(e) {
			;(this._base = e), (this._baseUri = b.file(e))
		}
		get baseUri() {
			return this._baseUri
		}
		set baseUri(e) {
			;(this._baseUri = e), (this._base = e.fsPath)
		}
		constructor(e, t) {
			if (typeof e != "string" && (!e || (!b.isUri(e) && !b.isUri(e.uri)))) throw We("base")
			if (typeof t != "string") throw We("pattern")
			typeof e == "string"
				? (this.baseUri = b.file(e))
				: b.isUri(e)
					? (this.baseUri = e)
					: (this.baseUri = e.uri),
				(this.pattern = t)
		}
		toJSON() {
			return { pattern: this.pattern, base: this.base, baseUri: this.baseUri.toJSON() }
		}
	}
Ei = R([me], Ei)
var OF = new WeakMap()
function LF(o, e) {
	OF.set(o, e)
}
var xs = class {
	constructor(e, t, n, r, i) {
		;(this.enabled = typeof e == "boolean" ? e : !0),
			typeof t == "string" && (this.condition = t),
			typeof n == "string" && (this.hitCondition = n),
			typeof r == "string" && (this.logMessage = r),
			typeof i == "string" && (this.mode = i)
	}
	get id() {
		return this._id || (this._id = OF.get(this) ?? He()), this._id
	}
}
xs = R([me], xs)
var jo = class extends xs {
	constructor(e, t, n, r, i, s) {
		if ((super(t, n, r, i, s), e === null)) throw We("location")
		this.location = e
	}
}
jo = R([me], jo)
var Go = class extends xs {
	constructor(e, t, n, r, i, s) {
		super(t, n, r, i, s), (this.functionName = e)
	}
}
Go = R([me], Go)
var md = class extends xs {
	constructor(e, t, n, r, i, s, a, l) {
		if ((super(r, i, s, a, l), !t)) throw We("dataId")
		;(this.label = e), (this.dataId = t), (this.canPersist = n)
	}
}
md = R([me], md)
var Qo = class {
	constructor(e, t, n) {
		;(this.command = e), (this.args = t || []), (this.options = n)
	}
}
Qo = R([me], Qo)
var Jo = class {
	constructor(e, t) {
		;(this.port = e), (this.host = t)
	}
}
Jo = R([me], Jo)
var wi = class {
	constructor(e) {
		this.path = e
	}
}
wi = R([me], wi)
var Cs = class {
	constructor(e) {
		this.implementation = e
	}
}
Cs = R([me], Cs)
var Tu = class {
		constructor(e, t, n) {
			this.session = e
			this.threadId = t
			this.frameId = n
		}
	},
	Eu = class {
		constructor(e, t) {
			this.session = e
			this.threadId = t
		}
	},
	Ha = class {
		constructor(e, t) {
			;(this.range = e), (this.expression = t)
		}
	}
Ha = R([me], Ha)
var WI = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(WI || {}),
	Wa = class {
		constructor(e, t) {
			;(this.range = e), (this.text = t)
		}
	}
Wa = R([me], Wa)
var Va = class {
	constructor(e, t, n = !0) {
		;(this.range = e), (this.variableName = t), (this.caseSensitiveLookup = n)
	}
}
Va = R([me], Va)
var Ba = class {
	constructor(e, t) {
		;(this.range = e), (this.expression = t)
	}
}
Ba = R([me], Ba)
var yu = class {
	constructor(e, t) {
		;(this.frameId = e), (this.stoppedLocation = t)
	}
}
yu = R([me], yu)
var cD = ((e) => ((e[(e.AIGenerated = 1)] = "AIGenerated"), e))(cD || {}),
	VI = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(VI || {}),
	nI = class {
		constructor(e, t) {
			;(this.newSymbolName = e), (this.tags = t)
		}
	},
	BI = ((n) => (
		(n[(n.Changed = 1)] = "Changed"), (n[(n.Created = 2)] = "Created"), (n[(n.Deleted = 3)] = "Deleted"), n
	))(BI || {}),
	rt = class extends Error {
		static FileExists(e) {
			return new rt(e, "EntryExists", rt.FileExists)
		}
		static FileNotFound(e) {
			return new rt(e, "EntryNotFound", rt.FileNotFound)
		}
		static FileNotADirectory(e) {
			return new rt(e, "EntryNotADirectory", rt.FileNotADirectory)
		}
		static FileIsADirectory(e) {
			return new rt(e, "EntryIsADirectory", rt.FileIsADirectory)
		}
		static NoPermissions(e) {
			return new rt(e, "NoPermissions", rt.NoPermissions)
		}
		static Unavailable(e) {
			return new rt(e, "Unavailable", rt.Unavailable)
		}
		constructor(e, t = "Unknown", n) {
			super(b.isUri(e) ? e.toString(!0) : e),
				(this.code = n?.name ?? "Unknown"),
				vP(this, t),
				Object.setPrototypeOf(this, rt.prototype),
				typeof Error.captureStackTrace == "function" &&
					typeof n == "function" &&
					Error.captureStackTrace(this, n)
		}
	}
rt = R([me], rt)
var Iu = class {
	constructor(e, t, n) {
		;(this.start = e), (this.end = t), (this.kind = n)
	}
}
Iu = R([me], Iu)
var $I = ((n) => (
		(n[(n.Comment = 1)] = "Comment"), (n[(n.Imports = 2)] = "Imports"), (n[(n.Region = 3)] = "Region"), n
	))($I || {}),
	zI = ((t) => ((t[(t.Collapsed = 0)] = "Collapsed"), (t[(t.Expanded = 1)] = "Expanded"), t))(zI || {}),
	uD = ((t) => ((t[(t.Editing = 0)] = "Editing"), (t[(t.Preview = 1)] = "Preview"), t))(uD || {}),
	pD = ((t) => ((t[(t.Published = 0)] = "Published"), (t[(t.Draft = 1)] = "Draft"), t))(pD || {}),
	qI = ((t) => ((t[(t.Unresolved = 0)] = "Unresolved"), (t[(t.Resolved = 1)] = "Resolved"), t))(qI || {}),
	KI = ((t) => ((t[(t.Current = 0)] = "Current"), (t[(t.Outdated = 1)] = "Outdated"), t))(KI || {}),
	jI = ((t) => ((t[(t.Reply = 1)] = "Reply"), (t[(t.Comment = 2)] = "Comment"), t))(jI || {}),
	Id = class {
		constructor(e, t = []) {
			;(this.tokenTypes = e), (this.tokenModifiers = t)
		}
	}
function M7(o) {
	return typeof o > "u" || aA(o)
}
var rI = class o {
		constructor(e) {
			if (
				((this._prevLine = 0),
				(this._prevChar = 0),
				(this._dataIsSortedAndDeltaEncoded = !0),
				(this._data = []),
				(this._dataLen = 0),
				(this._tokenTypeStrToInt = new Map()),
				(this._tokenModifierStrToInt = new Map()),
				(this._hasLegend = !1),
				e)
			) {
				this._hasLegend = !0
				for (let t = 0, n = e.tokenTypes.length; t < n; t++) this._tokenTypeStrToInt.set(e.tokenTypes[t], t)
				for (let t = 0, n = e.tokenModifiers.length; t < n; t++)
					this._tokenModifierStrToInt.set(e.tokenModifiers[t], t)
			}
		}
		push(e, t, n, r, i) {
			if (
				typeof e == "number" &&
				typeof t == "number" &&
				typeof n == "number" &&
				typeof r == "number" &&
				(typeof i == "number" || typeof i > "u")
			)
				return typeof i > "u" && (i = 0), this._pushEncoded(e, t, n, r, i)
			if (pe.isRange(e) && typeof t == "string" && M7(n)) return this._push(e, t, n)
			throw We()
		}
		_push(e, t, n) {
			if (!this._hasLegend) throw new Error("Legend must be provided in constructor")
			if (e.start.line !== e.end.line) throw new Error("`range` cannot span multiple lines")
			if (!this._tokenTypeStrToInt.has(t)) throw new Error("`tokenType` is not in the provided legend")
			let r = e.start.line,
				i = e.start.character,
				s = e.end.character - e.start.character,
				a = this._tokenTypeStrToInt.get(t),
				l = 0
			if (n)
				for (let d of n) {
					if (!this._tokenModifierStrToInt.has(d))
						throw new Error("`tokenModifier` is not in the provided legend")
					let c = this._tokenModifierStrToInt.get(d)
					l |= (1 << c) >>> 0
				}
			this._pushEncoded(r, i, s, a, l)
		}
		_pushEncoded(e, t, n, r, i) {
			if (
				this._dataIsSortedAndDeltaEncoded &&
				(e < this._prevLine || (e === this._prevLine && t < this._prevChar))
			) {
				this._dataIsSortedAndDeltaEncoded = !1
				let l = (this._data.length / 5) | 0,
					d = 0,
					c = 0
				for (let u = 0; u < l; u++) {
					let m = this._data[5 * u],
						f = this._data[5 * u + 1]
					m === 0 ? ((m = d), (f += c)) : (m += d),
						(this._data[5 * u] = m),
						(this._data[5 * u + 1] = f),
						(d = m),
						(c = f)
				}
			}
			let s = e,
				a = t
			this._dataIsSortedAndDeltaEncoded &&
				this._dataLen > 0 &&
				((s -= this._prevLine), s === 0 && (a -= this._prevChar)),
				(this._data[this._dataLen++] = s),
				(this._data[this._dataLen++] = a),
				(this._data[this._dataLen++] = n),
				(this._data[this._dataLen++] = r),
				(this._data[this._dataLen++] = i),
				(this._prevLine = e),
				(this._prevChar = t)
		}
		static _sortAndDeltaEncode(e) {
			let t = [],
				n = (e.length / 5) | 0
			for (let a = 0; a < n; a++) t[a] = a
			t.sort((a, l) => {
				let d = e[5 * a],
					c = e[5 * l]
				if (d === c) {
					let u = e[5 * a + 1],
						m = e[5 * l + 1]
					return u - m
				}
				return d - c
			})
			let r = new Uint32Array(e.length),
				i = 0,
				s = 0
			for (let a = 0; a < n; a++) {
				let l = 5 * t[a],
					d = e[l + 0],
					c = e[l + 1],
					u = e[l + 2],
					m = e[l + 3],
					f = e[l + 4],
					h = d - i,
					g = h === 0 ? c - s : c,
					I = 5 * a
				;(r[I + 0] = h), (r[I + 1] = g), (r[I + 2] = u), (r[I + 3] = m), (r[I + 4] = f), (i = d), (s = c)
			}
			return r
		}
		build(e) {
			return this._dataIsSortedAndDeltaEncoded
				? new Xo(new Uint32Array(this._data), e)
				: new Xo(o._sortAndDeltaEncode(this._data), e)
		}
	},
	Xo = class {
		constructor(e, t) {
			;(this.resultId = t), (this.data = e)
		}
	},
	wu = class {
		constructor(e, t, n) {
			;(this.start = e), (this.deleteCount = t), (this.data = n)
		}
	},
	ja = class {
		constructor(e, t) {
			;(this.resultId = t), (this.edits = e)
		}
	},
	GI = ((t) => ((t[(t.Separate = 0)] = "Separate"), (t[(t.MergeWithParent = 1)] = "MergeWithParent"), t))(GI || {}),
	oI = class {
		constructor(e) {
			this.name = e
		}
	},
	mD = ((t) => ((t[(t.Title = 1)] = "Title"), (t[(t.Inline = 2)] = "Inline"), t))(mD || {}),
	Ii = class {
		constructor() {}
	}
;(Ii.Back = { iconPath: new Vt("arrow-left") }), (Ii = R([me], Ii))
var QI = ((t) => ((t[(t.Separator = -1)] = "Separator"), (t[(t.Default = 0)] = "Default"), t))(QI || {}),
	JI = ((n) => ((n[(n.Info = 1)] = "Info"), (n[(n.Warning = 2)] = "Warning"), (n[(n.Error = 3)] = "Error"), n))(
		JI || {},
	),
	XI = ((t) => ((t[(t.UI = 1)] = "UI"), (t[(t.Workspace = 2)] = "Workspace"), t))(XI || {}),
	xd = class {
		static validate(e) {
			if (typeof e.badge == "string") {
				let t = AE(e.badge, 0)
				if ((t < e.badge.length && (t += AE(e.badge, t)), e.badge.length > t))
					throw new Error("The 'badge'-property must be undefined or a short character")
			} else if (e.badge && !Vt.isThemeIcon(e.badge))
				throw new Error("The 'badge'-property is not a valid ThemeIcon")
			if (!e.color && !e.badge && !e.tooltip) throw new Error("The decoration is empty")
			return !0
		}
		constructor(e, t, n) {
			;(this.badge = e), (this.tooltip = t), (this.color = n)
		}
	},
	fd = class {
		constructor(e) {
			this.kind = e
		}
	}
fd = R([me], fd)
var YI = ((r) => (
		(r[(r.Light = 1)] = "Light"),
		(r[(r.Dark = 2)] = "Dark"),
		(r[(r.HighContrast = 3)] = "HighContrast"),
		(r[(r.HighContrastLight = 4)] = "HighContrastLight"),
		r
	))(YI || {}),
	cr = class o {
		static isNotebookRange(e) {
			return e instanceof o ? !0 : e ? typeof e.start == "number" && typeof e.end == "number" : !1
		}
		get start() {
			return this._start
		}
		get end() {
			return this._end
		}
		get isEmpty() {
			return this._start === this._end
		}
		constructor(e, t) {
			if (e < 0) throw We("start must be positive")
			if (t < 0) throw We("end must be positive")
			e <= t ? ((this._start = e), (this._end = t)) : ((this._start = t), (this._end = e))
		}
		with(e) {
			let t = this._start,
				n = this._end
			return (
				e.start !== void 0 && (t = e.start),
				e.end !== void 0 && (n = e.end),
				t === this._start && n === this._end ? this : new o(t, n)
			)
		}
	},
	Ts = class o {
		static validate(e) {
			if (typeof e.kind != "number") throw new Error("NotebookCellData MUST have 'kind' property")
			if (typeof e.value != "string") throw new Error("NotebookCellData MUST have 'value' property")
			if (typeof e.languageId != "string") throw new Error("NotebookCellData MUST have 'languageId' property")
		}
		static isNotebookCellDataArray(e) {
			return Array.isArray(e) && e.every((t) => o.isNotebookCellData(t))
		}
		static isNotebookCellData(e) {
			return !0
		}
		constructor(e, t, n, r, i, s, a) {
			;(this.kind = e),
				(this.value = t),
				(this.languageId = n),
				(this.mime = r),
				(this.outputs = i ?? []),
				(this.metadata = s),
				(this.executionSummary = a),
				o.validate(this)
		}
	},
	Pu = class {
		constructor(e) {
			this.cells = e
		}
	},
	_u = class o {
		constructor(e, t) {
			this.data = e
			this.mime = t
			let n = LP(t, !0)
			if (!n) throw new Error(`INVALID mime type: ${t}. Must be in the format "type/subtype[;optionalparameter]"`)
			this.mime = n
		}
		static isNotebookCellOutputItem(e) {
			return e instanceof o ? !0 : e ? typeof e.mime == "string" && e.data instanceof Uint8Array : !1
		}
		static error(e) {
			let t = { name: e.name, message: e.message, stack: e.stack }
			return o.json(t, "application/vnd.code.notebook.error")
		}
		static stdout(e) {
			return o.text(e, "application/vnd.code.notebook.stdout")
		}
		static stderr(e) {
			return o.text(e, "application/vnd.code.notebook.stderr")
		}
		static bytes(e, t = "application/octet-stream") {
			return new o(e, t)
		}
		static #e = new TextEncoder()
		static text(e, t = mo.text) {
			let n = o.#e.encode(String(e))
			return new o(n, t)
		}
		static json(e, t = "text/x-json") {
			let n = JSON.stringify(e, void 0, "	")
			return o.text(n, t)
		}
	},
	Es = class o {
		static isNotebookCellOutput(e) {
			return e instanceof o
				? !0
				: !e || typeof e != "object"
					? !1
					: typeof e.id == "string" && Array.isArray(e.items)
		}
		static ensureUniqueMimeTypes(e, t = !1) {
			let n = new Set(),
				r = new Set()
			for (let i = 0; i < e.length; i++) {
				let s = e[i],
					a = LP(s.mime)
				if (!n.has(a) || iy(a)) {
					n.add(a)
					continue
				}
				r.add(i), t && console.warn(`DUPLICATED mime type '${s.mime}' will be dropped`)
			}
			return r.size === 0 ? e : e.filter((i, s) => !r.has(s))
		}
		constructor(e, t, n) {
			;(this.items = o.ensureUniqueMimeTypes(e, !0)),
				typeof t == "string"
					? ((this.id = t), (this.metadata = n))
					: ((this.id = He()), (this.metadata = t ?? n))
		}
	},
	iI = class {
		constructor(e, t, n) {
			this.label = e
			this.uri = t
			this.position = n
		}
	},
	ZI = ((t) => ((t[(t.Markup = 1)] = "Markup"), (t[(t.Code = 2)] = "Code"), t))(ZI || {}),
	mg = ((n) => (
		(n[(n.Idle = 1)] = "Idle"), (n[(n.Pending = 2)] = "Pending"), (n[(n.Executing = 3)] = "Executing"), n
	))(mg || {}),
	ex = ((t) => ((t[(t.Left = 1)] = "Left"), (t[(t.Right = 2)] = "Right"), t))(ex || {}),
	tx = ((r) => (
		(r[(r.Default = 0)] = "Default"),
		(r[(r.InCenter = 1)] = "InCenter"),
		(r[(r.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
		(r[(r.AtTop = 3)] = "AtTop"),
		r
	))(tx || {}),
	sI = class {
		constructor(e, t) {
			this.text = e
			this.alignment = t
		}
	},
	fD = ((t) => ((t[(t.Default = 1)] = "Default"), (t[(t.Preferred = 2)] = "Preferred"), t))(fD || {}),
	nx = ((n) => (
		(n[(n.Default = 1)] = "Default"), (n[(n.Preferred = 2)] = "Preferred"), (n[(n.Hidden = -1)] = "Hidden"), n
	))(nx || {}),
	Du = class {
		constructor(e, t = []) {
			this.uri = e
			this.provides = an(t)
		}
	},
	aI = class {
		constructor(e) {
			this.label = e
		}
	},
	rx = ((t) => ((t[(t.Named = 1)] = "Named"), (t[(t.Indexed = 2)] = "Indexed"), t))(rx || {}),
	xu = class {
		constructor(e, t) {
			this.label = e
			this.timestamp = t
		}
	}
xu = R([me], xu)
var ox = ((n) => (
		(n[(n.Production = 1)] = "Production"), (n[(n.Development = 2)] = "Development"), (n[(n.Test = 3)] = "Test"), n
	))(ox || {}),
	ix = ((t) => ((t[(t.Node = 1)] = "Node"), (t[(t.Webworker = 2)] = "Webworker"), t))(ix || {}),
	fg = ((r) => (
		(r[(r.Other = 0)] = "Other"),
		(r[(r.Comment = 1)] = "Comment"),
		(r[(r.String = 2)] = "String"),
		(r[(r.RegEx = 3)] = "RegEx"),
		r
	))(fg || {}),
	lI = class {
		constructor(e, t) {
			this.ranges = e
			this.wordPattern = t
		}
	},
	dI = class {
		constructor(e) {
			this._autoForwardAction = e
		}
		get autoForwardAction() {
			return this._autoForwardAction
		}
	},
	gD = ((s) => (
		(s[(s.Queued = 1)] = "Queued"),
		(s[(s.Running = 2)] = "Running"),
		(s[(s.Passed = 3)] = "Passed"),
		(s[(s.Failed = 4)] = "Failed"),
		(s[(s.Skipped = 5)] = "Skipped"),
		(s[(s.Errored = 6)] = "Errored"),
		s
	))(gD || {}),
	sx = ((n) => ((n[(n.Run = 1)] = "Run"), (n[(n.Debug = 2)] = "Debug"), (n[(n.Coverage = 3)] = "Coverage"), n))(
		sx || {},
	),
	ku = class {
		constructor(e, t, n) {
			this.controllerId = e
			this.profileId = t
			this.kind = n
		}
	},
	$a = class {
		constructor(e = void 0, t = void 0, n = void 0, r = !1, i = !0) {
			this.include = e
			this.exclude = t
			this.profile = n
			this.continuous = r
			this.preserveFocus = i
		}
	}
$a = R([me], $a)
var Pi = class {
	constructor(e) {
		this.message = e
	}
	static diff(e, t, n) {
		let r = new Pi(e)
		return (r.expectedOutput = t), (r.actualOutput = n), r
	}
}
Pi = R([me], Pi)
var Ss = class {
	constructor(e) {
		this.id = e
	}
}
Ss = R([me], Ss)
var cI = class {
		constructor(e, t, n) {
			this.label = e
			this.uri = t
			this.position = n
		}
	},
	vd = class {
		constructor(e, t) {
			this.covered = e
			this.total = t
			gg(this)
		}
	}
function gg(o) {
	if (o) {
		if (o.covered > o.total)
			throw new Error(
				`The total number of covered items (${o.covered}) cannot be greater than the total (${o.total})`,
			)
		if (o.total < 0) throw new Error(`The number of covered items (${o.total}) cannot be negative`)
	}
}
var ws = class o {
		constructor(e, t, n, r, i = []) {
			this.uri = e
			this.statementCoverage = t
			this.branchCoverage = n
			this.declarationCoverage = r
			this.includesTests = i
		}
		static fromDetails(e, t) {
			let n = new vd(0, 0),
				r = new vd(0, 0),
				i = new vd(0, 0)
			for (let a of t)
				if ("branches" in a) {
					;(n.total += 1), (n.covered += a.executed ? 1 : 0)
					for (let l of a.branches) (r.total += 1), (r.covered += l.executed ? 1 : 0)
				} else (i.total += 1), (i.covered += a.executed ? 1 : 0)
			let s = new o(e, n, r.total > 0 ? r : void 0, i.total > 0 ? i : void 0)
			return (s.detailedCoverage = t), s
		}
	},
	Ru = class {
		constructor(e, t, n = []) {
			this.executed = e
			this.location = t
			this.branches = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	Au = class {
		constructor(e, t, n) {
			this.executed = e
			this.location = t
			this.label = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	Ou = class {
		constructor(e, t, n) {
			this.name = e
			this.executed = t
			this.location = n
		}
		get executionCount() {
			return +this.executed
		}
		set executionCount(e) {
			this.executed = e
		}
	},
	hD = ((r) => (
		(r[(r.None = 0)] = "None"),
		(r[(r.Option = 1)] = "Option"),
		(r[(r.Default = 2)] = "Default"),
		(r[(r.Preferred = 3)] = "Preferred"),
		r
	))(hD || {}),
	vD = ((n) => (
		(n[(n.Untrusted = 0)] = "Untrusted"),
		(n[(n.Trusted = 1)] = "Trusted"),
		(n[(n.Unspecified = 2)] = "Unspecified"),
		n
	))(vD || {}),
	bD = ((s) => (
		(s[(s.Notify = 1)] = "Notify"),
		(s[(s.OpenBrowser = 2)] = "OpenBrowser"),
		(s[(s.OpenPreview = 3)] = "OpenPreview"),
		(s[(s.Silent = 4)] = "Silent"),
		(s[(s.Ignore = 5)] = "Ignore"),
		(s[(s.OpenBrowserOnce = 6)] = "OpenBrowserOnce"),
		s
	))(bD || {}),
	Ga = class {
		constructor(e, t, n, r, i, s) {
			;(this.kind = e),
				(this.name = t),
				(this.detail = n),
				(this.uri = r),
				(this.range = i),
				(this.selectionRange = s)
		}
	},
	Qa = class {
		constructor(e) {
			this.uri = e
		}
	},
	Ps = class {
		constructor(e, t) {
			this.original = e
			this.modified = t
		}
	},
	Lu = class {
		constructor(e, t, n, r) {
			this.base = e
			this.input1 = t
			this.input2 = n
			this.result = r
		}
	},
	Ja = class {
		constructor(e, t) {
			this.uri = e
			this.viewType = t
		}
	},
	Mu = class {
		constructor(e) {
			this.viewType = e
		}
	},
	Xa = class {
		constructor(e, t) {
			this.uri = e
			this.notebookType = t
		}
	},
	Ya = class {
		constructor(e, t, n) {
			this.original = e
			this.modified = t
			this.notebookType = n
		}
	},
	Fu = class {
		constructor() {}
	},
	Nu = class {
		constructor(e, t) {
			this.uri = e
			this.inputBoxUri = t
		}
	},
	Uu = class {
		constructor() {}
	},
	Hu = class {
		constructor(e) {
			this.textDiffs = e
		}
	},
	yD = ((t) => ((t[(t.Down = 0)] = "Down"), (t[(t.Up = 1)] = "Up"), t))(yD || {}),
	ID = ((t) => ((t[(t.Action = 1)] = "Action"), (t[(t.Toolbar = 2)] = "Toolbar"), t))(ID || {}),
	xD = ((n) => ((n[(n.Short = 1)] = "Short"), (n[(n.Medium = 2)] = "Medium"), (n[(n.Full = 3)] = "Full"), n))(
		xD || {},
	),
	uI = class {
		constructor(e, t, n) {
			;(this.id = e), (this.label = t), (this.values = n)
		}
	},
	ax = ((n) => (
		(n[(n.Accepted = 1)] = "Accepted"), (n[(n.Rejected = 2)] = "Rejected"), (n[(n.Saved = 3)] = "Saved"), n
	))(ax || {}),
	CD = ((i) => (
		(i[(i.Unhelpful = 0)] = "Unhelpful"),
		(i[(i.Helpful = 1)] = "Helpful"),
		(i[(i.Undone = 2)] = "Undone"),
		(i[(i.Accepted = 3)] = "Accepted"),
		(i[(i.Bug = 4)] = "Bug"),
		i
	))(CD || {}),
	lx = ((t) => ((t[(t.Unhelpful = 0)] = "Unhelpful"), (t[(t.Helpful = 1)] = "Helpful"), t))(lx || {}),
	_s = class {
		constructor(e) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			this.value = typeof e == "string" ? new en(e) : e
		}
	},
	Di = class {
		constructor(e, t) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			;(this.value = typeof e == "string" ? new en(e) : e), (this.vulnerabilities = t)
		}
	},
	Ds = class {
		constructor(e, t, n, r) {
			;(this.title = e), (this.message = t), (this.data = n), (this.buttons = r)
		}
	},
	ks = class {
		constructor(e, t) {
			;(this.value = e), (this.baseUri = t)
		}
	},
	ki = class {
		constructor(e, t) {
			;(this.value = e), (this.value2 = e), (this.title = t)
		}
	},
	Cd = class {
		constructor(e) {
			this.value = e
		}
	},
	Za = class {
		constructor(e, t) {
			;(this.value = e), (this.task = t)
		}
	},
	Ri = class {
		constructor(e) {
			if (typeof e != "string" && e.isTrusted === !0)
				throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.")
			this.value = typeof e == "string" ? new en(e) : e
		}
	},
	Rs = class {
		constructor(e) {
			this.value = e
		}
	},
	Io = class {
		constructor(e, t, n) {
			;(this.value = e), (this.iconPath = t), (this.options = n)
		}
	},
	As = class {
		constructor(e, t) {
			;(this.value = e), (this.isEdit = t)
		}
	},
	Os = class {
		constructor(e, t, n) {
			;(this.value = e), (this.license = t), (this.snippet = n)
		}
	},
	Ls = class {
		constructor(e, t) {
			this.uri = e
			this.range = t
		}
	},
	Ai = class {
		constructor(e, t) {
			;(this.uri = e),
				t === !0 ? ((this.isDone = !0), (this.edits = [])) : (this.edits = Array.isArray(t) ? t : [t])
		}
	},
	Ms = class {
		constructor(e, t) {
			;(this.uri = e),
				t === !0 ? ((this.isDone = !0), (this.edits = [])) : (this.edits = Array.isArray(t) ? t : [t])
		}
	},
	Wu = class {
		constructor(e, t, n, r, i) {
			this.prompt = e
			this.command = t
			this.references = n
			this.participant = r
			this.toolReferences = i
		}
	},
	Vu = class {
		constructor(e, t, n, r) {
			this.response = e
			this.result = t
			this.participant = n
			this.command = r
		}
	},
	dx = ((r) => (
		(r[(r.Panel = 1)] = "Panel"),
		(r[(r.Terminal = 2)] = "Terminal"),
		(r[(r.Notebook = 3)] = "Notebook"),
		(r[(r.Editor = 4)] = "Editor"),
		r
	))(dx || {}),
	SD = ((n) => (
		(n[(n.Complete = 1)] = "Complete"), (n[(n.Partial = 2)] = "Partial"), (n[(n.Omitted = 3)] = "Omitted"), n
	))(SD || {}),
	Bu = class {
		constructor(e, t, n) {
			this.document = e
			this.selection = t
			this.wholeRange = n
		}
	},
	$u = class {
		constructor(e) {
			this.cell = e
		}
	},
	zu = class {
		constructor(e, t, n) {
			;(this.mimeType = e), (this.data = t), (this.reference = n)
		}
	},
	qu = class {
		constructor(e) {
			this.diagnostics = e
		}
	},
	hg = ((n) => ((n[(n.User = 1)] = "User"), (n[(n.Assistant = 2)] = "Assistant"), (n[(n.System = 3)] = "System"), n))(
		hg || {},
	),
	Fs = class {
		constructor(e, t, n) {
			;(this.callId = e), (this.content = t), (this.isError = n ?? !1)
		}
	},
	pI = class {
		constructor(e, t, n) {
			this.command = e
			this.language = t
			this.confirmationMessages = n
		}
	},
	TD = ((n) => ((n[(n.Info = 0)] = "Info"), (n[(n.Warning = 1)] = "Warning"), (n[(n.Error = 2)] = "Error"), n))(
		TD || {},
	),
	Ku = class o {
		constructor(e, t, n) {
			this._content = []
			;(this.role = e), (this.content = t), (this.name = n)
		}
		static User(e, t) {
			return new o(1, e, t)
		}
		static Assistant(e, t) {
			return new o(2, e, t)
		}
		set content(e) {
			typeof e == "string" ? (this._content = [new Pt(e)]) : (this._content = e)
		}
		get content() {
			return this._content
		}
		set content2(e) {
			e && (this.content = e.map((t) => (typeof t == "string" ? new Pt(t) : t)))
		}
		get content2() {
			return this.content.map((e) => (e instanceof Pt ? e.value : e))
		}
	},
	ju = class o {
		constructor(e, t, n) {
			this._content = []
			;(this.role = e), (this.content = t), (this.name = n)
		}
		static User(e, t) {
			return new o(1, e, t)
		}
		static Assistant(e, t) {
			return new o(2, e, t)
		}
		set content(e) {
			typeof e == "string" ? (this._content = [new Pt(e)]) : (this._content = e)
		}
		get content() {
			return this._content
		}
		set content2(e) {
			e && (this.content = e.map((t) => (typeof t == "string" ? new Pt(t) : t)))
		}
		get content2() {
			return this.content.map((e) => (e instanceof Pt ? e.value : e))
		}
	},
	xo = class {
		constructor(e, t, n) {
			;(this.callId = e), (this.name = t), (this.input = n)
		}
	},
	Pt = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 21, value: this.value }
		}
	},
	Sd = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 23, value: this.value }
		}
	},
	ED = ((i) => (
		(i.PNG = "image/png"),
		(i.JPEG = "image/jpeg"),
		(i.GIF = "image/gif"),
		(i.WEBP = "image/webp"),
		(i.BMP = "image/bmp"),
		i
	))(ED || {}),
	Co = class {
		constructor(e) {
			this.value = e
		}
		toJSON() {
			return { $mid: 22, value: this.value }
		}
	}
var Hr = class o extends Error {
		static #e = "LanguageModelError"
		static NotFound(e) {
			return new o(e, o.NotFound.name)
		}
		static NoPermissions(e) {
			return new o(e, o.NoPermissions.name)
		}
		static Blocked(e) {
			return new o(e, o.Blocked.name)
		}
		static tryDeserialize(e) {
			if (e.name === o.#e) return new o(e.message, e.code, e.cause)
		}
		constructor(e, t, n) {
			super(e, { cause: n }), (this.name = o.#e), (this.code = t ?? "")
		}
	},
	el = class {
		constructor(e) {
			this.content = e
		}
		toJSON() {
			return { $mid: 20, content: this.content }
		}
	},
	mI = class extends el {},
	wD = ((t) => ((t[(t.Auto = 1)] = "Auto"), (t[(t.Required = 2)] = "Required"), t))(wD || {}),
	PD = ((r) => (
		(r[(r.SymbolInformation = 1)] = "SymbolInformation"),
		(r[(r.CommandInformation = 2)] = "CommandInformation"),
		(r[(r.SearchInformation = 3)] = "SearchInformation"),
		(r[(r.SettingInformation = 4)] = "SettingInformation"),
		r
	))(PD || {}),
	_D = ((i) => (
		(i[(i.Started = 1)] = "Started"),
		(i[(i.Recognizing = 2)] = "Recognizing"),
		(i[(i.Recognized = 3)] = "Recognized"),
		(i[(i.Stopped = 4)] = "Stopped"),
		(i[(i.Error = 5)] = "Error"),
		i
	))(_D || {}),
	DD = ((n) => ((n[(n.Started = 1)] = "Started"), (n[(n.Stopped = 2)] = "Stopped"), (n[(n.Error = 3)] = "Error"), n))(
		DD || {},
	),
	kD = ((t) => ((t[(t.Recognized = 1)] = "Recognized"), (t[(t.Stopped = 2)] = "Stopped"), t))(kD || {}),
	fI = class {
		constructor(e, t) {
			this.text = e
			this.range = t
		}
	},
	cx = ((t) => ((t[(t.Invoke = 0)] = "Invoke"), (t[(t.Automatic = 1)] = "Automatic"), t))(cx || {}),
	gI = class {
		constructor(e, t, n, r) {
			this.label = e
			this.command = t
			this.args = n
			this.env = r
		}
	},
	hI = class {
		constructor(e, t) {
			this.label = e
			this.uri = t
			this.headers = []
		}
	}
var er
;((t) => {
	function o(n) {
		let { selectionStartLineNumber: r, selectionStartColumn: i, positionLineNumber: s, positionColumn: a } = n,
			l = new Pe(r - 1, i - 1),
			d = new Pe(s - 1, a - 1)
		return new Bn(l, d)
	}
	t.to = o
	function e(n) {
		let { anchor: r, active: i } = n
		return {
			selectionStartLineNumber: r.line + 1,
			selectionStartColumn: r.character + 1,
			positionLineNumber: i.line + 1,
			positionColumn: i.character + 1,
		}
	}
	t.from = e
})((er ||= {}))
var H
;((t) => {
	function o(n) {
		if (!n) return
		let { start: r, end: i } = n
		return {
			startLineNumber: r.line + 1,
			startColumn: r.character + 1,
			endLineNumber: i.line + 1,
			endColumn: i.character + 1,
		}
	}
	t.from = o
	function e(n) {
		if (!n) return
		let { startLineNumber: r, startColumn: i, endLineNumber: s, endColumn: a } = n
		return new pe(r - 1, i - 1, s - 1, a - 1)
	}
	t.to = e
})((H ||= {}))
var tl
;((t) => {
	function o(n) {
		return { uri: n.uri, range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new rn(b.revive(n.uri), H.to(n.range))
	}
	t.to = e
})((tl ||= {}))
var UD
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 0:
				return 0
			case 3:
				return 3
			case 2:
				return 2
		}
	}
	e.to = o
})((UD ||= {}))
var Je
;((t) => {
	function o(n) {
		return new Pe(n.lineNumber - 1, n.column - 1)
	}
	t.to = o
	function e(n) {
		return { lineNumber: n.line + 1, column: n.character + 1 }
	}
	t.from = e
})((Je ||= {}))
var Hs
;((n) => {
	function o(r, i, s) {
		return Ye(an(r).map((a) => e(a, i, s)))
	}
	n.from = o
	function e(r, i, s) {
		if (typeof r == "string") return { $serialized: !0, language: r, isBuiltin: s?.isBuiltin }
		if (r)
			return {
				$serialized: !0,
				language: r.language,
				scheme: t(r.scheme, i),
				pattern: Ir.from(r.pattern) ?? void 0,
				exclusive: r.exclusive,
				notebookType: r.notebookType,
				isBuiltin: s?.isBuiltin,
			}
	}
	function t(r, i) {
		return i && typeof r == "string" ? i.transformOutgoingScheme(r) : r
	}
})((Hs ||= {}))
var RD
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
				return 2
			default:
				return
		}
	}
	t.to = e
})((RD ||= {}))
var Rd
;((t) => {
	function o(n) {
		let r
		return (
			n.code &&
				(we(n.code) || fn(n.code)
					? (r = String(n.code))
					: (r = { value: String(n.code.value), target: n.code.target })),
			{
				...H.from(n.range),
				message: n.message,
				source: n.source,
				code: r,
				severity: ux.from(n.severity),
				relatedInformation: n.relatedInformation && n.relatedInformation.map(AD.from),
				tags: Array.isArray(n.tags) ? Ye(n.tags.map(RD.from)) : void 0,
			}
		)
	}
	t.from = o
	function e(n) {
		let r = new _a(H.to(n), n.message, ux.to(n.severity))
		return (
			(r.source = n.source),
			(r.code = we(n.code) ? n.code : n.code?.value),
			(r.relatedInformation = n.relatedInformation && n.relatedInformation.map(AD.to)),
			(r.tags = n.tags && Ye(n.tags.map(RD.to))),
			r
		)
	}
	t.to = e
})((Rd ||= {}))
var AD
;((t) => {
	function o(n) {
		return { ...H.from(n.location.range), message: n.message, resource: n.location.uri }
	}
	t.from = o
	function e(n) {
		return new ys(new rn(n.resource, H.to(n)), n.message)
	}
	t.to = e
})((AD ||= {}))
var ux
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 8
			case 1:
				return 4
			case 2:
				return 2
			case 3:
				return 1
		}
		return 8
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 2:
				return 2
			case 4:
				return 1
			case 8:
				return 0
			case 1:
				return 3
			default:
				return 0
		}
	}
	t.to = e
})((ux ||= {}))
var wt
;((t) => {
	function o(n) {
		return typeof n == "number" && n >= 1 ? n - 1 : n === -2 ? SF : CF
	}
	t.from = o
	function e(n) {
		if (typeof n == "number" && n >= 0) return n + 1
		throw new Error("invalid 'EditorGroupColumn'")
	}
	t.to = e
})((wt ||= {}))
function W7(o) {
	return typeof o.range < "u"
}
function HD(o) {
	return o.length === 0 ? !0 : !!W7(o[0])
}
var Se
;((s) => {
	function o(a) {
		return a.map(s.from)
	}
	s.fromMany = o
	function e(a) {
		return a && typeof a == "object" && typeof a.language == "string" && typeof a.value == "string"
	}
	function t(a) {
		let l
		if (e(a)) {
			let { language: u, value: m } = a
			l = {
				value:
					"```" +
					u +
					`
` +
					m +
					"\n```\n",
			}
		} else
			en.isMarkdownString(a)
				? (l = {
						value: a.value,
						isTrusted: a.isTrusted,
						supportThemeIcons: a.supportThemeIcons,
						supportHtml: a.supportHtml,
						baseUri: a.baseUri,
					})
				: typeof a == "string"
					? (l = { value: a })
					: (l = { value: "" })
		let d = Object.create(null)
		l.uris = d
		let c = ({ href: u }) => {
			try {
				let m = b.parse(u, !0)
				;(m = m.with({ query: n(m.query, d) })), (d[u] = m)
			} catch {}
			return ""
		}
		return (
			Tt.walkTokens(Tt.lexer(l.value), (u) => {
				u.type === "link"
					? c({ href: u.href })
					: u.type === "image" && typeof u.href == "string" && c(ML(u.href))
			}),
			l
		)
	}
	s.from = t
	function n(a, l) {
		if (!a) return a
		let d
		try {
			d = tb(a)
		} catch {}
		if (!d) return a
		let c = !1
		return (
			(d = os(d, (u) => {
				if (b.isUri(u)) {
					let m = `__uri_${Math.random().toString(16).slice(2, 8)}`
					return (l[m] = u), (c = !0), m
				} else return
			})),
			c ? JSON.stringify(d) : a
		)
	}
	function r(a) {
		let l = new en(a.value, a.supportThemeIcons)
		return (
			(l.isTrusted = a.isTrusted),
			(l.supportHtml = a.supportHtml),
			(l.baseUri = a.baseUri ? b.from(a.baseUri) : void 0),
			l
		)
	}
	s.to = r
	function i(a) {
		if (a) return typeof a == "string" ? a : s.from(a)
	}
	s.fromStrict = i
})((Se ||= {}))
function MF(o) {
	return HD(o)
		? o.map((e) => ({
				range: H.from(e.range),
				hoverMessage: Array.isArray(e.hoverMessage)
					? Se.fromMany(e.hoverMessage)
					: e.hoverMessage
						? Se.from(e.hoverMessage)
						: void 0,
				renderOptions: e.renderOptions,
			}))
		: o.map((e) => ({ range: H.from(e) }))
}
function Tg(o) {
	return typeof o > "u" ? o : typeof o == "string" ? b.file(o) : o
}
var vg
;((e) => {
	function o(t) {
		return typeof t > "u"
			? t
			: {
					contentText: t.contentText,
					contentIconPath: t.contentIconPath ? Tg(t.contentIconPath) : void 0,
					border: t.border,
					borderColor: t.borderColor,
					fontStyle: t.fontStyle,
					fontWeight: t.fontWeight,
					textDecoration: t.textDecoration,
					color: t.color,
					backgroundColor: t.backgroundColor,
					margin: t.margin,
					width: t.width,
					height: t.height,
				}
	}
	e.from = o
})((vg ||= {}))
var OD
;((e) => {
	function o(t) {
		return typeof t > "u"
			? t
			: {
					backgroundColor: t.backgroundColor,
					outline: t.outline,
					outlineColor: t.outlineColor,
					outlineStyle: t.outlineStyle,
					outlineWidth: t.outlineWidth,
					border: t.border,
					borderColor: t.borderColor,
					borderRadius: t.borderRadius,
					borderSpacing: t.borderSpacing,
					borderStyle: t.borderStyle,
					borderWidth: t.borderWidth,
					fontStyle: t.fontStyle,
					fontWeight: t.fontWeight,
					textDecoration: t.textDecoration,
					cursor: t.cursor,
					color: t.color,
					opacity: t.opacity,
					letterSpacing: t.letterSpacing,
					gutterIconPath: t.gutterIconPath ? Tg(t.gutterIconPath) : void 0,
					gutterIconSize: t.gutterIconSize,
					overviewRulerColor: t.overviewRulerColor,
					before: t.before ? vg.from(t.before) : void 0,
					after: t.after ? vg.from(t.after) : void 0,
				}
	}
	e.from = o
})((OD ||= {}))
var FF
;((e) => {
	function o(t) {
		if (typeof t > "u") return t
		switch (t) {
			case 0:
				return 0
			case 1:
				return 1
			case 2:
				return 2
			case 3:
				return 3
		}
	}
	e.from = o
})((FF ||= {}))
var WD
;((e) => {
	function o(t) {
		return {
			isWholeLine: t.isWholeLine,
			rangeBehavior: t.rangeBehavior ? FF.from(t.rangeBehavior) : void 0,
			overviewRulerLane: t.overviewRulerLane,
			light: t.light ? OD.from(t.light) : void 0,
			dark: t.dark ? OD.from(t.dark) : void 0,
			backgroundColor: t.backgroundColor,
			outline: t.outline,
			outlineColor: t.outlineColor,
			outlineStyle: t.outlineStyle,
			outlineWidth: t.outlineWidth,
			border: t.border,
			borderColor: t.borderColor,
			borderRadius: t.borderRadius,
			borderSpacing: t.borderSpacing,
			borderStyle: t.borderStyle,
			borderWidth: t.borderWidth,
			fontStyle: t.fontStyle,
			fontWeight: t.fontWeight,
			textDecoration: t.textDecoration,
			cursor: t.cursor,
			color: t.color,
			opacity: t.opacity,
			letterSpacing: t.letterSpacing,
			gutterIconPath: t.gutterIconPath ? Tg(t.gutterIconPath) : void 0,
			gutterIconSize: t.gutterIconSize,
			overviewRulerColor: t.overviewRulerColor,
			before: t.before ? vg.from(t.before) : void 0,
			after: t.after ? vg.from(t.after) : void 0,
		}
	}
	e.from = o
})((WD ||= {}))
var on
;((t) => {
	function o(n) {
		return { text: n.newText, eol: n.newEol && _d.from(n.newEol), range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		let r = new Mn(H.to(n.range), n.text)
		return (r.newEol = typeof n.eol > "u" ? void 0 : _d.to(n.eol)), r
	}
	t.to = e
})((on ||= {}))
var zn
;((t) => {
	function o(n, r) {
		let i = { edits: [] }
		if (n instanceof Yr) {
			let s = new mc()
			for (let a of n._allEntries()) a._type === 1 && b.isUri(a.to) && a.from === void 0 && s.add(a.to)
			for (let a of n._allEntries())
				if (a._type === 1) {
					let l
					a.options?.contents &&
						(ArrayBuffer.isView(a.options.contents)
							? (l = { type: "base64", value: Ol(z.wrap(a.options.contents)) })
							: (l = { type: "dataTransferItem", id: a.options.contents._itemId })),
						i.edits.push({
							oldResource: a.from,
							newResource: a.to,
							options: { ...a.options, contents: l },
							metadata: a.metadata,
						})
				} else
					a._type === 2
						? i.edits.push({
								resource: a.uri,
								textEdit: on.from(a.edit),
								versionId: s.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
								metadata: a.metadata,
							})
						: a._type === 6
							? i.edits.push({
									resource: a.uri,
									textEdit: {
										range: H.from(a.range),
										text: a.edit.value,
										insertAsSnippet: !0,
										keepWhitespace: a.keepWhitespace,
									},
									versionId: s.has(a.uri) ? void 0 : r?.getTextDocumentVersion(a.uri),
									metadata: a.metadata,
								})
							: a._type === 3
								? i.edits.push({
										metadata: a.metadata,
										resource: a.uri,
										cellEdit: a.edit,
										notebookVersionId: r?.getNotebookDocumentVersion(a.uri),
									})
								: a._type === 5 &&
									i.edits.push({
										metadata: a.metadata,
										resource: a.uri,
										notebookVersionId: r?.getNotebookDocumentVersion(a.uri),
										cellEdit: {
											editType: 1,
											index: a.index,
											count: a.count,
											cells: a.cells.map(yg.from),
										},
									})
		}
		return i
	}
	t.from = o
	function e(n) {
		let r = new Yr(),
			i = new ft()
		for (let s of n.edits)
			if (s.textEdit) {
				let a = s,
					l = b.revive(a.resource),
					d = H.to(a.textEdit.range),
					c = a.textEdit.text,
					u = a.textEdit.insertAsSnippet,
					m
				u ? (m = bd.replace(d, new Vn(c))) : (m = Mn.replace(d, c))
				let f = i.get(l)
				f ? f.push(m) : i.set(l, [m])
			} else r.renameFile(b.revive(s.oldResource), b.revive(s.newResource), s.options)
		for (let [s, a] of i) r.set(s, a)
		return r
	}
	t.to = e
})((zn ||= {}))
var eo
;((n) => {
	let o = Object.create(null)
	;(o[0] = 0),
		(o[1] = 1),
		(o[2] = 2),
		(o[3] = 3),
		(o[4] = 4),
		(o[5] = 5),
		(o[6] = 6),
		(o[7] = 7),
		(o[8] = 8),
		(o[9] = 9),
		(o[10] = 10),
		(o[11] = 11),
		(o[12] = 12),
		(o[13] = 13),
		(o[14] = 14),
		(o[15] = 15),
		(o[16] = 16),
		(o[17] = 17),
		(o[18] = 18),
		(o[19] = 19),
		(o[20] = 20),
		(o[21] = 21),
		(o[22] = 22),
		(o[23] = 23),
		(o[24] = 24),
		(o[25] = 25)
	function e(r) {
		return typeof o[r] == "number" ? o[r] : 6
	}
	n.from = e
	function t(r) {
		for (let i in o) if (o[i] === r) return Number(i)
		return 6
	}
	n.to = t
})((eo ||= {}))
var Ns
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.to = e
})((Ns ||= {}))
var nl
;((t) => {
	function o(n) {
		return {
			name: n.name,
			kind: eo.from(n.kind),
			tags: n.tags && n.tags.map(Ns.from),
			containerName: n.containerName,
			location: $n.from(n.location),
		}
	}
	t.from = o
	function e(n) {
		let r = new vo(n.name, eo.to(n.kind), n.containerName, $n.to(n.location))
		return (r.tags = n.tags && n.tags.map(Ns.to)), r
	}
	t.to = e
})((nl ||= {}))
var VD
;((t) => {
	function o(n) {
		let r = {
			name: n.name || "!!MISSING: name!!",
			detail: n.detail,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			kind: eo.from(n.kind),
			tags: n.tags?.map(Ns.from) ?? [],
		}
		return n.children && (r.children = n.children.map(o)), r
	}
	t.from = o
	function e(n) {
		let r = new Zr(n.name, n.detail, eo.to(n.kind), H.to(n.range), H.to(n.selectionRange))
		return si(n.tags) && (r.tags = n.tags.map(Ns.to)), n.children && (r.children = n.children.map(e)), r
	}
	t.to = e
})((VD ||= {}))
var Ws
;((t) => {
	function o(n) {
		let r = new qa(eo.to(n.kind), n.name, n.detail || "", b.revive(n.uri), H.to(n.range), H.to(n.selectionRange))
		return (r._sessionId = n._sessionId), (r._itemId = n._itemId), r
	}
	t.to = o
	function e(n, r, i) {
		if (((r = r ?? n._sessionId), (i = i ?? n._itemId), r === void 0 || i === void 0))
			throw new Error("invalid item")
		return {
			_sessionId: r,
			_itemId: i,
			name: n.name,
			detail: n.detail,
			kind: eo.from(n.kind),
			uri: n.uri,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			tags: n.tags?.map(Ns.from),
		}
	}
	t.from = e
})((Ws ||= {}))
var BD
;((e) => {
	function o(t) {
		return new Cu(
			Ws.to(t.from),
			t.fromRanges.map((n) => H.to(n)),
		)
	}
	e.to = o
})((BD ||= {}))
var $D
;((e) => {
	function o(t) {
		return new Su(
			Ws.to(t.to),
			t.fromRanges.map((n) => H.to(n)),
		)
	}
	e.to = o
})(($D ||= {}))
var $n
;((t) => {
	function o(n) {
		return { range: n.range && H.from(n.range), uri: n.uri }
	}
	t.from = o
	function e(n) {
		return new rn(b.revive(n.uri), H.to(n.range))
	}
	t.to = e
})(($n ||= {}))
var Yu
;((t) => {
	function o(n) {
		let r = n,
			i = n
		return {
			originSelectionRange: r.originSelectionRange ? H.from(r.originSelectionRange) : void 0,
			uri: r.targetUri ? r.targetUri : i.uri,
			range: H.from(r.targetRange ? r.targetRange : i.range),
			targetSelectionRange: r.targetSelectionRange ? H.from(r.targetSelectionRange) : void 0,
		}
	}
	t.from = o
	function e(n) {
		return {
			targetUri: b.revive(n.uri),
			targetRange: H.to(n.range),
			targetSelectionRange: n.targetSelectionRange ? H.to(n.targetSelectionRange) : void 0,
			originSelectionRange: n.originSelectionRange ? H.to(n.originSelectionRange) : void 0,
		}
	}
	t.to = e
})((Yu ||= {}))
var Zu
;((t) => {
	function o(n) {
		return {
			range: H.from(n.range),
			contents: Se.fromMany(n.contents),
			canIncreaseVerbosity: n.canIncreaseVerbosity,
			canDecreaseVerbosity: n.canDecreaseVerbosity,
		}
	}
	t.from = o
	function e(n) {
		let r = n.contents.map(Se.to),
			i = H.to(n.range),
			s = n.canIncreaseVerbosity,
			a = n.canDecreaseVerbosity
		return new Da(r, i, s, a)
	}
	t.to = e
})((Zu ||= {}))
var zD
;((t) => {
	function o(n) {
		return { range: H.from(n.range), expression: n.expression }
	}
	t.from = o
	function e(n) {
		return new Ha(H.to(n.range), n.expression)
	}
	t.to = e
})((zD ||= {}))
var Eg
;((t) => {
	function o(n) {
		if (n instanceof Wa) return { type: "text", range: H.from(n.range), text: n.text }
		if (n instanceof Va)
			return {
				type: "variable",
				range: H.from(n.range),
				variableName: n.variableName,
				caseSensitiveLookup: n.caseSensitiveLookup,
			}
		if (n instanceof Ba) return { type: "expression", range: H.from(n.range), expression: n.expression }
		throw new Error("Unknown 'InlineValue' type")
	}
	t.from = o
	function e(n) {
		switch (n.type) {
			case "text":
				return { range: H.to(n.range), text: n.text }
			case "variable":
				return {
					range: H.to(n.range),
					variableName: n.variableName,
					caseSensitiveLookup: n.caseSensitiveLookup,
				}
			case "expression":
				return { range: H.to(n.range), expression: n.expression }
		}
	}
	t.to = e
})((Eg ||= {}))
var wg
;((t) => {
	function o(n) {
		return { frameId: n.frameId, stoppedLocation: H.from(n.stoppedLocation) }
	}
	t.from = o
	function e(n) {
		return new yu(n.frameId, H.to(n.stoppedLocation))
	}
	t.to = e
})((wg ||= {}))
var Pd
;((t) => {
	function o(n) {
		return { range: H.from(n.range), kind: n.kind }
	}
	t.from = o
	function e(n) {
		return new ka(H.to(n.range), n.kind)
	}
	t.to = e
})((Pd ||= {}))
var qD
;((t) => {
	function o(n) {
		return { uri: n.uri, highlights: n.highlights.map(Pd.from) }
	}
	t.from = o
	function e(n) {
		return new Ra(b.revive(n.uri), n.highlights.map(Pd.to))
	}
	t.to = e
})((qD ||= {}))
var NF
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 2:
				return 2
			case 0:
			default:
				return 0
		}
	}
	e.to = o
})((NF ||= {}))
var KD
;((e) => {
	function o(t) {
		return { triggerKind: NF.to(t.triggerKind), triggerCharacter: t.triggerCharacter }
	}
	e.to = o
})((KD ||= {}))
var px
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
		}
	}
	t.to = e
})((px ||= {}))
var mx
;((r) => {
	let o = new Map([
		[1, 0],
		[2, 1],
		[3, 2],
		[4, 3],
		[5, 4],
		[6, 5],
		[7, 7],
		[21, 6],
		[8, 8],
		[9, 9],
		[10, 12],
		[11, 13],
		[20, 14],
		[12, 15],
		[19, 16],
		[13, 17],
		[14, 27],
		[0, 18],
		[15, 19],
		[16, 20],
		[17, 21],
		[18, 23],
		[22, 10],
		[23, 11],
		[24, 24],
		[26, 26],
		[25, 25],
	])
	function e(i) {
		return o.get(i) ?? 9
	}
	r.from = e
	let t = new Map([
		[0, 1],
		[1, 2],
		[2, 3],
		[3, 4],
		[4, 5],
		[5, 6],
		[7, 7],
		[6, 21],
		[8, 8],
		[9, 9],
		[12, 10],
		[13, 11],
		[14, 20],
		[15, 12],
		[16, 19],
		[17, 13],
		[27, 14],
		[18, 0],
		[19, 15],
		[20, 16],
		[21, 17],
		[23, 18],
		[10, 22],
		[11, 23],
		[24, 24],
		[25, 25],
		[26, 26],
	])
	function n(i) {
		return t.get(i) ?? 9
	}
	r.to = n
})((mx ||= {}))
var jD
;((e) => {
	function o(t, n) {
		let r = new Ma(t.label)
		return (
			(r.insertText = t.insertText),
			(r.kind = mx.to(t.kind)),
			(r.tags = t.tags?.map(px.to)),
			(r.detail = t.detail),
			(r.documentation = Gr(t.documentation) ? Se.to(t.documentation) : t.documentation),
			(r.sortText = t.sortText),
			(r.filterText = t.filterText),
			(r.preselect = t.preselect),
			(r.commitCharacters = t.commitCharacters),
			Re.isIRange(t.range)
				? (r.range = H.to(t.range))
				: typeof t.range == "object" &&
					(r.range = { inserting: H.to(t.range.insert), replacing: H.to(t.range.replace) }),
			(r.keepWhitespace = typeof t.insertTextRules > "u" ? !1 : !!(t.insertTextRules & 1)),
			typeof t.insertTextRules < "u" && t.insertTextRules & 4
				? (r.insertText = new Vn(t.insertText))
				: ((r.insertText = t.insertText),
					(r.textEdit = r.range instanceof pe ? new Mn(r.range, r.insertText) : void 0)),
			t.additionalTextEdits &&
				t.additionalTextEdits.length > 0 &&
				(r.additionalTextEdits = t.additionalTextEdits.map((i) => on.to(i))),
			(r.command = n && t.command ? n.fromInternal(t.command) : void 0),
			r
		)
	}
	e.to = o
})((jD ||= {}))
var LD
;((t) => {
	function o(n) {
		if (typeof n.label != "string" && !Array.isArray(n.label)) throw new TypeError("Invalid label")
		return { label: n.label, documentation: Se.fromStrict(n.documentation) }
	}
	t.from = o
	function e(n) {
		return { label: n.label, documentation: Gr(n.documentation) ? Se.to(n.documentation) : n.documentation }
	}
	t.to = e
})((LD ||= {}))
var MD
;((t) => {
	function o(n) {
		return {
			label: n.label,
			documentation: Se.fromStrict(n.documentation),
			parameters: Array.isArray(n.parameters) ? n.parameters.map(LD.from) : [],
			activeParameter: n.activeParameter,
		}
	}
	t.from = o
	function e(n) {
		return {
			label: n.label,
			documentation: Gr(n.documentation) ? Se.to(n.documentation) : n.documentation,
			parameters: Array.isArray(n.parameters) ? n.parameters.map(LD.to) : [],
			activeParameter: n.activeParameter,
		}
	}
	t.to = e
})((MD ||= {}))
var ep
;((t) => {
	function o(n) {
		return {
			activeSignature: n.activeSignature,
			activeParameter: n.activeParameter,
			signatures: Array.isArray(n.signatures) ? n.signatures.map(MD.from) : [],
		}
	}
	t.from = o
	function e(n) {
		return {
			activeSignature: n.activeSignature,
			activeParameter: n.activeParameter,
			signatures: Array.isArray(n.signatures) ? n.signatures.map(MD.to) : [],
		}
	}
	t.to = e
})((ep ||= {}))
var GD
;((e) => {
	function o(t, n) {
		let r = new La(
			Je.to(n.position),
			typeof n.label == "string" ? n.label : n.label.map(UF.to.bind(void 0, t)),
			n.kind && fx.to(n.kind),
		)
		return (
			(r.textEdits = n.textEdits && n.textEdits.map(on.to)),
			(r.tooltip = Gr(n.tooltip) ? Se.to(n.tooltip) : n.tooltip),
			(r.paddingLeft = n.paddingLeft),
			(r.paddingRight = n.paddingRight),
			r
		)
	}
	e.to = o
})((GD ||= {}))
var UF
;((e) => {
	function o(t, n) {
		let r = new Oa(n.label)
		return (
			(r.tooltip = Gr(n.tooltip) ? Se.to(n.tooltip) : n.tooltip),
			FP.is(n.command) && (r.command = t.fromInternal(n.command)),
			n.location && (r.location = $n.to(n.location)),
			r
		)
	}
	e.to = o
})((UF ||= {}))
var fx
;((t) => {
	function o(n) {
		return n
	}
	t.from = o
	function e(n) {
		return n
	}
	t.to = e
})((fx ||= {}))
var Vs
;((t) => {
	function o(n) {
		return { range: H.from(n.range), url: n.target, tooltip: n.tooltip }
	}
	t.from = o
	function e(n) {
		let r
		if (n.url)
			try {
				r = typeof n.url == "string" ? b.parse(n.url, !0) : b.revive(n.url)
			} catch {}
		let i = new Fa(H.to(n.range), r)
		return (i.tooltip = n.tooltip), i
	}
	t.to = e
})((Vs ||= {}))
var Pg
;((t) => {
	function o(n) {
		let r = new Ua(n.label)
		return (
			n.textEdit && (r.textEdit = on.to(n.textEdit)),
			n.additionalTextEdits && (r.additionalTextEdits = n.additionalTextEdits.map((i) => on.to(i))),
			r
		)
	}
	t.to = o
	function e(n) {
		return {
			label: n.label,
			textEdit: n.textEdit ? on.from(n.textEdit) : void 0,
			additionalTextEdits: n.additionalTextEdits ? n.additionalTextEdits.map((r) => on.from(r)) : void 0,
		}
	}
	t.from = e
})((Pg ||= {}))
var Ad
;((t) => {
	function o(n) {
		return new qo(n[0], n[1], n[2], n[3])
	}
	t.to = o
	function e(n) {
		return [n.red, n.green, n.blue, n.alpha]
	}
	t.from = e
})((Ad ||= {}))
var QD
;((t) => {
	function o(n) {
		return { range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new Ci(H.to(n.range))
	}
	t.to = e
})((QD ||= {}))
var _g
;((e) => {
	function o(t) {
		switch (t) {
			case 2:
				return 2
			case 1:
				return 1
			case 3:
			case 4:
				return 3
		}
	}
	e.to = o
})((_g ||= {}))
var Od
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 0
			case 2:
				return 2
			case 3:
				return 3
			case 1:
			default:
				return 1
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 0:
				return 0
			case 2:
				return 2
			case 3:
				return 3
			case 1:
			default:
				return 1
		}
	}
	t.to = e
})((Od ||= {}))
var _d
;((t) => {
	function o(n) {
		if (n === 2) return 1
		if (n === 1) return 0
	}
	t.from = o
	function e(n) {
		if (n === 1) return 2
		if (n === 0) return 1
	}
	t.to = e
})((_d ||= {}))
var JD
;((e) => {
	function o(t) {
		if (typeof t == "object") return t.viewId
		switch (t) {
			case 1:
				return 3
			case 10:
				return 10
			case 15:
				return 15
		}
		throw new Error("Unknown 'ProgressLocation'")
	}
	e.from = o
})((JD ||= {}))
var Dg
;((t) => {
	function o(n) {
		let r = { start: n.start + 1, end: n.end + 1 }
		return n.kind && (r.kind = FD.from(n.kind)), r
	}
	t.from = o
	function e(n) {
		let r = { start: n.start - 1, end: n.end - 1 }
		return n.kind && (r.kind = FD.to(n.kind)), r
	}
	t.to = e
})((Dg ||= {}))
var FD
;((t) => {
	function o(n) {
		if (n)
			switch (n) {
				case 1:
					return ms.Comment
				case 2:
					return ms.Imports
				case 3:
					return ms.Region
			}
	}
	t.from = o
	function e(n) {
		if (n)
			switch (n.value) {
				case ms.Comment.value:
					return 1
				case ms.Imports.value:
					return 2
				case ms.Region.value:
					return 3
			}
	}
	t.to = e
})((FD ||= {}))
var kg
;((e) => {
	function o(t) {
		if (t)
			return {
				pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
				inactive: t.background,
				preserveFocus: t.preserveFocus,
				selection: typeof t.selection == "object" ? H.from(t.selection) : void 0,
				override: typeof t.override == "boolean" ? qP.id : void 0,
			}
	}
	e.from = o
})((kg ||= {}))
var Ir
;((r) => {
	function o(i) {
		return i instanceof Ei
			? i.toJSON()
			: typeof i == "string"
				? i
				: e(i) || t(i)
					? new Ei(i.baseUri ?? i.base, i.pattern).toJSON()
					: i
	}
	r.from = o
	function e(i) {
		let s = i
		return s ? b.isUri(s.baseUri) && typeof s.pattern == "string" : !1
	}
	function t(i) {
		let s = i
		return s ? typeof s.base == "string" && typeof s.pattern == "string" : !1
	}
	function n(i) {
		return typeof i == "string" ? i : new Ei(b.revive(i.baseUri), i.pattern)
	}
	r.to = n
})((Ir ||= {}))
var XD
;((e) => {
	function o(t) {
		if (t) {
			if (Array.isArray(t)) return t.map(o)
			if (typeof t == "string") return t
			{
				let n = t
				return {
					language: n.language,
					scheme: n.scheme,
					pattern: Ir.from(n.pattern) ?? void 0,
					exclusive: n.exclusive,
					notebookType: n.notebookType,
				}
			}
		} else return
	}
	e.from = o
})((XD ||= {}))
var to
;((t) => {
	function o(n) {
		return { start: n.start, end: n.end }
	}
	t.from = o
	function e(n) {
		return new cr(n.start, n.end)
	}
	t.to = e
})((to ||= {}))
var Ju
;((t) => {
	function o(n) {
		return {
			timing:
				typeof n.runStartTime == "number" && typeof n.runEndTime == "number"
					? { startTime: n.runStartTime, endTime: n.runEndTime }
					: void 0,
			executionOrder: n.executionOrder,
			success: n.lastRunSuccess,
		}
	}
	t.to = o
	function e(n) {
		return {
			lastRunSuccess: n.success,
			runStartTime: n.timing?.startTime,
			runEndTime: n.timing?.endTime,
			executionOrder: n.executionOrder,
		}
	}
	t.from = e
})((Ju ||= {}))
var YD
;((e) => {
	function o(t) {
		if (t === 1) return 2
		if (t === 2) return
		if (t === 3) return 3
		throw new Error(`Unknown state: ${t}`)
	}
	e.to = o
})((YD ||= {}))
var bg
;((t) => {
	function o(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
			default:
				return 2
		}
	}
	t.from = o
	function e(n) {
		switch (n) {
			case 1:
				return 1
			case 2:
			default:
				return 2
		}
	}
	t.to = e
})((bg ||= {}))
var rl
;((t) => {
	function o(n) {
		let r = { metadata: n.metadata ?? Object.create(null), cells: [] }
		for (let i of n.cells) Ts.validate(i), r.cells.push(yg.from(i))
		return r
	}
	t.from = o
	function e(n) {
		let r = new Pu(n.cells.map(yg.to))
		return pv(n.metadata) || (r.metadata = n.metadata), r
	}
	t.to = e
})((rl ||= {}))
var yg
;((t) => {
	function o(n) {
		return {
			cellKind: bg.from(n.kind),
			language: n.languageId,
			mime: n.mime,
			source: n.value,
			metadata: n.metadata,
			internalMetadata: Ju.from(n.executionSummary ?? {}),
			outputs: n.outputs ? n.outputs.map(Us.from) : [],
		}
	}
	t.from = o
	function e(n) {
		return new Ts(
			bg.to(n.cellKind),
			n.source,
			n.language,
			n.mime,
			n.outputs ? n.outputs.map(Us.to) : void 0,
			n.metadata,
			n.internalMetadata ? Ju.to(n.internalMetadata) : void 0,
		)
	}
	t.to = e
})((yg ||= {}))
var Dd
;((t) => {
	function o(n) {
		return { mime: n.mime, valueBytes: z.wrap(n.data) }
	}
	t.from = o
	function e(n) {
		return new _u(n.valueBytes.buffer, n.mime)
	}
	t.to = e
})((Dd ||= {}))
var Us
;((t) => {
	function o(n) {
		return { outputId: n.id, items: n.items.map(Dd.from), metadata: n.metadata }
	}
	t.from = o
	function e(n) {
		let r = n.items.map(Dd.to)
		return new Es(r, n.outputId, n.metadata)
	}
	t.to = e
})((Us ||= {}))
var Rg
;((n) => {
	function o(r) {
		return t(r)
			? { include: Ir.from(r.include) ?? void 0, exclude: Ir.from(r.exclude) ?? void 0 }
			: (Ir.from(r) ?? void 0)
	}
	n.from = o
	function e(r) {
		return t(r) ? { include: Ir.to(r.include), exclude: Ir.to(r.exclude) } : Ir.to(r)
	}
	n.to = e
	function t(r) {
		let i = r
		return i ? !bt(i.include) && !bt(i.exclude) : !1
	}
})((Rg ||= {}))
var ZD
;((e) => {
	function o(t, n, r) {
		let i = typeof t.command == "string" ? { title: "", command: t.command } : t.command
		return {
			alignment: t.alignment === 1 ? 1 : 2,
			command: n.toInternal(i, r),
			text: t.text,
			tooltip: t.tooltip,
			accessibilityInformation: t.accessibilityInformation,
			priority: t.priority,
		}
	}
	e.from = o
})((ZD ||= {}))
var ek
;((e) => {
	function o(t, n, r) {
		let i = typeof t.command == "string" ? { title: "", command: t.command } : t.command
		return {
			command: n.toInternal(i, r),
			label: t.label,
			description: t.description,
			detail: t.detail,
			documentation: t.documentation,
		}
	}
	e.from = o
})((ek ||= {}))
var tk
;((e) => {
	function o(t) {
		return {
			transientOutputs: t?.transientOutputs ?? !1,
			transientCellMetadata: t?.transientCellMetadata ?? {},
			transientDocumentMetadata: t?.transientDocumentMetadata ?? {},
			cellContentMetadata: t?.cellContentMetadata ?? {},
		}
	}
	e.from = o
})((tk ||= {}))
var gx
;((t) => {
	function o(n) {
		return { uri: n.uri, provides: n.provides }
	}
	t.from = o
	function e(n) {
		return new Du(b.revive(n.uri), n.provides)
	}
	t.to = e
})((gx ||= {}))
var tp
;((t) => {
	function o(n) {
		return {
			message: Se.fromStrict(n.message) || "",
			type: 0,
			expected: n.expectedOutput,
			actual: n.actualOutput,
			contextValue: n.contextValue,
			location: n.location && { range: H.from(n.location.range), uri: n.location.uri },
			stackTrace: n.stackTrace?.map((r) => ({
				label: r.label,
				position: r.position && Je.from(r.position),
				uri: r.uri && b.revive(r.uri).toJSON(),
			})),
		}
	}
	t.from = o
	function e(n) {
		let r = new Pi(typeof n.message == "string" ? n.message : Se.to(n.message))
		return (
			(r.actualOutput = n.actual),
			(r.expectedOutput = n.expected),
			(r.contextValue = n.contextValue),
			(r.location = n.location ? $n.to(n.location) : void 0),
			r
		)
	}
	t.to = e
})((tp ||= {}))
var So
;((t) => ((t.namespace = du), (t.denamespace = Wy)))((So ||= {}))
var nk
;((e) => {
	function o(t) {
		return { controllerId: t.controllerId, profileId: t.profileId, group: np.from(t.kind) }
	}
	e.from = o
})((nk ||= {}))
var np
;((t) => {
	let o = { 3: 8, 2: 4, 1: 2 }
	function e(n) {
		return o.hasOwnProperty(n) ? o[n] : 2
	}
	t.from = e
})((np ||= {}))
var Oi
;((t) => {
	function o(n) {
		let r = cu(n).controllerId
		return {
			extId: ze.fromExtHostTestItem(n, r).toString(),
			label: n.label,
			uri: b.revive(n.uri),
			busy: n.busy,
			tags: n.tags.map((i) => So.namespace(r, i.id)),
			range: Re.lift(H.from(n.range)),
			description: n.description || null,
			sortText: n.sortText || null,
			error: (n.error && Se.fromStrict(n.error)) || null,
		}
	}
	t.from = o
	function e(n) {
		return {
			parent: void 0,
			error: void 0,
			id: ze.fromString(n.extId).localId,
			label: n.label,
			uri: b.revive(n.uri),
			tags: (n.tags || []).map((r) => {
				let { tagId: i } = So.denamespace(r)
				return new Ss(i)
			}),
			children: {
				add: () => {},
				delete: () => {},
				forEach: () => {},
				*[Symbol.iterator]() {},
				get: () => {},
				replace: () => {},
				size: 0,
			},
			range: H.to(n.range || void 0),
			canResolveChildren: !1,
			busy: n.busy,
			description: n.description || void 0,
			sortText: n.sortText || void 0,
		}
	}
	t.toPlain = e
})((Oi ||= {}))
;((t) => {
	function o(n) {
		return { id: n.id }
	}
	t.from = o
	function e(n) {
		return new Ss(n.id)
	}
	t.to = e
})((So ||= {}))
var rk
;((t) => {
	let o = (n, r) => {
		let i = n.value
		if (!i) return
		let s = {
			...Oi.toPlain(i.item),
			parent: r,
			taskStates: i.tasks.map((a) => ({
				state: a.state,
				duration: a.duration,
				messages: a.messages.filter((l) => l.type === 0).map(tp.to),
			})),
			children: [],
		}
		if (n.children)
			for (let a of n.children.values()) {
				let l = o(a, s)
				l && s.children.push(l)
			}
		return s
	}
	function e(n) {
		let r = new Fb()
		for (let a of n.items) r.insert(ze.fromString(a.item.extId).path, a)
		let i = [r.nodes],
			s = []
		for (; i.length; ) for (let a of i.pop()) a.value ? s.push(a) : a.children && i.push(a.children.values())
		return { completedAt: n.completedAt, results: s.map((a) => o(a)).filter(or) }
	}
	t.to = e
})((rk ||= {}))
var Ag
;((s) => {
	function o(a) {
		return { covered: a.covered, total: a.total }
	}
	function e(a) {
		return "line" in a ? Je.from(a) : H.from(a)
	}
	function t(a) {
		if (a) return "endLineNumber" in a ? H.to(a) : Je.to(a)
	}
	function n(a) {
		if (a.type === 1) {
			let l = []
			if (a.branches)
				for (let d of a.branches) l.push({ executed: d.count, location: t(d.location), label: d.label })
			return new Ru(
				a.count,
				t(a.location),
				a.branches?.map((d) => new Au(d.count, t(d.location), d.label)),
			)
		} else return new Ou(a.name, a.count, t(a.location))
	}
	s.to = n
	function r(a) {
		if (typeof a.executed == "number" && a.executed < 0) throw new Error(`Invalid coverage count ${a.executed}`)
		return "branches" in a
			? {
					count: a.executed,
					location: e(a.location),
					type: 1,
					branches: a.branches.length
						? a.branches.map((l) => ({
								count: l.executed,
								location: l.location && e(l.location),
								label: l.label,
							}))
						: void 0,
				}
			: { type: 0, name: a.name, count: a.executed, location: e(a.location) }
	}
	s.fromDetails = r
	function i(a, l, d) {
		return (
			gg(d.statementCoverage),
			gg(d.branchCoverage),
			gg(d.declarationCoverage),
			{
				id: l,
				uri: d.uri,
				statement: o(d.statementCoverage),
				branch: d.branchCoverage && o(d.branchCoverage),
				declaration: d.declarationCoverage && o(d.declarationCoverage),
				testIds:
					d instanceof ws && d.includesTests.length
						? d.includesTests.map((c) => ze.fromExtHostTestItem(c, a).toString())
						: void 0,
			}
		)
	}
	s.fromFile = i
})((Ag ||= {}))
var ok
;((e) => {
	function o(t) {
		switch (t) {
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	e.to = o
})((ok ||= {}))
var Bs
;((t) => {
	function o(n) {
		let r = new Ga(eo.to(n.kind), n.name, n.detail || "", b.revive(n.uri), H.to(n.range), H.to(n.selectionRange))
		return (r._sessionId = n._sessionId), (r._itemId = n._itemId), r
	}
	t.to = o
	function e(n, r, i) {
		if (((r = r ?? n._sessionId), (i = i ?? n._itemId), r === void 0 || i === void 0))
			throw new Error("invalid item")
		return {
			_sessionId: r,
			_itemId: i,
			kind: eo.from(n.kind),
			name: n.name,
			detail: n.detail ?? "",
			uri: n.uri,
			range: H.from(n.range),
			selectionRange: H.from(n.selectionRange),
			tags: n.tags?.map(Ns.from),
		}
	}
	t.from = e
})((Bs ||= {}))
var Og
;((e) => {
	function o(t) {
		if (t) return { value: t.value, tooltip: t.tooltip }
	}
	e.from = o
})((Og ||= {}))
var wd
;((r) => {
	function o(i, s, a) {
		let l = s.fileData
		return l
			? new Zy(
					new eI(
						l.name,
						b.revive(l.uri),
						l.id,
						ji(() => a(l.id)),
					),
				)
			: i === mo.uriList && s.uriListData
				? new Ka(n(s.uriListData))
				: new Ka(s.asString)
	}
	r.to = o
	async function e(i, s, a = He()) {
		let l = await s.asString()
		if (i === mo.uriList) return { id: a, asString: l, fileData: void 0, uriListData: t(l) }
		let d = s.asFile()
		return { id: a, asString: l, fileData: d ? { name: d.name, uri: d.uri, id: d._itemId ?? d.id } : void 0 }
	}
	r.from = e
	function t(i) {
		return kb.split(i).map((s) => {
			if (s.startsWith("#")) return s
			try {
				return b.parse(s)
			} catch {}
			return s
		})
	}
	function n(i) {
		return kb.create(i.map((s) => (typeof s == "string" ? s : b.revive(s))))
	}
})((wd ||= {}))
var Ld
;((n) => {
	function o(r, i) {
		let s = r.items.map(([a, l]) => [a, wd.to(a, l, i)])
		return new bo(s)
	}
	n.toDataTransfer = o
	async function e(r) {
		return { items: await Promise.all(Array.from(r, async ([s, a]) => [s, await wd.from(s, a)])) }
	}
	n.from = e
	async function t(r) {
		return { items: await Promise.all(Array.from(r, async ([s, a]) => [s, await wd.from(s, a, a.id)])) }
	}
	n.fromList = t
})((Ld ||= {}))
var Lg
;((t) => {
	function o(n, r) {
		return {
			kind: "reply",
			agentId: n.participant ?? r?.agentId ?? "",
			subCommand: n.command ?? r?.command,
			message: n.prompt,
			title: n.label,
		}
	}
	t.from = o
	function e(n) {
		return { prompt: n.message, label: n.title, participant: n.agentId, command: n.subCommand }
	}
	t.to = e
})((Lg ||= {}))
var Ig
;((t) => {
	function o(n) {
		switch (n) {
			case 0:
				return 3
			case 1:
				return 1
			case 2:
				return 2
		}
	}
	t.to = o
	function e(n) {
		switch (n) {
			case 3:
				return 0
			case 1:
				return 1
			case 2:
				return 2
		}
		return 1
	}
	t.from = e
})((Ig ||= {}))
var V7
;((t) => {
	function o(n) {
		let r = n.content
				.map((a) => {
					if (a.type === "text") return new Pt(a.value)
					if (a.type === "tool_result") {
						let l = a.value.map((d) => (d.type === "text" ? new Pt(d.value) : new Co(d.value)))
						return new Fs(a.toolCallId, l, a.isError)
					} else return a.type === "image_url" ? void 0 : new xo(a.toolCallId, a.name, a.parameters)
				})
				.filter((a) => a !== void 0),
			i = Ig.to(n.role)
		return new Ku(i, r, n.name)
	}
	t.to = o
	function e(n) {
		let r = Ig.from(n.role),
			i = n.name,
			s = n.content
		typeof s == "string" && (s = [new Pt(s)])
		let a = s.map((l) => {
			if (l instanceof Fs)
				return {
					type: "tool_result",
					toolCallId: l.callId,
					value: Ye(
						l.content.map((d) =>
							d instanceof Pt
								? { type: "text", value: d.value }
								: d instanceof Co
									? { type: "prompt_tsx", value: d.value }
									: void 0,
						),
					),
					isError: l.isError,
				}
			if (l instanceof xo) return { type: "tool_use", toolCallId: l.callId, name: l.name, parameters: l.input }
			if (l instanceof Pt) return { type: "text", value: l.value }
			if (typeof l != "string") throw new Error("Unexpected chat message content type")
			return { type: "text", value: l }
		})
		return { role: r, name: i, content: a }
	}
	t.from = e
})((V7 ||= {}))
var Mg
;((t) => {
	function o(n) {
		let r = n.content.map((a) => {
				if (a.type === "text") return new Pt(a.value)
				if (a.type === "tool_result") {
					let l = a.value.map((d) => (d.type === "text" ? new Pt(d.value) : new Co(d.value)))
					return new Fs(a.toolCallId, l, a.isError)
				} else if (a.type === "image_url") {
					let l = { mimeType: a.value.mimeType, data: a.value.data.buffer }
					return new Sd(l)
				} else return new xo(a.toolCallId, a.name, a.parameters)
			}),
			i = Ig.to(n.role)
		return new ju(i, r, n.name)
	}
	t.to = o
	function e(n) {
		let r = Ig.from(n.role),
			i = n.name,
			s = n.content
		typeof s == "string" && (s = [new Pt(s)])
		let a = s.map((l) => {
			if (l instanceof Fs)
				return {
					type: "tool_result",
					toolCallId: l.callId,
					value: Ye(
						l.content.map((d) =>
							d instanceof Pt
								? { type: "text", value: d.value }
								: d instanceof Co
									? { type: "prompt_tsx", value: d.value }
									: void 0,
						),
					),
					isError: l.isError,
				}
			if (l instanceof Sd)
				return { type: "image_url", value: { mimeType: l.value.mimeType, data: z.wrap(l.value.data) } }
			if (l instanceof xo) return { type: "tool_use", toolCallId: l.callId, name: l.name, parameters: l.input }
			if (l instanceof Pt) return { type: "text", value: l.value }
			if (typeof l != "string") throw new Error("Unexpected chat message content type")
			return { type: "text", value: l }
		})
		return { role: r, name: i, content: a }
	}
	t.from = e
})((Mg ||= {}))
var xg
;((t) => {
	function o(n) {
		return { kind: "markdownContent", content: Se.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new _s(Se.to(n.content))
	}
	t.to = e
})((xg ||= {}))
var hx
;((t) => {
	function o(n) {
		return { kind: "codeblockUri", uri: n.value, isEdit: n.isEdit }
	}
	t.from = o
	function e(n) {
		return new As(b.revive(n.uri), n.isEdit)
	}
	t.to = e
})((hx ||= {}))
var vx
;((t) => {
	function o(n) {
		return { kind: "markdownVuln", content: Se.from(n.value), vulnerabilities: n.vulnerabilities }
	}
	t.from = o
	function e(n) {
		return new Di(Se.to(n.content), n.vulnerabilities)
	}
	t.to = e
})((vx ||= {}))
var bx
;((e) => {
	function o(t) {
		return { kind: "confirmation", title: t.title, message: t.message, data: t.data, buttons: t.buttons }
	}
	e.from = o
})((bx ||= {}))
var Cg
;((t) => {
	function o(n) {
		let { value: r, baseUri: i } = n
		function s(a, l) {
			return a.map((d) => {
				let c = b.joinPath(l, d.name)
				return { label: d.name, uri: c, children: d.children && s(d.children, c) }
			})
		}
		return { kind: "treeData", treeData: { label: Ht(i), uri: i, children: s(r, i) } }
	}
	t.from = o
	function e(n) {
		let r = ut(n.treeData)
		function i(l) {
			return l.map((d) => ({ name: d.label, children: d.children && i(d.children) }))
		}
		let s = r.uri,
			a = r.children ? i(r.children) : []
		return new ks(a, s)
	}
	t.to = e
})((Cg ||= {}))
var Xu
;((t) => {
	function o(n) {
		let r = (s) => b.isUri(s),
			i = (s) => "name" in s
		return {
			kind: "inlineReference",
			name: n.title,
			inlineReference: r(n.value) ? n.value : i(n.value) ? nl.from(n.value) : tl.from(n.value),
		}
	}
	t.from = o
	function e(n) {
		let r = ut(n)
		return new ki(
			b.isUri(r.inlineReference)
				? r.inlineReference
				: "location" in r.inlineReference
					? nl.to(r.inlineReference)
					: tl.to(r.inlineReference),
			n.name,
		)
	}
	t.to = e
})((Xu ||= {}))
var Fg
;((t) => {
	function o(n) {
		return { kind: "progressMessage", content: Se.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new Cd(n.content.value)
	}
	t.to = e
})((Fg ||= {}))
var Ng
;((t) => {
	function o(n) {
		return { kind: "warning", content: Se.from(n.value) }
	}
	t.from = o
	function e(n) {
		return new Ri(n.content.value)
	}
	t.to = e
})((Ng ||= {}))
var HF
;((t) => {
	function o(n) {
		return { kind: "move", uri: n.uri, range: H.from(n.range) }
	}
	t.from = o
	function e(n) {
		return new Ls(b.revive(n.uri), H.to(n.range))
	}
	t.to = e
})((HF ||= {}))
var yx
;((e) => {
	function o(t) {
		return { kind: "progressTask", content: Se.from(t.value) }
	}
	e.from = o
})((yx ||= {}))
var ik
;((e) => {
	function o(t) {
		return { kind: "progressTaskResult", content: typeof t == "string" ? Se.from(t) : void 0 }
	}
	e.from = o
})((ik ||= {}))
var Sg
;((t) => {
	function o(n, r, i) {
		return {
			kind: "command",
			command: r.toInternal(n.value, i) ?? { command: n.value.command, title: n.value.title },
		}
	}
	t.from = o
	function e(n, r) {
		return new Rs(r.fromInternal(n.command) ?? { command: n.command.id, title: n.command.title })
	}
	t.to = e
})((Sg ||= {}))
var Ix
;((t) => {
	function o(n) {
		return { kind: "textEdit", uri: n.uri, edits: n.edits.map((r) => on.from(r)), done: n.isDone }
	}
	t.from = o
	function e(n) {
		let r = new Ai(
			b.revive(n.uri),
			n.edits.map((i) => on.to(i)),
		)
		return (r.isDone = n.done), r
	}
	t.to = e
})((Ix ||= {}))
var xx
;((e) => {
	function o(t) {
		return t.newCellMetadata
			? { editType: 3, index: t.range.start, metadata: t.newCellMetadata }
			: t.newNotebookMetadata
				? { editType: 5, metadata: t.newNotebookMetadata }
				: {
						editType: 1,
						index: t.range.start,
						count: t.range.end - t.range.start,
						cells: t.newCells.map(yg.from),
					}
	}
	e.from = o
})((xx ||= {}))
var Cx
;((e) => {
	function o(t) {
		return { kind: "notebookEdit", uri: t.uri, edits: t.edits.map(xx.from), done: t.isDone }
	}
	e.from = o
})((Cx ||= {}))
var kd
;((t) => {
	function o(n) {
		let r = Yt.isThemeIcon(n.iconPath)
			? n.iconPath
			: b.isUri(n.iconPath)
				? { light: b.revive(n.iconPath) }
				: n.iconPath &&
					  "light" in n.iconPath &&
					  "dark" in n.iconPath &&
					  b.isUri(n.iconPath.light) &&
					  b.isUri(n.iconPath.dark)
					? { light: b.revive(n.iconPath.light), dark: b.revive(n.iconPath.dark) }
					: void 0
		return typeof n.value == "object" && "variableName" in n.value
			? {
					kind: "reference",
					reference: {
						variableName: n.value.variableName,
						value: b.isUri(n.value.value) || !n.value.value ? n.value.value : tl.from(n.value.value),
					},
					iconPath: r,
					options: n.options,
				}
			: {
					kind: "reference",
					reference: b.isUri(n.value) || typeof n.value == "string" ? n.value : tl.from(n.value),
					iconPath: r,
					options: n.options,
				}
	}
	t.from = o
	function e(n) {
		let r = ut(n),
			i = (s) => (b.isUri(s) ? s : tl.to(s))
		return new Io(
			typeof r.reference == "string"
				? r.reference
				: "variableName" in r.reference
					? { variableName: r.reference.variableName, value: r.reference.value && i(r.reference.value) }
					: i(r.reference),
		)
	}
	t.to = e
})((kd ||= {}))
var Sx
;((e) => {
	function o(t) {
		return { kind: "codeCitation", value: t.value, license: t.license, snippet: t.snippet }
	}
	e.from = o
})((Sx ||= {}))
var Tx
;((n) => {
	function o(r, i, s) {
		return r instanceof _s
			? xg.from(r)
			: r instanceof ki
				? Xu.from(r)
				: r instanceof Io
					? kd.from(r)
					: r instanceof Cd
						? Fg.from(r)
						: r instanceof ks
							? Cg.from(r)
							: r instanceof Rs
								? Sg.from(r, i, s)
								: r instanceof Ai
									? Ix.from(r)
									: r instanceof Ms
										? Cx.from(r)
										: r instanceof Di
											? vx.from(r)
											: r instanceof As
												? hx.from(r)
												: r instanceof Ri
													? Ng.from(r)
													: r instanceof Ds
														? bx.from(r)
														: r instanceof Os
															? Sx.from(r)
															: r instanceof Ls
																? HF.from(r)
																: { kind: "markdownContent", content: Se.from("") }
	}
	n.from = o
	function e(r, i) {
		switch (r.kind) {
			case "reference":
				return kd.to(r)
			case "markdownContent":
			case "inlineReference":
			case "progressMessage":
			case "treeData":
			case "command":
				return t(r, i)
		}
	}
	n.to = e
	function t(r, i) {
		switch (r.kind) {
			case "markdownContent":
				return xg.to(r)
			case "inlineReference":
				return Xu.to(r)
			case "progressMessage":
				return
			case "treeData":
				return Cg.to(r)
			case "command":
				return Sg.to(r, i)
		}
	}
	n.toContent = t
})((Tx ||= {}))
var Ex
;((e) => {
	function o(t, n, r, i, s) {
		let a = t.variables.variables.filter((c) => c.isTool),
			l = t.variables.variables.filter((c) => !c.isTool),
			d = {
				prompt: t.message,
				command: t.command,
				attempt: t.attempt ?? 0,
				enableCommandDetection: t.enableCommandDetection ?? !0,
				isParticipantDetected: t.isParticipantDetected ?? !1,
				references: l.map((c) => wx.to(c, i)),
				toolReferences: a.map(Px.to),
				location: Ug.to(t.location),
				acceptedConfirmationData: t.acceptedConfirmationData,
				rejectedConfirmationData: t.rejectedConfirmationData,
				location2: n,
				toolInvocationToken: Object.freeze({ sessionId: t.sessionId }),
				tools: s,
				model: r,
			}
		return t.requestId ? { ...d, id: t.requestId } : d
	}
	e.to = o
})((Ex ||= {}))
var sk
;((e) => {
	function o(t) {
		return { prompt: t.prompt, files: t.files.map((n) => b.revive(n)) }
	}
	e.to = o
})((sk ||= {}))
var Ug
;((t) => {
	function o(n) {
		switch (n) {
			case "notebook":
				return 3
			case "terminal":
				return 2
			case "panel":
				return 1
			case "editor":
				return 4
		}
	}
	t.to = o
	function e(n) {
		switch (n) {
			case 3:
				return "notebook"
			case 2:
				return "terminal"
			case 1:
				return "panel"
			case 4:
				return "editor"
		}
	}
	t.from = e
})((Ug ||= {}))
var wx
;((e) => {
	function o(t, n) {
		let r = t.value
		if (!r) throw new Error("Invalid value reference")
		if (yf(r)) r = b.revive(r)
		else if (r && typeof r == "object" && "uri" in r && "range" in r && yf(r.uri)) r = tl.to(ut(r))
		else if (pF(t)) {
			let i = t.references?.[0]?.reference
			r = new zu(
				t.mimeType ?? "image/png",
				() => Promise.resolve(new Uint8Array(Object.values(t.value))),
				i && b.isUri(i) ? i : void 0,
			)
		} else if (t.kind === "diagnostic") {
			let i = t.filterSeverity && ux.to(t.filterSeverity),
				s = t.filterUri && b.revive(t.filterUri).toString()
			r = new qu(
				n
					.map(([a, l]) =>
						t.filterUri && a.toString() !== s
							? [a, []]
							: [
									a,
									l.filter(
										(d) =>
											!(
												(i && d.severity > i) ||
												(t.filterRange &&
													!Re.areIntersectingOrTouching(t.filterRange, H.from(d.range)))
											),
									),
								],
					)
					.filter(([, a]) => a.length > 0),
			)
		}
		return {
			id: t.id,
			name: t.name,
			range: t.range && [t.range.start, t.range.endExclusive],
			value: r,
			modelDescription: t.modelDescription,
		}
	}
	e.to = o
})((wx ||= {}))
var Px
;((e) => {
	function o(t) {
		if (t.value) throw new Error("Invalid tool reference")
		return { name: t.id, range: t.range && [t.range.start, t.range.endExclusive] }
	}
	e.to = o
})((Px ||= {}))
var ak
;((e) => {
	function o(t, n, r) {
		return {
			id: t.id,
			label: t.label,
			fullName: t.fullName,
			icon: t.icon?.id,
			value: t.values[0].value,
			insertText: t.insertText,
			detail: t.detail,
			documentation: t.documentation,
			command: n.toInternal(t.command, r),
		}
	}
	e.from = o
})((ak ||= {}))
var rp
;((n) => {
	function o(r) {
		return { errorDetails: r.errorDetails, metadata: t(r.metadata), nextQuestion: r.nextQuestion }
	}
	n.to = o
	function e(r) {
		return { errorDetails: r.errorDetails, metadata: r.metadata, nextQuestion: r.nextQuestion }
	}
	n.from = e
	function t(r) {
		return os(r, (i) => {
			if (i.$mid === 20) return new el(os(i.content, t))
			if (i.$mid === 21) return new Pt(i.value)
			if (i.$mid === 22) return new Co(i.value)
		})
	}
})((rp ||= {}))
var lk
;((e) => {
	function o(t, n, r) {
		if (n.action.kind === "vote") return
		let i = rp.to(t)
		if (n.action.kind === "command") {
			let s = n.action.commandButton.command
			return {
				action: {
					kind: "command",
					commandButton: { command: r.fromInternal(s) ?? { command: s.id, title: s.title } },
				},
				result: i,
			}
		} else
			return n.action.kind === "followUp"
				? { action: { kind: "followUp", followup: Lg.to(n.action.followup) }, result: i }
				: n.action.kind === "inlineChat"
					? { action: { kind: "editor", accepted: n.action.action === "accepted" }, result: i }
					: n.action.kind === "chatEditingSessionAction"
						? {
								action: {
									kind: "chatEditingSessionAction",
									outcome:
										new Map([
											["accepted", 1],
											["rejected", 2],
											["saved", 3],
										]).get(n.action.outcome) ?? 2,
									uri: b.revive(n.action.uri),
									hasRemainingEdits: n.action.hasRemainingEdits,
								},
								result: i,
							}
						: { action: n.action, result: i }
	}
	e.to = o
})((lk ||= {}))
var _x
;((e) => {
	function o(t, n, r) {
		return "terminalCommand" in t
			? { terminalCommand: t.terminalCommand, shouldExecute: t.shouldExecute }
			: "uri" in t
				? { uri: t.uri }
				: n.toInternal(t, r)
	}
	e.from = o
})((_x ||= {}))
var ND
;((e) => {
	function o(t) {
		return { ...t, documentation: Se.fromStrict(t.documentation) }
	}
	e.from = o
})((ND ||= {}))
var dk
;((e) => {
	function o(t) {
		return Array.isArray(t)
			? { items: t.map((n) => ND.from(n)) }
			: {
					items: t.items.map((n) => ND.from(n)),
					resourceRequestConfig: t.resourceRequestConfig ? WF.from(t.resourceRequestConfig) : void 0,
				}
	}
	e.from = o
})((dk ||= {}))
var WF
;((e) => {
	function o(t) {
		return { ...t, pathSeparator: Ie ? "\\" : "/", cwd: t.cwd ? b.revive(t.cwd) : void 0 }
	}
	e.from = o
})((WF ||= {}))
var ck
;((e) => {
	function o(t) {
		return { kind: VF.to(t.kind), acceptedLength: t.acceptedLength }
	}
	e.to = o
})((ck ||= {}))
var VF
;((e) => {
	function o(t) {
		switch (t) {
			case 0:
				return 1
			case 1:
				return 2
			case 2:
				return 3
			default:
				return 0
		}
	}
	e.to = o
})((VF ||= {}))
var uk
;((e) => {
	function o(t, n) {
		return {
			id: n,
			label: t.label,
			description: t.description,
			canEdit: t.canEdit,
			collapsibleState: t.collapsibleState || 0,
			contextValue: t.contextValue,
		}
	}
	e.from = o
})((uk ||= {}))
var pk
;((e) => {
	function o(t) {
		return { name: t.id, description: t.modelDescription, inputSchema: t.inputSchema, tags: t.tags ?? [] }
	}
	e.to = o
})((pk ||= {}))
var Dx
;((t) => {
	function o(n) {
		return new el(n.content.map((r) => (r.kind === "text" ? new Pt(r.value) : new Co(r.value))))
	}
	t.to = o
	function e(n, r) {
		return (
			n.toolResultMessage && F(r, "chatParticipantPrivate"),
			{
				content: n.content.map((i) => {
					if (i instanceof Pt) return { kind: "text", value: i.value }
					if (i instanceof Co) return { kind: "promptTsx", value: i.value }
					throw new Error("Unknown LanguageModelToolResult part type")
				}),
				toolResultMessage: Se.fromStrict(n.toolResultMessage),
				toolResultDetails: n.toolResultDetails?.map((i) => (b.isUri(i) ? i : tl.from(i))),
			}
		)
	}
	t.from = e
})((Dx ||= {}))
var mk
;((e) => {
	function o(t) {
		return t
	}
	e.fromThemeIcon = o
})((mk ||= {}))
var kx = class o {
		constructor(e, t) {
			this.line = e
			this.character = t
		}
		isBefore(e) {
			return !1
		}
		isBeforeOrEqual(e) {
			return !1
		}
		isAfter(e) {
			return !1
		}
		isAfterOrEqual(e) {
			return !1
		}
		isEqual(e) {
			return !1
		}
		compareTo(e) {
			return 0
		}
		translate(e, t) {
			return new o(0, 0)
		}
		with(e) {
			return new o(0, 0)
		}
	},
	op = class o {
		constructor(e, t, n, r) {
			this.isEmpty = !1
			this.isSingleLine = !1
			;(this.start = new kx(e, t)), (this.end = new kx(n, r))
		}
		contains(e) {
			return !1
		}
		isEqual(e) {
			return !1
		}
		intersection(e) {}
		union(e) {
			return new o(0, 0, 0, 0)
		}
		with(e) {
			return new o(0, 0, 0, 0)
		}
	},
	ur = class {
		constructor(e, t, n) {
			this.uri = e
			this.ranges = t
			this.previewText = n
		}
	},
	Li = class {
		constructor(e, t, n) {
			this.uri = e
			this.text = t
			this.lineNumber = n
		}
	},
	Rx = ((n) => (
		(n[(n.None = 1)] = "None"),
		(n[(n.FilesExclude = 2)] = "FilesExclude"),
		(n[(n.SearchAndFilesExclude = 3)] = "SearchAndFilesExclude"),
		n
	))(Rx || {}),
	Hg = ((t) => ((t[(t.Information = 1)] = "Information"), (t[(t.Warning = 2)] = "Warning"), t))(Hg || {})
var ol = 2e4,
	BF = "\u27EA ",
	$F = " characters skipped \u27EB",
	$7 = (BF.length + $F.length + 5) * 2,
	z7 = O("searchService")
function Wg(o) {
	return !!o.rangeLocations && !!o.previewText
}
var ip = class {
	constructor(e, t, n, r) {
		this.rangeLocations = []
		this.webviewIndex = r
		let i = Array.isArray(t) ? t : [t]
		if (n && n.matchLines === 1 && q7(i)) {
			e = tO(e, n.matchLines)
			let s = "",
				a = 0,
				l = 0,
				d = Math.floor(n.charsPerLine / 5)
			for (let c of i) {
				let u = Math.max(c.startColumn - d, 0),
					m = c.startColumn + n.charsPerLine
				if (u > l + d + $7) {
					let f = BF + (u - l) + $F
					;(s += f + e.slice(u, m)), (a += u - (l + f.length))
				} else s += e.slice(l, m)
				;(l = m),
					this.rangeLocations.push({ source: c, preview: new fk(0, c.startColumn - a, c.endColumn - a) })
			}
			this.previewText = s
		} else {
			let s = Array.isArray(t) ? t[0].startLineNumber : t.startLineNumber,
				a = Rl(t, (l) => ({
					preview: new sp(l.startLineNumber - s, l.startColumn, l.endLineNumber - s, l.endColumn),
					source: l,
				}))
			;(this.rangeLocations = Array.isArray(a) ? a : [a]), (this.previewText = e)
		}
	}
}
function q7(o) {
	let e = o[0].startLineNumber
	for (let t of o) if (t.startLineNumber !== e || t.endLineNumber !== e) return !1
	return !0
}
var sp = class {
		constructor(e, t, n, r) {
			;(this.startLineNumber = e), (this.startColumn = t), (this.endLineNumber = n), (this.endColumn = r)
		}
	},
	fk = class extends sp {
		constructor(e, t, n) {
			super(e, t, e, n)
		}
	}
function zF(o, e = !0) {
	let t = o && o.files && o.files.exclude,
		n = e && o && o.search && o.search.exclude
	if (!t && !n) return
	if (!t || !n) return t || n || void 0
	let r = Object.create(null)
	return (r = gr(r, je(t))), (r = gr(r, je(n), !0)), r
}
function gk(o, e) {
	return o.excludePattern && yi(o.excludePattern, e)
		? !1
		: o.includePattern || o.usingSearchPaths
			? o.includePattern && yi(o.includePattern, e)
				? !0
				: o.usingSearchPaths
					? !!o.folderQueries &&
						o.folderQueries.some((t) => {
							let n = t.folder.fsPath
							if (Kr(e, n)) {
								let r = Mo(n, e)
								return !t.includePattern || !!yi(t.includePattern, r)
							} else return !1
						})
					: !1
			: !0
}
var Mi = class extends Error {
	constructor(t, n) {
		super(t)
		this.code = n
	}
}
function hk(o) {
	let e = { message: o.message, code: o.code }
	return new Error(JSON.stringify(e))
}
function qF(o) {
	return !!o.path
}
function Vg(o, e, t = !0) {
	let n = o.searchPath ? o.searchPath : o.relativePath
	return t ? ZA(n, e) : yi(e, n)
}
function il(o, e) {
	let t = { ...(o || {}), ...(e || {}) }
	return Object.keys(t).filter((n) => {
		let r = t[n]
		return typeof r == "boolean" && r
	})
}
var ap = class {
	constructor(e, t) {
		this._parsedIncludeExpression = null
		;(this._excludeExpression =
			t.excludePattern?.map((r) => ({ ...(e.excludePattern || {}), ...(r.pattern || {}) })) ?? []),
			this._excludeExpression.length === 0 && (this._excludeExpression = [e.excludePattern || {}]),
			(this._parsedExcludeExpression = this._excludeExpression.map((r) => Yn(r)))
		let n = e.includePattern
		t.includePattern && (n ? (n = { ...n, ...t.includePattern }) : (n = t.includePattern)),
			n && (this._parsedIncludeExpression = Yn(n))
	}
	_evalParsedExcludeExpression(e, t, n) {
		let r = null
		for (let i of this._parsedExcludeExpression) {
			let s = i(e, t, n)
			if (typeof s == "string") {
				r = s
				break
			}
		}
		return r
	}
	matchesExcludesSync(e, t, n) {
		return !!(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, t, n))
	}
	includedInQuerySync(e, t, n) {
		return !(
			(this._parsedExcludeExpression && this._evalParsedExcludeExpression(e, t, n)) ||
			(this._parsedIncludeExpression && !this._parsedIncludeExpression(e, t, n))
		)
	}
	includedInQuery(e, t, n) {
		let r = () => (this._parsedIncludeExpression ? !!this._parsedIncludeExpression(e, t, n) : !0)
		return Promise.all(
			this._parsedExcludeExpression.map((i) => {
				let s = i(e, t, n)
				return ao(s) ? s.then((a) => (a ? !1 : r())) : r()
			}),
		).then((i) => i.some((s) => !!s))
	}
	hasSiblingExcludeClauses() {
		return this._excludeExpression.reduce((e, t) => K7(t) || e, !1)
	}
}
function K7(o) {
	for (let e in o) if (typeof o[e] != "boolean") return !0
	return !1
}
function KF(o) {
	if (!o) return
	let e
	return (t) => (e || (e = (o() || Promise.resolve([])).then((n) => (n ? jF(n) : {}))), e.then((n) => !!n[t]))
}
function Bg(o) {
	if (!o) return
	let e
	return (t) => {
		if (!e) {
			let n = o()
			e = n ? jF(n) : {}
		}
		return !!e[t]
	}
}
function jF(o) {
	let e = {}
	for (let t of o) e[t] = !0
	return e
}
function Ax(o) {
	return o.flatMap((e) => e.patterns.map((t) => (e.baseUri ? { baseUri: e.baseUri, pattern: t } : t)))
}
var $g = { matchLines: 100, charsPerLine: 1e4 }
var j7 = !1,
	bk = class {
		constructor(e, t, n) {
			this.id = e
			this.dependencies = t
			this.callback = n
		}
	}
var yk = class o {
		constructor() {
			this._isWebWorker =
				typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope"
			this._isRenderer = typeof document == "object"
			this._defineCalls = []
			this._state = 1
		}
		static {
			this.INSTANCE = new o()
		}
		_initialize() {
			if (this._state === 1) {
				if (globalThis.define) {
					this._state = 3
					return
				}
			} else return
			;(this._state = 2),
				(globalThis.define = (e, t, n) => {
					typeof e != "string" && ((n = t), (t = e), (e = null)),
						(typeof t != "object" || !Array.isArray(t)) && ((n = t), (t = null)),
						this._defineCalls.push(new bk(e, t, n))
				}),
				(globalThis.define.amd = !0),
				this._isRenderer
					? (this._amdPolicy =
							globalThis._VSCODE_WEB_PACKAGE_TTP ??
							window.trustedTypes?.createPolicy("amdLoader", {
								createScriptURL(e) {
									if (
										e.startsWith(window.location.origin) ||
										e.startsWith(`${W.vscodeFileResource}://${VE}`)
									)
										return e
									throw new Error(`[trusted_script_src] Invalid script url: ${e}`)
								},
							}))
					: this._isWebWorker &&
						(this._amdPolicy =
							globalThis._VSCODE_WEB_PACKAGE_TTP ??
							globalThis.trustedTypes?.createPolicy("amdLoader", {
								createScriptURL(e) {
									return e
								},
							}))
		}
		async load(e) {
			if ((this._initialize(), this._state === 3))
				return new Promise((s) => {
					let a = He()
					globalThis.define(a, [e], function (l) {
						s(l)
					})
				})
			let t = await (this._isWebWorker
				? this._workerLoadScript(e)
				: this._isRenderer
					? this._rendererLoadScript(e)
					: this._nodeJSLoadScript(e))
			if (!t) {
				console.warn(`Did not receive a define call from script ${e}`)
				return
			}
			let n = {},
				r = [],
				i = []
			if (Array.isArray(t.dependencies)) for (let s of t.dependencies) s === "exports" ? r.push(n) : i.push(s)
			if (i.length > 0)
				throw new Error(`Cannot resolve dependencies for script ${e}. The dependencies are: ${i.join(", ")}`)
			return typeof t.callback == "function" ? (t.callback(...r) ?? n) : t.callback
		}
		_rendererLoadScript(e) {
			return new Promise((t, n) => {
				let r = document.createElement("script")
				r.setAttribute("async", "async"), r.setAttribute("type", "text/javascript")
				let i = () => {
						r.removeEventListener("load", s), r.removeEventListener("error", a)
					},
					s = (l) => {
						i(), t(this._defineCalls.pop())
					},
					a = (l) => {
						i(), n(l)
					}
				r.addEventListener("load", s),
					r.addEventListener("error", a),
					this._amdPolicy && (e = this._amdPolicy.createScriptURL(e)),
					r.setAttribute("src", e),
					window.document.getElementsByTagName("head")[0].appendChild(r)
			})
		}
		async _workerLoadScript(e) {
			return this._amdPolicy && (e = this._amdPolicy.createScriptURL(e)), await import(e), this._defineCalls.pop()
		}
		async _nodeJSLoadScript(e) {
			try {
				let t = (await import("fs")).default,
					n = (await import("vm")).default,
					r = (await import("module")).default,
					i = b.parse(e).fsPath,
					s = t.readFileSync(i).toString(),
					a = r.wrap(s.replace(/^#!.*/, ""))
				return new n.Script(a).runInThisContext().apply(), this._defineCalls.pop()
			} catch (t) {
				throw t
			}
		}
	},
	vk = new Map()
async function lp(o, e, t) {
	t === void 0 &&
		(t = !!(globalThis._VSCODE_PRODUCT_JSON ?? globalThis.vscode?.context?.configuration()?.product)?.commit)
	let n = e ? `${o}/${e}` : o
	if (vk.has(n)) return vk.get(n)
	let r
	if (/^\w[\w\d+.-]*:\/\//.test(n)) r = n
	else {
		let l = `${j7 && t && !Oo ? fO : mO}/${n}`
		r = Ec.asBrowserUri(l).toString(!0)
	}
	let i = yk.INSTANCE.load(r)
	return vk.set(n, i), i
}
var qg = "utf8",
	Tk = "utf8bom",
	Lx = "utf16be",
	Mx = "utf16le"
var Ox = [254, 255],
	xk = [255, 254],
	zg = [239, 187, 191],
	G7 = 512,
	Q7 = 512,
	J7 = 512 * 8,
	X7 = 512 * 128
var Ck = class extends Error {
		constructor(t, n) {
			super(t)
			this.decodeStreamErrorKind = n
		}
	},
	Sk = class o {
		constructor(e) {
			this.iconvLiteDecoder = e
		}
		static async create(e) {
			let t
			if (e !== qg) t = (await lp("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js")).getDecoder(JF(e))
			else {
				let n = new TextDecoder()
				t = {
					write(r) {
						return n.decode(r, { stream: !0 })
					},
					end() {
						return n.decode()
					},
				}
			}
			return new o(t)
		}
		write(e) {
			return this.iconvLiteDecoder.write(e)
		}
		end() {
			return this.iconvLiteDecoder.end()
		}
	}
function GF(o, e) {
	let t = (e.minBytesRequiredForDetection ?? e.guessEncoding) ? J7 : Q7
	return new Promise((n, r) => {
		let i = Al((u) => u.join("")),
			s = [],
			a = 0,
			l,
			d = new _e(),
			c = async () => {
				try {
					let u = await i8({ buffer: z.concat(s), bytesRead: a }, e.guessEncoding, e.candidateGuessEncodings)
					if (u.seemsBinary && e.acceptTextOnly)
						throw new Ck("Stream is binary but only text is accepted for decoding", 1)
					;(u.encoding = await e.overwriteEncoding(u.encoding)), (l = await Sk.create(u.encoding))
					let m = l.write(z.concat(s).buffer)
					i.write(m), (s.length = 0), (a = 0), n({ stream: i, detected: u })
				} catch (u) {
					d.cancel(), i.destroy(), r(u)
				}
			}
		hv(
			o,
			{
				onData: async (u) => {
					l
						? i.write(l.write(u.buffer))
						: (s.push(u),
							(a += u.byteLength),
							a >= t && (o.pause(), await c(), setTimeout(() => o.resume())))
				},
				onError: (u) => i.error(u),
				onEnd: async () => {
					l || (await c()), i.end(l?.end())
				},
			},
			d.token,
		)
	})
}
async function QF(o, e, t) {
	let r = (await lp("@vscode/iconv-lite-umd", "lib/iconv-lite-umd.js")).getEncoder(JF(e), t),
		i = !1,
		s = !1
	return {
		read() {
			if (s) return null
			let a = o.read()
			if (typeof a != "string") {
				if (((s = !0), !i && t?.addBOM))
					switch (e) {
						case qg:
						case Tk:
							return z.wrap(Uint8Array.from(zg))
						case Lx:
							return z.wrap(Uint8Array.from(Ox))
						case Mx:
							return z.wrap(Uint8Array.from(xk))
					}
				let l = r.end()
				return l && l.length > 0 ? ((i = !0), z.wrap(l)) : null
			}
			return (i = !0), z.wrap(r.write(a))
		},
	}
}
function JF(o) {
	return o === Tk || o === null ? qg : o
}
function Y7(o, e) {
	if (!o || e < Ox.length) return null
	let t = o.readUInt8(0),
		n = o.readUInt8(1)
	if (t === Ox[0] && n === Ox[1]) return Lx
	if (t === xk[0] && n === xk[1]) return Mx
	if (e < zg.length) return null
	let r = o.readUInt8(2)
	return t === zg[0] && n === zg[1] && r === zg[2] ? Tk : null
}
var Z7 = ["ascii", "utf-16", "utf-32"]
async function e8(o, e) {
	let t = await lp("jschardet", "dist/jschardet.min.js"),
		n = o.slice(0, X7),
		r = o8(n.buffer)
	e && ((e = Ye(e.map((a) => r8(a)))), e.length === 0 && (e = void 0))
	let i
	try {
		i = t.detect(r, e ? { detectEncodings: e } : void 0)
	} catch {
		return null
	}
	if (!i || !i.encoding) return null
	let s = i.encoding.toLowerCase()
	return 0 <= Z7.indexOf(s) ? null : n8(i.encoding)
}
var t8 = { ibm866: "cp866", big5: "cp950" }
function XF(o) {
	return o.replace(/[^a-zA-Z0-9]/g, "").toLowerCase()
}
function n8(o) {
	let e = XF(o)
	return t8[e] || e
}
function r8(o) {
	let e = XF(o),
		t = s8[e]
	return t ? t.guessableName : void 0
}
function o8(o) {
	let e = ""
	for (let t = 0; t < o.length; t++) e += String.fromCharCode(o[t])
	return e
}
function YF(o) {
	switch (o) {
		case "shiftjis":
			return "shift-jis"
		case "utf16le":
			return "utf-16le"
		case "utf16be":
			return "utf-16be"
		case "big5hkscs":
			return "big5-hkscs"
		case "eucjp":
			return "euc-jp"
		case "euckr":
			return "euc-kr"
		case "koi8r":
			return "koi8-r"
		case "koi8u":
			return "koi8-u"
		case "macroman":
			return "x-mac-roman"
		case "utf8bom":
			return "utf8"
		default: {
			let e = o.match(/windows(\d+)/)
			return e ? "windows-" + e[1] : o
		}
	}
}
function i8({ buffer: o, bytesRead: e }, t, n) {
	let r = Y7(o, e),
		i = !1
	if (r !== Lx && r !== Mx && o) {
		let s = !0,
			a = !0,
			l = !1
		for (let d = 0; d < e && d < G7; d++) {
			let c = d % 2 === 1,
				u = o.readUInt8(d) === 0
			if (
				(u && (l = !0),
				s && ((c && !u) || (!c && u)) && (s = !1),
				a && ((c && u) || (!c && !u)) && (a = !1),
				u && !s && !a)
			)
				break
		}
		l && (s ? (r = Mx) : a ? (r = Lx) : (i = !0))
	}
	return t && !i && !r && o
		? e8(o.slice(0, e), n).then((s) => ({ seemsBinary: !1, encoding: s }))
		: { seemsBinary: i, encoding: r }
}
var Ik = {
		utf8: { labelLong: "UTF-8", labelShort: "UTF-8", order: 1, alias: "utf8bom", guessableName: "UTF-8" },
		utf8bom: { labelLong: "UTF-8 with BOM", labelShort: "UTF-8 with BOM", encodeOnly: !0, order: 2, alias: "utf8" },
		utf16le: { labelLong: "UTF-16 LE", labelShort: "UTF-16 LE", order: 3, guessableName: "UTF-16LE" },
		utf16be: { labelLong: "UTF-16 BE", labelShort: "UTF-16 BE", order: 4, guessableName: "UTF-16BE" },
		windows1252: {
			labelLong: "Western (Windows 1252)",
			labelShort: "Windows 1252",
			order: 5,
			guessableName: "windows-1252",
		},
		iso88591: { labelLong: "Western (ISO 8859-1)", labelShort: "ISO 8859-1", order: 6 },
		iso88593: { labelLong: "Western (ISO 8859-3)", labelShort: "ISO 8859-3", order: 7 },
		iso885915: { labelLong: "Western (ISO 8859-15)", labelShort: "ISO 8859-15", order: 8 },
		macroman: { labelLong: "Western (Mac Roman)", labelShort: "Mac Roman", order: 9 },
		cp437: { labelLong: "DOS (CP 437)", labelShort: "CP437", order: 10 },
		windows1256: { labelLong: "Arabic (Windows 1256)", labelShort: "Windows 1256", order: 11 },
		iso88596: { labelLong: "Arabic (ISO 8859-6)", labelShort: "ISO 8859-6", order: 12 },
		windows1257: { labelLong: "Baltic (Windows 1257)", labelShort: "Windows 1257", order: 13 },
		iso88594: { labelLong: "Baltic (ISO 8859-4)", labelShort: "ISO 8859-4", order: 14 },
		iso885914: { labelLong: "Celtic (ISO 8859-14)", labelShort: "ISO 8859-14", order: 15 },
		windows1250: {
			labelLong: "Central European (Windows 1250)",
			labelShort: "Windows 1250",
			order: 16,
			guessableName: "windows-1250",
		},
		iso88592: {
			labelLong: "Central European (ISO 8859-2)",
			labelShort: "ISO 8859-2",
			order: 17,
			guessableName: "ISO-8859-2",
		},
		cp852: { labelLong: "Central European (CP 852)", labelShort: "CP 852", order: 18 },
		windows1251: {
			labelLong: "Cyrillic (Windows 1251)",
			labelShort: "Windows 1251",
			order: 19,
			guessableName: "windows-1251",
		},
		cp866: { labelLong: "Cyrillic (CP 866)", labelShort: "CP 866", order: 20, guessableName: "IBM866" },
		cp1125: { labelLong: "Cyrillic (CP 1125)", labelShort: "CP 1125", order: 21, guessableName: "IBM1125" },
		iso88595: {
			labelLong: "Cyrillic (ISO 8859-5)",
			labelShort: "ISO 8859-5",
			order: 22,
			guessableName: "ISO-8859-5",
		},
		koi8r: { labelLong: "Cyrillic (KOI8-R)", labelShort: "KOI8-R", order: 23, guessableName: "KOI8-R" },
		koi8u: { labelLong: "Cyrillic (KOI8-U)", labelShort: "KOI8-U", order: 24 },
		iso885913: { labelLong: "Estonian (ISO 8859-13)", labelShort: "ISO 8859-13", order: 25 },
		windows1253: {
			labelLong: "Greek (Windows 1253)",
			labelShort: "Windows 1253",
			order: 26,
			guessableName: "windows-1253",
		},
		iso88597: { labelLong: "Greek (ISO 8859-7)", labelShort: "ISO 8859-7", order: 27, guessableName: "ISO-8859-7" },
		windows1255: {
			labelLong: "Hebrew (Windows 1255)",
			labelShort: "Windows 1255",
			order: 28,
			guessableName: "windows-1255",
		},
		iso88598: {
			labelLong: "Hebrew (ISO 8859-8)",
			labelShort: "ISO 8859-8",
			order: 29,
			guessableName: "ISO-8859-8",
		},
		iso885910: { labelLong: "Nordic (ISO 8859-10)", labelShort: "ISO 8859-10", order: 30 },
		iso885916: { labelLong: "Romanian (ISO 8859-16)", labelShort: "ISO 8859-16", order: 31 },
		windows1254: { labelLong: "Turkish (Windows 1254)", labelShort: "Windows 1254", order: 32 },
		iso88599: { labelLong: "Turkish (ISO 8859-9)", labelShort: "ISO 8859-9", order: 33 },
		windows1258: { labelLong: "Vietnamese (Windows 1258)", labelShort: "Windows 1258", order: 34 },
		gbk: { labelLong: "Simplified Chinese (GBK)", labelShort: "GBK", order: 35 },
		gb18030: { labelLong: "Simplified Chinese (GB18030)", labelShort: "GB18030", order: 36 },
		cp950: { labelLong: "Traditional Chinese (Big5)", labelShort: "Big5", order: 37, guessableName: "Big5" },
		big5hkscs: { labelLong: "Traditional Chinese (Big5-HKSCS)", labelShort: "Big5-HKSCS", order: 38 },
		shiftjis: { labelLong: "Japanese (Shift JIS)", labelShort: "Shift JIS", order: 39, guessableName: "SHIFT_JIS" },
		eucjp: { labelLong: "Japanese (EUC-JP)", labelShort: "EUC-JP", order: 40, guessableName: "EUC-JP" },
		euckr: { labelLong: "Korean (EUC-KR)", labelShort: "EUC-KR", order: 41, guessableName: "EUC-KR" },
		windows874: { labelLong: "Thai (Windows 874)", labelShort: "Windows 874", order: 42 },
		iso885911: { labelLong: "Latin/Thai (ISO 8859-11)", labelShort: "ISO 8859-11", order: 43 },
		koi8ru: { labelLong: "Cyrillic (KOI8-RU)", labelShort: "KOI8-RU", order: 44 },
		koi8t: { labelLong: "Tajik (KOI8-T)", labelShort: "KOI8-T", order: 45 },
		gb2312: {
			labelLong: "Simplified Chinese (GB 2312)",
			labelShort: "GB 2312",
			order: 46,
			guessableName: "GB2312",
		},
		cp865: { labelLong: "Nordic DOS (CP 865)", labelShort: "CP 865", order: 47 },
		cp850: { labelLong: "Western European DOS (CP 850)", labelShort: "CP 850", order: 48 },
	},
	s8 = (() => {
		let o = {}
		for (let e in Ik) Ik[e].guessableName && (o[e] = Ik[e])
		return o
	})()
var ZF = O("textFileService")
function e2(o) {
	let e = !1
	return {
		read() {
			return e ? null : ((e = !0), o)
		},
	}
}
function jg(o, e, t) {
	return new es((n) => Ek(n, t)).isEqual(o, e)
}
function a8(o, e, t) {
	return jg(o.uri, e.uri, t) ? 0 : Fo(o.uri.toString(), e.uri.toString())
}
function l8(o, e, t) {
	return o.index !== e.index
		? o.index < e.index
			? -1
			: 1
		: jg(o.uri, e.uri, t)
			? Fo(o.name, e.name)
			: Fo(o.uri.toString(), e.uri.toString())
}
function n2(o, e, t, n) {
	let r = o.slice(0).sort((s, a) => t(s, a, n)),
		i = e.slice(0).sort((s, a) => t(s, a, n))
	return G0(r, i, (s, a) => t(s, a, n))
}
function Ek(o, e) {
	let t = e.getCapabilities(o.scheme)
	return !(t && t & 1024)
}
var Kg = class o extends Pb {
		constructor(t, n, r, i, s, a, l) {
			super(
				t,
				r.map((d) => new Yl(d)),
				i,
				s,
				l,
			)
			this._name = n
			this._isUntitled = a
			this._workspaceFolders = []
			;(this._structure = vr.forUris(l, () => !0)),
				r.forEach((d) => {
					this._workspaceFolders.push(d), this._structure.set(d.uri, d)
				})
		}
		static toExtHostWorkspace(t, n, r, i) {
			if (!t) return { workspace: null, added: [], removed: [] }
			let { id: s, name: a, folders: l, configuration: d, transient: c, isUntitled: u } = t,
				m = [],
				f = n
			n
				? l.forEach((C, T) => {
						let w = b.revive(C.uri),
							L = o._findFolder(r || n, w, i)
						L
							? ((L.name = C.name), (L.index = C.index), m.push(L))
							: m.push({ uri: w, name: C.name, index: T })
					})
				: m.push(...l.map(({ uri: C, name: T, index: w }) => ({ uri: b.revive(C), name: T, index: w }))),
				m.sort((C, T) => (C.index < T.index ? -1 : 1))
			let h = new o(s, a, m, !!c, d ? b.revive(d) : null, !!u, (C) => Ek(C, i)),
				{ added: g, removed: I } = n2(f ? f.workspaceFolders : [], h.workspaceFolders, a8, i)
			return { workspace: h, added: g, removed: I }
		}
		static _findFolder(t, n, r) {
			for (let i = 0; i < t.folders.length; i++) {
				let s = t.workspaceFolders[i]
				if (jg(s.uri, n, r)) return s
			}
		}
		get name() {
			return this._name
		}
		get isUntitled() {
			return this._isUntitled
		}
		get workspaceFolders() {
			return this._workspaceFolders.slice(0)
		}
		getWorkspaceFolder(t, n) {
			return n && this._structure.get(t) && (t = ts(t)), this._structure.findSubstr(t)
		}
		resolveWorkspaceFolder(t) {
			return this._structure.get(t)
		}
	},
	dp = class {
		constructor(e, t, n, r, i) {
			this._onDidChangeWorkspace = new E()
			this.onDidChangeWorkspace = this._onDidChangeWorkspace.event
			this._onDidGrantWorkspaceTrust = new E()
			this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event
			this._activeSearchCallbacks = []
			this._trusted = !1
			this._editSessionIdentityProviders = new Map()
			this._providerHandlePool = 0
			this._onWillCreateEditSessionIdentityEvent = new di()
			this._canonicalUriProviders = new Map()
			;(this._logService = r),
				(this._extHostFileSystemInfo = n),
				(this._uriTransformerService = i),
				(this._requestIdProvider = new Cb()),
				(this._barrier = new dn()),
				(this._proxy = e.getProxy(M.MainThreadWorkspace)),
				(this._messageService = e.getProxy(M.MainThreadMessageService))
			let s = t.workspace
			this._confirmedWorkspace = s
				? new Kg(
						s.id,
						s.name,
						[],
						!!s.transient,
						s.configuration ? b.revive(s.configuration) : null,
						!!s.isUntitled,
						(a) => Ek(a, n),
					)
				: void 0
		}
		$initializeWorkspace(e, t) {
			console.log("initializeWorkspace", e, t),
				(this._trusted = t),
				this.$acceptWorkspaceData(e),
				this._barrier.open()
		}
		waitForInitializeCall() {
			return this._barrier.wait()
		}
		get workspace() {
			return this._actualWorkspace
		}
		get name() {
			return this._actualWorkspace ? this._actualWorkspace.name : void 0
		}
		get workspaceFile() {
			if (this._actualWorkspace && this._actualWorkspace.configuration)
				return this._actualWorkspace.isUntitled
					? b.from({ scheme: W.untitled, path: Ht(ts(this._actualWorkspace.configuration)) })
					: this._actualWorkspace.configuration
		}
		get _actualWorkspace() {
			return this._unconfirmedWorkspace || this._confirmedWorkspace
		}
		getWorkspaceFolders() {
			if (this._actualWorkspace) return this._actualWorkspace.workspaceFolders.slice(0)
		}
		async getWorkspaceFolders2() {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.workspaceFolders.slice(0)
		}
		updateWorkspaceFolders(e, t, n, ...r) {
			let i = []
			if (
				(Array.isArray(r) &&
					r.forEach((c) => {
						b.isUri(c.uri) &&
							!i.some((u) => jg(u.uri, c.uri, this._extHostFileSystemInfo)) &&
							i.push({ uri: c.uri, name: c.name || If(c.uri) })
					}),
				this._unconfirmedWorkspace ||
					[t, n].some((c) => typeof c != "number" || c < 0) ||
					(n === 0 && i.length === 0))
			)
				return !1
			let s = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : []
			if (t + n > s.length) return !1
			let a = s.slice(0)
			a.splice(t, n, ...i.map((c) => ({ uri: c.uri, name: c.name || If(c.uri), index: void 0 })))
			for (let c = 0; c < a.length; c++) {
				let u = a[c]
				if (a.some((m, f) => f !== c && jg(u.uri, m.uri, this._extHostFileSystemInfo))) return !1
			}
			a.forEach((c, u) => (c.index = u))
			let { added: l, removed: d } = n2(s, a, l8, this._extHostFileSystemInfo)
			if (l.length === 0 && d.length === 0) return !1
			if (this._proxy) {
				let c = e.displayName || e.name
				this._proxy.$updateWorkspaceFolders(c, t, n, i).then(void 0, (u) => {
					this._unconfirmedWorkspace = void 0
					let m = { source: { identifier: e.identifier, label: e.displayName || e.name } }
					this._messageService.$showMessage(
						yL.Error,
						p("updateerror", "Extension '{0}' failed to update workspace folders: {1}", c, u.toString()),
						m,
						[],
					)
				})
			}
			return this.trySetWorkspaceFolders(a), !0
		}
		getWorkspaceFolder(e, t) {
			if (this._actualWorkspace) return this._actualWorkspace.getWorkspaceFolder(e, t)
		}
		async getWorkspaceFolder2(e, t) {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.getWorkspaceFolder(e, t)
		}
		async resolveWorkspaceFolder(e) {
			if ((await this._barrier.wait(), !!this._actualWorkspace))
				return this._actualWorkspace.resolveWorkspaceFolder(e)
		}
		getPath() {
			if (!this._actualWorkspace) return
			let { folders: e } = this._actualWorkspace
			if (e.length !== 0) return e[0].uri.fsPath
		}
		getRelativePath(e, t) {
			let n,
				r = ""
			if ((typeof e == "string" ? ((n = b.file(e)), (r = e)) : typeof e < "u" && ((n = e), (r = e.fsPath)), !n))
				return r
			let i = this.getWorkspaceFolder(n, !0)
			if (!i) return r
			typeof t > "u" && this._actualWorkspace && (t = this._actualWorkspace.folders.length > 1)
			let s = xf(i.uri, n)
			return t && i.name && (s = `${i.name}/${s}`), s
		}
		trySetWorkspaceFolders(e) {
			this._actualWorkspace &&
				(this._unconfirmedWorkspace =
					Kg.toExtHostWorkspace(
						{
							id: this._actualWorkspace.id,
							name: this._actualWorkspace.name,
							configuration: this._actualWorkspace.configuration,
							folders: e,
							isUntitled: this._actualWorkspace.isUntitled,
						},
						this._actualWorkspace,
						void 0,
						this._extHostFileSystemInfo,
					).workspace || void 0)
		}
		$acceptWorkspaceData(e) {
			let {
				workspace: t,
				added: n,
				removed: r,
			} = Kg.toExtHostWorkspace(
				e,
				this._confirmedWorkspace,
				this._unconfirmedWorkspace,
				this._extHostFileSystemInfo,
			)
			;(this._confirmedWorkspace = t || void 0),
				(this._unconfirmedWorkspace = void 0),
				this._onDidChangeWorkspace.fire(Object.freeze({ added: n, removed: r }))
		}
		findFiles(e, t, n, r, i = De.None) {
			this._logService.trace(
				`extHostWorkspace#findFiles: fileSearch, extension: ${r.value}, entryPoint: findFiles`,
			)
			let s = "",
				a = !0
			return (
				t === null ? (a = !1) : t !== void 0 && (typeof t == "string" ? (s = t) : (s = t.pattern)),
				this._findFilesImpl(
					{ type: "include", value: e },
					{ exclude: [s], maxResults: n, useExcludeSettings: a ? 2 : 1, useIgnoreFiles: { local: !1 } },
					i,
				)
			)
		}
		findFiles2(e, t = {}, n, r = De.None) {
			return (
				this._logService.trace(
					`extHostWorkspace#findFiles2New: fileSearch, extension: ${n.value}, entryPoint: findFiles2New`,
				),
				this._findFilesImpl({ type: "filePatterns", value: e }, t, r)
			)
		}
		async _findFilesImpl(e, t, n) {
			if (n.isCancellationRequested) return Promise.resolve([])
			let r = e.type === "include" ? [e.value] : (e.value ?? [])
			if (!Array.isArray(r))
				throw (
					(console.error("Invalid file pattern provided", r),
					new Error(`Invalid file pattern provided ${JSON.stringify(r)}`))
				)
			let i = r.map((s) => {
				let a = t2(t.exclude),
					l = {
						ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
						disregardIgnoreFiles:
							typeof t.useIgnoreFiles?.local == "boolean" ? !t.useIgnoreFiles.local : void 0,
						disregardGlobalIgnoreFiles:
							typeof t.useIgnoreFiles?.global == "boolean" ? !t.useIgnoreFiles.global : void 0,
						disregardParentIgnoreFiles:
							typeof t.useIgnoreFiles?.parent == "boolean" ? !t.useIgnoreFiles.parent : void 0,
						disregardExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings === 1,
						disregardSearchExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings !== 3,
						maxResults: t.maxResults,
						excludePattern: a.length > 0 ? a : void 0,
						_reason: "startFileSearch",
						shouldGlobSearch: e.type === "include" ? void 0 : !0,
					},
					d = Fx(Ir.from(s)),
					c = d?.folder
				return (
					e.type === "include" ? (l.includePattern = d?.pattern) : (l.filePattern = d?.pattern),
					{ folder: c, options: l }
				)
			})
			return this._findFilesBase(i, n)
		}
		async _findFilesBase(e, t) {
			return (
				await Promise.all(
					e?.map((r) =>
						this._proxy
							.$startFileSearch(r.folder ?? null, r.options, t)
							.then((i) => (Array.isArray(i) ? i.map((s) => b.revive(s)) : [])),
					) ?? [],
				)
			).flat()
		}
		findTextInFiles2(e, t, n, r = De.None) {
			this._logService.trace(
				`extHostWorkspace#findTextInFiles2: textSearch, extension: ${n.value}, entryPoint: findTextInFiles2`,
			)
			let i = (m) => {
					if (!t) return { folder: void 0, options: {} }
					let f = m ? Fx(Ir.from(m)) : void 0,
						h = t.exclude ? t2(t.exclude) : void 0
					return {
						options: {
							ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
							disregardIgnoreFiles: typeof t.useIgnoreFiles == "boolean" ? !t.useIgnoreFiles : void 0,
							disregardGlobalIgnoreFiles:
								typeof t.useIgnoreFiles?.global == "boolean" ? !t.useIgnoreFiles?.global : void 0,
							disregardParentIgnoreFiles:
								typeof t.useIgnoreFiles?.parent == "boolean" ? !t.useIgnoreFiles?.parent : void 0,
							disregardExcludeSettings: t.useExcludeSettings !== void 0 && t.useExcludeSettings === 1,
							disregardSearchExcludeSettings:
								t.useExcludeSettings !== void 0 && t.useExcludeSettings !== 3,
							fileEncoding: t.encoding,
							maxResults: t.maxResults,
							previewOptions: t.previewOptions
								? {
										matchLines: t.previewOptions?.numMatchLines ?? 100,
										charsPerLine: t.previewOptions?.charsPerLine ?? 1e4,
									}
								: void 0,
							surroundingContext: t.surroundingContext,
							includePattern: f?.pattern,
							excludePattern: h,
						},
						folder: f?.folder,
					}
				},
				a = (t?.include?.map((m) => i(m)) ?? [i(void 0)]).filter((m) => !!m),
				l = new Q(),
				d = l.add(new E()),
				c = this.findTextInFilesBase(e, a, (m, f) => d.fire({ result: m, uri: f }), r)
			return {
				results: new mi(async (m) => {
					l.add(
						d.event((f) => {
							let h = f.result,
								g = f.uri
							Wg(h)
								? m.emitOne(
										new ur(
											g,
											h.rangeLocations.map((I) => ({
												previewRange: new pe(
													I.preview.startLineNumber,
													I.preview.startColumn,
													I.preview.endLineNumber,
													I.preview.endColumn,
												),
												sourceRange: new pe(
													I.source.startLineNumber,
													I.source.startColumn,
													I.source.endLineNumber,
													I.source.endColumn,
												),
											})),
											h.previewText,
										),
									)
								: m.emitOne(new Li(g, h.text, h.lineNumber))
						}),
					),
						await c
				}),
				complete: c.then((m) => (l.dispose(), { limitHit: m?.limitHit ?? !1 })),
			}
		}
		async findTextInFilesBase(e, t, n, r = De.None) {
			let i = this._requestIdProvider.getNext(),
				s = !1
			if (
				(r.onCancellationRequested((a) => {
					s = !0
				}),
				(this._activeSearchCallbacks[i] = (a) => {
					if (s) return
					let l = b.revive(a.resource)
					a.results.forEach((d) => {
						let c = ut(d)
						n(c, l)
					})
				}),
				r.isCancellationRequested)
			)
				return {}
			try {
				let a = await Promise.all(
					t?.map((l) => this._proxy.$startTextSearch(e, l.folder ?? null, l.options, i, r) || {}) ?? [],
				)
				return (
					delete this._activeSearchCallbacks[i],
					a.reduce(
						(l, d) => ({
							limitHit: l?.limitHit || (d?.limitHit ?? !1),
							message: [l?.message ?? [], d?.message ?? []].flat(),
						}),
						{},
					) ?? { limitHit: !1 }
				)
			} catch (a) {
				throw (delete this._activeSearchCallbacks[i], a)
			}
		}
		async findTextInFiles(e, t, n, r, i = De.None) {
			this._logService.trace(
				`extHostWorkspace#findTextInFiles: textSearch, extension: ${r.value}, entryPoint: findTextInFiles`,
			)
			let s = typeof t.previewOptions > "u" ? { matchLines: 100, charsPerLine: 1e4 } : t.previewOptions,
				a = Fx(Ir.from(t.include)),
				l = typeof t.exclude == "string" ? t.exclude : t.exclude ? t.exclude.pattern : void 0,
				d = {
					ignoreSymlinks: typeof t.followSymlinks == "boolean" ? !t.followSymlinks : void 0,
					disregardIgnoreFiles: typeof t.useIgnoreFiles == "boolean" ? !t.useIgnoreFiles : void 0,
					disregardGlobalIgnoreFiles:
						typeof t.useGlobalIgnoreFiles == "boolean" ? !t.useGlobalIgnoreFiles : void 0,
					disregardParentIgnoreFiles:
						typeof t.useParentIgnoreFiles == "boolean" ? !t.useParentIgnoreFiles : void 0,
					disregardExcludeSettings: typeof t.useDefaultExcludes == "boolean" ? !t.useDefaultExcludes : !0,
					disregardSearchExcludeSettings: typeof t.useSearchExclude == "boolean" ? !t.useSearchExclude : !0,
					fileEncoding: t.encoding,
					maxResults: t.maxResults,
					previewOptions: s,
					surroundingContext: t.afterContext,
					includePattern: a?.pattern,
					excludePattern: l ? [{ pattern: l }] : void 0,
				},
				c = (u, m) => {
					Wg(u)
						? n({
								uri: m,
								preview: {
									text: u.previewText,
									matches: Rl(
										u.rangeLocations,
										(f) =>
											new pe(
												f.preview.startLineNumber,
												f.preview.startColumn,
												f.preview.endLineNumber,
												f.preview.endColumn,
											),
									),
								},
								ranges: Rl(
									u.rangeLocations,
									(f) =>
										new pe(
											f.source.startLineNumber,
											f.source.startColumn,
											f.source.endLineNumber,
											f.source.endColumn,
										),
								),
							})
						: n({ uri: m, text: u.text, lineNumber: u.lineNumber })
				}
			return this.findTextInFilesBase(e, [{ options: d, folder: a?.folder }], c, i)
		}
		$handleTextSearchResult(e, t) {
			this._activeSearchCallbacks[t]?.(e)
		}
		async save(e) {
			let t = await this._proxy.$save(e, { saveAs: !1 })
			return b.revive(t)
		}
		async saveAs(e) {
			let t = await this._proxy.$save(e, { saveAs: !0 })
			return b.revive(t)
		}
		saveAll(e) {
			return this._proxy.$saveAll(e)
		}
		resolveProxy(e) {
			return this._proxy.$resolveProxy(e)
		}
		lookupAuthorization(e) {
			return this._proxy.$lookupAuthorization(e)
		}
		lookupKerberosAuthorization(e) {
			return this._proxy.$lookupKerberosAuthorization(e)
		}
		loadCertificates() {
			return this._proxy.$loadCertificates()
		}
		get trusted() {
			return this._trusted
		}
		requestWorkspaceTrust(e) {
			return this._proxy.$requestWorkspaceTrust(e)
		}
		$onDidGrantWorkspaceTrust() {
			this._trusted || ((this._trusted = !0), this._onDidGrantWorkspaceTrust.fire())
		}
		registerEditSessionIdentityProvider(e, t) {
			if (this._editSessionIdentityProviders.has(e))
				throw new Error(`A provider has already been registered for scheme ${e}`)
			this._editSessionIdentityProviders.set(e, t)
			let n = this._uriTransformerService.transformOutgoingScheme(e),
				r = this._providerHandlePool++
			return (
				this._proxy.$registerEditSessionIdentityProvider(r, n),
				q(() => {
					this._editSessionIdentityProviders.delete(e), this._proxy.$unregisterEditSessionIdentityProvider(r)
				})
			)
		}
		async $getEditSessionIdentifier(e, t) {
			this._logService.info("Getting edit session identifier for workspaceFolder", e)
			let n = await this.resolveWorkspaceFolder(b.revive(e))
			if (!n) {
				this._logService.warn("Unable to resolve workspace folder")
				return
			}
			this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", n)
			let r = this._editSessionIdentityProviders.get(n.uri.scheme)
			if ((this._logService.info(`Provider for scheme ${n.uri.scheme} is defined: `, !!r), !r)) return
			let i = await r.provideEditSessionIdentity(n, t)
			if ((this._logService.info("Provider returned edit session identifier: ", i), !!i)) return i
		}
		async $provideEditSessionIdentityMatch(e, t, n, r) {
			this._logService.info("Getting edit session identifier for workspaceFolder", e)
			let i = await this.resolveWorkspaceFolder(b.revive(e))
			if (!i) {
				this._logService.warn("Unable to resolve workspace folder")
				return
			}
			this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", i)
			let s = this._editSessionIdentityProviders.get(i.uri.scheme)
			if ((this._logService.info(`Provider for scheme ${i.uri.scheme} is defined: `, !!s), !s)) return
			let a = await s.provideEditSessionIdentityMatch?.(t, n, r)
			if ((this._logService.info("Provider returned edit session identifier match result: ", a), !!a)) return a
		}
		getOnWillCreateEditSessionIdentityEvent(e) {
			return (t, n, r) => {
				let i = function (a) {
					t.call(n, a)
				}
				return (i.extension = e), this._onWillCreateEditSessionIdentityEvent.event(i, void 0, r)
			}
		}
		async $onWillCreateEditSessionIdentity(e, t, n) {
			let r = await this.resolveWorkspaceFolder(b.revive(e))
			if (r === void 0) throw new Error("Unable to resolve workspace folder")
			await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: r }, t, async (i, s) => {
				let a = Date.now()
				await Promise.resolve(i),
					Date.now() - a > n &&
						this._logService.warn("SLOW edit session create-participant", s.extension.identifier)
			}),
				t.isCancellationRequested
		}
		registerCanonicalUriProvider(e, t) {
			if (this._canonicalUriProviders.has(e))
				throw new Error(`A provider has already been registered for scheme ${e}`)
			this._canonicalUriProviders.set(e, t)
			let n = this._uriTransformerService.transformOutgoingScheme(e),
				r = this._providerHandlePool++
			return (
				this._proxy.$registerCanonicalUriProvider(r, n),
				q(() => {
					this._canonicalUriProviders.delete(e), this._proxy.$unregisterCanonicalUriProvider(r)
				})
			)
		}
		async provideCanonicalUri(e, t, n) {
			let r = this._canonicalUriProviders.get(e.scheme)
			if (!r) return
			let i = await r.provideCanonicalUri?.(b.revive(e), t, n)
			if (i) return i
		}
		async $provideCanonicalUri(e, t, n) {
			return this.provideCanonicalUri(b.revive(e), { targetScheme: t }, n)
		}
		async decode(e, t, n) {
			let r = await this._proxy.$resolveDecoding(t, n),
				i = (
					await GF(IA(z.wrap(e)), {
						...r,
						acceptTextOnly: !0,
						overwriteEncoding: (s) =>
							s === null || s === r.preferredEncoding
								? Promise.resolve(r.preferredEncoding)
								: this._proxy.$validateDetectedEncoding(t, s, n),
					})
				).stream
			return gv(i, (s) => s.join(""))
		}
		async encode(e, t, n) {
			let { encoding: r, addBOM: i } = await this._proxy.$resolveEncoding(t, n)
			if (r === qg && !i) return z.fromString(e).buffer
			let s = await QF(e2(e), r, { addBOM: i })
			return bA(s).buffer
		}
	}
dp = R([S(0, ie), S(1, Xe), S(2, po), S(3, te), S(4, fi)], dp)
var Sn = O("IExtHostWorkspace")
function Fx(o) {
	let e, t
	if (o)
		return typeof o == "string" ? (e = o) : ((e = o.pattern), (t = b.revive(o.baseUri))), { pattern: e, folder: t }
}
function t2(o) {
	return (
		o?.map((e) => {
			if (typeof e == "string") return e === "" ? void 0 : { pattern: e, uri: void 0 }
			{
				let t = Fx(e)
				return t ? { pattern: t.pattern, uri: t.folder } : void 0
			}
		}) ?? []
	).filter((e) => !!e)
}
var r2
;((e) => (e.DEFAULT = { allowTrailingComma: !0 }))((r2 ||= {}))
function d8(o, e = !1) {
	let t = 0,
		n = o.length,
		r = "",
		i = 0,
		s = 16,
		a = 0
	function l(g) {
		let I = 0,
			C = 0
		for (; I < g; ) {
			let T = o.charCodeAt(t)
			if (T >= 48 && T <= 57) C = C * 16 + T - 48
			else if (T >= 65 && T <= 70) C = C * 16 + T - 65 + 10
			else if (T >= 97 && T <= 102) C = C * 16 + T - 97 + 10
			else break
			t++, I++
		}
		return I < g && (C = -1), C
	}
	function d(g) {
		;(t = g), (r = ""), (i = 0), (s = 16), (a = 0)
	}
	function c() {
		let g = t
		if (o.charCodeAt(t) === 48) t++
		else for (t++; t < o.length && cp(o.charCodeAt(t)); ) t++
		if (t < o.length && o.charCodeAt(t) === 46)
			if ((t++, t < o.length && cp(o.charCodeAt(t)))) for (t++; t < o.length && cp(o.charCodeAt(t)); ) t++
			else return (a = 3), o.substring(g, t)
		let I = t
		if (t < o.length && (o.charCodeAt(t) === 69 || o.charCodeAt(t) === 101))
			if (
				(t++,
				((t < o.length && o.charCodeAt(t) === 43) || o.charCodeAt(t) === 45) && t++,
				t < o.length && cp(o.charCodeAt(t)))
			) {
				for (t++; t < o.length && cp(o.charCodeAt(t)); ) t++
				I = t
			} else a = 3
		return o.substring(g, I)
	}
	function u() {
		let g = "",
			I = t
		for (;;) {
			if (t >= n) {
				;(g += o.substring(I, t)), (a = 2)
				break
			}
			let C = o.charCodeAt(t)
			if (C === 34) {
				;(g += o.substring(I, t)), t++
				break
			}
			if (C === 92) {
				if (((g += o.substring(I, t)), t++, t >= n)) {
					a = 2
					break
				}
				switch (o.charCodeAt(t++)) {
					case 34:
						g += '"'
						break
					case 92:
						g += "\\"
						break
					case 47:
						g += "/"
						break
					case 98:
						g += "\b"
						break
					case 102:
						g += "\f"
						break
					case 110:
						g += `
`
						break
					case 114:
						g += "\r"
						break
					case 116:
						g += "	"
						break
					case 117: {
						let w = l(4)
						w >= 0 ? (g += String.fromCharCode(w)) : (a = 4)
						break
					}
					default:
						a = 5
				}
				I = t
				continue
			}
			if (C >= 0 && C <= 31)
				if (Nx(C)) {
					;(g += o.substring(I, t)), (a = 2)
					break
				} else a = 6
			t++
		}
		return g
	}
	function m() {
		if (((r = ""), (a = 0), (i = t), t >= n)) return (i = n), (s = 17)
		let g = o.charCodeAt(t)
		if (wk(g)) {
			do t++, (r += String.fromCharCode(g)), (g = o.charCodeAt(t))
			while (wk(g))
			return (s = 15)
		}
		if (Nx(g))
			return (
				t++,
				(r += String.fromCharCode(g)),
				g === 13 &&
					o.charCodeAt(t) === 10 &&
					(t++,
					(r += `
`)),
				(s = 14)
			)
		switch (g) {
			case 123:
				return t++, (s = 1)
			case 125:
				return t++, (s = 2)
			case 91:
				return t++, (s = 3)
			case 93:
				return t++, (s = 4)
			case 58:
				return t++, (s = 6)
			case 44:
				return t++, (s = 5)
			case 34:
				return t++, (r = u()), (s = 10)
			case 47: {
				let I = t - 1
				if (o.charCodeAt(t + 1) === 47) {
					for (t += 2; t < n && !Nx(o.charCodeAt(t)); ) t++
					return (r = o.substring(I, t)), (s = 12)
				}
				if (o.charCodeAt(t + 1) === 42) {
					t += 2
					let C = n - 1,
						T = !1
					for (; t < C; ) {
						if (o.charCodeAt(t) === 42 && o.charCodeAt(t + 1) === 47) {
							;(t += 2), (T = !0)
							break
						}
						t++
					}
					return T || (t++, (a = 1)), (r = o.substring(I, t)), (s = 13)
				}
				return (r += String.fromCharCode(g)), t++, (s = 16)
			}
			case 45:
				if (((r += String.fromCharCode(g)), t++, t === n || !cp(o.charCodeAt(t)))) return (s = 16)
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				return (r += c()), (s = 11)
			default:
				for (; t < n && f(g); ) t++, (g = o.charCodeAt(t))
				if (i !== t) {
					switch (((r = o.substring(i, t)), r)) {
						case "true":
							return (s = 8)
						case "false":
							return (s = 9)
						case "null":
							return (s = 7)
					}
					return (s = 16)
				}
				return (r += String.fromCharCode(g)), t++, (s = 16)
		}
	}
	function f(g) {
		if (wk(g) || Nx(g)) return !1
		switch (g) {
			case 125:
			case 93:
			case 123:
			case 91:
			case 34:
			case 58:
			case 44:
			case 47:
				return !1
		}
		return !0
	}
	function h() {
		let g
		do g = m()
		while (g >= 12 && g <= 15)
		return g
	}
	return {
		setPosition: d,
		getPosition: () => t,
		scan: e ? h : m,
		getToken: () => s,
		getTokenValue: () => r,
		getTokenOffset: () => i,
		getTokenLength: () => t - i,
		getTokenError: () => a,
	}
}
function wk(o) {
	return (
		o === 32 ||
		o === 9 ||
		o === 11 ||
		o === 12 ||
		o === 160 ||
		o === 5760 ||
		(o >= 8192 && o <= 8203) ||
		o === 8239 ||
		o === 8287 ||
		o === 12288 ||
		o === 65279
	)
}
function Nx(o) {
	return o === 10 || o === 13 || o === 8232 || o === 8233
}
function cp(o) {
	return o >= 48 && o <= 57
}
function o2(o, e, t = r2.DEFAULT) {
	let n = d8(o, !1)
	function r(Y) {
		return Y ? () => Y(n.getTokenOffset(), n.getTokenLength()) : () => !0
	}
	function i(Y) {
		return Y ? (j) => Y(j, n.getTokenOffset(), n.getTokenLength()) : () => !0
	}
	let s = r(e.onObjectBegin),
		a = i(e.onObjectProperty),
		l = r(e.onObjectEnd),
		d = r(e.onArrayBegin),
		c = r(e.onArrayEnd),
		u = i(e.onLiteralValue),
		m = i(e.onSeparator),
		f = r(e.onComment),
		h = i(e.onError),
		g = t && t.disallowComments,
		I = t && t.allowTrailingComma
	function C() {
		for (;;) {
			let Y = n.scan()
			switch (n.getTokenError()) {
				case 4:
					T(14)
					break
				case 5:
					T(15)
					break
				case 3:
					T(13)
					break
				case 1:
					g || T(11)
					break
				case 2:
					T(12)
					break
				case 6:
					T(16)
					break
			}
			switch (Y) {
				case 12:
				case 13:
					g ? T(10) : f()
					break
				case 16:
					T(1)
					break
				case 15:
				case 14:
					break
				default:
					return Y
			}
		}
	}
	function T(Y, j = [], K = []) {
		if ((h(Y), j.length + K.length > 0)) {
			let qe = n.getToken()
			for (; qe !== 17; ) {
				if (j.indexOf(qe) !== -1) {
					C()
					break
				} else if (K.indexOf(qe) !== -1) break
				qe = C()
			}
		}
	}
	function w(Y) {
		let j = n.getTokenValue()
		return Y ? u(j) : a(j), C(), !0
	}
	function L() {
		switch (n.getToken()) {
			case 11: {
				let Y = 0
				try {
					;(Y = JSON.parse(n.getTokenValue())), typeof Y != "number" && (T(2), (Y = 0))
				} catch {
					T(2)
				}
				u(Y)
				break
			}
			case 7:
				u(null)
				break
			case 8:
				u(!0)
				break
			case 9:
				u(!1)
				break
			default:
				return !1
		}
		return C(), !0
	}
	function A() {
		return n.getToken() !== 10
			? (T(3, [], [2, 5]), !1)
			: (w(!1), n.getToken() === 6 ? (m(":"), C(), oe() || T(4, [], [2, 5])) : T(5, [], [2, 5]), !0)
	}
	function J() {
		s(), C()
		let Y = !1
		for (; n.getToken() !== 2 && n.getToken() !== 17; ) {
			if (n.getToken() === 5) {
				if ((Y || T(4, [], []), m(","), C(), n.getToken() === 2 && I)) break
			} else Y && T(6, [], [])
			A() || T(4, [], [2, 5]), (Y = !0)
		}
		return l(), n.getToken() !== 2 ? T(7, [2], []) : C(), !0
	}
	function ne() {
		d(), C()
		let Y = !1
		for (; n.getToken() !== 4 && n.getToken() !== 17; ) {
			if (n.getToken() === 5) {
				if ((Y || T(4, [], []), m(","), C(), n.getToken() === 4 && I)) break
			} else Y && T(6, [], [])
			oe() || T(4, [], [4, 5]), (Y = !0)
		}
		return c(), n.getToken() !== 4 ? T(8, [4], []) : C(), !0
	}
	function oe() {
		switch (n.getToken()) {
			case 3:
				return ne()
			case 1:
				return J()
			case 10:
				return w(!0)
			default:
				return L()
		}
	}
	return (
		C(),
		n.getToken() === 17
			? t.allowEmptyContent
				? !0
				: (T(4, [], []), !1)
			: oe()
				? (n.getToken() !== 17 && T(9, [], []), !0)
				: (T(4, [], []), !1)
	)
}
function Gg(o) {
	return Object.isFrozen(o) ? o : ob(o)
}
var xr = class o {
		constructor(e, t, n, r, i) {
			this._contents = e
			this._keys = t
			this._overrides = n
			this.raw = r
			this.logService = i
			this.overrideConfigurations = new Map()
		}
		static createEmptyModel(e) {
			return new o({}, [], [], void 0, e)
		}
		get rawConfiguration() {
			if (!this._rawConfiguration)
				if (this.raw) {
					let e = (Array.isArray(this.raw) ? this.raw : [this.raw]).map((t) => {
						if (t instanceof o) return t
						let n = new Pk("", this.logService)
						return n.parseRaw(t), n.configurationModel
					})
					this._rawConfiguration = e.reduce((t, n) => (n === t ? n : t.merge(n)), e[0])
				} else this._rawConfiguration = this
			return this._rawConfiguration
		}
		get contents() {
			return this._contents
		}
		get overrides() {
			return this._overrides
		}
		get keys() {
			return this._keys
		}
		isEmpty() {
			return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0
		}
		getValue(e) {
			return e ? rg(this.contents, e) : this.contents
		}
		inspect(e, t) {
			let n = this
			return {
				get value() {
					return Gg(n.rawConfiguration.getValue(e))
				},
				get override() {
					return t ? Gg(n.rawConfiguration.getOverrideValue(e, t)) : void 0
				},
				get merged() {
					return Gg(t ? n.rawConfiguration.override(t).getValue(e) : n.rawConfiguration.getValue(e))
				},
				get overrides() {
					let r = []
					for (let { contents: i, identifiers: s, keys: a } of n.rawConfiguration.overrides) {
						let l = new o(i, a, [], void 0, n.logService).getValue(e)
						l !== void 0 && r.push({ identifiers: s, value: l })
					}
					return r.length ? Gg(r) : void 0
				},
			}
		}
		getOverrideValue(e, t) {
			let n = this.getContentsForOverrideIdentifer(t)
			return n ? (e ? rg(n, e) : n) : void 0
		}
		getKeysForOverrideIdentifier(e) {
			let t = []
			for (let n of this.overrides) n.identifiers.includes(e) && t.push(...n.keys)
			return ai(t)
		}
		getAllOverrideIdentifiers() {
			let e = []
			for (let t of this.overrides) e.push(...t.identifiers)
			return ai(e)
		}
		override(e) {
			let t = this.overrideConfigurations.get(e)
			return t || ((t = this.createOverrideConfigurationModel(e)), this.overrideConfigurations.set(e, t)), t
		}
		merge(...e) {
			let t = je(this.contents),
				n = je(this.overrides),
				r = [...this.keys],
				i = this.raw ? (Array.isArray(this.raw) ? [...this.raw] : [this.raw]) : [this]
			for (let s of e)
				if ((i.push(...(s.raw ? (Array.isArray(s.raw) ? s.raw : [s.raw]) : [s])), !s.isEmpty())) {
					this.mergeContents(t, s.contents)
					for (let a of s.overrides) {
						let [l] = n.filter((d) => mn(d.identifiers, a.identifiers))
						l
							? (this.mergeContents(l.contents, a.contents),
								l.keys.push(...a.keys),
								(l.keys = ai(l.keys)))
							: n.push(je(a))
					}
					for (let a of s.keys) r.indexOf(a) === -1 && r.push(a)
				}
			return new o(t, r, n, !i.length || i.every((s) => s instanceof o) ? void 0 : i, this.logService)
		}
		createOverrideConfigurationModel(e) {
			let t = this.getContentsForOverrideIdentifer(e)
			if (!t || typeof t != "object" || !Object.keys(t).length) return this
			let n = {}
			for (let r of ai([...Object.keys(this.contents), ...Object.keys(t)])) {
				let i = this.contents[r],
					s = t[r]
				s && (typeof i == "object" && typeof s == "object" ? ((i = je(i)), this.mergeContents(i, s)) : (i = s)),
					(n[r] = i)
			}
			return new o(n, this.keys, this.overrides, void 0, this.logService)
		}
		mergeContents(e, t) {
			for (let n of Object.keys(t)) {
				if (n in e && dt(e[n]) && dt(t[n])) {
					this.mergeContents(e[n], t[n])
					continue
				}
				e[n] = je(t[n])
			}
		}
		getContentsForOverrideIdentifer(e) {
			let t = null,
				n = null,
				r = (i) => {
					i && (n ? this.mergeContents(n, i) : (n = je(i)))
				}
			for (let i of this.overrides)
				i.identifiers.length === 1 && i.identifiers[0] === e
					? (t = i.contents)
					: i.identifiers.includes(e) && r(i.contents)
			return r(t), n
		}
		toJSON() {
			return { contents: this.contents, overrides: this.overrides, keys: this.keys }
		}
		addValue(e, t) {
			this.updateValue(e, t, !0)
		}
		setValue(e, t) {
			this.updateValue(e, t, !1)
		}
		removeValue(e) {
			let t = this.keys.indexOf(e)
			t !== -1 &&
				(this.keys.splice(t, 1),
				HM(this.contents, e),
				go.test(e) &&
					this.overrides.splice(
						this.overrides.findIndex((n) => mn(n.identifiers, ru(e))),
						1,
					))
		}
		updateValue(e, t, n) {
			if (
				(p_(this.contents, e, t, (r) => this.logService.error(r)),
				(n = n || this.keys.indexOf(e) === -1),
				n && this.keys.push(e),
				go.test(e))
			) {
				let r = ru(e),
					i = {
						identifiers: r,
						keys: Object.keys(this.contents[e]),
						contents: sy(this.contents[e], (a) => this.logService.error(a)),
					},
					s = this.overrides.findIndex((a) => mn(a.identifiers, r))
				s !== -1 ? (this.overrides[s] = i) : this.overrides.push(i)
			}
		}
	},
	Pk = class {
		constructor(e, t) {
			this._name = e
			this.logService = t
			this._raw = null
			this._configurationModel = null
			this._restrictedConfigurations = []
			this._parseErrors = []
		}
		get configurationModel() {
			return this._configurationModel || xr.createEmptyModel(this.logService)
		}
		get restrictedConfigurations() {
			return this._restrictedConfigurations
		}
		get errors() {
			return this._parseErrors
		}
		parse(e, t) {
			if (!bt(e)) {
				let n = this.doParseContent(e)
				this.parseRaw(n, t)
			}
		}
		reparse(e) {
			this._raw && this.parseRaw(this._raw, e)
		}
		parseRaw(e, t) {
			this._raw = e
			let { contents: n, keys: r, overrides: i, restricted: s, hasExcludedProperties: a } = this.doParseRaw(e, t)
			;(this._configurationModel = new xr(n, r, i, a ? [e] : void 0, this.logService)),
				(this._restrictedConfigurations = s || [])
		}
		doParseContent(e) {
			let t = {},
				n = null,
				r = [],
				i = [],
				s = []
			function a(d) {
				Array.isArray(r) ? r.push(d) : n !== null && (r[n] = d)
			}
			let l = {
				onObjectBegin: () => {
					let d = {}
					a(d), i.push(r), (r = d), (n = null)
				},
				onObjectProperty: (d) => {
					n = d
				},
				onObjectEnd: () => {
					r = i.pop()
				},
				onArrayBegin: () => {
					let d = []
					a(d), i.push(r), (r = d), (n = null)
				},
				onArrayEnd: () => {
					r = i.pop()
				},
				onLiteralValue: a,
				onError: (d, c, u) => {
					s.push({ error: d, offset: c, length: u })
				},
			}
			if (e)
				try {
					o2(e, l), (t = r[0] || {})
				} catch (d) {
					this.logService.error(`Error while parsing settings file ${this._name}: ${d}`),
						(this._parseErrors = [d])
				}
			return t
		}
		doParseRaw(e, t) {
			let n = yt.as(ho.Configuration).getConfigurationProperties(),
				r = this.filter(e, n, !0, t)
			e = r.raw
			let i = sy(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)),
				s = Object.keys(e),
				a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`))
			return {
				contents: i,
				keys: s,
				overrides: a,
				restricted: r.restricted,
				hasExcludedProperties: r.hasExcludedProperties,
			}
		}
		filter(e, t, n, r) {
			let i = !1
			if (!r?.scopes && !r?.skipRestricted && !r?.exclude?.length)
				return { raw: e, restricted: [], hasExcludedProperties: i }
			let s = {},
				a = []
			for (let l in e)
				if (go.test(l) && n) {
					let d = this.filter(e[l], t, !1, r)
					;(s[l] = d.raw), (i = i || d.hasExcludedProperties), a.push(...d.restricted)
				} else {
					let d = t[l]
					d?.restricted && a.push(l), this.shouldInclude(l, d, r) ? (s[l] = e[l]) : (i = !0)
				}
			return { raw: s, restricted: a, hasExcludedProperties: i }
		}
		shouldInclude(e, t, n) {
			if (n.exclude?.includes(e)) return !1
			if (n.include?.includes(e)) return !0
			if ((n.skipRestricted && t?.restricted) || (n.skipUnregistered && !t)) return !1
			let r = t ? (typeof t.scope < "u" ? t.scope : 4) : void 0
			return r === void 0 || n.scopes === void 0 ? !0 : n.scopes.includes(r)
		}
		toOverrides(e, t) {
			let n = []
			for (let r of Object.keys(e))
				if (go.test(r)) {
					let i = {}
					for (let s in e[r]) i[s] = e[r][s]
					n.push({ identifiers: ru(r), keys: Object.keys(i), contents: sy(i, t) })
				}
			return n
		}
	}
var _k = class {
		constructor(e, t, n, r, i, s, a, l, d, c, u, m, f) {
			this.key = e
			this.overrides = t
			this._value = n
			this.overrideIdentifiers = r
			this.defaultConfiguration = i
			this.policyConfiguration = s
			this.applicationConfiguration = a
			this.userConfiguration = l
			this.localUserConfiguration = d
			this.remoteUserConfiguration = c
			this.workspaceConfiguration = u
			this.folderConfigurationModel = m
			this.memoryConfigurationModel = f
		}
		get value() {
			return Gg(this._value)
		}
		toInspectValue(e) {
			return e?.value !== void 0 || e?.override !== void 0 || e?.overrides !== void 0 ? e : void 0
		}
		get defaultInspectValue() {
			return (
				this._defaultInspectValue ||
					(this._defaultInspectValue = this.defaultConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._defaultInspectValue
			)
		}
		get defaultValue() {
			return this.defaultInspectValue.merged
		}
		get default() {
			return this.toInspectValue(this.defaultInspectValue)
		}
		get policyInspectValue() {
			return (
				this._policyInspectValue === void 0 &&
					(this._policyInspectValue = this.policyConfiguration
						? this.policyConfiguration.inspect(this.key)
						: null),
				this._policyInspectValue
			)
		}
		get policyValue() {
			return this.policyInspectValue?.merged
		}
		get policy() {
			return this.policyInspectValue?.value !== void 0 ? { value: this.policyInspectValue.value } : void 0
		}
		get applicationInspectValue() {
			return (
				this._applicationInspectValue === void 0 &&
					(this._applicationInspectValue = this.applicationConfiguration
						? this.applicationConfiguration.inspect(this.key)
						: null),
				this._applicationInspectValue
			)
		}
		get applicationValue() {
			return this.applicationInspectValue?.merged
		}
		get application() {
			return this.toInspectValue(this.applicationInspectValue)
		}
		get userInspectValue() {
			return (
				this._userInspectValue ||
					(this._userInspectValue = this.userConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userInspectValue
			)
		}
		get userValue() {
			return this.userInspectValue.merged
		}
		get user() {
			return this.toInspectValue(this.userInspectValue)
		}
		get userLocalInspectValue() {
			return (
				this._userLocalInspectValue ||
					(this._userLocalInspectValue = this.localUserConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userLocalInspectValue
			)
		}
		get userLocalValue() {
			return this.userLocalInspectValue.merged
		}
		get userLocal() {
			return this.toInspectValue(this.userLocalInspectValue)
		}
		get userRemoteInspectValue() {
			return (
				this._userRemoteInspectValue ||
					(this._userRemoteInspectValue = this.remoteUserConfiguration.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._userRemoteInspectValue
			)
		}
		get userRemoteValue() {
			return this.userRemoteInspectValue.merged
		}
		get userRemote() {
			return this.toInspectValue(this.userRemoteInspectValue)
		}
		get workspaceInspectValue() {
			return (
				this._workspaceInspectValue === void 0 &&
					(this._workspaceInspectValue = this.workspaceConfiguration
						? this.workspaceConfiguration.inspect(this.key, this.overrides.overrideIdentifier)
						: null),
				this._workspaceInspectValue
			)
		}
		get workspaceValue() {
			return this.workspaceInspectValue?.merged
		}
		get workspace() {
			return this.toInspectValue(this.workspaceInspectValue)
		}
		get workspaceFolderInspectValue() {
			return (
				this._workspaceFolderInspectValue === void 0 &&
					(this._workspaceFolderInspectValue = this.folderConfigurationModel
						? this.folderConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier)
						: null),
				this._workspaceFolderInspectValue
			)
		}
		get workspaceFolderValue() {
			return this.workspaceFolderInspectValue?.merged
		}
		get workspaceFolder() {
			return this.toInspectValue(this.workspaceFolderInspectValue)
		}
		get memoryInspectValue() {
			return (
				this._memoryInspectValue === void 0 &&
					(this._memoryInspectValue = this.memoryConfigurationModel.inspect(
						this.key,
						this.overrides.overrideIdentifier,
					)),
				this._memoryInspectValue
			)
		}
		get memoryValue() {
			return this.memoryInspectValue.merged
		}
		get memory() {
			return this.toInspectValue(this.memoryInspectValue)
		}
	},
	up = class o {
		constructor(e, t, n, r, i, s, a, l, d, c) {
			this._defaultConfiguration = e
			this._policyConfiguration = t
			this._applicationConfiguration = n
			this._localUserConfiguration = r
			this._remoteUserConfiguration = i
			this._workspaceConfiguration = s
			this._folderConfigurations = a
			this._memoryConfiguration = l
			this._memoryConfigurationByResource = d
			this.logService = c
			this._workspaceConsolidatedConfiguration = null
			this._foldersConsolidatedConfigurations = new ft()
			this._userConfiguration = null
		}
		getValue(e, t, n) {
			return this.getConsolidatedConfigurationModel(e, t, n).getValue(e)
		}
		updateValue(e, t, n = {}) {
			let r
			n.resource
				? ((r = this._memoryConfigurationByResource.get(n.resource)),
					r ||
						((r = xr.createEmptyModel(this.logService)),
						this._memoryConfigurationByResource.set(n.resource, r)))
				: (r = this._memoryConfiguration),
				t === void 0 ? r.removeValue(e) : r.setValue(e, t),
				n.resource || (this._workspaceConsolidatedConfiguration = null)
		}
		inspect(e, t, n) {
			let r = this.getConsolidatedConfigurationModel(e, t, n),
				i = this.getFolderConfigurationModelForResource(t.resource, n),
				s = t.resource
					? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration
					: this._memoryConfiguration,
				a = new Set()
			for (let l of r.overrides) for (let d of l.identifiers) r.getOverrideValue(e, d) !== void 0 && a.add(d)
			return new _k(
				e,
				t,
				r.getValue(e),
				a.size ? [...a] : void 0,
				this._defaultConfiguration,
				this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration,
				this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration,
				this.userConfiguration,
				this.localUserConfiguration,
				this.remoteUserConfiguration,
				n ? this._workspaceConfiguration : void 0,
				i || void 0,
				s,
			)
		}
		keys(e) {
			let t = this.getFolderConfigurationModelForResource(void 0, e)
			return {
				default: this._defaultConfiguration.keys.slice(0),
				user: this.userConfiguration.keys.slice(0),
				workspace: this._workspaceConfiguration.keys.slice(0),
				workspaceFolder: t ? t.keys.slice(0) : [],
			}
		}
		updateDefaultConfiguration(e) {
			;(this._defaultConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updatePolicyConfiguration(e) {
			this._policyConfiguration = e
		}
		updateApplicationConfiguration(e) {
			;(this._applicationConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateLocalUserConfiguration(e) {
			;(this._localUserConfiguration = e),
				(this._userConfiguration = null),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateRemoteUserConfiguration(e) {
			;(this._remoteUserConfiguration = e),
				(this._userConfiguration = null),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateWorkspaceConfiguration(e) {
			;(this._workspaceConfiguration = e),
				(this._workspaceConsolidatedConfiguration = null),
				this._foldersConsolidatedConfigurations.clear()
		}
		updateFolderConfiguration(e, t) {
			this._folderConfigurations.set(e, t), this._foldersConsolidatedConfigurations.delete(e)
		}
		deleteFolderConfiguration(e) {
			this.folderConfigurations.delete(e), this._foldersConsolidatedConfigurations.delete(e)
		}
		compareAndUpdateDefaultConfiguration(e, t) {
			let n = []
			if (!t) {
				let { added: r, updated: i, removed: s } = sl(this._defaultConfiguration, e)
				t = [...r, ...i, ...s]
			}
			for (let r of t)
				for (let i of ru(r)) {
					let s = this._defaultConfiguration.getKeysForOverrideIdentifier(i),
						a = e.getKeysForOverrideIdentifier(i),
						l = [
							...a.filter((d) => s.indexOf(d) === -1),
							...s.filter((d) => a.indexOf(d) === -1),
							...s.filter(
								(d) =>
									!nn(this._defaultConfiguration.override(i).getValue(d), e.override(i).getValue(d)),
							),
						]
					n.push([i, l])
				}
			return this.updateDefaultConfiguration(e), { keys: t, overrides: n }
		}
		compareAndUpdatePolicyConfiguration(e) {
			let { added: t, updated: n, removed: r } = sl(this._policyConfiguration, e),
				i = [...t, ...n, ...r]
			return i.length && this.updatePolicyConfiguration(e), { keys: i, overrides: [] }
		}
		compareAndUpdateApplicationConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = sl(this.applicationConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateApplicationConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateLocalUserConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = sl(this.localUserConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateLocalUserConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateRemoteUserConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = sl(this.remoteUserConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateRemoteUserConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateWorkspaceConfiguration(e) {
			let { added: t, updated: n, removed: r, overrides: i } = sl(this.workspaceConfiguration, e),
				s = [...t, ...n, ...r]
			return s.length && this.updateWorkspaceConfiguration(e), { keys: s, overrides: i }
		}
		compareAndUpdateFolderConfiguration(e, t) {
			let n = this.folderConfigurations.get(e),
				{ added: r, updated: i, removed: s, overrides: a } = sl(n, t),
				l = [...r, ...i, ...s]
			return (l.length || !n) && this.updateFolderConfiguration(e, t), { keys: l, overrides: a }
		}
		compareAndDeleteFolderConfiguration(e) {
			let t = this.folderConfigurations.get(e)
			if (!t) throw new Error("Unknown folder")
			this.deleteFolderConfiguration(e)
			let { added: n, updated: r, removed: i, overrides: s } = sl(t, void 0)
			return { keys: [...n, ...r, ...i], overrides: s }
		}
		get defaults() {
			return this._defaultConfiguration
		}
		get applicationConfiguration() {
			return this._applicationConfiguration
		}
		get userConfiguration() {
			if (!this._userConfiguration)
				if (this._remoteUserConfiguration.isEmpty()) this._userConfiguration = this._localUserConfiguration
				else {
					let e = this._localUserConfiguration.merge(this._remoteUserConfiguration)
					this._userConfiguration = new xr(e.contents, e.keys, e.overrides, void 0, this.logService)
				}
			return this._userConfiguration
		}
		get localUserConfiguration() {
			return this._localUserConfiguration
		}
		get remoteUserConfiguration() {
			return this._remoteUserConfiguration
		}
		get workspaceConfiguration() {
			return this._workspaceConfiguration
		}
		get folderConfigurations() {
			return this._folderConfigurations
		}
		getConsolidatedConfigurationModel(e, t, n) {
			let r = this.getConsolidatedConfigurationModelForResource(t, n)
			if (
				(t.overrideIdentifier && (r = r.override(t.overrideIdentifier)),
				!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0)
			) {
				r = r.merge()
				for (let i of this._policyConfiguration.keys) r.setValue(i, this._policyConfiguration.getValue(i))
			}
			return r
		}
		getConsolidatedConfigurationModelForResource({ resource: e }, t) {
			let n = this.getWorkspaceConsolidatedConfiguration()
			if (t && e) {
				let r = t.getFolder(e)
				r && (n = this.getFolderConsolidatedConfiguration(r.uri) || n)
				let i = this._memoryConfigurationByResource.get(e)
				i && (n = n.merge(i))
			}
			return n
		}
		getWorkspaceConsolidatedConfiguration() {
			return (
				this._workspaceConsolidatedConfiguration ||
					(this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(
						this.applicationConfiguration,
						this.userConfiguration,
						this._workspaceConfiguration,
						this._memoryConfiguration,
					)),
				this._workspaceConsolidatedConfiguration
			)
		}
		getFolderConsolidatedConfiguration(e) {
			let t = this._foldersConsolidatedConfigurations.get(e)
			if (!t) {
				let n = this.getWorkspaceConsolidatedConfiguration(),
					r = this._folderConfigurations.get(e)
				r ? ((t = n.merge(r)), this._foldersConsolidatedConfigurations.set(e, t)) : (t = n)
			}
			return t
		}
		getFolderConfigurationModelForResource(e, t) {
			if (t && e) {
				let n = t.getFolder(e)
				if (n) return this._folderConfigurations.get(n.uri)
			}
		}
		toData() {
			return {
				defaults: {
					contents: this._defaultConfiguration.contents,
					overrides: this._defaultConfiguration.overrides,
					keys: this._defaultConfiguration.keys,
				},
				policy: {
					contents: this._policyConfiguration.contents,
					overrides: this._policyConfiguration.overrides,
					keys: this._policyConfiguration.keys,
				},
				application: {
					contents: this.applicationConfiguration.contents,
					overrides: this.applicationConfiguration.overrides,
					keys: this.applicationConfiguration.keys,
					raw: Array.isArray(this.applicationConfiguration.raw) ? void 0 : this.applicationConfiguration.raw,
				},
				userLocal: {
					contents: this.localUserConfiguration.contents,
					overrides: this.localUserConfiguration.overrides,
					keys: this.localUserConfiguration.keys,
					raw: Array.isArray(this.localUserConfiguration.raw) ? void 0 : this.localUserConfiguration.raw,
				},
				userRemote: {
					contents: this.remoteUserConfiguration.contents,
					overrides: this.remoteUserConfiguration.overrides,
					keys: this.remoteUserConfiguration.keys,
					raw: Array.isArray(this.remoteUserConfiguration.raw) ? void 0 : this.remoteUserConfiguration.raw,
				},
				workspace: {
					contents: this._workspaceConfiguration.contents,
					overrides: this._workspaceConfiguration.overrides,
					keys: this._workspaceConfiguration.keys,
				},
				folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
					let { contents: n, overrides: r, keys: i } = this._folderConfigurations.get(t)
					return e.push([t, { contents: n, overrides: r, keys: i }]), e
				}, []),
			}
		}
		allKeys() {
			let e = new Set()
			return (
				this._defaultConfiguration.keys.forEach((t) => e.add(t)),
				this.userConfiguration.keys.forEach((t) => e.add(t)),
				this._workspaceConfiguration.keys.forEach((t) => e.add(t)),
				this._folderConfigurations.forEach((t) => t.keys.forEach((n) => e.add(n))),
				[...e.values()]
			)
		}
		allOverrideIdentifiers() {
			let e = new Set()
			return (
				this._defaultConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this.userConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this._workspaceConfiguration.getAllOverrideIdentifiers().forEach((t) => e.add(t)),
				this._folderConfigurations.forEach((t) => t.getAllOverrideIdentifiers().forEach((n) => e.add(n))),
				[...e.values()]
			)
		}
		getAllKeysForOverrideIdentifier(e) {
			let t = new Set()
			return (
				this._defaultConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this.userConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this._workspaceConfiguration.getKeysForOverrideIdentifier(e).forEach((n) => t.add(n)),
				this._folderConfigurations.forEach((n) => n.getKeysForOverrideIdentifier(e).forEach((r) => t.add(r))),
				[...t.values()]
			)
		}
		static parse(e, t) {
			let n = this.parseConfigurationModel(e.defaults, t),
				r = this.parseConfigurationModel(e.policy, t),
				i = this.parseConfigurationModel(e.application, t),
				s = this.parseConfigurationModel(e.userLocal, t),
				a = this.parseConfigurationModel(e.userRemote, t),
				l = this.parseConfigurationModel(e.workspace, t),
				d = e.folders.reduce(
					(c, u) => (c.set(b.revive(u[0]), this.parseConfigurationModel(u[1], t)), c),
					new ft(),
				)
			return new o(n, r, i, s, a, l, d, xr.createEmptyModel(t), new ft(), t)
		}
		static parseConfigurationModel(e, t) {
			return new xr(e.contents, e.keys, e.overrides, e.raw, t)
		}
	}
var Ux = class {
	constructor(e, t, n, r, i) {
		this.change = e
		this.previous = t
		this.currentConfiguraiton = n
		this.currentWorkspace = r
		this.logService = i
		this._marker = `
`
		this._markerCode1 = this._marker.charCodeAt(0)
		this._markerCode2 = 46
		this.affectedKeys = new Set()
		this._previousConfiguration = void 0
		for (let s of e.keys) this.affectedKeys.add(s)
		for (let [, s] of e.overrides) for (let a of s) this.affectedKeys.add(a)
		this._affectsConfigStr = this._marker
		for (let s of this.affectedKeys) this._affectsConfigStr += s + this._marker
	}
	get previousConfiguration() {
		return (
			!this._previousConfiguration &&
				this.previous &&
				(this._previousConfiguration = up.parse(this.previous.data, this.logService)),
			this._previousConfiguration
		)
	}
	affectsConfiguration(e, t) {
		let n = this._marker + e,
			r = this._affectsConfigStr.indexOf(n)
		if (r < 0) return !1
		let i = r + n.length
		if (i >= this._affectsConfigStr.length) return !1
		let s = this._affectsConfigStr.charCodeAt(i)
		if (s !== this._markerCode1 && s !== this._markerCode2) return !1
		if (t) {
			let a = this.previousConfiguration
					? this.previousConfiguration.getValue(e, t, this.previous?.workspace)
					: void 0,
				l = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace)
			return !nn(a, l)
		}
		return !0
	}
}
function sl(o, e) {
	let { added: t, removed: n, updated: r } = i2(e?.rawConfiguration, o?.rawConfiguration),
		i = [],
		s = o?.getAllOverrideIdentifiers() || [],
		a = e?.getAllOverrideIdentifiers() || []
	if (e) {
		let l = a.filter((d) => !s.includes(d))
		for (let d of l) i.push([d, e.getKeysForOverrideIdentifier(d)])
	}
	if (o) {
		let l = s.filter((d) => !a.includes(d))
		for (let d of l) i.push([d, o.getKeysForOverrideIdentifier(d)])
	}
	if (e && o) {
		for (let l of s)
			if (a.includes(l)) {
				let d = i2(
					{ contents: o.getOverrideValue(void 0, l) || {}, keys: o.getKeysForOverrideIdentifier(l) },
					{ contents: e.getOverrideValue(void 0, l) || {}, keys: e.getKeysForOverrideIdentifier(l) },
				)
				i.push([l, [...d.added, ...d.removed, ...d.updated]])
			}
	}
	return { added: t, removed: n, updated: r, overrides: i }
}
function i2(o, e) {
	let t = o ? (e ? o.keys.filter((i) => e.keys.indexOf(i) === -1) : [...o.keys]) : [],
		n = e ? (o ? e.keys.filter((i) => o.keys.indexOf(i) === -1) : [...e.keys]) : [],
		r = []
	if (o && e) {
		for (let i of e.keys)
			if (o.keys.indexOf(i) !== -1) {
				let s = rg(e.contents, i),
					a = rg(o.contents, i)
				nn(s, a) || r.push(i)
			}
	}
	return { added: t, removed: n, updated: r }
}
function Hx(o, e) {
	if (e) {
		let t = e.split("."),
			n = o
		for (let r = 0; n && r < t.length; r++) n = n[t[r]]
		return n
	}
}
function p8(o) {
	return o instanceof b
}
function m8(o) {
	return o && o.uri instanceof b && o.languageId && typeof o.languageId == "string"
}
function f8(o) {
	return o && !o.uri && o.languageId && typeof o.languageId == "string"
}
function g8(o) {
	return o && o.uri instanceof b && (!o.name || typeof o.name == "string") && (!o.index || typeof o.index == "number")
}
function s2(o) {
	if (p8(o)) return { resource: o }
	if (m8(o)) return { resource: o.uri, overrideIdentifier: o.languageId }
	if (f8(o)) return { overrideIdentifier: o.languageId }
	if (g8(o)) return { resource: o.uri }
	if (o === null) return { resource: null }
}
var pp = class {
	constructor(e, t, n) {
		;(this._proxy = e.getProxy(M.MainThreadConfiguration)),
			(this._extHostWorkspace = t),
			(this._logService = n),
			(this._barrier = new dn()),
			(this._actual = null)
	}
	getConfigProvider() {
		return this._barrier.wait().then((e) => this._actual)
	}
	$initializeConfiguration(e) {
		;(this._actual = new Dk(this._proxy, this._extHostWorkspace, e, this._logService)), this._barrier.open()
	}
	$acceptConfigurationChanged(e, t) {
		this.getConfigProvider().then((n) => n.$acceptConfigurationChanged(e, t))
	}
}
pp = R([S(0, ie), S(1, Sn), S(2, te)], pp)
var Dk = class {
		constructor(e, t, n, r) {
			this._onDidChangeConfiguration = new E()
			;(this._proxy = e),
				(this._logService = r),
				(this._extHostWorkspace = t),
				(this._configuration = up.parse(n, r)),
				(this._configurationScopes = this._toMap(n.configurationScopes))
		}
		get onDidChangeConfiguration() {
			return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event
		}
		$acceptConfigurationChanged(e, t) {
			let n = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace }
			;(this._configuration = up.parse(e, this._logService)),
				(this._configurationScopes = this._toMap(e.configurationScopes)),
				this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(t, n))
		}
		getConfiguration(e, t, n) {
			console.log("getConfiguration", e, t, n)
			let r = s2(t) || {},
				i = this._toReadonlyValue(this._configuration.getValue(e, r, this._extHostWorkspace.workspace))
			e && this._validateConfigurationAccess(e, r, n?.identifier)
			function s(l) {
				if (l == null) return null
				if (typeof l == "boolean") return l ? 2 : 5
				switch (l) {
					case 1:
						return 2
					case 2:
						return 5
					case 3:
						return 6
				}
			}
			let a = {
				has(l) {
					return typeof Hx(i, l) < "u"
				},
				get: (l, d) => {
					this._validateConfigurationAccess(e ? `${e}.${l}` : l, r, n?.identifier)
					let c = Hx(i, l)
					if (typeof c > "u") c = d
					else {
						let u,
							m = (f, h) => {
								if (dt(f)) {
									let g,
										I = () => {
											;(u = u || je(i)), (g = g || Hx(u, h))
										}
									return new Proxy(f, {
										get: (C, T) => {
											if (typeof T == "string" && T.toLowerCase() === "tojson")
												return I(), () => g
											if (u) return (g = g || Hx(u, h)), g[T]
											let w = C[T]
											return typeof T == "string" ? m(w, `${h}.${T}`) : w
										},
										set: (C, T, w) => (I(), g && (g[T] = w), !0),
										deleteProperty: (C, T) => (I(), g && delete g[T], !0),
										defineProperty: (C, T, w) => (I(), g && Object.defineProperty(g, T, w), !0),
									})
								}
								return Array.isArray(f) ? je(f) : f
							}
						c = m(c, l)
					}
					return c
				},
				update: (l, d, c, u) => {
					l = e ? `${e}.${l}` : l
					let m = s(c)
					return d !== void 0
						? this._proxy.$updateConfigurationOption(m, l, d, r, u)
						: this._proxy.$removeConfigurationOption(m, l, r, u)
				},
				inspect: (l) => {
					l = e ? `${e}.${l}` : l
					let d = this._configuration.inspect(l, r, this._extHostWorkspace.workspace)
					if (d)
						return {
							key: l,
							defaultValue: je(d.policy?.value ?? d.default?.value),
							globalLocalValue: je(d.userLocal?.value),
							globalRemoteValue: je(d.userRemote?.value),
							globalValue: je(d.user?.value ?? d.application?.value),
							workspaceValue: je(d.workspace?.value),
							workspaceFolderValue: je(d.workspaceFolder?.value),
							defaultLanguageValue: je(d.default?.override),
							globalLocalLanguageValue: je(d.userLocal?.override),
							globalRemoteLanguageValue: je(d.userRemote?.override),
							globalLanguageValue: je(d.user?.override ?? d.application?.override),
							workspaceLanguageValue: je(d.workspace?.override),
							workspaceFolderLanguageValue: je(d.workspaceFolder?.override),
							languageIds: je(d.overrideIdentifiers),
						}
				},
			}
			return typeof i == "object" && gr(a, i, !1), Object.freeze(a)
		}
		_toReadonlyValue(e) {
			let t = (n) =>
				dt(n)
					? new Proxy(n, {
							get: (r, i) => t(r[i]),
							set: (r, i, s) => {
								throw new Error(
									`TypeError: Cannot assign to read only property '${String(i)}' of object`,
								)
							},
							deleteProperty: (r, i) => {
								throw new Error(`TypeError: Cannot delete read only property '${String(i)}' of object`)
							},
							defineProperty: (r, i) => {
								throw new Error(
									`TypeError: Cannot define property '${String(i)}' for a readonly object`,
								)
							},
							setPrototypeOf: (r) => {
								throw new Error("TypeError: Cannot set prototype for a readonly object")
							},
							isExtensible: () => !1,
							preventExtensions: () => !0,
						})
					: n
			return t(e)
		}
		_validateConfigurationAccess(e, t, n) {
			let r = go.test(e) ? 5 : this._configurationScopes.get(e),
				i = n ? `[${n.value}] ` : ""
			if (5 === r) {
				typeof t?.resource > "u" &&
					this._logService.warn(
						`${i}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${e}', provide the URI of a resource or 'null' for any resource.`,
					)
				return
			}
			if (4 === r) {
				t?.resource &&
					this._logService.warn(
						`${i}Accessing a window scoped configuration for a resource is not expected. To associate '${e}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`,
					)
				return
			}
		}
		_toConfigurationChangeEvent(e, t) {
			let n = new Ux(e, t, this._configuration, this._extHostWorkspace.workspace, this._logService)
			return Object.freeze({ affectsConfiguration: (r, i) => n.affectsConfiguration(r, s2(i)) })
		}
		_toMap(e) {
			return e.reduce((t, n) => (t.set(n[0], n[1]), t), new Map())
		}
	},
	pn = O("IExtHostConfiguration")
var kk = class {
		constructor(e, t) {
			this.versionId = e
			this.removedDueToLooping = t
		}
	},
	$s = class o {
		constructor(e, t) {
			this._activationEventsReader = e
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this._versionId = 0
			;(this._extensionDescriptions = t), this._initialize()
		}
		static isHostExtension(e, t, n) {
			if (t.getExtensionDescription(e)) return !1
			let r = n.getExtensionDescription(e)
			return r ? !!((r.main || r.browser) && r.api === "none") : !1
		}
		_initialize() {
			this._extensionDescriptions.sort(h8),
				(this._extensionsMap = new Ln()),
				(this._extensionsArr = []),
				(this._activationMap = new Map())
			for (let e of this._extensionDescriptions) {
				if (this._extensionsMap.has(e.identifier)) {
					console.error("Extension `" + e.identifier.value + "` is already registered")
					continue
				}
				this._extensionsMap.set(e.identifier, e), this._extensionsArr.push(e)
				let t = this._activationEventsReader.readActivationEvents(e)
				for (let n of t)
					this._activationMap.has(n) || this._activationMap.set(n, []), this._activationMap.get(n).push(e)
			}
		}
		set(e) {
			return (
				(this._extensionDescriptions = e),
				this._initialize(),
				this._versionId++,
				this._onDidChange.fire(void 0),
				{ versionId: this._versionId }
			)
		}
		deltaExtensions(e, t) {
			;(this._extensionDescriptions = l2(this._extensionDescriptions, t)),
				(this._extensionDescriptions = this._extensionDescriptions.concat(e))
			let n = o._findLoopingExtensions(this._extensionDescriptions)
			return (
				(this._extensionDescriptions = l2(
					this._extensionDescriptions,
					n.map((r) => r.identifier),
				)),
				this._initialize(),
				this._versionId++,
				this._onDidChange.fire(void 0),
				new kk(this._versionId, n)
			)
		}
		static _findLoopingExtensions(e) {
			let t = new (class {
					constructor() {
						this._arcs = new Map()
						this._nodesSet = new Set()
						this._nodesArr = []
					}
					addNode(a) {
						this._nodesSet.has(a) || (this._nodesSet.add(a), this._nodesArr.push(a))
					}
					addArc(a, l) {
						this.addNode(a),
							this.addNode(l),
							this._arcs.has(a) ? this._arcs.get(a).push(l) : this._arcs.set(a, [l])
					}
					getArcs(a) {
						return this._arcs.has(a) ? this._arcs.get(a) : []
					}
					hasOnlyGoodArcs(a, l) {
						let d = t.getArcs(a)
						for (let c = 0; c < d.length; c++) if (!l.has(d[c])) return !1
						return !0
					}
					getNodes() {
						return this._nodesArr
					}
				})(),
				n = new Ln()
			for (let a of e)
				if ((n.set(a.identifier, a), a.extensionDependencies))
					for (let l of a.extensionDependencies) t.addArc(Ce.toKey(a.identifier), Ce.toKey(l))
			let r = new Set()
			t.getNodes()
				.filter((a) => t.getArcs(a).length === 0)
				.forEach((a) => r.add(a))
			let i = t.getNodes().filter((a) => !r.has(a)),
				s
			do {
				s = !1
				for (let a = 0; a < i.length; a++) {
					let l = i[a]
					t.hasOnlyGoodArcs(l, r) && (i.splice(a, 1), a--, r.add(l), (s = !0))
				}
			} while (s)
			return i.map((a) => n.get(a))
		}
		containsActivationEvent(e) {
			return this._activationMap.has(e)
		}
		containsExtension(e) {
			return this._extensionsMap.has(e)
		}
		getExtensionDescriptionsForActivationEvent(e) {
			let t = this._activationMap.get(e)
			return t ? t.slice(0) : []
		}
		getAllExtensionDescriptions() {
			return this._extensionsArr.slice(0)
		}
		getSnapshot() {
			return new Rk(this._versionId, this.getAllExtensionDescriptions())
		}
		getExtensionDescription(e) {
			let t = this._extensionsMap.get(e)
			return t || void 0
		}
		getExtensionDescriptionByUUID(e) {
			for (let t of this._extensionsArr) if (t.uuid === e) return t
		}
		getExtensionDescriptionByIdOrUUID(e, t) {
			return this.getExtensionDescription(e) ?? (t ? this.getExtensionDescriptionByUUID(t) : void 0)
		}
	},
	Rk = class {
		constructor(e, t) {
			this.versionId = e
			this.extensions = t
		}
	}
function h8(o, e) {
	let t = o.isBuiltin ? 0 : o.isUnderDevelopment ? 2 : 1,
		n = e.isBuiltin ? 0 : e.isUnderDevelopment ? 2 : 1
	if (t !== n) return t - n
	let r = Ue.basename(o.extensionLocation.path),
		i = Ue.basename(e.extensionLocation.path)
	return r < i ? -1 : r > i ? 1 : 0
}
function l2(o, e) {
	let t = new ar(e)
	return o.filter((n) => !t.has(n.identifier))
}
var Md = class o {
		static {
			this.NONE = new o(!1, -1, -1, -1)
		}
		constructor(e, t, n, r) {
			;(this.startup = e),
				(this.codeLoadingTime = t),
				(this.activateCallTime = n),
				(this.activateResolvedTime = r)
		}
	},
	fp = class {
		constructor(e) {
			;(this._startup = e),
				(this._codeLoadingStart = -1),
				(this._codeLoadingStop = -1),
				(this._activateCallStart = -1),
				(this._activateCallStop = -1),
				(this._activateResolveStart = -1),
				(this._activateResolveStop = -1)
		}
		_delta(e, t) {
			return e === -1 || t === -1 ? -1 : t - e
		}
		build() {
			return new Md(
				this._startup,
				this._delta(this._codeLoadingStart, this._codeLoadingStop),
				this._delta(this._activateCallStart, this._activateCallStop),
				this._delta(this._activateResolveStart, this._activateResolveStop),
			)
		}
		codeLoadingStart() {
			this._codeLoadingStart = Date.now()
		}
		codeLoadingStop() {
			this._codeLoadingStop = Date.now()
		}
		activateCallStart() {
			this._activateCallStart = Date.now()
		}
		activateCallStop() {
			this._activateCallStop = Date.now()
		}
		activateResolveStart() {
			this._activateResolveStart = Date.now()
		}
		activateResolveStop() {
			this._activateResolveStop = Date.now()
		}
	},
	Fd = class {
		constructor(e, t, n, r, i, s) {
			;(this.activationFailed = e),
				(this.activationFailedError = t),
				(this.activationTimes = n),
				(this.module = r),
				(this.exports = i),
				(this.disposable = s)
		}
	},
	Wx = class extends Fd {
		constructor(e) {
			super(!1, null, e, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	Vx = class extends Fd {
		constructor() {
			super(!1, null, Md.NONE, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	gp = class extends Fd {
		constructor(e) {
			super(!0, e, Md.NONE, { activate: void 0, deactivate: void 0 }, void 0, $.None)
		}
	},
	mp = class {
		constructor(e, t, n, r) {
			this._logService = r
			;(this._registry = e),
				(this._globalRegistry = t),
				(this._host = n),
				(this._operations = new Ln()),
				(this._alreadyActivatedEvents = Object.create(null))
		}
		dispose() {
			for (let [e, t] of this._operations) t.dispose()
		}
		async waitForActivatingExtensions() {
			let e = []
			for (let [t, n] of this._operations) e.push(n.wait())
			await Promise.all(e)
		}
		isActivated(e) {
			let t = this._operations.get(e)
			return !!(t && t.value)
		}
		getActivatedExtension(e) {
			let t = this._operations.get(e)
			if (!t || !t.value) throw new Error(`Extension '${e.value}' is not known or not activated`)
			return t.value
		}
		async activateByEvent(e, t) {
			if (this._alreadyActivatedEvents[e]) return
			let n = this._registry.getExtensionDescriptionsForActivationEvent(e)
			await this._activateExtensions(
				n.map((r) => ({
					id: r.identifier,
					reason: { startup: t, extensionId: r.identifier, activationEvent: e },
				})),
			),
				(this._alreadyActivatedEvents[e] = !0)
		}
		activateById(e, t) {
			ht.logIncoming(0, 0, 0, "activateById start: " + e.value)
			let n = this._registry.getExtensionDescription(e)
			if ((ht.logIncoming(0, 0, 0, "activateById desc: " + n), !n))
				throw new Error(`Extension '${e.value}' is not known`)
			return this._activateExtensions([{ id: n.identifier, reason: t }])
		}
		async _activateExtensions(e) {
			let t = e.filter((n) => !this.isActivated(n.id)).map((n) => this._handleActivationRequest(n))
			await Promise.all(t.map((n) => n.wait()))
		}
		_handleActivationRequest(e) {
			if (this._operations.has(e.id)) return this._operations.get(e.id)
			if (this._isHostExtension(e.id)) return this._createAndSaveOperation(e, null, [], null)
			let t = this._registry.getExtensionDescription(e.id)
			if (!t) {
				let i = new Error(`Cannot activate unknown extension '${e.id.value}'`),
					s = this._createAndSaveOperation(e, null, [], new gp(i))
				return this._host.onExtensionActivationError(e.id, i, new sg(e.id.value)), s
			}
			let n = [],
				r = typeof t.extensionDependencies > "u" ? [] : t.extensionDependencies
			for (let i of r) {
				if (this._isResolvedExtension(i)) continue
				let s = this._operations.get(i)
				if (s) {
					n.push(s)
					continue
				}
				if (this._isHostExtension(i)) {
					n.push(
						this._handleActivationRequest({
							id: this._globalRegistry.getExtensionDescription(i).identifier,
							reason: e.reason,
						}),
					)
					continue
				}
				let a = this._registry.getExtensionDescription(i)
				if (a) {
					if (!a.main && !a.browser) continue
					n.push(this._handleActivationRequest({ id: a.identifier, reason: e.reason }))
					continue
				}
				let l = t.displayName || t.identifier.value,
					d = new Error(
						`Cannot activate the '${l}' extension because it depends on unknown extension '${i}'`,
					),
					c = this._createAndSaveOperation(e, t.displayName, [], new gp(d))
				return this._host.onExtensionActivationError(t.identifier, d, new sg(i)), c
			}
			return this._createAndSaveOperation(e, t.displayName, n, null)
		}
		_createAndSaveOperation(e, t, n, r) {
			let i = new Qg(e.id, t, e.reason, n, r, this._host, this._logService)
			return this._operations.set(e.id, i), i
		}
		_isHostExtension(e) {
			return $s.isHostExtension(e, this._registry, this._globalRegistry)
		}
		_isResolvedExtension(e) {
			let t = this._globalRegistry.getExtensionDescription(e)
			return t ? !t.main && !t.browser : !1
		}
	}
mp = R([S(3, te)], mp)
var Qg = class {
	constructor(e, t, n, r, i, s, a) {
		this._id = e
		this._displayName = t
		this._reason = n
		this._deps = r
		this._value = i
		this._host = s
		this._logService = a
		this._barrier = new dn()
		this._isDisposed = !1
		this._initialize()
	}
	get value() {
		return this._value
	}
	get friendlyName() {
		return this._displayName || this._id.value
	}
	dispose() {
		this._isDisposed = !0
	}
	wait() {
		return this._barrier.wait()
	}
	async _initialize() {
		await this._waitForDepsThenActivate(), this._barrier.open()
	}
	async _waitForDepsThenActivate() {
		if (!this._value) {
			for (; this._deps.length > 0; ) {
				for (let e = 0; e < this._deps.length; e++) {
					let t = this._deps[e]
					if (t.value && !t.value.activationFailed) {
						this._deps.splice(e, 1), e--
						continue
					}
					if (t.value && t.value.activationFailed) {
						let n = new Error(
							`Cannot activate the '${this.friendlyName}' extension because its dependency '${t.friendlyName}' failed to activate`,
						)
						;(n.detail = t.value.activationFailedError),
							(this._value = new gp(n)),
							this._host.onExtensionActivationError(this._id, n, null)
						return
					}
				}
				this._deps.length > 0 && (await Promise.race(this._deps.map((e) => e.wait())))
			}
			await this._activate()
		}
	}
	async _activate() {
		try {
			this._value = await this._host.actualActivateExtension(this._id, this._reason)
		} catch (e) {
			let t = new Error()
			if (
				(e && e.name && (t.name = e.name),
				e && e.message
					? (t.message = `Activating extension '${this._id.value}' failed: ${e.message}.`)
					: (t.message = `Activating extension '${this._id.value}' failed: ${e}.`),
				e && e.stack && (t.stack = e.stack),
				(this._value = new gp(t)),
				this._isDisposed && bn(e))
			)
				return
			this._host.onExtensionActivationError(this._id, t, null),
				this._logService.error(`Activating extension ${this._id.value} failed due to an error:`),
				this._logService.error(e)
		}
	}
}
Qg = R([S(6, te)], Qg)
var vp = class {
		constructor(e, t) {
			this._logService = t
			this._onDidChangeStorage = new E()
			this.onDidChangeStorage = this._onDidChangeStorage.event
			this._proxy = e.getProxy(M.MainThreadStorage)
		}
		registerExtensionStorageKeysToSync(e, t) {
			this._proxy.$registerExtensionStorageKeysToSync(e, t)
		}
		async initializeExtensionStorage(e, t, n) {
			let r = await this._proxy.$initializeExtensionStorage(e, t),
				i
			return r && (i = this.safeParseValue(e, t, r)), i || n
		}
		setValue(e, t, n) {
			return this._proxy.$setValue(e, t, n)
		}
		$acceptValue(e, t, n) {
			let r = this.safeParseValue(e, t, n)
			r && this._onDidChangeStorage.fire({ shared: e, key: t, value: r })
		}
		safeParseValue(e, t, n) {
			try {
				return JSON.parse(n)
			} catch (r) {
				this._logService.error(
					`[extHostStorage] unexpected error parsing storage contents (extensionId: ${t}, global: ${e}): ${r}`,
				)
			}
		}
	},
	bp = O("IExtHostStorage")
var Jg = class {
		constructor(e, t, n) {
			this._deferredPromises = new Map()
			;(this._id = e),
				(this._shared = t),
				(this._storage = n),
				(this._init = this._storage
					.initializeExtensionStorage(this._shared, this._id, Object.create(null))
					.then((r) => ((this._value = r), this))),
				(this._storageListener = this._storage.onDidChangeStorage((r) => {
					r.shared === this._shared && r.key === this._id && (this._value = r.value)
				})),
				(this._scheduler = new Wn(() => {
					let r = this._deferredPromises
					;(this._deferredPromises = new Map()),
						(async () => {
							try {
								await this._storage.setValue(this._shared, this._id, this._value)
								for (let i of r.values()) i.complete()
							} catch (i) {
								for (let s of r.values()) s.error(i)
							}
						})()
				}, 0))
		}
		keys() {
			return Object.entries(this._value ?? {})
				.filter(([, e]) => e !== void 0)
				.map(([e]) => e)
		}
		get whenReady() {
			return this._init
		}
		get(e, t) {
			let n = this._value[e]
			return typeof n > "u" && (n = t), n
		}
		update(e, t) {
			t !== null && typeof t == "object" ? (this._value[e] = JSON.parse(JSON.stringify(t))) : (this._value[e] = t)
			let n = this._deferredPromises.get(e)
			if (n !== void 0) return n.p
			let r = new Cn()
			return this._deferredPromises.set(e, r), this._scheduler.isScheduled() || this._scheduler.schedule(), r.p
		}
		dispose() {
			this._storageListener.dispose()
		}
	},
	Bx = class extends Jg {
		setKeysForSync(e) {
			this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, e)
		}
		constructor(e, t) {
			super(e.identifier.value, !0, t), (this._extension = e)
		}
	}
var Cr = class {
	constructor(e, t) {
		this._fileSystemProvider = new Map()
		this._writeQueue = new Pc()
		this._proxy = e.getProxy(M.MainThreadFileSystem)
		let n = this
		this.value = Object.freeze({
			async stat(r) {
				try {
					let i,
						s = n._fileSystemProvider.get(r.scheme)
					return (
						s
							? (await n._proxy.$ensureActivation(r.scheme), (i = await s.impl.stat(r)))
							: (i = await n._proxy.$stat(r)),
						{
							type: i.type,
							ctime: i.ctime,
							mtime: i.mtime,
							size: i.size,
							permissions: i.permissions === 1 ? 1 : void 0,
						}
					)
				} catch (i) {
					Cr._handleError(i)
				}
			},
			async readDirectory(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i
						? (await n._proxy.$ensureActivation(r.scheme), (await i.impl.readDirectory(r)).slice())
						: await n._proxy.$readdir(r)
				} catch (i) {
					return Cr._handleError(i)
				}
			},
			async createDirectory(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i && !i.isReadonly
						? (await n._proxy.$ensureActivation(r.scheme), await n.mkdirp(i.impl, i.extUri, r))
						: await n._proxy.$mkdir(r)
				} catch (i) {
					return Cr._handleError(i)
				}
			},
			async readFile(r) {
				try {
					let i = n._fileSystemProvider.get(r.scheme)
					return i
						? (await n._proxy.$ensureActivation(r.scheme), (await i.impl.readFile(r)).slice())
						: (await n._proxy.$readFile(r)).buffer
				} catch (i) {
					return Cr._handleError(i)
				}
			},
			async writeFile(r, i) {
				try {
					let s = n._fileSystemProvider.get(r.scheme)
					return s && !s.isReadonly
						? (await n._proxy.$ensureActivation(r.scheme),
							await n.mkdirp(s.impl, s.extUri, s.extUri.dirname(r)),
							await n._writeQueue.queueFor(r, () =>
								Promise.resolve(s.impl.writeFile(r, i, { create: !0, overwrite: !0 })),
							))
						: await n._proxy.$writeFile(r, z.wrap(i))
				} catch (s) {
					return Cr._handleError(s)
				}
			},
			async delete(r, i) {
				try {
					let s = n._fileSystemProvider.get(r.scheme)
					return s && !s.isReadonly && !i?.useTrash
						? (await n._proxy.$ensureActivation(r.scheme), await s.impl.delete(r, { recursive: !1, ...i }))
						: await n._proxy.$delete(r, { recursive: !1, useTrash: !1, atomic: !1, ...i })
				} catch (s) {
					return Cr._handleError(s)
				}
			},
			async rename(r, i, s) {
				try {
					return await n._proxy.$rename(r, i, { overwrite: !1, ...s })
				} catch (a) {
					return Cr._handleError(a)
				}
			},
			async copy(r, i, s) {
				try {
					return await n._proxy.$copy(r, i, { overwrite: !1, ...s })
				} catch (a) {
					return Cr._handleError(a)
				}
			},
			isWritableFileSystem(r) {
				let i = t.getCapabilities(r)
				if (typeof i == "number") return !(i & 2048)
			},
		})
	}
	async mkdirp(e, t, n) {
		let r = []
		for (; !t.isEqual(n, t.dirname(n)); )
			try {
				if (((await e.stat(n)).type & 2) === 0)
					throw rt.FileExists(
						`Unable to create folder '${n.scheme === W.file ? n.fsPath : n.toString(!0)}' that already exists but is not a directory`,
					)
				break
			} catch (i) {
				if ($c(i) !== "EntryNotFound") throw i
				r.push(t.basename(n)), (n = t.dirname(n))
			}
		for (let i = r.length - 1; i >= 0; i--) {
			n = t.joinPath(n, r[i])
			try {
				await e.createDirectory(n)
			} catch (s) {
				if ($c(s) !== "EntryExists") throw s
			}
		}
	}
	static _handleError(e) {
		if (e instanceof rt) throw e
		if (e instanceof ba)
			switch (e.code) {
				case "EntryExists":
					throw rt.FileExists(e.message)
				case "EntryNotFound":
					throw rt.FileNotFound(e.message)
				case "EntryNotADirectory":
					throw rt.FileNotADirectory(e.message)
				case "EntryIsADirectory":
					throw rt.FileIsADirectory(e.message)
				case "NoPermissions":
					throw rt.NoPermissions(e.message)
				case "Unavailable":
					throw rt.Unavailable(e.message)
				default:
					throw new rt(e.message, e.name)
			}
		if (!(e instanceof Error)) throw new rt(String(e))
		if (e.name === "ENOPRO" || e.message.includes("ENOPRO")) throw rt.Unavailable(e.message)
		switch (e.name) {
			case "EntryExists":
				throw rt.FileExists(e.message)
			case "EntryNotFound":
				throw rt.FileNotFound(e.message)
			case "EntryNotADirectory":
				throw rt.FileNotADirectory(e.message)
			case "EntryIsADirectory":
				throw rt.FileIsADirectory(e.message)
			case "NoPermissions":
				throw rt.NoPermissions(e.message)
			case "Unavailable":
				throw rt.Unavailable(e.message)
			default:
				throw new rt(e.message, e.name)
		}
	}
	addFileSystemProvider(e, t, n) {
		return (
			this._fileSystemProvider.set(e, {
				impl: t,
				extUri: n?.isCaseSensitive ? et : BE,
				isReadonly: !!n?.isReadonly,
			}),
			q(() => this._fileSystemProvider.delete(e))
		)
	}
	getFileSystemProviderExtUri(e) {
		return this._fileSystemProvider.get(e)?.extUri ?? et
	}
}
Cr = R([S(0, ie), S(1, po)], Cr)
var Fi = O("IExtHostConsumerFileSystem")
var Ip = O("IExtensionStoragePaths"),
	yp = class {
		constructor(e, t, n) {
			this._logService = t
			this._extHostFileSystem = n
			;(this._workspace = e.workspace ?? void 0),
				(this._environment = e.environment),
				(this.whenReady = this._getOrCreateWorkspaceStoragePath().then((r) => (this._value = r)))
		}
		async _getWorkspaceStorageURI(e) {
			return b.joinPath(this._environment.workspaceStorageHome, e)
		}
		async _getOrCreateWorkspaceStoragePath() {
			if (!this._workspace) return Promise.resolve(void 0)
			let e = this._workspace.id,
				t = await this._getWorkspaceStorageURI(e)
			try {
				return (
					await this._extHostFileSystem.value.stat(t),
					this._logService.trace("[ExtHostStorage] storage dir already exists", t),
					t
				)
			} catch {}
			try {
				return (
					this._logService.trace("[ExtHostStorage] creating dir and metadata-file", t),
					await this._extHostFileSystem.value.createDirectory(t),
					await this._extHostFileSystem.value.writeFile(
						b.joinPath(t, "meta.json"),
						new TextEncoder().encode(
							JSON.stringify(
								{
									id: this._workspace.id,
									configuration: b.revive(this._workspace.configuration)?.toString(),
									name: this._workspace.name,
								},
								void 0,
								2,
							),
						),
					),
					t
				)
			} catch (n) {
				this._logService.error("[ExtHostStorage]", n)
				return
			}
		}
		workspaceValue(e) {
			if (this._value) return b.joinPath(this._value, e.identifier.value)
		}
		globalValue(e) {
			return b.joinPath(this._environment.globalStorageHome, e.identifier.value.toLowerCase())
		}
		onWillDeactivateAll() {}
	}
yp = R([S(0, Xe), S(1, te), S(2, Fi)], yp)
var d2 = O("tunnelService"),
	bhe = O("sharedTunnelsService")
function c2(o) {
	return !!o.forwardPort
}
function v8(o) {
	if (o.scheme !== "http" && o.scheme !== "https") return
	let e = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(o.authority)
	if (e) return { address: e[1], port: +e[2] }
}
var Cp = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"]
function Ni(o) {
	return Cp.indexOf(o) >= 0
}
var Xg = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"]
function To(o) {
	return Xg.indexOf(o) >= 0
}
function u2(o, e, t, n) {
	if (t === 1) return !1
	if (t === 2 && To(e)) {
		let r = /(\d+)\.(\d+)\.(\d+)/g.exec(n)
		if (r?.length === 4 && parseInt(r[1]) >= 18) return !1
	}
	return o < 1024
}
var $x = class {
		constructor(e, t, n) {
			this.remoteAddress = e
			this.localAddress = t
			this._dispose = n
			this._onDispose = new E()
			this.onDidDispose = this._onDispose.event
		}
		dispose() {
			return this._onDispose.fire(), this._dispose()
		}
	},
	xp = class extends $ {
		constructor(t, n) {
			super()
			this.logService = t
			this.configurationService = n
			this._onTunnelOpened = new E()
			this.onTunnelOpened = this._onTunnelOpened.event
			this._onTunnelClosed = new E()
			this.onTunnelClosed = this._onTunnelClosed.event
			this._onAddedTunnelProvider = new E()
			this.onAddedTunnelProvider = this._onAddedTunnelProvider.event
			this._tunnels = new Map()
			this._canElevate = !1
			this._canChangeProtocol = !0
			this._privacyOptions = []
			this._factoryInProgress = new Set()
		}
		get hasTunnelProvider() {
			return !!this._tunnelProvider
		}
		get defaultTunnelHost() {
			let t = this.configurationService.getValue("remote.localPortHost")
			return !t || t === "localhost" ? "127.0.0.1" : "0.0.0.0"
		}
		setTunnelProvider(t) {
			return (
				(this._tunnelProvider = t),
				t
					? (this._onAddedTunnelProvider.fire(),
						{
							dispose: () => {
								;(this._tunnelProvider = void 0), (this._canElevate = !1), (this._privacyOptions = [])
							},
						})
					: ((this._canElevate = !1),
						(this._privacyOptions = []),
						this._onAddedTunnelProvider.fire(),
						{ dispose: () => {} })
			)
		}
		setTunnelFeatures(t) {
			;(this._canElevate = t.elevation),
				(this._privacyOptions = t.privacyOptions),
				(this._canChangeProtocol = t.protocol)
		}
		get canChangeProtocol() {
			return this._canChangeProtocol
		}
		get canElevate() {
			return this._canElevate
		}
		get canChangePrivacy() {
			return this._privacyOptions.length > 0
		}
		get privacyOptions() {
			return this._privacyOptions
		}
		get tunnels() {
			return this.getTunnels()
		}
		async getTunnels() {
			let t = [],
				n = Array.from(this._tunnels.values())
			for (let r of n) {
				let i = Array.from(r.values())
				for (let s of i) {
					let a = await s.value
					a && typeof a != "string" && t.push(a)
				}
			}
			return t
		}
		async dispose() {
			super.dispose()
			for (let t of this._tunnels.values()) {
				for (let { value: n } of t.values()) await n.then((r) => (typeof r != "string" ? r?.dispose() : void 0))
				t.clear()
			}
			this._tunnels.clear()
		}
		setEnvironmentTunnel(t, n, r, i, s) {
			this.addTunnelToMap(
				t,
				n,
				Promise.resolve({
					tunnelRemoteHost: t,
					tunnelRemotePort: n,
					localAddress: r,
					privacy: i,
					protocol: s,
					dispose: () => Promise.resolve(),
				}),
			)
		}
		async getExistingTunnel(t, n) {
			;(To(t) || Ni(t)) && (t = Cp[0])
			let r = this.getTunnelFromMap(t, n)
			if (r) return ++r.refcount, r.value
		}
		openTunnel(t, n, r, i, s, a = !1, l, d) {
			this.logService.trace(
				`ForwardedPorts: (TunnelService) openTunnel request for ${n}:${r} on local port ${s}.`,
			)
			let c = this._tunnelProvider ?? t
			if (!c) return
			if (
				(n || (n = "localhost"),
				i || (i = this.defaultTunnelHost),
				this._tunnelProvider && this._factoryInProgress.has(r))
			) {
				this.logService.debug(
					"ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.",
				)
				return
			}
			let u = this.retainOrCreateTunnel(c, n, r, i, s, a, l, d)
			return u
				? u.then((m) => {
						if (m) {
							if (typeof m == "string")
								return (
									this.logService.trace(
										"ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.",
									),
									this.removeEmptyOrErrorTunnelFromMap(n, r),
									m
								)
						} else {
							this.logService.trace("ForwardedPorts: (TunnelService) New tunnel is undefined."),
								this.removeEmptyOrErrorTunnelFromMap(n, r)
							return
						}
						this.logService.trace("ForwardedPorts: (TunnelService) New tunnel established.")
						let f = this.makeTunnel(m)
						return (
							(m.tunnelRemoteHost !== n || m.tunnelRemotePort !== r) &&
								this.logService.warn(
									"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.",
								),
							l &&
								m.privacy !== l &&
								this.logService.warn(
									"ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.",
								),
							this._onTunnelOpened.fire(f),
							f
						)
					})
				: (this.logService.trace("ForwardedPorts: (TunnelService) Tunnel was not created."), u)
		}
		makeTunnel(t) {
			return {
				tunnelRemotePort: t.tunnelRemotePort,
				tunnelRemoteHost: t.tunnelRemoteHost,
				tunnelLocalPort: t.tunnelLocalPort,
				localAddress: t.localAddress,
				privacy: t.privacy,
				protocol: t.protocol,
				dispose: async () => {
					this.logService.trace(
						`ForwardedPorts: (TunnelService) dispose request for ${t.tunnelRemoteHost}:${t.tunnelRemotePort} `,
					)
					let n = this._tunnels.get(t.tunnelRemoteHost)
					if (n) {
						let r = n.get(t.tunnelRemotePort)
						r && (r.refcount--, await this.tryDisposeTunnel(t.tunnelRemoteHost, t.tunnelRemotePort, r))
					}
				},
			}
		}
		async tryDisposeTunnel(t, n, r) {
			if (r.refcount <= 0) {
				this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${t}:${n}.`)
				let i = r.value.then(async (s) => {
					s &&
						typeof s != "string" &&
						(await s.dispose(!0),
						this._onTunnelClosed.fire({ host: s.tunnelRemoteHost, port: s.tunnelRemotePort }))
				})
				return this._tunnels.has(t) && this._tunnels.get(t).delete(n), i
			}
		}
		async closeTunnel(t, n) {
			this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${t}:${n} `)
			let r = this._tunnels.get(t)
			if (r && r.has(n)) {
				let i = r.get(n)
				;(i.refcount = 0), await this.tryDisposeTunnel(t, n, i)
			}
		}
		addTunnelToMap(t, n, r) {
			this._tunnels.has(t) || this._tunnels.set(t, new Map()),
				this._tunnels.get(t).set(n, { refcount: 1, value: r })
		}
		async removeEmptyOrErrorTunnelFromMap(t, n) {
			let r = this._tunnels.get(t)
			if (r) {
				let i = r.get(n),
					s = i ? await i.value : void 0
				;(!s || typeof s == "string") && r.delete(n), r.size === 0 && this._tunnels.delete(t)
			}
		}
		getTunnelFromMap(t, n) {
			let r = [t]
			Ni(t) ? (r.push(...Cp), r.push(...Xg)) : To(t) && r.push(...Xg)
			let i = r.map((s) => this._tunnels.get(s))
			for (let s of i) {
				let a = s?.get(n)
				if (a) return a
			}
		}
		canTunnel(t) {
			return !!v8(t)
		}
		createWithProvider(t, n, r, i, s, a, l) {
			this.logService.trace(
				`ForwardedPorts: (TunnelService) Creating tunnel with provider ${n}:${r} on local port ${i}.`,
			)
			let d = r
			this._factoryInProgress.add(d)
			let c = i === void 0 ? r : i,
				u = { elevationRequired: s ? this.isPortPrivileged(c) : !1 },
				m = {
					remoteAddress: { host: n, port: r },
					localAddressPort: i,
					privacy: a,
					public: a ? a !== "private" : void 0,
					protocol: l,
				},
				f = t.forwardPort(m, u)
			return (
				f
					? (this.addTunnelToMap(n, r, f),
						f.finally(() => {
							this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created by provider."),
								this._factoryInProgress.delete(d)
						}))
					: this._factoryInProgress.delete(d),
				f
			)
		}
	}
xp = R([S(0, te), S(1, br)], xp)
var Ak = class extends $x {},
	m2
;((t) => {
	function o(n) {
		return {
			remoteAddress: n.remoteAddress,
			localAddress: n.localAddress,
			public: !!n.public,
			privacy: n.privacy ?? (n.public ? "public" : "private"),
			protocol: n.protocol,
		}
	}
	t.fromApiTunnel = o
	function e(n) {
		return {
			remoteAddress: { host: n.tunnelRemoteHost, port: n.tunnelRemotePort },
			localAddress: n.localAddress,
			public: n.privacy !== "constantPrivate" && n.privacy !== "constantPrivate",
			privacy: n.privacy,
			protocol: n.protocol,
		}
	}
	t.fromServiceTunnel = e
})((m2 ||= {}))
var ll = O("IExtHostTunnelService"),
	al = class extends $ {
		constructor(t, n, r) {
			super()
			this.logService = r
			this._showCandidatePort = () => Promise.resolve(!0)
			this._extensionTunnels = new Map()
			this._onDidChangeTunnels = new E()
			this.onDidChangeTunnels = this._onDidChangeTunnels.event
			this._providerHandleCounter = 0
			this._portAttributesProviders = new Map()
			this._proxy = t.getProxy(M.MainThreadTunnelService)
		}
		async openTunnel(t, n) {
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) ${t.identifier.value} called openTunnel API for ${n.remoteAddress.host}:${n.remoteAddress.port}.`,
			)
			let r = await this._proxy.$openTunnel(n, t.displayName)
			if (r) {
				let i = new Ak(r.remoteAddress, r.localAddress, () => this._proxy.$closeTunnel(r.remoteAddress))
				return this._register(i), i
			}
		}
		async getTunnels() {
			return this._proxy.$getTunnels()
		}
		nextPortAttributesProviderHandle() {
			return this._providerHandleCounter++
		}
		registerPortsAttributesProvider(t, n) {
			t.portRange === void 0 &&
				t.commandPattern === void 0 &&
				this.logService.error("PortAttributesProvider must specify either a portRange or a commandPattern")
			let r = this.nextPortAttributesProviderHandle()
			return (
				this._portAttributesProviders.set(r, { selector: t, provider: n }),
				this._proxy.$registerPortsAttributesProvider(t, r),
				new ye(() => {
					this._portAttributesProviders.delete(r), this._proxy.$unregisterPortsAttributesProvider(r)
				})
			)
		}
		async $providePortAttributes(t, n, r, i, s) {
			let a = []
			for (let d of t) {
				let c = this._portAttributesProviders.get(d)
				if (!c) return []
				a.push(
					...(await Promise.all(
						n.map(async (u) => {
							let m
							try {
								m = await c.provider.providePortAttributes({ port: u, pid: r, commandLine: i }, s)
							} catch {
								m = await c.provider.providePortAttributes(u, r, i, s)
							}
							return { providedAttributes: m, port: u }
						}),
					)),
				)
			}
			let l = a.filter((d) => !!d.providedAttributes)
			return l.length > 0
				? l.map((d) => ({ autoForwardAction: d.providedAttributes.autoForwardAction, port: d.port }))
				: []
		}
		async $registerCandidateFinder(t) {}
		registerTunnelProvider(t, n) {
			if (this._forwardPortProvider)
				throw new Error(
					"A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.",
				)
			this._forwardPortProvider = async (i, s) => (await t.provideTunnel(i, s, De.None)) ?? void 0
			let r = n.tunnelFeatures
				? {
						elevation: !!n.tunnelFeatures?.elevation,
						privacyOptions: n.tunnelFeatures?.privacyOptions,
						protocol: n.tunnelFeatures.protocol === void 0 ? !0 : n.tunnelFeatures.protocol,
					}
				: void 0
			return (
				this._proxy.$setTunnelProvider(r, !0),
				Promise.resolve(
					q(() => {
						;(this._forwardPortProvider = void 0), this._proxy.$setTunnelProvider(void 0, !1)
					}),
				)
			)
		}
		async setTunnelFactory(t, n) {
			if (t) {
				t.candidatePortSource !== void 0 && this._proxy.$setCandidatePortSource(t.candidatePortSource),
					t.showCandidatePort &&
						((this._showCandidatePort = t.showCandidatePort), this._proxy.$setCandidateFilter())
				let r = t.tunnelFactory ?? (n ? this.makeManagedTunnelFactory(n) : void 0)
				if (r) {
					this._forwardPortProvider = r
					let i = t.tunnelFeatures?.privacyOptions ?? []
					t.tunnelFeatures?.public &&
						i.length === 0 &&
						(i = [
							{ id: "private", label: p("tunnelPrivacy.private", "Private"), themeIcon: "lock" },
							{ id: "public", label: p("tunnelPrivacy.public", "Public"), themeIcon: "eye" },
						])
					let s = t.tunnelFeatures
						? {
								elevation: !!t.tunnelFeatures?.elevation,
								public: !!t.tunnelFeatures?.public,
								privacyOptions: i,
								protocol: !0,
							}
						: void 0
					this._proxy.$setTunnelProvider(s, !!t.tunnelFactory)
				}
			} else this._forwardPortProvider = void 0
			return q(() => {
				this._forwardPortProvider = void 0
			})
		}
		makeManagedTunnelFactory(t) {}
		async $closeTunnel(t, n) {
			if (this._extensionTunnels.has(t.host)) {
				let r = this._extensionTunnels.get(t.host)
				r.has(t.port) &&
					(n && r.get(t.port).disposeListener.dispose(),
					await r.get(t.port).tunnel.dispose(),
					r.delete(t.port))
			}
		}
		async $onDidTunnelsChange() {
			this._onDidChangeTunnels.fire()
		}
		async $forwardPort(t, n) {
			if (this._forwardPortProvider)
				try {
					this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.")
					let r = this._forwardPortProvider(t, n)
					if (
						(this.logService.trace(
							"ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.",
						),
						r !== void 0)
					) {
						let i = await r
						if (
							(this.logService.trace(
								"ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.",
							),
							i === void 0)
						) {
							this.logService.error("ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined")
							return
						}
						this._extensionTunnels.has(t.remoteAddress.host) ||
							this._extensionTunnels.set(t.remoteAddress.host, new Map())
						let s = this._register(
							i.onDidDispose(
								() => (
									this.logService.trace(
										"ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.",
									),
									this._proxy.$closeTunnel(i.remoteAddress)
								),
							),
						)
						return (
							this._extensionTunnels
								.get(t.remoteAddress.host)
								.set(t.remoteAddress.port, { tunnel: i, disposeListener: s }),
							m2.fromApiTunnel(i)
						)
					} else this.logService.trace("ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined")
				} catch (r) {
					if (
						(this.logService.trace("ForwardedPorts: (ExtHostTunnelService) tunnel provider error"),
						r instanceof Error)
					)
						return r.message
				}
		}
		async $applyCandidateFilter(t) {
			let n = await Promise.all(t.map((i) => this._showCandidatePort(i.host, i.port, i.detail ?? ""))),
				r = t.filter((i, s) => n[s])
			return (
				this.logService.trace(
					`ForwardedPorts: (ExtHostTunnelService) filtered from ${t.map((i) => i.port).join(", ")} to ${r.map((i) => i.port).join(", ")}`,
				),
				r
			)
		}
	}
al = R([S(0, ie), S(1, Xe), S(2, te)], al)
function f2(o) {
	return [...o.entries()]
}
function g2(o) {
	return o ? [...o.entries()] : []
}
var Khe = new D("terminalTabFocusMode", !1, !0)
var jhe = O("ptyService")
var b8 = { Backend: "workbench.contributions.terminal.processBackend" },
	Ok = class {
		constructor() {
			this._backends = new Map()
		}
		get backends() {
			return this._backends
		}
		registerTerminalBackend(e) {
			let t = this._sanitizeRemoteAuthority(e.remoteAuthority)
			if (this._backends.has(t))
				throw new Error(`A terminal backend with remote authority '${t}' was already registered.`)
			this._backends.set(t, e)
		}
		getTerminalBackend(e) {
			return this._backends.get(this._sanitizeRemoteAuthority(e))
		}
		_sanitizeRemoteAuthority(e) {
			return e?.toLowerCase() ?? ""
		}
	}
yt.add(b8.Backend, new Ok())
var Ghe = O("localPtyService"),
	Qhe = O("terminalLogService")
var qx = class {
	constructor(e) {
		this._callback = e
		this._terminalBufferMap = new Map()
	}
	dispose() {
		for (let e of this._terminalBufferMap.values()) e.dispose()
	}
	startBuffering(e, t, n = 5) {
		let r = t((i) => {
			let s = typeof i == "string" ? i : i.data,
				a = this._terminalBufferMap.get(e)
			if (a) {
				a.data.push(s)
				return
			}
			let l = setTimeout(() => this.flushBuffer(e), n)
			;(a = {
				data: [s],
				timeoutId: l,
				dispose: () => {
					clearTimeout(l), this.flushBuffer(e), r.dispose()
				},
			}),
				this._terminalBufferMap.set(e, a)
		})
		return r
	}
	stopBuffering(e) {
		this._terminalBufferMap.get(e)?.dispose()
	}
	flushBuffer(e) {
		let t = this._terminalBufferMap.get(e)
		t && (this._terminalBufferMap.delete(e), this._callback(e, t.data.join("")))
	}
}
var Nd = (o, e, t, n) => {
		let r = e
		return {
			enumerable: !0,
			configurable: !1,
			get() {
				return r
			},
			set(i) {
				if (!t(r, i)) {
					let s = r
					;(r = i), o.listener?.(n(i, s))
				}
			},
		}
	},
	Sp = (o, e) => o === e,
	dl = {
		range: (o, e) => (o === e ? !0 : !o || !e ? !1 : o.isEqual(e)),
		label: Sp,
		description: Sp,
		sortText: Sp,
		busy: Sp,
		error: Sp,
		canResolveChildren: Sp,
		tags: (o, e) => !(o.length !== e.length || o.some((t) => !e.find((n) => t.id === n.id))),
	},
	Tp = (o) => (e) => ({ op: 4, update: o(e) }),
	y8 = (o, e) => ({
		range: (() => {
			let t,
				n = Tp((r) => ({ range: Re.lift(H.from(r)) }))
			return {
				enumerable: !0,
				configurable: !1,
				get() {
					return t
				},
				set(r) {
					o.listener?.({ op: 6 }), dl.range(t, r) || ((t = r), o.listener?.(n(r)))
				},
			}
		})(),
		label: Nd(
			o,
			e,
			dl.label,
			Tp((t) => ({ label: t })),
		),
		description: Nd(
			o,
			void 0,
			dl.description,
			Tp((t) => ({ description: t })),
		),
		sortText: Nd(
			o,
			void 0,
			dl.sortText,
			Tp((t) => ({ sortText: t })),
		),
		canResolveChildren: Nd(o, !1, dl.canResolveChildren, (t) => ({ op: 2, state: t })),
		busy: Nd(
			o,
			!1,
			dl.busy,
			Tp((t) => ({ busy: t })),
		),
		error: Nd(
			o,
			void 0,
			dl.error,
			Tp((t) => ({ error: Se.fromStrict(t) || null })),
		),
		tags: Nd(o, [], dl.tags, (t, n) => ({ op: 1, new: t.map(So.from), old: n.map(So.from) })),
	}),
	I8 = (o) => {
		let e = ze.fromString(o.extId),
			t = new zs(e.controllerId, e.localId, o.label, b.revive(o.uri) || void 0)
		return (
			(t.range = H.to(o.range || void 0)),
			(t.description = o.description || void 0),
			(t.sortText = o.sortText || void 0),
			(t.tags = o.tags.map((n) => So.to({ id: Wy(n).tagId }))),
			t
		)
	},
	Lk = (o) => {
		let e
		for (let t of o.tests) {
			let n = I8(t.item)
			;(cu(n).parent = e), (e = n)
		}
		return e
	},
	zs = class o {
		constructor(e, t, n, r) {
			if (t.includes("\0")) throw new Error(`Test IDs may not include the ${JSON.stringify(t)} symbol`)
			let i = wF(this, e)
			Object.defineProperties(this, {
				id: { value: t, enumerable: !0, writable: !1 },
				uri: { value: r, enumerable: !0, writable: !1 },
				parent: {
					enumerable: !1,
					get() {
						return i.parent instanceof Ep ? void 0 : i.parent
					},
				},
				children: { value: TF(i, cu, o), enumerable: !0, writable: !1 },
				...y8(i, n),
			})
		}
	},
	Ep = class extends zs {
		constructor(t, n) {
			super(t, t, n, void 0)
			this._isRoot = !0
		}
	},
	Kx = class extends zy {
		constructor(e, t, n) {
			super({
				controllerId: e,
				getDocumentVersion: (r) => r && n.getDocument(r)?.version,
				getApiFor: cu,
				getChildren: (r) => r.children,
				root: new Ep(e, t),
				toITestItem: Oi.from,
			})
		}
	}
var Yg = ((t) => ((t[(t.Desktop = 1)] = "Desktop"), (t[(t.Web = 2)] = "Web"), t))(Yg || {})
function Zg(o) {
	let e = z.alloc(1)
	switch (o) {
		case 0:
			e.writeUInt8(1, 0)
			break
		case 1:
			e.writeUInt8(2, 0)
			break
		case 2:
			e.writeUInt8(3, 0)
			break
	}
	return e
}
function eh(o, e) {
	if (o.byteLength !== 1) return !1
	switch (o.readUInt8(0)) {
		case 1:
			return e === 0
		case 2:
			return e === 1
		case 3:
			return e === 2
		default:
			return !1
	}
}
var wp = class extends $ {
	constructor(t, n, r) {
		super()
		this.initData = n
		this._onDidChangeTelemetryEnabled = this._register(new E())
		this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event
		this._onDidChangeTelemetryConfiguration = this._register(new E())
		this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event
		this._productConfig = { usage: !0, error: !0 }
		this._level = 0
		this._inLoggingOnlyMode = !1
		this._telemetryLoggers = new Map()
		this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly
		let i = n.remote.isRemote ? "remoteExtHostTelemetry" : t ? "workerExtHostTelemetry" : "extHostTelemetry"
		this._outputLogger = this._register(
			r.createLogger(i, {
				name: p(
					"extensionTelemetryLog",
					"Extension Telemetry{0}",
					this._inLoggingOnlyMode ? " (Not Sent)" : "",
				),
				hidden: !0,
				group: mF,
			}),
		)
	}
	getTelemetryConfiguration() {
		return this._level === 3
	}
	getTelemetryDetails() {
		return {
			isCrashEnabled: this._level >= 1,
			isErrorsEnabled: this._productConfig.error ? this._level >= 2 : !1,
			isUsageEnabled: this._productConfig.usage ? this._level >= 3 : !1,
		}
	}
	instantiateLogger(t, n, r) {
		let i = this.getTelemetryDetails(),
			s = new th(n, r, t, this._outputLogger, this._inLoggingOnlyMode, this.getBuiltInCommonProperties(t), {
				isUsageEnabled: i.isUsageEnabled,
				isErrorsEnabled: i.isErrorsEnabled,
			}),
			a = this._telemetryLoggers.get(t.identifier.value) ?? []
		return this._telemetryLoggers.set(t.identifier.value, [...a, s]), s.apiTelemetryLogger
	}
	$initializeTelemetryLevel(t, n, r) {
		;(this._level = t), (this._productConfig = r ?? { usage: !0, error: !0 })
	}
	getBuiltInCommonProperties(t) {
		let n = Object.create(null)
		switch (
			((n["common.extname"] = `${t.publisher}.${t.name}`),
			(n["common.extversion"] = t.version),
			(n["common.vscodemachineid"] = this.initData.telemetryInfo.machineId),
			(n["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId),
			(n["common.vscodecommithash"] = this.initData.commit),
			(n["common.sqmid"] = this.initData.telemetryInfo.sqmId),
			(n["common.devDeviceId"] = this.initData.telemetryInfo.devDeviceId),
			(n["common.vscodeversion"] = this.initData.version),
			(n["common.isnewappinstall"] = Mk(this.initData.telemetryInfo.firstSessionDate)),
			(n["common.product"] = this.initData.environment.appHost),
			this.initData.uiKind)
		) {
			case 2:
				n["common.uikind"] = "web"
				break
			case 1:
				n["common.uikind"] = "desktop"
				break
			default:
				n["common.uikind"] = "unknown"
		}
		return (n["common.remotename"] = Ql(fF(this.initData.remote.authority))), n
	}
	$onDidChangeTelemetryLevel(t) {
		;(this._oldTelemetryEnablement = this.getTelemetryConfiguration()), (this._level = t)
		let n = this.getTelemetryDetails()
		this._telemetryLoggers.forEach((r, i) => {
			let s = r.filter((a) => !a.isDisposed)
			s.length === 0 ? this._telemetryLoggers.delete(i) : this._telemetryLoggers.set(i, s)
		}),
			this._telemetryLoggers.forEach((r) => {
				for (let i of r) i.updateTelemetryEnablements(n.isUsageEnabled, n.isErrorsEnabled)
			}),
			this._oldTelemetryEnablement !== this.getTelemetryConfiguration() &&
				this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration()),
			this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails())
	}
	onExtensionError(t, n) {
		let i = this._telemetryLoggers.get(t.value)?.filter((a) => !a.isDisposed)
		if (!i) return this._telemetryLoggers.delete(t.value), !1
		let s = !1
		for (let a of i) a.ignoreUnhandledExtHostErrors || (a.logError(n), (s = !0))
		return s
	}
}
wp = R([S(1, Xe), S(2, uo)], wp)
var th = class {
	constructor(e, t, n, r, i, s, a) {
		this._extension = n
		this._logger = r
		this._inLoggingOnlyMode = i
		this._commonProperties = s
		this._onDidChangeEnableStates = new E()
		;(this.ignoreUnhandledExtHostErrors = t?.ignoreUnhandledErrors ?? !1),
			(this._ignoreBuiltinCommonProperties = t?.ignoreBuiltInCommonProperties ?? !1),
			(this._additionalCommonProperties = t?.additionalCommonProperties),
			(this._sender = e),
			(this._telemetryEnablements = { isUsageEnabled: a.isUsageEnabled, isErrorsEnabled: a.isErrorsEnabled })
	}
	static validateSender(e) {
		if (typeof e != "object") throw new TypeError("TelemetrySender argument is invalid")
		if (typeof e.sendEventData != "function")
			throw new TypeError("TelemetrySender.sendEventData must be a function")
		if (typeof e.sendErrorData != "function")
			throw new TypeError("TelemetrySender.sendErrorData must be a function")
		if (typeof e.flush < "u" && typeof e.flush != "function")
			throw new TypeError("TelemetrySender.flush must be a function or undefined")
	}
	updateTelemetryEnablements(e, t) {
		this._apiObject &&
			((this._telemetryEnablements = { isUsageEnabled: e, isErrorsEnabled: t }),
			this._onDidChangeEnableStates.fire(this._apiObject))
	}
	mixInCommonPropsAndCleanData(e) {
		let t = "properties" in e ? (e.properties ?? {}) : e
		return (
			(t = P_(t, [])),
			this._additionalCommonProperties && (t = gr(t, this._additionalCommonProperties)),
			this._ignoreBuiltinCommonProperties || (t = gr(t, this._commonProperties)),
			"properties" in e ? (e.properties = t) : (e = t),
			e
		)
	}
	logEvent(e, t) {
		this._sender &&
			(this._extension.publisher === "vscode"
				? (e = this._extension.name + "/" + e)
				: (e = this._extension.identifier.value + "/" + e),
			(t = this.mixInCommonPropsAndCleanData(t || {})),
			this._inLoggingOnlyMode || this._sender?.sendEventData(e, t),
			this._logger.trace(e, t))
	}
	logUsage(e, t) {
		this._telemetryEnablements.isUsageEnabled && this.logEvent(e, t)
	}
	logError(e, t) {
		if (!(!this._telemetryEnablements.isErrorsEnabled || !this._sender))
			if (typeof e == "string") this.logEvent(e, t)
			else {
				let n = { name: e.name, message: e.message, stack: e.stack, cause: e.cause },
					r = P_(n, []),
					i = new Error(r.message, { cause: r.cause })
				;(i.stack = r.stack),
					(i.name = r.name),
					(t = this.mixInCommonPropsAndCleanData(t || {})),
					this._inLoggingOnlyMode || this._sender.sendErrorData(i, t),
					this._logger.trace("exception", t)
			}
	}
	get apiTelemetryLogger() {
		if (!this._apiObject) {
			let e = this,
				t = {
					logUsage: e.logUsage.bind(e),
					get isUsageEnabled() {
						return e._telemetryEnablements.isUsageEnabled
					},
					get isErrorsEnabled() {
						return e._telemetryEnablements.isErrorsEnabled
					},
					logError: e.logError.bind(e),
					dispose: e.dispose.bind(e),
					onDidChangeEnableStates: e._onDidChangeEnableStates.event.bind(e),
				}
			this._apiObject = Object.freeze(t)
		}
		return this._apiObject
	}
	get isDisposed() {
		return !this._sender
	}
	dispose() {
		if (this._sender?.flush) {
			let e = this._sender
			;(this._sender = void 0), Promise.resolve(e.flush()).then((e = void 0)), (this._apiObject = void 0)
		} else this._sender = void 0
	}
}
function Mk(o) {
	let e = Date.now() - new Date(o).getTime()
	return isNaN(e) ? !1 : e < 1e3 * 60 * 60 * 24
}
var cl = O("IExtHostTelemetry")
var Pp = class {
	constructor(e, t, n) {
		this._commands = new Map()
		this._apiCommands = new Map()
		;(this.#e = e.getProxy(M.MainThreadCommands)),
			(this._logService = t),
			(this.#n = n),
			(this.#t = e.getProxy(M.MainThreadTelemetry)),
			(this.converter = new Fk(
				this,
				(r) => {
					let i = this._apiCommands.get(r)
					return i?.result === ge.Void ? i : void 0
				},
				t,
			)),
			(this._argumentProcessors = [
				{
					processArgument(r) {
						return ut(r)
					},
				},
				{
					processArgument(r) {
						return os(r, function (i) {
							if (Re.isIRange(i)) return H.to(i)
							if (cn.isIPosition(i)) return Je.to(i)
							if (Re.isIRange(i.range) && b.isUri(i.uri)) return $n.to(i)
							if (i instanceof z) return i.buffer.buffer
							if (!Array.isArray(i)) return i
						})
					},
				},
			])
	}
	#e
	#t
	#n
	registerArgumentProcessor(e) {
		this._argumentProcessors.push(e)
	}
	registerApiCommand(e) {
		let t = this.registerCommand(
			!1,
			e.id,
			async (...n) => {
				let r = e.args.map((s, a) => {
						if (!s.validate(n[a]))
							throw new Error(
								`Invalid argument '${s.name}' when running '${e.id}', received: ${typeof n[a] == "object" ? JSON.stringify(n[a], null, "	") : n[a]} `,
							)
						return s.convert(n[a])
					}),
					i = await this.executeCommand(e.internalId, ...r)
				return e.result.convert(i, n, this.converter)
			},
			void 0,
			{ description: e.description, args: e.args, returns: e.result.description },
		)
		return (
			this._apiCommands.set(e.id, e),
			new ye(() => {
				t.dispose(), this._apiCommands.delete(e.id)
			})
		)
	}
	registerCommand(e, t, n, r, i, s) {
		if ((this._logService.trace("ExtHostCommands#registerCommand", t), !t.trim().length))
			throw new Error("invalid id")
		if (this._commands.has(t)) throw new Error(`command '${t}' already exists`)
		return (
			this._commands.set(t, { callback: n, thisArg: r, metadata: i, extension: s }),
			e && this.#e.$registerCommand(t),
			new ye(() => {
				this._commands.delete(t) && e && this.#e.$unregisterCommand(t)
			})
		)
	}
	executeCommand(e, ...t) {
		return this._logService.trace("ExtHostCommands#executeCommand", e), this._doExecuteCommand(e, t, !0)
	}
	async _doExecuteCommand(e, t, n) {
		if (this._commands.has(e))
			return this.#e.$fireCommandActivationEvent(e), this._executeContributedCommand(e, t, !1)
		{
			let r = !1,
				i = os(t, function (s) {
					if (s instanceof Pe) return Je.from(s)
					if (s instanceof pe) return H.from(s)
					if (s instanceof rn) return $n.from(s)
					if (cr.isNotebookRange(s)) return to.from(s)
					if (s instanceof ArrayBuffer) return (r = !0), z.wrap(new Uint8Array(s))
					if (s instanceof Uint8Array) return (r = !0), z.wrap(s)
					if (s instanceof z) return (r = !0), s
					if (!Array.isArray(s)) return s
				})
			try {
				let s = await this.#e.$executeCommand(e, r ? new Xt(i) : i, n)
				return ut(s)
			} catch (s) {
				if (s instanceof Error && s.message === "$executeCommand:retry") return this._doExecuteCommand(e, t, !1)
				throw s
			}
		}
	}
	async _executeContributedCommand(e, t, n) {
		let r = this._commands.get(e)
		if (!r) throw new Error("Unknown command")
		let { callback: i, thisArg: s, metadata: a } = r
		if (a?.args)
			for (let d = 0; d < a.args.length; d++)
				try {
					uA(t[d], a.args[d].constraint)
				} catch {
					throw new Error(
						`Running the contributed command: '${e}' failed. Illegal argument '${a.args[d].name}' - ${a.args[d].description}`,
					)
				}
		let l = zt.create()
		try {
			return await i.apply(s, t)
		} catch (d) {
			if (e === this.converter.delegatingCommandId) {
				let c = this.converter.getActualCommand(...t)
				c && (e = c.command)
			}
			if ((bn(d) || this._logService.error(d, e, r.extension?.identifier), !n)) throw d
			if (r.extension?.identifier) {
				let c = this.#n.onExtensionError(r.extension.identifier, d)
				this._logService.trace("forwarded error to extension?", c, r.extension?.identifier)
			}
			throw new (class extends Error {
				constructor() {
					super(Xn(d))
					this.id = e
					this.source = r.extension?.displayName ?? r.extension?.name
				}
			})()
		} finally {
			this._reportTelemetry(r, e, l.elapsed())
		}
	}
	_reportTelemetry(e, t, n) {
		e.extension &&
			this.#t.$publicLog2("Extension:ActionExecuted", {
				extensionId: e.extension.identifier.value,
				id: new wa(t),
				duration: n,
			})
	}
	$executeContributedCommand(e, ...t) {
		this._logService.trace("ExtHostCommands#$executeContributedCommand", e)
		let n = this._commands.get(e)
		return n
			? ((t = t.map((r) => this._argumentProcessors.reduce((i, s) => s.processArgument(i, n.extension), r))),
				this._executeContributedCommand(e, t, !0))
			: Promise.reject(new Error(`Contributed command '${e}' does not exist.`))
	}
	getCommands(e = !1) {
		return (
			this._logService.trace("ExtHostCommands#getCommands", e),
			this.#e.$getCommands().then((t) => (e && (t = t.filter((n) => n[0] !== "_")), t))
		)
	}
	$getContributedCommandMetadata() {
		let e = Object.create(null)
		for (let [t, n] of this._commands) {
			let { metadata: r } = n
			r && (e[t] = r)
		}
		return Promise.resolve(e)
	}
}
Pp = R([S(0, ie), S(1, te), S(2, cl)], Pp)
var Tn = O("IExtHostCommands"),
	Fk = class {
		constructor(e, t, n) {
			this._commands = e
			this._lookupApiCommand = t
			this._logService = n
			this.delegatingCommandId = `__vsc${He()}`
			this._cache = new Map()
			this._cachIdPool = 0
			this._commands.registerCommand(!0, this.delegatingCommandId, this._executeConvertedCommand, this)
		}
		toInternal(e, t) {
			if (!e) return
			let n = { $ident: void 0, id: e.command, title: e.title, tooltip: e.tooltip }
			if (!e.command) return n
			let r = this._lookupApiCommand(e.command)
			if (r) (n.id = r.internalId), (n.arguments = r.args.map((i, s) => i.convert(e.arguments && e.arguments[s])))
			else if (si(e.arguments)) {
				let i = `${e.command} /${++this._cachIdPool}`
				this._cache.set(i, e),
					t.add(
						q(() => {
							this._cache.delete(i), this._logService.trace("CommandsConverter#DISPOSE", i)
						}),
					),
					(n.$ident = i),
					(n.id = this.delegatingCommandId),
					(n.arguments = [i]),
					this._logService.trace("CommandsConverter#CREATE", e.command, i)
			}
			return n
		}
		fromInternal(e) {
			return typeof e.$ident == "string"
				? this._cache.get(e.$ident)
				: { command: e.id, title: e.title, arguments: e.arguments }
		}
		getActualCommand(...e) {
			return this._cache.get(e[0])
		}
		_executeConvertedCommand(...e) {
			let t = this.getActualCommand(...e)
			return (
				this._logService.trace("CommandsConverter#EXECUTE", e[0], t ? t.command : "MISSING"),
				t
					? this._commands.executeCommand(t.command, ...(t.arguments || []))
					: Promise.reject(`Actual command not found, wanted to execute ${e[0]}`)
			)
		}
	},
	G = class o {
		constructor(e, t, n, r) {
			this.name = e
			this.description = t
			this.validate = n
			this.convert = r
		}
		static {
			this.Uri = new o(
				"uri",
				"Uri of a text document",
				(e) => b.isUri(e),
				(e) => e,
			)
		}
		static {
			this.Position = new o("position", "A position in a text document", (e) => Pe.isPosition(e), Je.from)
		}
		static {
			this.Range = new o("range", "A range in a text document", (e) => pe.isRange(e), H.from)
		}
		static {
			this.Selection = new o("selection", "A selection in a text document", (e) => Bn.isSelection(e), er.from)
		}
		static {
			this.Number = new o(
				"number",
				"",
				(e) => typeof e == "number",
				(e) => e,
			)
		}
		static {
			this.String = new o(
				"string",
				"",
				(e) => typeof e == "string",
				(e) => e,
			)
		}
		static Arr(e) {
			return new o(
				`${e.name}_array`,
				`Array of ${e.name}, ${e.description}`,
				(t) => Array.isArray(t) && t.every((n) => e.validate(n)),
				(t) => t.map((n) => e.convert(n)),
			)
		}
		static {
			this.CallHierarchyItem = new o("item", "A call hierarchy item", (e) => e instanceof qa, Ws.from)
		}
		static {
			this.TypeHierarchyItem = new o("item", "A type hierarchy item", (e) => e instanceof Ga, Bs.from)
		}
		static {
			this.TestItem = new o("testItem", "A VS Code TestItem", (e) => e instanceof zs, Oi.from)
		}
		static {
			this.TestProfile = new o("testProfile", "A VS Code test profile", (e) => e instanceof ku, nk.from)
		}
		optional() {
			return new o(
				this.name,
				`(optional) ${this.description}`,
				(e) => e == null || this.validate(e),
				(e) => (e === void 0 ? void 0 : e === null ? null : this.convert(e)),
			)
		}
		with(e, t) {
			return new o(e ?? this.name, t ?? this.description, this.validate, this.convert)
		}
	},
	ge = class o {
		constructor(e, t) {
			this.description = e
			this.convert = t
		}
		static {
			this.Void = new o("no result", (e) => e)
		}
	},
	be = class {
		constructor(e, t, n, r, i) {
			this.id = e
			this.internalId = t
			this.description = n
			this.args = r
			this.result = i
		}
	}
var tr = O("IExtHostTerminalService"),
	Dp = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._proxy = t
			this._id = n
			this._creationOptions = r
			this._name = i
			this._disposed = !1
			this._state = { isInteractedWith: !1, shell: void 0 }
			this.isOpen = !1
			this._onWillDispose = this._register(new E())
			this.onWillDispose = this._onWillDispose.event
			;(this._creationOptions = Object.freeze(this._creationOptions)),
				(this._pidPromise = new Promise((a) => (this._pidPromiseComplete = a)))
			let s = this
			this.value = {
				get name() {
					return s._name || ""
				},
				get processId() {
					return s._pidPromise
				},
				get creationOptions() {
					return s._creationOptions
				},
				get exitStatus() {
					return s._exitStatus
				},
				get state() {
					return s._state
				},
				get selection() {
					return s._selection
				},
				get shellIntegration() {
					return s.shellIntegration
				},
				sendText(a, l = !0) {
					s._checkDisposed(), s._proxy.$sendText(s._id, a, l)
				},
				show(a) {
					s._checkDisposed(), s._proxy.$show(s._id, a)
				},
				hide() {
					s._checkDisposed(), s._proxy.$hide(s._id)
				},
				dispose() {
					s._disposed || ((s._disposed = !0), s._proxy.$dispose(s._id))
				},
				get dimensions() {
					if (!(s._cols === void 0 || s._rows === void 0)) return { columns: s._cols, rows: s._rows }
				},
			}
		}
		dispose() {
			this._onWillDispose.fire(), super.dispose()
		}
		async create(t, n) {
			if (typeof this._id != "string") throw new Error("Terminal has already been created")
			await this._proxy.$createTerminal(this._id, {
				name: t.name,
				shellPath: t.shellPath ?? void 0,
				shellArgs: t.shellArgs ?? void 0,
				cwd: t.cwd ?? n?.cwd ?? void 0,
				env: t.env ?? void 0,
				icon: v2(t.iconPath) ?? void 0,
				color: qc.isThemeColor(t.color) ? t.color.id : void 0,
				initialText: t.message ?? void 0,
				strictEnv: t.strictEnv ?? void 0,
				hideFromUser: t.hideFromUser ?? void 0,
				forceShellIntegration: n?.forceShellIntegration ?? void 0,
				isFeatureTerminal: n?.isFeatureTerminal ?? void 0,
				isExtensionOwnedTerminal: !0,
				useShellEnvironment: n?.useShellEnvironment ?? void 0,
				location: n?.location || this._serializeParentTerminal(t.location, n?.resolvedExtHostIdentifier),
				isTransient: t.isTransient ?? void 0,
			})
		}
		async createExtensionTerminal(t, n, r, i, s) {
			if (typeof this._id != "string") throw new Error("Terminal has already been created")
			if (
				(await this._proxy.$createTerminal(this._id, {
					name: this._name,
					isExtensionCustomPtyTerminal: !0,
					icon: i,
					color: qc.isThemeColor(s) ? s.id : void 0,
					location: n?.location || this._serializeParentTerminal(t, r),
					isTransient: !0,
				}),
				typeof this._id == "string")
			)
				throw new Error("Terminal creation failed")
			return this._id
		}
		_serializeParentTerminal(t, n) {
			return typeof t == "object"
				? "parentTerminal" in t && t.parentTerminal && n
					? { parentTerminal: n }
					: "viewColumn" in t
						? { viewColumn: wt.from(t.viewColumn), preserveFocus: t.preserveFocus }
						: void 0
				: t
		}
		_checkDisposed() {
			if (this._disposed) throw new Error("Terminal has already been disposed")
		}
		set name(t) {
			this._name = t
		}
		setExitStatus(t, n) {
			this._exitStatus = Object.freeze({ code: t, reason: n })
		}
		setDimensions(t, n) {
			return (t === this._cols && n === this._rows) || t === 0 || n === 0
				? !1
				: ((this._cols = t), (this._rows = n), !0)
		}
		setInteractedWith() {
			return this._state.isInteractedWith ? !1 : ((this._state = { ...this._state, isInteractedWith: !0 }), !0)
		}
		setShellType(t) {
			return this._state.shell !== t ? ((this._state = { ...this._state, shell: t }), !0) : !1
		}
		setSelection(t) {
			this._selection = t
		}
		_setProcessId(t) {
			this._pidPromiseComplete
				? (this._pidPromiseComplete(t), (this._pidPromiseComplete = void 0))
				: this._pidPromise.then((n) => {
						n !== t && (this._pidPromise = Promise.resolve(t))
					})
		}
	},
	nh = class {
		constructor(e) {
			this._pty = e
			this.id = 0
			this.shouldPersist = !1
			this._onProcessData = new E()
			this.onProcessData = this._onProcessData.event
			this._onProcessReady = new E()
			this._onDidChangeProperty = new E()
			this.onDidChangeProperty = this._onDidChangeProperty.event
			this._onProcessExit = new E()
			this.onProcessExit = this._onProcessExit.event
		}
		get onProcessReady() {
			return this._onProcessReady.event
		}
		refreshProperty(e) {
			throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${e}`)
		}
		updateProperty(e, t) {
			throw new Error(
				`updateProperty is not suppported in extension owned terminals. property: ${e}, value: ${t}`,
			)
		}
		async start() {}
		shutdown() {
			this._pty.close()
		}
		input(e) {
			this._pty.handleInput?.(e)
		}
		resize(e, t) {
			this._pty.setDimensions?.({ columns: e, rows: t })
		}
		clearBuffer() {}
		async processBinary(e) {}
		acknowledgeDataEvent(e) {}
		async setUnicodeVersion(e) {}
		getInitialCwd() {
			return Promise.resolve("")
		}
		getCwd() {
			return Promise.resolve("")
		}
		startSendingEvents(e) {
			this._pty.onDidWrite((t) => this._onProcessData.fire(t)),
				this._pty.onDidClose?.((t = void 0) => {
					this._onProcessExit.fire(t === void 0 ? void 0 : t)
				}),
				this._pty.onDidOverrideDimensions?.((t) => {
					t &&
						this._onDidChangeProperty.fire({
							type: "overrideDimensions",
							value: { cols: t.columns, rows: t.rows },
						})
				}),
				this._pty.onDidChangeName?.((t) => {
					this._onDidChangeProperty.fire({ type: "title", value: t })
				}),
				this._pty.open(e || void 0),
				e && this._pty.setDimensions?.(e),
				this._onProcessReady.fire({ pid: -1, cwd: "", windowsPty: void 0 })
		}
	},
	x8 = 1,
	Ud = class extends $ {
		constructor(t, n, r) {
			super()
			this._extHostCommands = n
			this._terminals = []
			this._terminalProcesses = new Map()
			this._terminalProcessDisposables = {}
			this._extensionTerminalAwaitingStart = {}
			this._getTerminalPromises = {}
			this._environmentVariableCollections = new Map()
			this._lastQuickFixCommands = this._register(new kn())
			this._linkProviders = new Set()
			this._completionProviders = new Map()
			this._profileProviders = new Map()
			this._quickFixProviders = new Map()
			this._terminalLinkCache = new Map()
			this._terminalLinkCancellationSource = new Map()
			this._onDidCloseTerminal = new E()
			this.onDidCloseTerminal = this._onDidCloseTerminal.event
			this._onDidOpenTerminal = new E()
			this.onDidOpenTerminal = this._onDidOpenTerminal.event
			this._onDidChangeActiveTerminal = new E()
			this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event
			this._onDidChangeTerminalDimensions = new E()
			this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event
			this._onDidChangeTerminalState = new E()
			this.onDidChangeTerminalState = this._onDidChangeTerminalState.event
			this._onDidChangeShell = new E()
			this.onDidChangeShell = this._onDidChangeShell.event
			this._onDidWriteTerminalData = new E({
				onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
				onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents(),
			})
			this.onDidWriteTerminalData = this._onDidWriteTerminalData.event
			this._onDidExecuteCommand = new E({
				onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
				onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents(),
			})
			this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event
			;(this._proxy = r.getProxy(M.MainThreadTerminalService)),
				(this._bufferer = new qx(this._proxy.$sendProcessData)),
				this._proxy.$registerProcessSupport(t),
				this._extHostCommands.registerArgumentProcessor({
					processArgument: (i) => {
						let s = (a) => {
							let l = a
							return this.getTerminalById(l.instanceId)?.value
						}
						switch (i?.$mid) {
							case 15:
								return s(i)
							default: {
								if (Array.isArray(i))
									for (let a = 0; a < i.length && i[a].$mid === 15; a++) i[a] = s(i[a])
								return i
							}
						}
					},
				}),
				this._register({
					dispose: () => {
						for (let [i, s] of this._terminalProcesses) s.shutdown(!0)
					},
				})
		}
		get activeTerminal() {
			return this._activeTerminal?.value
		}
		get terminals() {
			return this._terminals.map((t) => t.value)
		}
		getDefaultShell(t) {
			return (t ? this._defaultAutomationProfile : this._defaultProfile)?.path || ""
		}
		getDefaultShellArgs(t) {
			return (t ? this._defaultAutomationProfile : this._defaultProfile)?.args || []
		}
		createExtensionTerminal(t, n) {
			let r = new Dp(this._proxy, He(), t, t.name),
				i = new nh(t.pty)
			return (
				r
					.createExtensionTerminal(
						t.location,
						n,
						this._serializeParentTerminal(t, n).resolvedExtHostIdentifier,
						v2(t.iconPath),
						C8(t.color),
					)
					.then((s) => {
						let a = this._setupExtHostProcessListeners(s, i)
						this._terminalProcessDisposables[s] = a
					}),
				this._terminals.push(r),
				r.value
			)
		}
		_serializeParentTerminal(t, n) {
			if (((n = n || {}), t.location && typeof t.location == "object" && "parentTerminal" in t.location)) {
				let r = t.location.parentTerminal
				if (r) {
					let i = this._terminals.find((s) => s.value === r)
					i && (n.resolvedExtHostIdentifier = i._id)
				}
			} else
				t.location && typeof t.location != "object"
					? (n.location = t.location)
					: n.location &&
						typeof n.location == "object" &&
						"splitActiveTerminal" in n.location &&
						(n.location = { splitActiveTerminal: !0 })
			return n
		}
		attachPtyToTerminal(t, n) {
			if (!this.getTerminalById(t)) throw new Error(`Cannot resolve terminal with id ${t} for virtual process`)
			let i = new nh(n),
				s = this._setupExtHostProcessListeners(t, i)
			this._terminalProcessDisposables[t] = s
		}
		async $acceptActiveTerminalChanged(t) {
			let n = this._activeTerminal
			if (t === null) {
				;(this._activeTerminal = void 0),
					n !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal)
				return
			}
			let r = this.getTerminalById(t)
			r &&
				((this._activeTerminal = r),
				n !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal.value))
		}
		async $acceptTerminalProcessData(t, n) {
			let r = this.getTerminalById(t)
			r && this._onDidWriteTerminalData.fire({ terminal: r.value, data: n })
		}
		async $acceptTerminalDimensions(t, n, r) {
			let i = this.getTerminalById(t)
			i &&
				i.setDimensions(n, r) &&
				this._onDidChangeTerminalDimensions.fire({ terminal: i.value, dimensions: i.value.dimensions })
		}
		async $acceptDidExecuteCommand(t, n) {
			let r = this.getTerminalById(t)
			r && this._onDidExecuteCommand.fire({ terminal: r.value, ...n })
		}
		async $acceptTerminalMaximumDimensions(t, n, r) {
			this._terminalProcesses.get(t)?.resize(n, r)
		}
		async $acceptTerminalTitleChange(t, n) {
			let r = this.getTerminalById(t)
			r && (r.name = n)
		}
		async $acceptTerminalClosed(t, n, r) {
			let i = this._getTerminalObjectIndexById(this._terminals, t)
			if (i !== null) {
				let s = this._terminals.splice(i, 1)[0]
				s.setExitStatus(n, r), this._onDidCloseTerminal.fire(s.value)
			}
		}
		$acceptTerminalOpened(t, n, r, i) {
			if (n) {
				let l = this._getTerminalObjectIndexById(this._terminals, n)
				if (l !== null) {
					;(this._terminals[l]._id = t),
						this._onDidOpenTerminal.fire(this.terminals[l]),
						(this._terminals[l].isOpen = !0)
					return
				}
			}
			let s = {
					name: i.name,
					shellPath: i.executable,
					shellArgs: i.args,
					cwd: typeof i.cwd == "string" ? i.cwd : b.revive(i.cwd),
					env: i.env,
					hideFromUser: i.hideFromUser,
				},
				a = new Dp(this._proxy, t, s, r)
			this._terminals.push(a), this._onDidOpenTerminal.fire(a.value), (a.isOpen = !0)
		}
		async $acceptTerminalProcessId(t, n) {
			this.getTerminalById(t)?._setProcessId(n)
		}
		async $startExtensionTerminal(t, n) {
			let r = this.getTerminalById(t)
			if (!r)
				return {
					message: p(
						"launchFail.idMissingOnExtHost",
						"Could not find the terminal with id {0} on the extension host",
						t,
					),
				}
			r.isOpen ||
				(await new Promise((s) => {
					let a = this.onDidOpenTerminal(async (l) => {
						l === r.value && (a.dispose(), s())
					})
				}))
			let i = this._terminalProcesses.get(t)
			i ? i.startSendingEvents(n) : (this._extensionTerminalAwaitingStart[t] = { initialDimensions: n })
		}
		_setupExtHostProcessListeners(t, n) {
			let r = new Q()
			r.add(n.onProcessReady((s) => this._proxy.$sendProcessReady(t, s.pid, s.cwd, s.windowsPty))),
				r.add(n.onDidChangeProperty((s) => this._proxy.$sendProcessProperty(t, s))),
				this._bufferer.startBuffering(t, n.onProcessData),
				r.add(n.onProcessExit((s) => this._onProcessExit(t, s))),
				this._terminalProcesses.set(t, n)
			let i = this._extensionTerminalAwaitingStart[t]
			return (
				i &&
					n instanceof nh &&
					(n.startSendingEvents(i.initialDimensions), delete this._extensionTerminalAwaitingStart[t]),
				r
			)
		}
		$acceptProcessAckDataEvent(t, n) {
			this._terminalProcesses.get(t)?.acknowledgeDataEvent(n)
		}
		$acceptProcessInput(t, n) {
			this._terminalProcesses.get(t)?.input(n)
		}
		$acceptTerminalInteraction(t) {
			let n = this.getTerminalById(t)
			n?.setInteractedWith() && this._onDidChangeTerminalState.fire(n.value)
		}
		$acceptTerminalSelection(t, n) {
			this.getTerminalById(t)?.setSelection(n)
		}
		$acceptProcessResize(t, n, r) {
			try {
				this._terminalProcesses.get(t)?.resize(n, r)
			} catch (i) {
				if (i.code !== "EPIPE" && i.code !== "ERR_IPC_CHANNEL_CLOSED") throw i
			}
		}
		$acceptProcessShutdown(t, n) {
			this._terminalProcesses.get(t)?.shutdown(n)
		}
		$acceptProcessRequestInitialCwd(t) {
			this._terminalProcesses
				.get(t)
				?.getInitialCwd()
				.then((n) => this._proxy.$sendProcessProperty(t, { type: "initialCwd", value: n }))
		}
		$acceptProcessRequestCwd(t) {
			this._terminalProcesses
				.get(t)
				?.getCwd()
				.then((n) => this._proxy.$sendProcessProperty(t, { type: "cwd", value: n }))
		}
		$acceptProcessRequestLatency(t) {
			return Promise.resolve(t)
		}
		registerProfileProvider(t, n, r) {
			if (this._profileProviders.has(n)) throw new Error(`Terminal profile provider "${n}" already registered`)
			return (
				this._profileProviders.set(n, r),
				this._proxy.$registerProfileProvider(n, t.identifier.value),
				new ye(() => {
					this._profileProviders.delete(n), this._proxy.$unregisterProfileProvider(n)
				})
			)
		}
		registerTerminalCompletionProvider(t, n, ...r) {
			if (this._completionProviders.has(n.id))
				throw new Error(`Terminal completion provider "${n.id}" already registered`)
			return (
				this._completionProviders.set(n.id, n),
				this._proxy.$registerCompletionProvider(n.id, t.identifier.value, ...r),
				new ye(() => {
					this._completionProviders.delete(n.id), this._proxy.$unregisterCompletionProvider(n.id)
				})
			)
		}
		async $provideTerminalCompletions(t, n) {
			let r = new _e().token
			if (r.isCancellationRequested || !this.activeTerminal) return
			let i = this._completionProviders.get(t)
			if (!i) return
			let s = await i.provideTerminalCompletions(this.activeTerminal, n, r)
			if (s != null) return dk.from(s)
		}
		$acceptTerminalShellType(t, n) {
			let r = this.getTerminalById(t)
			r?.setShellType(n) && this._onDidChangeTerminalState.fire(r.value)
		}
		registerTerminalQuickFixProvider(t, n, r) {
			if (this._quickFixProviders.has(t))
				throw new Error(`Terminal quick fix provider "${t}" is already registered`)
			return (
				this._quickFixProviders.set(t, r),
				this._proxy.$registerQuickFixProvider(t, n),
				new ye(() => {
					this._quickFixProviders.delete(t), this._proxy.$unregisterQuickFixProvider(t)
				})
			)
		}
		async $provideTerminalQuickFixes(t, n) {
			let r = new _e().token
			if (r.isCancellationRequested) return
			let i = this._quickFixProviders.get(t)
			if (!i) return
			let s = await i.provideTerminalQuickFixes(n, r)
			if (s === null || (Array.isArray(s) && s.length === 0)) return
			let a = new Q()
			if (((this._lastQuickFixCommands.value = a), !Array.isArray(s)))
				return s ? _x.from(s, this._extHostCommands.converter, a) : void 0
			let l = []
			for (let d of s) {
				let c = _x.from(d, this._extHostCommands.converter, a)
				c && l.push(c)
			}
			return l
		}
		async $createContributedProfileTerminal(t, n) {
			let r = new _e().token,
				i = await this._profileProviders.get(t)?.provideTerminalProfile(r)
			if (!r.isCancellationRequested) {
				if ((i && !("options" in i) && (i = { options: i }), !i || !("options" in i)))
					throw new Error(`No terminal profile options provided for id "${t}"`)
				if ("pty" in i.options) {
					this.createExtensionTerminal(i.options, n)
					return
				}
				this.createTerminalFromOptions(i.options, n)
			}
		}
		registerLinkProvider(t) {
			return (
				this._linkProviders.add(t),
				this._linkProviders.size === 1 && this._proxy.$startLinkProvider(),
				new ye(() => {
					this._linkProviders.delete(t), this._linkProviders.size === 0 && this._proxy.$stopLinkProvider()
				})
			)
		}
		async $provideLinks(t, n) {
			let r = this.getTerminalById(t)
			if (!r) return []
			this._terminalLinkCache.delete(t), this._terminalLinkCancellationSource.get(t)?.dispose(!0)
			let s = new _e()
			this._terminalLinkCancellationSource.set(t, s)
			let a = [],
				l = { terminal: r.value, line: n },
				d = []
			for (let m of this._linkProviders)
				d.push(
					lo.withAsyncBody(async (f) => {
						s.token.onCancellationRequested(() => f({ provider: m, links: [] }))
						let h = (await m.provideTerminalLinks(l, s.token)) || []
						s.token.isCancellationRequested || f({ provider: m, links: h })
					}),
				)
			let c = await Promise.all(d)
			if (s.token.isCancellationRequested) return []
			let u = new Map()
			for (let m of c)
				m &&
					m.links.length > 0 &&
					a.push(
						...m.links.map((f) => {
							let h = { id: x8++, startIndex: f.startIndex, length: f.length, label: f.tooltip }
							return u.set(h.id, { provider: m.provider, link: f }), h
						}),
					)
			return this._terminalLinkCache.set(t, u), a
		}
		$activateLink(t, n) {
			let r = this._terminalLinkCache.get(t)?.get(n)
			r && r.provider.handleTerminalLink(r.link)
		}
		_onProcessExit(t, n) {
			this._bufferer.stopBuffering(t),
				this._terminalProcesses.delete(t),
				delete this._extensionTerminalAwaitingStart[t]
			let r = this._terminalProcessDisposables[t]
			r && (r.dispose(), delete this._terminalProcessDisposables[t]), this._proxy.$sendProcessExit(t, n)
		}
		getTerminalById(t) {
			return this._getTerminalObjectById(this._terminals, t)
		}
		getTerminalIdByApiObject(t) {
			let n = this._terminals.findIndex((r) => r.value === t)
			return n >= 0 ? n : null
		}
		_getTerminalObjectById(t, n) {
			let r = this._getTerminalObjectIndexById(t, n)
			return r !== null ? t[r] : null
		}
		_getTerminalObjectIndexById(t, n) {
			let r = t.findIndex((i) => i._id === n)
			return r >= 0 ? r : null
		}
		getEnvironmentVariableCollection(t) {
			let n = this._environmentVariableCollections.get(t.identifier.value)
			return (
				n || ((n = this._register(new jx())), this._setEnvironmentVariableCollection(t.identifier.value, n)),
				n.getScopedEnvironmentVariableCollection(void 0)
			)
		}
		_syncEnvironmentVariableCollection(t, n) {
			let r = f2(n.map),
				i = g2(n.descriptionMap)
			this._proxy.$setEnvironmentVariableCollection(t, n.persistent, r.length === 0 ? void 0 : r, i)
		}
		$initEnvironmentVariableCollections(t) {
			t.forEach((n) => {
				let r = n[0],
					i = this._register(new jx(n[1]))
				this._setEnvironmentVariableCollection(r, i)
			})
		}
		$acceptDefaultProfile(t, n) {
			let r = this._defaultProfile
			;(this._defaultProfile = t),
				(this._defaultAutomationProfile = n),
				r?.path !== t.path && this._onDidChangeShell.fire(t.path)
		}
		_setEnvironmentVariableCollection(t, n) {
			this._environmentVariableCollections.set(t, n),
				this._register(
					n.onDidChangeCollection(() => {
						this._syncEnvironmentVariableCollection(t, n)
					}),
				)
		}
	}
Ud = R([S(1, Tn), S(2, ie)], Ud)
var jx = class extends $ {
		constructor(t) {
			super()
			this.map = new Map()
			this.scopedCollections = new Map()
			this.descriptionMap = new Map()
			this._persistent = !0
			this._onDidChangeCollection = new E()
			this.map = new Map(t)
		}
		get persistent() {
			return this._persistent
		}
		set persistent(t) {
			;(this._persistent = t), this._onDidChangeCollection.fire()
		}
		get onDidChangeCollection() {
			return this._onDidChangeCollection && this._onDidChangeCollection.event
		}
		getScopedEnvironmentVariableCollection(t) {
			let n = this.getScopeKey(t),
				r = this.scopedCollections.get(n)
			return (
				r ||
					((r = new Nk(this, t)),
					this.scopedCollections.set(n, r),
					this._register(r.onDidChangeCollection(() => this._onDidChangeCollection.fire()))),
				r
			)
		}
		replace(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 1, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		append(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 2, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		prepend(t, n, r, i) {
			this._setIfDiffers(t, { value: n, type: 3, options: r ?? { applyAtProcessCreation: !0 }, scope: i })
		}
		_setIfDiffers(t, n) {
			if (n.options && n.options.applyAtProcessCreation === !1 && !n.options.applyAtShellIntegration)
				throw new Error(
					"EnvironmentVariableMutatorOptions must apply at either process creation or shell integration",
				)
			let r = this.getKey(t, n.scope),
				i = this.map.get(r),
				s = n.options
					? {
							applyAtProcessCreation: n.options.applyAtProcessCreation ?? !1,
							applyAtShellIntegration: n.options.applyAtShellIntegration ?? !1,
						}
					: { applyAtProcessCreation: !0 }
			if (
				!i ||
				i.value !== n.value ||
				i.type !== n.type ||
				i.options?.applyAtProcessCreation !== s.applyAtProcessCreation ||
				i.options?.applyAtShellIntegration !== s.applyAtShellIntegration ||
				i.scope?.workspaceFolder?.index !== n.scope?.workspaceFolder?.index
			) {
				let a = this.getKey(t, n.scope),
					l = { variable: t, ...n, options: s }
				this.map.set(a, l), this._onDidChangeCollection.fire()
			}
		}
		get(t, n) {
			let r = this.getKey(t, n),
				i = this.map.get(r)
			return i ? h2(i) : void 0
		}
		getKey(t, n) {
			let r = this.getScopeKey(n)
			return r.length ? `${t}:::${r}` : t
		}
		getScopeKey(t) {
			return this.getWorkspaceKey(t?.workspaceFolder) ?? ""
		}
		getWorkspaceKey(t) {
			return t ? t.uri.toString() : void 0
		}
		getVariableMap(t) {
			let n = new Map()
			for (let [r, i] of this.map) this.getScopeKey(i.scope) === this.getScopeKey(t) && n.set(i.variable, h2(i))
			return n
		}
		delete(t, n) {
			let r = this.getKey(t, n)
			this.map.delete(r), this._onDidChangeCollection.fire()
		}
		clear(t) {
			if (t?.workspaceFolder) {
				for (let [n, r] of this.map)
					r.scope?.workspaceFolder?.index === t.workspaceFolder.index && this.map.delete(n)
				this.clearDescription(t)
			} else this.map.clear(), this.descriptionMap.clear()
			this._onDidChangeCollection.fire()
		}
		setDescription(t, n) {
			let r = this.getScopeKey(n),
				i = this.descriptionMap.get(r)
			if (!i || i.description !== t) {
				let s
				typeof t == "string"
					? (s = t)
					: (s = t?.value.split(`

`)[0])
				let a = { description: s, scope: n }
				this.descriptionMap.set(r, a), this._onDidChangeCollection.fire()
			}
		}
		getDescription(t) {
			let n = this.getScopeKey(t)
			return this.descriptionMap.get(n)?.description
		}
		clearDescription(t) {
			let n = this.getScopeKey(t)
			this.descriptionMap.delete(n)
		}
	},
	Nk = class {
		constructor(e, t) {
			this.collection = e
			this.scope = t
			this._onDidChangeCollection = new E()
		}
		get persistent() {
			return this.collection.persistent
		}
		set persistent(e) {
			this.collection.persistent = e
		}
		get onDidChangeCollection() {
			return this._onDidChangeCollection && this._onDidChangeCollection.event
		}
		getScoped(e) {
			return this.collection.getScopedEnvironmentVariableCollection(e)
		}
		replace(e, t, n) {
			this.collection.replace(e, t, n, this.scope)
		}
		append(e, t, n) {
			this.collection.append(e, t, n, this.scope)
		}
		prepend(e, t, n) {
			this.collection.prepend(e, t, n, this.scope)
		}
		get(e) {
			return this.collection.get(e, this.scope)
		}
		forEach(e, t) {
			this.collection.getVariableMap(this.scope).forEach((n, r) => e.call(t, r, n, this), this.scope)
		}
		[Symbol.iterator]() {
			return this.collection.getVariableMap(this.scope).entries()
		}
		delete(e) {
			this.collection.delete(e, this.scope), this._onDidChangeCollection.fire(void 0)
		}
		clear() {
			this.collection.clear(this.scope)
		}
		set description(e) {
			this.collection.setDescription(e, this.scope)
		}
		get description() {
			return this.collection.getDescription(this.scope)
		}
	},
	_p = class extends Ud {
		constructor(e, t) {
			super(!1, e, t)
		}
		createTerminal(e, t, n) {
			throw new Dl()
		}
		createTerminalFromOptions(e, t) {
			throw new Dl()
		}
	}
_p = R([S(0, Tn), S(1, ie)], _p)
function v2(o) {
	if (!(!o || typeof o == "string")) return "id" in o ? { id: o.id, color: o.color } : o
}
function C8(o) {
	return qc.isThemeColor(o) ? o : void 0
}
function h2(o) {
	let e = { ...o }
	return delete e.scope, (e.options = e.options ?? void 0), delete e.variable, e
}
var Gx = "__",
	iye = O("IAuthenticationService"),
	sye = O("IAuthenticationExtensionsService")
var Rp = O("IExtHostAuthentication"),
	kp = class {
		constructor(e) {
			this._authenticationProviders = new Map()
			this._onDidChangeSessions = new E()
			this._getSessionTaskSingler = new Uk()
			this._proxy = e.getProxy(M.MainThreadAuthentication)
		}
		getExtensionScopedSessionsEvent(e) {
			let t = e.toLowerCase()
			return Ee.chain(this._onDidChangeSessions.event, (n) =>
				n
					.filter((r) => !r.extensionIdFilter || r.extensionIdFilter.includes(t))
					.map((r) => ({ provider: r.provider })),
			)
		}
		async getSession(e, t, n, r = {}) {
			let i = Ce.toKey(e.identifier),
				s = [...n].sort().join(" "),
				l = Object.keys(r)
					.sort()
					.map((d) => `${d}:${!!r[d]}`)
					.join(", ")
			return await this._getSessionTaskSingler.getOrCreate(`${i} ${t} ${s} ${l}`, async () => {
				await this._proxy.$ensureProvider(t)
				let d = e.displayName || e.name
				return this._proxy.$getSession(t, n, i, d, r)
			})
		}
		async getAccounts(e) {
			return await this._proxy.$ensureProvider(e), await this._proxy.$getAccounts(e)
		}
		async removeSession(e, t) {
			let n = this._authenticationProviders.get(e)
			return n ? n.provider.removeSession(t) : this._proxy.$removeSession(e, t)
		}
		registerAuthenticationProvider(e, t, n, r) {
			if (this._authenticationProviders.get(e))
				throw new Error(`An authentication provider with id '${e}' is already registered.`)
			this._authenticationProviders.set(e, {
				label: t,
				provider: n,
				options: r ?? { supportsMultipleAccounts: !1 },
			})
			let i = n.onDidChangeSessions((s) => this._proxy.$sendDidChangeSessions(e, s))
			return (
				this._proxy.$registerAuthenticationProvider(e, t, r?.supportsMultipleAccounts ?? !1),
				new ye(() => {
					i.dispose(),
						this._authenticationProviders.delete(e),
						this._proxy.$unregisterAuthenticationProvider(e)
				})
			)
		}
		async $createSession(e, t, n) {
			let r = this._authenticationProviders.get(e)
			if (r) return await r.provider.createSession(t, n)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		async $removeSession(e, t) {
			let n = this._authenticationProviders.get(e)
			if (n) return await n.provider.removeSession(t)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		async $getSessions(e, t, n) {
			let r = this._authenticationProviders.get(e)
			if (r) return await r.provider.getSessions(t, n)
			throw new Error(`Unable to find authentication provider with handle: ${e}`)
		}
		$onDidChangeAuthenticationSessions(e, t, n) {
			return (
				e.startsWith(Gx) ||
					this._onDidChangeSessions.fire({ provider: { id: e, label: t }, extensionIdFilter: n }),
				Promise.resolve()
			)
		}
	}
kp = R([S(0, ie)], kp)
var Uk = class {
	constructor() {
		this._inFlightPromises = new Map()
	}
	getOrCreate(e, t) {
		let n = this._inFlightPromises.get(e)
		if (n) return n
		let r = t().finally(() => this._inFlightPromises.delete(e))
		return this._inFlightPromises.set(e, r), r
	}
}
var Ap = O("IExtHostLanguageModels"),
	Qx = class {
		constructor(e, t) {
			this.option = e
			this.stream = new kc()
			this.stream = t ?? new kc()
		}
	},
	Hk = class {
		constructor() {
			this._responseStreams = new Map()
			this._defaultStream = new kc()
			this._isDone = !1
			let e = this
			this.apiObject = {
				get stream() {
					return e._defaultStream.asyncIterable
				},
				get text() {
					return mi
						.map(e._defaultStream.asyncIterable, (t) => {
							if (t instanceof Pt) return t.value
						})
						.coalesce()
				},
			}
		}
		*_streams() {
			if (this._responseStreams.size > 0) for (let [, e] of this._responseStreams) yield e.stream
			else yield this._defaultStream
		}
		handleFragment(e) {
			if (this._isDone) return
			let t = this._responseStreams.get(e.index)
			t ||
				(this._responseStreams.size === 0 ? (t = new Qx(e.index, this._defaultStream)) : (t = new Qx(e.index)),
				this._responseStreams.set(e.index, t))
			let n
			e.part.type === "text"
				? (n = new Pt(e.part.value))
				: (n = new xo(e.part.toolCallId, e.part.name, e.part.parameters)),
				t.stream.emitOne(n)
		}
		reject(e) {
			this._isDone = !0
			for (let t of this._streams()) t.reject(e)
		}
		resolve() {
			this._isDone = !0
			for (let e of this._streams()) e.resolve()
		}
	},
	qs = class {
		constructor(e, t, n) {
			this._logService = t
			this._extHostAuthentication = n
			this._onDidChangeModelAccess = new E()
			this._onDidChangeProviders = new E()
			this.onDidChangeProviders = this._onDidChangeProviders.event
			this._languageModels = new Map()
			this._allLanguageModelData = new Map()
			this._modelAccessList = new Ln()
			this._pendingRequest = new Map()
			this._ignoredFileProviders = new Map()
			this._languageAccessInformationExtensions = new Set()
			this._proxy = e.getProxy(M.MainThreadLanguageModels)
		}
		static {
			this._idPool = 1
		}
		dispose() {
			this._onDidChangeModelAccess.dispose(), this._onDidChangeProviders.dispose()
		}
		registerLanguageModel(e, t, n, r) {
			let i = qs._idPool++
			this._languageModels.set(i, { extension: e.identifier, provider: n, languageModelId: t })
			let s
			r.auth &&
				(s = {
					providerLabel: e.displayName || e.name,
					accountLabel: typeof r.auth == "object" ? r.auth.label : void 0,
				}),
				this._proxy.$registerLanguageModelProvider(i, `${Ce.toKey(e.identifier)}/${t}`, {
					extension: e.identifier,
					id: t,
					vendor: r.vendor ?? Ce.toKey(e.identifier),
					name: r.name ?? "",
					family: r.family ?? "",
					version: r.version,
					maxInputTokens: r.maxInputTokens,
					maxOutputTokens: r.maxOutputTokens,
					auth: s,
					targetExtensions: r.extensions,
					isDefault: r.isDefault,
					isUserSelectable: r.isUserSelectable,
					capabilities: r.capabilities,
				})
			let a = n.onDidReceiveLanguageModelResponse2?.(({ extensionId: l, participant: d, tokenCount: c }) => {
				this._proxy.$whenLanguageModelChatRequestMade(t, new Ce(l), d, c)
			})
			return q(() => {
				this._languageModels.delete(i), this._proxy.$unregisterProvider(i), a?.dispose()
			})
		}
		async $startChatRequest(e, t, n, r, i, s) {
			let a = this._languageModels.get(e)
			if (!a) throw new Error("Provider not found")
			let l = new xa(async (c) => {
					if (s.isCancellationRequested) {
						this._logService.warn(
							`[CHAT](${a.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`,
						)
						return
					}
					let u
					if (
						(c.part instanceof xo
							? (u = {
									type: "tool_use",
									name: c.part.name,
									parameters: c.part.input,
									toolCallId: c.part.callId,
								})
							: c.part instanceof Pt && (u = { type: "text", value: c.part.value }),
						!u)
					) {
						this._logService.warn(`[CHAT](${a.extension.value}) UNKNOWN part ${JSON.stringify(c)}`)
						return
					}
					this._proxy.$reportResponsePart(t, { index: c.index, part: u })
				}),
				d
			try {
				d = a.provider.provideLanguageModelResponse(r.value.map(Mg.to), i, Ce.toKey(n), l, s)
			} catch (c) {
				throw c
			}
			Promise.resolve(d).then(
				() => {
					this._proxy.$reportResponseDone(t, void 0)
				},
				(c) => {
					this._proxy.$reportResponseDone(t, Do(c))
				},
			)
		}
		$provideTokenLength(e, t, n) {
			let r = this._languageModels.get(e)
			return r ? Promise.resolve(r.provider.provideTokenCount(t, n)) : Promise.resolve(0)
		}
		$acceptChatModelMetadata(e) {
			if (e.added)
				for (let { identifier: t, metadata: n } of e.added)
					this._allLanguageModelData.set(t, { metadata: n, apiObjects: new Ln() })
			if (e.removed)
				for (let t of e.removed) {
					this._allLanguageModelData.delete(t)
					for (let [n, r] of this._pendingRequest)
						r.languageModelId === t && (r.res.reject(new xt()), this._pendingRequest.delete(n))
				}
			e.added?.forEach((t) => this._fakeAuthPopulate(t.metadata)), this._onDidChangeProviders.fire(void 0)
		}
		async getDefaultLanguageModel(e) {
			let t = Rt.find(this._allLanguageModelData.entries(), ([, n]) => !!n.metadata.isDefault)?.[0]
			if (t) return this.getLanguageModelByIdentifier(e, t)
		}
		async getLanguageModelByIdentifier(e, t) {
			let n = this._allLanguageModelData.get(t)
			if (!n) return
			this._isUsingAuth(e.identifier, n.metadata) && (await this._fakeAuthPopulate(n.metadata))
			let r = n.apiObjects.get(e.identifier)
			if (!r) {
				let i = this
				;(r = {
					id: n.metadata.id,
					vendor: n.metadata.vendor,
					family: n.metadata.family,
					version: n.metadata.version,
					name: n.metadata.name,
					capabilities: {
						supportsImageToText: n.metadata.capabilities?.vision ?? !1,
						supportsToolCalling: n.metadata.capabilities?.toolCalling ?? !1,
					},
					maxInputTokens: n.metadata.maxInputTokens,
					countTokens(s, a) {
						if (!i._allLanguageModelData.has(t)) throw Hr.NotFound(t)
						return i._computeTokenLength(t, s, a ?? De.None)
					},
					sendRequest(s, a, l) {
						if (!i._allLanguageModelData.has(t)) throw Hr.NotFound(t)
						return i._sendChatRequest(e, t, s, a ?? {}, l ?? De.None)
					},
				}),
					Object.freeze(r),
					n.apiObjects.set(e.identifier, r)
			}
			return r
		}
		async selectLanguageModels(e, t) {
			let n = await this._proxy.$selectChatModels({ ...t, extension: e.identifier }),
				r = []
			for (let i of n) {
				let s = await this.getLanguageModelByIdentifier(e, i)
				s && r.push(s)
			}
			return r
		}
		async _sendChatRequest(e, t, n, r, i) {
			let s = this._convertMessages(e, n),
				a = e.identifier,
				l = this._allLanguageModelData.get(t)?.metadata
			if (!l || !this._allLanguageModelData.has(t)) throw Hr.NotFound(`Language model '${t}' is unknown.`)
			if (
				this._isUsingAuth(a, l) &&
				(!(await this._getAuthAccess(
					e,
					{ identifier: l.extension, displayName: l.auth.providerLabel },
					r.justification,
					!1,
				)) ||
					!this._modelAccessList.get(a)?.has(l.extension))
			)
				throw Hr.NoPermissions(`Language model '${t}' cannot be used by '${a.value}'.`)
			let d = (Math.random() * 1e6) | 0,
				c = new Hk()
			this._pendingRequest.set(d, { languageModelId: t, res: c })
			try {
				await this._proxy.$tryStartChatRequest(a, t, d, new Xt(s), r, i)
			} catch (u) {
				throw (this._pendingRequest.delete(d), Hr.tryDeserialize(u) ?? u)
			}
			return c.apiObject
		}
		_convertMessages(e, t) {
			let n = []
			for (let r of t) r.role === 3 && F(e, "languageModelSystem"), n.push(Mg.from(r))
			return n
		}
		async $acceptResponsePart(e, t) {
			let n = this._pendingRequest.get(e)
			n && n.res.handleFragment(t)
		}
		async $acceptResponseDone(e, t) {
			let n = this._pendingRequest.get(e)
			n && (this._pendingRequest.delete(e), t ? n.res.reject(Hr.tryDeserialize(t) ?? tf(t)) : n.res.resolve())
		}
		async _getAuthAccess(e, t, n, r) {
			let i = Gx + t.identifier.value
			if (await this._extHostAuthentication.getSession(e, i, [], { silent: !0 }))
				return this.$updateModelAccesslist([{ from: e.identifier, to: t.identifier, enabled: !0 }]), !0
			if (r) return !1
			try {
				let a = n ? p("chatAccessWithJustification", "Justification: {1}", t.displayName, n) : void 0
				return (
					await this._extHostAuthentication.getSession(e, i, [], { forceNewSession: { detail: a } }),
					this.$updateModelAccesslist([{ from: e.identifier, to: t.identifier, enabled: !0 }]),
					!0
				)
			} catch {
				return !1
			}
		}
		_isUsingAuth(e, t) {
			return !!t.auth && !Ce.equals(t.extension, e)
		}
		async _fakeAuthPopulate(e) {
			if (e.auth)
				for (let t of this._languageAccessInformationExtensions)
					try {
						await this._getAuthAccess(t, { identifier: e.extension, displayName: "" }, void 0, !0)
					} catch (n) {
						this._logService.error("Fake Auth request failed"), this._logService.error(n)
					}
		}
		async _computeTokenLength(e, t, n) {
			if (!this._allLanguageModelData.get(e)) throw Hr.NotFound(`Language model '${e}' is unknown.`)
			let i = Rt.find(this._languageModels.values(), (s) => s.languageModelId === e)
			return i
				? i.provider.provideTokenCount(t, n)
				: this._proxy.$countTokens(e, typeof t == "string" ? t : Mg.from(t), n)
		}
		$updateModelAccesslist(e) {
			let t = new Array()
			for (let { from: n, to: r, enabled: i } of e) {
				let s = this._modelAccessList.get(n) ?? new ar()
				if (s.has(r) !== i) {
					i ? s.add(r) : s.delete(r), this._modelAccessList.set(n, s)
					let l = { from: n, to: r }
					t.push(l), this._onDidChangeModelAccess.fire(l)
				}
			}
		}
		createLanguageModelAccessInformation(e) {
			this._languageAccessInformationExtensions.add(e)
			let t = this,
				n = Ee.signal(Ee.filter(this._onDidChangeModelAccess.event, (i) => Ce.equals(i.from, e.identifier))),
				r = Ee.signal(this._onDidChangeProviders.event)
			return {
				get onDidChange() {
					return Ee.any(n, r)
				},
				canSendRequest(i) {
					let s
					e: for (let [l, d] of t._allLanguageModelData)
						for (let c of d.apiObjects.values())
							if (c === i) {
								s = d.metadata
								break e
							}
					if (!s) return
					if (!t._isUsingAuth(e.identifier, s)) return !0
					let a = t._modelAccessList.get(e.identifier)
					if (a) return a.has(s.extension)
				},
			}
		}
		fileIsIgnored(e, t, n) {
			return F(e, "chatParticipantAdditions"), this._proxy.$fileIsIgnored(t, n)
		}
		async $isFileIgnored(e, t, n) {
			let r = this._ignoredFileProviders.get(e)
			if (!r) throw new Error("Unknown LanguageModelIgnoredFileProvider")
			return (await r.provideFileIgnored(b.revive(t), n)) ?? !1
		}
		registerIgnoredFileProvider(e, t) {
			F(e, "chatParticipantPrivate")
			let n = qs._idPool++
			return (
				this._proxy.$registerFileIgnoreProvider(n),
				this._ignoredFileProviders.set(n, t),
				q(() => {
					this._proxy.$unregisterFileIgnoreProvider(n), this._ignoredFileProviders.delete(n)
				})
			)
		}
	}
qs = R([S(0, ie), S(1, te), S(2, Rp)], qs)
function Op(o, e = Ie) {
	return qv(o, e) ? o.charAt(0).toUpperCase() + o.slice(1) : o
}
function b2(o, e) {
	return o.replace(/^~($|\/|\\)/, `${e}$1`)
}
var S8 = 60,
	T8 = S8 * 60,
	Wk = T8 * 24,
	eIe = Wk * 7,
	tIe = Wk * 30,
	nIe = Wk * 365
function y2(o) {
	return (
		o.getFullYear() +
		"-" +
		String(o.getMonth() + 1).padStart(2, "0") +
		"-" +
		String(o.getDate()).padStart(2, "0") +
		"T" +
		String(o.getHours()).padStart(2, "0") +
		":" +
		String(o.getMinutes()).padStart(2, "0") +
		":" +
		String(o.getSeconds()).padStart(2, "0") +
		"." +
		(o.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) +
		"Z"
	)
}
var I2 = {
	DateTimeFormat(o, e) {
		try {
			return new Intl.DateTimeFormat(o, e)
		} catch {
			return new Intl.DateTimeFormat(void 0, e)
		}
	},
	Collator(o, e) {
		try {
			return new Intl.Collator(o, e)
		} catch {
			return new Intl.Collator(void 0, e)
		}
	},
	Segmenter(o, e) {
		try {
			return new Intl.Segmenter(o, e)
		} catch {
			return new Intl.Segmenter(void 0, e)
		}
	},
	Locale(o, e) {
		try {
			return new Intl.Locale(o, e)
		} catch {
			return new Intl.Locale(ui, e)
		}
	},
}
var Lp = class o {
	constructor(e) {
		let t = TE(e)
		;(this._defaultValue = t), (this._asciiMap = o._createAsciiMap(t)), (this._map = new Map())
	}
	static _createAsciiMap(e) {
		let t = new Uint8Array(256)
		return t.fill(e), t
	}
	set(e, t) {
		let n = TE(t)
		e >= 0 && e < 256 ? (this._asciiMap[e] = n) : this._map.set(e, n)
	}
	get(e) {
		return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue
	}
	clear() {
		this._asciiMap.fill(this._defaultValue), this._map.clear()
	}
}
var Vk = class extends Lp {
		constructor(t, n) {
			super(0)
			this._segmenter = null
			this._cachedLine = null
			this._cachedSegments = []
			;(this.intlSegmenterLocales = n),
				this.intlSegmenterLocales.length > 0
					? (this._segmenter = I2.Segmenter(this.intlSegmenterLocales, { granularity: "word" }))
					: (this._segmenter = null)
			for (let r = 0, i = t.length; r < i; r++) this.set(t.charCodeAt(r), 2)
			this.set(32, 1), this.set(9, 1)
		}
		findPrevIntlWordBeforeOrAtOffset(t, n) {
			let r = null
			for (let i of this._getIntlSegmenterWordsOnLine(t)) {
				if (i.index > n) break
				r = i
			}
			return r
		}
		findNextIntlWordAtOrAfterOffset(t, n) {
			for (let r of this._getIntlSegmenterWordsOnLine(t)) if (!(r.index < n)) return r
			return null
		}
		_getIntlSegmenterWordsOnLine(t) {
			return this._segmenter
				? this._cachedLine === t
					? this._cachedSegments
					: ((this._cachedLine = t),
						(this._cachedSegments = this._filterWordSegments(this._segmenter.segment(t))),
						this._cachedSegments)
				: []
		}
		_filterWordSegments(t) {
			let n = []
			for (let r of t) this._isWordLike(r) && n.push(r)
			return n
		}
		_isWordLike(t) {
			return !!t.isWordLike
		}
	},
	x2 = new ko(10)
function C2(o, e) {
	let t = `${o}/${e.join(",")}`,
		n = x2.get(t)
	return n || ((n = new Vk(o, e)), x2.set(t, n)), n
}
var rh = class {
	constructor(e, t, n, r) {
		;(this.searchString = e), (this.isRegex = t), (this.matchCase = n), (this.wordSeparators = r)
	}
	parseSearchRequest() {
		if (this.searchString === "") return null
		let e
		this.isRegex
			? (e = Bk(this.searchString))
			: (e =
					this.searchString.indexOf(`
`) >= 0)
		let t = null
		try {
			t = Mv(this.searchString, this.isRegex, {
				matchCase: this.matchCase,
				wholeWord: !1,
				multiline: e,
				global: !0,
				unicode: !0,
			})
		} catch {
			return null
		}
		if (!t) return null
		let n = !this.isRegex && !e
		return (
			n && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (n = this.matchCase),
			new Wb(t, this.wordSeparators ? C2(this.wordSeparators, []) : null, n ? this.searchString : null)
		)
	}
}
function Bk(o) {
	if (!o || o.length === 0) return !1
	for (let e = 0, t = o.length; e < t; e++) {
		let n = o.charCodeAt(e)
		if (n === 10) return !0
		if (n === 92) {
			if ((e++, e >= t)) break
			let r = o.charCodeAt(e)
			if (r === 110 || r === 114 || r === 87) return !0
		}
	}
	return !1
}
function $k(o, e, t) {
	if (!t) return new td(o, null)
	let n = []
	for (let r = 0, i = e.length; r < i; r++) n[r] = e[r]
	return new td(o, n)
}
function w8(o, e, t, n, r) {
	if (n === 0) return !0
	let i = e.charCodeAt(n - 1)
	if (o.get(i) !== 0 || i === 13 || i === 10) return !0
	if (r > 0) {
		let s = e.charCodeAt(n)
		if (o.get(s) !== 0) return !0
	}
	return !1
}
function P8(o, e, t, n, r) {
	if (n + r === t) return !0
	let i = e.charCodeAt(n + r)
	if (o.get(i) !== 0 || i === 13 || i === 10) return !0
	if (r > 0) {
		let s = e.charCodeAt(n + r - 1)
		if (o.get(s) !== 0) return !0
	}
	return !1
}
function zk(o, e, t, n, r) {
	return w8(o, e, t, n, r) && P8(o, e, t, n, r)
}
var Jx = class {
	constructor(e, t) {
		;(this._wordSeparators = e),
			(this._searchRegex = t),
			(this._prevMatchStartIndex = -1),
			(this._prevMatchLength = 0)
	}
	reset(e) {
		;(this._searchRegex.lastIndex = e), (this._prevMatchStartIndex = -1), (this._prevMatchLength = 0)
	}
	next(e) {
		let t = e.length,
			n
		do {
			if (this._prevMatchStartIndex + this._prevMatchLength === t || ((n = this._searchRegex.exec(e)), !n))
				return null
			let r = n.index,
				i = n[0].length
			if (r === this._prevMatchStartIndex && i === this._prevMatchLength) {
				if (i === 0) {
					RE(e, t, this._searchRegex.lastIndex) > 65535
						? (this._searchRegex.lastIndex += 2)
						: (this._searchRegex.lastIndex += 1)
					continue
				}
				return null
			}
			if (
				((this._prevMatchStartIndex = r),
				(this._prevMatchLength = i),
				!this._wordSeparators || zk(this._wordSeparators, e, t, r, i))
			)
				return n
		} while (n)
		return null
	}
}
function S2(o) {
	return o.scheme !== W.file && o.scheme !== W.vscodeRemote
}
function _8(o) {
	if (o.folders.length) return o.folders.every((e) => S2(e.uri)) ? o.folders[0].uri : void 0
	if (o.configuration && S2(o.configuration)) return o.configuration
}
function T2(o) {
	return _8(o)?.scheme
}
var Xx = ig
var Yx = O("remoteAgentService"),
	wIe = new (class {
		constructor() {
			this.maxSampleCount = 5
			this.sampleDelay = 2e3
			this.initial = []
			this.maxInitialCount = 3
			this.average = []
			this.maxAverageCount = 100
			this.highLatencyMultiple = 2
			this.highLatencyMinThreshold = 500
			this.highLatencyMaxThreshold = 1500
			this.lastMeasurement = void 0
		}
		get latency() {
			return this.lastMeasurement
		}
		async measure(o) {
			let e = 1 / 0
			for (let n = 0; n < this.maxSampleCount; n++) {
				let r = await o.getRoundTripTime()
				if (r === void 0) return
				;(e = Math.min(e, r / 2)), await Wt(this.sampleDelay)
			}
			this.average.push(e), this.average.length > this.maxAverageCount && this.average.shift()
			let t
			return (
				this.initial.length < this.maxInitialCount
					? this.initial.push(e)
					: (t = this.initial.reduce((n, r) => n + r, 0) / this.initial.length),
				(this.lastMeasurement = {
					initial: t,
					current: e,
					average: this.average.reduce((n, r) => n + r, 0) / this.average.length,
					high:
						typeof t > "u"
							? !1
							: e > this.highLatencyMaxThreshold ||
								(e > this.highLatencyMinThreshold && e > t * this.highLatencyMultiple),
				}),
				this.lastMeasurement
			)
		}
	})()
var E2 = O("pathService"),
	Mp = class {
		constructor(e, t, n, r) {
			this.localUserHome = e
			this.remoteAgentService = t
			this.environmentService = n
			this.contextService = r
			;(this.resolveOS = (async () => (await this.remoteAgentService.getEnvironment())?.os || Ll)()),
				(this.resolveUserHome = (async () => {
					let i = await this.remoteAgentService.getEnvironment()
					return (this.maybeUnresolvedUserHome = i?.userHome ?? e)
				})())
		}
		hasValidBasename(e, t, n) {
			return typeof t == "string" || typeof t > "u"
				? this.resolveOS.then((r) => this.doHasValidBasename(e, r, t))
				: this.doHasValidBasename(e, t, n)
		}
		doHasValidBasename(e, t, n) {
			return e.scheme === W.file || e.scheme === W.vscodeRemote ? rO(n ?? Ht(e), t === 1) : !0
		}
		get defaultUriScheme() {
			return Mp.findDefaultUriScheme(this.environmentService, this.contextService)
		}
		static findDefaultUriScheme(e, t) {
			if (e.remoteAuthority) return W.vscodeRemote
			let n = T2(t.getWorkspace())
			if (n) return n
			let r = t.getWorkspace().folders[0]
			if (r) return r.uri.scheme
			let i = t.getWorkspace().configuration
			return i ? i.scheme : W.file
		}
		userHome(e) {
			return e?.preferLocal ? this.localUserHome : this.resolveUserHome
		}
		get resolvedUserHome() {
			return this.maybeUnresolvedUserHome
		}
		get path() {
			return this.resolveOS.then((e) => (e === 1 ? qt : Ue))
		}
		async fileURI(e) {
			let t = ""
			if (((await this.resolveOS) === 1 && (e = e.replace(/\\/g, "/")), e[0] === "/" && e[1] === "/")) {
				let r = e.indexOf("/", 2)
				r === -1 ? ((t = e.substring(2)), (e = "/")) : ((t = e.substring(2, r)), (e = e.substring(r) || "/"))
			}
			return b.from({ scheme: W.file, authority: t, path: e, query: "", fragment: "" })
		}
	}
Mp = R([S(1, Yx), S(2, Xx), S(3, gi)], Mp)
function k8(o) {
	return typeof o == "object" && "uri" in o && "pattern" in o
}
var oh = class {
	constructor(e, t, n, r, i, s) {
		this.configurationService = e
		this.workspaceContextService = t
		this.editorGroupsService = n
		this.logService = r
		this.pathService = i
		this.uriIdentityService = s
	}
	aiText(e, t, n = {}) {
		return { ...this.commonQuery(t?.map($f), n), type: 3, contentPattern: e }
	}
	text(e, t, n = {}) {
		e = this.getContentPattern(e, n)
		let r = this.configurationService.getValue(),
			i = t && t.some((a) => !this.configurationService.getValue({ resource: a }).search.useRipgrep)
		return {
			...this.commonQuery(t?.map($f), n),
			type: 2,
			contentPattern: e,
			previewOptions: n.previewOptions,
			maxFileSize: n.maxFileSize,
			usePCRE2: r.search.usePCRE2 || i || !1,
			surroundingContext: n.surroundingContext,
			userDisabledExcludesAndIgnoreFiles: n.disregardExcludeSettings && n.disregardIgnoreFiles,
		}
	}
	getContentPattern(e, t) {
		let n = this.configurationService.getValue()
		e.isRegExp && (e.pattern = e.pattern.replace(/\r?\n/g, "\\n"))
		let r = { ...e, wordSeparators: n.editor.wordSeparators }
		return (
			this.isCaseSensitive(e, t) && (r.isCaseSensitive = !0),
			this.isMultiline(e) && (r.isMultiline = !0),
			t.notebookSearchConfig?.includeMarkupInput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookMarkdownInput = t.notebookSearchConfig.includeMarkupInput)),
			t.notebookSearchConfig?.includeMarkupPreview &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookMarkdownPreview = t.notebookSearchConfig.includeMarkupPreview)),
			t.notebookSearchConfig?.includeCodeInput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookCellInput = t.notebookSearchConfig.includeCodeInput)),
			t.notebookSearchConfig?.includeOutput &&
				(r.notebookInfo || (r.notebookInfo = {}),
				(r.notebookInfo.isInNotebookCellOutput = t.notebookSearchConfig.includeOutput)),
			r
		)
	}
	file(e, t = {}) {
		return {
			...this.commonQuery(e, t),
			type: 1,
			filePattern: t.filePattern ? t.filePattern.trim() : t.filePattern,
			exists: t.exists,
			sortByScore: t.sortByScore,
			cacheKey: t.cacheKey,
			shouldGlobMatchFilePattern: t.shouldGlobSearch,
		}
	}
	handleIncludeExclude(e, t) {
		if (!e) return {}
		if (Array.isArray(e)) {
			if (((e = e.filter((n) => n.length > 0).map(Zx)), !e.length)) return {}
		} else e = Zx(e)
		return t ? this.parseSearchPaths(e) : { pattern: qk(...(Array.isArray(e) ? e : [e])) }
	}
	commonQuery(e = [], t = {}) {
		let n = Array.isArray(t.excludePattern) ? t.excludePattern.map((c) => c.pattern).flat() : t.excludePattern
		n = n?.length === 1 ? n[0] : n
		let r = this.handleIncludeExclude(t.includePattern, t.expandPatterns),
			i = this.handleIncludeExclude(n, t.expandPatterns),
			s = e.length > 1,
			a = (
				r.searchPaths && r.searchPaths.length
					? r.searchPaths.map((c) => this.getFolderQueryForSearchPath(c, t, i))
					: e.map((c) => this.getFolderQueryForRoot(c, t, i, s))
			).filter((c) => !!c),
			l = {
				_reason: t._reason,
				folderQueries: a,
				usingSearchPaths: !!(r.searchPaths && r.searchPaths.length),
				extraFileResources: t.extraFileResources,
				excludePattern: i.pattern,
				includePattern: r.pattern,
				onlyOpenEditors: t.onlyOpenEditors,
				maxResults: t.maxResults,
				onlyFileScheme: t.onlyFileScheme,
			}
		if (t.onlyOpenEditors) {
			let c = Ye(this.editorGroupsService.groups.flatMap((f) => f.editors.map((h) => h.resource)))
			this.logService.trace("QueryBuilder#commonQuery - openEditor URIs", JSON.stringify(c))
			let u = c.filter((f) => gk(l, f.fsPath)),
				m = this.commonQueryFromFileList(u)
			return (
				this.logService.trace("QueryBuilder#commonQuery - openEditor Query", JSON.stringify(m)), { ...l, ...m }
			)
		}
		let d = t.extraFileResources && t.extraFileResources.filter((c) => gk(l, c.fsPath))
		return (l.extraFileResources = d && d.length ? d : void 0), l
	}
	commonQueryFromFileList(e) {
		let t = [],
			n = new ft(),
			r = {},
			i = !1
		return (
			e.forEach((s) => {
				if (s.scheme === W.walkThrough) return
				if (vO(s)) {
					let l =
							this.workspaceContextService.getWorkspaceFolder(s)?.uri ??
							this.uriIdentityService.extUri.dirname(s),
						d = n.get(l)
					d || ((i = !0), (d = { folder: l, includePattern: {} }), t.push(d), n.set(l, d))
					let c = Mo(l.fsPath, s.fsPath)
					Ro(d.includePattern)[c.replace(/\\/g, "/")] = !0
				} else s.fsPath && ((i = !0), (r[s.fsPath] = !0))
			}),
			{ folderQueries: t, includePattern: r, usingSearchPaths: !0, excludePattern: i ? void 0 : { "**/*": !0 } }
		)
	}
	isCaseSensitive(e, t) {
		if (t.isSmartCase) {
			if (e.isRegExp) {
				if (OE(e.pattern, !0)) return !0
			} else if (OE(e.pattern)) return !0
		}
		return !!e.isCaseSensitive
	}
	isMultiline(e) {
		return e.isMultiline ||
			(e.isRegExp && Bk(e.pattern)) ||
			e.pattern.indexOf(`
`) >= 0
			? !0
			: !!e.isMultiline
	}
	parseSearchPaths(e) {
		let t = (u) => In(u) || /^\.\.?([\/\\]|$)/.test(u),
			r = (Array.isArray(e) ? e : A8(e)).map((u) => {
				let m = this.pathService.resolvedUserHome
				return m ? b2(u, m.scheme === W.file ? m.fsPath : m.path) : u
			}),
			i = pc(r, (u) => (t(u) ? "searchPaths" : "exprSegments")),
			s = (i.exprSegments || [])
				.map((u) => Rr(u, "/"))
				.map((u) => Rr(u, "\\"))
				.map((u) => (u[0] === "." && (u = "*" + u), O8(u))),
			a = {},
			l = this.expandSearchPathPatterns(i.searchPaths || [])
		l && l.length && (a.searchPaths = l)
		let d = s.flat(),
			c = qk(...d)
		return c && (a.pattern = c), a
	}
	getExcludesForFolder(e, t) {
		return t.disregardExcludeSettings ? void 0 : zF(e, !t.disregardSearchExcludeSettings)
	}
	expandSearchPathPatterns(e) {
		if (!e || !e.length) return []
		let t = e.flatMap((r) => {
				let { pathPortion: i, globPortion: s } = R8(r)
				return (
					s && (s = Kk(s)), this.expandOneSearchPath(i).flatMap((l) => this.resolveOneSearchPathPattern(l, s))
				)
			}),
			n = new Map()
		return (
			t.forEach((r) => {
				let i = r.searchPath.toString(),
					s = n.get(i)
				s
					? r.pattern && ((s.pattern = s.pattern || {}), (s.pattern[r.pattern] = !0))
					: n.set(i, { searchPath: r.searchPath, pattern: r.pattern ? qk(r.pattern) : void 0 })
			}),
			Array.from(n.values())
		)
	}
	expandOneSearchPath(e) {
		if (In(e)) {
			let t = this.workspaceContextService.getWorkspace().folders
			return t[0] && t[0].uri.scheme !== W.file
				? [{ searchPath: t[0].uri.with({ path: e }) }]
				: [{ searchPath: b.file(Gn(e)) }]
		}
		if (this.workspaceContextService.getWorkbenchState() === 2) {
			let t = this.workspaceContextService.getWorkspace().folders[0].uri
			if (((e = Zx(e)), e.startsWith("../") || e === "..")) {
				let r = Ue.resolve(t.path, e)
				return [{ searchPath: t.with({ path: r }) }]
			}
			let n = Kk(e)
			return [{ searchPath: t, pattern: n }]
		} else {
			if (e === "./" || e === ".\\") return []
			{
				let t = e.replace(/^\.[\/\\]/, ""),
					r = this.workspaceContextService
						.getWorkspace()
						.folders.map((i) => {
							let s = t.match(new RegExp(`^${kr(i.name)}(?:/(.*)|$)`))
							return s ? { match: s, folder: i } : null
						})
						.filter(or)
				if (r.length)
					return r.map((i) => {
						let s = i.match[1]
						return { searchPath: i.folder.uri, pattern: s && Kk(s) }
					})
				{
					let i = e.match(/\.[\/\\](.+)[\/\\]?/),
						s = i ? i[1] : e,
						a = p("search.noWorkspaceWithName", "Workspace folder does not exist: {0}", s)
					throw new Error(a)
				}
			}
		}
	}
	resolveOneSearchPathPattern(e, t) {
		let n = e.pattern && t ? `${e.pattern}/${t}` : e.pattern || t,
			r = [{ searchPath: e.searchPath, pattern: n }]
		return n && !n.endsWith("**") && r.push({ searchPath: e.searchPath, pattern: n + "/**" }), r
	}
	getFolderQueryForSearchPath(e, t, n) {
		let r = this.getFolderQueryForRoot($f(e.searchPath), t, n, !1)
		return r ? { ...r, includePattern: e.pattern } : null
	}
	getFolderQueryForRoot(e, t, n, r) {
		let i,
			s = b.isUri(e) ? e : e.uri,
			a = t.excludePattern?.map((f) => {
				let h = t.excludePattern && k8(f) ? f.uri : void 0
				return !h || !(b.isUri(e) && this.uriIdentityService.extUri.isEqual(e, h)) ? h : void 0
			})
		if ((a?.length || (a = [void 0]), n.searchPaths)) {
			let f = n.searchPaths.filter((h) => jr(h.searchPath, s))[0]
			if (f && !f.pattern) return null
			f && (i = f.pattern)
		}
		let l = this.configurationService.getValue({ resource: s }),
			c = { ...(this.getExcludesForFolder(l, t) || {}), ...(i || {}) },
			u = b.isUri(e) ? Ht(e) : e.name,
			m = a.map((f) => (Object.keys(c).length > 0 ? { folder: f, pattern: c } : void 0)).filter((f) => f)
		return {
			folder: s,
			folderName: r ? u : void 0,
			excludePattern: m,
			fileEncoding: l.files && l.files.encoding,
			disregardIgnoreFiles:
				typeof t.disregardIgnoreFiles == "boolean" ? t.disregardIgnoreFiles : !l.search.useIgnoreFiles,
			disregardGlobalIgnoreFiles:
				typeof t.disregardGlobalIgnoreFiles == "boolean"
					? t.disregardGlobalIgnoreFiles
					: !l.search.useGlobalIgnoreFiles,
			disregardParentIgnoreFiles:
				typeof t.disregardParentIgnoreFiles == "boolean"
					? t.disregardParentIgnoreFiles
					: !l.search.useParentIgnoreFiles,
			ignoreSymlinks: typeof t.ignoreSymlinks == "boolean" ? t.ignoreSymlinks : !l.search.followSymlinks,
		}
	}
}
oh = R([S(0, br), S(1, gi), S(2, $y), S(3, te), S(4, E2), S(5, vy)], oh)
function R8(o) {
	let e = o.match(/[\*\{\}\(\)\[\]\?]/)
	if (e) {
		let t = e.index,
			n = o.substr(0, t).match(/[/|\\][^/\\]*$/)
		if (n) {
			let r = o.substr(0, n.index)
			return r.match(/[/\\]/) || (r += "/"), { pathPortion: r, globPortion: o.substr((n.index || 0) + 1) }
		}
	}
	return { pathPortion: o }
}
function qk(...o) {
	return o.length ? o.reduce((e, t) => ((e[t] = !0), e), Object.create(null)) : void 0
}
function A8(o) {
	return sd(o, ",")
		.map((e) => e.trim())
		.filter((e) => !!e.length)
}
function O8(o) {
	return [`**/${o}/**`, `**/${o}`].map((t) => t.replace(/\*\*\/\*\*/g, "**"))
}
function Zx(o) {
	return o.replace(/\\/g, "/")
}
function Kk(o) {
	return Zx(o).replace(/^\.\//, "").replace(/\/+$/g, "")
}
var L8 = 7e3
function P2(o, e) {
	let t = e.activationEvents
	if (!t) return Promise.resolve(void 0)
	let n = [],
		r = []
	for (let c of t)
		if (/^workspaceContains:/.test(c)) {
			let u = c.substr(18)
			u.indexOf("*") >= 0 || u.indexOf("?") >= 0 || o.forceUsingSearch ? r.push(u) : n.push(u)
		}
	if (n.length === 0 && r.length === 0) return Promise.resolve(void 0)
	let { promise: i, resolve: s } = Tf(),
		a = (c) => s({ activationEvent: c }),
		l = Promise.all(n.map((c) => M8(o, c, a))).then(() => {}),
		d = F8(o, e.identifier, r, a)
	return (
		Promise.all([l, d]).then(() => {
			s(void 0)
		}),
		i
	)
}
async function M8(o, e, t) {
	for (let n of o.folders)
		if (await o.exists(ct(b.revive(n), e))) {
			t(`workspaceContains:${e}`)
			return
		}
}
async function F8(o, e, t, n) {
	if (t.length === 0) return Promise.resolve(void 0)
	let r = new _e(),
		i = o.checkExists(o.folders, t, r.token),
		s = setTimeout(async () => {
			r.cancel(),
				o.logService.info(
					`Not activating extension '${e.value}': Timed out while searching for 'workspaceContains' pattern ${t.join(",")}`,
				)
		}, L8),
		a = !1
	try {
		a = await i
	} catch (l) {
		bn(l) || Be(l)
	}
	r.dispose(), clearTimeout(s), a && n(`workspaceContains:${t.join(",")}`)
}
var Fp = class {
		constructor(e) {
			this._onDidChangePassword = new E()
			this.onDidChangePassword = this._onDidChangePassword.event
			this._proxy = e.getProxy(M.MainThreadSecretState)
		}
		async $onDidChangePassword(e) {
			this._onDidChangePassword.fire(e)
		}
		get(e, t) {
			return this._proxy.$getPassword(e, t)
		}
		store(e, t, n) {
			return this._proxy.$setPassword(e, t, n)
		}
		delete(e, t) {
			return this._proxy.$deletePassword(e, t)
		}
	},
	Np = O("IExtHostSecretState")
var eC = class {
	constructor(e, t) {
		this.disposables = new Q()
		;(this._id = Ce.toKey(e.identifier)),
			(this.#e = t),
			(this.onDidChange = Ee.map(
				Ee.filter(this.#e.onDidChangePassword, (n) => n.extensionId === this._id),
				(n) => ({ key: n.key }),
				this.disposables,
			))
	}
	#e
	dispose() {
		this.disposables.dispose()
	}
	get(e) {
		return this.#e.get(this._id, e)
	}
	store(e, t) {
		return this.#e.store(this._id, e, t)
	}
	delete(e) {
		return this.#e.delete(this._id, e)
	}
}
var Up = class {
	constructor(e, t, n) {
		this.logService = n
		this.bundleCache = new Map()
		;(this._proxy = t.getProxy(M.MainThreadLocalization)),
			(this.currentLanguage = e.environment.appLanguage),
			(this.isDefaultLanguage = this.currentLanguage === ui)
	}
	getMessage(e, t) {
		let { message: n, args: r, comment: i } = t
		if (this.isDefaultLanguage) return _E(n, r ?? {})
		let s = n
		i && i.length > 0 && (s += `/${Array.isArray(i) ? i.join("") : i}`)
		let a = this.bundleCache.get(e)?.contents[s]
		return (
			a ||
				this.logService.warn(
					`Using default string since no string found in i18n bundle that has the key: ${s}`,
				),
			_E(a ?? n, r ?? {})
		)
	}
	getBundle(e) {
		return this.bundleCache.get(e)?.contents
	}
	getBundleUri(e) {
		return this.bundleCache.get(e)?.uri
	}
	async initializeLocalizedMessages(e) {
		if (this.isDefaultLanguage || (!e.l10n && !e.isBuiltin) || this.bundleCache.has(e.identifier.value)) return
		let t,
			n = await this.getBundleLocation(e)
		if (!n) {
			this.logService.error(`No bundle location found for extension ${e.identifier.value}`)
			return
		}
		try {
			let r = await this._proxy.$fetchBundleContents(n),
				i = JSON.parse(r)
			t = e.isBuiltin ? i.contents?.bundle : i
		} catch (r) {
			this.logService.error(`Failed to load translations for ${e.identifier.value} from ${n}: ${r.message}`)
			return
		}
		t && this.bundleCache.set(e.identifier.value, { contents: t, uri: n })
	}
	async getBundleLocation(e) {
		if (e.isBuiltin) {
			let t = await this._proxy.$fetchBuiltInBundleUri(e.identifier.value, this.currentLanguage)
			return b.revive(t)
		}
		return e.l10n ? b.joinPath(e.extensionLocation, e.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0
	}
}
Up = R([S(0, Xe), S(1, ie), S(2, te)], Up)
var Hp = O("IExtHostLocalizationService")
var Vp = O("IExtHostManagedSockets"),
	Wp = class {
		constructor(e) {
			this._remoteSocketIdCounter = 0
			this._factory = null
			this._managedRemoteSockets = new Map()
			this._proxy = e.getProxy(M.MainThreadManagedSockets)
		}
		setFactory(e, t) {
			for (let n of this._managedRemoteSockets.values()) n.dispose()
			this._factory && this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId),
				(this._factory = new jk(e, t)),
				this._proxy.$registerSocketFactory(this._factory.socketFactoryId)
		}
		async $openRemoteSocket(e) {
			if (!this._factory || this._factory.socketFactoryId !== e) throw new Error(`No socket factory with id ${e}`)
			let t = ++this._remoteSocketIdCounter,
				n = await this._factory.makeConnection(),
				r = new Q()
			return (
				this._managedRemoteSockets.set(t, new Gk(t, n, r)),
				r.add(q(() => this._managedRemoteSockets.delete(t))),
				r.add(
					n.onDidEnd(() => {
						this._proxy.$onDidManagedSocketEnd(t), r.dispose()
					}),
				),
				r.add(
					n.onDidClose((i) => {
						this._proxy.$onDidManagedSocketClose(t, i?.stack ?? i?.message), r.dispose()
					}),
				),
				r.add(n.onDidReceiveMessage((i) => this._proxy.$onDidManagedSocketHaveData(t, z.wrap(i)))),
				t
			)
		}
		$remoteSocketWrite(e, t) {
			this._managedRemoteSockets.get(e)?.actual.send(t.buffer)
		}
		$remoteSocketEnd(e) {
			let t = this._managedRemoteSockets.get(e)
			t && (t.actual.end(), t.dispose())
		}
		async $remoteSocketDrain(e) {
			await this._managedRemoteSockets.get(e)?.actual.drain?.()
		}
	}
Wp = R([S(0, ie)], Wp)
var jk = class {
		constructor(e, t) {
			this.socketFactoryId = e
			this.makeConnection = t
		}
	},
	Gk = class extends $ {
		constructor(t, n, r) {
			super()
			this.socketId = t
			this.actual = n
			this._register(r)
		}
	}
var Xk = O("IHostUtils"),
	ul = class extends $ {
		constructor(t, n, r, i, s, a, l, d, c, u, m, f, h) {
			super()
			this._extHostManagedSockets = f
			this._extHostLanguageModels = h
			this._onDidChangeRemoteConnectionData = this._register(new E())
			this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event
			this._realPathCache = new Map()
			this._isTerminating = !1
			;(this._hostUtils = n),
				(this._extHostContext = r),
				(this._initData = l),
				(this._extHostWorkspace = i),
				(this._extHostConfiguration = s),
				(this._logService = a),
				(this._extHostTunnelService = c),
				(this._extHostTerminalService = u),
				(this._extHostLocalizationService = m),
				(this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(M.MainThreadWorkspace)),
				(this._mainThreadTelemetryProxy = this._extHostContext.getProxy(M.MainThreadTelemetry)),
				(this._mainThreadExtensionsProxy = this._extHostContext.getProxy(M.MainThreadExtensionService)),
				(this._almostReadyToRunExtensions = new dn()),
				(this._readyToStartExtensionHost = new dn()),
				(this._readyToRunExtensions = new dn()),
				(this._eagerExtensionsActivated = new dn()),
				(this._activationEventsReader = new Jk(this._initData.extensions.activationEvents)),
				(this._globalRegistry = new $s(this._activationEventsReader, this._initData.extensions.allExtensions))
			let g = new ar(this._initData.extensions.myExtensions)
			;(this._myRegistry = new $s(this._activationEventsReader, k2(this._globalRegistry, g))),
				aa &&
					(this._logService.info(
						`Creating extension host with the following global extensions: ${Bp(this._globalRegistry)}`,
					),
					this._logService.info(
						`Creating extension host with the following local extensions: ${Bp(this._myRegistry)}`,
					)),
				(this._storage = new vp(this._extHostContext, this._logService)),
				(this._secretState = new Fp(this._extHostContext)),
				(this._storagePath = d),
				(this._instaService = this._store.add(
					t.createChild(new va([bp, this._storage], [Np, this._secretState])),
				)),
				(this._activator = this._register(
					new mp(
						this._myRegistry,
						this._globalRegistry,
						{
							onExtensionActivationError: (I, C, T) => {
								this._mainThreadExtensionsProxy.$onExtensionActivationError(I, Do(C), T)
							},
							actualActivateExtension: async (I, C) => {
								if ($s.isHostExtension(I, this._myRegistry, this._globalRegistry))
									return await this._mainThreadExtensionsProxy.$activateExtension(I, C), new Vx()
								let T = this._myRegistry.getExtensionDescription(I)
								return this._activateExtension(T, C)
							},
						},
						this._logService,
					),
				)),
				(this._extensionPathIndex = null),
				(this._resolvers = Object.create(null)),
				(this._started = !1),
				(this._remoteConnectionData = this._initData.remote.connectionData)
		}
		getRemoteConnectionData() {
			return this._remoteConnectionData
		}
		async initialize() {
			try {
				await this._beforeAlmostReadyToRunExtensions(),
					this._almostReadyToRunExtensions.open(),
					await this._extHostWorkspace.waitForInitializeCall(),
					Ct("code/extHost/ready"),
					this._readyToStartExtensionHost.open(),
					this._initData.autoStart && this._startExtensionHost()
			} catch (t) {
				Be(t)
			}
		}
		async _deactivateAll() {
			this._storagePath.onWillDeactivateAll()
			let t = []
			try {
				t = this._myRegistry
					.getAllExtensionDescriptions()
					.map((s) => s.identifier)
					.filter((s) => this.isActivated(s))
					.map((s) => this._deactivate(s))
			} catch {}
			await Promise.all(t)
		}
		terminate(t, n = 0) {
			if (this._isTerminating) return
			;(this._isTerminating = !0),
				this._logService.info(`Extension host terminating: ${t}`),
				this._logService.flush(),
				this._extHostTerminalService.dispose(),
				this._activator.dispose(),
				ef((i) => {
					this._logService.error(i)
				}),
				this._extHostContext.dispose()
			let r = this._deactivateAll()
			Promise.race([Wt(5e3), r]).finally(() => {
				this._hostUtils.pid
					? this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${n}`)
					: this._logService.info(`Extension host exiting with code ${n}`),
					this._logService.flush(),
					this._logService.dispose(),
					this._hostUtils.exit(n)
			})
		}
		isActivated(t) {
			return this._readyToRunExtensions.isOpen() ? this._activator.isActivated(t) : !1
		}
		async getExtension(t) {
			let n = await this._mainThreadExtensionsProxy.$getExtension(t)
			return (
				n && { ...n, identifier: new Ce(n.identifier.value), extensionLocation: b.revive(n.extensionLocation) }
			)
		}
		_activateByEvent(t, n) {
			return ht.logIncoming(0, 0, 0, "_activateByEvent: " + t), this._activator.activateByEvent(t, n)
		}
		_activateById(t, n) {
			return this._activator.activateById(t, n)
		}
		activateByIdWithErrors(t, n) {
			return this._activateById(t, n).then(() => {
				let r = this._activator.getActivatedExtension(t)
				if (r.activationFailed) return Promise.reject(r.activationFailedError)
			})
		}
		getExtensionRegistry() {
			return this._readyToRunExtensions.wait().then((t) => this._myRegistry)
		}
		getExtensionExports(t) {
			if (this._readyToRunExtensions.isOpen()) return this._activator.getActivatedExtension(t).exports
			try {
				return this._activator.getActivatedExtension(t).exports
			} catch {
				return null
			}
		}
		async _realPathExtensionUri(t) {
			if (t.scheme === W.file && this._hostUtils.fsRealpath) {
				let n = t.fsPath
				this._realPathCache.has(n) || this._realPathCache.set(n, this._hostUtils.fsRealpath(n))
				let r = await this._realPathCache.get(n)
				return b.file(r)
			}
			return t
		}
		async getExtensionPathIndex() {
			return (
				this._extensionPathIndex ||
					(this._extensionPathIndex = this._createExtensionPathIndex(
						this._myRegistry.getAllExtensionDescriptions(),
					).then((t) => new Qk(t))),
				this._extensionPathIndex
			)
		}
		async _createExtensionPathIndex(t) {
			let n = vr.forUris((r) => Hl.ignorePathCasing(r))
			return (
				await Promise.all(
					t.map(async (r) => {
						if (this._getEntryPoint(r)) {
							let i = await this._realPathExtensionUri(r.extensionLocation)
							n.set(i, r)
						}
					}),
				),
				n
			)
		}
		_deactivate(t) {
			let n = Promise.resolve(void 0)
			if (!this._readyToRunExtensions.isOpen() || !this._activator.isActivated(t)) return n
			let r = this._activator.getActivatedExtension(t)
			if (!r) return n
			try {
				typeof r.module.deactivate == "function" &&
					(n = Promise.resolve(r.module.deactivate()).then(
						void 0,
						(i) => (this._logService.error(i), Promise.resolve(void 0)),
					))
			} catch (i) {
				this._logService.error(`An error occurred when deactivating the extension '${t.value}':`),
					this._logService.error(i)
			}
			try {
				r.disposable.dispose()
			} catch (i) {
				this._logService.error(
					`An error occurred when disposing the subscriptions for extension '${t.value}':`,
				),
					this._logService.error(i)
			}
			return n
		}
		async _activateExtension(t, n) {
			return (
				this._initData.remote.isRemote
					? this._mainThreadExtensionsProxy.$onWillActivateExtension(t.identifier)
					: await this._mainThreadExtensionsProxy.$onWillActivateExtension(t.identifier),
				this._doActivateExtension(t, n).then(
					(r) => {
						let i = r.activationTimes
						return (
							this._mainThreadExtensionsProxy.$onDidActivateExtension(
								t.identifier,
								i.codeLoadingTime,
								i.activateCallTime,
								i.activateResolvedTime,
								n,
							),
							this._logExtensionActivationTimes(t, n, "success", i),
							r
						)
					},
					(r) => {
						throw (this._logExtensionActivationTimes(t, n, "failure"), r)
					},
				)
			)
		}
		_logExtensionActivationTimes(t, n, r, i) {
			let s = D2(t, n)
			this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", { ...s, ...(i || {}), outcome: r })
		}
		_doActivateExtension(t, n) {
			let r = D2(t, n)
			this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", r)
			let i = this._getEntryPoint(t)
			if (!i) return Promise.resolve(new Wx(Md.NONE))
			this._logService.info(
				`ExtensionService#_doActivateExtension ${t.identifier.value}, startup: ${n.startup}, activationEvent: '${n.activationEvent}'${t.identifier.value !== n.extensionId.value ? `, root cause: ${n.extensionId.value}` : ""}`,
			),
				this._logService.flush()
			let s = this._isESM(t),
				a = new Q(),
				l = new fp(n.startup)
			return Promise.all([
				s
					? this._loadESMModule(t, ct(t.extensionLocation, i), l)
					: this._loadCommonJSModule(t, ct(t.extensionLocation, i), l),
				this._loadExtensionContext(t, a),
			])
				.then(
					(d) => (
						Ct(`code/extHost/willActivateExtension/${t.identifier.value}`),
						ul._callActivate(this._logService, t.identifier, d[0], d[1], a, l)
					),
				)
				.then((d) => (Ct(`code/extHost/didActivateExtension/${t.identifier.value}`), d))
		}
		_loadExtensionContext(t, n) {
			let r = this._extHostLanguageModels.createLanguageModelAccessInformation(t),
				i = n.add(new Bx(t, this._storage)),
				s = n.add(new Jg(t.identifier.value, !1, this._storage)),
				a = n.add(new eC(t, this._secretState)),
				l = t.isUnderDevelopment ? (this._initData.environment.extensionTestsLocationURI ? 3 : 2) : 1,
				d = this._initData.remote.isRemote ? 2 : 1
			return (
				this._logService.trace(`ExtensionService#loadExtensionContext ${t.identifier.value}`),
				Promise.all([i.whenReady, s.whenReady, this._storagePath.whenReady]).then(() => {
					let c = this,
						u,
						m,
						f = nt(t, "ipc") ? this._initData.messagePorts?.get(Ce.toKey(t.identifier)) : void 0
					return Object.freeze({
						globalState: i,
						workspaceState: s,
						secrets: a,
						subscriptions: [],
						get languageModelAccessInformation() {
							return r
						},
						get extensionUri() {
							return t.extensionLocation
						},
						get extensionPath() {
							return t.extensionLocation.fsPath
						},
						asAbsolutePath(h) {
							return Fe(t.extensionLocation.fsPath, h)
						},
						get storagePath() {
							return c._storagePath.workspaceValue(t)?.fsPath
						},
						get globalStoragePath() {
							return c._storagePath.globalValue(t).fsPath
						},
						get logPath() {
							return Fe(c._initData.logsLocation.fsPath, t.identifier.value)
						},
						get logUri() {
							return b.joinPath(c._initData.logsLocation, t.identifier.value)
						},
						get storageUri() {
							return c._storagePath.workspaceValue(t)
						},
						get globalStorageUri() {
							return c._storagePath.globalValue(t)
						},
						get extensionMode() {
							return l
						},
						get extension() {
							return u === void 0 && (u = new pl(c, t.identifier, t, d, !1)), u
						},
						get extensionRuntime() {
							return F(t, "extensionRuntime"), c.extensionRuntime
						},
						get environmentVariableCollection() {
							return c._extHostTerminalService.getEnvironmentVariableCollection(t)
						},
						get messagePassingProtocol() {
							if (!m) {
								if (!f) return
								let h = Ee.buffer(Ee.fromDOMEventEmitter(f, "message", (g) => g.data))
								f.start(), (m = { onDidReceiveMessage: h, postMessage: f.postMessage.bind(f) })
							}
							return m
						},
					})
				})
			)
		}
		static _callActivate(t, n, r, i, s, a) {
			return (
				(r = r || { activate: void 0, deactivate: void 0 }),
				this._callActivateOptional(t, n, r, i, a).then(
					(l) =>
						new Fd(
							!1,
							null,
							a.build(),
							r,
							l,
							q(() => {
								s.dispose(), Nn(i.subscriptions)
							}),
						),
				)
			)
		}
		static _callActivateOptional(t, n, r, i, s) {
			if (typeof r.activate == "function")
				try {
					s.activateCallStart(), t.trace(`ExtensionService#_callActivateOptional ${n.value}`)
					let a = typeof global == "object" ? global : self,
						l = r.activate.apply(a, [i])
					return (
						s.activateCallStop(),
						s.activateResolveStart(),
						Promise.resolve(l).then((d) => (s.activateResolveStop(), d))
					)
				} catch (a) {
					return Promise.reject(a)
				}
			else return Promise.resolve(r)
		}
		_activateOneStartupFinished(t, n) {
			this._activateById(t.identifier, { startup: !1, extensionId: t.identifier, activationEvent: n }).then(
				void 0,
				(r) => {
					this._logService.error(r)
				},
			)
		}
		_activateAllStartupFinishedDeferred(t, n = 0) {
			let i = Date.now()
			wv(() => {
				for (let s = n; s < t.length; s += 1) {
					let a = t[s]
					for (let l of a.activationEvents ?? [])
						if (l === "onStartupFinished")
							if (Date.now() - i > 50) {
								this._activateAllStartupFinishedDeferred(t, s)
								break
							} else this._activateOneStartupFinished(a, l)
				}
			})
		}
		_activateAllStartupFinished() {
			ht.logIncoming(0, 0, 0, "activateAllStartupFinished start"),
				this._mainThreadExtensionsProxy.$setPerformanceMarks(DO()),
				this._extHostConfiguration.getConfigProvider().then((t) => {
					ht.logIncoming(0, 0, 0, "activateAllStartupFinished getConfigProvider")
					let n = t.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation"),
						r = this._myRegistry.getAllExtensionDescriptions()
					if (n)
						ht.logIncoming(0, 0, 0, "activateAllStartupFinished shouldDeferActivation"),
							this._activateAllStartupFinishedDeferred(r)
					else {
						ht.logIncoming(0, 0, 0, "activateAllStartupFinished !shouldDeferActivation")
						for (let i of r)
							if (i.activationEvents)
								for (let s of i.activationEvents)
									s === "onStartupFinished" && this._activateOneStartupFinished(i, s)
					}
				})
		}
		_handleEagerExtensions() {
			ht.logIncoming(0, 0, 0, "handleEagerExtensions start")
			let t = this._activateByEvent("*", !0).then(void 0, (a) => {
				this._logService.error(a)
			})
			this._register(
				this._extHostWorkspace.onDidChangeWorkspace((a) =>
					this._handleWorkspaceContainsEagerExtensions(a.added),
				),
			)
			let n = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [],
				r = this._handleWorkspaceContainsEagerExtensions(n),
				i = this._handleRemoteResolverEagerExtensions(),
				s = Promise.all([i, t, r]).then(() => {})
			return (
				Promise.race([s, Wt(1e4)]).then(() => {
					this._activateAllStartupFinished()
				}),
				s
			)
		}
		_handleWorkspaceContainsEagerExtensions(t) {
			return (
				ht.logIncoming(0, 0, 0, "handleWorkspaceContainsEagerExtensions start: " + t.length),
				t.length === 0
					? Promise.resolve(void 0)
					: Promise.all(
							this._myRegistry
								.getAllExtensionDescriptions()
								.map((n) => this._handleWorkspaceContainsEagerExtension(t, n)),
						).then(() => {
							ht.logIncoming(0, 0, 0, "handleWorkspaceContainsEagerExtensions end")
						})
			)
		}
		async _handleWorkspaceContainsEagerExtension(t, n) {
			if (this.isActivated(n.identifier)) return
			let r = !this._initData.remote.isRemote && !!this._initData.remote.authority,
				i = {
					logService: this._logService,
					folders: t.map((a) => a.uri),
					forceUsingSearch: r || !this._hostUtils.fsExists,
					exists: (a) => this._hostUtils.fsExists(a.fsPath),
					checkExists: (a, l, d) => this._mainThreadWorkspaceProxy.$checkExists(a, l, d),
				},
				s = await P2(i, n)
			if (s)
				return this._activateById(n.identifier, {
					startup: !0,
					extensionId: n.identifier,
					activationEvent: s.activationEvent,
				}).then(void 0, (a) => this._logService.error(a))
		}
		async _handleRemoteResolverEagerExtensions() {
			if ((ht.logIncoming(0, 0, 0, "handleRemoteResolverEagerExtensions start"), this._initData.remote.authority))
				return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, !1)
		}
		async $extensionTestsExecute() {
			await this._eagerExtensionsActivated.wait()
			try {
				return await this._doHandleExtensionTests()
			} catch (t) {
				throw (console.error(t), t)
			}
		}
		async _doHandleExtensionTests() {
			let { extensionDevelopmentLocationURI: t, extensionTestsLocationURI: n } = this._initData.environment
			if (!t || !n) throw new Error(p("extensionTestError1", "Cannot load test runner."))
			let r = (await this.getExtensionPathIndex()).findSubstr(n),
				s = await (this._isESM(r, n.path)
					? this._loadESMModule(null, n, new fp(!1))
					: this._loadCommonJSModule(null, n, new fp(!1)))
			if (!s || typeof s.run != "function")
				throw new Error(
					p("extensionTestError", "Path {0} does not point to a valid extension test runner.", n.toString()),
				)
			return new Promise((a, l) => {
				let d = (m, f) => {
						m
							? (aa && this._logService.error("Test runner called back with error", m), l(m))
							: (aa &&
									(f
										? this._logService.info(`Test runner called back with ${f} failures.`)
										: this._logService.info("Test runner called back with successful outcome.")),
								a(typeof f == "number" && f > 0 ? 1 : 0))
					},
					c = so(n),
					u = s.run(c, d)
				u &&
					u.then &&
					u
						.then(() => {
							aa && this._logService.info("Test runner finished successfully."), a(0)
						})
						.catch((m) => {
							aa && this._logService.error("Test runner finished with error", m),
								l(m instanceof Error && m.stack ? m.stack : String(m))
						})
			})
		}
		_startExtensionHost() {
			if ((ht.logIncoming(0, 0, 0, "startExtensionHost start"), this._started))
				throw (
					(ht.logIncoming(0, 0, 0, "Extension host is already started!"),
					new Error("Extension host is already started!"))
				)
			return (
				(this._started = !0),
				this._readyToStartExtensionHost
					.wait()
					.then(() => this._readyToRunExtensions.open())
					.then(() => Promise.race([this._activator.waitForActivatingExtensions(), Wt(1e3)]))
					.then(() => this._handleEagerExtensions())
					.then(() => {
						this._eagerExtensionsActivated.open(), this._logService.info("Eager extensions activated")
					})
			)
		}
		registerRemoteAuthorityResolver(t, n) {
			return (
				(this._resolvers[t] = n),
				q(() => {
					delete this._resolvers[t]
				})
			)
		}
		async getRemoteExecServer(t) {
			let { resolver: n } = await this._activateAndGetResolver(t)
			return n?.resolveExecServer?.(t, { resolveAttempt: 0 })
		}
		async _activateAndGetResolver(t) {
			let n = t.indexOf("+")
			if (n === -1) throw new _i("Not an authority that can be resolved!", "InvalidAuthority")
			let r = t.substr(0, n)
			return (
				await this._almostReadyToRunExtensions.wait(),
				await this._activateByEvent(`onResolveRemoteAuthority:${r}`, !1),
				{ authorityPrefix: r, resolver: this._resolvers[r] }
			)
		}
		async $resolveAuthority(t, n) {
			let r = zt.create(!1),
				i = () => `[resolveAuthority(${G_(t)},${n})][${r.elapsed()}ms] `,
				s = (w) => this._logService.info(`${i()}${w}`),
				a = (w) => this._logService.warn(`${i()}${w}`),
				l = (w, L = void 0) => this._logService.error(`${i()}${w}`, L),
				d = (w) => {
					if (w instanceof _i)
						return { type: "error", error: { code: w._code, message: w._message, detail: w._detail } }
					throw w
				},
				c = async (w) => {
					s(`activating resolver for ${w}...`)
					let { resolver: L, authorityPrefix: A } = await this._activateAndGetResolver(w)
					if (!L)
						throw (
							(l(`no resolver for ${A}`),
							new _i(`No remote extension installed to resolve ${A}.`, "NoResolverFound"))
						)
					return { resolver: L, authorityPrefix: A, remoteAuthority: w }
				},
				u = t.split(/@|%40/g).reverse()
			s(`activating remote resolvers ${u.join(" -> ")}`)
			let m
			try {
				m = await Promise.all(u.map(c)).catch(async (w) => {
					if (!(w instanceof _i) || w._code !== "InvalidAuthority") throw w
					return a(`resolving nested authorities failed: ${w.message}`), [await c(t)]
				})
			} catch (w) {
				return d(w)
			}
			let f = new _c()
			f.cancelAndSet(() => s("waiting..."), 1e3)
			let h, g
			for (let [w, { authorityPrefix: L, resolver: A, remoteAuthority: J }] of m.entries())
				try {
					if (w === m.length - 1)
						s("invoking final resolve()..."),
							Ct(`code/extHost/willResolveAuthority/${L}`),
							(h = await A.resolve(J, { resolveAttempt: n, execServer: g })),
							Ct(`code/extHost/didResolveAuthorityOK/${L}`),
							s("setting tunnel factory..."),
							this._register(
								await this._extHostTunnelService.setTunnelFactory(
									A,
									za.isManagedResolvedAuthority(h) ? h : void 0,
								),
							)
					else {
						if (
							(s(`invoking resolveExecServer() for ${J}`),
							Ct(`code/extHost/willResolveExecServer/${L}`),
							(g = await A.resolveExecServer?.(J, { resolveAttempt: n, execServer: g })),
							!g)
						)
							throw new _i(`Exec server was not available for ${J}`, "NoResolverFound")
						Ct(`code/extHost/didResolveExecServerOK/${L}`)
					}
				} catch (ne) {
					return (
						Ct(`code/extHost/didResolveAuthorityError/${L}`), l("returned an error", ne), f.dispose(), d(ne)
					)
				}
			f.dispose()
			let I = {
					environmentTunnels: h.environmentTunnels,
					features: h.tunnelFeatures
						? {
								elevation: h.tunnelFeatures.elevation,
								privacyOptions: h.tunnelFeatures.privacyOptions,
								protocol: h.tunnelFeatures.protocol === void 0 ? !0 : h.tunnelFeatures.protocol,
							}
						: void 0,
				},
				C = {
					extensionHostEnv: h.extensionHostEnv,
					isTrusted: h.isTrusted,
					authenticationSession: h.authenticationSessionForInitializingExtensions
						? {
								id: h.authenticationSessionForInitializingExtensions.id,
								providerId: h.authenticationSessionForInitializingExtensions.providerId,
							}
						: void 0,
				}
			s(`returned ${za.isManagedResolvedAuthority(h) ? "managed authority" : `${h.host}:${h.port}`}`)
			let T
			if (za.isManagedResolvedAuthority(h)) {
				let w = n
				this._extHostManagedSockets.setFactory(w, h.makeConnection),
					(T = { authority: t, connectTo: new uu(w), connectionToken: h.connectionToken })
			} else T = { authority: t, connectTo: new qy(h.host, h.port), connectionToken: h.connectionToken }
			return { type: "ok", value: { authority: T, options: C, tunnelInformation: I } }
		}
		async $getCanonicalURI(t, n) {
			this._logService.info(`$getCanonicalURI invoked for authority (${G_(t)})`)
			let { resolver: r } = await this._activateAndGetResolver(t)
			if (!r) return null
			let i = b.revive(n)
			if (typeof r.getCanonicalURI > "u") return i
			let s = await Jt(() => r.getCanonicalURI(i))
			return s || i
		}
		async $startExtensionHost(t) {
			t.toAdd.forEach((a) => (a.extensionLocation = b.revive(a.extensionLocation)))
			let { globalRegistry: n, myExtensions: r } = _2(
					this._activationEventsReader,
					this._globalRegistry,
					this._myRegistry,
					t,
				),
				i = await this._createExtensionPathIndex(r)
			return (
				(await this.getExtensionPathIndex()).setSearchTree(i),
				this._globalRegistry.set(n.getAllExtensionDescriptions()),
				this._myRegistry.set(r),
				aa &&
					(this._logService.info(`$startExtensionHost: global extensions: ${Bp(this._globalRegistry)}`),
					this._logService.info(`$startExtensionHost: local extensions: ${Bp(this._myRegistry)}`)),
				this._startExtensionHost()
			)
		}
		$activateByEvent(t, n) {
			return n === 1
				? this._almostReadyToRunExtensions.wait().then((r) => this._activateByEvent(t, !1))
				: this._readyToRunExtensions.wait().then((r) => this._activateByEvent(t, !1))
		}
		async $activate(t, n) {
			return (
				console.log("activate", t, n),
				await this._readyToRunExtensions.wait(),
				this._myRegistry.getExtensionDescription(t) ? (await this._activateById(t, n), !0) : !1
			)
		}
		async $deltaExtensions(t) {
			t.toAdd.forEach((a) => (a.extensionLocation = b.revive(a.extensionLocation)))
			let { globalRegistry: n, myExtensions: r } = _2(
					this._activationEventsReader,
					this._globalRegistry,
					this._myRegistry,
					t,
				),
				i = await this._createExtensionPathIndex(r)
			return (
				(await this.getExtensionPathIndex()).setSearchTree(i),
				this._globalRegistry.set(n.getAllExtensionDescriptions()),
				this._myRegistry.set(r),
				aa &&
					(this._logService.info(`$deltaExtensions: global extensions: ${Bp(this._globalRegistry)}`),
					this._logService.info(`$deltaExtensions: local extensions: ${Bp(this._myRegistry)}`)),
				Promise.resolve(void 0)
			)
		}
		async $test_latency(t) {
			return t
		}
		async $test_up(t) {
			return t.byteLength
		}
		async $test_down(t) {
			let n = z.alloc(t),
				r = Math.random() % 256
			for (let i = 0; i < t; i++) n.writeUInt8(r, i)
			return n
		}
		async $updateRemoteConnectionData(t) {
			;(this._remoteConnectionData = t), this._onDidChangeRemoteConnectionData.fire()
		}
		_isESM(t, n) {
			return (n ??= t?.main), n?.endsWith(".mjs") || t?.type === "module"
		}
	}
ul = R(
	[
		S(0, Wo),
		S(1, Xk),
		S(2, ie),
		S(3, Sn),
		S(4, pn),
		S(5, te),
		S(6, Xe),
		S(7, Ip),
		S(8, ll),
		S(9, tr),
		S(10, Hp),
		S(11, Vp),
		S(12, Ap),
	],
	ul,
)
function _2(o, e, t, n) {
	o.addActivationEvents(n.addActivationEvents)
	let r = new $s(o, e.getAllExtensionDescriptions())
	r.deltaExtensions(n.toAdd, n.toRemove)
	let i = new ar(t.getAllExtensionDescriptions().map((a) => a.identifier))
	for (let a of n.myToRemove) i.delete(a)
	for (let a of n.myToAdd) i.add(a)
	let s = k2(r, i)
	return { globalRegistry: r, myExtensions: s }
}
function D2(o, e) {
	return {
		id: o.identifier.value,
		name: o.name,
		extensionVersion: o.version,
		publisherDisplayName: o.publisher,
		activationEvents: o.activationEvents ? o.activationEvents.join(",") : null,
		isBuiltin: o.isBuiltin,
		reason: e.activationEvent,
		reasonId: e.extensionId.value,
	}
}
function Bp(o) {
	return o
		.getAllExtensionDescriptions()
		.map((e) => e.identifier.value)
		.join(",")
}
var pr = O("IExtHostExtensionService"),
	pl = class {
		#e
		#t
		#n
		constructor(e, t, n, r, i) {
			;(this.#e = e),
				(this.#t = t),
				(this.#n = n.identifier),
				(this.id = n.identifier.value),
				(this.extensionUri = n.extensionLocation),
				(this.extensionPath = Gn(so(n.extensionLocation))),
				(this.packageJSON = n),
				(this.extensionKind = r),
				(this.isFromDifferentExtensionHost = i)
		}
		get isActive() {
			return this.#e.isActivated(this.#n)
		}
		get exports() {
			if (!(this.packageJSON.api === "none" || this.isFromDifferentExtensionHost))
				return this.#e.getExtensionExports(this.#n)
		}
		async activate() {
			if (this.isFromDifferentExtensionHost) throw new Error("Cannot activate foreign extension")
			return (
				await this.#e.activateByIdWithErrors(this.#n, {
					startup: !1,
					extensionId: this.#t,
					activationEvent: "api",
				}),
				this.exports
			)
		}
	}
function k2(o, e) {
	return o.getAllExtensionDescriptions().filter((t) => e.has(t.identifier))
}
var Qk = class {
		constructor(e) {
			this._searchTree = e
		}
		setSearchTree(e) {
			this._searchTree = e
		}
		findSubstr(e) {
			return this._searchTree.findSubstr(e)
		}
		forEach(e) {
			return this._searchTree.forEach(e)
		}
	},
	Jk = class {
		constructor(e) {
			this._map = new Ln()
			this.addActivationEvents(e)
		}
		readActivationEvents(e) {
			return this._map.get(e.identifier) ?? []
		}
		addActivationEvents(e) {
			for (let t of Object.keys(e)) this._map.set(t, e[t])
		}
	}
import * as $p from "fs"
import * as Yk from "path"
import * as R2 from "os"
var ml = class {
	constructor(e) {
		this._totalIncoming = 0
		this._totalOutgoing = 0
		this._writeStream = null
		this._logQueue = []
		this._isInitialized = !1
		this._isDisposed = !1
		this._processInterval = null
		this._isEnabled = !1
		if (!this._isEnabled) return
		;(this._logDir = Yk.join(R2.homedir(), ".ext_host", "log")), this._ensureLogDirectoryExists()
		let t = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").slice(0, 19),
			n = e ? `_${e}` : ""
		this._logFile = Yk.join(this._logDir, `rpc${n}_${t}.log`)
		try {
			this._writeStream = $p.createWriteStream(this._logFile, { flags: "a" })
			let r = new Date(),
				s = [
					"-------------------------------------------------------------",
					"Extension Host RPC Protocol Logger",
					`Started at: ${this._formatTimestampWithMilliseconds(r)}`,
					`Log file: ${this._logFile}`,
					"-------------------------------------------------------------",
					"",
				].join(`
`)
			this._logQueue.push(s),
				this._startProcessingQueue(),
				(this._isInitialized = !0),
				console.log(`FileRPCProtocolLogger initialized, log file: ${this._logFile}`)
		} catch (r) {
			console.error("Failed to initialize FileRPCProtocolLogger", r)
		}
	}
	_ensureLogDirectoryExists() {
		if (this._logDir)
			try {
				$p.existsSync(this._logDir) || $p.mkdirSync(this._logDir, { recursive: !0 })
			} catch (e) {
				console.error("Failed to create log directory", e)
			}
	}
	_startProcessingQueue() {
		this._processInterval = setInterval(() => {
			this._processQueue()
		}, 100)
	}
	_processQueue() {
		if (!(this._isDisposed || !this._writeStream || this._logQueue.length === 0))
			try {
				let e = this._logQueue.splice(0, Math.min(50, this._logQueue.length))
				for (let t of e)
					this._writeStream.write(
						t +
							`
`,
					)
			} catch (e) {
				console.error("Failed to write log entries", e)
			}
	}
	logIncoming(e, t, n, r, i) {
		this._isInitialized &&
			((this._totalIncoming += e), this._logMessage("IDEA \u2192 Ext", this._totalIncoming, e, t, n, r, i))
	}
	logOutgoing(e, t, n, r, i) {
		this._isInitialized &&
			((this._totalOutgoing += e), this._logMessage("Ext \u2192 IDEA", this._totalOutgoing, e, t, n, r, i))
	}
	_logMessage(e, t, n, r, i, s, a) {
		try {
			let l = new Date(),
				d = this._formatTimestampWithMilliseconds(l),
				c = i === 0 ? "Local" : "Other",
				u = `[${d}] `
			if (
				((u += `[${e}] `),
				(u += `[Total: ${String(t).padStart(7)}] `),
				(u += `[Len: ${String(n).padStart(5)}] `),
				(u += `[${String(r).padStart(5)}] `),
				(u += `[${c}] `),
				(u += s),
				a !== void 0)
			) {
				let m = /\($/.test(s) ? `${this._stringify(a)})` : this._stringify(a)
				u += ` ${m}`
			}
			this._logQueue.push(u)
		} catch (l) {
			console.error("Failed to format log message", l)
		}
	}
	_stringify(e) {
		try {
			return JSON.stringify(e, null, 0)
		} catch {
			return String(e)
		}
	}
	dispose() {
		if (!this._isDisposed) {
			this._isDisposed = !0
			try {
				this._processInterval && (clearInterval(this._processInterval), (this._processInterval = null)),
					this._processQueue()
				let e = new Date(),
					n = [
						"-------------------------------------------------------------",
						"Extension Host RPC Protocol Logger",
						`Ended at: ${this._formatTimestampWithMilliseconds(e)}`,
						`Total incoming: ${this._totalIncoming} bytes`,
						`Total outgoing: ${this._totalOutgoing} bytes`,
						"-------------------------------------------------------------",
					].join(`
`)
				this._writeStream &&
					(this._writeStream.write(
						n +
							`
`,
					),
					this._writeStream.end(),
					(this._writeStream = null)),
					console.log("FileRPCProtocolLogger disposed")
			} catch (e) {
				console.error("Failed to dispose FileRPCProtocolLogger", e)
			}
		}
	}
	_formatTimestampWithMilliseconds(e) {
		let t = e.getFullYear(),
			n = String(e.getMonth() + 1).padStart(2, "0"),
			r = String(e.getDate()).padStart(2, "0"),
			i = String(e.getHours()).padStart(2, "0"),
			s = String(e.getMinutes()).padStart(2, "0"),
			a = String(e.getSeconds()).padStart(2, "0"),
			l = String(e.getMilliseconds()).padStart(3, "0")
		return `${t}-${n}-${r} ${i}:${s}:${a}.${l}`
	}
}
var tC = class {
		static async installEarlyHandler(e) {
			Error.stackTraceLimit = 100
			let t = e.get(te),
				r = e.get(ie).getProxy(M.MainThreadErrors)
			ef((i) => {
				t.error(i)
				let s = Do(i)
				r.$onUnexpectedError(s)
			})
		}
		static async installFullHandler(e) {
			let t = e.get(te),
				n = e.get(ie),
				r = e.get(pr),
				i = e.get(cl),
				s = n.getProxy(M.MainThreadExtensionService),
				a = n.getProxy(M.MainThreadErrors),
				l = await r.getExtensionPathIndex(),
				d = new WeakMap()
			function c(f, h) {
				if (d.has(f)) return d.get(f).stack
				let g = "",
					I,
					C
				for (let w of h)
					(g += `
	at ${w.toString()}`),
						(C = w.getFileName()),
						!I && C && (I = l.findSubstr(b.file(C)))
				let T = `${f.name || "Error"}: ${f.message || ""}${g}`
				return d.set(f, { extensionIdentifier: I?.identifier, stack: T }), T
			}
			let u = Symbol("prepareStackTrace wrapped"),
				m = c
			Object.defineProperty(Error, "prepareStackTrace", {
				configurable: !1,
				get() {
					return m
				},
				set(f) {
					if (f === c || !f || f[u]) {
						m = f || c
						return
					}
					;(m = function (h, g) {
						return c(h, g), f.call(Error, h, g)
					}),
						Object.assign(m, { [u]: !0 })
				},
			}),
				ef((f) => {
					t.error(f)
					let h = Do(f),
						g
					if ((f instanceof Hc ? (g = f.extension) : (g = d.get(f)?.extensionIdentifier), g)) {
						s.$onExtensionRuntimeError(g, h)
						let I = i.onExtensionError(g, f)
						t.trace("forwarded error to extension?", I, g)
					}
				}),
				cc.addListener((f) => {
					let h = Do(f)
					a.$onUnexpectedError(h)
				})
		}
	},
	nC = class o {
		constructor(e, t, n, r, i) {
			;(this._hostUtils = n),
				(this._rpcProtocol = new Uc(e, new ml("extension_protocol"), r)),
				(t = o._transform(t, this._rpcProtocol))
			let s = new va(...pL())
			s.set(Xe, { _serviceBrand: void 0, ...t, messagePorts: i }),
				s.set(ie, new yb(this._rpcProtocol)),
				s.set(fi, new Ib(r)),
				s.set(Xk, n)
			let a = new bb(s, !0)
			a.invokeFunction(tC.installEarlyHandler),
				(this._logService = a.invokeFunction((l) => l.get(te))),
				Ct("code/extHost/didCreateServices"),
				this._hostUtils.pid
					? this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`)
					: this._logService.info("Extension host started"),
				this._logService.trace("initData", t),
				(this._extensionService = a.invokeFunction((l) => l.get(pr))),
				this._extensionService.initialize(),
				a.invokeFunction(tC.installFullHandler)
		}
		async asBrowserUri(e) {
			let t = this._rpcProtocol.getProxy(M.MainThreadExtensionService)
			return b.revive(await t.$asBrowserUri(e))
		}
		terminate(e) {
			this._extensionService.terminate(e)
		}
		static _transform(e, t) {
			e.extensions.allExtensions.forEach((r) => {
				r.extensionLocation = b.revive(t.transformIncomingURIs(r.extensionLocation))
			}),
				(e.environment.appRoot = b.revive(t.transformIncomingURIs(e.environment.appRoot)))
			let n = e.environment.extensionDevelopmentLocationURI
			return (
				n &&
					(e.environment.extensionDevelopmentLocationURI = n.map((r) =>
						b.revive(t.transformIncomingURIs(r)),
					)),
				(e.environment.extensionTestsLocationURI = b.revive(
					t.transformIncomingURIs(e.environment.extensionTestsLocationURI),
				)),
				(e.environment.globalStorageHome = b.revive(t.transformIncomingURIs(e.environment.globalStorageHome))),
				(e.environment.workspaceStorageHome = b.revive(
					t.transformIncomingURIs(e.environment.workspaceStorageHome),
				)),
				(e.nlsBaseUrl = b.revive(t.transformIncomingURIs(e.nlsBaseUrl))),
				(e.logsLocation = b.revive(t.transformIncomingURIs(e.logsLocation))),
				(e.workspace = t.transformIncomingURIs(e.workspace)),
				e
			)
		}
	}
function N8(o) {
	return {
		transformIncoming: (e) =>
			e.scheme === "vscode-remote"
				? { scheme: "file", path: e.path, query: e.query, fragment: e.fragment }
				: e.scheme === "file"
					? { scheme: "vscode-local", path: e.path, query: e.query, fragment: e.fragment }
					: e,
		transformOutgoing: (e) =>
			e.scheme === "file"
				? { scheme: "vscode-remote", authority: o, path: e.path, query: e.query, fragment: e.fragment }
				: e.scheme === "vscode-local"
					? { scheme: "file", path: e.path, query: e.query, fragment: e.fragment }
					: e,
		transformOutgoingScheme: (e) => (e === "file" ? "vscode-remote" : e === "vscode-local" ? "file" : e),
	}
}
function A2(o) {
	return new pb(N8(o))
}
var zp = class o {
		constructor(e) {
			this.pipeName = e
			this.type = 1
		}
		static {
			this.ENV_KEY = "VSCODE_EXTHOST_IPC_HOOK"
		}
		serialize(e) {
			e[o.ENV_KEY] = this.pipeName
		}
	},
	ih = class o {
		constructor() {
			this.type = 2
		}
		static {
			this.ENV_KEY = "VSCODE_EXTHOST_WILL_SEND_SOCKET"
		}
		serialize(e) {
			e[o.ENV_KEY] = "1"
		}
	},
	sh = class o {
		constructor() {
			this.type = 3
		}
		static {
			this.ENV_KEY = "VSCODE_WILL_SEND_MESSAGE_PORT"
		}
		serialize(e) {
			e[o.ENV_KEY] = "1"
		}
	}
function U8(o) {
	delete o[zp.ENV_KEY], delete o[ih.ENV_KEY], delete o[sh.ENV_KEY]
}
function O2(o) {
	if (o[zp.ENV_KEY]) return Zk(o, new zp(o[zp.ENV_KEY]))
	if (o[ih.ENV_KEY]) return Zk(o, new ih())
	if (o[sh.ENV_KEY]) return Zk(o, new sh())
	throw new Error("No connection information defined in environment!")
}
function Zk(o, e) {
	return U8(o), e
}
var qSe = new D("inOutput", !1),
	KSe = new D("activeLogOutput", !1),
	jSe = new D("activeLogOutput.isLog", !1),
	GSe = new D("activeLogOutput.levelSettable", !1),
	QSe = new D("activeLogOutput.level", ""),
	JSe = new D("activeLogOutput.levelIsDefault", !1),
	XSe = new D("outputView.scrollLock", !1),
	YSe = new D("activeOutputChannel", ""),
	ZSe = new D("output.filter.trace", !0),
	eTe = new D("output.filter.debug", !0),
	tTe = new D("output.filter.info", !0),
	nTe = new D("output.filter.warning", !0),
	rTe = new D("output.filter.error", !0),
	oTe = new D("outputFilterFocus", !1),
	iTe = new D("output.filter.categories", ""),
	sTe = O("outputService")
var H8 = { OutputChannels: "workbench.contributions.outputChannels" }
function W8(o) {
	return Array.isArray(o.source)
}
var eR = class {
	constructor() {
		this.channels = new Map()
		this._onDidRegisterChannel = new E()
		this.onDidRegisterChannel = this._onDidRegisterChannel.event
		this._onDidRemoveChannel = new E()
		this.onDidRemoveChannel = this._onDidRemoveChannel.event
		this._onDidUpdateChannelFiles = new E()
		this.onDidUpdateChannelSources = this._onDidUpdateChannelFiles.event
	}
	registerChannel(e) {
		this.channels.has(e.id) || (this.channels.set(e.id, e), this._onDidRegisterChannel.fire(e.id))
	}
	getChannels() {
		let e = []
		return this.channels.forEach((t) => e.push(t)), e
	}
	getChannel(e) {
		return this.channels.get(e)
	}
	updateChannelSources(e, t) {
		let n = this.channels.get(e)
		n && W8(n) && ((n.source = t), this._onDidUpdateChannelFiles.fire(n))
	}
	removeChannel(e) {
		let t = this.channels.get(e)
		t && (this.channels.delete(e), this._onDidRemoveChannel.fire(t))
	}
}
yt.add(H8.OutputChannels, new eR())
var rC = class extends ga {
		constructor(t, n, r, i, s) {
			super()
			this.id = t
			this.name = n
			this.logger = r
			this.proxy = i
			this.extension = s
			this.offset = 0
			this.visible = !1
			this.setLevel(r.getLevel()),
				this._register(r.onDidChangeLogLevel((a) => this.setLevel(a))),
				this._register(q(() => this.proxy.$dispose(this.id)))
		}
		get logLevel() {
			return this.getLevel()
		}
		appendLine(t) {
			this.append(
				t +
					`
`,
			)
		}
		append(t) {
			this.info(t)
		}
		clear() {
			let t = this.offset
			this.logger.flush(), this.proxy.$update(this.id, 3, t)
		}
		replace(t) {
			let n = this.offset
			this.info(t), this.proxy.$update(this.id, 2, n), this.visible && this.logger.flush()
		}
		show(t, n) {
			this.logger.flush(), this.proxy.$reveal(this.id, !!(typeof t == "boolean" ? t : n))
		}
		hide() {
			this.proxy.$close(this.id)
		}
		log(t, n) {
			;(this.offset += z.fromString(n).byteLength),
				dL(this.logger, t, n),
				this.visible && (this.logger.flush(), this.proxy.$update(this.id, 1))
		}
	},
	tR = class extends rC {
		appendLine(e) {
			this.append(e)
		}
	},
	qp = class {
		constructor(e, t, n, r, i, s) {
			this.initData = t
			this.extHostFileSystem = n
			this.extHostFileSystemInfo = r
			this.loggerService = i
			this.logService = s
			this.extensionLogDirectoryPromise = new Map()
			this.namePool = 1
			this.channels = new Map()
			this.visibleChannelId = null
			;(this.proxy = e.getProxy(M.MainThreadOutputService)),
				(this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(
					t.logsLocation,
					`output_logging_${y2(new Date()).replace(/-|:|\.\d+Z$/g, "")}`,
				))
		}
		$setVisibleChannel(e) {
			this.visibleChannelId = e
			for (let [t, n] of this.channels) n.visible = t === this.visibleChannelId
		}
		createOutputChannel(e, t, n) {
			if (((e = e.trim()), !e)) throw new Error("illegal argument `name`. must not be falsy")
			let r = typeof t == "object" && t.log,
				i = we(t) ? t : void 0
			if (we(i) && !i.trim()) throw new Error("illegal argument `languageId`. must not be empty")
			let s,
				a = this.initData.environment.extensionLogLevel?.find(([c]) => Ce.equals(n.identifier, c))?.[1]
			a && (s = cL(a))
			let l = new Q(),
				d = r ? this.doCreateLogOutputChannel(e, s, n, l) : this.doCreateOutputChannel(e, i, n, l)
			return (
				d.then((c) => {
					this.channels.set(c.id, c),
						(c.visible = c.id === this.visibleChannelId),
						l.add(q(() => this.channels.delete(c.id)))
				}),
				r
					? this.createExtHostLogOutputChannel(e, s ?? this.logService.getLevel(), d, l)
					: this.createExtHostOutputChannel(e, d, l)
			)
		}
		async doCreateOutputChannel(e, t, n, r) {
			this.outputDirectoryPromise ||
				(this.outputDirectoryPromise = this.extHostFileSystem.value
					.createDirectory(this.outputsLocation)
					.then(() => this.outputsLocation))
			let i = await this.outputDirectoryPromise,
				s = this.extHostFileSystemInfo.extUri.joinPath(
					i,
					`${this.namePool++}-${e.replace(/[\\/:\*\?"<>\|]/g, "")}.log`,
				),
				a = r.add(
					this.loggerService.createLogger(s, {
						logLevel: "always",
						donotRotate: !0,
						donotUseFormatters: !0,
						hidden: !0,
					}),
				),
				l = await this.proxy.$register(e, s, t, n.identifier.value)
			return r.add(q(() => this.loggerService.deregisterLogger(s))), new rC(l, e, a, this.proxy, n)
		}
		async doCreateLogOutputChannel(e, t, n, r) {
			let i = await this.createExtensionLogDirectory(n),
				s = e.replace(/[\\/:\*\?"<>\|]/g, ""),
				a = this.extHostFileSystemInfo.extUri.joinPath(i, `${s}.log`),
				l = `${n.identifier.value}.${s}`,
				d = r.add(
					this.loggerService.createLogger(a, {
						id: l,
						name: e,
						logLevel: t,
						extensionId: n.identifier.value,
					}),
				)
			return r.add(q(() => this.loggerService.deregisterLogger(a))), new tR(l, e, d, this.proxy, n)
		}
		createExtensionLogDirectory(e) {
			let t = this.extensionLogDirectoryPromise.get(e.identifier.value)
			if (!t) {
				let n = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, e.identifier.value)
				this.extensionLogDirectoryPromise.set(
					e.identifier.value,
					(t = (async () => {
						try {
							await this.extHostFileSystem.value.createDirectory(n)
						} catch (r) {
							if ($c(r) !== "EntryExists") throw r
						}
						return n
					})()),
				)
			}
			return t
		}
		createExtHostOutputChannel(e, t, n) {
			let r = () => {
				if (n.isDisposed) throw new Error("Channel has been closed")
			}
			return (
				t.then((i) => n.add(i)),
				{
					get name() {
						return e
					},
					append(i) {
						r(), t.then((s) => s.append(i))
					},
					appendLine(i) {
						r(), t.then((s) => s.appendLine(i))
					},
					clear() {
						r(), t.then((i) => i.clear())
					},
					replace(i) {
						r(), t.then((s) => s.replace(i))
					},
					show(i, s) {
						r(), t.then((a) => a.show(i, s))
					},
					hide() {
						r(), t.then((i) => i.hide())
					},
					dispose() {
						n.dispose()
					},
				}
			)
		}
		createExtHostLogOutputChannel(e, t, n, r) {
			let i = () => {
					if (r.isDisposed) throw new Error("Channel has been closed")
				},
				s = r.add(new E())
			function a(l) {
				;(t = l), s.fire(l)
			}
			return (
				n.then((l) => {
					l.logLevel !== t && a(l.logLevel), r.add(l.onDidChangeLogLevel((d) => a(d)))
				}),
				{
					...this.createExtHostOutputChannel(e, n, r),
					get logLevel() {
						return t
					},
					onDidChangeLogLevel: s.event,
					trace(l, ...d) {
						i(), n.then((c) => c.trace(l, ...d))
					},
					debug(l, ...d) {
						i(), n.then((c) => c.debug(l, ...d))
					},
					info(l, ...d) {
						i(), n.then((c) => c.info(l, ...d))
					},
					warn(l, ...d) {
						i(), n.then((c) => c.warn(l, ...d))
					},
					error(l, ...d) {
						i(), n.then((c) => c.error(l, ...d))
					},
				}
			)
		}
	}
qp = R([S(0, ie), S(1, Xe), S(2, Fi), S(3, po), S(4, uo), S(5, te)], qp)
var oC = O("IExtHostOutputService")
var Ui = class {
	constructor(e, t) {
		this._logService = t
		this._provider = new Map()
		this._proxy = e.getProxy(M.MainThreadDecorations)
	}
	static {
		this._handlePool = 0
	}
	static {
		this._maxEventSize = 250
	}
	registerFileDecorationProvider(e, t) {
		let n = Ui._handlePool++
		this._provider.set(n, { provider: e, extensionDescription: t }),
			this._proxy.$registerDecorationProvider(n, t.identifier.value)
		let r =
			e.onDidChangeFileDecorations &&
			e.onDidChangeFileDecorations((i) => {
				if (!i) {
					this._proxy.$onDidChange(n, null)
					return
				}
				let s = an(i)
				if (s.length <= Ui._maxEventSize) {
					this._proxy.$onDidChange(n, s)
					return
				}
				this._logService.warn(
					"[Decorations] CAPPING events from decorations provider",
					t.identifier.value,
					s.length,
				)
				let a = s.map((c) => ({ uri: c, rank: KA(c.path, "/") })),
					l = j0(a, (c, u) => c.rank - u.rank || Fo(c.uri.path, u.uri.path)),
					d = []
				e: for (let c of l) {
					let u
					for (let m of c) {
						let f = Qt(m.uri.path)
						if (u !== f && ((u = f), d.push(m.uri) >= Ui._maxEventSize)) break e
					}
				}
				this._proxy.$onDidChange(n, d)
			})
		return new ye(() => {
			r?.dispose(), this._proxy.$unregisterDecorationProvider(n), this._provider.delete(n)
		})
	}
	async $provideDecorations(e, t, n) {
		if (!this._provider.has(e)) return Object.create(null)
		let r = Object.create(null),
			{ provider: i, extensionDescription: s } = this._provider.get(e)
		return (
			await Promise.all(
				t.map(async (a) => {
					try {
						let { uri: l, id: d } = a,
							c = await Promise.resolve(i.provideFileDecoration(b.revive(l), n))
						if (!c) return
						try {
							xd.validate(c),
								c.badge && typeof c.badge != "string" && F(s, "codiconDecoration"),
								(r[d] = [c.propagate, c.tooltip, c.badge, c.color])
						} catch (u) {
							this._logService.warn(`INVALID decoration from extension '${s.identifier.value}': ${u}`)
						}
					} catch (l) {
						this._logService.error(l)
					}
				}),
			),
			r
		)
	}
}
Ui = R([S(0, ie), S(1, te)], Ui)
var iC = O("IExtHostDecorations")
var sC = class {
	constructor(e) {
		;(this.values = e),
			(this.prefixSum = new Uint32Array(e.length)),
			(this.prefixSumValidIndex = new Int32Array(1)),
			(this.prefixSumValidIndex[0] = -1)
	}
	getCount() {
		return this.values.length
	}
	insertValues(e, t) {
		e = Nl(e)
		let n = this.values,
			r = this.prefixSum,
			i = t.length
		return i === 0
			? !1
			: ((this.values = new Uint32Array(n.length + i)),
				this.values.set(n.subarray(0, e), 0),
				this.values.set(n.subarray(e), e + i),
				this.values.set(t, e),
				e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
				(this.prefixSum = new Uint32Array(this.values.length)),
				this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)),
				!0)
	}
	setValue(e, t) {
		return (
			(e = Nl(e)),
			(t = Nl(t)),
			this.values[e] === t
				? !1
				: ((this.values[e] = t),
					e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
					!0)
		)
	}
	removeValues(e, t) {
		;(e = Nl(e)), (t = Nl(t))
		let n = this.values,
			r = this.prefixSum
		if (e >= n.length) return !1
		let i = n.length - e
		return (
			t >= i && (t = i),
			t === 0
				? !1
				: ((this.values = new Uint32Array(n.length - t)),
					this.values.set(n.subarray(0, e), 0),
					this.values.set(n.subarray(e + t), e),
					(this.prefixSum = new Uint32Array(this.values.length)),
					e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1),
					this.prefixSumValidIndex[0] >= 0 &&
						this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)),
					!0)
		)
	}
	getTotalSum() {
		return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1)
	}
	getPrefixSum(e) {
		return e < 0 ? 0 : ((e = Nl(e)), this._getPrefixSum(e))
	}
	_getPrefixSum(e) {
		if (e <= this.prefixSumValidIndex[0]) return this.prefixSum[e]
		let t = this.prefixSumValidIndex[0] + 1
		t === 0 && ((this.prefixSum[0] = this.values[0]), t++), e >= this.values.length && (e = this.values.length - 1)
		for (let n = t; n <= e; n++) this.prefixSum[n] = this.prefixSum[n - 1] + this.values[n]
		return (this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e)), this.prefixSum[e]
	}
	getIndexOf(e) {
		;(e = Math.floor(e)), this.getTotalSum()
		let t = 0,
			n = this.values.length - 1,
			r = 0,
			i = 0,
			s = 0
		for (; t <= n; )
			if (((r = (t + (n - t) / 2) | 0), (i = this.prefixSum[r]), (s = i - this.values[r]), e < s)) n = r - 1
			else if (e >= i) t = r + 1
			else break
		return new nR(r, e - s)
	}
}
var nR = class {
	constructor(e, t) {
		this.index = e
		this.remainder = t
		this._prefixSumIndexOfResultBrand = void 0
		;(this.index = e), (this.remainder = t)
	}
}
var aC = class {
	constructor(e, t, n, r) {
		;(this._uri = e),
			(this._lines = t),
			(this._eol = n),
			(this._versionId = r),
			(this._lineStarts = null),
			(this._cachedTextValue = null)
	}
	dispose() {
		this._lines.length = 0
	}
	get version() {
		return this._versionId
	}
	getText() {
		return (
			this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)),
			this._cachedTextValue
		)
	}
	onEvents(e) {
		e.eol && e.eol !== this._eol && ((this._eol = e.eol), (this._lineStarts = null))
		let t = e.changes
		for (let n of t)
			this._acceptDeleteRange(n.range),
				this._acceptInsertText(new cn(n.range.startLineNumber, n.range.startColumn), n.text)
		;(this._versionId = e.versionId), (this._cachedTextValue = null)
	}
	_ensureLineStarts() {
		if (!this._lineStarts) {
			let e = this._eol.length,
				t = this._lines.length,
				n = new Uint32Array(t)
			for (let r = 0; r < t; r++) n[r] = this._lines[r].length + e
			this._lineStarts = new sC(n)
		}
	}
	_setLineText(e, t) {
		;(this._lines[e] = t),
			this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length)
	}
	_acceptDeleteRange(e) {
		if (e.startLineNumber === e.endLineNumber) {
			if (e.startColumn === e.endColumn) return
			this._setLineText(
				e.startLineNumber - 1,
				this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) +
					this._lines[e.startLineNumber - 1].substring(e.endColumn - 1),
			)
			return
		}
		this._setLineText(
			e.startLineNumber - 1,
			this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) +
				this._lines[e.endLineNumber - 1].substring(e.endColumn - 1),
		),
			this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber),
			this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber)
	}
	_acceptInsertText(e, t) {
		if (t.length === 0) return
		let n = Nv(t)
		if (n.length === 1) {
			this._setLineText(
				e.lineNumber - 1,
				this._lines[e.lineNumber - 1].substring(0, e.column - 1) +
					n[0] +
					this._lines[e.lineNumber - 1].substring(e.column - 1),
			)
			return
		}
		;(n[n.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1)),
			this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0])
		let r = new Uint32Array(n.length - 1)
		for (let i = 1; i < n.length; i++)
			this._lines.splice(e.lineNumber + i - 1, 0, n[i]), (r[i - 1] = n[i].length + this._eol.length)
		this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r)
	}
}
var rR = new Map()
function L2(o, e) {
	e ? rR.set(o, e) : rR.delete(o)
}
function V8(o) {
	return rR.get(o)
}
var lC = class extends aC {
		constructor(t, n, r, i, s, a, l, d) {
			super(n, r, i, s)
			this._proxy = t
			this._languageId = a
			this._isDirty = l
			this._encoding = d
			this._isDisposed = !1
		}
		dispose() {
			yn(!this._isDisposed), (this._isDisposed = !0), (this._isDirty = !1)
		}
		equalLines(t) {
			return mn(this._lines, t)
		}
		get document() {
			if (!this._document) {
				let t = this
				this._document = {
					get uri() {
						return t._uri
					},
					get fileName() {
						return t._uri.fsPath
					},
					get isUntitled() {
						return t._uri.scheme === W.untitled
					},
					get languageId() {
						return t._languageId
					},
					get version() {
						return t._versionId
					},
					get isClosed() {
						return t._isDisposed
					},
					get isDirty() {
						return t._isDirty
					},
					get encoding() {
						return t._encoding
					},
					save() {
						return t._save()
					},
					getText(n) {
						return n ? t._getTextInRange(n) : t.getText()
					},
					get eol() {
						return t._eol ===
							`
`
							? 1
							: 2
					},
					get lineCount() {
						return t._lines.length
					},
					lineAt(n) {
						return t._lineAt(n)
					},
					offsetAt(n) {
						return t._offsetAt(n)
					},
					positionAt(n) {
						return t._positionAt(n)
					},
					validateRange(n) {
						return t._validateRange(n)
					},
					validatePosition(n) {
						return t._validatePosition(n)
					},
					getWordRangeAtPosition(n, r) {
						return t._getWordRangeAtPosition(n, r)
					},
					[Symbol.for("debug.description")]() {
						return `TextDocument(${t._uri.toString()})`
					},
				}
			}
			return Object.freeze(this._document)
		}
		_acceptLanguageId(t) {
			yn(!this._isDisposed), (this._languageId = t)
		}
		_acceptIsDirty(t) {
			yn(!this._isDisposed), (this._isDirty = t)
		}
		_acceptEncoding(t) {
			yn(!this._isDisposed), (this._encoding = t)
		}
		_save() {
			return this._isDisposed
				? Promise.reject(new Error("Document has been closed"))
				: this._proxy.$trySaveDocument(this._uri)
		}
		_getTextInRange(t) {
			let n = this._validateRange(t)
			if (n.isEmpty) return ""
			if (n.isSingleLine) return this._lines[n.start.line].substring(n.start.character, n.end.character)
			let r = this._eol,
				i = n.start.line,
				s = n.end.line,
				a = []
			a.push(this._lines[i].substring(n.start.character))
			for (let l = i + 1; l < s; l++) a.push(this._lines[l])
			return a.push(this._lines[s].substring(0, n.end.character)), a.join(r)
		}
		_lineAt(t) {
			let n
			if (
				(t instanceof Pe ? (n = t.line) : typeof t == "number" && (n = t),
				typeof n != "number" || n < 0 || n >= this._lines.length || Math.floor(n) !== n)
			)
				throw new Error("Illegal value for `line`")
			return new oR(n, this._lines[n], n === this._lines.length - 1)
		}
		_offsetAt(t) {
			return (
				(t = this._validatePosition(t)),
				this._ensureLineStarts(),
				this._lineStarts.getPrefixSum(t.line - 1) + t.character
			)
		}
		_positionAt(t) {
			;(t = Math.floor(t)), (t = Math.max(0, t)), this._ensureLineStarts()
			let n = this._lineStarts.getIndexOf(t),
				r = this._lines[n.index].length
			return new Pe(n.index, Math.min(n.remainder, r))
		}
		_validateRange(t) {
			if (!(t instanceof pe)) throw new Error("Invalid argument")
			let n = this._validatePosition(t.start),
				r = this._validatePosition(t.end)
			return n === t.start && r === t.end ? t : new pe(n.line, n.character, r.line, r.character)
		}
		_validatePosition(t) {
			if (!(t instanceof Pe)) throw new Error("Invalid argument")
			if (this._lines.length === 0) return t.with(0, 0)
			let { line: n, character: r } = t,
				i = !1
			if (n < 0) (n = 0), (r = 0), (i = !0)
			else if (n >= this._lines.length) (n = this._lines.length - 1), (r = this._lines[n].length), (i = !0)
			else {
				let s = this._lines[n].length
				r < 0 ? ((r = 0), (i = !0)) : r > s && ((r = s), (i = !0))
			}
			return i ? new Pe(n, r) : t
		}
		_getWordRangeAtPosition(t, n) {
			let r = this._validatePosition(t)
			if (!n) n = V8(this._languageId)
			else if (Fv(n))
				throw new Error(
					`[getWordRangeAtPosition]: ignoring custom regexp '${n.source}' because it matches the empty string.`,
				)
			let i = pw(r.character + 1, uw(n), this._lines[r.line], 0)
			if (i) return new pe(r.line, i.startColumn - 1, r.line, i.endColumn - 1)
		}
	},
	oR = class {
		constructor(e, t, n) {
			;(this._line = e), (this._text = t), (this._isLastLine = n)
		}
		get lineNumber() {
			return this._line
		}
		get text() {
			return this._text
		}
		get range() {
			return new pe(this._line, 0, this._line, this._text.length)
		}
		get rangeIncludingLineBreak() {
			return this._isLastLine ? this.range : new pe(this._line, 0, this._line + 1, 0)
		}
		get firstNonWhitespaceCharacterIndex() {
			return /^(\s*)/.exec(this._text)[1].length
		}
		get isEmptyOrWhitespace() {
			return this.firstNonWhitespaceCharacterIndex === this._text.length
		}
	}
var fl = class {
		constructor(e) {
			;(this._prefix = e), (this._lastId = 0)
		}
		nextId() {
			return this._prefix + ++this._lastId
		}
	},
	cEe = new fl("id#")
var dC = class o {
		static {
			this._Keys = new fl("TextEditorDecorationType")
		}
		constructor(e, t, n) {
			let r = o._Keys.nextId()
			e.$registerTextEditorDecorationType(t.identifier, r, WD.from(n)),
				(this.value = Object.freeze({
					key: r,
					dispose() {
						e.$removeTextEditorDecorationType(r)
					},
				}))
		}
	},
	iR = class {
		constructor(e, t) {
			this._collectedEdits = []
			this._setEndOfLine = void 0
			this._finalized = !1
			;(this._document = e),
				(this._documentVersionId = e.version),
				(this._undoStopBefore = t.undoStopBefore),
				(this._undoStopAfter = t.undoStopAfter)
		}
		finalize() {
			return (
				(this._finalized = !0),
				{
					documentVersionId: this._documentVersionId,
					edits: this._collectedEdits,
					setEndOfLine: this._setEndOfLine,
					undoStopBefore: this._undoStopBefore,
					undoStopAfter: this._undoStopAfter,
				}
			)
		}
		_throwIfFinalized() {
			if (this._finalized) throw new Error("Edit is only valid while callback runs")
		}
		replace(e, t) {
			this._throwIfFinalized()
			let n = null
			if (e instanceof Pe) n = new pe(e, e)
			else if (e instanceof pe) n = e
			else throw new Error("Unrecognized location")
			this._pushEdit(n, t, !1)
		}
		insert(e, t) {
			this._throwIfFinalized(), this._pushEdit(new pe(e, e), t, !0)
		}
		delete(e) {
			this._throwIfFinalized()
			let t = null
			if (e instanceof pe) t = e
			else throw new Error("Unrecognized location")
			this._pushEdit(t, null, !0)
		}
		_pushEdit(e, t, n) {
			let r = this._document.validateRange(e)
			this._collectedEdits.push({ range: r, text: t, forceMoveMarkers: n })
		}
		setEndOfLine(e) {
			if ((this._throwIfFinalized(), e !== 1 && e !== 2)) throw We("endOfLine")
			this._setEndOfLine = e
		}
	},
	sR = class {
		constructor(e, t, n, r) {
			;(this._proxy = e), (this._id = t), this._accept(n), (this._logService = r)
			let i = this
			this.value = {
				get tabSize() {
					return i._tabSize
				},
				set tabSize(s) {
					i._setTabSize(s)
				},
				get indentSize() {
					return i._indentSize
				},
				set indentSize(s) {
					i._setIndentSize(s)
				},
				get insertSpaces() {
					return i._insertSpaces
				},
				set insertSpaces(s) {
					i._setInsertSpaces(s)
				},
				get cursorStyle() {
					return i._cursorStyle
				},
				set cursorStyle(s) {
					i._setCursorStyle(s)
				},
				get lineNumbers() {
					return i._lineNumbers
				},
				set lineNumbers(s) {
					i._setLineNumbers(s)
				},
			}
		}
		_accept(e) {
			;(this._tabSize = e.tabSize),
				(this._indentSize = e.indentSize),
				(this._originalIndentSize = e.originalIndentSize),
				(this._insertSpaces = e.insertSpaces),
				(this._cursorStyle = e.cursorStyle),
				(this._lineNumbers = Od.to(e.lineNumbers))
		}
		_validateTabSize(e) {
			if (e === "auto") return "auto"
			if (typeof e == "number") {
				let t = Math.floor(e)
				return t > 0 ? t : null
			}
			if (typeof e == "string") {
				let t = parseInt(e, 10)
				return isNaN(t) ? null : t > 0 ? t : null
			}
			return null
		}
		_setTabSize(e) {
			let t = this._validateTabSize(e)
			if (t !== null) {
				if (typeof t == "number") {
					if (this._tabSize === t) return
					this._tabSize = t
				}
				this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, { tabSize: t }))
			}
		}
		_validateIndentSize(e) {
			if (e === "tabSize") return "tabSize"
			if (typeof e == "number") {
				let t = Math.floor(e)
				return t > 0 ? t : null
			}
			if (typeof e == "string") {
				let t = parseInt(e, 10)
				return isNaN(t) ? null : t > 0 ? t : null
			}
			return null
		}
		_setIndentSize(e) {
			let t = this._validateIndentSize(e)
			if (t !== null) {
				if (typeof t == "number") {
					if (this._originalIndentSize === t) return
					;(this._indentSize = t), (this._originalIndentSize = t)
				}
				this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, { indentSize: t }))
			}
		}
		_validateInsertSpaces(e) {
			return e === "auto" ? "auto" : e === "false" ? !1 : !!e
		}
		_setInsertSpaces(e) {
			let t = this._validateInsertSpaces(e)
			if (typeof t == "boolean") {
				if (this._insertSpaces === t) return
				this._insertSpaces = t
			}
			this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, { insertSpaces: t }))
		}
		_setCursorStyle(e) {
			this._cursorStyle !== e &&
				((this._cursorStyle = e),
				this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, { cursorStyle: e })))
		}
		_setLineNumbers(e) {
			this._lineNumbers !== e &&
				((this._lineNumbers = e),
				this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, { lineNumbers: Od.from(e) })))
		}
		assign(e) {
			let t = {},
				n = !1
			if (typeof e.tabSize < "u") {
				let r = this._validateTabSize(e.tabSize)
				r === "auto"
					? ((n = !0), (t.tabSize = r))
					: typeof r == "number" && this._tabSize !== r && ((this._tabSize = r), (n = !0), (t.tabSize = r))
			}
			if (typeof e.indentSize < "u") {
				let r = this._validateIndentSize(e.indentSize)
				r === "tabSize"
					? ((n = !0), (t.indentSize = r))
					: typeof r == "number" &&
						this._originalIndentSize !== r &&
						((this._indentSize = r), (this._originalIndentSize = r), (n = !0), (t.indentSize = r))
			}
			if (typeof e.insertSpaces < "u") {
				let r = this._validateInsertSpaces(e.insertSpaces)
				r === "auto"
					? ((n = !0), (t.insertSpaces = r))
					: this._insertSpaces !== r && ((this._insertSpaces = r), (n = !0), (t.insertSpaces = r))
			}
			typeof e.cursorStyle < "u" &&
				this._cursorStyle !== e.cursorStyle &&
				((this._cursorStyle = e.cursorStyle), (n = !0), (t.cursorStyle = e.cursorStyle)),
				typeof e.lineNumbers < "u" &&
					this._lineNumbers !== e.lineNumbers &&
					((this._lineNumbers = e.lineNumbers), (n = !0), (t.lineNumbers = Od.from(e.lineNumbers))),
				n && this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, t))
		}
		_warnOnError(e, t) {
			t.catch((n) => {
				this._logService.warn(`ExtHostTextEditorOptions '${e}' failed:'`), this._logService.warn(n)
			})
		}
	},
	cC = class {
		constructor(e, t, n, r, i, s, a, l) {
			this.id = e
			this._proxy = t
			this._logService = n
			this._disposed = !1
			this._hasDecorationsForKey = new Set()
			;(this._selections = i),
				(this._options = new sR(this._proxy, this.id, s, n)),
				(this._visibleRanges = a),
				(this._viewColumn = l)
			let d = this
			this.value = Object.freeze({
				get document() {
					return r.value
				},
				set document(c) {
					throw new _o("document")
				},
				get selection() {
					return d._selections && d._selections[0]
				},
				set selection(c) {
					if (!(c instanceof Bn)) throw We("selection")
					;(d._selections = [c]), d._trySetSelection()
				},
				get selections() {
					return d._selections
				},
				set selections(c) {
					if (!Array.isArray(c) || c.some((u) => !(u instanceof Bn))) throw We("selections")
					;(d._selections = c), d._trySetSelection()
				},
				get visibleRanges() {
					return d._visibleRanges
				},
				set visibleRanges(c) {
					throw new _o("visibleRanges")
				},
				get diffInformation() {
					return d._diffInformation
				},
				get options() {
					return d._options.value
				},
				set options(c) {
					d._disposed || d._options.assign(c)
				},
				get viewColumn() {
					return d._viewColumn
				},
				set viewColumn(c) {
					throw new _o("viewColumn")
				},
				edit(c, u = { undoStopBefore: !0, undoStopAfter: !0 }) {
					if (d._disposed) return Promise.reject(new Error("TextEditor#edit not possible on closed editors"))
					let m = new iR(r.value, u)
					return c(m), d._applyEdit(m)
				},
				insertSnippet(c, u, m = { undoStopBefore: !0, undoStopAfter: !0 }) {
					if (d._disposed)
						return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"))
					let f
					if (!u || (Array.isArray(u) && u.length === 0)) f = d._selections.map((h) => H.from(h))
					else if (u instanceof Pe) {
						let { lineNumber: h, column: g } = Je.from(u)
						f = [{ startLineNumber: h, startColumn: g, endLineNumber: h, endColumn: g }]
					} else if (u instanceof pe) f = [H.from(u)]
					else {
						f = []
						for (let h of u)
							if (h instanceof pe) f.push(H.from(h))
							else {
								let { lineNumber: g, column: I } = Je.from(h)
								f.push({ startLineNumber: g, startColumn: I, endLineNumber: g, endColumn: I })
							}
					}
					return (
						m.keepWhitespace === void 0 && (m.keepWhitespace = !1),
						t.$tryInsertSnippet(e, r.value.version, c.value, f, m)
					)
				},
				setDecorations(c, u) {
					let m = u.length === 0
					;(m && !d._hasDecorationsForKey.has(c.key)) ||
						(m ? d._hasDecorationsForKey.delete(c.key) : d._hasDecorationsForKey.add(c.key),
						d._runOnProxy(() => {
							if (HD(u)) return t.$trySetDecorations(e, c.key, MF(u))
							{
								let f = new Array(4 * u.length)
								for (let h = 0, g = u.length; h < g; h++) {
									let I = u[h]
									;(f[4 * h] = I.start.line + 1),
										(f[4 * h + 1] = I.start.character + 1),
										(f[4 * h + 2] = I.end.line + 1),
										(f[4 * h + 3] = I.end.character + 1)
								}
								return t.$trySetDecorationsFast(e, c.key, f)
							}
						}))
				},
				revealRange(c, u) {
					d._runOnProxy(() => t.$tryRevealRange(e, H.from(c), u || 0))
				},
				show(c) {
					t.$tryShowEditor(e, wt.from(c))
				},
				hide() {
					t.$tryHideEditor(e)
				},
				[Symbol.for("debug.description")]() {
					return `TextEditor(${this.document.uri.toString()})`
				},
			})
		}
		dispose() {
			yn(!this._disposed), (this._disposed = !0)
		}
		_acceptOptions(e) {
			yn(!this._disposed), this._options._accept(e)
		}
		_acceptVisibleRanges(e) {
			yn(!this._disposed), (this._visibleRanges = e)
		}
		_acceptViewColumn(e) {
			yn(!this._disposed), (this._viewColumn = e)
		}
		_acceptSelections(e) {
			yn(!this._disposed), (this._selections = e)
		}
		_acceptDiffInformation(e) {
			yn(!this._disposed), (this._diffInformation = e)
		}
		async _trySetSelection() {
			let e = this._selections.map(er.from)
			return await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, e)), this.value
		}
		_applyEdit(e) {
			let t = e.finalize()
			if (t.edits.length === 0 && !t.setEndOfLine) return Promise.resolve(!0)
			let n = t.edits.map((i) => i.range)
			n.sort((i, s) =>
				i.end.line === s.end.line
					? i.end.character === s.end.character
						? i.start.line === s.start.line
							? i.start.character - s.start.character
							: i.start.line - s.start.line
						: i.end.character - s.end.character
					: i.end.line - s.end.line,
			)
			for (let i = 0, s = n.length - 1; i < s; i++) {
				let a = n[i].end
				if (n[i + 1].start.isBefore(a)) return Promise.reject(new Error("Overlapping ranges are not allowed!"))
			}
			let r = t.edits.map((i) => ({ range: H.from(i.range), text: i.text, forceMoveMarkers: i.forceMoveMarkers }))
			return this._proxy.$tryApplyEdits(this.id, t.documentVersionId, r, {
				setEndOfLine: typeof t.setEndOfLine == "number" ? _d.from(t.setEndOfLine) : void 0,
				undoStopBefore: t.undoStopBefore,
				undoStopAfter: t.undoStopAfter,
			})
		}
		_runOnProxy(e) {
			return this._disposed
				? (this._logService.warn("TextEditor is closed/disposed"), Promise.resolve(void 0))
				: e().then(
						() => this,
						(t) => ((t instanceof Error && t.name === "DISPOSED") || this._logService.warn(t), null),
					)
		}
	}
var aR = class {
		constructor(e) {
			this.value = e
			this._count = 0
		}
		ref() {
			this._count++
		}
		unref() {
			return --this._count === 0
		}
	},
	Kp = class {
		constructor(e, t) {
			this._extHostRpc = e
			this._logService = t
			this._activeEditorId = null
			this._editors = new Map()
			this._documents = new ft()
			this._onDidAddDocuments = new E()
			this._onDidRemoveDocuments = new E()
			this._onDidChangeVisibleTextEditors = new E()
			this._onDidChangeActiveTextEditor = new E()
			this.onDidAddDocuments = this._onDidAddDocuments.event
			this.onDidRemoveDocuments = this._onDidRemoveDocuments.event
			this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event
			this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event
		}
		$acceptDocumentsAndEditorsDelta(e) {
			this.acceptDocumentsAndEditorsDelta(e)
		}
		acceptDocumentsAndEditorsDelta(e) {
			let t = [],
				n = [],
				r = []
			if (e.removedDocuments)
				for (let i of e.removedDocuments) {
					let s = b.revive(i),
						a = this._documents.get(s)
					a?.unref() && (this._documents.delete(s), t.push(a.value))
				}
			if (e.addedDocuments)
				for (let i of e.addedDocuments) {
					let s = b.revive(i.uri),
						a = this._documents.get(s)
					if (a && s.scheme !== W.vscodeNotebookCell && s.scheme !== W.vscodeInteractiveInput)
						throw new Error(`document '${s} already exists!'`)
					a ||
						((a = new aR(
							new lC(
								this._extHostRpc.getProxy(M.MainThreadDocuments),
								s,
								i.lines,
								i.EOL,
								i.versionId,
								i.languageId,
								i.isDirty,
								i.encoding,
							),
						)),
						this._documents.set(s, a),
						n.push(a.value)),
						a.ref()
				}
			if (e.removedEditors)
				for (let i of e.removedEditors) {
					let s = this._editors.get(i)
					this._editors.delete(i), s && r.push(s)
				}
			if (e.addedEditors)
				for (let i of e.addedEditors) {
					let s = b.revive(i.documentUri)
					yn(this._documents.has(s), `document '${s}' does not exist`),
						yn(!this._editors.has(i.id), `editor '${i.id}' already exists!`)
					let a = this._documents.get(s).value,
						l = new cC(
							i.id,
							this._extHostRpc.getProxy(M.MainThreadTextEditors),
							this._logService,
							new kt(() => a.document),
							i.selections.map(er.to),
							i.options,
							i.visibleRanges.map((d) => H.to(d)),
							typeof i.editorPosition == "number" ? wt.to(i.editorPosition) : void 0,
						)
					this._editors.set(i.id, l)
				}
			e.newActiveEditor !== void 0 &&
				(yn(
					e.newActiveEditor === null || this._editors.has(e.newActiveEditor),
					`active editor '${e.newActiveEditor}' does not exist`,
				),
				(this._activeEditorId = e.newActiveEditor)),
				Nn(t),
				Nn(r),
				e.removedDocuments && this._onDidRemoveDocuments.fire(t),
				e.addedDocuments && this._onDidAddDocuments.fire(n),
				(e.removedEditors || e.addedEditors) &&
					this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((i) => i.value)),
				e.newActiveEditor !== void 0 && this._onDidChangeActiveTextEditor.fire(this.activeEditor())
		}
		getDocument(e) {
			return this._documents.get(e)?.value
		}
		allDocuments() {
			return Rt.map(this._documents.values(), (e) => e.value)
		}
		getEditor(e) {
			return this._editors.get(e)
		}
		activeEditor(e) {
			if (!this._activeEditorId) return
			let t = this._editors.get(this._activeEditorId)
			return e ? t : t?.value
		}
		allEditors() {
			return [...this._editors.values()]
		}
	}
Kp = R([S(0, ie), S(1, te)], Kp)
var no = O("IExtHostDocumentsAndEditors")
var Ks = O("IExtHostApiDeprecationService"),
	jp = class {
		constructor(e, t) {
			this._extHostLogService = t
			this._reportedUsages = new Set()
			this._telemetryShape = e.getProxy(M.MainThreadTelemetry)
		}
		report(e, t, n) {
			let r = this.getUsageKey(e, t)
			this._reportedUsages.has(r) ||
				(this._reportedUsages.add(r),
				t.isUnderDevelopment &&
					this._extHostLogService.warn(`[Deprecation Warning] '${e}' is deprecated. ${n}`),
				this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
					extensionId: t.identifier.value,
					apiId: e,
				}))
		}
		getUsageKey(e, t) {
			return `${e}-${t.identifier.value}`
		}
	}
jp = R([S(0, ie), S(1, te)], jp)
var WEe = Object.freeze(
	new (class {
		report(o, e, t) {}
	})(),
)
var B8 = {
		type: "object",
		additionalProperties: !1,
		properties: {
			type: {
				type: "string",
				description: p(
					"TaskDefinition.description",
					"The actual task type. Please note that types starting with a '$' are reserved for internal usage.",
				),
			},
			required: { type: "array", items: { type: "string" } },
			properties: {
				type: "object",
				description: p("TaskDefinition.properties", "Additional properties of the task type"),
				additionalProperties: { $ref: "http://json-schema.org/draft-07/schema#" },
			},
			when: {
				type: "string",
				markdownDescription: p(
					"TaskDefinition.when",
					"Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information.",
				),
				default: "",
			},
		},
	},
	M2
;((e) => {
	function o(t, n, r) {
		if (!t) return
		let i = we(t.type) ? t.type : void 0
		if (!i || i.length === 0) {
			r.error(
				p(
					"TaskTypeConfiguration.noType",
					"The task type configuration is missing the required 'taskType' property",
				),
			)
			return
		}
		let s = []
		if (Array.isArray(t.required)) for (let a of t.required) we(a) && s.push(a)
		return {
			extensionId: n.value,
			taskType: i,
			required: s,
			properties: t.properties ? je(t.properties) : {},
			when: t.when ? Lt.deserialize(t.when) : void 0,
		}
	}
	e.from = o
})((M2 ||= {}))
var $8 = My.registerExtensionPoint({
		extensionPoint: "taskDefinitions",
		activationEventsGenerator: (o, e) => {
			for (let t of o) t.type && e.push(`onTaskType:${t.type}`)
		},
		jsonSchema: { description: p("TaskDefinitionExtPoint", "Contributes task kinds"), type: "array", items: B8 },
	}),
	lR = class {
		constructor() {
			this._onDefinitionsChanged = new E()
			this.onDefinitionsChanged = this._onDefinitionsChanged.event
			;(this.taskTypes = Object.create(null)),
				(this.readyPromise = new Promise((e, t) => {
					$8.setHandler((n, r) => {
						this._schema = void 0
						try {
							for (let i of r.removed) {
								let s = i.value
								for (let a of s)
									this.taskTypes && a.type && this.taskTypes[a.type] && delete this.taskTypes[a.type]
							}
							for (let i of r.added) {
								let s = i.value
								for (let a of s) {
									let l = M2.from(a, i.description.identifier, i.collector)
									l && (this.taskTypes[l.taskType] = l)
								}
							}
							;(r.removed.length > 0 || r.added.length > 0) && this._onDefinitionsChanged.fire()
						} catch {}
						e(void 0)
					})
				}))
		}
		onReady() {
			return this.readyPromise
		}
		get(e) {
			return this.taskTypes[e]
		}
		all() {
			return Object.keys(this.taskTypes).map((e) => this.taskTypes[e])
		}
		getJsonSchema() {
			if (this._schema === void 0) {
				let e = []
				for (let t of this.all()) {
					let n = { type: "object", additionalProperties: !1 }
					t.required.length > 0 && (n.required = t.required.slice(0)),
						t.properties !== void 0
							? (n.properties = je(t.properties))
							: (n.properties = Object.create(null)),
						(n.properties.type = { type: "string", enum: [t.taskType] }),
						e.push(n)
				}
				this._schema = { oneOf: e }
			}
			return this._schema
		}
	},
	F2 = new lR()
var N2 = "settings",
	ewe = new D("taskRunning", !1, p("tasks.taskRunningContext", "Whether a task is currently running.")),
	twe = new D("taskTerminalActive", !1, p("taskTerminalActive", "Whether the active terminal is a task terminal.")),
	nwe = uf("tasksCategory", "Tasks"),
	cR = ((n) => ((n[(n.Escape = 1)] = "Escape"), (n[(n.Strong = 2)] = "Strong"), (n[(n.Weak = 3)] = "Weak"), n))(
		cR || {},
	)
;((e) => {
	function o(t) {
		if (!t) return 2
		switch (t.toLowerCase()) {
			case "escape":
				return 1
			case "strong":
				return 2
			case "weak":
				return 3
			default:
				return 2
		}
	}
	e.from = o
})((cR ||= {}))
var z8
;((e) => (e.defaults = { cwd: "${workspaceFolder}" }))((z8 ||= {}))
var uR = ((n) => ((n[(n.Always = 1)] = "Always"), (n[(n.Silent = 2)] = "Silent"), (n[(n.Never = 3)] = "Never"), n))(
	uR || {},
)
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "always":
				return 1
			case "silent":
				return 2
			case "never":
				return 3
			default:
				return 1
		}
	}
	e.fromString = o
})((uR ||= {}))
var pR = ((n) => (
	(n[(n.Never = 1)] = "Never"), (n[(n.OnProblem = 2)] = "OnProblem"), (n[(n.Always = 3)] = "Always"), n
))(pR || {})
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "always":
				return 3
			case "never":
				return 1
			case "onproblem":
				return 2
			default:
				return 2
		}
	}
	e.fromString = o
})((pR ||= {}))
var mR = ((n) => ((n[(n.Shared = 1)] = "Shared"), (n[(n.Dedicated = 2)] = "Dedicated"), (n[(n.New = 3)] = "New"), n))(
	mR || {},
)
;((e) => {
	function o(t) {
		switch (t.toLowerCase()) {
			case "shared":
				return 1
			case "dedicated":
				return 2
			case "new":
				return 3
			default:
				return 1
		}
	}
	e.fromString = o
})((mR ||= {}))
var q8
;((e) =>
	(e.defaults = { echo: !0, reveal: 1, revealProblems: 1, focus: !1, panel: 1, showReuseMessage: !0, clear: !1 }))(
	(q8 ||= {}),
)
var fR = ((n) => (
	(n[(n.Shell = 1)] = "Shell"), (n[(n.Process = 2)] = "Process"), (n[(n.CustomExecution = 3)] = "CustomExecution"), n
))(fR || {})
;((t) => {
	function o(n) {
		switch (n.toLowerCase()) {
			case "shell":
				return 1
			case "process":
				return 2
			case "customExecution":
				return 3
			default:
				return 2
		}
	}
	t.fromString = o
	function e(n) {
		switch (n) {
			case 1:
				return "shell"
			case 2:
				return "process"
			case 3:
				return "customExecution"
			default:
				return "process"
		}
	}
	t.toString = e
})((fR ||= {}))
var K8
;((e) => {
	function o(t) {
		return we(t) ? t : t.value
	}
	e.value = o
})((K8 ||= {}))
var j8
;((s) => {
	;(s.Clean = { _id: "clean", isDefault: !1 }),
		(s.Build = { _id: "build", isDefault: !1 }),
		(s.Rebuild = { _id: "rebuild", isDefault: !1 }),
		(s.Test = { _id: "test", isDefault: !1 })
	function r(a) {
		return a === s.Clean._id || a === s.Build._id || a === s.Rebuild._id || a === s.Test._id
	}
	s.is = r
	function i(a) {
		if (a !== void 0) return we(a) ? (r(a) ? { _id: a, isDefault: !1 } : void 0) : a
	}
	s.from = i
})((j8 ||= {}))
var G8
;((s) => {
	;(s.Workspace = "workspace"),
		(s.Extension = "extension"),
		(s.InMemory = "inMemory"),
		(s.WorkspaceFile = "workspaceFile"),
		(s.User = "user")
	function i(a) {
		switch (a) {
			case s.User:
				return 2
			case s.WorkspaceFile:
				return 5
			default:
				return 6
		}
	}
	s.toConfigurationTarget = i
})((G8 ||= {}))
var Q8
;((e) => (e.defaults = { reevaluateOnRerun: !0, runOn: 1, instanceLimit: 1 }))((Q8 ||= {}))
var gR = ((t) => ((t[(t.Process = 1)] = "Process"), (t[(t.Terminal = 2)] = "Terminal"), t))(gR || {})
;((e) => (e._default = 2))((gR ||= {}))
var J8
;((a) => {
	function o(l) {
		return {
			taskId: l._id,
			taskName: l.configurationProperties.name,
			runType: l.configurationProperties.isBackground ? "background" : "singleRun",
			group: l.configurationProperties.group,
			__task: l,
		}
	}
	function e(l, d, c) {
		return { ...o(l), kind: "start", terminalId: d, resolvedVariables: c }
	}
	a.start = e
	function t(l, d, c) {
		return { ...o(l), kind: "processStarted", terminalId: d, processId: c }
	}
	a.processStarted = t
	function n(l, d, c) {
		return { ...o(l), kind: "processEnded", terminalId: d, exitCode: c }
	}
	a.processEnded = n
	function r(l, d, c) {
		return { ...o(l), kind: "terminated", exitReason: c, terminalId: d }
	}
	a.terminated = r
	function i(l, d, c) {
		return { ...o(d), kind: l, terminalId: c }
	}
	a.general = i
	function s() {
		return { kind: "changed" }
	}
	a.changed = s
})((J8 ||= {}))
var dR
;((t) => {
	function o(n) {
		let r = Object.keys(n).sort(),
			i = ""
		for (let s of r) {
			let a = n[s]
			a instanceof Object ? (a = o(a)) : typeof a == "string" && (a = a.replace(/,/g, ",,")),
				(i += s + "," + a + ",")
		}
		return i
	}
	function e(n) {
		let i = { _key: o(n), type: n.taskType }
		return Object.assign(i, n), i
	}
	t.create = e
})((dR ||= {}))
var X8
;((e) => {
	function o(t, n) {
		let r = F2.get(t.type)
		if (r === void 0) {
			let l = je(t)
			return delete l._key, dR.create(l)
		}
		let i = Object.create(null)
		i.type = r.taskType
		let s = new Set()
		r.required.forEach((l) => s.add(l))
		let a = r.properties
		for (let l of Object.keys(a)) {
			let d = t[l]
			if (d != null) i[l] = d
			else if (s.has(l)) {
				let c = a[l]
				if (c.default !== void 0) i[l] = je(c.default)
				else
					switch (c.type) {
						case "boolean":
							i[l] = !1
							break
						case "number":
						case "integer":
							i[l] = 0
							break
						case "string":
							i[l] = ""
							break
						default:
							n.error(
								p(
									"TaskDefinition.missingRequiredProperty",
									"Error: the task identifier '{0}' is missing the required property '{1}'. The task identifier will be ignored.",
									JSON.stringify(t, void 0, 0),
									l,
								),
							)
							return
					}
			}
		}
		return dR.create(i)
	}
	e.createTaskIdentifier = o
})((X8 ||= {}))
var hR
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((hR ||= {}))
var vR
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((vR ||= {}))
var U2
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((U2 ||= {}))
var uC
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && !!i.process
		} else return !1
	}
	n.is = o
	function e(r) {
		if (r == null) return
		let i = { process: r.process, args: r.args }
		return r.options && (i.options = U2.from(r.options)), i
	}
	n.from = e
	function t(r) {
		if (r != null) return new Si(r.process, r.args, r.options)
	}
	n.to = t
})((uC ||= {}))
var H2
;((t) => {
	function o(n) {
		if (n != null) return n
	}
	t.from = o
	function e(n) {
		if (n != null) return n
	}
	t.to = e
})((H2 ||= {}))
var pC
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && (!!i.commandLine || !!i.command)
		} else return !1
	}
	n.is = o
	function e(r) {
		if (r == null) return
		let i = {}
		return (
			r.commandLine !== void 0 ? (i.commandLine = r.commandLine) : ((i.command = r.command), (i.args = r.args)),
			r.options && (i.options = H2.from(r.options)),
			i
		)
	}
	n.from = e
	function t(r) {
		if (!(r == null || (r.command === void 0 && r.commandLine === void 0)))
			return r.commandLine ? new Ko(r.commandLine, r.options) : new Ko(r.command, r.args ? r.args : [], r.options)
	}
	n.to = t
})((pC ||= {}))
var Yo
;((n) => {
	function o(r) {
		if (r) {
			let i = r
			return i && i.customExecution === "customExecution"
		} else return !1
	}
	n.is = o
	function e(r) {
		return { customExecution: "customExecution" }
	}
	n.from = e
	function t(r, i) {
		return i.get(r)
	}
	n.to = t
})((Yo ||= {}))
var bR
;((e) => {
	function o(t, n) {
		let r
		return (
			t.scope !== void 0 && typeof t.scope != "number"
				? (r = t.scope.uri)
				: t.scope !== void 0 &&
					typeof t.scope == "number" &&
					(t.scope === 2 && n && n.workspaceFile ? (r = n.workspaceFile) : (r = N2)),
			{ id: t._id, workspaceFolder: r }
		)
	}
	e.from = o
})((bR ||= {}))
var W2
;((e) => {
	function o(t) {
		if (t != null) return { _id: t.id, isDefault: t.isDefault }
	}
	e.from = o
})((W2 ||= {}))
var Hi
;((n) => {
	function o(r, i) {
		if (r == null) return []
		let s = []
		for (let a of r) {
			let l = e(a, i)
			l && s.push(l)
		}
		return s
	}
	n.fromMany = o
	function e(r, i) {
		if (r == null) return
		let s
		r.execution instanceof Si
			? (s = uC.from(r.execution))
			: r.execution instanceof Ko
				? (s = pC.from(r.execution))
				: r.execution && r.execution instanceof yd && (s = Yo.from(r.execution))
		let a = hR.from(r.definition),
			l
		return (
			r.scope ? (typeof r.scope == "number" ? (l = r.scope) : (l = r.scope.uri)) : (l = 2),
			!a || !l
				? void 0
				: {
						_id: r._id,
						definition: a,
						name: r.name,
						source: { extensionId: i.identifier.value, label: r.source, scope: l },
						execution: s,
						isBackground: r.isBackground,
						group: W2.from(r.group),
						presentationOptions: vR.from(r.presentationOptions),
						problemMatchers: an(r.problemMatchers),
						hasDefinedMatchers: r.hasDefinedMatchers,
						runOptions: r.runOptions ? r.runOptions : { reevaluateOnRerun: !0 },
						detail: r.detail,
					}
		)
	}
	n.from = e
	async function t(r, i, s) {
		if (r == null) return
		let a
		uC.is(r.execution)
			? (a = uC.to(r.execution))
			: pC.is(r.execution)
				? (a = pC.to(r.execution))
				: Yo.is(r.execution) && (a = Yo.to(r._id, s))
		let l = hR.to(r.definition),
			d
		if (
			(r.source &&
				(r.source.scope !== void 0
					? typeof r.source.scope == "number"
						? (d = r.source.scope)
						: (d = await i.resolveWorkspaceFolder(b.revive(r.source.scope)))
					: (d = 2)),
			!l || !d)
		)
			return
		let c = new gn(l, d, r.name, r.source.label, a, r.problemMatchers)
		return (
			r.isBackground !== void 0 && (c.isBackground = r.isBackground),
			r.group !== void 0 &&
				((c.group = un.from(r.group._id)),
				c.group &&
					r.group.isDefault &&
					((c.group = new un(c.group.id, c.group.label)),
					r.group.isDefault === !0 && (c.group.isDefault = r.group.isDefault))),
			r.presentationOptions && (c.presentationOptions = vR.to(r.presentationOptions)),
			r._id && (c._id = r._id),
			r.detail && (c.detail = r.detail),
			c
		)
	}
	n.to = t
})((Hi ||= {}))
var V2
;((t) => {
	function o(n) {
		return n
	}
	t.from = o
	function e(n) {
		if (n) return Object.assign(Object.create(null), n)
	}
	t.to = e
})((V2 ||= {}))
var ah = class {
		constructor(e, t, n) {
			this._id = t
			this._task = n
			this.#e = e
		}
		#e
		get task() {
			return this._task
		}
		terminate() {
			this.#e.terminateTask(this)
		}
		fireDidStartProcess(e) {}
		fireDidEndProcess(e) {}
	},
	Hd = class {
		constructor(e, t, n, r, i, s, a, l) {
			this._onDidExecuteTask = new E()
			this._onDidTerminateTask = new E()
			this._onDidTaskProcessStarted = new E()
			this._onDidTaskProcessEnded = new E()
			this._onDidStartTaskProblemMatchers = new E()
			this._onDidEndTaskProblemMatchers = new E()
			;(this._proxy = e.getProxy(M.MainThreadTask)),
				(this._workspaceProvider = n),
				(this._editorService = r),
				(this._configurationService = i),
				(this._terminalService = s),
				(this._handleCounter = 0),
				(this._handlers = new Map()),
				(this._taskExecutions = new Map()),
				(this._taskExecutionPromises = new Map()),
				(this._providedCustomExecutions2 = new Map()),
				(this._notProvidedCustomExecutions = new Set()),
				(this._activeCustomExecutions2 = new Map()),
				(this._logService = a),
				(this._deprecationService = l),
				this._proxy.$registerSupportedExecutions(!0)
		}
		registerTaskProvider(e, t, n) {
			if (!n) return new ye(() => {})
			let r = this.nextHandle()
			return (
				this._handlers.set(r, { type: t, provider: n, extension: e }),
				this._proxy.$registerTaskProvider(r, t),
				new ye(() => {
					this._handlers.delete(r), this._proxy.$unregisterTaskProvider(r)
				})
			)
		}
		registerTaskSystem(e, t) {
			this._proxy.$registerTaskSystem(e, t)
		}
		fetchTasks(e) {
			return this._proxy.$fetchTasks(V2.from(e)).then(async (t) => {
				let n = []
				for (let r of t) {
					let i = await Hi.to(r, this._workspaceProvider, this._providedCustomExecutions2)
					i && n.push(i)
				}
				return n
			})
		}
		get taskExecutions() {
			let e = []
			return this._taskExecutions.forEach((t) => e.push(t)), e
		}
		terminateTask(e) {
			if (!(e instanceof ah)) throw new Error("No valid task execution provided")
			return this._proxy.$terminateTask(e._id)
		}
		get onDidStartTask() {
			return this._onDidExecuteTask.event
		}
		async $onDidStartTask(e, t, n) {
			let r = this._providedCustomExecutions2.get(e.id)
			r &&
				(this._activeCustomExecutions2.set(e.id, r),
				this._terminalService.attachPtyToTerminal(t, await r.callback(n))),
				(this._lastStartedTask = e.id),
				this._onDidExecuteTask.fire({ execution: await this.getTaskExecution(e) })
		}
		get onDidEndTask() {
			return this._onDidTerminateTask.event
		}
		async $OnDidEndTask(e) {
			if (!this._taskExecutionPromises.has(e.id)) return
			let t = await this.getTaskExecution(e)
			this._taskExecutionPromises.delete(e.id),
				this._taskExecutions.delete(e.id),
				this.customExecutionComplete(e),
				this._onDidTerminateTask.fire({ execution: t })
		}
		get onDidStartTaskProcess() {
			return this._onDidTaskProcessStarted.event
		}
		async $onDidStartTaskProcess(e) {
			let t = await this.getTaskExecution(e.id)
			this._onDidTaskProcessStarted.fire({ execution: t, processId: e.processId })
		}
		get onDidEndTaskProcess() {
			return this._onDidTaskProcessEnded.event
		}
		async $onDidEndTaskProcess(e) {
			let t = await this.getTaskExecution(e.id)
			this._onDidTaskProcessEnded.fire({ execution: t, exitCode: e.exitCode })
		}
		get onDidStartTaskProblemMatchers() {
			return this._onDidStartTaskProblemMatchers.event
		}
		async $onDidStartTaskProblemMatchers(e) {
			let t
			try {
				t = await this.getTaskExecution(e.execution.id)
			} catch {
				return
			}
			this._onDidStartTaskProblemMatchers.fire({ execution: t })
		}
		get onDidEndTaskProblemMatchers() {
			return this._onDidEndTaskProblemMatchers.event
		}
		async $onDidEndTaskProblemMatchers(e) {
			let t
			try {
				t = await this.getTaskExecution(e.execution.id)
			} catch {
				return
			}
			this._onDidEndTaskProblemMatchers.fire({ execution: t, hasErrors: e.hasErrors })
		}
		$provideTasks(e, t) {
			let n = this._handlers.get(e)
			if (!n) return Promise.reject(new Error("no handler found"))
			let r = [],
				i = Jt(() => n.provider.provideTasks(De.None)).then((s) => this.provideTasksInternal(t, r, n, s))
			return new Promise((s) => {
				i.then((a) => {
					Promise.all(r).then(() => {
						s(a)
					})
				})
			})
		}
		async $resolveTask(e, t) {
			let n = this._handlers.get(e)
			if (!n) return Promise.reject(new Error("no handler found"))
			if (t.definition.type !== n.type)
				throw new Error(
					`Unexpected: Task of type [${t.definition.type}] cannot be resolved by provider of type [${n.type}].`,
				)
			let r = await Hi.to(t, this._workspaceProvider, this._providedCustomExecutions2)
			if (!r) throw new Error("Unexpected: Task cannot be resolved.")
			let i = await n.provider.resolveTask(r, De.None)
			if (!i) return
			this.checkDeprecation(i, n)
			let s = Hi.from(i, n.extension)
			if (!s) throw new Error("Unexpected: Task cannot be resolved.")
			if (i.definition !== r.definition)
				throw new Error(
					"Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.",
				)
			return Yo.is(s.execution) && (await this.addCustomExecution(s, i, !0)), await this.resolveTaskInternal(s)
		}
		nextHandle() {
			return this._handleCounter++
		}
		async addCustomExecution(e, t, n) {
			let r = await this._proxy.$createTaskId(e)
			!n &&
				!this._providedCustomExecutions2.has(r) &&
				(this._notProvidedCustomExecutions.add(r), this._activeCustomExecutions2.set(r, t.execution)),
				this._providedCustomExecutions2.set(r, t.execution)
		}
		async getTaskExecution(e, t) {
			if (typeof e == "string") {
				let i = this._taskExecutionPromises.get(e)
				if (!i) throw new jn("Unexpected: The specified task is missing an execution")
				return i
			}
			let n = this._taskExecutionPromises.get(e.id)
			if (n) return n
			let r
			return (
				t
					? (r = Promise.resolve(new ah(this, e.id, t)))
					: (r = Hi.to(e.task, this._workspaceProvider, this._providedCustomExecutions2).then((i) => {
							if (!i) throw new jn("Unexpected: Task does not exist.")
							return new ah(this, e.id, i)
						})),
				this._taskExecutionPromises.set(e.id, r),
				r.then((i) => (this._taskExecutions.set(e.id, i), i))
			)
		}
		checkDeprecation(e, t) {
			e._deprecated &&
				this._deprecationService.report(
					"Task.constructor",
					t.extension,
					"Use the Task constructor that takes a `scope` instead.",
				)
		}
		customExecutionComplete(e) {
			this._activeCustomExecutions2.get(e.id) && this._activeCustomExecutions2.delete(e.id),
				this._notProvidedCustomExecutions.has(e.id) &&
					this._lastStartedTask !== e.id &&
					(this._providedCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.delete(e.id))
			let n = this._notProvidedCustomExecutions.values(),
				r = n.next()
			for (; !r.done; )
				!this._activeCustomExecutions2.has(r.value) &&
					this._lastStartedTask !== r.value &&
					(this._providedCustomExecutions2.delete(r.value),
					this._notProvidedCustomExecutions.delete(r.value)),
					(r = n.next())
		}
	}
Hd = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, no), S(4, pn), S(5, tr), S(6, te), S(7, Ks)], Hd)
var Gp = class extends Hd {
	constructor(e, t, n, r, i, s, a, l) {
		super(e, t, n, r, i, s, a, l),
			this.registerTaskSystem(W.vscodeRemote, { scheme: W.vscodeRemote, authority: "", platform: IE(0) })
	}
	async executeTask(e, t) {
		if (!t.execution) throw new Error("Tasks to execute must include an execution")
		let n = Hi.from(t, e)
		if (n === void 0) throw new Error("Task is not valid")
		if (Yo.is(n.execution)) await this.addCustomExecution(n, t, !1)
		else throw new Dl()
		let r = await this.getTaskExecution(await this._proxy.$getTaskExecution(n), t)
		return (
			this._proxy.$executeTask(n).catch((i) => {
				throw new Error(i)
			}),
			r
		)
	}
	provideTasksInternal(e, t, n, r) {
		let i = []
		if (r)
			for (let s of r) {
				if ((this.checkDeprecation(s, n), !s.definition || !e[s.definition.type])) {
					let l = s.source ? s.source : "No task source"
					this._logService.warn(
						`The task [${l}, ${s.name}] uses an undefined task type. The task will be ignored in the future.`,
					)
				}
				let a = Hi.from(s, n.extension)
				a && Yo.is(a.execution)
					? (i.push(a), t.push(this.addCustomExecution(a, s, !0)))
					: this._logService.warn("Only custom execution tasks supported.")
			}
		return { tasks: i, extension: n.extension }
	}
	async resolveTaskInternal(e) {
		if (Yo.is(e.execution)) return e
		this._logService.warn("Only custom execution tasks supported.")
	}
	async $resolveVariables(e, t) {
		return { process: void 0, variables: Object.create(null) }
	}
	async $jsonTasksSupported() {
		return !1
	}
	async $findExecutable(e, t, n) {}
}
Gp = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, no), S(4, pn), S(5, tr), S(6, te), S(7, Ks)], Gp)
var Qp = O("IExtHostTask")
var Jp = class {
	constructor() {
		this.pendingRequests = new Map()
		this.queue = []
		this._onError = new E()
		this._onExit = new E()
		this.sequence = 1
	}
	get onError() {
		return this._onError.event
	}
	get onExit() {
		return this._onExit.event
	}
	onMessage(e) {
		this.messageCallback && this._onError.fire(new Error("attempt to set more than one 'Message' callback")),
			(this.messageCallback = e)
	}
	onEvent(e) {
		this.eventCallback && this._onError.fire(new Error("attempt to set more than one 'Event' callback")),
			(this.eventCallback = e)
	}
	onRequest(e) {
		this.requestCallback && this._onError.fire(new Error("attempt to set more than one 'Request' callback")),
			(this.requestCallback = e)
	}
	sendResponse(e) {
		e.seq > 0
			? this._onError.fire(new Error(`attempt to send more than one response for command ${e.command}`))
			: this.internalSend("response", e)
	}
	sendRequest(e, t, n, r) {
		let i = { command: e }
		if (
			(t && Object.keys(t).length > 0 && (i.arguments = t), this.internalSend("request", i), typeof r == "number")
		) {
			let s = setTimeout(() => {
				clearTimeout(s)
				let a = this.pendingRequests.get(i.seq)
				if (a) {
					this.pendingRequests.delete(i.seq)
					let l = {
						type: "response",
						seq: 0,
						request_seq: i.seq,
						success: !1,
						command: e,
						message: p("timeout", "Timeout after {0} ms for '{1}'", r, e),
					}
					a(l)
				}
			}, r)
		}
		return n && this.pendingRequests.set(i.seq, n), i.seq
	}
	acceptMessage(e) {
		this.messageCallback
			? this.messageCallback(e)
			: (this.queue.push(e), this.queue.length === 1 && this.processQueue())
	}
	needsTaskBoundaryBetween(e, t) {
		return e.type !== "event" || t.type !== "event"
	}
	async processQueue() {
		let e
		for (; this.queue.length; ) {
			if (
				((!e || this.needsTaskBoundaryBetween(this.queue[0], e)) && (await Wt(0)), (e = this.queue.shift()), !e)
			)
				return
			switch (e.type) {
				case "event":
					this.eventCallback?.(e)
					break
				case "request":
					this.requestCallback?.(e)
					break
				case "response": {
					let t = e,
						n = this.pendingRequests.get(t.request_seq)
					n && (this.pendingRequests.delete(t.request_seq), n(t))
					break
				}
			}
		}
	}
	internalSend(e, t) {
		;(t.type = e), (t.seq = this.sequence++), this.sendMessage(t)
	}
	async cancelPendingRequests() {
		if (this.pendingRequests.size === 0) return Promise.resolve()
		let e = new Map()
		this.pendingRequests.forEach((t, n) => e.set(n, t)),
			await Wt(500),
			e.forEach((t, n) => {
				t({ type: "response", seq: 0, request_seq: n, success: !1, command: "canceled", message: "canceled" }),
					this.pendingRequests.delete(n)
			})
	}
	getPendingRequestIds() {
		return Array.from(this.pendingRequests.keys())
	}
	dispose() {
		this.queue = []
	}
}
function B2(o) {
	return o.type && (o.label || o.program || o.runtime)
}
var Y8 = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/
function Z8(o) {
	return !!(o && o.match(Y8))
}
function $2(o) {
	if (typeof o.path == "string" && !(typeof o.sourceReference == "number" && o.sourceReference > 0)) {
		if (Z8(o.path)) return b.parse(o.path)
		if (In(o.path)) return b.file(o.path)
	}
	return o.path
}
function z2(o) {
	if (typeof o.path == "object") {
		let e = b.revive(o.path)
		if (e) return e.scheme === W.file ? e.fsPath : e.toString()
	}
	return o.path
}
function q2(o, e) {
	let t = e ? $2 : z2,
		n = je(o)
	return (
		j2(n, (r, i) => {
			r && i && (i.path = t(i))
		}),
		n
	)
}
function K2(o, e) {
	let t = e ? $2 : z2,
		n = je(o)
	return (
		j2(n, (r, i) => {
			!r && i && (i.path = t(i))
		}),
		n
	)
}
function j2(o, e) {
	switch (o.type) {
		case "event": {
			let t = o
			switch (t.event) {
				case "output":
					e(!1, t.body.source)
					break
				case "loadedSource":
					e(!1, t.body.source)
					break
				case "breakpoint":
					e(!1, t.body.breakpoint.source)
					break
				default:
					break
			}
			break
		}
		case "request": {
			let t = o
			switch (t.command) {
				case "setBreakpoints":
					e(!0, t.arguments.source)
					break
				case "breakpointLocations":
					e(!0, t.arguments.source)
					break
				case "source":
					e(!0, t.arguments.source)
					break
				case "gotoTargets":
					e(!0, t.arguments.source)
					break
				case "launchVSCode":
					t.arguments.args.forEach((n) => e(!1, n))
					break
				default:
					break
			}
			break
		}
		case "response": {
			let t = o
			if (t.success && t.body)
				switch (t.command) {
					case "stackTrace":
						t.body.stackFrames.forEach((n) => e(!1, n.source))
						break
					case "loadedSources":
						t.body.sources.forEach((n) => e(!1, n))
						break
					case "scopes":
						t.body.scopes.forEach((n) => e(!1, n.source))
						break
					case "setFunctionBreakpoints":
						t.body.breakpoints.forEach((n) => e(!1, n.source))
						break
					case "setBreakpoints":
						t.body.breakpoints.forEach((n) => e(!1, n.source))
						break
					case "disassemble":
						t.body?.instructions.forEach((r) => e(!1, r.location))
						break
					case "locations":
						e(!1, t.body?.source)
						break
					default:
						break
				}
			break
		}
	}
}
var Zo = O("IExtHostEditorTabs"),
	mC = class {
		constructor(e, t, n) {
			;(this._activeTabIdGetter = n), (this._parentGroup = t), this.acceptDtoUpdate(e)
		}
		get apiObject() {
			if (!this._apiObject) {
				let e = this,
					t = {
						get isActive() {
							return e._dto.id === e._activeTabIdGetter()
						},
						get label() {
							return e._dto.label
						},
						get input() {
							return e._input
						},
						get isDirty() {
							return e._dto.isDirty
						},
						get isPinned() {
							return e._dto.isPinned
						},
						get isPreview() {
							return e._dto.isPreview
						},
						get group() {
							return e._parentGroup.apiObject
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		get tabId() {
			return this._dto.id
		}
		acceptDtoUpdate(e) {
			;(this._dto = e), (this._input = this._initInput())
		}
		_initInput() {
			switch (this._dto.input.kind) {
				case 1:
					return new Qa(b.revive(this._dto.input.uri))
				case 2:
					return new Ps(b.revive(this._dto.input.original), b.revive(this._dto.input.modified))
				case 3:
					return new Lu(
						b.revive(this._dto.input.base),
						b.revive(this._dto.input.input1),
						b.revive(this._dto.input.input2),
						b.revive(this._dto.input.result),
					)
				case 6:
					return new Ja(b.revive(this._dto.input.uri), this._dto.input.viewType)
				case 7:
					return new Mu(this._dto.input.viewType)
				case 4:
					return new Xa(b.revive(this._dto.input.uri), this._dto.input.notebookType)
				case 5:
					return new Ya(
						b.revive(this._dto.input.original),
						b.revive(this._dto.input.modified),
						this._dto.input.notebookType,
					)
				case 8:
					return new Fu()
				case 9:
					return new Nu(b.revive(this._dto.input.uri), b.revive(this._dto.input.inputBoxUri))
				case 10:
					return new Uu()
				case 11:
					return new Hu(
						this._dto.input.diffEditors.map((e) => new Ps(b.revive(e.original), b.revive(e.modified))),
					)
				default:
					return
			}
		}
	},
	yR = class {
		constructor(e, t) {
			this._tabs = []
			this._activeTabId = ""
			;(this._dto = e), (this._activeGroupIdGetter = t)
			for (let n of e.tabs)
				n.isActive && (this._activeTabId = n.id), this._tabs.push(new mC(n, this, () => this.activeTabId()))
		}
		get apiObject() {
			if (!this._apiObject) {
				let e = this,
					t = {
						get isActive() {
							return e._dto.groupId === e._activeGroupIdGetter()
						},
						get viewColumn() {
							return wt.to(e._dto.viewColumn)
						},
						get activeTab() {
							return e._tabs.find((n) => n.tabId === e._activeTabId)?.apiObject
						},
						get tabs() {
							return Object.freeze(e._tabs.map((n) => n.apiObject))
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		get groupId() {
			return this._dto.groupId
		}
		get tabs() {
			return this._tabs
		}
		acceptGroupDtoUpdate(e) {
			this._dto = e
		}
		acceptTabOperation(e) {
			if (e.kind === 0) {
				let n = new mC(e.tabDto, this, () => this.activeTabId())
				return this._tabs.splice(e.index, 0, n), e.tabDto.isActive && (this._activeTabId = n.tabId), n
			} else if (e.kind === 1) {
				let n = this._tabs.splice(e.index, 1)[0]
				if (!n) throw new Error(`Tab close updated received for index ${e.index} which does not exist`)
				return n.tabId === this._activeTabId && (this._activeTabId = ""), n
			} else if (e.kind === 3) {
				if (e.oldIndex === void 0) throw new Error("Invalid old index on move IPC")
				let n = this._tabs.splice(e.oldIndex, 1)[0]
				if (!n) throw new Error(`Tab move updated received for index ${e.oldIndex} which does not exist`)
				return this._tabs.splice(e.index, 0, n), n
			}
			let t = this._tabs.find((n) => n.tabId === e.tabDto.id)
			if (!t) throw new Error("INVALID tab")
			return (
				e.tabDto.isActive
					? (this._activeTabId = e.tabDto.id)
					: this._activeTabId === e.tabDto.id && !e.tabDto.isActive && (this._activeTabId = ""),
				t.acceptDtoUpdate(e.tabDto),
				t
			)
		}
		activeTabId() {
			return this._activeTabId
		}
	},
	Xp = class {
		constructor(e) {
			this._onDidChangeTabs = new E()
			this._onDidChangeTabGroups = new E()
			this._extHostTabGroups = []
			this._proxy = e.getProxy(M.MainThreadEditorTabs)
		}
		get tabGroups() {
			if (!this._apiObject) {
				let e = this,
					t = {
						onDidChangeTabGroups: e._onDidChangeTabGroups.event,
						onDidChangeTabs: e._onDidChangeTabs.event,
						get all() {
							return Object.freeze(e._extHostTabGroups.map((n) => n.apiObject))
						},
						get activeTabGroup() {
							let n = e._activeGroupId
							return Ro(e._extHostTabGroups.find((i) => i.groupId === n)?.apiObject)
						},
						close: async (n, r) => {
							let i = Array.isArray(n) ? n : [n]
							return i.length ? (e9(i[0]) ? this._closeGroups(i, r) : this._closeTabs(i, r)) : !0
						},
					}
				this._apiObject = Object.freeze(t)
			}
			return this._apiObject
		}
		$acceptEditorTabModel(e) {
			let t = new Set(this._extHostTabGroups.map((d) => d.groupId)),
				n = new Set(e.map((d) => d.groupId)),
				r = rE(t, n),
				i = this._extHostTabGroups.filter((d) => r.removed.includes(d.groupId)).map((d) => d.apiObject),
				s = [],
				a = []
			this._extHostTabGroups = e.map((d) => {
				let c = new yR(d, () => this._activeGroupId)
				return r.added.includes(c.groupId) ? s.push(c.apiObject) : a.push(c.apiObject), c
			})
			let l = Ro(e.find((d) => d.isActive === !0)?.groupId)
			l !== void 0 && this._activeGroupId !== l && (this._activeGroupId = l),
				this._onDidChangeTabGroups.fire(Object.freeze({ opened: s, closed: i, changed: a }))
		}
		$acceptTabGroupUpdate(e) {
			let t = this._extHostTabGroups.find((n) => n.groupId === e.groupId)
			if (!t) throw new Error("Update Group IPC call received before group creation.")
			t.acceptGroupDtoUpdate(e),
				e.isActive && (this._activeGroupId = e.groupId),
				this._onDidChangeTabGroups.fire(Object.freeze({ changed: [t.apiObject], opened: [], closed: [] }))
		}
		$acceptTabOperation(e) {
			let t = this._extHostTabGroups.find((r) => r.groupId === e.groupId)
			if (!t) throw new Error("Update Tabs IPC call received before group creation.")
			let n = t.acceptTabOperation(e)
			switch (e.kind) {
				case 0:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [n.apiObject], closed: [], changed: [] }))
					return
				case 1:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [], closed: [n.apiObject], changed: [] }))
					return
				case 3:
				case 2:
					this._onDidChangeTabs.fire(Object.freeze({ opened: [], closed: [], changed: [n.apiObject] }))
					return
			}
		}
		_findExtHostTabFromApi(e) {
			for (let t of this._extHostTabGroups) for (let n of t.tabs) if (n.apiObject === e) return n
		}
		_findExtHostTabGroupFromApi(e) {
			return this._extHostTabGroups.find((t) => t.apiObject === e)
		}
		async _closeTabs(e, t) {
			let n = []
			for (let r of e) {
				let i = this._findExtHostTabFromApi(r)
				if (!i) throw new Error("Tab close: Invalid tab not found!")
				n.push(i.tabId)
			}
			return this._proxy.$closeTab(n, t)
		}
		async _closeGroups(e, t) {
			let n = []
			for (let r of e) {
				let i = this._findExtHostTabGroupFromApi(r)
				if (!i) throw new Error("Group close: Invalid group not found!")
				n.push(i.groupId)
			}
			return this._proxy.$closeGroup(n, t)
		}
	}
Xp = R([S(0, ie)], Xp)
function e9(o) {
	return o.tabs !== void 0
}
var uPe = {
	6: p("testState.errored", "Errored"),
	4: p("testState.failed", "Failed"),
	3: p("testState.passed", "Passed"),
	1: p("testState.queued", "Queued"),
	2: p("testState.running", "Running"),
	5: p("testState.skipped", "Skipped"),
	0: p("testState.unset", "Not yet run"),
}
var pPe = { 4: p("testGroup.debug", "Debug"), 2: p("testGroup.run", "Run"), 8: p("testGroup.coverage", "Coverage") }
var n9 = 0,
	G2 = new WeakMap(),
	js = O("IExtHostTesting"),
	Yp = class extends $ {
		constructor(t, n, r, i) {
			super()
			this.logService = n
			this.commands = r
			this.editors = i
			this.resultsChangedEmitter = this._register(new E())
			this.controllers = new Map()
			this.defaultProfilesChangedEmitter = this._register(new E())
			this.followupProviders = new Set()
			this.testFollowups = new Map()
			this.onResultsChanged = this.resultsChangedEmitter.event
			this.results = []
			;(this.proxy = t.getProxy(M.MainThreadTesting)),
				(this.observer = new TR(this.proxy)),
				(this.runTracker = new xR(this.proxy, n)),
				r.registerArgumentProcessor({
					processArgument: (s) => {
						switch (s?.$mid) {
							case 16: {
								let a = s,
									l = a.tests[a.tests.length - 1].item.extId
								return this.controllers.get(ze.root(l))?.collection.tree.get(l)?.actual ?? Lk(s)
							}
							case 18: {
								let { test: a, message: l } = s,
									d = a.item.extId
								return {
									test:
										this.controllers.get(ze.root(d))?.collection.tree.get(d)?.actual ??
										Lk({ $mid: 16, tests: [a] }),
									message: tp.to(l),
								}
							}
							default:
								return s
						}
					},
				}),
				r.registerCommand(!1, "testing.getExplorerSelection", async () => {
					let s = await r.executeCommand("_testing.getExplorerSelection"),
						a = (l) => {
							let d = this.controllers.get(ze.root(l))
							if (d) return ze.isRoot(l) ? d.controller : d.collection.tree.get(l)?.actual
						}
					return { include: s?.include.map(a).filter(or) || [], exclude: s?.exclude.map(a).filter(or) || [] }
				})
		}
		createTestController(t, n, r, i) {
			if (this.controllers.has(n)) throw new Error(`Attempt to insert a duplicate controller with ID "${n}"`)
			let s = new Q(),
				a = s.add(new Kx(n, r, this.editors))
			a.root.label = r
			let l = new Map(),
				d = new Set(),
				c = this.proxy,
				u = () => {
					let h = 0
					i && (h |= 2)
					let g = f.relatedCodeProvider
					return g && (g?.provideRelatedTests && (h |= 8), g?.provideRelatedCode && (h |= 4)), h
				},
				m = {
					items: a.root.children,
					get label() {
						return r
					},
					set label(h) {
						;(r = h), (a.root.label = h), c.$updateController(n, { label: r })
					},
					get refreshHandler() {
						return i
					},
					set refreshHandler(h) {
						;(i = h), c.$updateController(n, { capabilities: u() })
					},
					get id() {
						return n
					},
					get relatedCodeProvider() {
						return f.relatedCodeProvider
					},
					set relatedCodeProvider(h) {
						F(t, "testRelatedCode"),
							(f.relatedCodeProvider = h),
							c.$updateController(n, { capabilities: u() })
					},
					createRunProfile: (h, g, I, C, T, w) => {
						let L = lr(h)
						for (; l.has(L); ) L++
						return new gC(
							this.proxy,
							l,
							d,
							this.defaultProfilesChangedEmitter.event,
							n,
							L,
							h,
							g,
							I,
							C,
							T,
							w,
						)
					},
					createTestItem(h, g, I) {
						return new zs(n, h, g, I)
					},
					createTestRun: (h, g, I = !0) => this.runTracker.createTestRun(t, n, a, h, g, I),
					invalidateTestResults: (h) => {
						if (h === void 0) this.proxy.$markTestRetired(void 0)
						else {
							let g = h instanceof Array ? h : [h]
							this.proxy.$markTestRetired(g.map((I) => ze.fromExtHostTestItem(I, n).toString()))
						}
					},
					set resolveHandler(h) {
						a.resolveHandler = h
					},
					get resolveHandler() {
						return a.resolveHandler
					},
					dispose: () => {
						s.dispose()
					},
				},
				f = { controller: m, collection: a, profiles: l, extension: t, activeProfiles: d }
			return (
				c.$registerTestController(n, r, u()),
				s.add(q(() => c.$unregisterTestController(n))),
				this.controllers.set(n, f),
				s.add(q(() => this.controllers.delete(n))),
				s.add(a.onDidGenerateDiff((h) => c.$publishDiff(n, h.map(By.serialize)))),
				m
			)
		}
		createTestObserver() {
			return this.observer.checkout()
		}
		async runTests(t, n = De.None) {
			let r = Q2(t)
			if (!r) throw new Error("The request passed to `vscode.test.runTests` must include a profile")
			let i = this.controllers.get(r.controllerId)
			if (!i) throw new Error("Controller not found")
			await this.proxy.$runTests(
				{
					preserveFocus: t.preserveFocus ?? !0,
					group: np.from(r.kind),
					targets: [
						{
							testIds: t.include?.map((s) =>
								ze.fromExtHostTestItem(s, i.collection.root.id).toString(),
							) ?? [i.collection.root.id],
							profileId: r.profileId,
							controllerId: r.controllerId,
						},
					],
					exclude: t.exclude?.map((s) => s.id),
				},
				n,
			)
		}
		registerTestFollowupProvider(t) {
			return (
				this.followupProviders.add(t),
				{
					dispose: () => {
						this.followupProviders.delete(t)
					},
				}
			)
		}
		async $getTestsRelatedToCode(t, n, r) {
			let i = this.editors.getDocument(b.revive(t))
			if (!i) return []
			let s = Je.to(n),
				a = []
			return (
				await Promise.all(
					[...this.controllers.values()].map(async (l) => {
						let d
						try {
							d = await l.relatedCodeProvider?.provideRelatedTests?.(i.document, s, r)
						} catch (c) {
							r.isCancellationRequested ||
								this.logService.warn(
									`Error thrown while providing related tests for ${l.controller.label}`,
									c,
								)
						}
						if (d) {
							for (let c of d) a.push(ze.fromExtHostTestItem(c, l.controller.id).toString())
							l.collection.flushDiff()
						}
					}),
				),
				a
			)
		}
		async $getCodeRelatedToTest(t, n) {
			let r = this.controllers.get(ze.root(t))
			if (!r) return []
			let i = r.collection.tree.get(t)
			return i ? ((await r.relatedCodeProvider?.provideRelatedCode?.(i.actual, n))?.map($n.from) ?? []) : []
		}
		$syncTests() {
			for (let { collection: t } of this.controllers.values()) t.flushDiff()
			return Promise.resolve()
		}
		async $getCoverageDetails(t, n, r) {
			return (await this.runTracker.getCoverageDetails(t, n, r))?.map(Ag.fromDetails)
		}
		async $disposeRun(t) {
			this.runTracker.disposeTestRun(t)
		}
		$configureRunProfile(t, n) {
			this.controllers.get(t)?.profiles.get(n)?.configureHandler?.()
		}
		$setDefaultRunProfiles(t) {
			let n = new Map()
			for (let [r, i] of Object.entries(t)) {
				let s = this.controllers.get(r)
				if (!s) continue
				let a = new Map(),
					l = i.filter((c) => !s.activeProfiles.has(c)),
					d = [...s.activeProfiles].filter((c) => !i.includes(c))
				for (let c of l) a.set(c, !0), s.activeProfiles.add(c)
				for (let c of d) a.set(c, !1), s.activeProfiles.delete(c)
				a.size && n.set(r, a)
			}
			this.defaultProfilesChangedEmitter.fire(n)
		}
		async $refreshTests(t, n) {
			await this.controllers.get(t)?.controller.refreshHandler?.(n)
		}
		$publishTestResults(t) {
			;(this.results = Object.freeze(
				t
					.map((n) => {
						let r = rk.to(n),
							i = n.tasks.findIndex((s) => s.hasCoverage)
						return (
							i !== -1 &&
								(r.getDetailedCoverage = (s, a = De.None) =>
									this.proxy.$getCoverageDetails(n.id, i, s, a).then((l) => l.map(Ag.to))),
							G2.set(r, n.id),
							r
						)
					})
					.concat(this.results)
					.sort((n, r) => r.completedAt - n.completedAt)
					.slice(0, 32),
			)),
				this.resultsChangedEmitter.fire()
		}
		async $expandTest(t, n) {
			let r = this.controllers.get(ze.fromString(t).controllerId)?.collection
			r && (await r.expand(t, n < 0 ? 1 / 0 : n), r.flushDiff())
		}
		$acceptDiff(t) {
			this.observer.applyDiff(t.map((n) => By.deserialize({ asCanonicalUri: (r) => r }, n)))
		}
		async $runControllerTests(t, n) {
			return Promise.all(t.map((r) => this.runControllerTestRequest(r, !1, n)))
		}
		async $startContinuousRun(t, n) {
			let r = new _e(n),
				i = await Promise.all(t.map((s) => this.runControllerTestRequest(s, !0, r.token)))
			return (
				!n.isCancellationRequested &&
					!i.some((s) => s.error) &&
					(await new Promise((s) => n.onCancellationRequested(s))),
				r.dispose(!0),
				i
			)
		}
		async $provideTestFollowups(t, n) {
			let r = this.results.find((a) => G2.get(a) === t.resultId),
				i = r && o9(ze.fromString(t.extId), r?.results)
			if (!i) return []
			let s = []
			return (
				await Promise.all(
					[...this.followupProviders].map(async (a) => {
						try {
							let l = await a.provideFollowup(r, i, t.taskIndex, t.messageIndex, n)
							l && (s = s.concat(l))
						} catch (l) {
							this.logService.error("Error thrown while providing followup for test message", l)
						}
					}),
				),
				n.isCancellationRequested
					? []
					: s.map((a) => {
							let l = n9++
							return this.testFollowups.set(l, a), { title: a.title, id: l }
						})
			)
		}
		$disposeTestFollowups(t) {
			for (let n of t) this.testFollowups.delete(n)
		}
		$executeTestFollowup(t) {
			let n = this.testFollowups.get(t)
			return n ? this.commands.executeCommand(n.command, ...(n.arguments || [])) : Promise.resolve()
		}
		$cancelExtensionTestRun(t, n) {
			t === void 0 ? this.runTracker.cancelAllRuns() : this.runTracker.cancelRunById(t, n)
		}
		getMetadataForRun(t) {
			for (let n of this.runTracker.trackers) {
				let r = n.getTaskIdForRun(t)
				if (r) return { taskId: r, runId: n.id }
			}
		}
		async runControllerTestRequest(t, n, r) {
			let i = this.controllers.get(t.controllerId)
			if (!i) return {}
			let { collection: s, profiles: a, extension: l } = i,
				d = a.get(t.profileId)
			if (!d) return {}
			let c = t.testIds.map((h) => s.tree.get(h)).filter(or),
				u = t.excludeExtIds
					.map((h) => i.collection.tree.get(h))
					.filter(or)
					.filter((h) => c.some((g) => g.fullId.compare(h.fullId) === 2))
			if (!c.length) return {}
			let m = new $a(
					c.some((h) => h.actual instanceof Ep) ? void 0 : c.map((h) => h.actual),
					u.map((h) => h.actual),
					d,
					n,
				),
				f = yF(t) && this.runTracker.prepareForMainThreadTestRun(l, m, fC.fromInternal(t, i.collection), d, r)
			try {
				return await d.runHandler(m, r), {}
			} catch (h) {
				return { error: String(h) }
			} finally {
				f && f.hasRunningTasks && !r.isCancellationRequested && (await Ee.toPromise(f.onEnd))
			}
		}
	}
Yp = R([S(0, ie), S(1, te), S(2, Tn), S(3, no)], Yp)
var r9 = 1e4
var IR = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.dto = t
			this.proxy = n
			this.logService = r
			this.profile = i
			this.extension = s
			this.state = 0
			this.running = 0
			this.tasks = new Map()
			this.sharedTestIds = new Set()
			this.endEmitter = this._register(new E())
			this.publishedCoverage = new Map()
			this.onEnd = this.endEmitter.event
			this.cts = this._register(new _e(a))
			let l = this._register(new Wn(() => this.forciblyEndTasks(), r9))
			this._register(this.cts.token.onCancellationRequested(() => l.schedule()))
			let d = new E()
			;(this.onDidDispose = d.event),
				this._register(
					q(() => {
						d.fire(), d.dispose()
					}),
				)
		}
		get hasRunningTasks() {
			return this.running > 0
		}
		get id() {
			return this.dto.id
		}
		getTaskIdForRun(t) {
			for (let [n, { run: r }] of this.tasks) if (r === t) return n
		}
		cancel(t) {
			t
				? this.tasks.get(t)?.cts.cancel()
				: this.state === 0
					? (this.cts.cancel(), (this.state = 1))
					: this.state === 1 && this.forciblyEndTasks()
		}
		async getCoverageDetails(t, n, r) {
			let [, i] = ze.fromString(t).path,
				s = this.publishedCoverage.get(t)
			if (!s) return []
			let { report: a, extIds: l } = s,
				d = this.tasks.get(i)
			if (!d) throw new Error("unreachable: run task was not found")
			let c
			if (n && a instanceof ws) {
				let m = l.indexOf(n)
				if (m === -1) return []
				c = a.includesTests[m]
			}
			return (
				(await (c
					? this.profile?.loadDetailedCoverageForTest?.(d.run, a, c, r)
					: this.profile?.loadDetailedCoverage?.(d.run, a, r))) ?? []
			)
		}
		createRun(t) {
			let n = this.dto.id,
				r = this.dto.controllerId,
				i = He(),
				s =
					(u) =>
					(m, ...f) => {
						if (l) {
							this.logService.warn(`Setting the state of test "${m.id}" is a no-op after the run ends.`)
							return
						}
						this.ensureTestIsKnown(m), u(m, ...f)
					},
				a = (u, m) => {
					let f = m instanceof Array ? m.map(tp.from) : [tp.from(m)]
					if (u.uri && u.range) {
						let h = { range: H.from(u.range), uri: u.uri }
						for (let g of f) g.location = g.location || h
					}
					this.proxy.$appendTestMessagesInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), f)
				},
				l = !1,
				d = this._register(new _e(this.cts.token)),
				c = {
					isPersisted: this.dto.isPersisted,
					token: d.token,
					name: t,
					onDidDispose: this.onDidDispose,
					addCoverage: (u) => {
						if (l) return
						let m = u instanceof ws ? u.includesTests : []
						if (m.length) for (let g of m) this.ensureTestIsKnown(g)
						let f = u.uri.toString(),
							h = new ze([n, i, f]).toString()
						this.publishedCoverage.set(h, {
							report: u,
							extIds: m.map((g) => ze.fromExtHostTestItem(g, r).toString()),
						}),
							this.proxy.$appendCoverage(n, i, Ag.fromFile(r, h, u))
					},
					enqueued: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 1)
					}),
					skipped: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 5)
					}),
					started: s((u) => {
						this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 2)
					}),
					errored: s((u, m, f) => {
						a(u, m), this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 6, f)
					}),
					failed: s((u, m, f) => {
						a(u, m), this.proxy.$updateTestStateInRun(n, i, ze.fromExtHostTestItem(u, r).toString(), 4, f)
					}),
					passed: s((u, m) => {
						this.proxy.$updateTestStateInRun(
							n,
							i,
							ze.fromExtHostTestItem(u, this.dto.controllerId).toString(),
							3,
							m,
						)
					}),
					appendOutput: (u, m, f) => {
						l ||
							(f && this.ensureTestIsKnown(f),
							this.proxy.$appendOutputToRun(
								n,
								i,
								z.fromString(u),
								m && $n.from(m),
								f && ze.fromExtHostTestItem(f, r).toString(),
							))
					},
					end: () => {
						l || ((l = !0), this.proxy.$finishedTestRunTask(n, i), --this.running || this.markEnded())
					},
				}
			return (
				this.running++,
				this.tasks.set(i, { run: c, cts: d }),
				this.proxy.$startedTestRunTask(n, {
					id: i,
					ctrlId: this.dto.controllerId,
					name: t || this.extension.displayName || this.extension.identifier.value,
					running: !0,
				}),
				c
			)
		}
		forciblyEndTasks() {
			for (let { run: t } of this.tasks.values()) t.end()
		}
		markEnded() {
			this.state !== 2 && ((this.state = 2), this.endEmitter.fire())
		}
		ensureTestIsKnown(t) {
			if (!(t instanceof zs)) throw new Pa(t.id)
			if (this.sharedTestIds.has(ze.fromExtHostTestItem(t, this.dto.controllerId).toString())) return
			let n = [],
				r = this.dto.colllection.root
			for (;;) {
				let i = Oi.from(t)
				if ((n.unshift(i), this.sharedTestIds.has(i.extId) || (this.sharedTestIds.add(i.extId), t === r))) break
				t = t.parent || r
			}
			this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, n)
		}
		dispose() {
			this.markEnded(), super.dispose()
		}
	},
	xR = class {
		constructor(e, t) {
			this.proxy = e
			this.logService = t
			this.tracked = new Map()
			this.trackedById = new Map()
		}
		get trackers() {
			return this.tracked.values()
		}
		getCoverageDetails(e, t, n) {
			let r = ze.root(e)
			return this.trackedById.get(r)?.getCoverageDetails(e, t, n) || []
		}
		disposeTestRun(e) {
			this.trackedById.get(e)?.dispose(), this.trackedById.delete(e)
			for (let [t, { id: n }] of this.tracked) n === e && this.tracked.delete(t)
		}
		prepareForMainThreadTestRun(e, t, n, r, i) {
			return this.getTracker(t, n, r, e, i)
		}
		cancelRunById(e, t) {
			this.trackedById.get(e)?.cancel(t)
		}
		cancelAllRuns() {
			for (let e of this.tracked.values()) e.cancel()
		}
		createTestRun(e, t, n, r, i, s) {
			let a = this.tracked.get(r)
			if (a) return a.createRun(i)
			let l = fC.fromPublic(t, n, r, s),
				d = Q2(r)
			this.proxy.$startedExtensionTestRun({
				controllerId: t,
				continuous: !!r.continuous,
				profile: d && { group: np.from(d.kind), id: d.profileId },
				exclude: r.exclude?.map((u) => ze.fromExtHostTestItem(u, n.root.id).toString()) ?? [],
				id: l.id,
				include: r.include?.map((u) => ze.fromExtHostTestItem(u, n.root.id).toString()) ?? [n.root.id],
				preserveFocus: r.preserveFocus ?? !0,
				persist: s,
			})
			let c = this.getTracker(r, l, r.profile, e)
			return (
				Ee.once(c.onEnd)(() => {
					this.proxy.$finishedExtensionTestRun(l.id)
				}),
				c.createRun(i)
			)
		}
		getTracker(e, t, n, r, i) {
			let s = new IR(t, this.proxy, this.logService, n, r, i)
			return this.tracked.set(e, s), this.trackedById.set(s.id, s), s
		}
	},
	Q2 = (o) => {
		if (o.profile) {
			if (!(o.profile instanceof gC))
				throw new Error(
					"TestRunRequest.profile is not an instance created from TestController.createRunProfile",
				)
			return o.profile
		}
	},
	fC = class o {
		constructor(e, t, n, r) {
			this.controllerId = e
			this.id = t
			this.isPersisted = n
			this.colllection = r
		}
		static fromPublic(e, t, n, r) {
			return new o(e, He(), r, t)
		}
		static fromInternal(e, t) {
			return new o(e.controllerId, e.runId, !0, t)
		}
	},
	CR = class {
		constructor(e) {
			this.emitter = e
			this.added = new Set()
			this.updated = new Set()
			this.removed = new Set()
			this.alreadyRemoved = new Set()
		}
		get isEmpty() {
			return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0
		}
		add(e) {
			this.added.add(e)
		}
		update(e) {
			Object.assign(e.revived, Oi.toPlain(e.item)), this.added.has(e) || this.updated.add(e)
		}
		remove(e) {
			if (this.added.has(e)) {
				this.added.delete(e)
				return
			}
			this.updated.delete(e)
			let t = ze.parentId(e.item.extId)
			if (t && this.alreadyRemoved.has(t.toString())) {
				this.alreadyRemoved.add(e.item.extId)
				return
			}
			this.removed.add(e)
		}
		getChangeEvent() {
			let { added: e, updated: t, removed: n } = this
			return {
				get added() {
					return [...e].map((r) => r.revived)
				},
				get updated() {
					return [...t].map((r) => r.revived)
				},
				get removed() {
					return [...n].map((r) => r.revived)
				},
			}
		}
		complete() {
			this.isEmpty || this.emitter.fire(this.getChangeEvent())
		}
	},
	SR = class extends Hy {
		constructor() {
			super(...arguments)
			this.changeEmitter = new E()
			this.onDidChangeTests = this.changeEmitter.event
		}
		get rootTests() {
			return this.roots
		}
		getMirroredTestDataById(t) {
			return this.items.get(t)
		}
		getMirroredTestDataByReference(t) {
			return this.items.get(t.id)
		}
		createItem(t, n) {
			return { ...t, revived: Oi.toPlain(t.item), depth: n ? n.depth + 1 : 0, children: new Set() }
		}
		createChangeCollector() {
			return new CR(this.changeEmitter)
		}
	},
	TR = class {
		constructor(e) {
			this.proxy = e
		}
		checkout() {
			this.current || (this.current = this.createObserverData())
			let e = this.current
			return (
				e.observers++,
				{
					onDidChangeTest: e.tests.onDidChangeTests,
					get tests() {
						return [...e.tests.rootTests].map((t) => t.revived)
					},
					dispose: ji(() => {
						--e.observers === 0 && (this.proxy.$unsubscribeFromDiffs(), (this.current = void 0))
					}),
				}
			)
		}
		getMirroredTestDataByReference(e) {
			return this.current?.tests.getMirroredTestDataByReference(e)
		}
		applyDiff(e) {
			this.current?.tests.apply(e)
		}
		createObserverData() {
			let e = new SR({ asCanonicalUri: (t) => t })
			return this.proxy.$subscribeToDiffs(), { observers: 0, tests: e }
		}
	},
	lh = (o, e, t, n) => {
		t ? Object.assign(t, n) : e.$updateTestRunConfig(o.controllerId, o.profileId, n)
	},
	gC = class extends ku {
		constructor(t, n, r, i, s, a, l, d, c, u = !1, m = void 0, f = !1) {
			super(s, a, d)
			this._label = l
			this.runHandler = c
			this._tag = m
			this._supportsContinuousRun = f
			;(this.#e = t), (this.#i = n), (this.#t = r), (this.#n = i), n.set(a, this)
			let h = np.from(d)
			u && r.add(a),
				(this.#r = {
					profileId: a,
					controllerId: s,
					tag: m ? So.namespace(this.controllerId, m.id) : null,
					label: l,
					group: h,
					isDefault: u,
					hasConfigurationHandler: !1,
					supportsContinuousRun: f,
				}),
				queueMicrotask(() => {
					this.#r && (this.#e.$publishTestRunProfile(this.#r), (this.#r = void 0))
				})
		}
		#e
		#t
		#n
		#r
		#i
		get label() {
			return this._label
		}
		set label(t) {
			t !== this._label && ((this._label = t), lh(this, this.#e, this.#r, { label: t }))
		}
		get supportsContinuousRun() {
			return this._supportsContinuousRun
		}
		set supportsContinuousRun(t) {
			t !== this._supportsContinuousRun &&
				((this._supportsContinuousRun = t), lh(this, this.#e, this.#r, { supportsContinuousRun: t }))
		}
		get isDefault() {
			return this.#t.has(this.profileId)
		}
		set isDefault(t) {
			t !== this.isDefault &&
				(t ? this.#t.add(this.profileId) : this.#t.delete(this.profileId),
				lh(this, this.#e, this.#r, { isDefault: t }))
		}
		get tag() {
			return this._tag
		}
		set tag(t) {
			t?.id !== this._tag?.id &&
				((this._tag = t), lh(this, this.#e, this.#r, { tag: t ? So.namespace(this.controllerId, t.id) : null }))
		}
		get configureHandler() {
			return this._configureHandler
		}
		set configureHandler(t) {
			t !== this._configureHandler &&
				((this._configureHandler = t), lh(this, this.#e, this.#r, { hasConfigurationHandler: !!t }))
		}
		get onDidChangeDefault() {
			return Ee.chain(this.#n, (t) => t.map((n) => n.get(this.controllerId)?.get(this.profileId)).filter(or))
		}
		dispose() {
			this.#i?.delete(this.profileId) &&
				((this.#i = void 0), this.#e.$removeTestProfile(this.controllerId, this.profileId)),
				(this.#r = void 0)
		}
	}
function o9(o, e) {
	for (let t = 0; t < o.path.length; t++) {
		let n = e.find((r) => r.id === o.path[t])
		if (!n) return
		if (t === o.path.length - 1) return n
		e = n.children
	}
}
var u_e = O("configurationResolverService"),
	ER = ((K) => (
		(K.Unknown = "unknown"),
		(K.Env = "env"),
		(K.Config = "config"),
		(K.Command = "command"),
		(K.Input = "input"),
		(K.ExtensionInstallFolder = "extensionInstallFolder"),
		(K.WorkspaceFolder = "workspaceFolder"),
		(K.Cwd = "cwd"),
		(K.WorkspaceFolderBasename = "workspaceFolderBasename"),
		(K.UserHome = "userHome"),
		(K.LineNumber = "lineNumber"),
		(K.ColumnNumber = "columnNumber"),
		(K.SelectedText = "selectedText"),
		(K.File = "file"),
		(K.FileWorkspaceFolder = "fileWorkspaceFolder"),
		(K.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename"),
		(K.RelativeFile = "relativeFile"),
		(K.RelativeFileDirname = "relativeFileDirname"),
		(K.FileDirname = "fileDirname"),
		(K.FileExtname = "fileExtname"),
		(K.FileBasename = "fileBasename"),
		(K.FileBasenameNoExtension = "fileBasenameNoExtension"),
		(K.FileDirnameBasename = "fileDirnameBasename"),
		(K.ExecPath = "execPath"),
		(K.ExecInstallFolder = "execInstallFolder"),
		(K.PathSeparator = "pathSeparator"),
		(K.PathSeparatorAlias = "/"),
		K
	))(ER || {}),
	J2 = Object.values(ER).filter((o) => typeof o == "string"),
	qn = class extends jn {
		constructor(t, n) {
			super(n)
			this.variable = t
		}
	}
var dh = class o {
	constructor(e) {
		this.locations = new Map()
		typeof e == "string"
			? ((this.stringRoot = !0), (this.root = { value: e }))
			: ((this.stringRoot = !1), (this.root = structuredClone(e)))
	}
	static {
		this.VARIABLE_LHS = "${"
	}
	static parse(e) {
		if (e instanceof o) return e
		let t = new o(e)
		return t.applyPlatformSpecificKeys(), t.parseObject(t.root), t
	}
	applyPlatformSpecificKeys() {
		let e = this.root,
			t = Ie ? "windows" : st ? "osx" : Ve ? "linux" : void 0
		t === void 0 ||
			!e ||
			typeof e != "object" ||
			!e.hasOwnProperty(t) ||
			(Object.keys(e[t]).forEach((n) => (e[n] = e[t][n])), delete e.windows, delete e.osx, delete e.linux)
	}
	parseVariable(e, t) {
		if (e[t] !== "$" || e[t + 1] !== "{") return
		let n = t + 2,
			r = 1
		for (; n < e.length; ) {
			if (e[n] === "{") r++
			else if (e[n] === "}" && (r--, r === 0)) break
			n++
		}
		if (r !== 0) return
		let i = e.slice(t, n + 1),
			s = e.substring(t + 2, n),
			a = s.indexOf(":")
		return a === -1
			? { replacement: { id: i, name: s, inner: s }, end: n }
			: { replacement: { id: i, inner: s, name: s.slice(0, a), arg: s.slice(a + 1) }, end: n }
	}
	parseObject(e) {
		if (!(typeof e != "object" || e === null)) {
			if (Array.isArray(e)) {
				for (let t = 0; t < e.length; t++) {
					let n = e[t]
					typeof n == "string" ? this.parseString(e, t, n) : this.parseObject(n)
				}
				return
			}
			for (let [t, n] of Object.entries(e)) typeof n == "string" ? this.parseString(e, t, n) : this.parseObject(n)
			for (let [t] of Object.entries(e)) this.parseString(e, t, t, !0)
		}
	}
	parseString(e, t, n, r) {
		let i = 0
		for (; i < n.length; ) {
			let s = n.indexOf("${", i)
			if (s === -1) break
			let a = this.parseVariable(n, s)
			if (a) {
				let l = this.locations.get(a.replacement.id) || { locations: [], replacement: a.replacement }
				l.locations.push({ object: e, propertyName: t, replaceKeyName: r }),
					this.locations.set(a.replacement.id, l),
					(i = a.end + 1)
			} else i = s + 2
		}
	}
	unresolved() {
		return Rt.map(
			Rt.filter(this.locations.values(), (e) => e.resolved === void 0),
			(e) => e.replacement,
		)
	}
	resolved() {
		return Rt.map(
			Rt.filter(this.locations.values(), (e) => !!e.resolved),
			(e) => [e.replacement, e.resolved],
		)
	}
	resolve(e, t) {
		typeof t != "object" && (t = { value: String(t) })
		let n = this.locations.get(e.id)
		if (n) {
			if (t.value !== void 0)
				for (let { object: r, propertyName: i, replaceKeyName: s } of n.locations || [])
					if (s && typeof i == "string") {
						let a = r[i],
							l = i.replaceAll(e.id, t.value)
						delete r[i], (r[l] = a)
					} else {
						let a = r[i].replaceAll(e.id, t.value)
						r[i] = a
					}
			n.resolved = t
		}
	}
	toObject() {
		return this.stringRoot ? this.root.value : this.root
	}
}
var hC = class {
	constructor(e, t, n, r) {
		this._contributedVariables = new Map()
		this.resolvableVariables = new Set(J2)
		;(this._context = e),
			(this._labelService = t),
			(this._userHomePromise = n),
			r && (this._envVariablesPromise = r.then((i) => this.prepareEnv(i)))
	}
	prepareEnv(e) {
		if (Ie) {
			let t = Object.create(null)
			return (
				Object.keys(e).forEach((n) => {
					t[n.toLowerCase()] = e[n]
				}),
				t
			)
		}
		return e
	}
	async resolveWithEnvironment(e, t, n) {
		let r = dh.parse(n),
			i = { env: this.prepareEnv(e), userHome: void 0 }
		for (let s of r.unresolved()) {
			let a = await this.evaluateSingleVariable(i, s, t?.uri)
			a !== void 0 && r.resolve(s, String(a))
		}
		return r.toObject()
	}
	async resolveAsync(e, t) {
		let n = dh.parse(t),
			r = { env: await this._envVariablesPromise, userHome: await this._userHomePromise }
		for (let i of n.unresolved()) {
			let s = await this.evaluateSingleVariable(r, i, e?.uri)
			s !== void 0 && n.resolve(i, String(s))
		}
		return n.toObject()
	}
	resolveWithInteractionReplace(e, t) {
		throw new Error("resolveWithInteractionReplace not implemented.")
	}
	resolveWithInteraction(e, t) {
		throw new Error("resolveWithInteraction not implemented.")
	}
	contributeVariable(e, t) {
		if (this._contributedVariables.has(e)) throw new Error("Variable " + e + " is contributed twice.")
		this.resolvableVariables.add(e), this._contributedVariables.set(e, t)
	}
	fsPath(e) {
		return this._labelService ? this._labelService.getUriLabel(e, { noPrefix: !0 }) : e.fsPath
	}
	async evaluateSingleVariable(e, t, n, r) {
		let { name: i, arg: s } = t,
			a = (c) => {
				let u = this._context.getFilePath()
				if (u) return Op(u)
				throw new qn(
					c,
					p("canNotResolveFile", "Variable {0} can not be resolved. Please open an editor.", t.id),
				)
			},
			l = (c) => {
				let u = a(c)
				if (this._context.getWorkspaceFolderPathForFile) {
					let m = this._context.getWorkspaceFolderPathForFile()
					if (m) return Op(m)
				}
				throw new qn(
					c,
					p(
						"canNotResolveFolderForFile",
						"Variable {0}: can not find workspace folder of '{1}'.",
						t.id,
						Ze(u),
					),
				)
			},
			d = (c) => {
				if (s) {
					let u = this._context.getFolderUri(s)
					if (u) return u
					throw new qn(
						c,
						p("canNotFindFolder", "Variable {0} can not be resolved. No such folder '{1}'.", c, s),
					)
				}
				if (n) return n
				throw this._context.getWorkspaceFolderCount() > 1
					? new qn(
							c,
							p(
								"canNotResolveWorkspaceFolderMultiRoot",
								"Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.",
								c,
							),
						)
					: new qn(
							c,
							p(
								"canNotResolveWorkspaceFolder",
								"Variable {0} can not be resolved. Please open a folder.",
								c,
							),
						)
			}
		switch (i) {
			case "env":
				if (s) {
					if (e.env) {
						let c = e.env[Ie ? s.toLowerCase() : s]
						if (we(c)) return c
					}
					return ""
				}
				throw new qn(
					"env",
					p(
						"missingEnvVarName",
						"Variable {0} can not be resolved because no environment variable name is given.",
						t.id,
					),
				)
			case "config":
				if (s) {
					let c = this._context.getConfigurationValue(n, s)
					if (bt(c))
						throw new qn(
							"config",
							p(
								"configNotFound",
								"Variable {0} can not be resolved because setting '{1}' not found.",
								t.id,
								s,
							),
						)
					if (dt(c))
						throw new qn(
							"config",
							p(
								"configNoString",
								"Variable {0} can not be resolved because '{1}' is a structured value.",
								t.id,
								s,
							),
						)
					return c
				}
				throw new qn(
					"config",
					p("missingConfigName", "Variable {0} can not be resolved because no settings name is given.", t.id),
				)
			case "command":
				return this.resolveFromMap("command", t.id, s, r, "command")
			case "input":
				return this.resolveFromMap("input", t.id, s, r, "input")
			case "extensionInstallFolder":
				if (s) {
					let c = await this._context.getExtension(s)
					if (!c)
						throw new qn(
							"extensionInstallFolder",
							p(
								"extensionNotInstalled",
								"Variable {0} can not be resolved because the extension {1} is not installed.",
								t.id,
								s,
							),
						)
					return this.fsPath(c.extensionLocation)
				}
				throw new qn(
					"extensionInstallFolder",
					p(
						"missingExtensionName",
						"Variable {0} can not be resolved because no extension name is given.",
						t.id,
					),
				)
			default:
				switch (i) {
					case "workspaceRoot":
					case "workspaceFolder": {
						let c = d("workspaceFolder")
						return c ? Op(this.fsPath(c)) : void 0
					}
					case "cwd": {
						if (!n && !s) return Lo()
						let c = d("cwd")
						return c ? Op(this.fsPath(c)) : void 0
					}
					case "workspaceRootFolderName":
					case "workspaceFolderBasename": {
						let c = d("workspaceFolderBasename")
						return c ? Op(Ze(this.fsPath(c))) : void 0
					}
					case "userHome":
						if (e.userHome) return e.userHome
						throw new qn(
							"userHome",
							p(
								"canNotResolveUserHome",
								"Variable {0} can not be resolved. UserHome path is not defined",
								t.id,
							),
						)
					case "lineNumber": {
						let c = this._context.getLineNumber()
						if (c) return c
						throw new qn(
							"lineNumber",
							p(
								"canNotResolveLineNumber",
								"Variable {0} can not be resolved. Make sure to have a line selected in the active editor.",
								t.id,
							),
						)
					}
					case "columnNumber": {
						let c = this._context.getColumnNumber()
						if (c) return c
						throw new Error(
							p(
								"canNotResolveColumnNumber",
								"Variable {0} can not be resolved. Make sure to have a column selected in the active editor.",
								t.id,
							),
						)
					}
					case "selectedText": {
						let c = this._context.getSelectedText()
						if (c) return c
						throw new qn(
							"selectedText",
							p(
								"canNotResolveSelectedText",
								"Variable {0} can not be resolved. Make sure to have some text selected in the active editor.",
								t.id,
							),
						)
					}
					case "file":
						return a("file")
					case "fileWorkspaceFolder":
						return l("fileWorkspaceFolder")
					case "fileWorkspaceFolderBasename":
						return Ze(l("fileWorkspaceFolderBasename"))
					case "relativeFile":
						return n || s ? Mo(this.fsPath(d("relativeFile")), a("relativeFile")) : a("relativeFile")
					case "relativeFileDirname": {
						let c = Qt(a("relativeFileDirname"))
						if (n || s) {
							let u = Mo(this.fsPath(d("relativeFileDirname")), c)
							return u.length === 0 ? "." : u
						}
						return c
					}
					case "fileDirname":
						return Qt(a("fileDirname"))
					case "fileExtname":
						return la(a("fileExtname"))
					case "fileBasename":
						return Ze(a("fileBasename"))
					case "fileBasenameNoExtension": {
						let c = Ze(a("fileBasenameNoExtension"))
						return c.slice(0, c.length - la(c).length)
					}
					case "fileDirnameBasename":
						return Ze(Qt(a("fileDirnameBasename")))
					case "execPath": {
						let c = this._context.getExecPath()
						return c || t.id
					}
					case "execInstallFolder": {
						let c = this._context.getAppRoot()
						return c || t.id
					}
					case "pathSeparator":
					case "/":
						return at
					default:
						try {
							return this.resolveFromMap("unknown", t.id, s, r, void 0)
						} catch {
							return t.id
						}
				}
		}
	}
	resolveFromMap(e, t, n, r, i) {
		if (n && r) {
			let s = i === void 0 ? r[n] : r[i + ":" + n]
			if (typeof s == "string") return s
			throw new qn(
				e,
				p("noValueForCommand", "Variable {0} can not be resolved because the command has no value.", t),
			)
		}
		return t
	}
}
var ei = O("IExtHostVariableResolverProvider"),
	wR = class extends hC {
		constructor(e, t, n, r, i, s, a) {
			function l() {
				if (n) {
					let d = n.activeEditor()
					if (d) return d.document.uri
					let c = r.tabGroups.all.find((u) => u.isActive)?.activeTab
					if (c !== void 0) {
						if (c.input instanceof Ps || c.input instanceof Ya) return c.input.modified
						if (c.input instanceof Qa || c.input instanceof Xa || c.input instanceof Ja) return c.input.uri
					}
				}
			}
			super(
				{
					getFolderUri: (d) => {
						let c = s.folders.filter((u) => u.name === d)
						if (c && c.length > 0) return c[0].uri
					},
					getWorkspaceFolderCount: () => s.folders.length,
					getConfigurationValue: (d, c) => i.getConfiguration(void 0, d).get(c),
					getAppRoot: () => Lo(),
					getExecPath: () => Pr.VSCODE_EXEC_PATH,
					getFilePath: () => {
						let d = l()
						if (d) return Gn(d.fsPath)
					},
					getWorkspaceFolderPathForFile: () => {
						if (t) {
							let d = l()
							if (d) {
								let c = t.getWorkspaceFolder(d)
								if (c) return Gn(c.uri.fsPath)
							}
						}
					},
					getSelectedText: () => {
						if (n) {
							let d = n.activeEditor()
							if (d && !d.selection.isEmpty) return d.document.getText(d.selection)
						}
					},
					getLineNumber: () => {
						if (n) {
							let d = n.activeEditor()
							if (d) return String(d.selection.end.line + 1)
						}
					},
					getColumnNumber: () => {
						if (n) {
							let d = n.activeEditor()
							if (d) return String(d.selection.end.character + 1)
						}
					},
					getExtension: (d) => e.getExtension(d),
				},
				void 0,
				a ? Promise.resolve(a) : void 0,
				Promise.resolve(Pr),
			)
		}
	},
	gl = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.extensionService = t
			this.workspaceService = n
			this.editorService = r
			this.configurationService = i
			this.editorTabs = s
			this._resolver = new kt(async () => {
				let t = await this.configurationService.getConfigProvider(),
					r = { folders: (await this.workspaceService.getWorkspaceFolders2()) || [] }
				return (
					this._register(
						this.workspaceService.onDidChangeWorkspace(async (i) => {
							r.folders = (await this.workspaceService.getWorkspaceFolders2()) || []
						}),
					),
					new wR(
						this.extensionService,
						this.workspaceService,
						this.editorService,
						this.editorTabs,
						t,
						r,
						this.homeDir(),
					)
				)
			})
		}
		getResolver() {
			return this._resolver.value
		}
		homeDir() {}
	}
gl = R([S(0, pr), S(1, Sn), S(2, no), S(3, pn), S(4, Zo)], gl)
var em = O("IExtHostDebugService"),
	Wd = class extends $ {
		constructor(t, n, r, i, s, a, l, d) {
			super()
			this._workspaceService = n
			this._extensionService = r
			this._configurationService = i
			this._editorTabs = s
			this._variableResolver = a
			this._commands = l
			this._testing = d
			this._debugSessions = new Map()
			this._debugVisualizationTreeItemIdsCounter = 0
			this._debugVisualizationProviders = new Map()
			this._debugVisualizationTrees = new Map()
			this._debugVisualizationTreeItemIds = new WeakMap()
			this._debugVisualizationElements = new Map()
			this._visualizers = new Map()
			this._visualizerIdCounter = 0
			;(this._configProviderHandleCounter = 0),
				(this._configProviders = []),
				(this._adapterFactoryHandleCounter = 0),
				(this._adapterFactories = []),
				(this._trackerFactoryHandleCounter = 0),
				(this._trackerFactories = []),
				(this._debugAdapters = new Map()),
				(this._debugAdaptersTrackers = new Map()),
				(this._onDidStartDebugSession = this._register(new E())),
				(this._onDidTerminateDebugSession = this._register(new E())),
				(this._onDidChangeActiveDebugSession = this._register(new E())),
				(this._onDidReceiveDebugSessionCustomEvent = this._register(new E())),
				(this._debugServiceProxy = t.getProxy(M.MainThreadDebugService)),
				(this._onDidChangeBreakpoints = this._register(new E())),
				(this._onDidChangeActiveStackItem = this._register(new E())),
				(this._activeDebugConsole = new _R(this._debugServiceProxy)),
				(this._breakpoints = new Map()),
				this._extensionService.getExtensionRegistry().then((c) => {
					this._register(
						c.onDidChange((u) => {
							this.registerAllDebugTypes(c)
						}),
					),
						this.registerAllDebugTypes(c)
				}),
				(this._telemetryProxy = t.getProxy(M.MainThreadTelemetry))
		}
		get onDidStartDebugSession() {
			return this._onDidStartDebugSession.event
		}
		get onDidTerminateDebugSession() {
			return this._onDidTerminateDebugSession.event
		}
		get onDidChangeActiveDebugSession() {
			return this._onDidChangeActiveDebugSession.event
		}
		get activeDebugSession() {
			return this._activeDebugSession?.api
		}
		get onDidReceiveDebugSessionCustomEvent() {
			return this._onDidReceiveDebugSessionCustomEvent.event
		}
		get activeDebugConsole() {
			return this._activeDebugConsole.value
		}
		async $getVisualizerTreeItem(t, n) {
			let r = this.hydrateVisualizationContext(n)
			if (!r) return
			let i = await this._debugVisualizationTrees.get(t)?.getTreeItem?.(r)
			return i ? this.convertVisualizerTreeItem(t, i) : void 0
		}
		registerDebugVisualizationTree(t, n, r) {
			let i = Ce.toKey(t.identifier),
				s = this.extensionVisKey(i, n)
			if (this._debugVisualizationProviders.has(s))
				throw new Error(`A debug visualization provider with id '${n}' is already registered`)
			return (
				this._debugVisualizationTrees.set(s, r),
				this._debugServiceProxy.$registerDebugVisualizerTree(s, !!r.editItem),
				q(() => {
					this._debugServiceProxy.$unregisterDebugVisualizerTree(s), this._debugVisualizationTrees.delete(n)
				})
			)
		}
		async $getVisualizerTreeItemChildren(t, n) {
			let r = this._debugVisualizationElements.get(n)?.item
			return r
				? (await this._debugVisualizationTrees.get(t)?.getChildren?.(r))?.map((s) =>
						this.convertVisualizerTreeItem(t, s),
					) || []
				: []
		}
		async $editVisualizerTreeItem(t, n) {
			let r = this._debugVisualizationElements.get(t)
			if (!r) return
			let i = await this._debugVisualizationTrees.get(r.provider)?.editItem?.(r.item, n)
			return this.convertVisualizerTreeItem(r.provider, i || r.item)
		}
		$disposeVisualizedTree(t) {
			let n = this._debugVisualizationElements.get(t)
			if (!n) return
			let r = [n.children]
			for (let i of r)
				if (i)
					for (let s of i)
						r.push(this._debugVisualizationElements.get(s)?.children),
							this._debugVisualizationElements.delete(s)
		}
		convertVisualizerTreeItem(t, n) {
			let r = this._debugVisualizationTreeItemIds.get(n)
			return (
				r ||
					((r = this._debugVisualizationTreeItemIdsCounter++),
					this._debugVisualizationTreeItemIds.set(n, r),
					this._debugVisualizationElements.set(r, { provider: t, item: n })),
				uk.from(n, r)
			)
		}
		asDebugSourceUri(t, n) {
			let r = t
			if (typeof r.sourceReference == "number" && r.sourceReference > 0) {
				let i = `debug:${encodeURIComponent(r.path || "")}`,
					s = "?"
				return (
					n && ((i += `${s}session=${encodeURIComponent(n.id)}`), (s = "&")),
					(i += `${s}ref=${r.sourceReference}`),
					b.parse(i)
				)
			} else {
				if (r.path) return b.file(r.path)
				throw new Error(
					"cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.",
				)
			}
		}
		registerAllDebugTypes(t) {
			let n = []
			for (let r of t.getAllExtensionDescriptions())
				if (r.contributes) {
					let i = r.contributes.debuggers
					if (i && i.length > 0) for (let s of i) B2(s) && n.push(s.type)
				}
			this._debugServiceProxy.$registerDebugTypes(n)
		}
		get activeStackItem() {
			return this._activeStackItem
		}
		get onDidChangeActiveStackItem() {
			return this._onDidChangeActiveStackItem.event
		}
		get onDidChangeBreakpoints() {
			return this._onDidChangeBreakpoints.event
		}
		get breakpoints() {
			let t = []
			return this._breakpoints.forEach((n) => t.push(n)), t
		}
		async $resolveDebugVisualizer(t, n) {
			let r = this._visualizers.get(t)
			if (!r) throw new Error(`No debug visualizer found with id '${t}'`)
			let { v: i, provider: s, extensionId: a } = r
			if (
				(i.visualization || ((i = (await s.resolveDebugVisualization?.(i, n)) || i), (r.v = i)),
				!i.visualization)
			)
				throw new Error(`No visualization returned from resolveDebugVisualization in '${s}'`)
			return this.serializeVisualization(a, i.visualization)
		}
		async $executeDebugVisualizerCommand(t) {
			let n = this._visualizers.get(t)
			if (!n) throw new Error(`No debug visualizer found with id '${t}'`)
			let r = n.v.visualization
			r && "command" in r && this._commands.executeCommand(r.command, ...(r.arguments || []))
		}
		hydrateVisualizationContext(t) {
			let n = this._debugSessions.get(t.sessionId)
			return (
				n && {
					session: n.api,
					variable: t.variable,
					containerId: t.containerId,
					frameId: t.frameId,
					threadId: t.threadId,
				}
			)
		}
		async $provideDebugVisualizers(t, n, r, i) {
			let s = this.hydrateVisualizationContext(r),
				a = this.extensionVisKey(t, n),
				l = this._debugVisualizationProviders.get(a)
			if (!s || !l) return []
			let d = await l.provideDebugVisualization(s, i)
			return d
				? d.map((c) => {
						let u = ++this._visualizerIdCounter
						this._visualizers.set(u, { v: c, provider: l, extensionId: t })
						let m = c.iconPath ? this.getIconPathOrClass(c.iconPath) : void 0
						return {
							id: u,
							name: c.name,
							iconClass: m?.iconClass,
							iconPath: m?.iconPath,
							visualization: this.serializeVisualization(t, c.visualization),
						}
					})
				: []
		}
		$disposeDebugVisualizers(t) {
			for (let n of t) this._visualizers.delete(n)
		}
		registerDebugVisualizationProvider(t, n, r) {
			if (!t.contributes?.debugVisualizers?.some((a) => a.id === n))
				throw new Error(
					`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${n})`,
				)
			let i = Ce.toKey(t.identifier),
				s = this.extensionVisKey(i, n)
			if (this._debugVisualizationProviders.has(s))
				throw new Error(`A debug visualization provider with id '${n}' is already registered`)
			return (
				this._debugVisualizationProviders.set(s, r),
				this._debugServiceProxy.$registerDebugVisualizer(i, n),
				q(() => {
					this._debugServiceProxy.$unregisterDebugVisualizer(i, n),
						this._debugVisualizationProviders.delete(n)
				})
			)
		}
		addBreakpoints(t) {
			let n = t.filter((s) => {
				let a = s.id
				return this._breakpoints.has(a) ? !1 : (this._breakpoints.set(a, s), !0)
			})
			this.fireBreakpointChanges(n, [], [])
			let r = [],
				i = new Map()
			for (let s of n)
				if (s instanceof jo) {
					let a = i.get(s.location.uri.toString())
					a ||
						((a = { type: "sourceMulti", uri: s.location.uri, lines: [] }),
						i.set(s.location.uri.toString(), a),
						r.push(a)),
						a.lines.push({
							id: s.id,
							enabled: s.enabled,
							condition: s.condition,
							hitCondition: s.hitCondition,
							logMessage: s.logMessage,
							line: s.location.range.start.line,
							character: s.location.range.start.character,
							mode: s.mode,
						})
				} else
					s instanceof Go &&
						r.push({
							type: "function",
							id: s.id,
							enabled: s.enabled,
							hitCondition: s.hitCondition,
							logMessage: s.logMessage,
							condition: s.condition,
							functionName: s.functionName,
							mode: s.mode,
						})
			return this._debugServiceProxy.$registerBreakpoints(r)
		}
		removeBreakpoints(t) {
			let n = t.filter((a) => this._breakpoints.delete(a.id))
			this.fireBreakpointChanges([], n, [])
			let r = n.filter((a) => a instanceof jo).map((a) => a.id),
				i = n.filter((a) => a instanceof Go).map((a) => a.id),
				s = n.filter((a) => a instanceof md).map((a) => a.id)
			return this._debugServiceProxy.$unregisterBreakpoints(r, i, s)
		}
		startDebugging(t, n, r) {
			let i = r.testRun && this._testing.getMetadataForRun(r.testRun)
			return this._debugServiceProxy.$startDebugging(t ? t.uri : void 0, n, {
				parentSessionID: r.parentSession ? r.parentSession.id : void 0,
				lifecycleManagedByParent: r.lifecycleManagedByParent,
				repl: r.consoleMode === 1 ? "mergeWithParent" : "separate",
				noDebug: r.noDebug,
				compact: r.compact,
				suppressSaveBeforeStart: r.suppressSaveBeforeStart,
				testRun: i && { runId: i.runId, taskId: i.taskId },
				suppressDebugStatusbar: r.suppressDebugStatusbar ?? r.debugUI?.simple,
				suppressDebugToolbar: r.suppressDebugToolbar ?? r.debugUI?.simple,
				suppressDebugView: r.suppressDebugView ?? r.debugUI?.simple,
			})
		}
		stopDebugging(t) {
			return this._debugServiceProxy.$stopDebugging(t ? t.id : void 0)
		}
		registerDebugConfigurationProvider(t, n, r) {
			if (!n) return new ye(() => {})
			let i = this._configProviderHandleCounter++
			return (
				this._configProviders.push({ type: t, handle: i, provider: n }),
				this._debugServiceProxy.$registerDebugConfigurationProvider(
					t,
					r,
					!!n.provideDebugConfigurations,
					!!n.resolveDebugConfiguration,
					!!n.resolveDebugConfigurationWithSubstitutedVariables,
					i,
				),
				new ye(() => {
					;(this._configProviders = this._configProviders.filter((s) => s.provider !== n)),
						this._debugServiceProxy.$unregisterDebugConfigurationProvider(i)
				})
			)
		}
		registerDebugAdapterDescriptorFactory(t, n, r) {
			if (!r) return new ye(() => {})
			if (!this.definesDebugType(t, n))
				throw new Error(
					`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${n}' debugger.`,
				)
			if (this.getAdapterDescriptorFactoryByType(n))
				throw new Error("a DebugAdapterDescriptorFactory can only be registered once per a type.")
			let i = this._adapterFactoryHandleCounter++
			return (
				this._adapterFactories.push({ type: n, handle: i, factory: r }),
				this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(n, i),
				new ye(() => {
					;(this._adapterFactories = this._adapterFactories.filter((s) => s.factory !== r)),
						this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(i)
				})
			)
		}
		registerDebugAdapterTrackerFactory(t, n) {
			if (!n) return new ye(() => {})
			let r = this._trackerFactoryHandleCounter++
			return (
				this._trackerFactories.push({ type: t, handle: r, factory: n }),
				new ye(() => {
					this._trackerFactories = this._trackerFactories.filter((i) => i.factory !== n)
				})
			)
		}
		async $runInTerminal(t, n) {
			return Promise.resolve(void 0)
		}
		async $substituteVariables(t, n) {
			let r,
				i = await this.getFolder(t)
			return (
				i &&
					(r = {
						uri: i.uri,
						name: i.name,
						index: i.index,
						toResource: () => {
							throw new Error("Not implemented")
						},
					}),
				(await this._variableResolver.getResolver()).resolveAsync(r, n)
			)
		}
		createDebugAdapter(t, n) {
			if (t instanceof Cs) return new kR(t.implementation)
		}
		createSignService() {}
		async $startDASession(t, n) {
			let r = this,
				i = await this.getSession(n)
			return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(i.type), i).then((s) => {
				if (!s)
					throw new Error(
						`Couldn't find a debug adapter descriptor for debug type '${i.type}' (extension might have failed to activate)`,
					)
				let a = this.createDebugAdapter(s, i)
				if (!a) throw new Error(`Couldn't create a debug adapter for type '${i.type}'.`)
				let l = a
				return (
					this._debugAdapters.set(t, l),
					this.getDebugAdapterTrackers(i).then(
						(d) => (
							d && this._debugAdaptersTrackers.set(t, d),
							l.onMessage(async (c) => {
								if (c.type === "request" && c.command === "handshake") {
									let u = c,
										m = {
											type: "response",
											seq: 0,
											command: u.command,
											request_seq: u.seq,
											success: !0,
										}
									this._signService || (this._signService = this.createSignService())
									try {
										if (this._signService) {
											let f = await this._signService.sign(u.arguments.value)
											;(m.body = { signature: f }), l.sendResponse(m)
										} else throw new Error("no signer")
									} catch (f) {
										;(m.success = !1), (m.message = f.message), l.sendResponse(m)
									}
								} else {
									d && d.onDidSendMessage && d.onDidSendMessage(c)
									try {
										c = K2(c, !0)
									} catch (u) {
										let m = c.type + "_" + (c.command ?? c.event ?? "")
										throw (
											(this._telemetryProxy.$publicLog2("debugProtocolMessageError", {
												type: m,
												from: i.type,
											}),
											u)
										)
									}
									r._debugServiceProxy.$acceptDAMessage(t, c)
								}
							}),
							l.onError((c) => {
								d && d.onError && d.onError(c),
									this._debugServiceProxy.$acceptDAError(t, c.name, c.message, c.stack)
							}),
							l.onExit((c) => {
								d && d.onExit && d.onExit(c ?? void 0, void 0),
									this._debugServiceProxy.$acceptDAExit(t, c ?? void 0, void 0)
							}),
							d && d.onWillStartSession && d.onWillStartSession(),
							l.startSession()
						),
					)
				)
			})
		}
		$sendDAMessage(t, n) {
			n = q2(n, !1)
			let r = this._debugAdaptersTrackers.get(t)
			r && r.onWillReceiveMessage && r.onWillReceiveMessage(n), this._debugAdapters.get(t)?.sendMessage(n)
		}
		$stopDASession(t) {
			let n = this._debugAdaptersTrackers.get(t)
			this._debugAdaptersTrackers.delete(t), n && n.onWillStopSession && n.onWillStopSession()
			let r = this._debugAdapters.get(t)
			return this._debugAdapters.delete(t), r ? r.stopSession() : Promise.resolve(void 0)
		}
		$acceptBreakpointsDelta(t) {
			let n = [],
				r = [],
				i = []
			if (t.added)
				for (let s of t.added) {
					let a = s.id
					if (a && !this._breakpoints.has(a)) {
						let l
						if (s.type === "function")
							l = new Go(s.functionName, s.enabled, s.condition, s.hitCondition, s.logMessage, s.mode)
						else if (s.type === "data")
							l = new md(
								s.label,
								s.dataId,
								s.canPersist,
								s.enabled,
								s.hitCondition,
								s.condition,
								s.logMessage,
								s.mode,
							)
						else {
							let d = b.revive(s.uri)
							l = new jo(
								new rn(d, new Pe(s.line, s.character)),
								s.enabled,
								s.condition,
								s.hitCondition,
								s.logMessage,
								s.mode,
							)
						}
						LF(l, a), this._breakpoints.set(a, l), n.push(l)
					}
				}
			if (t.removed)
				for (let s of t.removed) {
					let a = this._breakpoints.get(s)
					a && (this._breakpoints.delete(s), r.push(a))
				}
			if (t.changed) {
				for (let s of t.changed)
					if (s.id) {
						let a = this._breakpoints.get(s.id)
						if (a) {
							if (a instanceof Go && s.type === "function") {
								let l = a
								;(l.enabled = s.enabled),
									(l.condition = s.condition),
									(l.hitCondition = s.hitCondition),
									(l.logMessage = s.logMessage),
									(l.functionName = s.functionName)
							} else if (a instanceof jo && s.type === "source") {
								let l = a
								;(l.enabled = s.enabled),
									(l.condition = s.condition),
									(l.hitCondition = s.hitCondition),
									(l.logMessage = s.logMessage),
									(l.location = new rn(b.revive(s.uri), new Pe(s.line, s.character)))
							}
							i.push(a)
						}
					}
			}
			this.fireBreakpointChanges(n, r, i)
		}
		async $acceptStackFrameFocus(t) {
			let n
			if (t) {
				let r = await this.getSession(t.sessionId)
				t.kind === "thread" ? (n = new Eu(r.api, t.threadId)) : (n = new Tu(r.api, t.threadId, t.frameId))
			}
			;(this._activeStackItem = n), this._onDidChangeActiveStackItem.fire(this._activeStackItem)
		}
		$provideDebugConfigurations(t, n, r) {
			return Jt(async () => {
				let i = this.getConfigProviderByHandle(t)
				if (!i) throw new Error("no DebugConfigurationProvider found")
				if (!i.provideDebugConfigurations)
					throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations")
				let s = await this.getFolder(n)
				return i.provideDebugConfigurations(s, r)
			}).then((i) => {
				if (!i) throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations")
				return i
			})
		}
		$resolveDebugConfiguration(t, n, r, i) {
			return Jt(async () => {
				let s = this.getConfigProviderByHandle(t)
				if (!s) throw new Error("no DebugConfigurationProvider found")
				if (!s.resolveDebugConfiguration)
					throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration")
				let a = await this.getFolder(n)
				return s.resolveDebugConfiguration(a, r, i)
			})
		}
		$resolveDebugConfigurationWithSubstitutedVariables(t, n, r, i) {
			return Jt(async () => {
				let s = this.getConfigProviderByHandle(t)
				if (!s) throw new Error("no DebugConfigurationProvider found")
				if (!s.resolveDebugConfigurationWithSubstitutedVariables)
					throw new Error(
						"DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables",
					)
				let a = await this.getFolder(n)
				return s.resolveDebugConfigurationWithSubstitutedVariables(a, r, i)
			})
		}
		async $provideDebugAdapter(t, n) {
			let r = this.getAdapterDescriptorFactoryByHandle(t)
			if (!r) return Promise.reject(new Error("no adapter descriptor factory found for handle"))
			let i = await this.getSession(n)
			return this.getAdapterDescriptor(r, i).then((s) => {
				if (!s) throw new Error(`Couldn't find a debug adapter descriptor for debug type '${i.type}'`)
				return this.convertToDto(s)
			})
		}
		async $acceptDebugSessionStarted(t) {
			let n = await this.getSession(t)
			this._onDidStartDebugSession.fire(n.api)
		}
		async $acceptDebugSessionTerminated(t) {
			let n = await this.getSession(t)
			n && (this._onDidTerminateDebugSession.fire(n.api), this._debugSessions.delete(n.id))
		}
		async $acceptDebugSessionActiveChanged(t) {
			;(this._activeDebugSession = t ? await this.getSession(t) : void 0),
				this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api)
		}
		async $acceptDebugSessionNameChanged(t, n) {
			;(await this.getSession(t))?._acceptNameChanged(n)
		}
		async $acceptDebugSessionCustomEvent(t, n) {
			let i = { session: (await this.getSession(t)).api, event: n.event, body: n.body }
			this._onDidReceiveDebugSessionCustomEvent.fire(i)
		}
		convertToDto(t) {
			if (t instanceof Qo) return this.convertExecutableToDto(t)
			if (t instanceof Jo) return this.convertServerToDto(t)
			if (t instanceof wi) return this.convertPipeServerToDto(t)
			if (t instanceof Cs) return this.convertImplementationToDto(t)
			throw new Error("convertToDto unexpected type")
		}
		convertExecutableToDto(t) {
			return { type: "executable", command: t.command, args: t.args, options: t.options }
		}
		convertServerToDto(t) {
			return { type: "server", port: t.port, host: t.host }
		}
		convertPipeServerToDto(t) {
			return { type: "pipeServer", path: t.path }
		}
		convertImplementationToDto(t) {
			return { type: "implementation" }
		}
		getAdapterDescriptorFactoryByType(t) {
			let n = this._adapterFactories.filter((r) => r.type === t)
			if (n.length > 0) return n[0].factory
		}
		getAdapterDescriptorFactoryByHandle(t) {
			let n = this._adapterFactories.filter((r) => r.handle === t)
			if (n.length > 0) return n[0].factory
		}
		getConfigProviderByHandle(t) {
			let n = this._configProviders.filter((r) => r.handle === t)
			if (n.length > 0) return n[0].provider
		}
		definesDebugType(t, n) {
			if (t.contributes) {
				let r = t.contributes.debuggers
				if (r && r.length > 0) {
					for (let i of r) if (i.label && i.type && i.type === n) return !0
				}
			}
			return !1
		}
		getDebugAdapterTrackers(t) {
			let r = t.configuration.type,
				i = this._trackerFactories
					.filter((s) => s.type === r || s.type === "*")
					.map((s) =>
						Jt(() => s.factory.createDebugAdapterTracker(t.api)).then(
							(a) => a,
							(a) => null,
						),
					)
			return Promise.race([
				Promise.all(i).then((s) => {
					let a = Ye(s)
					if (a.length > 0) return new DR(a)
				}),
				new Promise((s) => setTimeout(() => s(void 0), 1e3)),
			]).catch((s) => {})
		}
		async getAdapterDescriptor(t, n) {
			let r = n.configuration.debugServer
			if (typeof r == "number") return Promise.resolve(new Jo(r))
			if (t) {
				let s = await this._extensionService.getExtensionRegistry()
				return Jt(() => t.createDebugAdapterDescriptor(n.api, this.daExecutableFromPackage(n, s))).then((a) => {
					if (a) return a
				})
			}
			let i = await this._extensionService.getExtensionRegistry()
			return Promise.resolve(this.daExecutableFromPackage(n, i))
		}
		daExecutableFromPackage(t, n) {}
		fireBreakpointChanges(t, n, r) {
			;(t.length > 0 || n.length > 0 || r.length > 0) &&
				this._onDidChangeBreakpoints.fire(Object.freeze({ added: t, removed: n, changed: r }))
		}
		async getSession(t) {
			if (t)
				if (typeof t == "string") {
					let n = this._debugSessions.get(t)
					if (n) return n
				} else {
					let n = this._debugSessions.get(t.id)
					if (!n) {
						let r = await this.getFolder(t.folderUri),
							i = t.parent ? this._debugSessions.get(t.parent) : void 0
						;(n = new PR(this._debugServiceProxy, t.id, t.type, t.name, r, t.configuration, i?.api)),
							this._debugSessions.set(n.id, n),
							this._debugServiceProxy.$sessionCached(n.id)
					}
					return n
				}
			throw new Error("cannot find session")
		}
		getFolder(t) {
			if (t) {
				let n = b.revive(t)
				return this._workspaceService.resolveWorkspaceFolder(n)
			}
			return Promise.resolve(void 0)
		}
		extensionVisKey(t, n) {
			return `${t}\0${n}`
		}
		serializeVisualization(t, n) {
			if (n) {
				if ("title" in n && "command" in n) return { type: 0 }
				if ("treeId" in n) return { type: 1, id: `${t}\0${n.treeId}` }
				throw new Error("Unsupported debug visualization type")
			}
		}
		getIconPathOrClass(t) {
			let n = this.getIconUris(t),
				r,
				i
			return "id" in n ? (i = Yt.asClassName(n)) : (r = n), { iconPath: r, iconClass: i }
		}
		getIconUris(t) {
			if (t instanceof Vt) return { id: t.id }
			let n = typeof t == "object" && "dark" in t ? t.dark : t,
				r = typeof t == "object" && "light" in t ? t.light : t
			return { dark: typeof n == "string" ? b.file(n) : n, light: typeof r == "string" ? b.file(r) : r }
		}
	}
Wd = R([S(0, ie), S(1, Sn), S(2, pr), S(3, pn), S(4, Zo), S(5, ei), S(6, Tn), S(7, js)], Wd)
var PR = class {
		constructor(e, t, n, r, i, s, a) {
			this._debugServiceProxy = e
			this._id = t
			this._type = n
			this._name = r
			this._workspaceFolder = i
			this._configuration = s
			this._parentSession = a
		}
		get api() {
			let e = this
			return (this.apiSession ??= Object.freeze({
				id: e._id,
				type: e._type,
				get name() {
					return e._name
				},
				set name(t) {
					;(e._name = t), e._debugServiceProxy.$setDebugSessionName(e._id, t)
				},
				parentSession: e._parentSession,
				workspaceFolder: e._workspaceFolder,
				configuration: e._configuration,
				customRequest(t, n) {
					return e._debugServiceProxy.$customDebugAdapterRequest(e._id, t, n)
				},
				getDebugProtocolBreakpoint(t) {
					return e._debugServiceProxy.$getDebugProtocolBreakpoint(e._id, t.id)
				},
			}))
		}
		get id() {
			return this._id
		}
		get type() {
			return this._type
		}
		_acceptNameChanged(e) {
			this._name = e
		}
		get configuration() {
			return this._configuration
		}
	},
	_R = class {
		constructor(e) {
			this.value = Object.freeze({
				append(t) {
					e.$appendDebugConsole(t)
				},
				appendLine(t) {
					this.append(
						t +
							`
`,
					)
				},
			})
		}
	},
	DR = class {
		constructor(e) {
			this.trackers = e
		}
		onWillStartSession() {
			this.trackers.forEach((e) => (e.onWillStartSession ? e.onWillStartSession() : void 0))
		}
		onWillReceiveMessage(e) {
			this.trackers.forEach((t) => (t.onWillReceiveMessage ? t.onWillReceiveMessage(e) : void 0))
		}
		onDidSendMessage(e) {
			this.trackers.forEach((t) => (t.onDidSendMessage ? t.onDidSendMessage(e) : void 0))
		}
		onWillStopSession() {
			this.trackers.forEach((e) => (e.onWillStopSession ? e.onWillStopSession() : void 0))
		}
		onError(e) {
			this.trackers.forEach((t) => (t.onError ? t.onError(e) : void 0))
		}
		onExit(e, t) {
			this.trackers.forEach((n) => (n.onExit ? n.onExit(e, t) : void 0))
		}
	},
	kR = class extends Jp {
		constructor(t) {
			super()
			this.implementation = t
			t.onDidSendMessage((n) => {
				this.acceptMessage(n)
			})
		}
		startSession() {
			return Promise.resolve(void 0)
		}
		sendMessage(t) {
			this.implementation.handleMessage(t)
		}
		stopSession() {
			return this.implementation.dispose(), Promise.resolve(void 0)
		}
	},
	Zp = class extends Wd {
		constructor(e, t, n, r, i, s, a, l) {
			super(e, t, n, r, i, s, a, l)
		}
	}
Zp = R([S(0, ie), S(1, Sn), S(2, pr), S(3, pn), S(4, Zo), S(5, ei), S(6, Tn), S(7, js)], Zp)
function i9(o) {
	return "uri" in o && "ranges" in o && "preview" in o
}
function s9(o) {
	return o.folderOptions.map((e) => ({
		folder: e.folder,
		excludes: e.excludes.map((t) => (typeof t == "string" ? t : t.pattern)),
		includes: e.includes,
		useGlobalIgnoreFiles: e.useIgnoreFiles.global,
		useIgnoreFiles: e.useIgnoreFiles.local,
		useParentIgnoreFiles: e.useIgnoreFiles.parent,
		followSymlinks: e.followSymlinks,
		maxResults: o.maxResults,
		session: o.session,
	}))
}
var tm = class {
	constructor(e) {
		this.provider = e
	}
	provideFileSearchResults(e, t, n) {
		return (async () => {
			let i = s9(t)
			return Promise.all(i.map((s) => this.provider.provideFileSearchResults({ pattern: e }, s, n)))
		})().then((i) => Ye(i).flat())
	}
}
function a9(o) {
	return o.folderOptions.map((e) => ({
		folder: e.folder,
		excludes: e.excludes.map((t) => (typeof t == "string" ? t : t.pattern)),
		includes: e.includes,
		useGlobalIgnoreFiles: e.useIgnoreFiles.global,
		useIgnoreFiles: e.useIgnoreFiles.local,
		useParentIgnoreFiles: e.useIgnoreFiles.parent,
		followSymlinks: e.followSymlinks,
		maxResults: o.maxResults,
		previewOptions: RR(o.previewOptions),
		maxFileSize: o.maxFileSize,
		encoding: e.encoding,
		afterContext: o.surroundingContext,
		beforeContext: o.surroundingContext,
	}))
}
function RR(o) {
	return { matchLines: o?.matchLines ?? $g.matchLines, charsPerLine: o?.charsPerLine ?? $g.charsPerLine }
}
function l9(o) {
	if (i9(o)) {
		let e = an(o.ranges).map((t, n) => {
			let i = an(o.preview.matches)[n]
			return { sourceRange: t, previewRange: i }
		})
		return new ur(o.uri, e, o.preview.text)
	} else return new Li(o.uri, o.text, o.lineNumber)
}
var vC = class {
	constructor(e) {
		this.provider = e
	}
	provideTextSearchResults(e, t, n, r) {
		let i = (l) => {
			d9(l) && n.report(l9(l))
		}
		return (async () =>
			Ye(
				await Promise.all(
					a9(t).map((l) => this.provider.provideTextSearchResults(e, l, { report: (d) => i(d) }, r)),
				),
			).reduce((l, d) => ({ limitHit: l.limitHit || d.limitHit }), { limitHit: !1 }))().then((l) => ({
			limitHit: l.limitHit,
			message: Ye(an(l.message)),
		}))
	}
}
function d9(o) {
	if (c9(o)) {
		if (Array.isArray(o.ranges)) {
			if (!Array.isArray(o.preview.matches))
				return (
					console.warn(
						"INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.",
					),
					!1
				)
			if (o.preview.matches.length !== o.ranges.length)
				return (
					console.warn(
						"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
					),
					!1
				)
		} else if (Array.isArray(o.preview.matches))
			return (
				console.warn(
					"INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
				),
				!1
			)
	}
	return !0
}
function c9(o) {
	return !!o.preview
}
var nm = class extends vr {
	constructor(e, t, n = () => !1) {
		let r = new Bf(n, () => !1)
		super(r)
		let i = new ft()
		e.forEach((s, a) => {
			let l = s.folder.with({ query: "", fragment: "" })
			i.has(l) ? i.get(l).push({ fq: s, i: a }) : i.set(l, [{ fq: s, i: a }])
		}),
			i.forEach((s, a) => {
				let l = new Map()
				for (let d of s) {
					let c = t(d.fq, d.i)
					l.set(this.encodeKey(d.fq.folder), c)
				}
				super.set(a, l)
			})
	}
	findQueryFragmentAwareSubstr(e) {
		let t = super.findSubstr(e.with({ query: "", fragment: "" }))
		if (!t) return
		let n = this.encodeKey(e)
		return t.get(n)
	}
	forEachFolderQueryInfo(e) {
		return this.forEach((t) => t.forEach((n) => e(n)))
	}
	encodeKey(e) {
		let t = ""
		return e.query && (t += e.query), e.fragment && (t += "#" + e.fragment), t
	}
}
var AR = class {
		constructor(e, t, n) {
			this.config = e
			this.provider = t
			this.sessionLifecycle = n
			this.isLimitHit = !1
			this.resultCount = 0
			this.isCanceled = !1
			;(this.filePattern = e.filePattern),
				(this.includePattern = e.includePattern && Yn(e.includePattern)),
				(this.maxResults = e.maxResults || void 0),
				(this.exists = e.exists),
				(this.activeCancellationTokens = new Set()),
				(this.globalExcludePattern = e.excludePattern && Yn(e.excludePattern))
		}
		cancel() {
			;(this.isCanceled = !0),
				this.activeCancellationTokens.forEach((e) => e.cancel()),
				(this.activeCancellationTokens = new Set())
		}
		search(e) {
			let t = this.config.folderQueries || []
			return new Promise((n, r) => {
				let i = (s) => {
					this.resultCount++, e(s)
				}
				if (this.isCanceled) return n({ limitHit: this.isLimitHit })
				this.config.extraFileResources &&
					this.config.extraFileResources.forEach((s) => {
						let a = s.toString(),
							l = Ze(a)
						;(this.globalExcludePattern && this.globalExcludePattern(a, l)) ||
							this.matchFile(i, { base: s, basename: l })
					}),
					this.doSearch(t, i).then(
						(s) => {
							n({ limitHit: this.isLimitHit, stats: s || void 0 })
						},
						(s) => {
							r(new Error(Xn(s)))
						},
					)
			})
		}
		async doSearch(e, t) {
			let n = new _e(),
				r = e.map((c) => this.getSearchOptionsForFolder(c)),
				i = this.provider instanceof tm ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj,
				s = { folderOptions: r, maxResults: this.config.maxResults ?? ol, session: i },
				a = (c) => {
					let u = new ap(this.config, c),
						m = !u.hasSiblingExcludeClauses()
					return { queryTester: u, noSiblingsClauses: m, folder: c.folder, tree: this.initDirectoryTree() }
				},
				l = new nm(e, a),
				d
			try {
				this.activeCancellationTokens.add(n), (d = zt.create())
				let c = await this.provider.provideFileSearchResults(this.config.filePattern || "", s, n.token),
					u = d.elapsed(),
					m = zt.create()
				return (this.isCanceled && !this.isLimitHit) ||
					(c &&
						c.forEach((f) => {
							let h = l.findQueryFragmentAwareSubstr(f),
								g = Ue.relative(h.folder.path, f.path)
							if (h.noSiblingsClauses) {
								let I = Ze(f.path)
								this.matchFile(t, { base: h.folder, relativePath: g, basename: I })
								return
							}
							this.addDirectoryEntries(h.tree, h.folder, g, t)
						}),
					this.isCanceled && !this.isLimitHit)
					? null
					: (l.forEachFolderQueryInfo((f) => {
							this.matchDirectoryTree(f.tree, f.queryTester, t)
						}),
						{ providerTime: u, postProcessTime: m.elapsed() })
			} finally {
				n.dispose(), this.activeCancellationTokens.delete(n)
			}
		}
		getSearchOptionsForFolder(e) {
			let t = il(this.config.includePattern, e.includePattern),
				n = e.excludePattern?.map((i) => ({
					folder: i.folder,
					patterns: il(this.config.excludePattern, i.pattern),
				}))
			n?.length || (n = [{ folder: void 0, patterns: il(this.config.excludePattern, void 0) }])
			let r = Ax(n)
			return {
				folder: e.folder,
				excludes: r,
				includes: t,
				useIgnoreFiles: {
					local: !e.disregardIgnoreFiles,
					parent: !e.disregardParentIgnoreFiles,
					global: !e.disregardGlobalIgnoreFiles,
				},
				followSymlinks: !e.ignoreSymlinks,
			}
		}
		initDirectoryTree() {
			let e = { rootEntries: [], pathToEntries: Object.create(null) }
			return (e.pathToEntries["."] = e.rootEntries), e
		}
		addDirectoryEntries({ pathToEntries: e }, t, n, r) {
			if (n === this.filePattern) {
				let s = Ze(this.filePattern)
				this.matchFile(r, { base: t, relativePath: this.filePattern, basename: s })
			}
			function i(s) {
				let a = Ze(s),
					l = Qt(s),
					d = e[l]
				d || ((d = e[l] = []), i(l)), d.push({ base: t, relativePath: s, basename: a })
			}
			i(n)
		}
		matchDirectoryTree({ rootEntries: e, pathToEntries: t }, n, r) {
			let i = this,
				s = this.filePattern
			function a(l) {
				let d = Bg(() => l.map((c) => c.basename))
				for (let c = 0, u = l.length; c < u; c++) {
					let m = l[c],
						{ relativePath: f, basename: h } = m
					if (n.matchesExcludesSync(f, h, s !== h ? d : void 0)) continue
					let g = t[f]
					if (g) a(g)
					else {
						if (f === s) continue
						i.matchFile(r, m)
					}
					if (i.isLimitHit) break
				}
			}
			a(e)
		}
		matchFile(e, t) {
			;(!this.includePattern || (t.relativePath && this.includePattern(t.relativePath, t.basename))) &&
				((this.exists || (this.maxResults && this.resultCount >= this.maxResults)) &&
					((this.isLimitHit = !0), this.cancel()),
				this.isLimitHit || e(t))
		}
	},
	OR = class {
		constructor() {
			;(this._obj = new Object()), (this.tokenSource = new _e())
		}
		get obj() {
			if (this._obj) return this._obj
			throw new Error("Session object has been dereferenced.")
		}
		cancel() {
			this.tokenSource.cancel(), (this._obj = void 0)
		}
	},
	bC = class o {
		constructor() {
			this.sessions = new Map()
		}
		static {
			this.BATCH_SIZE = 512
		}
		fileSearch(e, t, n, r) {
			let i = this.getSessionTokenSource(e.cacheKey),
				s = new AR(e, t, i),
				a = 0,
				l = (d) => {
					;(a += d.length), n(d.map((c) => this.rawMatchToSearchItem(c)))
				}
			return this.doSearch(s, o.BATCH_SIZE, l, r).then((d) => ({
				limitHit: d.limitHit,
				stats: d.stats
					? { fromCache: !1, type: "fileSearchProvider", resultCount: a, detailStats: d.stats }
					: void 0,
				messages: [],
			}))
		}
		clearCache(e) {
			this.sessions.get(e)?.cancel(), this.sessions.delete(e)
		}
		getSessionTokenSource(e) {
			if (e) return this.sessions.has(e) || this.sessions.set(e, new OR()), this.sessions.get(e)
		}
		rawMatchToSearchItem(e) {
			return e.relativePath ? { resource: ct(e.base, e.relativePath) } : { resource: e.base }
		}
		doSearch(e, t, n, r) {
			let i = r.onCancellationRequested(() => {
					e.cancel()
				}),
				s = (l) => {
					l && (a.push(l), t > 0 && a.length >= t && (n(a), (a = [])))
				},
				a = []
			return e.search(s).then(
				(l) => (a.length && n(a), i.dispose(), l),
				(l) => (a.length && n(a), i.dispose(), Promise.reject(l)),
			)
		}
	}
var Vd = class {
	constructor(e, t, n) {
		this.queryProviderPair = e
		this.fileUtils = t
		this.processType = n
		this.collector = null
		this.isLimitHit = !1
		this.resultCount = 0
	}
	get query() {
		return this.queryProviderPair.query
	}
	search(e, t) {
		let n = this.query.folderQueries || [],
			r = new _e(t)
		return new Promise((i, s) => {
			this.collector = new LR(e)
			let a = !1,
				l = (d, c) => {
					if (!a && !this.isLimitHit) {
						let u = this.resultSize(d)
						d instanceof ur &&
							typeof this.query.maxResults == "number" &&
							this.resultCount + u > this.query.maxResults &&
							((this.isLimitHit = !0),
							(a = !0),
							r.cancel(),
							(d = this.trimResultToSize(d, this.query.maxResults - this.resultCount)))
						let m = this.resultSize(d)
						this.resultCount += m
						let f = d instanceof ur
						;(m > 0 || !f) && this.collector.add(d, c)
					}
				}
			this.doSearch(n, l, r.token).then(
				(d) => {
					r.dispose(),
						this.collector.flush(),
						i({
							limitHit: this.isLimitHit || d?.limitHit,
							messages: this.getMessagesFromResults(d),
							stats: { type: this.processType },
						})
				},
				(d) => {
					r.dispose()
					let c = Xn(d)
					s(new Error(c))
				},
			)
		})
	}
	getMessagesFromResults(e) {
		return e?.message ? (Array.isArray(e.message) ? e.message : [e.message]) : []
	}
	resultSize(e) {
		return e instanceof ur ? (Array.isArray(e.ranges) ? e.ranges.length : 1) : 0
	}
	trimResultToSize(e, t) {
		return new ur(e.uri, e.ranges.slice(0, t), e.previewText)
	}
	async doSearch(e, t, n) {
		let r = new nm(
				e,
				(c, u) => ({ queryTester: new ap(this.query, c), folder: c.folder, folderIdx: u }),
				() => !0,
			),
			i = [],
			s = {
				report: (c) => {
					if (c.uri === void 0)
						throw Error("Text search result URI is undefined. Please check provider implementation.")
					let u = r.findQueryFragmentAwareSubstr(c.uri),
						m = u.folder.scheme === W.file ? KF(() => this.fileUtils.readdir(ts(c.uri))) : void 0,
						f = xf(u.folder, c.uri)
					if (f) {
						let h = u.queryTester.includedInQuery(f, Ze(f), m)
						ao(h)
							? i.push(
									h.then((g) => {
										g && t(c, u.folderIdx)
									}),
								)
							: h && t(c, u.folderIdx)
					}
				},
			},
			l = {
				folderOptions: e.map((c) => this.getSearchOptionsForFolder(c)),
				maxFileSize: this.query.maxFileSize,
				maxResults: this.query.maxResults ?? ol,
				previewOptions: this.query.previewOptions ?? $g,
				surroundingContext: this.query.surroundingContext ?? 0,
			}
		"usePCRE2" in this.query && (l.usePCRE2 = this.query.usePCRE2)
		let d
		return (
			this.queryProviderPair.query.type === 3
				? (d = await this.queryProviderPair.provider.provideAITextSearchResults(
						this.queryProviderPair.query.contentPattern,
						l,
						s,
						n,
					))
				: (d = await this.queryProviderPair.provider.provideTextSearchResults(
						u9(this.queryProviderPair.query.contentPattern),
						l,
						s,
						n,
					)),
			i.length && (await Promise.all(i)),
			d
		)
	}
	getSearchOptionsForFolder(e) {
		let t = il(this.query.includePattern, e.includePattern),
			n = e.excludePattern?.map((s) => ({ folder: s.folder, patterns: il(this.query.excludePattern, s.pattern) }))
		;(!n || n.length === 0) && (n = [{ folder: void 0, patterns: il(this.query.excludePattern, void 0) }])
		let r = Ax(n)
		return {
			folder: b.from(e.folder),
			excludes: r,
			includes: t,
			useIgnoreFiles: {
				local: !e.disregardIgnoreFiles,
				parent: !e.disregardParentIgnoreFiles,
				global: !e.disregardGlobalIgnoreFiles,
			},
			followSymlinks: !e.ignoreSymlinks,
			encoding: (e.fileEncoding && this.fileUtils.toCanonicalName(e.fileEncoding)) ?? "",
		}
	}
}
function u9(o) {
	return {
		isCaseSensitive: o.isCaseSensitive || !1,
		isRegExp: o.isRegExp || !1,
		isWordMatch: o.isWordMatch || !1,
		isMultiline: o.isMultiline || !1,
		pattern: o.pattern,
	}
}
var LR = class {
	constructor(e) {
		this._onResult = e
		this._currentFolderIdx = -1
		this._currentFileMatch = null
		this._batchedCollector = new MR(512, (t) => this.sendItems(t))
	}
	add(e, t) {
		this._currentFileMatch &&
			(this._currentFolderIdx !== t || !jr(this._currentUri, e.uri)) &&
			(this.pushToCollector(), (this._currentFileMatch = null)),
			this._currentFileMatch ||
				((this._currentFolderIdx = t), (this._currentFileMatch = { resource: e.uri, results: [] })),
			this._currentFileMatch.results.push(p9(e))
	}
	pushToCollector() {
		let e = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0
		this._batchedCollector.addItem(this._currentFileMatch, e)
	}
	flush() {
		this.pushToCollector(), this._batchedCollector.flush()
	}
	sendItems(e) {
		this._onResult(e)
	}
}
function p9(o) {
	return o instanceof ur
		? {
				previewText: o.previewText,
				rangeLocations: o.ranges.map((e) => ({
					preview: {
						startLineNumber: e.previewRange.start.line,
						startColumn: e.previewRange.start.character,
						endLineNumber: e.previewRange.end.line,
						endColumn: e.previewRange.end.character,
					},
					source: {
						startLineNumber: e.sourceRange.start.line,
						startColumn: e.sourceRange.start.character,
						endLineNumber: e.sourceRange.end.line,
						endColumn: e.sourceRange.end.character,
					},
				})),
			}
		: { text: o.text, lineNumber: o.lineNumber }
}
var MR = class o {
	constructor(e, t) {
		this.maxBatchSize = e
		this.cb = t
		this.totalNumberCompleted = 0
		this.batch = []
		this.batchSize = 0
	}
	static {
		this.TIMEOUT = 4e3
	}
	static {
		this.START_BATCH_AFTER_COUNT = 50
	}
	addItem(e, t) {
		e && this.addItemToBatch(e, t)
	}
	addItems(e, t) {
		e && this.addItemsToBatch(e, t)
	}
	addItemToBatch(e, t) {
		this.batch.push(e), (this.batchSize += t), this.onUpdate()
	}
	addItemsToBatch(e, t) {
		;(this.batch = this.batch.concat(e)), (this.batchSize += t), this.onUpdate()
	}
	onUpdate() {
		this.totalNumberCompleted < o.START_BATCH_AFTER_COUNT
			? this.flush()
			: this.batchSize >= this.maxBatchSize
				? this.flush()
				: this.timeoutHandle ||
					(this.timeoutHandle = setTimeout(() => {
						this.flush()
					}, o.TIMEOUT))
	}
	flush() {
		this.batchSize &&
			((this.totalNumberCompleted += this.batchSize),
			this.cb(this.batch),
			(this.batch = []),
			(this.batchSize = 0),
			this.timeoutHandle && (clearTimeout(this.timeoutHandle), (this.timeoutHandle = 0)))
	}
}
var rm = O("IExtHostSearch"),
	hl = class {
		constructor(e, t, n) {
			this.extHostRpc = e
			this._uriTransformer = t
			this._logService = n
			this._proxy = this.extHostRpc.getProxy(M.MainThreadSearch)
			this._handlePool = 0
			this._textSearchProvider = new Map()
			this._textSearchUsedSchemes = new Set()
			this._aiTextSearchProvider = new Map()
			this._aiTextSearchUsedSchemes = new Set()
			this._fileSearchProvider = new Map()
			this._fileSearchUsedSchemes = new Set()
			this._fileSearchManager = new bC()
		}
		_transformScheme(e) {
			return this._uriTransformer.transformOutgoingScheme(e)
		}
		registerTextSearchProviderOld(e, t) {
			if (this._textSearchUsedSchemes.has(e))
				throw new Error(`a text search provider for the scheme '${e}' is already registered`)
			this._textSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._textSearchProvider.set(n, new vC(t)),
				this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._textSearchUsedSchemes.delete(e),
						this._textSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerTextSearchProvider(e, t) {
			if (this._textSearchUsedSchemes.has(e))
				throw new Error(`a text search provider for the scheme '${e}' is already registered`)
			this._textSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._textSearchProvider.set(n, t),
				this._proxy.$registerTextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._textSearchUsedSchemes.delete(e),
						this._textSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerAITextSearchProvider(e, t) {
			if (this._aiTextSearchUsedSchemes.has(e))
				throw new Error(`an AI text search provider for the scheme '${e}'is already registered`)
			this._aiTextSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._aiTextSearchProvider.set(n, t),
				this._proxy.$registerAITextSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._aiTextSearchUsedSchemes.delete(e),
						this._aiTextSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerFileSearchProviderOld(e, t) {
			if (this._fileSearchUsedSchemes.has(e))
				throw new Error(`a file search provider for the scheme '${e}' is already registered`)
			this._fileSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._fileSearchProvider.set(n, new tm(t)),
				this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._fileSearchUsedSchemes.delete(e),
						this._fileSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		registerFileSearchProvider(e, t) {
			if (this._fileSearchUsedSchemes.has(e))
				throw new Error(`a file search provider for the scheme '${e}' is already registered`)
			this._fileSearchUsedSchemes.add(e)
			let n = this._handlePool++
			return (
				this._fileSearchProvider.set(n, t),
				this._proxy.$registerFileSearchProvider(n, this._transformScheme(e)),
				q(() => {
					this._fileSearchUsedSchemes.delete(e),
						this._fileSearchProvider.delete(n),
						this._proxy.$unregisterProvider(n)
				})
			)
		}
		$provideFileSearchResults(e, t, n, r) {
			let i = ch(n),
				s = this._fileSearchProvider.get(e)
			if (s)
				return this._fileSearchManager.fileSearch(
					i,
					s,
					(a) => {
						this._proxy.$handleFileMatch(
							e,
							t,
							a.map((l) => l.resource),
						)
					},
					r,
				)
			throw new Error("unknown provider: " + e)
		}
		async doInternalFileSearchWithCustomCallback(e, t, n) {
			return { messages: [] }
		}
		$clearCache(e) {
			return this._fileSearchManager.clearCache(e), Promise.resolve(void 0)
		}
		$provideTextSearchResults(e, t, n, r) {
			let i = this._textSearchProvider.get(e)
			if (!i || !i.provideTextSearchResults) throw new Error(`Unknown Text Search Provider ${e}`)
			let s = ch(n)
			return this.createTextSearchManager(s, i).search((l) => this._proxy.$handleTextMatch(e, t, l), r)
		}
		$provideAITextSearchResults(e, t, n, r) {
			let i = this._aiTextSearchProvider.get(e)
			if (!i || !i.provideAITextSearchResults) throw new Error(`Unknown AI Text Search Provider ${e}`)
			let s = ch(n)
			return this.createAITextSearchManager(s, i).search((l) => this._proxy.$handleTextMatch(e, t, l), r)
		}
		$enableExtensionHostSearch() {}
		async $getAIName(e) {
			let t = this._aiTextSearchProvider.get(e)
			if (!(!t || !t.provideAITextSearchResults)) return t.name ?? "AI"
		}
		createTextSearchManager(e, t) {
			return new Vd(
				{ query: e, provider: t },
				{ readdir: (n) => Promise.resolve([]), toCanonicalName: (n) => n },
				"textSearchProvider",
			)
		}
		createAITextSearchManager(e, t) {
			return new Vd(
				{ query: e, provider: t },
				{ readdir: (n) => Promise.resolve([]), toCanonicalName: (n) => n },
				"aiTextSearchProvider",
			)
		}
	}
hl = R([S(0, ie), S(1, fi), S(2, te)], hl)
function ch(o) {
	return {
		...o,
		folderQueries: o.folderQueries && o.folderQueries.map(m9),
		extraFileResources: o.extraFileResources && o.extraFileResources.map((e) => b.revive(e)),
	}
}
function m9(o) {
	return ut(o)
}
var vl = class {
	constructor(e, t) {
		this._onDidChangeWindowState = new E()
		this.onDidChangeWindowState = this._onDidChangeWindowState.event
		this._state = vl.InitialState
		e.handle && (this._nativeHandle = Ic(e.handle).buffer),
			(this._proxy = t.getProxy(M.MainThreadWindow)),
			this._proxy.$getInitialState().then(({ isFocused: n, isActive: r }) => {
				this.onDidChangeWindowProperty("focused", n), this.onDidChangeWindowProperty("active", r)
			})
	}
	static {
		this.InitialState = { focused: !0, active: !0 }
	}
	getState() {
		let e = this._state
		return {
			get focused() {
				return e.focused
			},
			get active() {
				return e.active
			},
		}
	}
	get nativeHandle() {
		return this._nativeHandle
	}
	$onDidChangeActiveNativeWindowHandle(e) {
		this._nativeHandle = e ? Ic(e).buffer : void 0
	}
	$onDidChangeWindowFocus(e) {
		this.onDidChangeWindowProperty("focused", e)
	}
	$onDidChangeWindowActive(e) {
		this.onDidChangeWindowProperty("active", e)
	}
	onDidChangeWindowProperty(e, t) {
		t !== this._state[e] &&
			((this._state = { ...this._state, [e]: t }), this._onDidChangeWindowState.fire(this._state))
	}
	openUri(e, t) {
		let n
		if (typeof e == "string") {
			n = e
			try {
				e = b.parse(e)
			} catch {
				return Promise.reject(`Invalid uri - '${e}'`)
			}
		}
		return Yi(e.scheme)
			? Promise.reject("Invalid scheme - cannot be empty")
			: e.scheme === W.command
				? Promise.reject(`Invalid scheme '${e.scheme}'`)
				: this._proxy.$openUri(e, n, t)
	}
	async asExternalUri(e, t) {
		if (Yi(e.scheme)) return Promise.reject("Invalid scheme - cannot be empty")
		let n = await this._proxy.$asExternalUri(e, t)
		return b.from(n)
	}
}
vl = R([S(0, Xe), S(1, ie)], vl)
var yC = O("IExtHostWindow")
var bl = class extends hb {
	constructor(e, t) {
		super(
			t.logLevel,
			t.logsLocation,
			t.loggers.map((n) => ut(n)),
		),
			(this._proxy = e.getProxy(M.MainThreadLogger))
	}
	$setLogLevel(e, t) {
		t ? this.setLogLevel(b.revive(t), e) : this.setLogLevel(e)
	}
	setVisibility(e, t) {
		super.setVisibility(e, t), this._proxy.$setVisibility(e, t)
	}
	doCreateLogger(e, t, n) {
		return new FR(this._proxy, e, t, n)
	}
}
bl = R([S(0, ie), S(1, Xe)], bl)
var FR = class extends ga {
	constructor(t, n, r, i) {
		super(i?.logLevel === "always")
		this.proxy = t
		this.file = n
		this.isLoggerCreated = !1
		this.buffer = []
		this.setLevel(r),
			this.proxy.$createLogger(n, i).then(() => {
				this.doLog(this.buffer), (this.isLoggerCreated = !0)
			})
	}
	log(t, n) {
		let r = [[t, n]]
		this.isLoggerCreated ? this.doLog(r) : this.buffer.push(...r)
	}
	doLog(t) {
		this.proxy.$log(this.file, t)
	}
	flush() {
		this.proxy.$flush(this.file)
	}
}
var im = O("IExtHostTerminalShellIntegration"),
	om = class extends $ {
		constructor(t, n) {
			super()
			this._extHostTerminalService = n
			this._activeShellIntegrations = new Map()
			this._onDidChangeTerminalShellIntegration = new E()
			this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event
			this._onDidStartTerminalShellExecution = new E()
			this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event
			this._onDidEndTerminalShellExecution = new E()
			this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event
			;(this._proxy = t.getProxy(M.MainThreadTerminalShellIntegration)),
				this._register(
					q(() => {
						for (let [r, i] of this._activeShellIntegrations) i.dispose()
						this._activeShellIntegrations.clear()
					}),
				)
		}
		$shellIntegrationChange(t) {
			let n = this._extHostTerminalService.getTerminalById(t)
			if (!n) return
			let r = n.value,
				i = this._activeShellIntegrations.get(t)
			i ||
				((i = new NR(n.value, this._onDidStartTerminalShellExecution)),
				this._activeShellIntegrations.set(t, i),
				i.store.add(n.onWillDispose(() => this._activeShellIntegrations.get(t)?.dispose())),
				i.store.add(i.onDidRequestShellExecution((s) => this._proxy.$executeCommand(t, s))),
				i.store.add(i.onDidRequestEndExecution((s) => this._onDidEndTerminalShellExecution.fire(s))),
				i.store.add(
					i.onDidRequestChangeShellIntegration((s) => this._onDidChangeTerminalShellIntegration.fire(s)),
				),
				(n.shellIntegration = i.value)),
				this._onDidChangeTerminalShellIntegration.fire({ terminal: r, shellIntegration: i.value })
		}
		$shellExecutionStart(t, n, r, i, s) {
			this._activeShellIntegrations.has(t) || this.$shellIntegrationChange(t)
			let a = { value: n, confidence: r, isTrusted: i }
			this._activeShellIntegrations.get(t)?.startShellExecution(a, b.revive(s))
		}
		$shellExecutionEnd(t, n, r, i, s) {
			let a = { value: n, confidence: r, isTrusted: i }
			this._activeShellIntegrations.get(t)?.endShellExecution(a, s)
		}
		$shellExecutionData(t, n) {
			this._activeShellIntegrations.get(t)?.emitData(n)
		}
		$shellEnvChange(t, n, r, i) {
			this._activeShellIntegrations.get(t)?.setEnv(n, r, i)
		}
		$cwdChange(t, n) {
			this._activeShellIntegrations.get(t)?.setCwd(b.revive(n))
		}
		$closeTerminal(t) {
			this._activeShellIntegrations.get(t)?.dispose(), this._activeShellIntegrations.delete(t)
		}
	}
om = R([S(0, ie), S(1, tr)], om)
var NR = class extends $ {
		constructor(t, n) {
			super()
			this._terminal = t
			this._onDidStartTerminalShellExecution = n
			this._pendingExecutions = []
			this.store = this._register(new Q())
			this._onDidRequestChangeShellIntegration = this._register(new E())
			this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event
			this._onDidRequestShellExecution = this._register(new E())
			this.onDidRequestShellExecution = this._onDidRequestShellExecution.event
			this._onDidRequestEndExecution = this._register(new E())
			this.onDidRequestEndExecution = this._onDidRequestEndExecution.event
			this._onDidRequestNewExecution = this._register(new E())
			this.onDidRequestNewExecution = this._onDidRequestNewExecution.event
			let r = this
			this.value = {
				get cwd() {
					return r._cwd
				},
				get env() {
					if (r._env)
						return Object.freeze({ isTrusted: r._env.isTrusted, value: Object.freeze({ ...r._env.value }) })
				},
				executeCommand(i, s) {
					let a = i
					if (s) for (let c of s) !c.match(/["'`]/) && c.match(/\s/) ? (a += ` "${c}"`) : (a += ` ${c}`)
					r._onDidRequestShellExecution.fire(a)
					let l = { value: a, confidence: 2, isTrusted: !0 }
					return r.requestNewShellExecution(l, r._cwd).value
				},
			}
		}
		get currentExecution() {
			return this._currentExecution
		}
		requestNewShellExecution(t, n) {
			let r = new xC(t, n ?? this._cwd)
			return (
				IC(t.value).length > 1 &&
					(this._currentExecutionProperties = { isMultiLine: !0, unresolvedCommandLines: IC(t.value) }),
				this._pendingExecutions.push(r),
				this._onDidRequestNewExecution.fire(t.value),
				r
			)
		}
		startShellExecution(t, n) {
			if (
				(this._pendingEndingExecution &&
					(this._onDidRequestEndExecution.fire({
						terminal: this._terminal,
						shellIntegration: this.value,
						execution: this._pendingEndingExecution.value,
						exitCode: void 0,
					}),
					(this._pendingEndingExecution = void 0)),
				this._currentExecution)
			) {
				if (
					this._currentExecutionProperties?.isMultiLine &&
					this._currentExecutionProperties.unresolvedCommandLines
				) {
					let i = X2(this._currentExecutionProperties.unresolvedCommandLines, t)
					if (i) {
						this._currentExecutionProperties.unresolvedCommandLines = i.unresolvedCommandLines
						return
					}
				}
				this._currentExecution.endExecution(void 0),
					this._currentExecution.flush(),
					this._onDidRequestEndExecution.fire({
						terminal: this._terminal,
						shellIntegration: this.value,
						execution: this._currentExecution.value,
						exitCode: void 0,
					})
			}
			let r
			if (t.confidence === 2)
				for (let [i, s] of this._pendingExecutions.entries())
					if (s.value.commandLine.value === t.value) {
						;(r = s),
							(this._currentExecutionProperties = { isMultiLine: !1, unresolvedCommandLines: void 0 }),
							(r = s),
							this._pendingExecutions.splice(i, 1)
						break
					} else {
						let a = X2(IC(s.value.commandLine.value), t)
						if (a) {
							;(this._currentExecutionProperties = {
								isMultiLine: !0,
								unresolvedCommandLines: a.unresolvedCommandLines,
							}),
								(r = s),
								this._pendingExecutions.splice(i, 1)
							break
						}
					}
			else r = this._pendingExecutions.shift()
			r || (r = new xC(t, n ?? this._cwd)),
				(this._currentExecution = r),
				this._onDidStartTerminalShellExecution.fire({
					terminal: this._terminal,
					shellIntegration: this.value,
					execution: this._currentExecution.value,
				})
		}
		emitData(t) {
			this.currentExecution?.emitData(t)
		}
		endShellExecution(t, n) {
			if (
				!(
					this._currentExecutionProperties?.isMultiLine &&
					this._currentExecutionProperties.unresolvedCommandLines &&
					this._currentExecutionProperties.unresolvedCommandLines.length > 0
				) &&
				this._currentExecution
			) {
				let r = this._currentExecutionProperties?.isMultiLine ? this._currentExecution.value.commandLine : t
				this._currentExecution.endExecution(r)
				let i = this._currentExecution
				;(this._pendingEndingExecution = i),
					(this._currentExecution = void 0),
					i.flush().then(() => {
						this._pendingEndingExecution === i &&
							(this._onDidRequestEndExecution.fire({
								terminal: this._terminal,
								shellIntegration: this.value,
								execution: i.value,
								exitCode: n,
							}),
							(this._pendingEndingExecution = void 0))
					})
			}
		}
		setEnv(t, n, r) {
			let i = {}
			for (let s = 0; s < t.length; s++) i[t[s]] = n[s]
			;(this._env = { value: i, isTrusted: r }), this._fireChangeEvent()
		}
		setCwd(t) {
			let n = !1
			b.isUri(this._cwd)
				? (n = !b.isUri(t) || this._cwd.toString() !== t.toString())
				: this._cwd !== t && (n = !0),
				n && ((this._cwd = t), this._fireChangeEvent())
		}
		_fireChangeEvent() {
			this._onDidRequestChangeShellIntegration.fire({ terminal: this._terminal, shellIntegration: this.value })
		}
	},
	xC = class {
		constructor(e, t) {
			this._commandLine = e
			this.cwd = t
			this._isEnded = !1
			let n = this
			this.value = {
				get commandLine() {
					return n._commandLine
				},
				get cwd() {
					return n.cwd
				},
				read() {
					return n._createDataStream()
				},
			}
		}
		_createDataStream() {
			if (!this._dataStream) {
				if (this._isEnded) return mi.EMPTY
				this._dataStream = new UR()
			}
			return this._dataStream.createIterable()
		}
		emitData(e) {
			this._isEnded || this._dataStream?.emitData(e)
		}
		endExecution(e) {
			e && (this._commandLine = e), this._dataStream?.endExecution(), (this._isEnded = !0)
		}
		async flush() {
			this._dataStream &&
				(await this._dataStream.flush(), this._dataStream.dispose(), (this._dataStream = void 0))
		}
	},
	UR = class extends $ {
		constructor() {
			super(...arguments)
			this._iterables = []
			this._emitters = []
		}
		createIterable() {
			this._barrier || (this._barrier = new dn())
			let t = this._barrier,
				n = new mi(async (r) => {
					this._emitters.push(r), await t.wait()
				})
			return this._iterables.push(n), n
		}
		emitData(t) {
			for (let n of this._emitters) n.emitOne(t)
		}
		endExecution() {
			this._barrier?.open()
		}
		async flush() {
			await Promise.all(this._iterables.map((t) => t.toPromise()))
		}
	}
function IC(o) {
	return o
		.split(
			`
`,
		)
		.map((e) => e.trim())
		.filter((e) => e.length > 0)
}
function X2(o, e) {
	if (o.length === 0) return !1
	let t = [...o],
		n = IC(e.value)
	if (t && t.length > 0) {
		for (; t.length > 0 && t[0] === n[0]; ) t.shift(), n.shift()
		if (n.length === 0) return { unresolvedCommandLines: t }
	}
	return !1
}
function Y2(o, e) {
	return Ce.toKey(o) + "/" + e
}
var f9
;((e) => {
	function o(t, n) {
		return (
			t.id === n.id &&
			t.remoteAuthority === n.remoteAuthority &&
			t.label === n.label &&
			t.isTrustedByDefault === n.isTrustedByDefault
		)
	}
	e.equals = o
})((f9 ||= {}))
var g9
;((n) => {
	function o(r) {
		return r
	}
	n.toSerialized = o
	function e(r) {
		return {
			id: r.id,
			label: r.label,
			launch: CC.fromSerialized(r.launch),
			variableReplacement: r.variableReplacement ? Z2.fromSerialized(r.variableReplacement) : void 0,
		}
	}
	n.fromSerialized = e
	function t(r, i) {
		return (
			r.id === i.id &&
			r.label === i.label &&
			mn(r.roots, i.roots, (s, a) => s.toString() === a.toString()) &&
			nn(r.launch, i.launch) &&
			nn(r.presentation, i.presentation) &&
			nn(r.variableReplacement, i.variableReplacement)
		)
	}
	n.equals = t
})((g9 ||= {}))
var Z2
;((t) => {
	function o(n) {
		return n
	}
	t.toSerialized = o
	function e(n) {
		return {
			section: n.section,
			folder: n.folder ? { ...n.folder, uri: b.revive(n.folder.uri) } : void 0,
			target: n.target,
		}
	}
	t.fromSerialized = e
})((Z2 ||= {}))
var XRe = O("IMcpService")
var CC
;((t) => {
	function o(n) {
		return n
	}
	t.toSerialized = o
	function e(n) {
		switch (n.type) {
			case 2:
				return { type: n.type, uri: b.revive(n.uri), headers: n.headers }
			case 1:
				return {
					type: n.type,
					cwd: n.cwd ? b.revive(n.cwd) : void 0,
					command: n.command,
					args: n.args,
					env: n.env,
					envFile: n.envFile,
				}
		}
	}
	t.fromSerialized = e
})((CC ||= {}))
var Wr
;((i) => {
	let o
	;((c) => (
		(c[(c.Stopped = 0)] = "Stopped"),
		(c[(c.Starting = 1)] = "Starting"),
		(c[(c.Running = 2)] = "Running"),
		(c[(c.Error = 3)] = "Error")
	))((o = i.Kind ||= {})),
		(i.toString = (s) => {
			switch (s.state) {
				case 0:
					return p("mcpstate.stopped", "Stopped")
				case 1:
					return p("mcpstate.starting", "Starting")
				case 2:
					return p("mcpstate.running", "Running")
				case 3:
					return p("mcpstate.error", "Error {0}", s.message)
				default:
					gc(s)
			}
		}),
		(i.toKindString = (s) => {
			switch (s) {
				case 0:
					return "stopped"
				case 1:
					return "starting"
				case 2:
					return "running"
				case 3:
					return "error"
				default:
					gc(s)
			}
		}),
		(i.canBeStarted = (s) => s === 3 || s === 0),
		(i.isRunning = (s) => !(0, i.canBeStarted)(s.state))
})((Wr ||= {}))
var Bd = O("IExtHostMpcService"),
	yl = class extends $ {
		constructor(t) {
			super()
			this._initialProviderPromises = new Set()
			this._sseEventSources = this._register(new Br())
			this._eventSource = new kt(
				async () => (await lp("@c4312/eventsource-umd", "dist/index.umd.js")).EventSource,
			)
			this._proxy = t.getProxy(M.MainThreadMcp)
		}
		$startMcp(t, n) {
			this._startMcp(t, CC.fromSerialized(n))
		}
		_startMcp(t, n) {
			if (n.type === 2) {
				this._sseEventSources.set(t, new HR(this._eventSource.value, t, n, this._proxy))
				return
			}
			throw new Error("not implemented")
		}
		$stopMcp(t) {
			this._sseEventSources.has(t) &&
				(this._sseEventSources.deleteAndDispose(t),
				this._proxy.$onDidChangeState(t, { state: Wr.Kind.Stopped }))
		}
		$sendMessage(t, n) {
			this._sseEventSources.get(t)?.send(n)
		}
		async $waitForInitialCollectionProviders() {
			await Promise.all(this._initialProviderPromises)
		}
		registerMcpConfigurationProvider(t, n, r) {
			let i = new Q(),
				s = t.contributes?.modelContextServerCollections?.find((c) => c.id === n)
			if (!s)
				throw new Error(
					`MCP configuration providers must be registered in the contributes.modelContextServerCollections array within your package.json, but "${n}" was not`,
				)
			let a = {
					id: Y2(t.identifier, n),
					isTrustedByDefault: !0,
					label: s?.label ?? t.displayName ?? t.name,
					scope: 1,
				},
				l = async () => {
					let c = await r.provideMcpServerDefinitions(De.None)
					function u(f) {
						return !!f.uri
					}
					let m = []
					for (let f of c ?? [])
						m.push({
							id: Ce.toKey(t.identifier),
							label: f.label,
							launch: u(f)
								? { type: 2, uri: f.uri, headers: f.headers }
								: {
										type: 1,
										cwd: f.cwd,
										args: f.args,
										command: f.command,
										env: f.env,
										envFile: void 0,
									},
						})
					this._proxy.$upsertMcpCollection(a, m)
				}
			i.add(
				q(() => {
					this._proxy.$deleteMcpCollection(a.id)
				}),
			),
				r.onDidChange && i.add(r.onDidChange(l))
			let d = new Promise((c) => {
				setTimeout(
					() =>
						l().finally(() => {
							this._initialProviderPromises.delete(d), c()
						}),
					0,
				)
			})
			return this._initialProviderPromises.add(d), i
		}
	}
yl = R([S(0, ie)], yl)
var HR = class extends $ {
	constructor(t, n, r, i) {
		super()
		this._id = n
		this._proxy = i
		this._requestSequencer = new Jv()
		this._postEndpoint = new Cn()
		t.then((s) => this._attach(s, r))
	}
	_attach(t, n) {
		if (this._store.isDisposed) return
		let r = new t(n.uri.toString(), {
			fetch: (i, s) =>
				fetch(i, { ...s, headers: { ...Object.fromEntries(n.headers), ...s?.headers } }).then(
					async (a) => (
						a.status >= 300 &&
							(this._proxy.$onDidChangeState(this._id, {
								state: Wr.Kind.Error,
								message: `${a.status} status connecting to ${n.uri}: ${await this._getErrText(a)}`,
							}),
							r.close()),
						a
					),
					(a) => (
						this._proxy.$onDidChangeState(this._id, {
							state: Wr.Kind.Error,
							message: `Error connecting to ${n.uri}: ${String(a)}`,
						}),
						r.close(),
						Promise.reject(a)
					),
				),
		})
		this._register(q(() => r.close())),
			r.addEventListener("endpoint", (i) => {
				this._postEndpoint.complete(new URL(i.data, n.uri.toString()).toString())
			}),
			r.addEventListener("message", (i) => {
				this._proxy.$onDidReceiveMessage(this._id, i.data)
			}),
			r.addEventListener("open", () => {
				this._proxy.$onDidChangeState(this._id, { state: Wr.Kind.Running })
			}),
			r.addEventListener("error", (i) => {
				this._postEndpoint.cancel(),
					this._proxy.$onDidChangeState(this._id, {
						state: Wr.Kind.Error,
						message: `Error connecting to ${n.uri}: ${i.code || 0} ${i.message || JSON.stringify(i)}`,
					}),
					r.close()
			})
	}
	async send(t) {
		try {
			let n = await this._requestSequencer.queue(async () => {
				let r = await this._postEndpoint.p,
					i = new TextEncoder().encode(t)
				return fetch(r, {
					method: "POST",
					headers: { "Content-Type": "application/json", "Content-Length": String(i.length) },
					body: i,
				})
			})
			n.status >= 300 &&
				this._proxy.$onDidPublishLog(
					this._id,
					4,
					`${n.status} status sending message to ${this._postEndpoint}: ${await this._getErrText(n)}`,
				)
		} catch {}
	}
	async _getErrText(t) {
		try {
			return await t.text()
		} catch {
			return t.statusText
		}
	}
}
Ke(Hp, Up, 1)
Ke(uo, bl, 1)
Ke(Ks, jp, 1)
Ke(Tn, Pp, 0)
Ke(Rp, kp, 0)
Ke(Ap, qs, 0)
Ke(pn, pp, 0)
Ke(Fi, Cr, 0)
Ke(js, Yp, 0)
Ke(em, Zp, 0)
Ke(iC, Ui, 0)
Ke(no, Kp, 0)
Ke(Vp, Wp, 0)
Ke(po, _b, 0)
Ke(oC, qp, 1)
Ke(rm, hl, 0)
Ke(bp, vp, 0)
Ke(Qp, Gp, 0)
Ke(tr, _p, 0)
Ke(im, om, 0)
Ke(ll, al, 0)
Ke(yC, vl, 0)
Ke(Sn, dp, 0)
Ke(Np, Fp, 0)
Ke(Zo, Xp, 0)
Ke(ei, gl, 0)
Ke(Bd, yl, 0)
var sm = class extends Ud {
	constructor(e, t) {
		super(!0, e, t)
	}
	createTerminal(e, t, n) {
		return this.createTerminalFromOptions({ name: e, shellPath: t, shellArgs: n })
	}
	createTerminalFromOptions(e, t) {
		let n = new Dp(this._proxy, He(), e, e.name)
		return this._terminals.push(n), n.create(e, this._serializeParentTerminal(e, t)), n.value
	}
}
sm = R([S(0, Tn), S(1, ie)], sm)
import { promises as nN } from "fs"
function eN(o, ...e) {
	let t = e.reduce((i, s) => ((i[s] = !0), i), {}),
		n = [
			/^ELECTRON_.+$/,
			/^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/,
			/^SNAP(|_.*)$/,
			/^GDK_PIXBUF_.+$/,
		]
	Object.keys(o)
		.filter((i) => !t[i])
		.forEach((i) => {
			for (let s = 0; s < n.length; s++)
				if (i.search(n[s]) !== -1) {
					delete o[i]
					break
				}
		})
}
function tN(o) {
	o && (delete o.DEBUG, Ve && delete o.LD_PRELOAD)
}
function SC(o = Pr) {
	return o.comspec || "cmd.exe"
}
function rN(o) {
	let e = [],
		t = !1,
		n = function (r) {
			if (t) {
				e.push(r)
				return
			}
			;(!o.send(r, (s) => {
				if ((s && console.error(s), (t = !1), e.length > 0)) {
					let a = e.slice(0)
					;(e = []), a.forEach((l) => n(l))
				}
			}) ||
				Ie) &&
				(t = !0)
		}
	return { send: n }
}
async function v9(o) {
	if (await Qe.exists(o)) {
		let e
		try {
			e = await nN.stat(o)
		} catch (t) {
			t.message.startsWith("EACCES") && (e = await nN.lstat(o))
		}
		return e ? !e.isDirectory() : !1
	}
	return !1
}
async function $d(o, e, t, n = Pr, r = v9) {
	if (In(o)) return (await r(o)) ? o : void 0
	if ((e === void 0 && (e = Lo()), Qt(o) !== ".")) {
		let l = Fe(e, o)
		return (await r(l)) ? l : void 0
	}
	let s = aw(n, "PATH")
	if ((t === void 0 && we(s) && (t = s.split(Av)), t === void 0 || t.length === 0)) {
		let l = Fe(e, o)
		return (await r(l)) ? l : void 0
	}
	for (let l of t) {
		let d
		if ((In(l) ? (d = Fe(l, o)) : (d = Fe(e, l, o)), Ie)) {
			let u = (aw(n, "PATHEXT") || ".COM;.EXE;.BAT;.CMD").split(";").map(async (m) => {
				let f = d + m
				return (await r(f)) ? f : void 0
			})
			for (let m of u) {
				let f = await m
				if (f) return f
			}
		}
		if (await r(d)) return d
	}
	let a = Fe(e, o)
	return (await r(a)) ? a : void 0
}
import { homedir as b9 } from "os"
var am = class extends Hd {
	constructor(t, n, r, i, s, a, l, d, c) {
		super(t, n, r, i, s, a, l, d)
		this.workspaceService = r
		this.variableResolver = c
		n.remote.isRemote && n.remote.authority
			? this.registerTaskSystem(W.vscodeRemote, {
					scheme: W.vscodeRemote,
					authority: n.remote.authority,
					platform: process.platform,
				})
			: this.registerTaskSystem(W.file, { scheme: W.file, authority: "", platform: process.platform }),
			this._proxy.$registerSupportedExecutions(!0, !0, !0)
	}
	async executeTask(t, n) {
		let r = n
		if (!n.execution && r._id === void 0) throw new Error("Tasks to execute must include an execution")
		if (r._id !== void 0) {
			let i = bR.from(r, this.workspaceService),
				s = await this._proxy.$getTaskExecution(i)
			if (s.task === void 0) throw new Error("Task from execution DTO is undefined")
			let a = await this.getTaskExecution(s, n)
			return this._proxy.$executeTask(i).catch(() => {}), a
		} else {
			let i = Hi.from(n, t)
			if (i === void 0) return Promise.reject(new Error("Task is not valid"))
			Yo.is(i.execution) && (await this.addCustomExecution(i, n, !1))
			let s = await this.getTaskExecution(await this._proxy.$getTaskExecution(i), n)
			return this._proxy.$executeTask(i).catch(() => {}), s
		}
	}
	provideTasksInternal(t, n, r, i) {
		let s = []
		if (i)
			for (let a of i) {
				this.checkDeprecation(a, r),
					(!a.definition || !t[a.definition.type]) &&
						this._logService.warn(
							`The task [${a.source}, ${a.name}] uses an undefined task type. The task will be ignored in the future.`,
						)
				let l = Hi.from(a, r.extension)
				l && (s.push(l), Yo.is(l.execution) && n.push(this.addCustomExecution(l, a, !0)))
			}
		return { tasks: s, extension: r.extension }
	}
	async resolveTaskInternal(t) {
		return t
	}
	async getAFolder(t) {
		let n = t && t.length > 0 ? t[0] : void 0
		if (!n) {
			let r = b.file(b9())
			n = new Yl({ uri: r, name: Ht(r), index: 0 })
		}
		return {
			uri: n.uri,
			name: n.name,
			index: n.index,
			toResource: () => {
				throw new Error("Not implemented")
			},
		}
	}
	async $resolveVariables(t, n) {
		let r = b.revive(t),
			i = { process: void 0, variables: Object.create(null) },
			s = await this._workspaceProvider.resolveWorkspaceFolder(r),
			a = (await this._workspaceProvider.getWorkspaceFolders2()) ?? [],
			l = await this.variableResolver.getResolver(),
			d = s
				? {
						uri: s.uri,
						name: s.name,
						index: s.index,
						toResource: () => {
							throw new Error("Not implemented")
						},
					}
				: await this.getAFolder(a)
		for (let c of n.variables) i.variables[c] = await l.resolveAsync(d, c)
		if (n.process !== void 0) {
			let c
			if (n.process.path !== void 0) {
				c = n.process.path.split(Av)
				for (let h = 0; h < c.length; h++) c[h] = await l.resolveAsync(d, c[h])
			}
			let u = await l.resolveAsync(d, n.process.name),
				m = n.process.cwd !== void 0 ? await l.resolveAsync(d, n.process.cwd) : void 0,
				f = await $d(u, m, c)
			f ? (i.process = f) : In(u) ? (i.process = u) : (i.process = Fe(m ?? "", u))
		}
		return i
	}
	async $jsonTasksSupported() {
		return !0
	}
	async $findExecutable(t, n, r) {
		return $d(t, n, r)
	}
}
am = R([S(0, ie), S(1, Xe), S(2, Sn), S(3, no), S(4, pn), S(5, tr), S(6, te), S(7, Ks), S(8, ei)], am)
import * as zd from "child_process"
var F0e = O("externalTerminal"),
	uh = "Terminal.app"
var iN = p("console.title", "VS Code Console"),
	ph = class {
		async getDefaultTerminalForPlatforms() {
			return {
				windows: mh.getDefaultTerminalWindows(),
				linux: await fh.getDefaultTerminalLinuxReady(),
				osx: "xterm",
			}
		}
	},
	ti = class ti extends ph {
		static {
			this.CMD = "cmd.exe"
		}
		openTerminal(e, t) {
			return this.spawnTerminal(zd, e, SC(), t)
		}
		spawnTerminal(e, t, n, r) {
			let i = t.windowsExec || ti.getDefaultTerminalWindows()
			r && r[1] === ":" && (r = r[0].toUpperCase() + r.substr(1))
			let s = Ze(i, ".exe").toLowerCase()
			if (s === "cmder") return e.spawn(i, r ? [r] : void 0), Promise.resolve(void 0)
			let a = ["/c", "start", "/wait"]
			return (
				i.indexOf(" ") >= 0 && a.push(i),
				a.push(i),
				s === "wt" && a.push("-d ."),
				new Promise((l, d) => {
					let c = lm(process),
						u = e.spawn(n, a, { cwd: r, env: c, detached: !0 })
					u.on("error", d), u.on("exit", () => l())
				})
			)
		}
		async runInTerminal(e, t, n, r, i) {
			let s = "windowsExec" in i && i.windowsExec ? i.windowsExec : ti.getDefaultTerminalWindows(),
				a = await ti.getWtExePath()
			return new Promise((l, d) => {
				let c = `"${t} - ${iN}"`,
					u = `"${n.join('" "')}" & pause`,
					m = Object.assign({}, lm(process), r)
				Object.keys(m)
					.filter((C) => m[C] === null)
					.forEach((C) => delete m[C])
				let f = { cwd: t, env: m, windowsVerbatimArguments: !0 },
					h,
					g
				Ze(s, ".exe") === "wt"
					? ((h = s), (g = ["-d", ".", ti.CMD, "/c", u]))
					: a
						? ((h = a), (g = ["-d", ".", s, "/c", u]))
						: ((h = ti.CMD), (g = ["/c", "start", c, "/wait", s, "/c", `"${u}"`])),
					zd.spawn(h, g, f).on("error", (C) => {
						d(WR(C))
					}),
					l(void 0)
			})
		}
		static getDefaultTerminalWindows() {
			if (!ti._DEFAULT_TERMINAL_WINDOWS) {
				let e = !!process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
				ti._DEFAULT_TERMINAL_WINDOWS = `${process.env.windir ? process.env.windir : "C:\\Windows"}\\${e ? "Sysnative" : "System32"}\\cmd.exe`
			}
			return ti._DEFAULT_TERMINAL_WINDOWS
		}
		static async getWtExePath() {
			try {
				return await $d("wt")
			} catch {
				return
			}
		}
	}
R([eb], ti, "getWtExePath", 1)
var mh = ti,
	TC = class o extends ph {
		static {
			this.OSASCRIPT = "/usr/bin/osascript"
		}
		openTerminal(e, t) {
			return this.spawnTerminal(zd, e, t)
		}
		runInTerminal(e, t, n, r, i) {
			let s = i.osxExec || uh
			return new Promise((a, l) => {
				if (s === uh || s === "iTerm.app") {
					let d = s === uh ? "TerminalHelper" : "iTermHelper",
						u = [
							Ec.asFileUri(`vs/workbench/contrib/externalTerminal/node/${d}.scpt`).fsPath,
							"-t",
							e || iN,
							"-w",
							t,
						]
					for (let h of n) u.push("-a"), u.push(h)
					if (r) {
						let h = Object.assign({}, lm(process), r)
						for (let g in h) {
							let I = h[g]
							I === null ? (u.push("-u"), u.push(g)) : (u.push("-e"), u.push(`${g}=${I}`))
						}
					}
					let m = "",
						f = zd.spawn(o.OSASCRIPT, u)
					f.on("error", (h) => {
						l(WR(h))
					}),
						f.stderr.on("data", (h) => {
							m += h.toString()
						}),
						f.on("exit", (h) => {
							if (h === 0) a(void 0)
							else if (m) {
								let g = m.split(
									`
`,
									1,
								)
								l(new Error(g[0]))
							} else
								l(
									new Error(
										p("mac.terminal.script.failed", "Script '{0}' failed with exit code {1}", d, h),
									),
								)
						})
				} else l(new Error(p("mac.terminal.type.not.supported", "'{0}' not supported", s)))
			})
		}
		spawnTerminal(e, t, n) {
			let r = t.osxExec || uh
			return new Promise((i, s) => {
				let a = ["-a", r]
				n && a.push(n)
				let l = lm(process),
					d = e.spawn("/usr/bin/open", a, { cwd: n, env: l })
				d.on("error", s), d.on("exit", () => i())
			})
		}
	},
	fh = class o extends ph {
		static {
			this.WAIT_MESSAGE = p("press.any.key", "Press any key to continue...")
		}
		openTerminal(e, t) {
			return this.spawnTerminal(zd, e, t)
		}
		runInTerminal(e, t, n, r, i) {
			let s = i.linuxExec ? Promise.resolve(i.linuxExec) : o.getDefaultTerminalLinuxReady()
			return new Promise((a, l) => {
				let d = []
				s.then((c) => {
					c.indexOf("gnome-terminal") >= 0 ? d.push("-x") : d.push("-e"), d.push("bash"), d.push("-c")
					let u = `${y9(n)}; echo; read -p "${o.WAIT_MESSAGE}" -n1;`
					d.push(`''${u}''`)
					let m = Object.assign({}, lm(process), r)
					Object.keys(m)
						.filter((I) => m[I] === null)
						.forEach((I) => delete m[I])
					let f = { cwd: t, env: m },
						h = "",
						g = zd.spawn(c, d, f)
					g.on("error", (I) => {
						l(WR(I))
					}),
						g.stderr.on("data", (I) => {
							h += I.toString()
						}),
						g.on("exit", (I) => {
							if (I === 0) a(void 0)
							else if (h) {
								let C = h.split(
									`
`,
									1,
								)
								l(new Error(C[0]))
							} else l(new Error(p("linux.term.failed", "'{0}' failed with exit code {1}", c, I)))
						})
				})
			})
		}
		static async getDefaultTerminalLinuxReady() {
			if (!o._DEFAULT_TERMINAL_LINUX_READY)
				if (!Ve) o._DEFAULT_TERMINAL_LINUX_READY = Promise.resolve("xterm")
				else {
					let e = await Qe.exists("/etc/debian_version")
					o._DEFAULT_TERMINAL_LINUX_READY = new Promise((t) => {
						e
							? t("x-terminal-emulator")
							: process.env.DESKTOP_SESSION === "gnome" || process.env.DESKTOP_SESSION === "gnome-classic"
								? t("gnome-terminal")
								: process.env.DESKTOP_SESSION === "kde-plasma"
									? t("konsole")
									: process.env.COLORTERM
										? t(process.env.COLORTERM)
										: process.env.TERM
											? t(process.env.TERM)
											: t("xterm")
					})
				}
			return o._DEFAULT_TERMINAL_LINUX_READY
		}
		spawnTerminal(e, t, n) {
			let r = t.linuxExec ? Promise.resolve(t.linuxExec) : o.getDefaultTerminalLinuxReady()
			return new Promise((i, s) => {
				r.then((a) => {
					let l = lm(process),
						d = e.spawn(a, [], { cwd: n, env: l })
					d.on("error", s), d.on("exit", () => i())
				})
			})
		}
	}
function lm(o) {
	let e = { ...o.env }
	return eN(e), e
}
function WR(o) {
	return "errno" in o && o.errno === "ENOENT" && "path" in o && typeof o.path == "string"
		? new Error(p("ext.term.app.not.found", "can't find terminal application '{0}'", o.path))
		: o
}
function y9(o) {
	let e = ""
	for (let t of o) t.indexOf(" ") >= 0 ? (e += '"' + t + '"') : (e += t), (e += " ")
	return e
}
var EC = class o {
	constructor() {
		this.validators = new Map()
	}
	static {
		this._nextId = 1
	}
	async createNewMessage(e) {
		try {
			let t = await this.getValidator()
			if (t) {
				let n = String(o._nextId++)
				return this.validators.set(n, t), { id: n, data: t.createNewMessage(e) }
			}
		} catch {}
		return { id: "", data: e }
	}
	async validate(e, t) {
		if (!e.id) return !0
		let n = this.validators.get(e.id)
		if (!n) return !1
		this.validators.delete(e.id)
		try {
			return n.validate(t) === "ok"
		} catch {
			return !1
		} finally {
			n.dispose?.()
		}
	}
	async sign(e) {
		try {
			return await this.signValue(e)
		} catch {}
		return e
	}
}
var dm = class extends EC {
	getValidator() {
		return this.vsda().then((e) => new e.validator())
	}
	signValue(e) {
		return this.vsda().then((t) => new t.signer().sign(e))
	}
	async vsda() {
		let e = "vsda",
			{ default: t } = await import(e)
		return t
	}
}
import * as cm from "child_process"
import * as VR from "net"
var wC = class o extends Jp {
		constructor() {
			super()
			this.rawData = Buffer.allocUnsafe(0)
			this.contentLength = -1
		}
		static {
			this.TWO_CRLF = `\r
\r
`
		}
		static {
			this.HEADER_LINESEPARATOR = /\r?\n/
		}
		static {
			this.HEADER_FIELDSEPARATOR = /: */
		}
		connect(t, n) {
			;(this.outputStream = n),
				(this.rawData = Buffer.allocUnsafe(0)),
				(this.contentLength = -1),
				t.on("data", (r) => this.handleData(r))
		}
		sendMessage(t) {
			if (this.outputStream) {
				let n = JSON.stringify(t)
				this.outputStream.write(`Content-Length: ${Buffer.byteLength(n, "utf8")}${o.TWO_CRLF}${n}`, "utf8")
			}
		}
		handleData(t) {
			for (this.rawData = Buffer.concat([this.rawData, t]); ; ) {
				if (this.contentLength >= 0) {
					if (this.rawData.length >= this.contentLength) {
						let n = this.rawData.toString("utf8", 0, this.contentLength)
						if (
							((this.rawData = this.rawData.slice(this.contentLength)),
							(this.contentLength = -1),
							n.length > 0)
						)
							try {
								this.acceptMessage(JSON.parse(n))
							} catch (r) {
								this._onError.fire(
									new Error(
										(r.message || r) +
											`
` +
											n,
									),
								)
							}
						continue
					}
				} else {
					let n = this.rawData.indexOf(o.TWO_CRLF)
					if (n !== -1) {
						let i = this.rawData.toString("utf8", 0, n).split(o.HEADER_LINESEPARATOR)
						for (let s of i) {
							let a = s.split(o.HEADER_FIELDSEPARATOR)
							a[0] === "Content-Length" && (this.contentLength = Number(a[1]))
						}
						this.rawData = this.rawData.slice(n + o.TWO_CRLF.length)
						continue
					}
				}
				break
			}
		}
	},
	PC = class extends wC {
		startSession() {
			return new Promise((e, t) => {
				let n = !1
				;(this.socket = this.createConnection(() => {
					this.connect(this.socket, this.socket), e(), (n = !0)
				})),
					this.socket.on("close", () => {
						n ? this._onError.fire(new Error("connection closed")) : t(new Error("connection closed"))
					}),
					this.socket.on("error", (r) => {
						r instanceof AggregateError && (r = r.errors[0]), n ? this._onError.fire(r) : t(r)
					})
			})
		}
		async stopSession() {
			await this.cancelPendingRequests(), this.socket && (this.socket.end(), (this.socket = void 0))
		}
	},
	_C = class extends PC {
		constructor(t) {
			super()
			this.adapterServer = t
		}
		createConnection(t) {
			return VR.createConnection(this.adapterServer.port, this.adapterServer.host || "127.0.0.1", t)
		}
	},
	DC = class extends PC {
		constructor(t) {
			super()
			this.adapterServer = t
		}
		createConnection(t) {
			return VR.createConnection(this.adapterServer.path, t)
		}
	},
	gh = class o extends wC {
		constructor(t, n) {
			super()
			this.adapterExecutable = t
			this.debugType = n
		}
		async startSession() {
			let t = this.adapterExecutable.command,
				n = this.adapterExecutable.args,
				r = this.adapterExecutable.options || {}
			try {
				if (t)
					if (In(t)) {
						if (!(await Qe.exists(t)))
							throw new Error(
								p("debugAdapterBinNotFound", "Debug adapter executable '{0}' does not exist.", t),
							)
					} else t.indexOf("/") < 0 && t.indexOf("\\") < 0
				else
					throw new Error(
						p(
							{
								key: "debugAdapterCannotDetermineExecutable",
								comment: ["Adapter executable file not found"],
							},
							"Cannot determine executable for debug adapter '{0}'.",
							this.debugType,
						),
					)
				let i = process.env
				if ((r.env && Object.keys(r.env).length > 0 && (i = gr(je(process.env), r.env)), t === "node"))
					if (Array.isArray(n) && n.length > 0) {
						let s = !!process.env.ELECTRON_RUN_AS_NODE || !!process.versions.electron,
							a = {
								env: i,
								execArgv: s
									? ["-e", "delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])"]
									: [],
								silent: !0,
							}
						r.cwd && (a.cwd = r.cwd)
						let l = cm.fork(n[0], n.slice(1), a)
						if (!l.pid)
							throw new Error(
								p("unableToLaunchDebugAdapter", "Unable to launch debug adapter from '{0}'.", n[0]),
							)
						this.serverProcess = l
					} else throw new Error(p("unableToLaunchDebugAdapterNoArgs", "Unable to launch debug adapter."))
				else {
					let s = t,
						a = n,
						l = { env: i }
					r.cwd && (l.cwd = r.cwd),
						Ie &&
							(t.endsWith(".bat") || t.endsWith(".cmd")) &&
							((l.shell = !0),
							(s = `"${t}"`),
							(a = n.map((d) => ((d = d.replace(/"/g, '\\"')), `"${d}"`)))),
						(this.serverProcess = cm.spawn(s, a, l))
				}
				this.serverProcess.on("error", (s) => {
					this._onError.fire(s)
				}),
					this.serverProcess.on("exit", (s, a) => {
						this._onExit.fire(s)
					}),
					this.serverProcess.stdout.on("close", () => {
						this._onError.fire(new Error("read error"))
					}),
					this.serverProcess.stdout.on("error", (s) => {
						this._onError.fire(s)
					}),
					this.serverProcess.stdin.on("error", (s) => {
						this._onError.fire(s)
					}),
					this.serverProcess.stderr.resume(),
					this.connect(this.serverProcess.stdout, this.serverProcess.stdin)
			} catch (i) {
				this._onError.fire(i)
			}
		}
		async stopSession() {
			return this.serverProcess
				? (await this.cancelPendingRequests(),
					Ie
						? new Promise((t, n) => {
								let r = cm.exec(`taskkill /F /T /PID ${this.serverProcess.pid}`, function (i, s, a) {
									if (i) return n(i)
								})
								r.on("exit", t), r.on("error", n)
							})
						: (this.serverProcess.kill("SIGTERM"), Promise.resolve(void 0)))
				: Promise.resolve(void 0)
		}
		static extract(t, n) {
			if (!t) return
			let r = Object.create(null)
			t.runtime && (t.runtime.indexOf("./") === 0 ? (r.runtime = Fe(n, t.runtime)) : (r.runtime = t.runtime)),
				t.runtimeArgs && (r.runtimeArgs = t.runtimeArgs),
				t.program && (In(t.program) ? (r.program = t.program) : (r.program = Fe(n, t.program))),
				t.args && (r.args = t.args)
			let i = t
			return (
				i.win && (r.win = o.extract(i.win, n)),
				i.winx86 && (r.winx86 = o.extract(i.winx86, n)),
				i.windows && (r.windows = o.extract(i.windows, n)),
				i.osx && (r.osx = o.extract(i.osx, n)),
				i.linux && (r.linux = o.extract(i.linux, n)),
				r
			)
		}
		static platformAdapterExecutable(t, n) {
			let r = Object.create(null)
			n = n.toLowerCase()
			for (let c of t)
				if (c.contributes) {
					let u = c.contributes.debuggers
					u &&
						u.length > 0 &&
						u
							.filter((m) => typeof m.type == "string" && xn(m.type, n))
							.forEach((m) => {
								let f = o.extract(m, c.extensionLocation.fsPath)
								r = gr(r, f, c.isBuiltin)
							})
				}
			let i
			Ie && !process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
				? (i = r.winx86 || r.win || r.windows)
				: Ie
					? (i = r.win || r.windows)
					: st
						? (i = r.osx)
						: Ve && (i = r.linux),
				(i = i || r)
			let s = i.program || r.program,
				a = i.args || r.args,
				l = i.runtime || r.runtime,
				d = i.runtimeArgs || r.runtimeArgs
			if (l)
				return {
					type: "executable",
					command: l,
					args: (d || []).concat(typeof s == "string" ? [s] : []).concat(a || []),
				}
			if (s) return { type: "executable", command: s, args: a || [] }
		}
	}
import * as sN from "child_process"
function I9(o, e) {
	return new Promise((t, n) => {
		let r = "",
			i = sN.spawn(o, e)
		i.pid &&
			i.stdout.on("data", (s) => {
				r += s.toString()
			}),
			i.on("error", (s) => {
				n(s)
			}),
			i.on("close", (s) => {
				t(r)
			})
	})
}
async function aN(o) {
	if (o)
		if (Ie) {
			let e = await import("@vscode/windows-process-tree")
			return new Promise((t) => {
				e.getProcessTree(o, (n) => {
					t(!!n && n.children.length > 0)
				})
			})
		} else
			return I9("/usr/bin/pgrep", ["-lP", String(o)]).then(
				(e) => {
					let t = e.trim()
					return !(t.length === 0 || t.indexOf(" tmux") >= 0)
				},
				(e) => !0,
			)
	return Promise.resolve(!0)
}
function lN(o, e, t, n, r) {
	o = o.trim().toLowerCase()
	let i
	o.indexOf("powershell") >= 0 || o.indexOf("pwsh") >= 0
		? (i = 1)
		: o.indexOf("cmd.exe") >= 0
			? (i = 0)
			: o.indexOf("bash") >= 0
				? (i = 2)
				: Ie
					? (i = 0)
					: (i = 2)
	let s,
		a = " "
	switch (i) {
		case 1:
			if (
				((s = (l) => (
					(l = l.replace(/\'/g, "''")),
					l.length > 0 && l.charAt(l.length - 1) === "\\" ? `'${l}\\'` : `'${l}'`
				)),
				n)
			) {
				let l = ME(n)
				l && (a += `${l}:; `), (a += `cd ${s(n)}; `)
			}
			if (r)
				for (let l in r) {
					let d = r[l]
					d === null ? (a += `Remove-Item env:${l}; `) : (a += `\${env:${l}}='${d}'; `)
				}
			if (e.length > 0) {
				let l = e.shift(),
					d = t ? l : s(l)
				a += d[0] === "'" ? `& ${d} ` : `${d} `
				for (let c of e) (a += c === "<" || c === ">" || t ? c : s(c)), (a += " ")
			}
			break
		case 0:
			if (
				((s = (l) => (
					(l = l.replace(/\"/g, '""')),
					(l = l.replace(/([><!^&|])/g, "^$1")),
					' "'.split("").some((d) => l.includes(d)) || l.length === 0 ? `"${l}"` : l
				)),
				n)
			) {
				let l = ME(n)
				l && (a += `${l}: && `), (a += `cd ${s(n)} && `)
			}
			if (r) {
				a += 'cmd /C "'
				for (let l in r) {
					let d = r[l]
					d === null
						? (a += `set "${l}=" && `)
						: ((d = d.replace(/[&^|<>]/g, (c) => `^${c}`)), (a += `set "${l}=${d}" && `))
				}
			}
			for (let l of e) (a += l === "<" || l === ">" || t ? l : s(l)), (a += " ")
			r && (a += '"')
			break
		case 2: {
			s = (d) => ((d = d.replace(/(["'\\\$!><#()\[\]*&^| ;{}?`])/g, "\\$1")), d.length === 0 ? '""' : d)
			let l = (d) => (/[^\w@%\/+=,.:^-]/.test(d) ? `'${d.replace(/'/g, "'\\''")}'` : d)
			if ((n && (a += `cd ${s(n)} ; `), r)) {
				a += "/usr/bin/env"
				for (let d in r) {
					let c = r[d]
					c === null ? (a += ` -u ${l(d)}`) : (a += ` ${l(`${d}=${c}`)}`)
				}
				a += " "
			}
			for (let d of e) (a += d === "<" || d === ">" || t ? d : s(d)), (a += " ")
			break
		}
	}
	return a
}
var um = class extends Wd {
	constructor(t, n, r, i, s, a, l, d, c, u) {
		super(t, n, r, i, l, d, c, u)
		this._terminalService = s
		this._terminalShellIntegrationService = a
		this._integratedTerminalInstances = new BR()
	}
	createDebugAdapter(t, n) {
		return t instanceof Qo
			? new gh(this.convertExecutableToDto(t), n.type)
			: t instanceof Jo
				? new _C(this.convertServerToDto(t))
				: t instanceof wi
					? new DC(this.convertPipeServerToDto(t))
					: super.createDebugAdapter(t, n)
	}
	daExecutableFromPackage(t, n) {
		let r = gh.platformAdapterExecutable(n.getAllExtensionDescriptions(), t.type)
		if (r) return new Qo(r.command, r.args, r.options)
	}
	createSignService() {
		return new dm()
	}
	async $runInTerminal(t, n) {
		if (t.kind === "integrated") {
			this._terminalDisposedListener ||
				(this._terminalDisposedListener = this._register(
					this._terminalService.onDidCloseTerminal((g) => {
						this._integratedTerminalInstances.onTerminalClosed(g)
					}),
				))
			let r = await this._configurationService.getConfigProvider(),
				i = this._terminalService.getDefaultShell(!0),
				s = this._terminalService.getDefaultShellArgs(!0),
				a = t.title || p("debug.terminal.title", "Debug Process"),
				l = JSON.stringify({ shell: i, shellArgs: s }),
				d = await this._integratedTerminalInstances.checkout(l, a),
				c,
				u = !1
			if (d) c = t.cwd
			else {
				let g = { shellPath: i, shellArgs: s, cwd: t.cwd, name: a, iconPath: new Vt("debug") }
				;(u = !0),
					(d = this._terminalService.createTerminalFromOptions(g, {
						isFeatureTerminal: !0,
						forceShellIntegration: !0,
						useShellEnvironment: !0,
					})),
					this._integratedTerminalInstances.insert(d, l)
			}
			d.show(!0)
			let m = await d.processId
			if (u) {
				let g
				;((w) => ((w[(w.DataDebounce = 500)] = "DataDebounce"), (w[(w.MaxDelay = 5e3)] = "MaxDelay")))(
					(g ||= {}),
				)
				let I = new Q()
				await new Promise((C) => {
					let T = I.add(new Wn(C, 500))
					I.add(
						this._terminalService.onDidWriteTerminalData((w) => {
							w.terminal === d && T.schedule()
						}),
					),
						I.add(
							this._terminalShellIntegrationService.onDidChangeTerminalShellIntegration((w) => {
								w.terminal === d && C()
							}),
						),
						I.add(Ef(C, 5e3))
				}),
					I.dispose()
			} else if (
				(d.state.isInteractedWith && !d.shellIntegration && (d.sendText(""), await Wt(200)),
				r.getConfiguration("debug.terminal").get("clearBeforeReusing"))
			) {
				let g
				if (
					(i.indexOf("powershell") >= 0 || i.indexOf("pwsh") >= 0 || i.indexOf("cmd.exe") >= 0
						? (g = "cls")
						: i.indexOf("bash") >= 0
							? (g = "clear")
							: Ie
								? (g = "cls")
								: (g = "clear"),
					d.shellIntegration)
				) {
					let I = new Q(),
						C = d.shellIntegration.executeCommand(g)
					await new Promise((T) => {
						I.add(
							this._terminalShellIntegrationService.onDidEndTerminalShellExecution((w) => {
								w.execution === C && T()
							}),
						),
							I.add(Ef(T, 500))
					}),
						I.dispose()
				} else d.sendText(g), await Wt(200)
			}
			let f = lN(i, t.args, !!t.argsCanBeInterpretedByShell, c, t.env)
			d.shellIntegration ? d.shellIntegration.executeCommand(f) : d.sendText(f)
			let h = this.onDidTerminateDebugSession((g) => {
				g.id === n && (this._integratedTerminalInstances.free(d), h.dispose())
			})
			return m
		} else if (t.kind === "external") return x9(t, await this._configurationService.getConfigProvider())
		return super.$runInTerminal(t, n)
	}
}
um = R([S(0, ie), S(1, Sn), S(2, pr), S(3, pn), S(4, tr), S(5, im), S(6, Zo), S(7, ei), S(8, Tn), S(9, js)], um)
var hh
function x9(o, e) {
	if (!hh)
		if (Ie) hh = new mh()
		else if (st) hh = new TC()
		else if (Ve) hh = new fh()
		else throw new Error("external terminals not supported on this platform")
	let t = e.getConfiguration("terminal")
	return hh.runInTerminal(o.title, o.cwd, o.args, o.env || {}, t.external || {})
}
var BR = class o {
	constructor() {
		this._terminalInstances = new Map()
	}
	static {
		this.minUseDelay = 1e3
	}
	async checkout(e, t, n = !1) {
		let i = [...this._terminalInstances.entries()].map(([s, a]) =>
			Ar(async (l) => {
				if (s.name !== t || (a.lastUsedAt !== -1 && (await aN(await s.processId)))) return null
				let d = Date.now()
				return a.lastUsedAt + o.minUseDelay > d || l.isCancellationRequested
					? null
					: a.config !== e
						? (n && s.dispose(), null)
						: ((a.lastUsedAt = d), s)
			}),
		)
		return await IO(i, (s) => !!s)
	}
	insert(e, t) {
		this._terminalInstances.set(e, { lastUsedAt: Date.now(), config: t })
	}
	free(e) {
		let t = this._terminalInstances.get(e)
		t && (t.lastUsedAt = -1)
	}
	onTerminalClosed(e) {
		this._terminalInstances.delete(e)
	}
}
var dN = new kt(() => {
		let o = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" })
		return { collator: o, collatorIsNumeric: o.resolvedOptions().numeric }
	}),
	PAe = new kt(() => ({ collator: new Intl.Collator(void 0, { numeric: !0 }) })),
	_Ae = new kt(() => ({ collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" }) }))
function cN(o, e, t = !1) {
	let n = o || "",
		r = e || "",
		i = dN.value.collator.compare(n, r)
	return dN.value.collatorIsNumeric && i === 0 && n !== r ? (n < r ? -1 : 1) : i
}
function C9(o, e, t = !1) {
	return t || ((o = o && o.toLowerCase()), (e = e && e.toLowerCase())), o === e ? 0 : o < e ? -1 : 1
}
function vh(o, e, t = !1) {
	let n = o.split(at),
		r = e.split(at),
		i = n.length - 1,
		s = r.length - 1,
		a,
		l
	for (let d = 0; ; d++) {
		if (((a = i === d), (l = s === d), a && l)) return cN(n[d], r[d], t)
		if (a) return -1
		if (l) return 1
		let c = C9(n[d], r[d], t)
		if (c !== 0) return c
	}
}
function kC(o, e, t) {
	let n = o.toLowerCase(),
		r = e.toLowerCase(),
		i = S9(o, e, t)
	if (i) return i
	let s = n.endsWith(t),
		a = r.endsWith(t)
	if (s !== a) return s ? -1 : 1
	let l = cN(n, r)
	return l !== 0 ? l : n.localeCompare(r)
}
function S9(o, e, t) {
	let n = o.toLowerCase(),
		r = e.toLowerCase(),
		i = n.startsWith(t),
		s = r.startsWith(t)
	if (i !== s) return i ? -1 : 1
	if (i && s) {
		if (n.length < r.length) return -1
		if (n.length > r.length) return 1
	}
	return 0
}
var AC = 0,
	uN = [AC, []]
function pN(o, e, t, n) {
	if (!o || !e) return uN
	let r = o.length,
		i = e.length
	if (r < i) return uN
	let s = o.toLowerCase()
	return T9(e, t, i, o, s, r, n)
}
function T9(o, e, t, n, r, i, s) {
	let a = [],
		l = []
	for (let m = 0; m < t; m++) {
		let f = m * i,
			h = f - i,
			g = m > 0,
			I = o[m],
			C = e[m]
		for (let T = 0; T < i; T++) {
			let w = T > 0,
				L = f + T,
				A = L - 1,
				J = h + T - 1,
				ne = w ? a[A] : 0,
				oe = g && w ? a[J] : 0,
				Y = g && w ? l[J] : 0,
				j
			!oe && g ? (j = 0) : (j = E9(I, C, n, r, T, Y)),
				j && oe + j >= ne && (s || g || r.startsWith(e, T))
					? ((l[L] = Y + 1), (a[L] = oe + j))
					: ((l[L] = AC), (a[L] = ne))
		}
	}
	let d = [],
		c = t - 1,
		u = i - 1
	for (; c >= 0 && u >= 0; ) {
		let m = c * i + u
		l[m] === AC || (d.push(u), c--), u--
	}
	return [a[t * i - 1], d.reverse()]
}
function E9(o, e, t, n, r, i) {
	let s = 0
	if (!w9(e, n[r])) return s
	if (((s += 1), i > 0 && (s += i * 5), o === t[r] && (s += 1), r === 0)) s += 8
	else {
		let a = P9(t.charCodeAt(r - 1))
		a ? (s += a) : zc(t.charCodeAt(r)) && i === 0 && (s += 2)
	}
	return s
}
function w9(o, e) {
	return o === e ? !0 : o === "/" || o === "\\" ? e === "/" || e === "\\" : !1
}
function P9(o) {
	switch (o) {
		case 47:
		case 92:
			return 5
		case 95:
		case 45:
		case 46:
		case 32:
		case 39:
		case 34:
		case 58:
			return 4
		default:
			return 0
	}
}
var OC = Object.freeze({ score: 0 }),
	RC = 1 << 18,
	$R = 1 << 17,
	zR = 65536
function _9(o, e, t, n) {
	let r = n.values ? n.values : [n]
	return lr({
		[n.normalized]: {
			values: r.map((s) => ({ value: s.normalized, expectContiguousMatch: s.expectContiguousMatch })),
			label: o,
			description: e,
			allowNonContiguousMatches: t,
		},
	})
}
function mN(o, e, t, n, r) {
	if (!o || !e.normalized) return OC
	let i = n.getItemLabel(o)
	if (!i) return OC
	let s = n.getItemDescription(o),
		a = _9(i, s, t, e),
		l = r[a]
	if (l) return l
	let d = D9(i, s, n.getItemPath(o), e, t)
	return (r[a] = d), d
}
function D9(o, e, t, n, r) {
	let i = !t || !n.containsPathSeparator
	return t && (Ve ? n.pathNormalized === t : xn(n.pathNormalized, t))
		? {
				score: RC,
				labelMatch: [{ start: 0, end: o.length }],
				descriptionMatch: e ? [{ start: 0, end: e.length }] : void 0,
			}
		: n.values && n.values.length > 1
			? k9(o, e, t, n.values, i, r)
			: yN(o, e, t, n, i, r)
}
function k9(o, e, t, n, r, i) {
	let s = 0,
		a = [],
		l = []
	for (let d of n) {
		let { score: c, labelMatch: u, descriptionMatch: m } = yN(o, e, t, d, r, i)
		if (c === AC) return OC
		;(s += c), u && a.push(...u), m && l.push(...m)
	}
	return { score: s, labelMatch: gN(a), descriptionMatch: gN(l) }
}
function yN(o, e, t, n, r, i) {
	if (r || !e) {
		let [s, a] = pN(o, n.normalized, n.normalizedLowercase, i && !n.expectContiguousMatch)
		if (s) {
			let l = Ab(n.normalized, o),
				d
			if (l) {
				d = $R
				let c = Math.round((n.normalized.length / o.length) * 100)
				d += c
			} else d = zR
			return { score: d + s, labelMatch: l || fN(a) }
		}
	}
	if (e) {
		let s = e
		t && (s = `${e}${at}`)
		let a = s.length,
			l = `${s}${o}`,
			[d, c] = pN(l, n.normalized, n.normalizedLowercase, i && !n.expectContiguousMatch)
		if (d) {
			let u = fN(c),
				m = [],
				f = []
			return (
				u.forEach((h) => {
					h.start < a && h.end > a
						? (m.push({ start: 0, end: h.end - a }), f.push({ start: h.start, end: a }))
						: h.start >= a
							? m.push({ start: h.start - a, end: h.end - a })
							: f.push(h)
				}),
				{ score: d, labelMatch: m, descriptionMatch: f }
			)
		}
	}
	return OC
}
function fN(o) {
	let e = []
	if (!o) return e
	let t
	for (let n of o) t && t.end === n ? (t.end += 1) : ((t = { start: n, end: n + 1 }), e.push(t))
	return e
}
function gN(o) {
	let e = o.sort((r, i) => r.start - i.start),
		t = [],
		n
	for (let r of e)
		!n || !R9(n, r)
			? ((n = r), t.push(r))
			: ((n.start = Math.min(n.start, r.start)), (n.end = Math.max(n.end, r.end)))
	return t
}
function R9(o, e) {
	return !(o.end < e.start || e.end < o.start)
}
function IN(o, e, t, n, r, i) {
	let s = mN(o, t, n, r, i),
		a = mN(e, t, n, r, i),
		l = s.score,
		d = a.score
	if ((l === RC || d === RC) && l !== d) return l === RC ? -1 : 1
	if (l > zR || d > zR) {
		if (l !== d) return l > d ? -1 : 1
		if (l < $R && d < $R) {
			let I = A9(s.labelMatch, a.labelMatch)
			if (I !== 0) return I
		}
		let h = r.getItemLabel(o) || "",
			g = r.getItemLabel(e) || ""
		if (h.length !== g.length) return h.length - g.length
	}
	if (l !== d) return l > d ? -1 : 1
	let c = Array.isArray(s.labelMatch) && s.labelMatch.length > 0,
		u = Array.isArray(a.labelMatch) && a.labelMatch.length > 0
	if (c && !u) return -1
	if (u && !c) return 1
	let m = hN(o, s, r),
		f = hN(e, a, r)
	return m && f && m !== f ? (f > m ? -1 : 1) : O9(o, e, t, r)
}
function hN(o, e, t) {
	let n = -1,
		r = -1
	if (
		(e.descriptionMatch && e.descriptionMatch.length
			? (n = e.descriptionMatch[0].start)
			: e.labelMatch && e.labelMatch.length && (n = e.labelMatch[0].start),
		e.labelMatch && e.labelMatch.length)
	) {
		if (((r = e.labelMatch[e.labelMatch.length - 1].end), e.descriptionMatch && e.descriptionMatch.length)) {
			let i = t.getItemDescription(o)
			i && (r += i.length)
		}
	} else
		e.descriptionMatch && e.descriptionMatch.length && (r = e.descriptionMatch[e.descriptionMatch.length - 1].end)
	return r - n
}
function A9(o, e) {
	if ((!o && !e) || ((!o || !o.length) && (!e || !e.length))) return 0
	if (!e || !e.length) return -1
	if (!o || !o.length) return 1
	let t = o[0].start,
		r = o[o.length - 1].end - t,
		i = e[0].start,
		a = e[e.length - 1].end - i
	return r === a ? 0 : a < r ? 1 : -1
}
function O9(o, e, t, n) {
	let r = n.getItemLabel(o) || "",
		i = n.getItemLabel(e) || "",
		s = n.getItemDescription(o),
		a = n.getItemDescription(e),
		l = r.length + (s ? s.length : 0),
		d = i.length + (a ? a.length : 0)
	if (l !== d) return l - d
	let c = n.getItemPath(o),
		u = n.getItemPath(e)
	return c && u && c.length !== u.length
		? c.length - u.length
		: r !== i
			? kC(r, i, t.normalized)
			: s && a && s !== a
				? kC(s, a, t.normalized)
				: c && u && c !== u
					? kC(c, u, t.normalized)
					: 0
}
function vN(o) {
	return o.startsWith('"') && o.endsWith('"')
}
var L9 = " "
function bh(o) {
	typeof o != "string" && (o = "")
	let e = o.toLowerCase(),
		{ pathNormalized: t, normalized: n, normalizedLowercase: r } = bN(o),
		i = t.indexOf(at) >= 0,
		s = vN(o),
		a,
		l = o.split(L9)
	if (l.length > 1)
		for (let d of l) {
			let c = vN(d),
				{ pathNormalized: u, normalized: m, normalizedLowercase: f } = bN(d)
			m &&
				(a || (a = []),
				a.push({
					original: d,
					originalLowercase: d.toLowerCase(),
					pathNormalized: u,
					normalized: m,
					normalizedLowercase: f,
					expectContiguousMatch: c,
				}))
		}
	return {
		original: o,
		originalLowercase: e,
		pathNormalized: t,
		normalized: n,
		normalizedLowercase: r,
		values: a,
		containsPathSeparator: i,
		expectContiguousMatch: s,
	}
}
function bN(o) {
	let e
	Ie ? (e = o.replace(/\//g, at)) : (e = o.replace(/\\/g, at))
	let t = jA(e).replace(/\s|"/g, "")
	return { pathNormalized: e, normalized: t, normalizedLowercase: t.toLowerCase() }
}
import * as PN from "child_process"
import * as mm from "fs"
import { StringDecoder as wN } from "string_decoder"
import * as SN from "child_process"
function pm(o) {
	return o.startsWith("**") || o.startsWith("/") ? o : `/${o}`
}
function xN(o) {
	return new sp(o.start.line, o.start.character, o.end.line, o.end.character)
}
function qR(o) {
	return new op(o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn)
}
var qd = class {
	constructor(e, t) {
		this.prefix = e
		this.logService = t
	}
	appendLine(e) {
		this.logService.debug(`${this.prefix}#search`, e)
	}
}
qd = R([S(1, te)], qd)
import { rgPath as M9 } from "@vscode/ripgrep"
var CN = M9.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked")
function TN(o, e, t, n, r) {
	let i = F9(o, e, t, n, r),
		s = e.folder.fsPath
	return {
		cmd: SN.spawn(CN, i.args, { cwd: s }),
		rgDiskPath: CN,
		siblingClauses: i.siblingClauses,
		rgArgs: i,
		cwd: s,
	}
}
function F9(o, e, t, n, r) {
	let i = ["--files", "--hidden", "--case-sensitive", "--no-require-git"]
	U9([e], t, !1).forEach((a) => {
		let l = pm(a)
		if ((i.push("-g", l), st)) {
			let d = ew(l)
			d !== l && i.push("-g", d)
		}
	})
	let s = N9([e], n, void 0, !1)
	return (
		s.globArgs.forEach((a) => {
			let l = `!${pm(a)}`
			if ((i.push("-g", l), st)) {
				let d = ew(l)
				d !== l && i.push("-g", d)
			}
		}),
		e.disregardIgnoreFiles !== !1
			? i.push("--no-ignore")
			: e.disregardParentIgnoreFiles !== !1 && i.push("--no-ignore-parent"),
		e.ignoreSymlinks || i.push("--follow"),
		o.exists && i.push("--quiet"),
		r && i.push("--threads", `${r}`),
		i.push("--no-config"),
		e.disregardGlobalIgnoreFiles && i.push("--no-ignore-global"),
		{ args: i, siblingClauses: s.siblingClauses }
	)
}
function N9(o, e, t, n = !0) {
	let r = [],
		i = {}
	return (
		o.forEach((s) => {
			let a = Object.assign({}, s.excludePattern || {}, e || {}),
				l = EN(a, n ? s.folder.fsPath : void 0, t)
			r.push(...l.globArgs), l.siblingClauses && (i = Object.assign(i, l.siblingClauses))
		}),
		{ globArgs: r, siblingClauses: i }
	)
}
function U9(o, e, t = !0) {
	let n = []
	return (
		o.forEach((r) => {
			let i = Object.assign({}, e || {}, r.includePattern || {}),
				s = EN(i, t ? r.folder.fsPath : void 0)
			n.push(...s.globArgs)
		}),
		n
	)
}
function EN(o, e, t) {
	let n = [],
		r = {}
	return (
		Object.keys(o).forEach((i) => {
			if ((t && t.has(i)) || !i) return
			let s = o[i]
			;(i = W9(e ? H9(e, i) : i)),
				i.startsWith("\\\\") ? (i = "\\\\" + i.substr(2).replace(/\\/g, "/")) : (i = i.replace(/\\/g, "/")),
				typeof s == "boolean" && s
					? (i.startsWith("\\\\") && (i += "**"), n.push(V9(i)))
					: s && s.when && (r[i] = s)
		}),
		{ globArgs: n, siblingClauses: r }
	)
}
function H9(o, e) {
	return In(e) ? e : Fe(o, e)
}
function W9(o) {
	return (o = Rr(o, "\\")), Rr(o, "/")
}
function V9(o) {
	return vf(o).toLowerCase() === "c:/" ? o.replace(/^c:[/\\]/i, "/") : o
}
var LC = new Set()
process.on("exit", () => {
	LC.forEach((o) => o())
})
var KR = class {
		constructor(e) {
			this.normalizedFilePatternLowercase = null
			this.maxFilesize = null
			this.isCanceled = !1
			this.fileWalkSW = null
			this.cmdSW = null
			this.cmdResultCount = 0
			;(this.config = e),
				(this.filePattern = e.filePattern || ""),
				(this.includePattern = e.includePattern && Yn(e.includePattern)),
				(this.maxResults = e.maxResults || null),
				(this.exists = !!e.exists),
				(this.walkedPaths = Object.create(null)),
				(this.resultCount = 0),
				(this.isLimitHit = !1),
				(this.directoriesWalked = 0),
				(this.filesWalked = 0),
				(this.errors = []),
				this.filePattern &&
					(this.normalizedFilePatternLowercase = e.shouldGlobMatchFilePattern
						? null
						: bh(this.filePattern).normalizedLowercase),
				(this.globalExcludePattern = e.excludePattern && Yn(e.excludePattern)),
				(this.folderExcludePatterns = new Map()),
				e.folderQueries.forEach((t) => {
					let n = {}
					t.excludePattern?.forEach((i) => {
						Object.assign(n, i.pattern || {}, this.config.excludePattern || {})
					}),
						t.excludePattern?.length || Object.assign(n, this.config.excludePattern || {})
					let r = t.folder.fsPath
					e.folderQueries
						.map((i) => i.folder.fsPath)
						.filter((i) => i !== r)
						.forEach((i) => {
							Kr(i, r) && (n[Mo(r, i)] = !0)
						}),
						this.folderExcludePatterns.set(r, new jR(n, r))
				})
		}
		cancel() {
			;(this.isCanceled = !0), LC.forEach((e) => e())
		}
		walk(e, t, n, r, i, s) {
			if (((this.fileWalkSW = zt.create(!1)), this.isCanceled)) return s(null, this.isLimitHit)
			t.forEach((a) => {
				let l = Ze(a.fsPath)
				;(this.globalExcludePattern && this.globalExcludePattern(a.fsPath, l)) ||
					this.matchFile(r, { relativePath: a.fsPath, searchPath: void 0 })
			}),
				(this.cmdSW = zt.create(!1)),
				this.parallel(
					e,
					(a, l) => {
						this.call(this.cmdTraversal, this, a, n, r, i, (d) => {
							if (d) {
								let c = Xn(d)
								console.error(c), this.errors.push(c), l(d, void 0)
							} else l(null, void 0)
						})
					},
					(a, l) => {
						this.fileWalkSW.stop()
						let d = a ? Ye(a)[0] : null
						s(d, this.isLimitHit)
					},
				)
		}
		parallel(e, t, n) {
			let r = new Array(e.length),
				i = new Array(e.length),
				s = !1,
				a = 0
			if (e.length === 0) return n(null, [])
			e.forEach((l, d) => {
				t(l, (c, u) => {
					if ((c ? ((s = !0), (r[d] = null), (i[d] = c)) : ((r[d] = u), (i[d] = null)), ++a === e.length))
						return n(s ? i : null, r)
				})
			})
		}
		call(e, t, ...n) {
			try {
				e.apply(t, n)
			} catch (r) {
				n[n.length - 1](r)
			}
		}
		cmdTraversal(e, t, n, r, i) {
			let s = e.folder.fsPath,
				a = st,
				l = () => f && f.kill()
			LC.add(l)
			let d = (C) => {
					LC.delete(l), (d = () => {}), i(C)
				},
				c = "",
				u = this.initDirectoryTree(),
				m = TN(
					this.config,
					e,
					this.config.includePattern,
					this.folderExcludePatterns.get(e.folder.fsPath).expression,
					t,
				),
				f = m.cmd,
				h = !Object.keys(m.siblingClauses).length,
				g = m.rgArgs.args.map((C) => (C.match(/^-/) ? C : `'${C}'`)).join(" "),
				I = `${m.rgDiskPath} ${g}
 - cwd: ${m.cwd}`
			m.rgArgs.siblingClauses &&
				(I += `
 - Sibling clauses: ${JSON.stringify(m.rgArgs.siblingClauses)}`),
				r({ message: I }),
				(this.cmdResultCount = 0),
				this.collectStdout(f, "utf8", r, (C, T, w) => {
					if (C) {
						d(C)
						return
					}
					if (this.isLimitHit) {
						d()
						return
					}
					let A = (c + (a ? Bl(T || "") : T)).split(`
`)
					if (w) {
						let J = A.length
						;(A[J - 1] = A[J - 1].trim()), A[J - 1] || A.pop()
					} else c = A.pop() || ""
					if (
						A.length &&
						A[0].indexOf(`
`) !== -1
					) {
						d(new Error("Splitting up files failed"))
						return
					}
					if (((this.cmdResultCount += A.length), h)) {
						for (let J of A)
							if (
								(this.matchFile(n, { base: s, relativePath: J, searchPath: this.getSearchPath(e, J) }),
								this.isLimitHit)
							) {
								l()
								break
							}
						;(w || this.isLimitHit) && d()
						return
					}
					this.addDirectoryEntries(e, u, s, A, n), w && (this.matchDirectoryTree(u, s, n), d())
				})
		}
		spawnFindCmd(e) {
			let t = this.folderExcludePatterns.get(e.folder.fsPath),
				n = t.getBasenameTerms(),
				r = t.getPathTerms(),
				i = ["-L", "."]
			if (n.length || r.length) {
				i.push("-not", "(", "(")
				for (let s of n) i.push("-name", s), i.push("-o")
				for (let s of r) i.push("-path", s), i.push("-o")
				i.pop(), i.push(")", "-prune", ")")
			}
			return i.push("-type", "f"), PN.spawn("find", i, { cwd: e.folder.fsPath })
		}
		readStdout(e, t, n) {
			let r = ""
			this.collectStdout(
				e,
				t,
				() => {},
				(i, s, a) => {
					if (i) {
						n(i)
						return
					}
					;(r += s), a && n(null, r)
				},
			)
		}
		collectStdout(e, t, n, r) {
			let i = (l, d, c) => {
					;(l || c) && ((i = () => {}), this.cmdSW?.stop()), r(l, d, c)
				},
				s = !1
			e.stdout
				? (this.forwardData(e.stdout, t, i), e.stdout.once("data", () => (s = !0)))
				: n({ message: "stdout is null" })
			let a
			e.stderr ? (a = this.collectData(e.stderr)) : n({ message: "stderr is null" }),
				e.on("error", (l) => {
					i(l)
				}),
				e.on("close", (l) => {
					let d
					!s && (d = this.decodeData(a, t)) && B9(d)
						? i(new Error(`command failed with error code ${l}: ${this.decodeData(a, t)}`))
						: (this.exists && l === 0 && (this.isLimitHit = !0), i(null, "", !0))
				})
		}
		forwardData(e, t, n) {
			let r = new wN(t)
			return (
				e.on("data", (i) => {
					n(null, r.write(i))
				}),
				r
			)
		}
		collectData(e) {
			let t = []
			return (
				e.on("data", (n) => {
					t.push(n)
				}),
				t
			)
		}
		decodeData(e, t) {
			let n = new wN(t)
			return e.map((r) => n.write(r)).join("")
		}
		initDirectoryTree() {
			let e = { rootEntries: [], pathToEntries: Object.create(null) }
			return (e.pathToEntries["."] = e.rootEntries), e
		}
		addDirectoryEntries(e, { pathToEntries: t }, n, r, i) {
			r.indexOf(this.filePattern) !== -1 &&
				this.matchFile(i, {
					base: n,
					relativePath: this.filePattern,
					searchPath: this.getSearchPath(e, this.filePattern),
				})
			let s = (a) => {
				let l = Ze(a),
					d = Qt(a),
					c = t[d]
				c || ((c = t[d] = []), s(d)),
					c.push({ base: n, relativePath: a, basename: l, searchPath: this.getSearchPath(e, a) })
			}
			r.forEach(s)
		}
		matchDirectoryTree({ rootEntries: e, pathToEntries: t }, n, r) {
			let i = this,
				s = this.folderExcludePatterns.get(n),
				a = this.filePattern
			function l(d) {
				i.directoriesWalked++
				let c = Bg(() => d.map((u) => u.basename))
				for (let u = 0, m = d.length; u < m; u++) {
					let f = d[u],
						{ relativePath: h, basename: g } = f
					if (s.test(h, g, a !== g ? c : void 0)) continue
					let I = t[h]
					if (I) l(I)
					else {
						if ((i.filesWalked++, h === a)) continue
						i.matchFile(r, f)
					}
					if (i.isLimitHit) break
				}
			}
			l(e)
		}
		getStats() {
			return {
				cmdTime: this.cmdSW.elapsed(),
				fileWalkTime: this.fileWalkSW.elapsed(),
				directoriesWalked: this.directoriesWalked,
				filesWalked: this.filesWalked,
				cmdResultCount: this.cmdResultCount,
			}
		}
		doWalk(e, t, n, r, i) {
			let s = e.folder,
				a = Bg(() => n)
			this.parallel(
				n,
				(l, d) => {
					if (this.isCanceled || this.isLimitHit) return d(null)
					let c = t ? [t, l].join(at) : l
					if (
						this.folderExcludePatterns
							.get(e.folder.fsPath)
							.test(c, l, this.config.filePattern !== l ? a : void 0)
					)
						return d(null)
					let u = [s.fsPath, c].join(at)
					mm.lstat(u, (m, f) => {
						if (m || this.isCanceled || this.isLimitHit) return d(null)
						this.statLinkIfNeeded(u, f, (h, g) =>
							h || this.isCanceled || this.isLimitHit
								? d(null)
								: g.isDirectory()
									? (this.directoriesWalked++,
										this.realPathIfNeeded(u, f, (I, C) =>
											I ||
											this.isCanceled ||
											this.isLimitHit ||
											((C = C || ""), this.walkedPaths[C])
												? d(null)
												: ((this.walkedPaths[C] = !0),
													Qe.readdir(u).then(
														(T) => {
															if (this.isCanceled || this.isLimitHit) return d(null)
															this.doWalk(e, c, T, r, (w) => d(w || null))
														},
														(T) => {
															d(null)
														},
													)),
										))
									: (this.filesWalked++,
										c === this.filePattern ||
											(this.maxFilesize && fn(g.size) && g.size > this.maxFilesize) ||
											this.matchFile(r, {
												base: s.fsPath,
												relativePath: c,
												searchPath: this.getSearchPath(e, c),
											}),
										d(null, void 0)),
						)
					})
				},
				(l) => {
					let d = l && Ye(l)
					return i(d && d.length > 0 ? d[0] : void 0)
				},
			)
		}
		matchFile(e, t) {
			this.isFileMatch(t) &&
				(!this.includePattern || this.includePattern(t.relativePath, Ze(t.relativePath))) &&
				(this.resultCount++,
				(this.exists || (this.maxResults && this.resultCount > this.maxResults)) && (this.isLimitHit = !0),
				this.isLimitHit || e(t))
		}
		isFileMatch(e) {
			if (this.filePattern) {
				if (this.filePattern === "*") return !0
				if (this.normalizedFilePatternLowercase) return Vg(e, this.normalizedFilePatternLowercase)
				if (this.filePattern) return Vg(e, this.filePattern, !1)
			}
			return !0
		}
		statLinkIfNeeded(e, t, n) {
			return t.isSymbolicLink() ? mm.stat(e, n) : n(null, t)
		}
		realPathIfNeeded(e, t, n) {
			return t.isSymbolicLink() ? mm.realpath(e, (r, i) => (r ? n(r) : n(null, i))) : n(null, e)
		}
		getSearchPath(e, t) {
			return e.folderName ? Fe(e.folderName, t) : t
		}
	},
	yh = class {
		constructor(e, t) {
			;(this.folderQueries = e.folderQueries),
				(this.extraFiles = e.extraFileResources || []),
				(this.numThreads = t),
				(this.walker = new KR(e))
		}
		search(e, t, n) {
			this.walker.walk(this.folderQueries, this.extraFiles, this.numThreads, e, t, (r, i) => {
				n(r, { limitHit: i, stats: this.walker.getStats(), messages: [] })
			})
		}
		cancel() {
			this.walker.cancel()
		}
	},
	jR = class {
		constructor(e, t) {
			this.expression = e
			this.root = t
			this.init(e)
		}
		init(e) {
			let t, n
			Object.keys(e)
				.filter((r) => e[r])
				.forEach((r) => {
					In(r) ? ((t = t || r_()), (t[r] = e[r])) : ((n = n || r_()), (n[r] = e[r]))
				}),
				(this.absoluteParsedExpr = t && Yn(t, { trimForExclusions: !0 })),
				(this.relativeParsedExpr = n && Yn(n, { trimForExclusions: !0 }))
		}
		test(e, t, n) {
			return (
				(this.relativeParsedExpr && this.relativeParsedExpr(e, t, n)) ||
				(this.absoluteParsedExpr && this.absoluteParsedExpr(Fe(this.root, e), t, n))
			)
		}
		getBasenameTerms() {
			let e = []
			return (
				this.absoluteParsedExpr && e.push(...i_(this.absoluteParsedExpr)),
				this.relativeParsedExpr && e.push(...i_(this.relativeParsedExpr)),
				e
			)
		}
		getPathTerms() {
			let e = []
			return (
				this.absoluteParsedExpr && e.push(...s_(this.absoluteParsedExpr)),
				this.relativeParsedExpr && e.push(...s_(this.relativeParsedExpr)),
				e
			)
		}
	}
function B9(o) {
	let e = o.trim().split(`
`),
		t = e[0].trim()
	if (t.startsWith("Error parsing regex")) return t
	if (t.startsWith("regex parse error")) return eO(e[e.length - 1].trim())
	if (t.startsWith("error parsing glob") || t.startsWith("unsupported encoding"))
		return t.charAt(0).toUpperCase() + t.substr(1)
	if (t === "Literal '\\n' not allowed.") return "Literal '\\n' currently not supported"
	if (t.startsWith("Literal ")) return t
}
import * as RN from "child_process"
import { EventEmitter as $9 } from "events"
import { StringDecoder as z9 } from "string_decoder"
import { RegExpParser as q9, RegExpVisitor as K9 } from "vscode-regexpp"
import { rgPath as j9 } from "@vscode/ripgrep"
var _N = j9.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked"),
	fm = class {
		constructor(e, t) {
			this.outputChannel = e
			this._numThreads = t
		}
		provideTextSearchResults(e, t, n, r) {
			return Promise.all(
				t.folderOptions.map((i) => {
					let s = {
						folderOptions: i,
						numThreads: this._numThreads,
						maxResults: t.maxResults,
						previewOptions: t.previewOptions,
						maxFileSize: t.maxFileSize,
						surroundingContext: t.surroundingContext,
					}
					return this.provideTextSearchResultsWithRgOptions(e, s, n, r)
				}),
			).then((i) => ({ limitHit: i.some((a) => !!a && a.limitHit) }))
		}
		provideTextSearchResultsWithRgOptions(e, t, n, r) {
			return (
				this.outputChannel.appendLine(
					`provideTextSearchResults ${e.pattern}, ${JSON.stringify({ ...t, folder: t.folderOptions.folder.toString() })}`,
				),
				new Promise((i, s) => {
					r.onCancellationRequested(() => g())
					let a = { ...t, numThreads: this._numThreads },
						l = J9(e, a),
						d = t.folderOptions.folder.fsPath,
						c = l.map((L) => (L.match(/^-/) ? L : `'${L}'`)).join(" ")
					this.outputChannel.appendLine(`${_N} ${c}
 - cwd: ${d}`)
					let u = RN.spawn(_N, l, { cwd: d })
					u.on("error", (L) => {
						console.error(L),
							this.outputChannel.appendLine("Error: " + (L && L.message)),
							s(hk(new Mi(L && L.message, 5)))
					})
					let m = !1,
						f = new GR(t.maxResults ?? ol, t.folderOptions.folder, RR(t.previewOptions))
					f.on("result", (L) => {
						;(m = !0), (C = ""), n.report(L)
					})
					let h = !1,
						g = () => {
							;(h = !0), u?.kill(), f?.cancel()
						},
						I = !1
					f.on("hitLimit", () => {
						;(I = !0), g()
					})
					let C = ""
					u.stdout.on("data", (L) => {
						f.handleData(L), m || (C += L)
					})
					let T = !1
					u.stdout.once("data", () => (T = !0))
					let w = ""
					u.stderr.on("data", (L) => {
						let A = L.toString()
						this.outputChannel.appendLine(A), w.length + A.length < 1e6 && (w += A)
					}),
						u.on("close", () => {
							if (
								(this.outputChannel.appendLine(T ? "Got data from stdout" : "No data from stdout"),
								this.outputChannel.appendLine(m ? "Got result from parser" : "No result from parser"),
								C && this.outputChannel.appendLine(`Got data without result: ${C}`),
								this.outputChannel.appendLine(""),
								h)
							)
								i({ limitHit: I })
							else {
								f.flush(), (u = null)
								let L
								w && !T && (L = G9(w)) ? s(hk(new Mi(L.message, L.code))) : i({ limitHit: I })
							}
						})
				})
			)
		}
	}
function G9(o) {
	let e = o.split(`
`),
		t = e[0].trim()
	if (e.some((r) => r.startsWith("regex parse error"))) return new Mi(Q9(e), 2)
	let n = t.match(/grep config error: unknown encoding: (.*)/)
	if (n) return new Mi(`Unknown encoding: ${n[1]}`, 1)
	if (t.startsWith("error parsing glob")) return new Mi(t.charAt(0).toUpperCase() + t.substr(1), 3)
	if (t.startsWith("the literal")) return new Mi(t.charAt(0).toUpperCase() + t.substr(1), 4)
	if (t.startsWith("PCRE2: error compiling pattern")) return new Mi(t, 2)
}
function Q9(o) {
	let e = ["Regex parse error"],
		t = o.filter((n) => n.startsWith("PCRE2:"))
	if (t.length >= 1) {
		let n = t[0].replace("PCRE2:", "")
		if (n.indexOf(":") !== -1 && n.split(":").length >= 2) {
			let r = n.split(":")[1]
			e.push(":" + r)
		}
	}
	return e.join("")
}
var GR = class extends $9 {
	constructor(t, n, r) {
		super()
		this.maxResults = t
		this.root = n
		this.previewOptions = r
		this.remainder = ""
		this.isDone = !1
		this.hitLimit = !1
		this.numResults = 0
		this.stringDecoder = new z9()
	}
	cancel() {
		this.isDone = !0
	}
	flush() {
		this.handleDecodedData(this.stringDecoder.end())
	}
	on(t, n) {
		return super.on(t, n), this
	}
	handleData(t) {
		if (this.isDone) return
		let n = typeof t == "string" ? t : this.stringDecoder.write(t)
		this.handleDecodedData(n)
	}
	handleDecodedData(t) {
		let n = t.indexOf(`
`),
			r = this.remainder + t
		if (n >= 0) n += this.remainder.length
		else {
			this.remainder = r
			return
		}
		let i = 0
		for (; n >= 0; )
			this.handleLine(r.substring(i, n).trim()),
				(i = n + 1),
				(n = r.indexOf(
					`
`,
					i,
				))
		this.remainder = r.substring(i)
	}
	handleLine(t) {
		if (this.isDone || !t) return
		let n
		try {
			n = JSON.parse(t)
		} catch {
			throw new Error(`malformed line from rg: ${t}`)
		}
		if (n.type === "match") {
			let r = Ih(n.data.path),
				i = b.joinPath(this.root, r),
				s = this.createTextSearchMatch(n.data, i)
			this.onResult(s), this.hitLimit && (this.cancel(), this.emit("hitLimit"))
		} else if (n.type === "context") {
			let r = Ih(n.data.path),
				i = b.joinPath(this.root, r)
			this.createTextSearchContexts(n.data, i).forEach((a) => this.onResult(a))
		}
	}
	createTextSearchMatch(t, n) {
		let r = t.line_number - 1,
			i = Ih(t.lines),
			s = Buffer.from(i),
			a = 0,
			l = 0,
			d = r
		t.submatches.length === 0 &&
			t.submatches.push(
				i.length ? { start: 0, end: 1, match: { text: i[0] } } : { start: 0, end: 0, match: { text: "" } },
			)
		let c = Ye(
				t.submatches.map((f, h) => {
					if (this.hitLimit) return null
					this.numResults++, this.numResults >= this.maxResults && (this.hitLimit = !0)
					let g = Ih(f.match),
						I = s.slice(a, f.start).toString(),
						C = DN(I),
						T = C.numLines > 0 ? C.lastLineLength : C.lastLineLength + l,
						w = DN(g),
						L = C.numLines + d,
						A = w.numLines + L,
						J = w.numLines > 0 ? w.lastLineLength : w.lastLineLength + T
					return (a = f.end), (l = J), (d = A), new op(L, T, A, J)
				}),
			),
			u = Rl(c, xN),
			m = new ip(i, u, this.previewOptions)
		return new ur(
			n,
			m.rangeLocations.map((f) => ({ sourceRange: qR(f.source), previewRange: qR(f.preview) })),
			m.previewText,
		)
	}
	createTextSearchContexts(t, n) {
		let r = Ih(t.lines),
			i = t.line_number
		return r
			.replace(/\r?\n$/, "")
			.split(
				`
`,
			)
			.map((s, a) => new Li(n, s, i + a))
	}
	onResult(t) {
		this.emit("result", t)
	}
}
function Ih(o) {
	return o.bytes ? Buffer.from(o.bytes, "base64").toString() : o.text
}
function DN(o) {
	let e = /\n/g,
		t = 0,
		n = -1,
		r
	for (; (r = e.exec(o)); ) t++, (n = r.index)
	let i = n >= 0 ? o.length - n - 1 : o.length
	return { numLines: t, lastLineLength: i }
}
function J9(o, e) {
	let t = ["--hidden", "--no-require-git"]
	t.push(o.isCaseSensitive ? "--case-sensitive" : "--ignore-case")
	let { doubleStarIncludes: n, otherIncludes: r } = pc(e.folderOptions.includes, (s) =>
		s.startsWith("**") ? "doubleStarIncludes" : "otherIncludes",
	)
	if (r && r.length) {
		let s = new Set()
		r.forEach((a) => {
			s.add(a)
		}),
			t.push("-g", "!*"),
			s.forEach((a) => {
				X9(a)
					.map(pm)
					.forEach((l) => {
						t.push("-g", l)
					})
			})
	}
	n &&
		n.length &&
		n.forEach((s) => {
			t.push("-g", s)
		}),
		e.folderOptions.excludes
			.map((s) => (typeof s == "string" ? s : s.pattern))
			.map(pm)
			.forEach((s) => t.push("-g", `!${s}`)),
		e.maxFileSize && t.push("--max-filesize", e.maxFileSize + ""),
		e.folderOptions.useIgnoreFiles.local
			? e.folderOptions.useIgnoreFiles.parent || t.push("--no-ignore-parent")
			: t.push("--no-ignore"),
		e.folderOptions.followSymlinks && t.push("--follow"),
		e.folderOptions.encoding &&
			e.folderOptions.encoding !== "utf8" &&
			t.push("--encoding", e.folderOptions.encoding),
		e.numThreads && t.push("--threads", `${e.numThreads}`),
		o.pattern === "--" && ((o.isRegExp = !0), (o.pattern = "\\-\\-")),
		o.isMultiline && !o.isRegExp && ((o.pattern = kr(o.pattern)), (o.isRegExp = !0)),
		e.usePCRE2 && t.push("--pcre2"),
		t.push("--crlf"),
		o.isRegExp && ((o.pattern = Y9(o.pattern)), t.push("--engine", "auto"))
	let i
	if (o.isWordMatch) {
		let a = Mv(o.pattern, !!o.isRegExp, { wholeWord: o.isWordMatch }).source.replace(/\\\//g, "/")
		t.push("--regexp", a)
	} else if (o.isRegExp) {
		let s = Z9(o.pattern)
		;(s = eB(s)), t.push("--regexp", s)
	} else (i = o.pattern), t.push("--fixed-strings")
	return (
		t.push("--no-config"),
		e.folderOptions.useIgnoreFiles.global || t.push("--no-ignore-global"),
		t.push("--json"),
		o.isMultiline && t.push("--multiline"),
		e.surroundingContext &&
			(t.push("--before-context", e.surroundingContext + ""),
			t.push("--after-context", e.surroundingContext + "")),
		t.push("--"),
		i && t.push(i),
		t.push("."),
		t
	)
}
function X9(o) {
	return AN(o).flatMap((t) => {
		let n = sd(t, "/")
		return n.map((r, i) => n.slice(0, i + 1).join("/"))
	})
}
function Y9(o) {
	let e = /((?:[^\\]|^)(?:\\\\)*)\\u([a-z0-9]{4})/gi
	for (; o.match(e); ) o = o.replace(e, "$1\\x{$2}")
	let t = /((?:[^\\]|^)(?:\\\\)*)\\u\{([a-z0-9]{4})\}/gi
	for (; o.match(t); ) o = o.replace(t, "$1\\x{$2}")
	return o
}
var kN = (o) => o.type === "Assertion" && o.kind === "lookbehind"
function Z9(o) {
	let e
	try {
		e = new q9().parsePattern(o)
	} catch {
		return o
	}
	let t = "",
		n = 0,
		r = (a, l, d) => {
			;(t += o.slice(n, a) + d), (n = l)
		},
		i = []
	return (
		new K9({
			onCharacterEnter(a) {
				if (a.raw !== "\\n") return
				let l = i[0]
				if (!l) r(a.start, a.end, "\\r?\\n")
				else if (!i.some(kN))
					if (l.type === "CharacterClass")
						if (l.negate) {
							let d = o.slice(l.start + 2, a.start) + o.slice(a.end, l.end - 1)
							l.parent?.type === "Quantifier"
								? r(l.start, l.end, d ? `[^${d}]` : ".")
								: r(l.start, l.end, "(?!\\r?\\n" + (d ? `|[${d}]` : "") + ")")
						} else {
							let d = o.slice(l.start + 1, a.start) + o.slice(a.end, l.end - 1)
							r(l.start, l.end, d === "" ? "\\r?\\n" : `(?:[${d}]|\\r?\\n)`)
						}
					else l.type === "Quantifier" && r(a.start, a.end, "(?:\\r?\\n)")
			},
			onQuantifierEnter(a) {
				i.unshift(a)
			},
			onQuantifierLeave() {
				i.shift()
			},
			onCharacterClassRangeEnter(a) {
				i.unshift(a)
			},
			onCharacterClassRangeLeave() {
				i.shift()
			},
			onCharacterClassEnter(a) {
				i.unshift(a)
			},
			onCharacterClassLeave() {
				i.shift()
			},
			onAssertionEnter(a) {
				kN(a) && i.push(a)
			},
			onAssertionLeave(a) {
				i[0] === a && i.shift()
			},
		}).visit(e),
		(t += o.slice(n)),
		t
	)
}
function eB(o) {
	return o.replace(/\n/g, "\\r?\\n")
}
function tB(o) {
	let e = !1,
		t = !1,
		n = "",
		r = ""
	for (let i = 0; i < o.length; i++) {
		let s = o[i]
		switch (s) {
			case "\\":
				t ? (e ? (r += "\\" + s) : (n += "\\" + s), (t = !1)) : (t = !0)
				break
			case "{":
				if (t) e ? (r += s) : (n += s), (t = !1)
				else {
					if (e) return { strInBraces: n + "{" + r + "{" + o.substring(i + 1) }
					e = !0
				}
				break
			case "}":
				if (t) e ? (r += s) : (n += s), (t = !1)
				else {
					if (e) return { fixedStart: n, strInBraces: r, fixedEnd: o.substring(i + 1) }
					n += s
				}
				break
			default:
				e ? (r += (t ? "\\" : "") + s) : (n += (t ? "\\" : "") + s), (t = !1)
				break
		}
	}
	return { strInBraces: n + (e ? "{" + r : "") }
}
function AN(o) {
	let { fixedStart: e, strInBraces: t, fixedEnd: n } = tB(o)
	if (e === void 0 || n === void 0) return [t]
	let r = sd(t, ",")
	r.length || (r = [""])
	let i = AN(n)
	return r.flatMap((s) => {
		let a = e + s
		return i.map((l) => a + l)
	})
}
var gm = class extends Vd {
	constructor(e, t, n = Uo, r = "searchProcess") {
		super(
			{ query: e, provider: t },
			{ readdir: (i) => n.Promises.readdir(i.fsPath), toCanonicalName: (i) => YF(i) },
			r,
		)
	}
}
var MC = class {
	constructor(e, t) {
		this.query = e
		this.numThreads = t
	}
	search(e, t, n) {
		if (
			(!this.query.folderQueries || !this.query.folderQueries.length) &&
			(!this.query.extraFileResources || !this.query.extraFileResources.length)
		)
			return Promise.resolve({ type: "success", limitHit: !1, stats: { type: "searchProcess" }, messages: [] })
		let r = {
				appendLine(s) {
					n({ message: s })
				},
			},
			i = new gm(this.query, new fm(r, this.numThreads), Uo)
		return new Promise((s, a) =>
			i
				.search((l) => {
					t(l.map(nB))
				}, e)
				.then((l) => s({ limitHit: l.limitHit ?? !1, type: "success", stats: l.stats, messages: [] }), a),
		)
	}
}
function nB(o) {
	return {
		path: o.resource && o.resource.fsPath,
		results: o.results,
		numMatches: (o.results || []).reduce((e, t) => (Wg(t) ? e + t.rangeLocations.length : e + 1), 0),
	}
}
var FC = class o {
		constructor(e = "searchProcess", t) {
			this.processType = e
			this.getNumThreads = t
			this.caches = Object.create(null)
		}
		static {
			this.BATCH_SIZE = 512
		}
		fileSearch(e) {
			let t,
				n = ON(e),
				r = new E({
					onDidAddFirstListener: () => {
						;(t = Ar(async (i) => {
							let s = await this.getNumThreads?.()
							return this.doFileSearchWithEngine(yh, n, (a) => r.fire(a), i, o.BATCH_SIZE, s)
						})),
							t.then(
								(i) => r.fire(i),
								(i) => r.fire({ type: "error", error: { message: i.message, stack: i.stack } }),
							)
					},
					onDidRemoveLastListener: () => {
						t.cancel()
					},
				})
			return r.event
		}
		textSearch(e) {
			let t,
				n = ON(e),
				r = new E({
					onDidAddFirstListener: () => {
						;(t = Ar((i) => this.ripgrepTextSearch(n, (s) => r.fire(s), i))),
							t.then(
								(i) => r.fire(i),
								(i) => r.fire({ type: "error", error: { message: i.message, stack: i.stack } }),
							)
					},
					onDidRemoveLastListener: () => {
						t.cancel()
					},
				})
			return r.event
		}
		async ripgrepTextSearch(e, t, n) {
			e.maxFileSize = this.getPlatformFileLimits().maxFileSize
			let r = await this.getNumThreads?.()
			return new MC(e, r).search(n, t, t)
		}
		getPlatformFileLimits() {
			return { maxFileSize: 16 * Bc.GB }
		}
		doFileSearch(e, t, n, r) {
			return this.doFileSearchWithEngine(yh, e, n, r, o.BATCH_SIZE, t)
		}
		doFileSearchWithEngine(e, t, n, r, i = o.BATCH_SIZE, s) {
			let a = 0,
				l = (c) => {
					Array.isArray(c)
						? ((a += c.length), n(c.map((u) => this.rawMatchToSearchItem(u))))
						: c.relativePath
							? (a++, n(this.rawMatchToSearchItem(c)))
							: n(c)
				}
			if (t.sortByScore) {
				let c = this.trySortedSearchFromCache(t, l, r)
				if (!c) {
					let u = t.maxResults ? Object.assign({}, t, { maxResults: null }) : t,
						m = new e(u, s)
					c = this.doSortedSearch(m, t, n, l, r)
				}
				return new Promise((u, m) => {
					c.then(([f, h]) => {
						let g = h.map((I) => this.rawMatchToSearchItem(I))
						this.sendProgress(g, n, i), u(f)
					}, m)
				})
			}
			let d = new e(t, s)
			return this.doSearch(d, l, i, r).then((c) => ({
				limitHit: c.limitHit,
				type: "success",
				stats: {
					detailStats: c.stats,
					type: this.processType,
					fromCache: !1,
					resultCount: a,
					sortingTime: void 0,
				},
				messages: [],
			}))
		}
		rawMatchToSearchItem(e) {
			return { path: e.base ? Fe(e.base, e.relativePath) : e.relativePath }
		}
		doSortedSearch(e, t, n, r, i) {
			let s = new E(),
				a = Ar((d) => {
					let c = [],
						u = (m) => {
							Array.isArray(m) ? (c = m) : (r(m), s.fire(m))
						}
					return this.doSearch(e, u, -1, d).then((m) => [m, c])
				}),
				l
			if (t.cacheKey) {
				l = this.getOrCreateCache(t.cacheKey)
				let d = { promise: a, event: s.event, resolved: !1 }
				;(l.resultsToSearchCache[t.filePattern || ""] = d),
					a.then(
						() => {
							d.resolved = !0
						},
						(c) => {
							delete l.resultsToSearchCache[t.filePattern || ""]
						},
					),
					(a = this.preventCancellation(a))
			}
			return a.then(([d, c]) => {
				let u = l ? l.scorerCache : Object.create(null),
					m = (typeof t.maxResults != "number" || t.maxResults > 0) && zt.create(!1)
				return this.sortResults(t, c, u, i).then((f) => {
					let h = m ? m.elapsed() : -1
					return [
						{
							type: "success",
							stats: {
								detailStats: d.stats,
								sortingTime: h,
								fromCache: !1,
								type: this.processType,
								resultCount: f.length,
							},
							messages: d.messages,
							limitHit: d.limitHit || (typeof t.maxResults == "number" && c.length > t.maxResults),
						},
						f,
					]
				})
			})
		}
		getOrCreateCache(e) {
			let t = this.caches[e]
			return t || (this.caches[e] = new QR())
		}
		trySortedSearchFromCache(e, t, n) {
			let r = e.cacheKey && this.caches[e.cacheKey]
			if (!r) return
			let i = this.getResultsFromCache(r, e.filePattern || "", t, n)
			if (i)
				return i.then(([s, a, l]) => {
					let d = zt.create(!1)
					return this.sortResults(e, a, r.scorerCache, n).then((c) => {
						let u = d.elapsed(),
							m = {
								fromCache: !0,
								detailStats: l,
								type: this.processType,
								resultCount: a.length,
								sortingTime: u,
							}
						return [
							{
								type: "success",
								limitHit: s.limitHit || (typeof e.maxResults == "number" && a.length > e.maxResults),
								stats: m,
								messages: [],
							},
							c,
						]
					})
				})
		}
		sortResults(e, t, n, r) {
			let i = bh(e.filePattern || ""),
				s = (l, d) => IN(l, d, i, !0, rB, n),
				a = typeof e.maxResults == "number" ? e.maxResults : ol
			return Q0(t, s, a, 1e4, r)
		}
		sendProgress(e, t, n) {
			if (n && n > 0) for (let r = 0; r < e.length; r += n) t(e.slice(r, r + n))
			else t(e)
		}
		getResultsFromCache(e, t, n, r) {
			let i = zt.create(!1),
				s = t.indexOf(at) >= 0,
				a
			for (let u in e.resultsToSearchCache)
				if (t.startsWith(u)) {
					if (s && u.indexOf(at) < 0 && u !== "") continue
					let m = e.resultsToSearchCache[u]
					a = { promise: this.preventCancellation(m.promise), event: m.event, resolved: m.resolved }
					break
				}
			if (!a) return null
			let l = i.elapsed(),
				d = zt.create(!1),
				c = a.event(n)
			return (
				r &&
					r.onCancellationRequested(() => {
						c.dispose()
					}),
				a.promise.then(([u, m]) => {
					if (r && r.isCancellationRequested) throw Ki()
					let f = [],
						h = bh(t).normalizedLowercase
					for (let g of m) Vg(g, h) && f.push(g)
					return [
						u,
						f,
						{
							cacheWasResolved: a.resolved,
							cacheLookupTime: l,
							cacheFilterTime: d.elapsed(),
							cacheEntryCount: m.length,
						},
					]
				})
			)
		}
		doSearch(e, t, n, r) {
			return new Promise((i, s) => {
				let a = []
				r?.onCancellationRequested(() => e.cancel()),
					e.search(
						(l) => {
							l && (n ? (a.push(l), n > 0 && a.length >= n && (t(a), (a = []))) : t(l))
						},
						(l) => {
							t(l)
						},
						(l, d) => {
							a.length && t(a),
								l
									? (t({ message: "Search finished. Error: " + l.message }), s(l))
									: (t({ message: "Search finished. Stats: " + JSON.stringify(d.stats) }), i(d))
						},
					)
			})
		}
		clearCache(e) {
			return delete this.caches[e], Promise.resolve(void 0)
		}
		preventCancellation(e) {
			return new (class {
				get [Symbol.toStringTag]() {
					return this.toString()
				}
				cancel() {}
				then(t, n) {
					return e.then(t, n)
				}
				catch(t) {
					return this.then(void 0, t)
				}
				finally(t) {
					return e.finally(t)
				}
			})()
		}
	},
	QR = class {
		constructor() {
			this.resultsToSearchCache = Object.create(null)
			this.scorerCache = Object.create(null)
		}
	},
	rB = new (class {
		getItemLabel(o) {
			return Ze(o.relativePath)
		}
		getItemDescription(o) {
			return Qt(o.relativePath)
		}
		getItemPath(o) {
			return o.relativePath
		}
	})()
function ON(o) {
	return {
		...o,
		folderQueries: o.folderQueries && o.folderQueries.map(oB),
		extraFileResources: o.extraFileResources && o.extraFileResources.map((e) => b.revive(e)),
	}
}
function oB(o) {
	return ut(o)
}
var xh = class {
	constructor(e, t) {
		this.outputChannel = e
		this.getNumThreads = t
		this.inProgress = new Set()
		process.once("exit", () => this.dispose())
	}
	async provideTextSearchResults(e, t, n, r) {
		let i = await this.getNumThreads(),
			s = new fm(this.outputChannel, i)
		return Promise.all(
			t.folderOptions.map((a) => {
				let l = {
					folderOptions: a,
					numThreads: i,
					maxResults: t.maxResults,
					previewOptions: t.previewOptions,
					maxFileSize: t.maxFileSize,
					surroundingContext: t.surroundingContext,
				}
				if (a.folder.scheme === W.vscodeUserData) {
					let d = { ...l, folder: a.folder.with({ scheme: W.file }) },
						c = new xa((u) => n.report({ ...u, uri: u.uri.with({ scheme: a.folder.scheme }) }))
					return this.withToken(r, (u) => s.provideTextSearchResultsWithRgOptions(e, d, c, u))
				} else return this.withToken(r, (d) => s.provideTextSearchResultsWithRgOptions(e, l, n, d))
			}),
		).then((a) => ({ limitHit: a.some((d) => !!d && d.limitHit) }))
	}
	async withToken(e, t) {
		let n = iB(e)
		this.inProgress.add(n)
		let r = await t(n.token)
		return this.inProgress.delete(n), r
	}
	dispose() {
		this.inProgress.forEach((e) => e.cancel())
	}
}
function iB(o) {
	let e = new _e()
	return o.onCancellationRequested(() => e.cancel()), e
}
var hm = class extends hl {
	constructor(t, n, r, i, s) {
		super(t, r, s)
		this.configurationService = i
		this._pfs = Uo
		this._internalFileSearchHandle = -1
		this._internalFileSearchProvider = null
		this._registeredEHSearchProvider = !1
		this._disposables = new Q()
		this.isDisposed = !1
		;(this.getNumThreads = this.getNumThreads.bind(this)),
			(this.getNumThreadsCached = this.getNumThreadsCached.bind(this)),
			(this.handleConfigurationChanged = this.handleConfigurationChanged.bind(this))
		let a = new qd("RipgrepSearchUD", this._logService)
		this._disposables.add(this.registerTextSearchProvider(W.vscodeUserData, new xh(a, this.getNumThreadsCached))),
			n.remote.isRemote && n.remote.authority && this._registerEHSearchProviders(),
			i.getConfigProvider().then((l) => {
				this.isDisposed || this._disposables.add(l.onDidChangeConfiguration(this.handleConfigurationChanged))
			})
	}
	handleConfigurationChanged(t) {
		t.affectsConfiguration("search") && (this._numThreadsPromise = void 0)
	}
	async getNumThreads() {
		return (await this.configurationService.getConfigProvider())
			.getConfiguration("search")
			.get("ripgrep.maxThreads")
	}
	async getNumThreadsCached() {
		return this._numThreadsPromise || (this._numThreadsPromise = this.getNumThreads()), this._numThreadsPromise
	}
	dispose() {
		;(this.isDisposed = !0), this._disposables.dispose()
	}
	$enableExtensionHostSearch() {
		this._registerEHSearchProviders()
	}
	_registerEHSearchProviders() {
		if (this._registeredEHSearchProvider) return
		this._registeredEHSearchProvider = !0
		let t = new qd("RipgrepSearchEH", this._logService)
		this._disposables.add(this.registerTextSearchProvider(W.file, new xh(t, this.getNumThreadsCached))),
			this._disposables.add(
				this.registerInternalFileSearchProvider(W.file, new FC("fileSearchProvider", this.getNumThreadsCached)),
			)
	}
	registerInternalFileSearchProvider(t, n) {
		let r = this._handlePool++
		return (
			(this._internalFileSearchProvider = n),
			(this._internalFileSearchHandle = r),
			this._proxy.$registerFileSearchProvider(r, this._transformScheme(t)),
			q(() => {
				;(this._internalFileSearchProvider = null), this._proxy.$unregisterProvider(r)
			})
		)
	}
	$provideFileSearchResults(t, n, r, i) {
		let s = ch(r)
		if (t === this._internalFileSearchHandle) {
			let a = Date.now()
			return this.doInternalFileSearch(t, n, s, i).then((l) => {
				let d = Date.now() - a
				return this._logService.debug(`Ext host file search time: ${d}ms`), l
			})
		}
		return super.$provideFileSearchResults(t, n, r, i)
	}
	async doInternalFileSearchWithCustomCallback(t, n, r) {
		let i = (a) => {
			if ((qF(a) && (a = [a]), Array.isArray(a))) {
				r(a.map((l) => b.file(l.path)))
				return
			}
			a.message && this._logService.debug("ExtHostSearch", a.message)
		}
		if (!this._internalFileSearchProvider) throw new Error("No internal file search handler")
		let s = await this.getNumThreadsCached()
		return this._internalFileSearchProvider.doFileSearch(t, s, i, n)
	}
	async doInternalFileSearch(t, n, r, i) {
		return this.doInternalFileSearchWithCustomCallback(r, i, (s) => {
			this._proxy.$handleFileMatch(t, n, s)
		})
	}
	$clearCache(t) {
		return this._internalFileSearchProvider?.clearCache(t), super.$clearCache(t)
	}
	createTextSearchManager(t, n) {
		return new gm(t, n, void 0, "textSearchProvider")
	}
}
hm = R([S(0, ie), S(1, Xe), S(2, fi), S(3, pn), S(4, te)], hm)
function JR(o, e, t, n, r, i) {
	if (Array.isArray(o)) {
		let s = 0
		for (let a of o) {
			let l = JR(a, e, t, n, r, i)
			if (l === 10) return l
			l > s && (s = l)
		}
		return s
	} else {
		if (typeof o == "string") return n ? (o === "*" ? 5 : o === t ? 10 : 0) : 0
		if (o) {
			let { language: s, pattern: a, scheme: l, hasAccessToAllModels: d, notebookType: c } = o
			if (!n && !d) return 0
			c && r && (e = r)
			let u = 0
			if (l)
				if (l === e.scheme) u = 10
				else if (l === "*") u = 5
				else return 0
			if (s)
				if (s === t) u = 10
				else if (s === "*") u = Math.max(u, 5)
				else return 0
			if (c)
				if (c === i) u = 10
				else if (c === "*" && i !== void 0) u = Math.max(u, 5)
				else return 0
			if (a) {
				let m
				if (
					(typeof a == "string" ? (m = a) : (m = { ...a, base: Gn(a.base) }),
					m === e.fsPath || yi(m, e.fsPath))
				)
					u = 10
				else return 0
			}
			return u
		} else return 0
	}
}
function XR(o) {
	return typeof o == "string" ? !1 : Array.isArray(o) ? o.some(XR) : !!o.notebookType
}
var YR = ((r) => (
	(r[(r.None = 0)] = "None"),
	(r[(r.Indent = 1)] = "Indent"),
	(r[(r.IndentOutdent = 2)] = "IndentOutdent"),
	(r[(r.Outdent = 3)] = "Outdent"),
	r
))(YR || {})
var fMe = O("editSessionIdentityService"),
	ZR = ((n) => (
		(n[(n.Complete = 100)] = "Complete"), (n[(n.Partial = 50)] = "Partial"), (n[(n.None = 0)] = "None"), n
	))(ZR || {})
var NC = class {
	constructor(e) {
		this._relatedInformationProviders = new Map()
		this._nextHandle = 0
		this._proxy = e.getProxy(M.MainThreadAiRelatedInformation)
	}
	async $provideAiRelatedInformation(e, t, n) {
		if (this._relatedInformationProviders.size === 0) throw new Error("No related information providers registered")
		let r = this._relatedInformationProviders.get(e)
		if (!r) throw new Error("related information provider not found")
		return (await r.provideRelatedInformation(t, n)) ?? []
	}
	getRelatedInformation(e, t, n) {
		return this._proxy.$getAiRelatedInformation(t, n)
	}
	registerRelatedInformationProvider(e, t, n) {
		let r = this._nextHandle
		return (
			this._nextHandle++,
			this._relatedInformationProviders.set(r, n),
			this._proxy.$registerAiRelatedInformationProvider(r, t),
			new ye(() => {
				this._proxy.$unregisterAiRelatedInformationProvider(r), this._relatedInformationProviders.delete(r)
			})
		)
	}
}
function LN(o) {
	for (let e = 0, t = o.length; e < t; e += 4) {
		let n = o[e + 0],
			r = o[e + 1],
			i = o[e + 2],
			s = o[e + 3]
		;(o[e + 0] = s), (o[e + 1] = i), (o[e + 2] = r), (o[e + 3] = n)
	}
}
function aB(o) {
	let e = new Uint8Array(o.buffer, o.byteOffset, o.length * 4)
	return Pv() || LN(e), z.wrap(e)
}
function lB(o) {
	let e = o.buffer
	if ((Pv() || LN(e), e.byteOffset % 4 === 0)) return new Uint32Array(e.buffer, e.byteOffset, e.length / 4)
	{
		let t = new Uint8Array(e.byteLength)
		return t.set(e), new Uint32Array(t.buffer, t.byteOffset, t.length / 4)
	}
}
function UC(o) {
	let e = new Uint32Array(dB(o)),
		t = 0
	if (((e[t++] = o.id), o.type === "full"))
		(e[t++] = 1), (e[t++] = o.data.length), e.set(o.data, t), (t += o.data.length)
	else {
		;(e[t++] = 2), (e[t++] = o.deltas.length)
		for (let n of o.deltas)
			(e[t++] = n.start),
				(e[t++] = n.deleteCount),
				n.data ? ((e[t++] = n.data.length), e.set(n.data, t), (t += n.data.length)) : (e[t++] = 0)
	}
	return aB(e)
}
function dB(o) {
	let e = 0
	if (((e += 2), o.type === "full")) e += 1 + o.data.length
	else {
		;(e += 1), (e += 3 * o.deltas.length)
		for (let t of o.deltas) t.data && (e += t.data.length)
	}
	return e
}
function e1(o) {
	let e = lB(o),
		t = 0,
		n = e[t++]
	if (e[t++] === 1) {
		let a = e[t++],
			l = e.subarray(t, t + a)
		return (t += a), { id: n, type: "full", data: l }
	}
	let i = e[t++],
		s = []
	for (let a = 0; a < i; a++) {
		let l = e[t++],
			d = e[t++],
			c = e[t++],
			u
		c > 0 && ((u = e.subarray(t, t + c)), (t += c)), (s[a] = { start: l, deleteCount: d, data: u })
	}
	return { id: n, type: "delta", deltas: s }
}
var cB = [
		new be(
			"vscode.executeDocumentHighlights",
			"_executeDocumentHighlights",
			"Execute document highlight provider.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of DocumentHighlight-instances.", ni(Pd.to)),
		),
		new be(
			"vscode.executeDocumentSymbolProvider",
			"_executeDocumentSymbolProvider",
			"Execute document symbol provider.",
			[G.Uri],
			new ge("A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.", (o, e) => {
				if (rf(o)) return
				class t extends vo {
					static to(r) {
						let i = new t(r.name, eo.to(r.kind), r.containerName || "", new rn(e[0], H.to(r.range)))
						return (
							(i.detail = r.detail),
							(i.range = i.location.range),
							(i.selectionRange = H.to(r.selectionRange)),
							(i.children = r.children ? r.children.map(t.to) : []),
							i
						)
					}
				}
				return o.map(t.to)
			}),
		),
		new be(
			"vscode.executeFormatDocumentProvider",
			"_executeFormatDocumentProvider",
			"Execute document format provider.",
			[
				G.Uri,
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ni(on.to)),
		),
		new be(
			"vscode.executeFormatRangeProvider",
			"_executeFormatRangeProvider",
			"Execute range format provider.",
			[
				G.Uri,
				G.Range,
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ni(on.to)),
		),
		new be(
			"vscode.executeFormatOnTypeProvider",
			"_executeFormatOnTypeProvider",
			"Execute format on type provider.",
			[
				G.Uri,
				G.Position,
				new G(
					"ch",
					"Trigger character",
					(o) => typeof o == "string",
					(o) => o,
				),
				new G(
					"options",
					"Formatting options",
					(o) => !0,
					(o) => o,
				),
			],
			new ge("A promise that resolves to an array of TextEdits.", ni(on.to)),
		),
		new be(
			"vscode.executeDefinitionProvider",
			"_executeDefinitionProvider",
			"Execute all definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.experimental.executeDefinitionProvider_recursive",
			"_executeDefinitionProvider_recursive",
			"Execute all definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.executeTypeDefinitionProvider",
			"_executeTypeDefinitionProvider",
			"Execute all type definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.experimental.executeTypeDefinitionProvider_recursive",
			"_executeTypeDefinitionProvider_recursive",
			"Execute all type definition providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.executeDeclarationProvider",
			"_executeDeclarationProvider",
			"Execute all declaration providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.experimental.executeDeclarationProvider_recursive",
			"_executeDeclarationProvider_recursive",
			"Execute all declaration providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.executeImplementationProvider",
			"_executeImplementationProvider",
			"Execute all implementation providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.experimental.executeImplementationProvider_recursive",
			"_executeImplementationProvider_recursive",
			"Execute all implementation providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location or LocationLink instances.", Il),
		),
		new be(
			"vscode.executeReferenceProvider",
			"_executeReferenceProvider",
			"Execute all reference providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location-instances.", ni($n.to)),
		),
		new be(
			"vscode.experimental.executeReferenceProvider",
			"_executeReferenceProvider_recursive",
			"Execute all reference providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Location-instances.", ni($n.to)),
		),
		new be(
			"vscode.executeHoverProvider",
			"_executeHoverProvider",
			"Execute all hover providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Hover-instances.", ni(Zu.to)),
		),
		new be(
			"vscode.experimental.executeHoverProvider_recursive",
			"_executeHoverProvider_recursive",
			"Execute all hover providers.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of Hover-instances.", ni(Zu.to)),
		),
		new be(
			"vscode.executeSelectionRangeProvider",
			"_executeSelectionRangeProvider",
			"Execute selection range provider.",
			[
				G.Uri,
				new G(
					"position",
					"A position in a text document",
					(o) => Array.isArray(o) && o.every((e) => Pe.isPosition(e)),
					(o) => o.map(Je.from),
				),
			],
			new ge("A promise that resolves to an array of ranges.", (o) =>
				o.map((e) => {
					let t
					for (let n of e.reverse()) t = new Ci(H.to(n), t)
					return t
				}),
			),
		),
		new be(
			"vscode.executeWorkspaceSymbolProvider",
			"_executeWorkspaceSymbolProvider",
			"Execute all workspace symbol providers.",
			[G.String.with("query", "Search string")],
			new ge("A promise that resolves to an array of SymbolInformation-instances.", (o) => o.map(nl.to)),
		),
		new be(
			"vscode.prepareCallHierarchy",
			"_executePrepareCallHierarchy",
			"Prepare call hierarchy at a position inside a document",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of CallHierarchyItem-instances", (o) => o.map(Ws.to)),
		),
		new be(
			"vscode.provideIncomingCalls",
			"_executeProvideIncomingCalls",
			"Compute incoming calls for an item",
			[G.CallHierarchyItem],
			new ge("A promise that resolves to an array of CallHierarchyIncomingCall-instances", (o) => o.map(BD.to)),
		),
		new be(
			"vscode.provideOutgoingCalls",
			"_executeProvideOutgoingCalls",
			"Compute outgoing calls for an item",
			[G.CallHierarchyItem],
			new ge("A promise that resolves to an array of CallHierarchyOutgoingCall-instances", (o) => o.map($D.to)),
		),
		new be(
			"vscode.prepareRename",
			"_executePrepareRename",
			"Execute the prepareRename of rename provider.",
			[G.Uri, G.Position],
			new ge("A promise that resolves to a range and placeholder text.", (o) => {
				if (o) return { range: H.to(o.range), placeholder: o.text }
			}),
		),
		new be(
			"vscode.executeDocumentRenameProvider",
			"_executeDocumentRenameProvider",
			"Execute rename provider.",
			[G.Uri, G.Position, G.String.with("newName", "The new symbol name")],
			new ge("A promise that resolves to a WorkspaceEdit.", (o) => {
				if (o) {
					if (o.rejectReason) throw new Error(o.rejectReason)
					return zn.to(o)
				}
			}),
		),
		new be(
			"vscode.executeLinkProvider",
			"_executeLinkProvider",
			"Execute document link provider.",
			[
				G.Uri,
				G.Number.with(
					"linkResolveCount",
					"Number of links that should be resolved, only when links are unresolved.",
				).optional(),
			],
			new ge("A promise that resolves to an array of DocumentLink-instances.", (o) => o.map(Vs.to)),
		),
		new be(
			"vscode.provideDocumentSemanticTokensLegend",
			"_provideDocumentSemanticTokensLegend",
			"Provide semantic tokens legend for a document",
			[G.Uri],
			new ge("A promise that resolves to SemanticTokensLegend.", (o) => {
				if (o) return new Id(o.tokenTypes, o.tokenModifiers)
			}),
		),
		new be(
			"vscode.provideDocumentSemanticTokens",
			"_provideDocumentSemanticTokens",
			"Provide semantic tokens for a document",
			[G.Uri],
			new ge("A promise that resolves to SemanticTokens.", (o) => {
				if (!o) return
				let e = e1(o)
				if (e.type === "full") return new Xo(e.data, void 0)
			}),
		),
		new be(
			"vscode.provideDocumentRangeSemanticTokensLegend",
			"_provideDocumentRangeSemanticTokensLegend",
			"Provide semantic tokens legend for a document range",
			[G.Uri, G.Range.optional()],
			new ge("A promise that resolves to SemanticTokensLegend.", (o) => {
				if (o) return new Id(o.tokenTypes, o.tokenModifiers)
			}),
		),
		new be(
			"vscode.provideDocumentRangeSemanticTokens",
			"_provideDocumentRangeSemanticTokens",
			"Provide semantic tokens for a document range",
			[G.Uri, G.Range],
			new ge("A promise that resolves to SemanticTokens.", (o) => {
				if (!o) return
				let e = e1(o)
				if (e.type === "full") return new Xo(e.data, void 0)
			}),
		),
		new be(
			"vscode.executeCompletionItemProvider",
			"_executeCompletionItemProvider",
			"Execute completion item provider.",
			[
				G.Uri,
				G.Position,
				G.String.with(
					"triggerCharacter",
					"Trigger completion when the user types the character, like `,` or `(`",
				).optional(),
				G.Number.with(
					"itemResolveCount",
					"Number of completions to resolve (too large numbers slow down completions)",
				).optional(),
			],
			new ge("A promise that resolves to a CompletionList-instance.", (o, e, t) => {
				if (!o) return new zo([])
				let n = o.suggestions.map((r) => jD.to(r, t))
				return new zo(n, o.incomplete)
			}),
		),
		new be(
			"vscode.executeSignatureHelpProvider",
			"_executeSignatureHelpProvider",
			"Execute signature help provider.",
			[
				G.Uri,
				G.Position,
				G.String.with(
					"triggerCharacter",
					"Trigger signature help when the user types the character, like `,` or `(`",
				).optional(),
			],
			new ge("A promise that resolves to SignatureHelp.", (o) => {
				if (o) return ep.to(o)
			}),
		),
		new be(
			"vscode.executeCodeLensProvider",
			"_executeCodeLensProvider",
			"Execute code lens provider.",
			[
				G.Uri,
				G.Number.with(
					"itemResolveCount",
					"Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)",
				).optional(),
			],
			new ge("A promise that resolves to an array of CodeLens-instances.", (o, e, t) =>
				ni((n) => new Aa(H.to(n.range), n.command && t.fromInternal(n.command)))(o),
			),
		),
		new be(
			"vscode.executeCodeActionProvider",
			"_executeCodeActionProvider",
			"Execute code action provider.",
			[
				G.Uri,
				new G(
					"rangeOrSelection",
					"Range in a text document. Some refactoring provider requires Selection object.",
					(o) => pe.isRange(o),
					(o) => (Bn.isSelection(o) ? er.from(o) : H.from(o)),
				),
				G.String.with("kind", "Code action kind to return code actions for").optional(),
				G.Number.with(
					"itemResolveCount",
					"Number of code actions to resolve (too large numbers slow down code actions)",
				).optional(),
			],
			new ge("A promise that resolves to an array of Command-instances.", (o, e, t) =>
				ni((n) => {
					if (n._isSynthetic) {
						if (!n.command) throw new Error("Synthetic code actions must have a command")
						return t.fromInternal(n.command)
					} else {
						let r = new xi(n.title, n.kind ? new lt(n.kind) : void 0)
						return (
							n.edit && (r.edit = zn.to(n.edit)),
							n.command && (r.command = t.fromInternal(n.command)),
							(r.isPreferred = n.isPreferred),
							r
						)
					}
				})(o),
			),
		),
		new be(
			"vscode.executeDocumentColorProvider",
			"_executeDocumentColorProvider",
			"Execute document color provider.",
			[G.Uri],
			new ge("A promise that resolves to an array of ColorInformation objects.", (o) =>
				o ? o.map((e) => new Na(H.to(e.range), Ad.to(e.color))) : [],
			),
		),
		new be(
			"vscode.executeColorPresentationProvider",
			"_executeColorPresentationProvider",
			"Execute color presentation provider.",
			[
				new G("color", "The color to show and insert", (o) => o instanceof qo, Ad.from),
				new G(
					"context",
					"Context object with uri and range",
					(o) => !0,
					(o) => ({ uri: o.uri, range: H.from(o.range) }),
				),
			],
			new ge("A promise that resolves to an array of ColorPresentation objects.", (o) => (o ? o.map(Pg.to) : [])),
		),
		new be(
			"vscode.executeInlayHintProvider",
			"_executeInlayHintProvider",
			"Execute inlay hints provider",
			[G.Uri, G.Range],
			new ge("A promise that resolves to an array of Inlay objects", (o, e, t) => o.map(GD.to.bind(void 0, t))),
		),
		new be(
			"vscode.executeFoldingRangeProvider",
			"_executeFoldingRangeProvider",
			"Execute folding range provider",
			[G.Uri],
			new ge("A promise that resolves to an array of FoldingRange objects", (o, e) => {
				if (o) return o.map(Dg.to)
			}),
		),
		new be(
			"vscode.resolveNotebookContentProviders",
			"_resolveNotebookContentProvider",
			"Resolve Notebook Content Providers",
			[],
			new ge(
				"A promise that resolves to an array of NotebookContentProvider static info objects.",
				ni((o) => ({
					viewType: o.viewType,
					displayName: o.displayName,
					options: {
						transientOutputs: o.options.transientOutputs,
						transientCellMetadata: o.options.transientCellMetadata,
						transientDocumentMetadata: o.options.transientDocumentMetadata,
					},
					filenamePattern: o.filenamePattern.map((e) => Rg.to(e)),
				})),
			),
		),
		new be(
			"vscode.executeInlineValueProvider",
			"_executeInlineValueProvider",
			"Execute inline value provider",
			[
				G.Uri,
				G.Range,
				new G(
					"context",
					"An InlineValueContext",
					(o) => o && typeof o.frameId == "number" && o.stoppedLocation instanceof pe,
					(o) => wg.from(o),
				),
			],
			new ge("A promise that resolves to an array of InlineValue objects", (o) => o.map(Eg.to)),
		),
		new be(
			"vscode.open",
			"_workbench.open",
			"Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
			[
				new G(
					"uriOrString",
					"Uri-instance or string (only http/https)",
					(o) => b.isUri(o) || (typeof o == "string" && pO(o, W.http, W.https)),
					(o) => o,
				),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "number" || typeof o == "object",
					(o) => o && (typeof o == "number" ? [wt.from(o), void 0] : [wt.from(o.viewColumn), kg.from(o)]),
				).optional(),
				G.String.with("label", "").optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.openWith",
			"_workbench.openWith",
			"Opens the provided resource with a specific editor.",
			[
				G.Uri.with("resource", "Resource to open"),
				G.String.with(
					"viewId",
					"Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor",
				),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "number" || typeof o == "object",
					(o) => o && (typeof o == "number" ? [wt.from(o), void 0] : [wt.from(o.viewColumn), kg.from(o)]),
				).optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.diff",
			"_workbench.diff",
			"Opens the provided resources in the diff editor to compare their contents.",
			[
				G.Uri.with("left", "Left-hand side resource of the diff editor"),
				G.Uri.with("right", "Right-hand side resource of the diff editor"),
				G.String.with("title", "Human readable title for the diff editor").optional(),
				new G(
					"columnOrOptions",
					"Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
					(o) => o === void 0 || typeof o == "object",
					(o) => o && [wt.from(o.viewColumn), kg.from(o)],
				).optional(),
			],
			ge.Void,
		),
		new be(
			"vscode.changes",
			"_workbench.changes",
			"Opens a list of resources in the changes editor to compare their contents.",
			[
				G.String.with("title", "Human readable title for the changes editor"),
				new G(
					"resourceList",
					"List of resources to compare",
					(o) => {
						for (let e of o) {
							if (e.length !== 3) return !1
							let [t, n, r] = e
							if (
								!b.isUri(t) ||
								(!b.isUri(n) && n !== void 0 && n !== null) ||
								(!b.isUri(r) && r !== void 0 && r !== null)
							)
								return !1
						}
						return !0
					},
					(o) => o,
				),
			],
			ge.Void,
		),
		new be(
			"vscode.prepareTypeHierarchy",
			"_executePrepareTypeHierarchy",
			"Prepare type hierarchy at a position inside a document",
			[G.Uri, G.Position],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Bs.to)),
		),
		new be(
			"vscode.provideSupertypes",
			"_executeProvideSupertypes",
			"Compute supertypes for an item",
			[G.TypeHierarchyItem],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Bs.to)),
		),
		new be(
			"vscode.provideSubtypes",
			"_executeProvideSubtypes",
			"Compute subtypes for an item",
			[G.TypeHierarchyItem],
			new ge("A promise that resolves to an array of TypeHierarchyItem-instances", (o) => o.map(Bs.to)),
		),
		new be(
			"vscode.revealTestInExplorer",
			"_revealTestInExplorer",
			"Reveals a test instance in the explorer",
			[G.TestItem],
			ge.Void,
		),
		new be(
			"vscode.startContinuousTestRun",
			"testing.startContinuousRunFromExtension",
			"Starts running the given tests with continuous run mode.",
			[G.TestProfile, G.Arr(G.TestItem)],
			ge.Void,
		),
		new be(
			"vscode.stopContinuousTestRun",
			"testing.stopContinuousRunFromExtension",
			"Stops running the given tests with continuous run mode.",
			[G.Arr(G.TestItem)],
			ge.Void,
		),
		new be(
			"vscode.experimental.editSession.continue",
			"_workbench.editSessions.actions.continueEditSession",
			"Continue the current edit session in a different workspace",
			[G.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")],
			ge.Void,
		),
		new be(
			"setContext",
			"_setContext",
			"Set a custom context key value that can be used in when clauses.",
			[
				G.String.with("name", "The context key name"),
				new G(
					"value",
					"The context key value",
					() => !0,
					(o) => o,
				),
			],
			ge.Void,
		),
		new be(
			"vscode.editorChat.start",
			"inlineChat.start",
			"Invoke a new editor chat session",
			[
				new G(
					"Run arguments",
					"",
					(o) => !0,
					(o) => {
						if (o)
							return {
								initialRange: o.initialRange ? H.from(o.initialRange) : void 0,
								initialSelection: Bn.isSelection(o.initialSelection)
									? er.from(o.initialSelection)
									: void 0,
								message: o.message,
								autoSend: o.autoSend,
								position: o.position ? Je.from(o.position) : void 0,
							}
					},
				),
			],
			ge.Void,
		),
	],
	HC = class {
		static register(e) {
			cB.forEach(e.registerApiCommand, e), this._registerValidateWhenClausesCommand(e)
		}
		static _registerValidateWhenClausesCommand(e) {
			e.registerCommand(!1, "_validateWhenClauses", zO)
		}
	}
function ni(o) {
	return (e) => {
		if (Array.isArray(e)) return e.map(o)
	}
}
function Il(o) {
	if (!Array.isArray(o)) return
	let e = []
	for (let t of o) ZL(t) ? e.push(Yu.to(t)) : e.push($n.to(t))
	return e
}
var vm = class {
	constructor(e, t) {
		;(this._proxy = e.getProxy(M.MainThreadBulkEdits)),
			(this._versionInformationProvider = {
				getTextDocumentVersion: (n) => t.getDocument(n)?.version,
				getNotebookDocumentVersion: () => {},
			})
	}
	applyWorkspaceEdit(e, t, n) {
		let r = new Xt(zn.from(e, this._versionInformationProvider))
		return this._proxy.$tryApplyWorkspaceEdit(r, void 0, n?.isRefactoring ?? !1)
	}
}
vm = R([S(0, ie)], vm)
function MN(o) {
	return !!o && typeof o.sessionId == "string" && o.$mid === 19
}
var t1 = class {
		constructor(e, t, n, r, i) {
			this._extension = e
			this._request = t
			this._proxy = n
			this._commandsConverter = r
			this._sessionDisposables = i
			this._stopWatch = zt.create(!1)
			this._isClosed = !1
		}
		close() {
			this._isClosed = !0
		}
		get timings() {
			return { firstProgress: this._firstProgress, totalElapsed: this._stopWatch.elapsed() }
		}
		get apiObject() {
			if (!this._apiObject) {
				let t = function (r) {
						if (e._isClosed) {
							let i = new Error("Response stream has been closed")
							throw (Error.captureStackTrace(i, r), i)
						}
					},
					e = this
				this._stopWatch.reset()
				let n = (r, i) => {
					if (
						(typeof this._firstProgress > "u" &&
							(r.kind === "markdownContent" || r.kind === "markdownVuln") &&
							(this._firstProgress = this._stopWatch.elapsed()),
						i)
					) {
						let s = this._proxy.$handleProgressChunk(this._request.requestId, r),
							a = {
								report: (l) => {
									s?.then((d) => {
										d &&
											(en.isMarkdownString(l.value)
												? this._proxy.$handleProgressChunk(
														this._request.requestId,
														Ng.from(l),
														d,
													)
												: this._proxy.$handleProgressChunk(
														this._request.requestId,
														kd.from(l),
														d,
													))
									})
								},
							}
						Promise.all([s, i?.(a)]).then(([l, d]) => {
							l !== void 0 && this._proxy.$handleProgressChunk(this._request.requestId, ik.from(d), l)
						})
					} else this._proxy.$handleProgressChunk(this._request.requestId, r)
				}
				this._apiObject = Object.freeze({
					markdown(r) {
						t(this.markdown)
						let i = new _s(r),
							s = xg.from(i)
						return n(s), this
					},
					markdownWithVulnerabilities(r, i) {
						t(this.markdown), i && F(e._extension, "chatParticipantAdditions")
						let s = new Di(r, i),
							a = vx.from(s)
						return n(a), this
					},
					codeblockUri(r, i) {
						t(this.codeblockUri), F(e._extension, "chatParticipantAdditions")
						let s = new As(r, i),
							a = hx.from(s)
						return n(a), this
					},
					filetree(r, i) {
						t(this.filetree)
						let s = new ks(r, i),
							a = Cg.from(s)
						return n(a), this
					},
					anchor(r, i) {
						let s = new ki(r, i)
						return this.push(s)
					},
					button(r) {
						t(this.anchor)
						let i = new Rs(r),
							s = Sg.from(i, e._commandsConverter, e._sessionDisposables)
						return n(s), this
					},
					progress(r, i) {
						t(this.progress)
						let s = new Za(r, i),
							a = i ? yx.from(s) : Fg.from(s)
						return n(a, i), this
					},
					warning(r) {
						t(this.progress), F(e._extension, "chatParticipantAdditions")
						let i = new Ri(r),
							s = Ng.from(i)
						return n(s), this
					},
					reference(r, i) {
						return this.reference2(r, i)
					},
					reference2(r, i, s) {
						if (
							(t(this.reference),
							typeof r == "object" && "variableName" in r && F(e._extension, "chatParticipantAdditions"),
							typeof r == "object" && "variableName" in r && !r.value)
						) {
							let a = e._request.variables.variables.find((l) => l.name === r.variableName)
							if (a) {
								let l
								if (a.references?.length)
									l = a.references.map((d) => ({
										kind: "reference",
										reference: { variableName: r.variableName, value: d.reference },
									}))
								else {
									let d = new Io(r, i, s)
									l = [kd.from(d)]
								}
								return l.forEach((d) => n(d)), this
							}
						} else {
							let a = new Io(r, i, s),
								l = kd.from(a)
							n(l)
						}
						return this
					},
					codeCitation(r, i, s) {
						t(this.codeCitation), F(e._extension, "chatParticipantAdditions")
						let a = new Os(r, i, s),
							l = Sx.from(a)
						n(l)
					},
					textEdit(r, i) {
						t(this.textEdit), F(e._extension, "chatParticipantAdditions")
						let s = new Ai(r, i)
						s.isDone = i === !0 ? !0 : void 0
						let a = Ix.from(s)
						return n(a), this
					},
					notebookEdit(r, i) {
						t(this.notebookEdit), F(e._extension, "chatParticipantAdditions")
						let s = new Ms(r, i),
							a = Cx.from(s)
						return n(a), this
					},
					confirmation(r, i, s, a) {
						t(this.confirmation), F(e._extension, "chatParticipantAdditions")
						let l = new Ds(r, i, s, a),
							d = bx.from(l)
						return n(d), this
					},
					push(r) {
						if (
							(t(this.push),
							(r instanceof Ai ||
								r instanceof Ms ||
								r instanceof Di ||
								r instanceof Ri ||
								r instanceof Ds ||
								r instanceof Os ||
								r instanceof Ls ||
								r instanceof Za) &&
								F(e._extension, "chatParticipantAdditions"),
							r instanceof Io)
						)
							this.reference2(r.value, r.iconPath, r.options)
						else if (r instanceof Za) {
							let i = r.task ? yx.from(r) : Fg.from(r)
							n(i, r.task)
						} else if (r instanceof ki) {
							let i = Xu.from(r)
							if (r.resolve) {
								F(e._extension, "chatParticipantAdditions"), (i.resolveId = He())
								let s = new _e()
								r
									.resolve(s.token)
									.then(() => {
										let a = Xu.from(r)
										e._proxy.$handleAnchorResolve(e._request.requestId, i.resolveId, a)
									})
									.then(
										() => s.dispose(),
										() => s.dispose(),
									),
									e._sessionDisposables.add(q(() => s.dispose(!0)))
							}
							n(i)
						} else {
							let i = Tx.from(r, e._commandsConverter, e._sessionDisposables)
							n(i)
						}
						return this
					},
				})
			}
			return this._apiObject
		}
	},
	WC = class o extends $ {
		constructor(t, n, r, i, s, a, l) {
			super()
			this._logService = n
			this._commands = r
			this._documents = i
			this._languageModels = s
			this._diagnostics = a
			this._tools = l
			this._agents = new Map()
			this._participantDetectionProviders = new Map()
			this._relatedFilesProviders = new Map()
			this._sessionDisposables = this._register(new Br())
			this._completionDisposables = this._register(new Br())
			this._inFlightRequests = new Set()
			this._onDidDisposeChatSession = this._register(new E())
			this.onDidDisposeChatSession = this._onDidDisposeChatSession.event
			;(this._proxy = t.getProxy(M.MainThreadChatAgents2)),
				r.registerArgumentProcessor({ processArgument: (d) => (MN(d) ? null : d) })
		}
		static {
			this._idPool = 0
		}
		static {
			this._participantDetectionProviderIdPool = 0
		}
		static {
			this._relatedFilesProviderIdPool = 0
		}
		transferActiveChat(t) {
			this._proxy.$transferActiveChatSession(t)
		}
		createChatAgent(t, n, r) {
			let i = o._idPool++,
				s = new VC(t, n, this._proxy, i, r)
			return this._agents.set(i, s), this._proxy.$registerAgent(i, t.identifier, n, {}, void 0), s.apiAgent
		}
		createDynamicChatAgent(t, n, r, i) {
			let s = o._idPool++,
				a = new VC(t, n, this._proxy, s, i)
			return (
				this._agents.set(s, a), this._proxy.$registerAgent(s, t.identifier, n, { isSticky: !0 }, r), a.apiAgent
			)
		}
		registerChatParticipantDetectionProvider(t, n) {
			let r = o._participantDetectionProviderIdPool++
			return (
				this._participantDetectionProviders.set(r, new n1(t, n)),
				this._proxy.$registerChatParticipantDetectionProvider(r),
				q(() => {
					this._participantDetectionProviders.delete(r),
						this._proxy.$unregisterChatParticipantDetectionProvider(r)
				})
			)
		}
		registerRelatedFilesProvider(t, n, r) {
			let i = o._relatedFilesProviderIdPool++
			return (
				this._relatedFilesProviders.set(i, new r1(t, n)),
				this._proxy.$registerRelatedFilesProvider(i, r),
				q(() => {
					this._relatedFilesProviders.delete(i), this._proxy.$unregisterRelatedFilesProvider(i)
				})
			)
		}
		async $provideRelatedFiles(t, n, r) {
			let i = this._relatedFilesProviders.get(t)
			if (!i) return Promise.resolve([])
			let s = sk.to(n)
			return (await i.provider.provideRelatedFiles(s, r)) ?? void 0
		}
		async $detectChatParticipant(t, n, r, i, s) {
			let a = this._participantDetectionProviders.get(t)
			if (!a) return
			let { request: l, location: d, history: c } = await this._createRequest(n, r, a.extension),
				u = await this.getModelForRequest(l, a.extension),
				m = nt(a.extension, "chatParticipantPrivate"),
				f = Ex.to(
					m ? l : { ...l, requestId: "" },
					d,
					u,
					this.getDiagnosticsWhenEnabled(a.extension),
					this.getToolsForRequest(a.extension, l),
				)
			return a.provider.provideParticipantDetection(
				f,
				{ history: c },
				{ participants: i.participants, location: Ug.to(i.location) },
				s,
			)
		}
		async _createRequest(t, n, r) {
			let i = ut(t),
				s = await this.prepareHistoryTurns(r, i.agentId, n),
				a
			if (i.locationData?.type === "editor") {
				let l = this._documents.getDocument(i.locationData.document)
				a = new Bu(l, er.to(i.locationData.selection), H.to(i.locationData.wholeRange))
			} else if (i.locationData?.type === "notebook") {
				let l = this._documents.getDocument(i.locationData.sessionInputUri)
				a = new $u(l)
			} else i.locationData?.type, "terminal"
			return { request: i, location: a, history: s }
		}
		async getModelForRequest(t, n) {
			let r
			if (
				(t.userSelectedModelId &&
					(r = await this._languageModels.getLanguageModelByIdentifier(n, t.userSelectedModelId)),
				!r && ((r = await this._languageModels.getDefaultLanguageModel(n)), !r))
			)
				throw new Error("Language model unavailable")
			return r
		}
		async $setRequestPaused(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = Rt.find(this._inFlightRequests, (a) => a.requestId === n)
			s && i.setChatRequestPauseState({ request: s.extRequest, isPaused: r })
		}
		async $invokeAgent(t, n, r, i) {
			let s = this._agents.get(t)
			if (!s) throw new Error(`[CHAT](${t}) CANNOT invoke agent because the agent is not registered`)
			let a, l
			try {
				let { request: d, location: c, history: u } = await this._createRequest(n, r, s.extension),
					m = this._sessionDisposables.get(d.sessionId)
				m || ((m = new Q()), this._sessionDisposables.set(d.sessionId, m)),
					(a = new t1(s.extension, d, this._proxy, this._commands.converter, m))
				let f = await this.getModelForRequest(d, s.extension),
					h = nt(s.extension, "chatParticipantPrivate"),
					g = Ex.to(
						h ? d : { ...d, requestId: "" },
						c,
						f,
						this.getDiagnosticsWhenEnabled(s.extension),
						this.getToolsForRequest(s.extension, d),
					)
				;(l = { requestId: n.requestId, extRequest: g }), this._inFlightRequests.add(l)
				let I = s.invoke(g, { history: u }, a.apiObject, i)
				return await Zv(
					Promise.resolve(I).then((C) => {
						if (C?.metadata)
							try {
								JSON.stringify(C.metadata)
							} catch (w) {
								let L = `result.metadata MUST be JSON.stringify-able. Got error: ${w.message}`
								return (
									this._logService.error(
										`[${s.extension.identifier.value}] [@${s.id}] ${L}`,
										s.extension,
									),
									{ errorDetails: { message: L }, timings: a?.timings, nextQuestion: C.nextQuestion }
								)
							}
						let T
						return (
							C?.errorDetails && (T = { ...C.errorDetails, responseIsIncomplete: !0 }),
							(T?.responseIsRedacted || T?.isQuotaExceeded) && F(s.extension, "chatParticipantPrivate"),
							{
								errorDetails: T,
								timings: a?.timings,
								metadata: C?.metadata,
								nextQuestion: C?.nextQuestion,
							}
						)
					}),
					i,
				)
			} catch (d) {
				this._logService.error(d, s.extension), d instanceof Hr && d.cause && (d = d.cause)
				let c = d instanceof Error && d.name === "ChatQuotaExceeded"
				return { errorDetails: { message: Xn(d), responseIsIncomplete: !0, isQuotaExceeded: c } }
			} finally {
				l && this._inFlightRequests.delete(l), a?.close()
			}
		}
		getDiagnosticsWhenEnabled(t) {
			return nt(t, "chatReferenceDiagnostic") ? this._diagnostics.getDiagnostics() : []
		}
		getToolsForRequest(t, n) {
			if (!si(n.userSelectedTools)) return
			let r = new Set(n.userSelectedTools)
			return this._tools.getTools(t).filter((i) => r.has(i.name))
		}
		async prepareHistoryTurns(t, n, r) {
			let i = []
			for (let s of r.history) {
				let a = rp.to(s.result),
					l = n === s.request.agentId ? a : { ...a, metadata: void 0 },
					d = s.request.variables.variables
						.filter((f) => !f.isTool)
						.map((f) => wx.to(f, this.getDiagnosticsWhenEnabled(t))),
					c = s.request.variables.variables.filter((f) => f.isTool).map(Px.to),
					u = new Wu(s.request.message, s.request.command, d, s.request.agentId, c)
				i.push(u)
				let m = Ye(s.response.map((f) => Tx.toContent(f, this._commands.converter)))
				i.push(new Vu(m, l, s.request.agentId, s.request.command))
			}
			return i
		}
		$releaseSession(t) {
			this._sessionDisposables.deleteAndDispose(t), this._onDidDisposeChatSession.fire(t)
		}
		async $provideFollowups(t, n, r, i, s) {
			let a = this._agents.get(n)
			if (!a) return Promise.resolve([])
			let l = ut(t),
				d = await this.prepareHistoryTurns(a.extension, a.id, i),
				c = rp.to(r)
			return (await a.provideFollowups(c, { history: d }, s))
				.filter((u) => {
					let m =
						!u.participant ||
						Rt.some(
							this._agents.values(),
							(f) => f.id === u.participant && Ce.equals(f.extension.identifier, a.extension.identifier),
						)
					return (
						m ||
							this._logService.warn(
								`[@${a.id}] ChatFollowup refers to an unknown participant: ${u.participant}`,
							),
						m
					)
				})
				.map((u) => Lg.from(u, l))
		}
		$acceptFeedback(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = rp.to(n),
				a
			switch (r.direction) {
				case 0:
					a = 0
					break
				case 1:
					a = 1
					break
			}
			let l = {
				result: s,
				kind: a,
				unhelpfulReason: nt(i.extension, "chatParticipantAdditions") ? r.reason : void 0,
			}
			i.acceptFeedback(Object.freeze(l))
		}
		$acceptAction(t, n, r) {
			let i = this._agents.get(t)
			if (!i || r.action.kind === "vote") return
			let s = lk.to(n, r, this._commands.converter)
			s && i.acceptAction(Object.freeze(s))
		}
		async $invokeCompletionProvider(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return []
			let s = this._completionDisposables.get(t)
			return (
				s ? s.clear() : ((s = new Q()), this._completionDisposables.set(t, s)),
				(await i.invokeCompletionProvider(n, r)).map((l) => ak.from(l, this._commands.converter, s))
			)
		}
		async $provideChatTitle(t, n, r) {
			let i = this._agents.get(t)
			if (!i) return
			let s = await this.prepareHistoryTurns(i.extension, i.id, { history: n })
			return await i.provideTitle({ history: s }, r)
		}
		async $provideSampleQuestions(t, n, r) {
			let i = this._agents.get(t)
			if (i) return (await i.provideSampleQuestions(Ug.to(n), r)).map((s) => Lg.from(s, void 0))
		}
	},
	n1 = class {
		constructor(e, t) {
			this.extension = e
			this.provider = t
		}
	},
	r1 = class {
		constructor(e, t) {
			this.extension = e
			this.provider = t
		}
	},
	VC = class {
		constructor(e, t, n, r, i) {
			this.extension = e
			this.id = t
			this._proxy = n
			this._handle = r
			this._requestHandler = i
			this._onDidReceiveFeedback = new E()
			this._onDidPerformAction = new E()
			this._pauseStateEmitter = new E()
		}
		acceptFeedback(e) {
			this._onDidReceiveFeedback.fire(e)
		}
		acceptAction(e) {
			this._onDidPerformAction.fire(e)
		}
		setChatRequestPauseState(e) {
			this._pauseStateEmitter.fire(e)
		}
		async invokeCompletionProvider(e, t) {
			return this._agentVariableProvider
				? ((await this._agentVariableProvider.provider.provideCompletionItems(e, t)) ?? [])
				: []
		}
		async provideFollowups(e, t, n) {
			if (!this._followupProvider) return []
			let r = await this._followupProvider.provideFollowups(e, t, n)
			return r ? r.filter((i) => !(i && "commandId" in i)).filter((i) => !(i && "message" in i)) : []
		}
		async provideTitle(e, t) {
			if (this._titleProvider) return (await this._titleProvider.provideChatTitle(e, t)) ?? void 0
		}
		async provideSampleQuestions(e, t) {
			if (!this._welcomeMessageProvider || !this._welcomeMessageProvider.provideSampleQuestions) return []
			let n = await this._welcomeMessageProvider.provideSampleQuestions(e, t)
			return n || []
		}
		get apiAgent() {
			let e = !1,
				t = !1,
				n = () => {
					e ||
						t ||
						((t = !0),
						queueMicrotask(() => {
							this._proxy.$updateAgent(this._handle, {
								icon: this._iconPath
									? this._iconPath instanceof b
										? this._iconPath
										: "light" in this._iconPath
											? this._iconPath.light
											: void 0
									: void 0,
								iconDark: this._iconPath && "dark" in this._iconPath ? this._iconPath.dark : void 0,
								themeIcon: this._iconPath instanceof Vt ? this._iconPath : void 0,
								hasFollowups: this._followupProvider !== void 0,
								helpTextPrefix:
									!this._helpTextPrefix || typeof this._helpTextPrefix == "string"
										? this._helpTextPrefix
										: Se.from(this._helpTextPrefix),
								helpTextVariablesPrefix:
									!this._helpTextVariablesPrefix || typeof this._helpTextVariablesPrefix == "string"
										? this._helpTextVariablesPrefix
										: Se.from(this._helpTextVariablesPrefix),
								helpTextPostfix:
									!this._helpTextPostfix || typeof this._helpTextPostfix == "string"
										? this._helpTextPostfix
										: Se.from(this._helpTextPostfix),
								supportIssueReporting: this._supportIssueReporting,
								requester: this._requester,
								additionalWelcomeMessage:
									!this._additionalWelcomeMessage || typeof this._additionalWelcomeMessage == "string"
										? this._additionalWelcomeMessage
										: Se.from(this._additionalWelcomeMessage),
							}),
								(t = !1)
						}))
				},
				r = this
			return {
				get id() {
					return r.id
				},
				get iconPath() {
					return r._iconPath
				},
				set iconPath(i) {
					;(r._iconPath = i), n()
				},
				get requestHandler() {
					return r._requestHandler
				},
				set requestHandler(i) {
					bc(typeof i == "function", "Invalid request handler"), (r._requestHandler = i)
				},
				get followupProvider() {
					return r._followupProvider
				},
				set followupProvider(i) {
					;(r._followupProvider = i), n()
				},
				get helpTextPrefix() {
					return F(r.extension, "defaultChatParticipant"), r._helpTextPrefix
				},
				set helpTextPrefix(i) {
					F(r.extension, "defaultChatParticipant"), (r._helpTextPrefix = i), n()
				},
				get helpTextVariablesPrefix() {
					return F(r.extension, "defaultChatParticipant"), r._helpTextVariablesPrefix
				},
				set helpTextVariablesPrefix(i) {
					F(r.extension, "defaultChatParticipant"), (r._helpTextVariablesPrefix = i), n()
				},
				get helpTextPostfix() {
					return F(r.extension, "defaultChatParticipant"), r._helpTextPostfix
				},
				set helpTextPostfix(i) {
					F(r.extension, "defaultChatParticipant"), (r._helpTextPostfix = i), n()
				},
				get supportIssueReporting() {
					return F(r.extension, "chatParticipantPrivate"), r._supportIssueReporting
				},
				set supportIssueReporting(i) {
					F(r.extension, "chatParticipantPrivate"), (r._supportIssueReporting = i), n()
				},
				get onDidReceiveFeedback() {
					return r._onDidReceiveFeedback.event
				},
				set participantVariableProvider(i) {
					if ((F(r.extension, "chatParticipantAdditions"), (r._agentVariableProvider = i), i)) {
						if (!i.triggerCharacters.length) throw new Error("triggerCharacters are required")
						r._proxy.$registerAgentCompletionsProvider(r._handle, r.id, i.triggerCharacters)
					} else r._proxy.$unregisterAgentCompletionsProvider(r._handle, r.id)
				},
				get participantVariableProvider() {
					return F(r.extension, "chatParticipantAdditions"), r._agentVariableProvider
				},
				set welcomeMessageProvider(i) {
					F(r.extension, "defaultChatParticipant"), (r._welcomeMessageProvider = i), n()
				},
				get welcomeMessageProvider() {
					return F(r.extension, "defaultChatParticipant"), r._welcomeMessageProvider
				},
				set additionalWelcomeMessage(i) {
					F(r.extension, "defaultChatParticipant"), (r._additionalWelcomeMessage = i), n()
				},
				get additionalWelcomeMessage() {
					return F(r.extension, "defaultChatParticipant"), r._additionalWelcomeMessage
				},
				set titleProvider(i) {
					F(r.extension, "defaultChatParticipant"), (r._titleProvider = i), n()
				},
				get titleProvider() {
					return F(r.extension, "defaultChatParticipant"), r._titleProvider
				},
				get onDidChangePauseState() {
					return F(r.extension, "chatParticipantAdditions"), r._pauseStateEmitter.event
				},
				onDidPerformAction: nt(this.extension, "chatParticipantAdditions")
					? this._onDidPerformAction.event
					: void 0,
				set requester(i) {
					;(r._requester = i), n()
				},
				get requester() {
					return r._requester
				},
				dispose() {
					;(e = !0),
						(r._followupProvider = void 0),
						r._onDidReceiveFeedback.dispose(),
						r._proxy.$unregisterAgent(r._handle)
				},
			}
		}
		invoke(e, t, n, r) {
			return this._requestHandler(e, t, n, r)
		}
	}
var BC = class {
	constructor(e) {
		this._items = new Map()
		this._proxy = e.getProxy(M.MainThreadChatStatus)
	}
	createChatStatusItem(e, t) {
		let n = uB(e.identifier, t)
		if (this._items.has(n)) throw new Error(`Chat status item '${t}' already exists`)
		let r = { id: n, title: "", description: "", detail: "" },
			i = !1,
			s = !1,
			a = () => {
				if (i) throw new Error("Chat status item is disposed")
				s && this._proxy.$setEntry(t, r)
			},
			l = Object.freeze({
				id: t,
				get title() {
					return r.title
				},
				set title(d) {
					;(r.title = d), a()
				},
				get description() {
					return r.description
				},
				set description(d) {
					;(r.description = d), a()
				},
				get detail() {
					return r.detail
				},
				set detail(d) {
					;(r.detail = d), a()
				},
				show: () => {
					;(s = !0), a()
				},
				hide: () => {
					;(s = !1), this._proxy.$disposeEntry(t)
				},
				dispose: () => {
					;(i = !0), this._proxy.$disposeEntry(t), this._items.delete(n)
				},
			})
		return this._items.set(n, l), l
	}
}
function uB(o, e) {
	return `${Ce.toKey(o)}.${e}`
}
var $C = class {
	constructor(e) {
		let t = e.getProxy(M.MainThreadClipboard)
		this.value = Object.freeze({
			readText() {
				return t.$readText()
			},
			writeText(n) {
				return t.$writeText(n)
			},
		})
	}
}
var FN = "vscode-cdn.net",
	pB = `vscode-resource.${FN}`,
	Ch = `'self' https://*.${FN} vscode-file://*`
function xl(o, e) {
	return o.scheme === W.http || o.scheme === W.https
		? o
		: o.scheme === W.file
			? b.from({ scheme: "vscode-file", path: o.path, fragment: o.fragment, query: o.query })
			: (e &&
					e.authority &&
					e.isRemote &&
					o.scheme === W.file &&
					(o = b.from({ scheme: W.vscodeRemote, authority: e.authority, path: o.path })),
				b.from({
					scheme: W.https,
					authority: `${o.scheme}+${mB(o.authority)}.${pB}`,
					path: o.path,
					fragment: o.fragment,
					query: o.query,
				}))
}
function mB(o) {
	return o.replace(/./g, (e) => {
		let t = e.charCodeAt(0)
		return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || (t >= 48 && t <= 57)
			? e
			: "-" + t.toString(16).padStart(4, "0")
	})
}
var zC = class {
	constructor(e, t, n) {
		this._proxy = e
		this._editors = t
		this._remoteInfo = n
		this._handlePool = 0
		this._disposables = new Q()
		this._insets = new Map()
		this._disposables.add(
			t.onDidChangeVisibleTextEditors(() => {
				let r = t.getVisibleTextEditors()
				for (let i of this._insets.values()) r.indexOf(i.editor) < 0 && i.inset.dispose()
			}),
		)
	}
	dispose() {
		this._insets.forEach((e) => e.inset.dispose()), this._disposables.dispose()
	}
	createWebviewEditorInset(e, t, n, r, i) {
		let s
		for (let f of this._editors.getVisibleTextEditors(!0))
			if (f.value === e) {
				s = f
				break
			}
		if (!s) throw new Error("not a visible editor")
		let a = this,
			l = this._handlePool++,
			d = new E(),
			c = new E(),
			u = new (class {
				constructor() {
					this._html = ""
					this._options = Object.create(null)
				}
				asWebviewUri(f) {
					return xl(f, a._remoteInfo)
				}
				get cspSource() {
					return Ch
				}
				set options(f) {
					;(this._options = f), a._proxy.$setOptions(l, f)
				}
				get options() {
					return this._options
				}
				set html(f) {
					;(this._html = f), a._proxy.$setHtml(l, f)
				}
				get html() {
					return this._html
				}
				get onDidReceiveMessage() {
					return d.event
				}
				postMessage(f) {
					return a._proxy.$postMessage(l, f)
				}
			})(),
			m = new (class {
				constructor() {
					this.editor = e
					this.line = t
					this.height = n
					this.webview = u
					this.onDidDispose = c.event
				}
				dispose() {
					a._insets.has(l) &&
						(a._insets.delete(l), a._proxy.$disposeEditorInset(l), c.fire(), c.dispose(), d.dispose())
				}
			})()
		return (
			this._proxy.$createEditorInset(
				l,
				s.id,
				s.value.document.uri,
				t + 1,
				n,
				r || {},
				i.identifier,
				i.extensionLocation,
			),
			this._insets.set(l, { editor: e, inset: m, onDidReceiveMessage: d }),
			m
		)
	}
	$onDidDispose(e) {
		let t = this._insets.get(e)
		t && t.inset.dispose()
	}
	$onDidReceiveMessage(e, t) {
		this._insets.get(e)?.onDidReceiveMessage.fire(t)
	}
}
var qC = class o {
	constructor(e) {
		this.providers = new Map()
		this._proxy = e.getProxy(M.MainThreadCodeMapper)
	}
	static {
		this._providerHandlePool = 0
	}
	async $mapCode(e, t, n) {
		let r = this.providers.get(e)
		if (!r) throw new Error(`Received request to map code for unknown provider handle ${e}`)
		let i = {
				textEdit: (l, d) => {
					;(d = an(d)), this._proxy.$handleProgress(t.requestId, { uri: l, edits: d.map(on.from) })
				},
				notebookEdit: (l, d) => {
					;(d = an(d)), this._proxy.$handleProgress(t.requestId, { uri: l, edits: d.map(xx.from) })
				},
			},
			s = {
				location: t.location,
				chatRequestId: t.chatRequestId,
				codeBlocks: t.codeBlocks.map((l) => ({
					code: l.code,
					resource: b.revive(l.resource),
					markdownBeforeBlock: l.markdownBeforeBlock,
				})),
			}
		return (await r.provideMappedEdits(s, i, n)) ?? null
	}
	registerMappedEditsProvider(e, t) {
		let n = o._providerHandlePool++
		return (
			this._proxy.$registerCodeMapperProvider(n, e.displayName ?? e.name),
			this.providers.set(n, t),
			{ dispose: () => this._proxy.$unregisterCodeMapperProvider(n) }
		)
	}
}
function NN(o, e, t) {
	let n = o.getProxy(M.MainThreadComments)
	class r {
		constructor() {
			this._commentControllers = new Map()
			this._commentControllersByExtension = new Ln()
			e.registerArgumentProcessor({
				processArgument: (g) => {
					if (g && g.$mid === 6) {
						let I = this._commentControllers.get(g.handle)
						return I ? I.value : g
					} else if (g && g.$mid === 7) {
						let I = g,
							C = this._commentControllers.get(I.commentControlHandle)
						if (!C) return I
						let T = C.getCommentThread(I.commentThreadHandle)
						return T ? T.value : I
					} else if (g && (g.$mid === 9 || g.$mid === 8)) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						return C ? (g.$mid === 8 ? C.value : { thread: C.value, text: g.text }) : g
					} else if (g && g.$mid === 10) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						if (!C) return g
						let T = g.commentUniqueId,
							w = C.getCommentByUniqueId(T)
						return w || g
					} else if (g && g.$mid === 11) {
						let I = this._commentControllers.get(g.thread.commentControlHandle)
						if (!I) return g
						let C = I.getCommentThread(g.thread.commentThreadHandle)
						if (!C) return g
						let T = g.text,
							w = g.commentUniqueId,
							L = C.getCommentByUniqueId(w)
						return L ? (typeof L.body == "string" ? (L.body = T) : (L.body = new en(T)), L) : g
					}
					return g
				},
			})
		}
		static {
			this.handlePool = 0
		}
		createCommentController(g, I, C) {
			let T = r.handlePool++,
				w = new s(g, T, I, C)
			this._commentControllers.set(w.handle, w)
			let L = this._commentControllersByExtension.get(g.identifier) || []
			return L.push(w), this._commentControllersByExtension.set(g.identifier, L), w.value
		}
		async $createCommentThreadTemplate(g, I, C, T) {
			let w = this._commentControllers.get(g)
			w && w.$createCommentThreadTemplate(I, C, T)
		}
		async $setActiveComment(g, I) {
			let C = this._commentControllers.get(g)
			C && C.$setActiveComment(I ?? void 0)
		}
		async $updateCommentThreadTemplate(g, I, C) {
			let T = this._commentControllers.get(g)
			T && T.$updateCommentThreadTemplate(I, C)
		}
		$deleteCommentThread(g, I) {
			this._commentControllers.get(g)?.$deleteCommentThread(I)
		}
		async $updateCommentThread(g, I, C) {
			this._commentControllers.get(g)?.$updateCommentThread(I, C)
		}
		async $provideCommentingRanges(g, I, C) {
			let T = this._commentControllers.get(g)
			if (!T || !T.commentingRangeProvider) return Promise.resolve(void 0)
			let w = await t.ensureDocumentData(b.revive(I))
			return Jt(async () => {
				let L = await T.commentingRangeProvider?.provideCommentingRanges(w.document, C),
					A
				return (
					Array.isArray(L)
						? (A = { ranges: L, fileComments: !1 })
						: L
							? (A = { ranges: L.ranges || [], fileComments: L.enableFileComments || !1 })
							: (A = L ?? void 0),
					A
				)
			}).then((L) => {
				let A
				return L && (A = { ranges: L.ranges.map((J) => H.from(J)), fileComments: L.fileComments }), A
			})
		}
		$toggleReaction(g, I, C, T, w) {
			let L = this._commentControllers.get(g)
			return !L || !L.reactionHandler
				? Promise.resolve(void 0)
				: Jt(() => {
						let A = L.getCommentThread(I)
						if (A) {
							let J = A.getCommentByUniqueId(T.uniqueIdInThread)
							if (L !== void 0 && J && L.reactionHandler) return L.reactionHandler(J, d(w))
						}
						return Promise.resolve(void 0)
					})
		}
	}
	let f = class f {
		constructor(g, I, C, T, w, L, A, J, ne) {
			this._commentControllerHandle = I
			this._id = C
			this._uri = T
			this._range = w
			this._comments = L
			this.extensionDescription = A
			this._isTemplate = J
			this.handle = f._handlePool++
			this.commentHandle = 0
			this.modifications = Object.create(null)
			this._onDidUpdateCommentThread = new E()
			this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event
			this._canReply = !0
			this._commentsMap = new Map()
			this._acceptInputDisposables = new kn()
			;(this._acceptInputDisposables.value = new Q()),
				this._id === void 0 && (this._id = `${g}.${this.handle}`),
				n.$createCommentThread(
					I,
					this.handle,
					this._id,
					this._uri,
					H.from(this._range),
					this._comments.map((Y) => a(this, Y, this._commentsMap, this.extensionDescription)),
					A.identifier,
					this._isTemplate,
					ne,
				),
				(this._localDisposables = []),
				(this._isDiposed = !1),
				this._localDisposables.push(
					this.onDidUpdateCommentThread(() => {
						this.eventuallyUpdateCommentThread()
					}),
				),
				this._localDisposables.push({
					dispose: () => {
						n.$deleteCommentThread(I, this.handle)
					},
				})
			let oe = this
			this.value = {
				get uri() {
					return oe.uri
				},
				get range() {
					return oe.range
				},
				set range(Y) {
					oe.range = Y
				},
				get comments() {
					return oe.comments
				},
				set comments(Y) {
					oe.comments = Y
				},
				get collapsibleState() {
					return oe.collapsibleState
				},
				set collapsibleState(Y) {
					oe.collapsibleState = Y
				},
				get canReply() {
					return oe.canReply
				},
				set canReply(Y) {
					oe.canReply = Y
				},
				get contextValue() {
					return oe.contextValue
				},
				set contextValue(Y) {
					oe.contextValue = Y
				},
				get label() {
					return oe.label
				},
				set label(Y) {
					oe.label = Y
				},
				get state() {
					return oe.state
				},
				set state(Y) {
					oe.state = Y
				},
				reveal: (Y, j) => oe.reveal(Y, j),
				hide: () => oe.hide(),
				dispose: () => {
					oe.dispose()
				},
			}
		}
		static {
			this._handlePool = 0
		}
		set threadId(g) {
			this._id = g
		}
		get threadId() {
			return this._id
		}
		get id() {
			return this._id
		}
		get resource() {
			return this._uri
		}
		get uri() {
			return this._uri
		}
		set range(g) {
			;((g === void 0) != (this._range === void 0) || !g || !this._range || !g.isEqual(this._range)) &&
				((this._range = g), (this.modifications.range = g), this._onDidUpdateCommentThread.fire())
		}
		get range() {
			return this._range
		}
		set canReply(g) {
			this._canReply !== g &&
				((this._canReply = g), (this.modifications.canReply = g), this._onDidUpdateCommentThread.fire())
		}
		get canReply() {
			return this._canReply
		}
		get label() {
			return this._label
		}
		set label(g) {
			;(this._label = g), (this.modifications.label = g), this._onDidUpdateCommentThread.fire()
		}
		get contextValue() {
			return this._contextValue
		}
		set contextValue(g) {
			;(this._contextValue = g), (this.modifications.contextValue = g), this._onDidUpdateCommentThread.fire()
		}
		get comments() {
			return this._comments
		}
		set comments(g) {
			;(this._comments = g), (this.modifications.comments = g), this._onDidUpdateCommentThread.fire()
		}
		get collapsibleState() {
			return this._collapseState
		}
		set collapsibleState(g) {
			this._collapseState !== g &&
				((this._collapseState = g),
				(this.modifications.collapsibleState = g),
				this._onDidUpdateCommentThread.fire())
		}
		get state() {
			return this._state
		}
		set state(g) {
			;(this._state = g),
				typeof g == "object"
					? (F(this.extensionDescription, "commentThreadApplicability"),
						(this.modifications.state = g.resolved),
						(this.modifications.applicability = g.applicability))
					: (this.modifications.state = g),
				this._onDidUpdateCommentThread.fire()
		}
		get isDisposed() {
			return this._isDiposed
		}
		updateIsTemplate() {
			this._isTemplate && ((this._isTemplate = !1), (this.modifications.isTemplate = !1))
		}
		eventuallyUpdateCommentThread() {
			if (this._isDiposed) return
			this.updateIsTemplate(),
				this._acceptInputDisposables.value || (this._acceptInputDisposables.value = new Q())
			let g = (C) => Object.prototype.hasOwnProperty.call(this.modifications, C),
				I = {}
			g("range") && (I.range = H.from(this._range)),
				g("label") && (I.label = this.label),
				g("contextValue") && (I.contextValue = this.contextValue ?? null),
				g("comments") &&
					(I.comments = this._comments.map((C) => a(this, C, this._commentsMap, this.extensionDescription))),
				g("collapsibleState") && (I.collapseState = c(this._collapseState)),
				g("canReply") && (I.canReply = this.canReply),
				g("state") && (I.state = u(this._state)),
				g("applicability") && (I.applicability = m(this._state)),
				g("isTemplate") && (I.isTemplate = this._isTemplate),
				(this.modifications = {}),
				n.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, I)
		}
		getCommentByUniqueId(g) {
			for (let I of this._commentsMap) {
				let C = I[0],
					T = I[1]
				if (g === T) return C
			}
		}
		async reveal(g, I) {
			F(this.extensionDescription, "commentReveal")
			let C
			g && g.body !== void 0 ? (C = g) : (I = I ?? g)
			let T = C ? this._commentsMap.get(C) : void 0
			T ??= this._commentsMap.get(this._comments[0])
			let w = !0,
				L = !1
			return (
				I?.focus === 1 ? ((L = !0), (w = !1)) : I?.focus === 2 && (w = !1),
				n.$revealCommentThread(this._commentControllerHandle, this.handle, T, {
					preserveFocus: w,
					focusReply: L,
				})
			)
		}
		async hide() {
			return n.$hideCommentThread(this._commentControllerHandle, this.handle)
		}
		dispose() {
			;(this._isDiposed = !0),
				this._acceptInputDisposables.dispose(),
				this._localDisposables.forEach((g) => g.dispose())
		}
	}
	R([Wl(100)], f.prototype, "eventuallyUpdateCommentThread", 1)
	let i = f
	class s {
		constructor(g, I, C, T) {
			this._extension = g
			this._handle = I
			this._id = C
			this._label = T
			this._threads = new Map()
			n.$registerCommentController(this.handle, C, T, this._extension.identifier.value)
			let w = this
			;(this.value = Object.freeze({
				id: w.id,
				label: w.label,
				get options() {
					return w.options
				},
				set options(L) {
					w.options = L
				},
				get commentingRangeProvider() {
					return w.commentingRangeProvider
				},
				set commentingRangeProvider(L) {
					w.commentingRangeProvider = L
				},
				get reactionHandler() {
					return w.reactionHandler
				},
				set reactionHandler(L) {
					w.reactionHandler = L
				},
				get activeCommentThread() {
					return w.activeCommentThread
				},
				createCommentThread(L, A, J) {
					return w.createCommentThread(L, A, J).value
				},
				dispose: () => {
					w.dispose()
				},
			})),
				(this._localDisposables = []),
				this._localDisposables.push({
					dispose: () => {
						n.$unregisterCommentController(this.handle)
					},
				})
		}
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		get handle() {
			return this._handle
		}
		get commentingRangeProvider() {
			return this._commentingRangeProvider
		}
		set commentingRangeProvider(g) {
			;(this._commentingRangeProvider = g),
				g?.resourceHints && F(this._extension, "commentingRangeHint"),
				n.$updateCommentingRanges(this.handle, g?.resourceHints)
		}
		get reactionHandler() {
			return this._reactionHandler
		}
		set reactionHandler(g) {
			;(this._reactionHandler = g), n.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!g })
		}
		get options() {
			return this._options
		}
		set options(g) {
			;(this._options = g), n.$updateCommentControllerFeatures(this.handle, { options: this._options })
		}
		get activeComment() {
			return F(this._extension, "activeComment"), this._activeComment
		}
		get activeCommentThread() {
			return F(this._extension, "activeComment"), this._activeThread?.value
		}
		createCommentThread(g, I, C) {
			let T = new i(this.id, this.handle, void 0, g, I, C, this._extension, !1)
			return this._threads.set(T.handle, T), T
		}
		$setActiveComment(g) {
			if (!g) {
				;(this._activeComment = void 0), (this._activeThread = void 0)
				return
			}
			let I = this._threads.get(g.commentThreadHandle)
			I &&
				((this._activeComment = g.uniqueIdInThread ? I.getCommentByUniqueId(g.uniqueIdInThread) : void 0),
				(this._activeThread = I))
		}
		$createCommentThreadTemplate(g, I, C) {
			let T = new i(this.id, this.handle, void 0, b.revive(g), H.to(I), [], this._extension, !0, C)
			return (T.collapsibleState = 1), this._threads.set(T.handle, T), T
		}
		$updateCommentThreadTemplate(g, I) {
			let C = this._threads.get(g)
			C && (C.range = H.to(I))
		}
		$updateCommentThread(g, I) {
			let C = this._threads.get(g)
			if (!C) return
			;((w) => Object.prototype.hasOwnProperty.call(I, w))("collapseState") &&
				(C.collapsibleState = c(I.collapseState))
		}
		$deleteCommentThread(g) {
			this._threads.get(g)?.dispose(), this._threads.delete(g)
		}
		getCommentThread(g) {
			return this._threads.get(g)
		}
		dispose() {
			this._threads.forEach((g) => {
				g.dispose()
			}),
				this._localDisposables.forEach((g) => g.dispose())
		}
	}
	function a(h, g, I, C) {
		let T = I.get(g)
		return (
			T || ((T = ++h.commentHandle), I.set(g, T)),
			g.state !== void 0 && F(C, "commentsDraftState"),
			g.reactions?.some((w) => w.reactors !== void 0) && F(C, "commentReactor"),
			{
				mode: g.mode,
				contextValue: g.contextValue,
				uniqueIdInThread: T,
				body: typeof g.body == "string" ? g.body : Se.from(g.body),
				userName: g.author.name,
				userIconPath: g.author.iconPath,
				label: g.label,
				commentReactions: g.reactions ? g.reactions.map((w) => l(w)) : void 0,
				state: g.state,
				timestamp: g.timestamp?.toJSON(),
			}
		)
	}
	function l(h) {
		return {
			label: h.label,
			iconPath: h.iconPath ? Tg(h.iconPath) : void 0,
			count: h.count,
			hasReacted: h.authorHasReacted,
			reactors:
				h.reactors && h.reactors.length > 0 && typeof h.reactors[0] != "string"
					? h.reactors.map((g) => g.name)
					: h.reactors,
		}
	}
	function d(h) {
		return {
			label: h.label || "",
			count: h.count || 0,
			iconPath: h.iconPath ? b.revive(h.iconPath) : "",
			authorHasReacted: h.hasReacted || !1,
			reactors: h.reactors?.map((g) => ({ name: g })),
		}
	}
	function c(h) {
		if (h !== void 0)
			switch (h) {
				case 1:
					return 1
				case 0:
					return 0
			}
		return 0
	}
	function u(h) {
		let g
		if ((typeof h == "object" ? (g = h.resolved) : (g = h), g !== void 0))
			switch (g) {
				case 0:
					return 0
				case 1:
					return 1
			}
		return 0
	}
	function m(h) {
		let g
		if ((typeof h == "object" && (g = h.applicability), g !== void 0))
			switch (g) {
				case 0:
					return 0
				case 1:
					return 1
			}
		return 0
	}
	return new r()
}
var KC = {},
	ot = { exports: KC }
;(function (o, e) {
	if (typeof KC == "object" && typeof ot == "object") ot.exports = e()
	else if (typeof define == "function" && define.amd) define([], e)
	else {
		var t = e()
		for (var n in t) (typeof KC == "object" ? KC : o)[n] = t[n]
	}
})(typeof self < "u" ? self : void 0, function () {
	return (function (o) {
		var e = {}
		function t(n) {
			if (e[n]) return e[n].exports
			var r = (e[n] = { i: n, l: !1, exports: {} })
			return o[n].call(r.exports, r, r.exports, t), (r.l = !0), r.exports
		}
		return (
			(t.m = o),
			(t.c = e),
			(t.d = function (n, r, i) {
				t.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: i })
			}),
			(t.r = function (n) {
				typeof Symbol < "u" &&
					Symbol.toStringTag &&
					Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }),
					Object.defineProperty(n, "__esModule", { value: !0 })
			}),
			(t.t = function (n, r) {
				if ((1 & r && (n = t(n)), 8 & r || (4 & r && typeof n == "object" && n && n.__esModule))) return n
				var i = Object.create(null)
				if (
					(t.r(i),
					Object.defineProperty(i, "default", { enumerable: !0, value: n }),
					2 & r && typeof n != "string")
				)
					for (var s in n)
						t.d(
							i,
							s,
							function (a) {
								return n[a]
							}.bind(null, s),
						)
				return i
			}),
			(t.n = function (n) {
				var r =
					n && n.__esModule
						? function () {
								return n.default
							}
						: function () {
								return n
							}
				return t.d(r, "a", r), r
			}),
			(t.o = function (n, r) {
				return Object.prototype.hasOwnProperty.call(n, r)
			}),
			(t.p = ""),
			t((t.s = 0))
		)
	})([
		function (o, e, t) {
			;(function (n) {
				var r
				;(e = o.exports = mt),
					(r =
						typeof n == "object" && n.env && n.env.NODE_DEBUG && /\bsemver\b/i.test(n.env.NODE_DEBUG)
							? function () {
									var k = Array.prototype.slice.call(arguments, 0)
									k.unshift("SEMVER"), console.log.apply(console, k)
								}
							: function () {}),
					(e.SEMVER_SPEC_VERSION = "2.0.0")
				var i = 256,
					s = Number.MAX_SAFE_INTEGER || 9007199254740991,
					a = (e.re = []),
					l = (e.src = []),
					d = 0,
					c = d++
				l[c] = "0|[1-9]\\d*"
				var u = d++
				l[u] = "[0-9]+"
				var m = d++
				l[m] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
				var f = d++
				l[f] = "(" + l[c] + ")\\.(" + l[c] + ")\\.(" + l[c] + ")"
				var h = d++
				l[h] = "(" + l[u] + ")\\.(" + l[u] + ")\\.(" + l[u] + ")"
				var g = d++
				l[g] = "(?:" + l[c] + "|" + l[m] + ")"
				var I = d++
				l[I] = "(?:" + l[u] + "|" + l[m] + ")"
				var C = d++
				l[C] = "(?:-(" + l[g] + "(?:\\." + l[g] + ")*))"
				var T = d++
				l[T] = "(?:-?(" + l[I] + "(?:\\." + l[I] + ")*))"
				var w = d++
				l[w] = "[0-9A-Za-z-]+"
				var L = d++
				l[L] = "(?:\\+(" + l[w] + "(?:\\." + l[w] + ")*))"
				var A = d++,
					J = "v?" + l[f] + l[C] + "?" + l[L] + "?"
				l[A] = "^" + J + "$"
				var ne = "[v=\\s]*" + l[h] + l[T] + "?" + l[L] + "?",
					oe = d++
				l[oe] = "^" + ne + "$"
				var Y = d++
				l[Y] = "((?:<|>)?=?)"
				var j = d++
				l[j] = l[u] + "|x|X|\\*"
				var K = d++
				l[K] = l[c] + "|x|X|\\*"
				var qe = d++
				l[qe] =
					"[v=\\s]*(" + l[K] + ")(?:\\.(" + l[K] + ")(?:\\.(" + l[K] + ")(?:" + l[C] + ")?" + l[L] + "?)?)?"
				var Bt = d++
				l[Bt] =
					"[v=\\s]*(" + l[j] + ")(?:\\.(" + l[j] + ")(?:\\.(" + l[j] + ")(?:" + l[T] + ")?" + l[L] + "?)?)?"
				var vt = d++
				l[vt] = "^" + l[Y] + "\\s*" + l[qe] + "$"
				var ae = d++
				l[ae] = "^" + l[Y] + "\\s*" + l[Bt] + "$"
				var Z = d++
				l[Z] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])"
				var se = d++
				l[se] = "(?:~>?)"
				var ee = d++
				;(l[ee] = "(\\s*)" + l[se] + "\\s+"), (a[ee] = new RegExp(l[ee], "g"))
				var fe = d++
				l[fe] = "^" + l[se] + l[qe] + "$"
				var Ae = d++
				l[Ae] = "^" + l[se] + l[Bt] + "$"
				var he = d++
				l[he] = "(?:\\^)"
				var de = d++
				;(l[de] = "(\\s*)" + l[he] + "\\s+"), (a[de] = new RegExp(l[de], "g"))
				var Et = d++
				l[Et] = "^" + l[he] + l[qe] + "$"
				var _t = d++
				l[_t] = "^" + l[he] + l[Bt] + "$"
				var Te = d++
				l[Te] = "^" + l[Y] + "\\s*(" + ne + ")$|^$"
				var wn = d++
				l[wn] = "^" + l[Y] + "\\s*(" + J + ")$|^$"
				var Ft = d++
				;(l[Ft] = "(\\s*)" + l[Y] + "\\s*(" + ne + "|" + l[qe] + ")"), (a[Ft] = new RegExp(l[Ft], "g"))
				var ro = d++
				l[ro] = "^\\s*(" + l[qe] + ")\\s+-\\s+(" + l[qe] + ")\\s*$"
				var sc = d++
				l[sc] = "^\\s*(" + l[Bt] + ")\\s+-\\s+(" + l[Bt] + ")\\s*$"
				var oi = d++
				l[oi] = "(<|>)?=?\\s*\\*"
				for (var oo = 0; oo < 35; oo++) r(oo, l[oo]), a[oo] || (a[oo] = new RegExp(l[oo]))
				function $e(k, U) {
					if (k instanceof mt) return k
					if (typeof k != "string" || k.length > i || !(U ? a[oe] : a[A]).test(k)) return null
					try {
						return new mt(k, U)
					} catch {
						return null
					}
				}
				function mt(k, U) {
					if (k instanceof mt) {
						if (k.loose === U) return k
						k = k.version
					} else if (typeof k != "string") throw new TypeError("Invalid Version: " + k)
					if (k.length > i) throw new TypeError("version is longer than " + i + " characters")
					if (!(this instanceof mt)) return new mt(k, U)
					r("SemVer", k, U), (this.loose = U)
					var B = k.trim().match(U ? a[oe] : a[A])
					if (!B) throw new TypeError("Invalid Version: " + k)
					if (
						((this.raw = k),
						(this.major = +B[1]),
						(this.minor = +B[2]),
						(this.patch = +B[3]),
						this.major > s || this.major < 0)
					)
						throw new TypeError("Invalid major version")
					if (this.minor > s || this.minor < 0) throw new TypeError("Invalid minor version")
					if (this.patch > s || this.patch < 0) throw new TypeError("Invalid patch version")
					B[4]
						? (this.prerelease = B[4].split(".").map(function (ve) {
								if (/^[0-9]+$/.test(ve)) {
									var Me = +ve
									if (Me >= 0 && Me < s) return Me
								}
								return ve
							}))
						: (this.prerelease = []),
						(this.build = B[5] ? B[5].split(".") : []),
						this.format()
				}
				;(e.parse = $e),
					(e.valid = function (k, U) {
						var B = $e(k, U)
						return B ? B.version : null
					}),
					(e.clean = function (k, U) {
						var B = $e(k.trim().replace(/^[=v]+/, ""), U)
						return B ? B.version : null
					}),
					(e.SemVer = mt),
					(mt.prototype.format = function () {
						return (
							(this.version = this.major + "." + this.minor + "." + this.patch),
							this.prerelease.length && (this.version += "-" + this.prerelease.join(".")),
							this.version
						)
					}),
					(mt.prototype.toString = function () {
						return this.version
					}),
					(mt.prototype.compare = function (k) {
						return (
							r("SemVer.compare", this.version, this.loose, k),
							k instanceof mt || (k = new mt(k, this.loose)),
							this.compareMain(k) || this.comparePre(k)
						)
					}),
					(mt.prototype.compareMain = function (k) {
						return (
							k instanceof mt || (k = new mt(k, this.loose)),
							Tr(this.major, k.major) || Tr(this.minor, k.minor) || Tr(this.patch, k.patch)
						)
					}),
					(mt.prototype.comparePre = function (k) {
						if (
							(k instanceof mt || (k = new mt(k, this.loose)),
							this.prerelease.length && !k.prerelease.length)
						)
							return -1
						if (!this.prerelease.length && k.prerelease.length) return 1
						if (!this.prerelease.length && !k.prerelease.length) return 0
						var U = 0
						do {
							var B = this.prerelease[U],
								ve = k.prerelease[U]
							if ((r("prerelease compare", U, B, ve), B === void 0 && ve === void 0)) return 0
							if (ve === void 0) return 1
							if (B === void 0) return -1
							if (B !== ve) return Tr(B, ve)
						} while (++U)
					}),
					(mt.prototype.inc = function (k, U) {
						switch (k) {
							case "premajor":
								;(this.prerelease.length = 0),
									(this.patch = 0),
									(this.minor = 0),
									this.major++,
									this.inc("pre", U)
								break
							case "preminor":
								;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc("pre", U)
								break
							case "prepatch":
								;(this.prerelease.length = 0), this.inc("patch", U), this.inc("pre", U)
								break
							case "prerelease":
								this.prerelease.length === 0 && this.inc("patch", U), this.inc("pre", U)
								break
							case "major":
								;(this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0) || this.major++,
									(this.minor = 0),
									(this.patch = 0),
									(this.prerelease = [])
								break
							case "minor":
								;(this.patch === 0 && this.prerelease.length !== 0) || this.minor++,
									(this.patch = 0),
									(this.prerelease = [])
								break
							case "patch":
								this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
								break
							case "pre":
								if (this.prerelease.length === 0) this.prerelease = [0]
								else {
									for (var B = this.prerelease.length; --B >= 0; )
										typeof this.prerelease[B] == "number" && (this.prerelease[B]++, (B = -2))
									B === -1 && this.prerelease.push(0)
								}
								U &&
									(this.prerelease[0] === U
										? isNaN(this.prerelease[1]) && (this.prerelease = [U, 0])
										: (this.prerelease = [U, 0]))
								break
							default:
								throw new Error("invalid increment argument: " + k)
						}
						return this.format(), (this.raw = this.version), this
					}),
					(e.inc = function (k, U, B, ve) {
						typeof B == "string" && ((ve = B), (B = void 0))
						try {
							return new mt(k, B).inc(U, ve).version
						} catch {
							return null
						}
					}),
					(e.diff = function (k, U) {
						if (Gm(k, U)) return null
						var B = $e(k),
							ve = $e(U)
						if (B.prerelease.length || ve.prerelease.length) {
							for (var Me in B)
								if ((Me === "major" || Me === "minor" || Me === "patch") && B[Me] !== ve[Me])
									return "pre" + Me
							return "prerelease"
						}
						for (var Me in B)
							if ((Me === "major" || Me === "minor" || Me === "patch") && B[Me] !== ve[Me]) return Me
					}),
					(e.compareIdentifiers = Tr)
				var ov = /^[0-9]+$/
				function Tr(k, U) {
					var B = ov.test(k),
						ve = ov.test(U)
					return B && ve && ((k = +k), (U = +U)), B && !ve ? -1 : ve && !B ? 1 : k < U ? -1 : k > U ? 1 : 0
				}
				function fr(k, U, B) {
					return new mt(k, B).compare(new mt(U, B))
				}
				function wl(k, U, B) {
					return fr(k, U, B) > 0
				}
				function ac(k, U, B) {
					return fr(k, U, B) < 0
				}
				function Gm(k, U, B) {
					return fr(k, U, B) === 0
				}
				function iv(k, U, B) {
					return fr(k, U, B) !== 0
				}
				function lc(k, U, B) {
					return fr(k, U, B) >= 0
				}
				function Qm(k, U, B) {
					return fr(k, U, B) <= 0
				}
				function Pl(k, U, B, ve) {
					var Me
					switch (U) {
						case "===":
							typeof k == "object" && (k = k.version),
								typeof B == "object" && (B = B.version),
								(Me = k === B)
							break
						case "!==":
							typeof k == "object" && (k = k.version),
								typeof B == "object" && (B = B.version),
								(Me = k !== B)
							break
						case "":
						case "=":
						case "==":
							Me = Gm(k, B, ve)
							break
						case "!=":
							Me = iv(k, B, ve)
							break
						case ">":
							Me = wl(k, B, ve)
							break
						case ">=":
							Me = lc(k, B, ve)
							break
						case "<":
							Me = ac(k, B, ve)
							break
						case "<=":
							Me = Qm(k, B, ve)
							break
						default:
							throw new TypeError("Invalid operator: " + U)
					}
					return Me
				}
				function Er(k, U) {
					if (k instanceof Er) {
						if (k.loose === U) return k
						k = k.value
					}
					if (!(this instanceof Er)) return new Er(k, U)
					r("comparator", k, U),
						(this.loose = U),
						this.parse(k),
						this.semver === qi ? (this.value = "") : (this.value = this.operator + this.semver.version),
						r("comp", this)
				}
				;(e.rcompareIdentifiers = function (k, U) {
					return Tr(U, k)
				}),
					(e.major = function (k, U) {
						return new mt(k, U).major
					}),
					(e.minor = function (k, U) {
						return new mt(k, U).minor
					}),
					(e.patch = function (k, U) {
						return new mt(k, U).patch
					}),
					(e.compare = fr),
					(e.compareLoose = function (k, U) {
						return fr(k, U, !0)
					}),
					(e.rcompare = function (k, U, B) {
						return fr(U, k, B)
					}),
					(e.sort = function (k, U) {
						return k.sort(function (B, ve) {
							return e.compare(B, ve, U)
						})
					}),
					(e.rsort = function (k, U) {
						return k.sort(function (B, ve) {
							return e.rcompare(B, ve, U)
						})
					}),
					(e.gt = wl),
					(e.lt = ac),
					(e.eq = Gm),
					(e.neq = iv),
					(e.gte = lc),
					(e.lte = Qm),
					(e.cmp = Pl),
					(e.Comparator = Er)
				var qi = {}
				function Nt(k, U) {
					if (k instanceof Nt) return k.loose === U ? k : new Nt(k.raw, U)
					if (k instanceof Er) return new Nt(k.value, U)
					if (!(this instanceof Nt)) return new Nt(k, U)
					if (
						((this.loose = U),
						(this.raw = k),
						(this.set = k
							.split(/\s*\|\|\s*/)
							.map(function (B) {
								return this.parseRange(B.trim())
							}, this)
							.filter(function (B) {
								return B.length
							})),
						!this.set.length)
					)
						throw new TypeError("Invalid SemVer Range: " + k)
					this.format()
				}
				function Kn(k) {
					return !k || k.toLowerCase() === "x" || k === "*"
				}
				function XT(k, U, B, ve, Me, hn, it, rr, tn, Fn, wr, jt, Pn) {
					return (
						(U = Kn(B) ? "" : Kn(ve) ? ">=" + B + ".0.0" : Kn(Me) ? ">=" + B + "." + ve + ".0" : ">=" + U) +
						" " +
						(rr = Kn(tn)
							? ""
							: Kn(Fn)
								? "<" + (+tn + 1) + ".0.0"
								: Kn(wr)
									? "<" + tn + "." + (+Fn + 1) + ".0"
									: jt
										? "<=" + tn + "." + Fn + "." + wr + "-" + jt
										: "<=" + rr)
					).trim()
				}
				function ta(k, U) {
					for (var B = 0; B < k.length; B++) if (!k[B].test(U)) return !1
					if (U.prerelease.length) {
						for (B = 0; B < k.length; B++)
							if ((r(k[B].semver), k[B].semver !== qi && k[B].semver.prerelease.length > 0)) {
								var ve = k[B].semver
								if (ve.major === U.major && ve.minor === U.minor && ve.patch === U.patch) return !0
							}
						return !1
					}
					return !0
				}
				function dc(k, U, B) {
					try {
						U = new Nt(U, B)
					} catch {
						return !1
					}
					return U.test(k)
				}
				function Jm(k, U, B, ve) {
					var Me, hn, it, rr, tn
					switch (((k = new mt(k, ve)), (U = new Nt(U, ve)), B)) {
						case ">":
							;(Me = wl), (hn = Qm), (it = ac), (rr = ">"), (tn = ">=")
							break
						case "<":
							;(Me = ac), (hn = lc), (it = wl), (rr = "<"), (tn = "<=")
							break
						default:
							throw new TypeError('Must provide a hilo val of "<" or ">"')
					}
					if (dc(k, U, ve)) return !1
					for (var Fn = 0; Fn < U.set.length; ++Fn) {
						var wr = U.set[Fn],
							jt = null,
							Pn = null
						if (
							(wr.forEach(function (P) {
								P.semver === qi && (P = new Er(">=0.0.0")),
									(jt = jt || P),
									(Pn = Pn || P),
									Me(P.semver, jt.semver, ve) ? (jt = P) : it(P.semver, Pn.semver, ve) && (Pn = P)
							}),
							jt.operator === rr ||
								jt.operator === tn ||
								((!Pn.operator || Pn.operator === rr) && hn(k, Pn.semver)) ||
								(Pn.operator === tn && it(k, Pn.semver)))
						)
							return !1
					}
					return !0
				}
				;(Er.prototype.parse = function (k) {
					var U = this.loose ? a[Te] : a[wn],
						B = k.match(U)
					if (!B) throw new TypeError("Invalid comparator: " + k)
					;(this.operator = B[1]),
						this.operator === "=" && (this.operator = ""),
						B[2] ? (this.semver = new mt(B[2], this.loose)) : (this.semver = qi)
				}),
					(Er.prototype.toString = function () {
						return this.value
					}),
					(Er.prototype.test = function (k) {
						return (
							r("Comparator.test", k, this.loose),
							this.semver === qi ||
								(typeof k == "string" && (k = new mt(k, this.loose)),
								Pl(k, this.operator, this.semver, this.loose))
						)
					}),
					(Er.prototype.intersects = function (k, U) {
						if (!(k instanceof Er)) throw new TypeError("a Comparator is required")
						var B
						if (this.operator === "") return (B = new Nt(k.value, U)), dc(this.value, B, U)
						if (k.operator === "") return (B = new Nt(this.value, U)), dc(k.semver, B, U)
						var ve = !(
								(this.operator !== ">=" && this.operator !== ">") ||
								(k.operator !== ">=" && k.operator !== ">")
							),
							Me = !(
								(this.operator !== "<=" && this.operator !== "<") ||
								(k.operator !== "<=" && k.operator !== "<")
							),
							hn = this.semver.version === k.semver.version,
							it = !(
								(this.operator !== ">=" && this.operator !== "<=") ||
								(k.operator !== ">=" && k.operator !== "<=")
							),
							rr =
								Pl(this.semver, "<", k.semver, U) &&
								(this.operator === ">=" || this.operator === ">") &&
								(k.operator === "<=" || k.operator === "<"),
							tn =
								Pl(this.semver, ">", k.semver, U) &&
								(this.operator === "<=" || this.operator === "<") &&
								(k.operator === ">=" || k.operator === ">")
						return ve || Me || (hn && it) || rr || tn
					}),
					(e.Range = Nt),
					(Nt.prototype.format = function () {
						return (
							(this.range = this.set
								.map(function (k) {
									return k.join(" ").trim()
								})
								.join("||")
								.trim()),
							this.range
						)
					}),
					(Nt.prototype.toString = function () {
						return this.range
					}),
					(Nt.prototype.parseRange = function (k) {
						var U = this.loose
						;(k = k.trim()), r("range", k, U)
						var B = U ? a[sc] : a[ro]
						;(k = k.replace(B, XT)),
							r("hyphen replace", k),
							(k = k.replace(a[Ft], "$1$2$3")),
							r("comparator trim", k, a[Ft]),
							(k = (k = (k = k.replace(a[ee], "$1~")).replace(a[de], "$1^")).split(/\s+/).join(" "))
						var ve = U ? a[Te] : a[wn],
							Me = k
								.split(" ")
								.map(function (hn) {
									return (function (it, rr) {
										return (
											r("comp", it),
											(it = (function (tn, Fn) {
												return tn
													.trim()
													.split(/\s+/)
													.map(function (wr) {
														return (function (jt, Pn) {
															r("caret", jt, Pn)
															var P = Pn ? a[_t] : a[Et]
															return jt.replace(P, function (vn, Ne, X, xe, Ut) {
																var _n
																return (
																	r("caret", jt, vn, Ne, X, xe, Ut),
																	Kn(Ne)
																		? (_n = "")
																		: Kn(X)
																			? (_n =
																					">=" +
																					Ne +
																					".0.0 <" +
																					(+Ne + 1) +
																					".0.0")
																			: Kn(xe)
																				? (_n =
																						Ne === "0"
																							? ">=" +
																								Ne +
																								"." +
																								X +
																								".0 <" +
																								Ne +
																								"." +
																								(+X + 1) +
																								".0"
																							: ">=" +
																								Ne +
																								"." +
																								X +
																								".0 <" +
																								(+Ne + 1) +
																								".0.0")
																				: Ut
																					? (r("replaceCaret pr", Ut),
																						Ut.charAt(0) !== "-" &&
																							(Ut = "-" + Ut),
																						(_n =
																							Ne === "0"
																								? X === "0"
																									? ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										Ut +
																										" <" +
																										Ne +
																										"." +
																										X +
																										"." +
																										(+xe + 1)
																									: ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										Ut +
																										" <" +
																										Ne +
																										"." +
																										(+X + 1) +
																										".0"
																								: ">=" +
																									Ne +
																									"." +
																									X +
																									"." +
																									xe +
																									Ut +
																									" <" +
																									(+Ne + 1) +
																									".0.0"))
																					: (r("no pr"),
																						(_n =
																							Ne === "0"
																								? X === "0"
																									? ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										" <" +
																										Ne +
																										"." +
																										X +
																										"." +
																										(+xe + 1)
																									: ">=" +
																										Ne +
																										"." +
																										X +
																										"." +
																										xe +
																										" <" +
																										Ne +
																										"." +
																										(+X + 1) +
																										".0"
																								: ">=" +
																									Ne +
																									"." +
																									X +
																									"." +
																									xe +
																									" <" +
																									(+Ne + 1) +
																									".0.0")),
																	r("caret return", _n),
																	_n
																)
															})
														})(wr, Fn)
													})
													.join(" ")
											})(it, rr)),
											r("caret", it),
											(it = (function (tn, Fn) {
												return tn
													.trim()
													.split(/\s+/)
													.map(function (wr) {
														return (function (jt, Pn) {
															var P = Pn ? a[Ae] : a[fe]
															return jt.replace(P, function (vn, Ne, X, xe, Ut) {
																var _n
																return (
																	r("tilde", jt, vn, Ne, X, xe, Ut),
																	Kn(Ne)
																		? (_n = "")
																		: Kn(X)
																			? (_n =
																					">=" +
																					Ne +
																					".0.0 <" +
																					(+Ne + 1) +
																					".0.0")
																			: Kn(xe)
																				? (_n =
																						">=" +
																						Ne +
																						"." +
																						X +
																						".0 <" +
																						Ne +
																						"." +
																						(+X + 1) +
																						".0")
																				: Ut
																					? (r("replaceTilde pr", Ut),
																						Ut.charAt(0) !== "-" &&
																							(Ut = "-" + Ut),
																						(_n =
																							">=" +
																							Ne +
																							"." +
																							X +
																							"." +
																							xe +
																							Ut +
																							" <" +
																							Ne +
																							"." +
																							(+X + 1) +
																							".0"))
																					: (_n =
																							">=" +
																							Ne +
																							"." +
																							X +
																							"." +
																							xe +
																							" <" +
																							Ne +
																							"." +
																							(+X + 1) +
																							".0"),
																	r("tilde return", _n),
																	_n
																)
															})
														})(wr, Fn)
													})
													.join(" ")
											})(it, rr)),
											r("tildes", it),
											(it = (function (tn, Fn) {
												return (
													r("replaceXRanges", tn, Fn),
													tn
														.split(/\s+/)
														.map(function (wr) {
															return (function (jt, Pn) {
																jt = jt.trim()
																var P = Pn ? a[ae] : a[vt]
																return jt.replace(P, function (vn, Ne, X, xe, Ut, _n) {
																	r("xRange", jt, vn, Ne, X, xe, Ut, _n)
																	var Xm = Kn(X),
																		_l = Xm || Kn(xe),
																		ii = _l || Kn(Ut)
																	return (
																		Ne === "=" && ii && (Ne = ""),
																		Xm
																			? (vn =
																					Ne === ">" || Ne === "<"
																						? "<0.0.0"
																						: "*")
																			: Ne && ii
																				? (_l && (xe = 0),
																					ii && (Ut = 0),
																					Ne === ">"
																						? ((Ne = ">="),
																							_l
																								? ((X = +X + 1),
																									(xe = 0),
																									(Ut = 0))
																								: ii &&
																									((xe = +xe + 1),
																									(Ut = 0)))
																						: Ne === "<=" &&
																							((Ne = "<"),
																							_l
																								? (X = +X + 1)
																								: (xe = +xe + 1)),
																					(vn = Ne + X + "." + xe + "." + Ut))
																				: _l
																					? (vn =
																							">=" +
																							X +
																							".0.0 <" +
																							(+X + 1) +
																							".0.0")
																					: ii &&
																						(vn =
																							">=" +
																							X +
																							"." +
																							xe +
																							".0 <" +
																							X +
																							"." +
																							(+xe + 1) +
																							".0"),
																		r("xRange return", vn),
																		vn
																	)
																})
															})(wr, Fn)
														})
														.join(" ")
												)
											})(it, rr)),
											r("xrange", it),
											(it = (function (tn, Fn) {
												return r("replaceStars", tn, Fn), tn.trim().replace(a[oi], "")
											})(it, rr)),
											r("stars", it),
											it
										)
									})(hn, U)
								})
								.join(" ")
								.split(/\s+/)
						return (
							this.loose &&
								(Me = Me.filter(function (hn) {
									return !!hn.match(ve)
								})),
							(Me = Me.map(function (hn) {
								return new Er(hn, U)
							}))
						)
					}),
					(Nt.prototype.intersects = function (k, U) {
						if (!(k instanceof Nt)) throw new TypeError("a Range is required")
						return this.set.some(function (B) {
							return B.every(function (ve) {
								return k.set.some(function (Me) {
									return Me.every(function (hn) {
										return ve.intersects(hn, U)
									})
								})
							})
						})
					}),
					(e.toComparators = function (k, U) {
						return new Nt(k, U).set.map(function (B) {
							return B.map(function (ve) {
								return ve.value
							})
								.join(" ")
								.trim()
								.split(" ")
						})
					}),
					(Nt.prototype.test = function (k) {
						if (!k) return !1
						typeof k == "string" && (k = new mt(k, this.loose))
						for (var U = 0; U < this.set.length; U++) if (ta(this.set[U], k)) return !0
						return !1
					}),
					(e.satisfies = dc),
					(e.maxSatisfying = function (k, U, B) {
						var ve = null,
							Me = null
						try {
							var hn = new Nt(U, B)
						} catch {
							return null
						}
						return (
							k.forEach(function (it) {
								hn.test(it) && ((ve && Me.compare(it) !== -1) || (Me = new mt((ve = it), B)))
							}),
							ve
						)
					}),
					(e.minSatisfying = function (k, U, B) {
						var ve = null,
							Me = null
						try {
							var hn = new Nt(U, B)
						} catch {
							return null
						}
						return (
							k.forEach(function (it) {
								hn.test(it) && ((ve && Me.compare(it) !== 1) || (Me = new mt((ve = it), B)))
							}),
							ve
						)
					}),
					(e.validRange = function (k, U) {
						try {
							return new Nt(k, U).range || "*"
						} catch {
							return null
						}
					}),
					(e.ltr = function (k, U, B) {
						return Jm(k, U, "<", B)
					}),
					(e.gtr = function (k, U, B) {
						return Jm(k, U, ">", B)
					}),
					(e.outside = Jm),
					(e.prerelease = function (k, U) {
						var B = $e(k, U)
						return B && B.prerelease.length ? B.prerelease : null
					}),
					(e.intersects = function (k, U, B) {
						return (k = new Nt(k, B)), (U = new Nt(U, B)), k.intersects(U)
					}),
					(e.coerce = function (k) {
						if (k instanceof mt) return k
						if (typeof k != "string") return null
						var U = k.match(a[Z])
						return U == null ? null : $e((U[1] || "0") + "." + (U[2] || "0") + "." + (U[3] || "0"))
					})
			}).call(this, t(1))
		},
		function (o, e) {
			var t,
				n,
				r = (o.exports = {})
			function i() {
				throw new Error("setTimeout has not been defined")
			}
			function s() {
				throw new Error("clearTimeout has not been defined")
			}
			function a(I) {
				if (t === setTimeout) return setTimeout(I, 0)
				if ((t === i || !t) && setTimeout) return (t = setTimeout), setTimeout(I, 0)
				try {
					return t(I, 0)
				} catch {
					try {
						return t.call(null, I, 0)
					} catch {
						return t.call(this, I, 0)
					}
				}
			}
			;(function () {
				try {
					t = typeof setTimeout == "function" ? setTimeout : i
				} catch {
					t = i
				}
				try {
					n = typeof clearTimeout == "function" ? clearTimeout : s
				} catch {
					n = s
				}
			})()
			var l,
				d = [],
				c = !1,
				u = -1
			function m() {
				c && l && ((c = !1), l.length ? (d = l.concat(d)) : (u = -1), d.length && f())
			}
			function f() {
				if (!c) {
					var I = a(m)
					c = !0
					for (var C = d.length; C; ) {
						for (l = d, d = []; ++u < C; ) l && l[u].run()
						;(u = -1), (C = d.length)
					}
					;(l = null),
						(c = !1),
						(function (T) {
							if (n === clearTimeout) return clearTimeout(T)
							if ((n === s || !n) && clearTimeout) return (n = clearTimeout), clearTimeout(T)
							try {
								n(T)
							} catch {
								try {
									return n.call(null, T)
								} catch {
									return n.call(this, T)
								}
							}
						})(I)
				}
			}
			function h(I, C) {
				;(this.fun = I), (this.array = C)
			}
			function g() {}
			;(r.nextTick = function (I) {
				var C = new Array(arguments.length - 1)
				if (arguments.length > 1) for (var T = 1; T < arguments.length; T++) C[T - 1] = arguments[T]
				d.push(new h(I, C)), d.length !== 1 || c || a(f)
			}),
				(h.prototype.run = function () {
					this.fun.apply(null, this.array)
				}),
				(r.title = "browser"),
				(r.browser = !0),
				(r.env = {}),
				(r.argv = []),
				(r.version = ""),
				(r.versions = {}),
				(r.on = g),
				(r.addListener = g),
				(r.once = g),
				(r.off = g),
				(r.removeListener = g),
				(r.removeAllListeners = g),
				(r.emit = g),
				(r.prependListener = g),
				(r.prependOnceListener = g),
				(r.listeners = function (I) {
					return []
				}),
				(r.binding = function (I) {
					throw new Error("process.binding is not supported")
				}),
				(r.cwd = function () {
					return "/"
				}),
				(r.chdir = function (I) {
					throw new Error("process.chdir is not supported")
				}),
				(r.umask = function () {
					return 0
				})
		},
	])
})
var d2e = ot.exports.SEMVER_SPEC_VERSION,
	c2e = ot.exports.parse,
	fB = ot.exports.valid,
	u2e = ot.exports.coerce,
	p2e = ot.exports.clean,
	m2e = ot.exports.inc,
	f2e = ot.exports.major,
	g2e = ot.exports.minor,
	h2e = ot.exports.patch,
	v2e = ot.exports.prerelease,
	b2e = ot.exports.gt,
	y2e = ot.exports.gte,
	I2e = ot.exports.lt,
	x2e = ot.exports.lte,
	C2e = ot.exports.eq,
	S2e = ot.exports.neq,
	T2e = ot.exports.cmp,
	E2e = ot.exports.compare,
	w2e = ot.exports.rcompare,
	P2e = ot.exports.compareIdentifiers,
	_2e = ot.exports.rcompareIdentifiers,
	D2e = ot.exports.compareBuild,
	k2e = ot.exports.sort,
	R2e = ot.exports.rsort,
	A2e = ot.exports.diff,
	O2e = ot.exports.validRange,
	L2e = ot.exports.satisfies,
	M2e = ot.exports.maxSatisfying,
	F2e = ot.exports.minSatisfying,
	N2e = ot.exports.minVersion,
	U2e = ot.exports.gtr,
	H2e = ot.exports.ltr,
	W2e = ot.exports.outside,
	V2e = ot.exports.intersects,
	B2e = ot.exports.SemVer,
	$2e = ot.exports.Comparator,
	z2e = ot.exports.Range
var UN = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/,
	hB = /^-(\d{4})(\d{2})(\d{2})$/
function vB(o) {
	return (o = o.trim()), o === "*" || UN.test(o)
}
function o1(o) {
	if (!vB(o)) return null
	if (((o = o.trim()), o === "*"))
		return {
			hasCaret: !1,
			hasGreaterEquals: !1,
			majorBase: 0,
			majorMustEqual: !1,
			minorBase: 0,
			minorMustEqual: !1,
			patchBase: 0,
			patchMustEqual: !1,
			preRelease: null,
		}
	let e = o.match(UN)
	return e
		? {
				hasCaret: e[1] === "^",
				hasGreaterEquals: e[1] === ">=",
				majorBase: e[2] === "x" ? 0 : parseInt(e[2], 10),
				majorMustEqual: e[2] !== "x",
				minorBase: e[4] === "x" ? 0 : parseInt(e[4], 10),
				minorMustEqual: e[4] !== "x",
				patchBase: e[6] === "x" ? 0 : parseInt(e[6], 10),
				patchMustEqual: e[6] !== "x",
				preRelease: e[8] || null,
			}
		: null
}
function i1(o) {
	if (!o) return null
	let e = o.majorBase,
		t = o.majorMustEqual,
		n = o.minorBase,
		r = o.minorMustEqual,
		i = o.patchBase,
		s = o.patchMustEqual
	o.hasCaret && (e === 0 || (r = !1), (s = !1))
	let a = 0
	if (o.preRelease) {
		let l = hB.exec(o.preRelease)
		if (l) {
			let [, d, c, u] = l
			a = Date.UTC(Number(d), Number(c) - 1, Number(u))
		}
	}
	return {
		majorBase: e,
		majorMustEqual: t,
		minorBase: n,
		minorMustEqual: r,
		patchBase: i,
		patchMustEqual: s,
		isMinimum: o.hasGreaterEquals,
		notBefore: a,
	}
}
var s1 = class {
	constructor() {
		this.buffers = []
	}
	add(e) {
		let t = this.buffers.indexOf(e)
		return t < 0 && ((t = this.buffers.length), this.buffers.push(e)), t
	}
}
function HN(o, e) {
	if (e.serializeBuffersForPostMessage) {
		let t = new s1(),
			r = JSON.stringify(o, (s, a) => {
				if (a instanceof ArrayBuffer) return { $$vscode_array_buffer_reference$$: !0, index: t.add(a) }
				if (ArrayBuffer.isView(a)) {
					let l = bB(a)
					if (l)
						return {
							$$vscode_array_buffer_reference$$: !0,
							index: t.add(a.buffer),
							view: { type: l, byteLength: a.byteLength, byteOffset: a.byteOffset },
						}
				}
				return a
			}),
			i = t.buffers.map((s) => {
				let a = new Uint8Array(s)
				return z.wrap(a)
			})
		return { message: r, buffers: i }
	} else return { message: JSON.stringify(o), buffers: [] }
}
function bB(o) {
	switch (o.constructor.name) {
		case "Int8Array":
			return 1
		case "Uint8Array":
			return 2
		case "Uint8ClampedArray":
			return 3
		case "Int16Array":
			return 4
		case "Uint16Array":
			return 5
		case "Int32Array":
			return 6
		case "Uint32Array":
			return 7
		case "Float32Array":
			return 8
		case "Float64Array":
			return 9
		case "BigInt64Array":
			return 10
		case "BigUint64Array":
			return 11
	}
}
function WN(o, e) {
	let t = e.map((i) => {
			let s = new ArrayBuffer(i.byteLength)
			return new Uint8Array(s).set(i.buffer), s
		}),
		n = e.length
			? (i, s) => {
					if (s && typeof s == "object" && s.$$vscode_array_buffer_reference$$) {
						let a = s,
							{ index: l } = a,
							d = t[l]
						if (a.view)
							switch (a.view.type) {
								case 1:
									return new Int8Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int8Array.BYTES_PER_ELEMENT,
									)
								case 2:
									return new Uint8Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint8Array.BYTES_PER_ELEMENT,
									)
								case 3:
									return new Uint8ClampedArray(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT,
									)
								case 4:
									return new Int16Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int16Array.BYTES_PER_ELEMENT,
									)
								case 5:
									return new Uint16Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint16Array.BYTES_PER_ELEMENT,
									)
								case 6:
									return new Int32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Int32Array.BYTES_PER_ELEMENT,
									)
								case 7:
									return new Uint32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Uint32Array.BYTES_PER_ELEMENT,
									)
								case 8:
									return new Float32Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Float32Array.BYTES_PER_ELEMENT,
									)
								case 9:
									return new Float64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / Float64Array.BYTES_PER_ELEMENT,
									)
								case 10:
									return new BigInt64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT,
									)
								case 11:
									return new BigUint64Array(
										d,
										a.view.byteOffset,
										a.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT,
									)
								default:
									throw new Error("Unknown array buffer view type")
							}
						return d
					}
					return s
				}
			: void 0
	return { message: JSON.parse(o, n), arrayBuffers: t }
}
var a1 = class {
	constructor(e, t, n, r, i, s, a) {
		this.#a = ""
		this.#l = !1
		this.#d = !1
		this._onMessageEmitter = new E()
		this.onDidReceiveMessage = this._onMessageEmitter.event
		this.#p = new E()
		this._onDidDispose = this.#p.event
		;(this.#e = e),
			(this.#t = t),
			(this.#s = n),
			(this.#r = r),
			(this.#i = i),
			(this.#o = s),
			(this.#c = Gs(s)),
			(this.#u = yB(s)),
			(this.#n = a)
	}
	#e
	#t
	#n
	#r
	#i
	#o
	#a
	#s
	#l
	#d
	#c
	#u
	#p
	dispose() {
		;(this.#l = !0), this.#p.fire(), this.#p.dispose(), this._onMessageEmitter.dispose()
	}
	asWebviewUri(e) {
		return (this.#d = !0), xl(e, this.#r)
	}
	get cspSource() {
		let e = this.#o.extensionLocation
		if (e.scheme === W.https || e.scheme === W.http) {
			let t = e.toString()
			return t.endsWith("/") || (t += "/"), t + " " + Ch
		}
		return Ch
	}
	get html() {
		return this.assertNotDisposed(), this.#a
	}
	set html(e) {
		this.assertNotDisposed(),
			this.#a !== e &&
				((this.#a = e),
				this.#u &&
					!this.#d &&
					/(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(e) &&
					((this.#d = !0),
					this.#n.report(
						"Webview vscode-resource: uris",
						this.#o,
						"Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri",
					)),
				this.#t.$setHtml(this.#e, this.rewriteOldResourceUrlsIfNeeded(e)))
	}
	get options() {
		return this.assertNotDisposed(), this.#s
	}
	set options(e) {
		this.assertNotDisposed(), nn(this.#s, e) || this.#t.$setOptions(this.#e, l1(this.#o, this.#i, e)), (this.#s = e)
	}
	async postMessage(e) {
		if (this.#l) return !1
		let t = HN(e, { serializeBuffersForPostMessage: this.#c })
		return this.#t.$postMessage(this.#e, t.message, ...t.buffers)
	}
	assertNotDisposed() {
		if (this.#l) throw new Error("Webview is disposed")
	}
	rewriteOldResourceUrlsIfNeeded(e) {
		if (!this.#u) return e
		let t = this.#o.extensionLocation?.scheme === W.vscodeRemote,
			n = this.#o.extensionLocation.scheme === W.vscodeRemote ? this.#o.extensionLocation.authority : void 0
		return e
			.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (r, i, s, a, l, d) => {
				let c = b.from({ scheme: a || "file", path: decodeURIComponent(l) }),
					u = xl(c, { isRemote: t, authority: n }).toString()
				return `${i}${u}${d}`
			})
			.replace(
				/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
				(r, i, s, a, l, d) => {
					let c = b.from({ scheme: a || "file", path: decodeURIComponent(l) }),
						u = xl(c, { isRemote: t, authority: n }).toString()
					return `${i}${u}${d}`
				},
			)
	}
}
function Gs(o) {
	try {
		let e = i1(o1(o.engines.vscode))
		return !!e && e.majorBase >= 1 && e.minorBase >= 57
	} catch {
		return !1
	}
}
function yB(o) {
	try {
		let e = i1(o1(o.engines.vscode))
		return e ? e.majorBase < 1 || (e.majorBase === 1 && e.minorBase < 60) : !1
	} catch {
		return !1
	}
}
var jC = class extends $ {
	constructor(t, n, r, i, s) {
		super()
		this.remoteInfo = n
		this.workspace = r
		this._logService = i
		this._deprecationService = s
		this._webviews = new Map()
		this._webviewProxy = t.getProxy(M.MainThreadWebviews)
	}
	dispose() {
		super.dispose()
		for (let t of this._webviews.values()) t.dispose()
		this._webviews.clear()
	}
	$onMessage(t, n, r) {
		console.log("onMessage", t, n, r)
		let i = this.getWebview(t)
		if (i) {
			let { message: s } = WN(n, r.value)
			i._onMessageEmitter.fire(s)
		}
	}
	$onMissingCsp(t, n) {
		this._logService.warn(
			`${n} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`,
		)
	}
	createNewWebview(t, n, r) {
		let i = new a1(t, this._webviewProxy, IB(n), this.remoteInfo, this.workspace, r, this._deprecationService)
		this._webviews.set(t, i)
		let s = i._onDidDispose(() => {
			s.dispose(), this.deleteWebview(t)
		})
		return i
	}
	deleteWebview(t) {
		this._webviews.delete(t)
	}
	getWebview(t) {
		return this._webviews.get(t)
	}
}
function Kd(o) {
	return { id: o.identifier, location: o.extensionLocation }
}
function l1(o, e, t) {
	return {
		enableCommandUris: t.enableCommandUris,
		enableScripts: t.enableScripts,
		enableForms: t.enableForms,
		portMapping: t.portMapping,
		localResourceRoots: t.localResourceRoots || xB(o, e),
	}
}
function IB(o) {
	return {
		enableCommandUris: o.enableCommandUris,
		enableScripts: o.enableScripts,
		enableForms: o.enableForms,
		portMapping: o.portMapping,
		localResourceRoots: o.localResourceRoots?.map((e) => b.from(e)),
	}
}
function xB(o, e) {
	return [...(e?.getWorkspaceFolders() || []).map((t) => t.uri), o.extensionLocation]
}
var mr = class o {
	constructor(e) {
		this.id = e
		this._data = new Map()
		this._idPool = 1
	}
	static {
		this.enableDebugLogging = !1
	}
	add(e) {
		let t = this._idPool++
		return this._data.set(t, e), this.logDebugInfo(), t
	}
	get(e, t) {
		return this._data.has(e) ? this._data.get(e)[t] : void 0
	}
	delete(e) {
		this._data.delete(e), this.logDebugInfo()
	}
	logDebugInfo() {
		o.enableDebugLogging && console.log(`${this.id} cache size - ${this._data.size}`)
	}
}
var d1 = class {
		constructor(e, t) {
			this.document = e
			this._storagePath = t
			this._backupCounter = 1
			this._edits = new mr("custom documents")
		}
		addEdit(e) {
			return this._edits.add([e])
		}
		async undo(e, t) {
			await this.getEdit(e).undo(), t || this.disposeBackup()
		}
		async redo(e, t) {
			await this.getEdit(e).redo(), t || this.disposeBackup()
		}
		disposeEdits(e) {
			for (let t of e) this._edits.delete(t)
		}
		getNewBackupUri() {
			if (!this._storagePath) throw new Error("Backup requires a valid storage path")
			let e = TB(this.document.uri) + this._backupCounter++
			return ct(this._storagePath, e)
		}
		updateBackup(e) {
			this._backup?.delete(), (this._backup = e)
		}
		disposeBackup() {
			this._backup?.delete(), (this._backup = void 0)
		}
		getEdit(e) {
			let t = this._edits.get(e, 0)
			if (!t) throw new Error("No edit found")
			return t
		}
	},
	c1 = class {
		constructor() {
			this._documents = new Map()
		}
		get(e, t) {
			return this._documents.get(this.key(e, t))
		}
		add(e, t, n) {
			let r = this.key(e, t.uri)
			if (this._documents.has(r)) throw new Error(`Document already exists for viewType:${e} resource:${t.uri}`)
			let i = new d1(t, n)
			return this._documents.set(r, i), i
		}
		delete(e, t) {
			let n = this.key(e, t.uri)
			this._documents.delete(n)
		}
		key(e, t) {
			return `${e}@@@${t}`
		}
	}
var u1 = class {
		constructor() {
			this._providers = new Map()
		}
		addTextProvider(e, t, n) {
			return this.add(e, { type: 0, extension: t, provider: n })
		}
		addCustomProvider(e, t, n) {
			return this.add(e, { type: 1, extension: t, provider: n })
		}
		get(e) {
			return this._providers.get(e)
		}
		add(e, t) {
			if (this._providers.has(e)) throw new Error(`Provider for viewType:${e} already registered`)
			return this._providers.set(e, t), new ye(() => this._providers.delete(e))
		}
	},
	QC = class {
		constructor(e, t, n, r, i) {
			this._extHostDocuments = t
			this._extensionStoragePaths = n
			this._extHostWebview = r
			this._extHostWebviewPanels = i
			this._editorProviders = new u1()
			this._documents = new c1()
			this._proxy = e.getProxy(M.MainThreadCustomEditors)
		}
		registerCustomEditorProvider(e, t, n, r) {
			let i = new Q()
			return (
				CB(n)
					? (i.add(this._editorProviders.addTextProvider(t, e, n)),
						this._proxy.$registerTextEditorProvider(
							Kd(e),
							t,
							r.webviewOptions || {},
							{ supportsMove: !!n.moveCustomTextEditor },
							Gs(e),
						))
					: (i.add(this._editorProviders.addCustomProvider(t, e, n)),
						GC(n) &&
							i.add(
								n.onDidChangeCustomDocument((s) => {
									let a = this.getCustomDocumentEntry(t, s.document.uri)
									if (SB(s)) {
										let l = a.addEdit(s)
										this._proxy.$onDidEdit(s.document.uri, t, l, s.label)
									} else this._proxy.$onContentChange(s.document.uri, t)
								}),
							),
						this._proxy.$registerCustomEditorProvider(
							Kd(e),
							t,
							r.webviewOptions || {},
							!!r.supportsMultipleEditorsPerDocument,
							Gs(e),
						)),
				ye.from(
					i,
					new ye(() => {
						this._proxy.$unregisterEditorProvider(t)
					}),
				)
			)
		}
		async $createCustomDocument(e, t, n, r, i) {
			let s = this._editorProviders.get(t)
			if (!s) throw new Error(`No provider found for '${t}'`)
			if (s.type !== 1) throw new Error(`Invalid provide type for '${t}'`)
			let a = b.revive(e),
				l = await s.provider.openCustomDocument(a, { backupId: n, untitledDocumentData: r?.buffer }, i),
				d
			return (
				GC(s.provider) &&
					this._extensionStoragePaths &&
					(d =
						this._extensionStoragePaths.workspaceValue(s.extension) ??
						this._extensionStoragePaths.globalValue(s.extension)),
				this._documents.add(t, l, d),
				{ editable: GC(s.provider) }
			)
		}
		async $disposeCustomDocument(e, t) {
			let n = this._editorProviders.get(t)
			if (!n) throw new Error(`No provider found for '${t}'`)
			if (n.type !== 1) throw new Error(`Invalid provider type for '${t}'`)
			let r = b.revive(e),
				{ document: i } = this.getCustomDocumentEntry(t, r)
			this._documents.delete(t, i), i.dispose()
		}
		async $resolveCustomEditor(e, t, n, r, i, s) {
			let a = this._editorProviders.get(n)
			if (!a) throw new Error(`No provider found for '${n}'`)
			let l = wt.to(i),
				d = this._extHostWebview.createNewWebview(t, r.contentOptions, a.extension),
				c = this._extHostWebviewPanels.createNewWebviewPanel(t, n, r.title, l, r.options, d, r.active),
				u = b.revive(e)
			switch (a.type) {
				case 1: {
					let { document: m } = this.getCustomDocumentEntry(n, u)
					return a.provider.resolveCustomEditor(m, c, s)
				}
				case 0: {
					let m = this._extHostDocuments.getDocument(u)
					return a.provider.resolveCustomTextEditor(m, c, s)
				}
				default:
					throw new Error("Unknown webview provider type")
			}
		}
		$disposeEdits(e, t, n) {
			this.getCustomDocumentEntry(t, e).disposeEdits(n)
		}
		async $onMoveCustomEditor(e, t, n) {
			let r = this._editorProviders.get(n)
			if (!r) throw new Error(`No provider found for '${n}'`)
			if (!r.provider.moveCustomTextEditor) throw new Error(`Provider does not implement move '${n}'`)
			let i = this._extHostWebviewPanels.getWebviewPanel(e)
			if (!i) throw new Error("No webview found")
			let s = b.revive(t),
				a = this._extHostDocuments.getDocument(s)
			await r.provider.moveCustomTextEditor(a, i, De.None)
		}
		async $undo(e, t, n, r) {
			return this.getCustomDocumentEntry(t, e).undo(n, r)
		}
		async $redo(e, t, n, r) {
			return this.getCustomDocumentEntry(t, e).redo(n, r)
		}
		async $revert(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e)
			await this.getCustomEditorProvider(t).revertCustomDocument(r.document, n), r.disposeBackup()
		}
		async $onSave(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e)
			await this.getCustomEditorProvider(t).saveCustomDocument(r.document, n), r.disposeBackup()
		}
		async $onSaveAs(e, t, n, r) {
			let i = this.getCustomDocumentEntry(t, e)
			return this.getCustomEditorProvider(t).saveCustomDocumentAs(i.document, b.revive(n), r)
		}
		async $backup(e, t, n) {
			let r = this.getCustomDocumentEntry(t, e),
				s = await this.getCustomEditorProvider(t).backupCustomDocument(
					r.document,
					{ destination: r.getNewBackupUri() },
					n,
				)
			return r.updateBackup(s), s.id
		}
		getCustomDocumentEntry(e, t) {
			let n = this._documents.get(e, b.revive(t))
			if (!n) throw new Error("No custom document found")
			return n
		}
		getCustomEditorProvider(e) {
			let n = this._editorProviders.get(e)?.provider
			if (!n || !GC(n)) throw new Error("Custom document is not editable")
			return n
		}
	}
function GC(o) {
	return !!o.onDidChangeCustomDocument
}
function CB(o) {
	return typeof o.resolveCustomTextEditor == "function"
}
function SB(o) {
	return typeof o.undo == "function" && typeof o.redo == "function"
}
function TB(o) {
	let e = o.scheme === W.file || o.scheme === W.untitled ? o.fsPath : o.toString()
	return lr(e) + ""
}
var JC = class o {
		constructor(e, t, n, r, i, s, a, l) {
			this._name = e
			this._owner = t
			this._maxDiagnosticsTotal = n
			this._maxDiagnosticsPerFile = r
			this._modelVersionIdProvider = i
			this._isDisposed = !1
			;(this._maxDiagnosticsTotal = Math.max(r, n)),
				(this.#n = new ft((d) => s.getComparisonKey(d))),
				(this.#e = a),
				(this.#t = l)
		}
		#e
		#t
		#n
		dispose() {
			this._isDisposed ||
				(this.#t.fire([...this.#n.keys()]),
				this.#e?.$clear(this._owner),
				this.#n.clear(),
				(this._isDisposed = !0))
		}
		get name() {
			return this._checkDisposed(), this._name
		}
		set(e, t) {
			if (!e) {
				this.clear()
				return
			}
			this._checkDisposed()
			let n = []
			if (b.isUri(e)) {
				if (!t) {
					this.delete(e)
					return
				}
				this.#n.set(e, t.slice()), (n = [e])
			} else if (Array.isArray(e)) {
				n = []
				let s
				e = [...e].sort(o._compareIndexedTuplesByUri)
				for (let a of e) {
					let [l, d] = a
					if (
						((!s || l.toString() !== s.toString()) &&
							(s && this.#n.get(s).length === 0 && this.#n.delete(s),
							(s = l),
							n.push(l),
							this.#n.set(l, [])),
						d)
					)
						this.#n.get(l)?.push(...d)
					else {
						let c = this.#n.get(l)
						c && (c.length = 0)
					}
				}
			}
			if ((this.#t.fire(n), !this.#e)) return
			let r = [],
				i = 0
			for (let s of n) {
				let a = [],
					l = this.#n.get(s)
				if (l)
					if (l.length > this._maxDiagnosticsPerFile) {
						a = []
						let d = [0, 1, 2, 3]
						e: for (let c = 0; c < 4; c++)
							for (let u of l)
								if (
									u.severity === d[c] &&
									a.push({ ...Rd.from(u), modelVersionId: this._modelVersionIdProvider(s) }) ===
										this._maxDiagnosticsPerFile
								)
									break e
						a.push({
							severity: 2,
							message: p(
								{ key: "limitHit", comment: ["amount of errors/warning skipped due to limits"] },
								"Not showing {0} further errors and warnings.",
								l.length - this._maxDiagnosticsPerFile,
							),
							startLineNumber: a[a.length - 1].startLineNumber,
							startColumn: a[a.length - 1].startColumn,
							endLineNumber: a[a.length - 1].endLineNumber,
							endColumn: a[a.length - 1].endColumn,
						})
					} else a = l.map((d) => ({ ...Rd.from(d), modelVersionId: this._modelVersionIdProvider(s) }))
				if ((r.push([s, a]), (i += a.length), i > this._maxDiagnosticsTotal)) break
			}
			this.#e.$changeMany(this._owner, r)
		}
		delete(e) {
			this._checkDisposed(),
				this.#t.fire([e]),
				this.#n.delete(e),
				this.#e?.$changeMany(this._owner, [[e, void 0]])
		}
		clear() {
			this._checkDisposed(), this.#t.fire([...this.#n.keys()]), this.#n.clear(), this.#e?.$clear(this._owner)
		}
		forEach(e, t) {
			this._checkDisposed()
			for (let [n, r] of this) e.call(t, n, r, this)
		}
		*[Symbol.iterator]() {
			this._checkDisposed()
			for (let e of this.#n.keys()) yield [e, this.get(e)]
		}
		get(e) {
			this._checkDisposed()
			let t = this.#n.get(e)
			return Array.isArray(t) ? Object.freeze(t.slice(0)) : []
		}
		has(e) {
			return this._checkDisposed(), Array.isArray(this.#n.get(e))
		}
		_checkDisposed() {
			if (this._isDisposed) throw new Error("illegal state - object is disposed")
		}
		static _compareIndexedTuplesByUri(e, t) {
			return e[0].toString() < t[0].toString() ? -1 : e[0].toString() > t[0].toString() ? 1 : 0
		}
	},
	Eo = class {
		constructor(e, t, n, r) {
			this._logService = t
			this._fileSystemInfoService = n
			this._extHostDocumentsAndEditors = r
			this._collections = new Map()
			this._onDidChangeDiagnostics = new bv({ merge: (e) => e.flat(), delay: 50 })
			this.onDidChangeDiagnostics = Ee.map(this._onDidChangeDiagnostics.event, Eo._mapper)
			this._proxy = e.getProxy(M.MainThreadDiagnostics)
		}
		static {
			this._idPool = 0
		}
		static {
			this._maxDiagnosticsPerFile = 1e3
		}
		static {
			this._maxDiagnosticsTotal = 1.1 * this._maxDiagnosticsPerFile
		}
		static _mapper(e) {
			let t = new ft()
			for (let n of e) t.set(n, n)
			return { uris: Object.freeze(Array.from(t.values())) }
		}
		createDiagnosticCollection(e, t) {
			let {
					_collections: n,
					_proxy: r,
					_onDidChangeDiagnostics: i,
					_logService: s,
					_fileSystemInfoService: a,
					_extHostDocumentsAndEditors: l,
				} = this,
				d = new (class {
					$changeMany(m, f) {
						r.$changeMany(m, f),
							s.trace(
								"[DiagnosticCollection] change many (extension, owner, uris)",
								e.value,
								m,
								f.length === 0 ? "CLEARING" : f,
							)
					}
					$clear(m) {
						r.$clear(m), s.trace("[DiagnosticCollection] remove all (extension, owner)", e.value, m)
					}
					dispose() {
						r.dispose()
					}
				})(),
				c
			if (!t) (t = "_generated_diagnostic_collection_name_#" + Eo._idPool++), (c = t)
			else if (!n.has(t)) c = t
			else {
				this._logService.warn(`DiagnosticCollection with name '${t}' does already exist.`)
				do c = t + Eo._idPool++
				while (n.has(c))
			}
			return new (class extends JC {
				constructor() {
					super(
						t,
						c,
						Eo._maxDiagnosticsTotal,
						Eo._maxDiagnosticsPerFile,
						(m) => l.getDocument(m)?.version,
						a.extUri,
						d,
						i,
					),
						n.set(c, this)
				}
				dispose() {
					super.dispose(), n.delete(c)
				}
			})()
		}
		getDiagnostics(e) {
			if (e) return this._getDiagnostics(e)
			{
				let t = new Map(),
					n = []
				for (let r of this._collections.values())
					r.forEach((i, s) => {
						let a = t.get(i.toString())
						typeof a > "u" && ((a = n.length), t.set(i.toString(), a), n.push([i, []])),
							(n[a][1] = n[a][1].concat(...s))
					})
				return n
			}
		}
		_getDiagnostics(e) {
			let t = []
			for (let n of this._collections.values()) n.has(e) && (t = t.concat(n.get(e)))
			return t
		}
		$acceptMarkersChange(e) {
			if (!this._mirrorCollection) {
				let t = "_generated_mirror",
					n = new JC(
						t,
						t,
						Number.MAX_SAFE_INTEGER,
						Number.MAX_SAFE_INTEGER,
						(r) => {},
						this._fileSystemInfoService.extUri,
						void 0,
						this._onDidChangeDiagnostics,
					)
				this._collections.set(t, n), (this._mirrorCollection = n)
			}
			for (let [t, n] of e) this._mirrorCollection.set(b.revive(t), n.map(Rd.to))
		}
	}
Eo = R([S(1, te), S(2, po)], Eo)
var XC = class {
	constructor(e) {
		this._proxy = e.getProxy(M.MainThreadDialogs)
	}
	showOpenDialog(e) {
		return this._proxy.$showOpenDialog(e).then((t) => (t ? t.map((n) => b.revive(n)) : void 0))
	}
	showSaveDialog(e) {
		return this._proxy.$showSaveDialog(e).then((t) => (t ? b.revive(t) : void 0))
	}
}
var YC = class o {
	constructor(e, t, n) {
		this._documentsAndEditors = t
		this._logService = n
		this._documentContentProviders = new Map()
		this._proxy = e.getProxy(M.MainThreadDocumentContentProviders)
	}
	static {
		this._handlePool = 0
	}
	registerTextDocumentContentProvider(e, t) {
		if (Object.keys(W).indexOf(e) >= 0) throw new Error(`scheme '${e}' already registered`)
		let n = o._handlePool++
		this._documentContentProviders.set(n, t), this._proxy.$registerTextContentProvider(n, e)
		let r
		if (typeof t.onDidChange == "function") {
			let i
			r = t.onDidChange(async (s) => {
				if (s.scheme !== e) {
					this._logService.warn(
						`Provider for scheme '${e}' is firing event for schema '${s.scheme}' which will be IGNORED`,
					)
					return
				}
				if (!this._documentsAndEditors.getDocument(s)) return
				i && (await i)
				let a = this.$provideTextDocumentContent(n, s)
					.then(async (l) => {
						if (!l && typeof l != "string") return
						let d = this._documentsAndEditors.getDocument(s)
						if (!d) return
						let c = Nv(l)
						if (!d.equalLines(c)) return this._proxy.$onVirtualDocumentChange(s, l)
					})
					.catch(Be)
					.finally(() => {
						i === a && (i = void 0)
					})
				i = a
			})
		}
		return new ye(() => {
			this._documentContentProviders.delete(n) && this._proxy.$unregisterTextContentProvider(n),
				r && (r.dispose(), (r = void 0))
		})
	}
	$provideTextDocumentContent(e, t) {
		let n = this._documentContentProviders.get(e)
		return n
			? Promise.resolve(n.provideTextDocumentContent(b.revive(t), De.None))
			: Promise.reject(new Error(`unsupported uri-scheme: ${t.scheme}`))
	}
}
var ZC = class {
	constructor(e, t, n, r = { timeout: 1500, errors: 3 }) {
		this._logService = e
		this._documents = t
		this._mainThreadBulkEdits = n
		this._thresholds = r
		this._callbacks = new Ao()
		this._badListeners = new WeakMap()
	}
	dispose() {
		this._callbacks.clear()
	}
	getOnWillSaveTextDocumentEvent(e) {
		return (t, n, r) => {
			let s = { dispose: this._callbacks.push([t, n, e]) }
			return Array.isArray(r) && r.push(s), s
		}
	}
	async $participateInSave(e, t) {
		let n = b.revive(e),
			r = !1,
			i = setTimeout(() => (r = !0), this._thresholds.timeout),
			s = []
		try {
			for (let a of [...this._callbacks]) {
				if (r) break
				let l = this._documents.getDocument(n),
					d = await this._deliverEventAsyncAndBlameBadListeners(a, { document: l, reason: _g.to(t) })
				s.push(d)
			}
		} finally {
			clearTimeout(i)
		}
		return s
	}
	_deliverEventAsyncAndBlameBadListeners([e, t, n], r) {
		let i = this._badListeners.get(e)
		return typeof i == "number" && i > this._thresholds.errors
			? Promise.resolve(!1)
			: this._deliverEventAsync(n, e, t, r).then(
					() => !0,
					(s) => {
						if (
							(this._logService.error(
								`onWillSaveTextDocument-listener from extension '${n.identifier.value}' threw ERROR`,
							),
							this._logService.error(s),
							!(s instanceof Error) || s.message !== "concurrent_edits")
						) {
							let a = this._badListeners.get(e)
							this._badListeners.set(e, a ? a + 1 : 1),
								typeof a == "number" &&
									a > this._thresholds.errors &&
									this._logService.info(
										`onWillSaveTextDocument-listener from extension '${n.identifier.value}' will now be IGNORED because of timeouts and/or errors`,
									)
						}
						return !1
					},
				)
	}
	_deliverEventAsync(e, t, n, r) {
		let i = [],
			s = Date.now(),
			{ document: a, reason: l } = r,
			{ version: d } = a,
			c = Object.freeze({
				document: a,
				reason: l,
				waitUntil(u) {
					if (Object.isFrozen(i)) throw uc("waitUntil can not be called async")
					i.push(Promise.resolve(u))
				},
			})
		try {
			t.apply(n, [c])
		} catch (u) {
			return Promise.reject(u)
		}
		return (
			Object.freeze(i),
			new Promise((u, m) => {
				let f = setTimeout(() => m(new Error("timeout")), this._thresholds.timeout)
				return Promise.all(i)
					.then((h) => {
						this._logService.debug(
							`onWillSaveTextDocument-listener from extension '${e.identifier.value}' finished after ${Date.now() - s}ms`,
						),
							clearTimeout(f),
							u(h)
					})
					.catch((h) => {
						clearTimeout(f), m(h)
					})
			}).then((u) => {
				let m = { edits: [] }
				for (let f of u)
					if (Array.isArray(f) && f.every((h) => h instanceof Mn))
						for (let { newText: h, newEol: g, range: I } of f)
							m.edits.push({
								resource: a.uri,
								versionId: void 0,
								textEdit: { range: I && H.from(I), text: h, eol: g && _d.from(g) },
							})
				if (m.edits.length !== 0)
					return d === a.version
						? this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new Xt(m))
						: Promise.reject(new Error("concurrent_edits"))
			})
		)
	}
}
var eS = class {
	constructor(e, t) {
		this._onDidAddDocument = new E()
		this._onDidRemoveDocument = new E()
		this._onDidChangeDocument = new E()
		this._onDidSaveDocument = new E()
		this.onDidAddDocument = this._onDidAddDocument.event
		this.onDidRemoveDocument = this._onDidRemoveDocument.event
		this.onDidChangeDocument = this._onDidChangeDocument.event
		this.onDidSaveDocument = this._onDidSaveDocument.event
		this._toDispose = new Q()
		this._documentLoader = new Map()
		;(this._proxy = e.getProxy(M.MainThreadDocuments)),
			(this._documentsAndEditors = t),
			this._documentsAndEditors.onDidRemoveDocuments(
				(n) => {
					for (let r of n) this._onDidRemoveDocument.fire(r.document)
				},
				void 0,
				this._toDispose,
			),
			this._documentsAndEditors.onDidAddDocuments(
				(n) => {
					for (let r of n) this._onDidAddDocument.fire(r.document)
				},
				void 0,
				this._toDispose,
			)
	}
	dispose() {
		this._toDispose.dispose()
	}
	getAllDocumentData() {
		return [...this._documentsAndEditors.allDocuments()]
	}
	getDocumentData(e) {
		if (!e) return
		let t = this._documentsAndEditors.getDocument(e)
		if (t) return t
	}
	getDocument(e) {
		let t = this.getDocumentData(e)
		if (!t?.document) throw new Error(`Unable to retrieve document from URI '${e}'`)
		return t.document
	}
	ensureDocumentData(e, t) {
		let n = this._documentsAndEditors.getDocument(e)
		if (n && (!t?.encoding || n.document.encoding === t.encoding)) return Promise.resolve(n)
		let r = this._documentLoader.get(e.toString())
		return (
			r
				? t?.encoding &&
					(r = r.then((i) => (i.document.encoding !== t.encoding ? this.ensureDocumentData(e, t) : i)))
				: ((r = this._proxy.$tryOpenDocument(e, t).then(
						(i) => {
							this._documentLoader.delete(e.toString())
							let s = b.revive(i)
							return Ro(this._documentsAndEditors.getDocument(s))
						},
						(i) => (this._documentLoader.delete(e.toString()), Promise.reject(i)),
					)),
					this._documentLoader.set(e.toString(), r)),
			r
		)
	}
	createDocumentData(e) {
		return this._proxy.$tryCreateDocument(e).then((t) => b.revive(t))
	}
	$acceptModelLanguageChanged(e, t) {
		let n = b.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		this._onDidRemoveDocument.fire(r.document), r._acceptLanguageId(t), this._onDidAddDocument.fire(r.document)
	}
	$acceptModelSaved(e) {
		let t = b.revive(e),
			n = this._documentsAndEditors.getDocument(t)
		if (!n) throw new Error("unknown document")
		this.$acceptDirtyStateChanged(e, !1), this._onDidSaveDocument.fire(n.document)
	}
	$acceptDirtyStateChanged(e, t) {
		let n = b.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		r._acceptIsDirty(t),
			this._onDidChangeDocument.fire({ document: r.document, contentChanges: [], reason: void 0 })
	}
	$acceptEncodingChanged(e, t) {
		let n = b.revive(e),
			r = this._documentsAndEditors.getDocument(n)
		if (!r) throw new Error("unknown document")
		r._acceptEncoding(t),
			this._onDidChangeDocument.fire({ document: r.document, contentChanges: [], reason: void 0 })
	}
	$acceptModelChanged(e, t, n) {
		let r = b.revive(e),
			i = this._documentsAndEditors.getDocument(r)
		if (!i) throw new Error("unknown document")
		i._acceptIsDirty(n), i.onEvents(t)
		let s
		t.isUndoing ? (s = 1) : t.isRedoing && (s = 2),
			this._onDidChangeDocument.fire(
				ob({
					document: i.document,
					contentChanges: t.changes.map((a) => ({
						range: H.to(a.range),
						rangeOffset: a.rangeOffset,
						rangeLength: a.rangeLength,
						text: a.text,
					})),
					reason: s,
				}),
			)
	}
	setWordDefinitionFor(e, t) {
		L2(e, t)
	}
}
var tS = class {
	constructor(e) {
		this._provider = new Map()
		this._onDidChange = new E()
		this.onDidChange = this._onDidChange.event
		this._allKnownModels = new Set()
		this._handlePool = 0
		this._proxy = e.getProxy(M.MainThreadEmbeddings)
	}
	registerEmbeddingsProvider(e, t, n) {
		if (this._allKnownModels.has(t)) throw new Error("An embeddings provider for this model is already registered")
		let r = this._handlePool++
		return (
			this._proxy.$registerEmbeddingProvider(r, t),
			this._provider.set(r, { id: t, provider: n }),
			q(() => {
				this._allKnownModels.delete(t), this._proxy.$unregisterEmbeddingProvider(r), this._provider.delete(r)
			})
		)
	}
	async computeEmbeddings(e, t, n) {
		n ??= De.None
		let r = !1
		typeof t == "string" && ((t = [t]), (r = !0))
		let i = await this._proxy.$computeEmbeddings(e, t, n)
		if (i.length !== t.length) throw new Error()
		if (r) {
			if (i.length !== 1) throw new Error()
			return i[0]
		}
		return i
	}
	async $provideEmbeddings(e, t, n) {
		let r = this._provider.get(e)
		if (!r) return []
		let i = await r.provider.provideEmbeddings(t, n)
		return i || []
	}
	get embeddingsModels() {
		return Array.from(this._allKnownModels)
	}
	$acceptEmbeddingModels(e) {
		;(this._allKnownModels = new Set(e)), this._onDidChange.fire()
	}
}
var nS = class {
	constructor(e) {
		this._AiEmbeddingVectorProviders = new Map()
		this._nextHandle = 0
		this._proxy = e.getProxy(M.MainThreadAiEmbeddingVector)
	}
	async $provideAiEmbeddingVector(e, t, n) {
		if (this._AiEmbeddingVectorProviders.size === 0) throw new Error("No embedding vector providers registered")
		let r = this._AiEmbeddingVectorProviders.get(e)
		if (!r) throw new Error("Embedding vector provider not found")
		let i = await r.provideEmbeddingVector(t, n)
		if (!i) throw new Error("Embedding vector provider returned undefined")
		return i
	}
	registerEmbeddingVectorProvider(e, t, n) {
		let r = this._nextHandle
		return (
			this._nextHandle++,
			this._AiEmbeddingVectorProviders.set(r, n),
			this._proxy.$registerAiEmbeddingVectorProvider(t, r),
			new ye(() => {
				this._proxy.$unregisterAiEmbeddingVectorProvider(r), this._AiEmbeddingVectorProviders.delete(r)
			})
		)
	}
}
var m1 = class {
		constructor(e, t, n) {
			let r = new Uint8Array(e * t)
			for (let i = 0, s = e * t; i < s; i++) r[i] = n
			;(this._data = r), (this.rows = e), (this.cols = t)
		}
		get(e, t) {
			return this._data[e * this.cols + t]
		}
		set(e, t, n) {
			this._data[e * this.cols + t] = n
		}
	},
	Th = class {
		constructor(e) {
			let t = 0,
				n = 0
			for (let i = 0, s = e.length; i < s; i++) {
				let [a, l, d] = e[i]
				l > t && (t = l), a > n && (n = a), d > n && (n = d)
			}
			t++, n++
			let r = new m1(n, t, 0)
			for (let i = 0, s = e.length; i < s; i++) {
				let [a, l, d] = e[i]
				r.set(a, l, d)
			}
			;(this._states = r), (this._maxCharCode = t)
		}
		nextState(e, t) {
			return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t)
		}
	},
	p1 = null
function EB() {
	return (
		p1 === null &&
			(p1 = new Th([
				[1, 104, 2],
				[1, 72, 2],
				[1, 102, 6],
				[1, 70, 6],
				[2, 116, 3],
				[2, 84, 3],
				[3, 116, 4],
				[3, 84, 4],
				[4, 112, 5],
				[4, 80, 5],
				[5, 115, 9],
				[5, 83, 9],
				[5, 58, 10],
				[6, 105, 7],
				[6, 73, 7],
				[7, 108, 8],
				[7, 76, 8],
				[8, 101, 9],
				[8, 69, 9],
				[9, 58, 10],
				[10, 47, 11],
				[11, 47, 12],
			])),
		p1
	)
}
var Sh = null
function wB() {
	if (Sh === null) {
		Sh = new Lp(0)
		let o = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`
		for (let t = 0; t < o.length; t++) Sh.set(o.charCodeAt(t), 1)
		let e = ".,;:"
		for (let t = 0; t < e.length; t++) Sh.set(e.charCodeAt(t), 2)
	}
	return Sh
}
var rS = class o {
	static _createLink(e, t, n, r, i) {
		let s = i - 1
		do {
			let a = t.charCodeAt(s)
			if (e.get(a) !== 2) break
			s--
		} while (s > r)
		if (r > 0) {
			let a = t.charCodeAt(r - 1),
				l = t.charCodeAt(s)
			;((a === 40 && l === 41) || (a === 91 && l === 93) || (a === 123 && l === 125)) && s--
		}
		return {
			range: { startLineNumber: n, startColumn: r + 1, endLineNumber: n, endColumn: s + 2 },
			url: t.substring(r, s + 1),
		}
	}
	static computeLinks(e, t = EB()) {
		let n = wB(),
			r = []
		for (let i = 1, s = e.getLineCount(); i <= s; i++) {
			let a = e.getLineContent(i),
				l = a.length,
				d = 0,
				c = 0,
				u = 0,
				m = 1,
				f = !1,
				h = !1,
				g = !1,
				I = !1
			for (; d < l; ) {
				let C = !1,
					T = a.charCodeAt(d)
				if (m === 13) {
					let w
					switch (T) {
						case 40:
							;(f = !0), (w = 0)
							break
						case 41:
							w = f ? 0 : 1
							break
						case 91:
							;(g = !0), (h = !0), (w = 0)
							break
						case 93:
							;(g = !1), (w = h ? 0 : 1)
							break
						case 123:
							;(I = !0), (w = 0)
							break
						case 125:
							w = I ? 0 : 1
							break
						case 39:
						case 34:
						case 96:
							u === T ? (w = 1) : u === 39 || u === 34 || u === 96 ? (w = 0) : (w = 1)
							break
						case 42:
							w = u === 42 ? 1 : 0
							break
						case 124:
							w = u === 124 ? 1 : 0
							break
						case 32:
							w = g ? 0 : 1
							break
						default:
							w = n.get(T)
					}
					w === 1 && (r.push(o._createLink(n, a, i, c, d)), (C = !0))
				} else if (m === 12) {
					let w
					T === 91 ? ((h = !0), (w = 0)) : (w = n.get(T)), w === 1 ? (C = !0) : (m = 13)
				} else (m = t.nextState(m, T)), m === 0 && (C = !0)
				C && ((m = 1), (f = !1), (h = !1), (I = !1), (c = d + 1), (u = T)), d++
			}
			m === 13 && r.push(o._createLink(n, a, i, c, l))
		}
		return r
	}
}
var f1 = class {
		constructor() {
			this._schemes = []
		}
		add(e) {
			;(this._stateMachine = void 0), this._schemes.push(e)
		}
		delete(e) {
			let t = this._schemes.indexOf(e)
			t >= 0 && (this._schemes.splice(t, 1), (this._stateMachine = void 0))
		}
		_initStateMachine() {
			if (!this._stateMachine) {
				let e = this._schemes.sort(),
					t = [],
					n,
					r,
					i = 14,
					s = 14
				for (let a of e) {
					let l = n ? QA(n, a) : 0
					for (l === 0 ? (r = 1) : (r = s); l < a.length; l++)
						l + 1 === a.length ? ((i = s), (s = 9)) : (s += 1),
							t.push([r, a.toUpperCase().charCodeAt(l), s]),
							t.push([r, a.toLowerCase().charCodeAt(l), s]),
							(r = s)
					;(n = a), (s = i)
				}
				t.push([9, 58, 10]), t.push([10, 47, 12]), (this._stateMachine = new Th(t))
			}
		}
		provideDocumentLinks(e) {
			this._initStateMachine()
			let t = [],
				n = rS.computeLinks(
					{
						getLineContent(r) {
							return e.lineAt(r - 1).text
						},
						getLineCount() {
							return e.lineCount
						},
					},
					this._stateMachine,
				)
			for (let r of n) {
				let i = Vs.to(r)
				i.target && t.push(i)
			}
			return t
		}
	},
	oS = class o {
		constructor(e, t) {
			this._extHostLanguageFeatures = t
			this._linkProvider = new f1()
			this._fsProvider = new Map()
			this._registeredSchemes = new Set()
			this._watches = new Map()
			this._handlePool = 0
			this._proxy = e.getProxy(M.MainThreadFileSystem)
		}
		dispose() {
			this._linkProviderRegistration?.dispose()
		}
		registerFileSystemProvider(e, t, n, r = {}) {
			if ((o._validateFileSystemProvider(n), this._registeredSchemes.has(t)))
				throw new Error(`a provider for the scheme '${t}' is already registered`)
			this._linkProviderRegistration ||
				(this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(
					e,
					"*",
					this._linkProvider,
				))
			let i = this._handlePool++
			this._linkProvider.add(t), this._registeredSchemes.add(t), this._fsProvider.set(i, n)
			let s = 2
			r.isCaseSensitive && (s += 1024),
				r.isReadonly && (s += 2048),
				typeof n.copy == "function" && (s += 8),
				typeof n.open == "function" &&
					typeof n.close == "function" &&
					typeof n.read == "function" &&
					typeof n.write == "function" &&
					(F(e, "fsChunks"), (s += 4))
			let a
			r.isReadonly &&
				Gr(r.isReadonly) &&
				r.isReadonly.value !== "" &&
				(a = {
					value: r.isReadonly.value,
					isTrusted: r.isReadonly.isTrusted,
					supportThemeIcons: r.isReadonly.supportThemeIcons,
					supportHtml: r.isReadonly.supportHtml,
					baseUri: r.isReadonly.baseUri,
					uris: r.isReadonly.uris,
				}),
				this._proxy.$registerFileSystemProvider(i, t, s, a).catch((d) => {
					console.error(
						`FAILED to register filesystem provider of ${e.identifier.value}-extension for the scheme ${t}`,
					),
						console.error(d)
				})
			let l = n.onDidChangeFile((d) => {
				let c = []
				for (let u of d) {
					let { uri: m, type: f } = u
					if (m.scheme !== t) continue
					let h
					switch (f) {
						case 1:
							h = 0
							break
						case 2:
							h = 1
							break
						case 3:
							h = 2
							break
						default:
							throw new Error("Unknown FileChangeType")
					}
					c.push({ resource: m, type: h })
				}
				this._proxy.$onFileSystemChange(i, c)
			})
			return q(() => {
				l.dispose(),
					this._linkProvider.delete(t),
					this._registeredSchemes.delete(t),
					this._fsProvider.delete(i),
					this._proxy.$unregisterProvider(i)
			})
		}
		static _validateFileSystemProvider(e) {
			if (!e) throw new Error("MISSING provider")
			if (typeof e.watch != "function") throw new Error("Provider does NOT implement watch")
			if (typeof e.stat != "function") throw new Error("Provider does NOT implement stat")
			if (typeof e.readDirectory != "function") throw new Error("Provider does NOT implement readDirectory")
			if (typeof e.createDirectory != "function") throw new Error("Provider does NOT implement createDirectory")
			if (typeof e.readFile != "function") throw new Error("Provider does NOT implement readFile")
			if (typeof e.writeFile != "function") throw new Error("Provider does NOT implement writeFile")
			if (typeof e.delete != "function") throw new Error("Provider does NOT implement delete")
			if (typeof e.rename != "function") throw new Error("Provider does NOT implement rename")
		}
		static _asIStat(e) {
			let { type: t, ctime: n, mtime: r, size: i, permissions: s } = e
			return { type: t, ctime: n, mtime: r, size: i, permissions: s }
		}
		$stat(e, t) {
			return Promise.resolve(this._getFsProvider(e).stat(b.revive(t))).then((n) => o._asIStat(n))
		}
		$readdir(e, t) {
			return Promise.resolve(this._getFsProvider(e).readDirectory(b.revive(t)))
		}
		$readFile(e, t) {
			return Promise.resolve(this._getFsProvider(e).readFile(b.revive(t))).then((n) => z.wrap(n))
		}
		$writeFile(e, t, n, r) {
			return Promise.resolve(this._getFsProvider(e).writeFile(b.revive(t), n.buffer, r))
		}
		$delete(e, t, n) {
			return Promise.resolve(this._getFsProvider(e).delete(b.revive(t), n))
		}
		$rename(e, t, n, r) {
			return Promise.resolve(this._getFsProvider(e).rename(b.revive(t), b.revive(n), r))
		}
		$copy(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.copy) throw new Error('FileSystemProvider does not implement "copy"')
			return Promise.resolve(i.copy(b.revive(t), b.revive(n), r))
		}
		$mkdir(e, t) {
			return Promise.resolve(this._getFsProvider(e).createDirectory(b.revive(t)))
		}
		$watch(e, t, n, r) {
			let i = this._getFsProvider(e).watch(b.revive(n), r)
			this._watches.set(t, i)
		}
		$unwatch(e, t) {
			let n = this._watches.get(t)
			n && (n.dispose(), this._watches.delete(t))
		}
		$open(e, t, n) {
			let r = this._getFsProvider(e)
			if (!r.open) throw new Error('FileSystemProvider does not implement "open"')
			return Promise.resolve(r.open(b.revive(t), n))
		}
		$close(e, t) {
			let n = this._getFsProvider(e)
			if (!n.close) throw new Error('FileSystemProvider does not implement "close"')
			return Promise.resolve(n.close(t))
		}
		$read(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.read) throw new Error('FileSystemProvider does not implement "read"')
			let s = z.alloc(r)
			return Promise.resolve(i.read(t, n, s.buffer, 0, r)).then((a) => s.slice(0, a))
		}
		$write(e, t, n, r) {
			let i = this._getFsProvider(e)
			if (!i.write) throw new Error('FileSystemProvider does not implement "write"')
			return Promise.resolve(i.write(t, n, r.buffer, 0, r.byteLength))
		}
		_getFsProvider(e) {
			let t = this._fsProvider.get(e)
			if (!t) {
				let n = new Error()
				throw ((n.name = "ENOPRO"), (n.message = "no provider"), n)
			}
			return t
		}
	}
function lS(o) {
	return typeof o.correlationId == "number"
}
function VN(o) {
	return o.recursive === !0
}
var iS = class o extends $ {
		constructor(t, n, r, i) {
			super()
			this.onFileChanges = t
			this.onLogMessage = n
			this.verboseLogging = r
			this.options = i
			this.watcherDisposables = this._register(new kn())
			this.requests = void 0
			this.restartCounter = 0
		}
		static {
			this.MAX_RESTARTS = 5
		}
		init() {
			let t = new Q()
			;(this.watcherDisposables.value = t),
				(this.watcher = this.createWatcher(t)),
				this.watcher.setVerboseLogging(this.verboseLogging),
				t.add(this.watcher.onDidChangeFile((n) => this.onFileChanges(n))),
				t.add(this.watcher.onDidLogMessage((n) => this.onLogMessage(n))),
				t.add(this.watcher.onDidError((n) => this.onError(n.error, n.request)))
		}
		onError(t, n) {
			this.canRestart(t, n)
				? this.restartCounter < o.MAX_RESTARTS && this.requests
					? (this.error(`restarting watcher after unexpected error: ${t}`), this.restart(this.requests))
					: this.error(`gave up attempting to restart watcher after unexpected error: ${t}`)
				: this.error(t)
		}
		canRestart(t, n) {
			return !(
				!this.options.restartOnError ||
				n ||
				t.indexOf("No space left on device") !== -1 ||
				t.indexOf("EMFILE") !== -1
			)
		}
		restart(t) {
			this.restartCounter++, this.init(), this.watch(t)
		}
		async watch(t) {
			;(this.requests = t), await this.watcher?.watch(t)
		}
		async setVerboseLogging(t) {
			;(this.verboseLogging = t), await this.watcher?.setVerboseLogging(t)
		}
		error(t) {
			this.onLogMessage({ type: "error", message: `[File Watcher (${this.options.type})] ${t}` })
		}
		trace(t) {
			this.onLogMessage({ type: "trace", message: `[File Watcher (${this.options.type})] ${t}` })
		}
		dispose() {
			return (this.watcher = void 0), super.dispose()
		}
	},
	sS = class extends iS {
		constructor(e, t, n) {
			super(e, t, n, { type: "node.js", restartOnError: !1 })
		}
	},
	aS = class extends iS {
		constructor(e, t, n) {
			super(e, t, n, { type: "universal", restartOnError: !0 })
		}
	}
function v1(o) {
	return o.map((e) => ({ type: e.type, resource: b.revive(e.resource), cId: e.cId }))
}
function BN(o) {
	let e = new h1()
	for (let t of o) e.processEvent(t)
	return e.coalesce()
}
function b1(o, e) {
	return typeof e == "string" && !e.startsWith(hs) && !In(e) ? { base: o, pattern: e } : e
}
function y1(o, e) {
	let t = []
	for (let n of e) t.push(Yn(b1(o, n)))
	return t
}
var h1 = class {
	constructor() {
		this.coalesced = new Set()
		this.mapPathToChange = new Map()
	}
	toKey(e) {
		return Ve ? e.resource.fsPath : e.resource.fsPath.toLowerCase()
	}
	processEvent(e) {
		let t = this.mapPathToChange.get(this.toKey(e)),
			n = !1
		if (t) {
			let r = t.type,
				i = e.type
			t.resource.fsPath !== e.resource.fsPath && (e.type === 2 || e.type === 1)
				? (n = !0)
				: r === 1 && i === 2
					? (this.mapPathToChange.delete(this.toKey(e)), this.coalesced.delete(t))
					: r === 2 && i === 1
						? (t.type = 0)
						: (r === 1 && i === 0) || (t.type = i)
		} else n = !0
		n && (this.coalesced.add(e), this.mapPathToChange.set(this.toKey(e), e))
	}
	coalesce() {
		let e = [],
			t = []
		return Array.from(this.coalesced)
			.filter((n) => (n.type !== 2 ? (e.push(n), !1) : !0))
			.sort((n, r) => n.resource.fsPath.length - r.resource.fsPath.length)
			.filter((n) => (t.some((r) => vL(n.resource.fsPath, r, !Ve)) ? !1 : (t.push(n.resource.fsPath), !0)))
			.concat(e)
	}
}
function $N(o, e) {
	if (typeof e == "number")
		switch (o.type) {
			case 1:
				return (e & 4) === 0
			case 2:
				return (e & 8) === 0
			case 0:
				return (e & 2) === 0
		}
	return !1
}
function zN(o) {
	if (typeof o == "number") {
		let e = []
		return (
			o & 4 && e.push("Added"),
			o & 8 && e.push("Deleted"),
			o & 2 && e.push("Updated"),
			e.length === 0 ? "<all>" : `[${e.join(", ")}]`
		)
	}
	return "<none>"
}
var I1 = class {
		constructor(e, t, n, r, i, s, a) {
			this.session = Math.random()
			this._onDidCreate = new E()
			this._onDidChange = new E()
			this._onDidDelete = new E()
			;(this._config = 0),
				a.ignoreCreateEvents && (this._config += 1),
				a.ignoreChangeEvents && (this._config += 2),
				a.ignoreDeleteEvents && (this._config += 4)
			let l = Yn(s),
				d = typeof s == "string",
				c = !1,
				u = i((m) => {
					if (
						!(typeof m.session == "number" && m.session !== this.session) &&
						!(c && typeof m.session > "u")
					) {
						if (!a.ignoreCreateEvents)
							for (let f of m.created) {
								let h = b.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidCreate.fire(h)
							}
						if (!a.ignoreChangeEvents)
							for (let f of m.changed) {
								let h = b.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidChange.fire(h)
							}
						if (!a.ignoreDeleteEvents)
							for (let f of m.deleted) {
								let h = b.revive(f)
								l(h.fsPath) && (!d || n.getWorkspaceFolder(h)) && this._onDidDelete.fire(h)
							}
					}
				})
			this._disposable = ye.from(
				this.ensureWatching(e, n, t, r, s, a, !1),
				this._onDidCreate,
				this._onDidChange,
				this._onDidDelete,
				u,
			)
		}
		get ignoreCreateEvents() {
			return !!(this._config & 1)
		}
		get ignoreChangeEvents() {
			return !!(this._config & 2)
		}
		get ignoreDeleteEvents() {
			return !!(this._config & 4)
		}
		ensureWatching(e, t, n, r, i, s, a) {
			let l = ye.from()
			if (typeof i == "string" || (s.ignoreChangeEvents && s.ignoreCreateEvents && s.ignoreDeleteEvents)) return l
			let d = e.getProxy(M.MainThreadFileSystemEventService),
				c = !1
			;(i.pattern.includes(hs) || i.pattern.includes(ny)) && (c = !0)
			let u = [],
				m,
				f
			if (a)
				(s.ignoreChangeEvents || s.ignoreCreateEvents || s.ignoreDeleteEvents) &&
					((f = 14),
					s.ignoreChangeEvents && (f &= -3),
					s.ignoreCreateEvents && (f &= -5),
					s.ignoreDeleteEvents && (f &= -9))
			else if (c && u.length === 0) {
				let h = t.getWorkspaceFolder(b.revive(i.baseUri)),
					g = n.getConfiguration("files", h).get("watcherExclude")
				if (g) for (let I in g) I && g[I] === !0 && u.push(I)
			} else if (!c) {
				let h = t.getWorkspaceFolder(b.revive(i.baseUri))
				if (h) {
					let g = n.getConfiguration("files", h).get("watcherExclude")
					if (g) {
						for (let I in g)
							if (I && g[I] === !0) {
								let C = `${Rr(I, "/")}/${hs}`
								m || (m = []), m.push(b1(h.uri.fsPath, C))
							}
					}
					if (!m || m.length === 0) return l
				}
			}
			return (
				d.$watch(
					r.identifier.value,
					this.session,
					i.baseUri,
					{ recursive: c, excludes: u, includes: m, filter: f },
					!!a,
				),
				ye.from({ dispose: () => d.$unwatch(this.session) })
			)
		}
		dispose() {
			this._disposable.dispose()
		}
		get onDidCreate() {
			return this._onDidCreate.event
		}
		get onDidChange() {
			return this._onDidChange.event
		}
		get onDidDelete() {
			return this._onDidDelete.event
		}
	},
	x1 = class {
		constructor(e) {
			this._events = e
			this._created = new kt(() => this._events.created.map(b.revive))
			this._changed = new kt(() => this._events.changed.map(b.revive))
			this._deleted = new kt(() => this._events.deleted.map(b.revive))
			this.session = this._events.session
		}
		get created() {
			return this._created.value
		}
		get changed() {
			return this._changed.value
		}
		get deleted() {
			return this._deleted.value
		}
	},
	dS = class {
		constructor(e, t, n) {
			this._mainContext = e
			this._logService = t
			this._extHostDocumentsAndEditors = n
			this._onFileSystemEvent = new E()
			this._onDidRenameFile = new E()
			this._onDidCreateFile = new E()
			this._onDidDeleteFile = new E()
			this._onWillRenameFile = new di()
			this._onWillCreateFile = new di()
			this._onWillDeleteFile = new di()
			this.onDidRenameFile = this._onDidRenameFile.event
			this.onDidCreateFile = this._onDidCreateFile.event
			this.onDidDeleteFile = this._onDidDeleteFile.event
		}
		createFileSystemWatcher(e, t, n, r, i) {
			return new I1(this._mainContext, t, e, n, this._onFileSystemEvent.event, Ir.from(r), i)
		}
		$onFileEvent(e) {
			this._onFileSystemEvent.fire(new x1(e))
		}
		$onDidRunFileOperation(e, t) {
			switch (e) {
				case 2:
					this._onDidRenameFile.fire(
						Object.freeze({
							files: t.map((n) => ({ oldUri: b.revive(n.source), newUri: b.revive(n.target) })),
						}),
					)
					break
				case 1:
					this._onDidDeleteFile.fire(Object.freeze({ files: t.map((n) => b.revive(n.target)) }))
					break
				case 0:
				case 3:
					this._onDidCreateFile.fire(Object.freeze({ files: t.map((n) => b.revive(n.target)) }))
					break
				default:
			}
		}
		getOnWillRenameFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillRenameFile)
		}
		getOnWillCreateFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillCreateFile)
		}
		getOnWillDeleteFileEvent(e) {
			return this._createWillExecuteEvent(e, this._onWillDeleteFile)
		}
		_createWillExecuteEvent(e, t) {
			return (n, r, i) => {
				let s = function (l) {
					n.call(r, l)
				}
				return (s.extension = e), t.event(s, void 0, i)
			}
		}
		async $onWillRunFileOperation(e, t, n, r) {
			switch (e) {
				case 2:
					return await this._fireWillEvent(
						this._onWillRenameFile,
						{ files: t.map((i) => ({ oldUri: b.revive(i.source), newUri: b.revive(i.target) })) },
						n,
						r,
					)
				case 1:
					return await this._fireWillEvent(
						this._onWillDeleteFile,
						{ files: t.map((i) => b.revive(i.target)) },
						n,
						r,
					)
				case 0:
				case 3:
					return await this._fireWillEvent(
						this._onWillCreateFile,
						{ files: t.map((i) => b.revive(i.target)) },
						n,
						r,
					)
			}
		}
		async _fireWillEvent(e, t, n, r) {
			let i = new Set(),
				s = []
			if (
				(await e.fireAsync(t, r, async (l, d) => {
					let c = Date.now(),
						u = await Promise.resolve(l)
					u instanceof Yr &&
						(s.push([d.extension, u]), i.add(d.extension.displayName ?? d.extension.identifier.value)),
						Date.now() - c > n && this._logService.warn("SLOW file-participant", d.extension.identifier)
				}),
				r.isCancellationRequested || s.length === 0)
			)
				return
			let a = { edits: [] }
			for (let [, l] of s) {
				let { edits: d } = zn.from(l, {
					getTextDocumentVersion: (c) => this._extHostDocumentsAndEditors.getDocument(c)?.version,
					getNotebookDocumentVersion: () => {},
				})
				a.edits = a.edits.concat(d)
			}
			return { edit: a, extensionNames: Array.from(i) }
		}
	}
var cS = class {
	constructor(e, t, n, r, i) {
		this._extHostNotebooks = t
		this._textDocumentsAndEditors = n
		this._commands = r
		let s = new be(
			"interactive.open",
			"_interactive.open",
			"Open interactive window and return notebook editor and input URI",
			[
				new G(
					"showOptions",
					"Show Options",
					(a) => !0,
					(a) => a,
				),
				new G(
					"resource",
					"Interactive resource Uri",
					(a) => !0,
					(a) => a,
				),
				new G(
					"controllerId",
					"Notebook controller Id",
					(a) => !0,
					(a) => a,
				),
				new G(
					"title",
					"Interactive editor title",
					(a) => !0,
					(a) => a,
				),
			],
			new ge("Notebook and input URI", (a) => {
				if (
					(i.debug("[ExtHostInteractive] open iw with notebook editor id", a.notebookEditorId),
					a.notebookEditorId !== void 0)
				) {
					let l = this._extHostNotebooks.getEditorById(a.notebookEditorId)
					return (
						i.debug("[ExtHostInteractive] notebook editor found", l.id),
						{
							notebookUri: b.revive(a.notebookUri),
							inputUri: b.revive(a.inputUri),
							notebookEditor: l.apiEditor,
						}
					)
				}
				return (
					i.debug(
						"[ExtHostInteractive] notebook editor not found, uris for the interactive document",
						a.notebookUri,
						a.inputUri,
					),
					{ notebookUri: b.revive(a.notebookUri), inputUri: b.revive(a.inputUri) }
				)
			}),
		)
		this._commands.registerApiCommand(s)
	}
	$willAddInteractiveDocument(e, t, n, r) {
		this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
			addedDocuments: [
				{ EOL: t, lines: [""], languageId: n, uri: e, isDirty: !1, versionId: 1, encoding: "utf8" },
			],
		})
	}
	$willRemoveInteractiveDocument(e, t) {
		this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({ removedDocuments: [e] })
	}
}
var uS = class {
	constructor(e) {
		this._handlePool = 0
		this._proxy = e.getProxy(M.MainThreadLabelService)
	}
	$registerResourceLabelFormatter(e) {
		let t = this._handlePool++
		return (
			this._proxy.$registerResourceLabelFormatter(t, e),
			q(() => {
				this._proxy.$unregisterResourceLabelFormatter(t)
			})
		)
	}
}
var pS = class o extends Re {
	constructor(e, t, n, r) {
		super(e, t, n, r),
			(this.selectionStartLineNumber = e),
			(this.selectionStartColumn = t),
			(this.positionLineNumber = n),
			(this.positionColumn = r)
	}
	toString() {
		return (
			"[" +
			this.selectionStartLineNumber +
			"," +
			this.selectionStartColumn +
			" -> " +
			this.positionLineNumber +
			"," +
			this.positionColumn +
			"]"
		)
	}
	equalsSelection(e) {
		return o.selectionsEqual(this, e)
	}
	static selectionsEqual(e, t) {
		return (
			e.selectionStartLineNumber === t.selectionStartLineNumber &&
			e.selectionStartColumn === t.selectionStartColumn &&
			e.positionLineNumber === t.positionLineNumber &&
			e.positionColumn === t.positionColumn
		)
	}
	getDirection() {
		return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn
			? 0
			: 1
	}
	setEndPosition(e, t) {
		return this.getDirection() === 0
			? new o(this.startLineNumber, this.startColumn, e, t)
			: new o(e, t, this.startLineNumber, this.startColumn)
	}
	getPosition() {
		return new cn(this.positionLineNumber, this.positionColumn)
	}
	getSelectionStart() {
		return new cn(this.selectionStartLineNumber, this.selectionStartColumn)
	}
	setStartPosition(e, t) {
		return this.getDirection() === 0
			? new o(e, t, this.endLineNumber, this.endColumn)
			: new o(this.endLineNumber, this.endColumn, e, t)
	}
	static fromPositions(e, t = e) {
		return new o(e.lineNumber, e.column, t.lineNumber, t.column)
	}
	static fromRange(e, t) {
		return t === 0
			? new o(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn)
			: new o(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn)
	}
	static liftSelection(e) {
		return new o(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn)
	}
	static selectionsArrEqual(e, t) {
		if ((e && !t) || (!e && t)) return !1
		if (!e && !t) return !0
		if (e.length !== t.length) return !1
		for (let n = 0, r = e.length; n < r; n++) if (!this.selectionsEqual(e[n], t[n])) return !1
		return !0
	}
	static isISelection(e) {
		return (
			e &&
			typeof e.selectionStartLineNumber == "number" &&
			typeof e.selectionStartColumn == "number" &&
			typeof e.positionLineNumber == "number" &&
			typeof e.positionColumn == "number"
		)
	}
	static createWithDirection(e, t, n, r, i) {
		return i === 0 ? new o(e, t, n, r) : new o(n, r, e, t)
	}
}
var mS = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentSymbols(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentSymbols(n, t)
			if (!rf(r)) return r[0] instanceof Zr ? r.map(VD.from) : o._asDocumentSymbolTree(r)
		}
		static _asDocumentSymbolTree(e) {
			e = e.slice(0).sort((r, i) => {
				let s = r.location.range.start.compareTo(i.location.range.start)
				return s === 0 && (s = i.location.range.end.compareTo(r.location.range.end)), s
			})
			let t = [],
				n = []
			for (let r of e) {
				let i = {
					name: r.name || "!!MISSING: name!!",
					kind: eo.from(r.kind),
					tags: r.tags?.map(Ns.from) || [],
					detail: "",
					containerName: r.containerName,
					range: H.from(r.location.range),
					selectionRange: H.from(r.location.range),
					children: [],
				}
				for (;;) {
					if (n.length === 0) {
						n.push(i), t.push(i)
						break
					}
					let s = n[n.length - 1]
					if (Re.containsRange(s.range, i.range) && !Re.equalsRange(s.range, i.range)) {
						s.children?.push(i), n.push(i)
						break
					}
					n.pop()
				}
			}
			return t
		}
	},
	bm = class {
		constructor(e, t, n, r, i, s) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._extension = r
			this._extTelemetry = i
			this._logService = s
			this._cache = new mr("CodeLens")
			this._disposables = new Map()
		}
		async provideCodeLenses(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideCodeLenses(n, t)
			if (!r || t.isCancellationRequested) return
			let i = this._cache.add(r),
				s = new Q()
			this._disposables.set(i, s)
			let a = { cacheId: i, lenses: [] }
			for (let l = 0; l < r.length; l++) {
				if (!pe.isRange(r[l].range)) {
					console.warn("INVALID code lens, range is not defined", this._extension.identifier.value)
					continue
				}
				a.lenses.push({
					cacheId: [i, l],
					range: H.from(r[l].range),
					command: this._commands.toInternal(r[l].command, s),
				})
			}
			return a
		}
		async resolveCodeLens(e, t) {
			let n = e.cacheId && this._cache.get(...e.cacheId)
			if (!n) return
			let r
			if (
				(typeof this._provider.resolveCodeLens != "function" || n.isResolved
					? (r = n)
					: (r = await this._provider.resolveCodeLens(n, t)),
				r || (r = n),
				t.isCancellationRequested)
			)
				return
			let i = e.cacheId && this._disposables.get(e.cacheId[0])
			if (i) {
				if (!r.command) {
					let s = new Error("INVALID code lens resolved, lacks command: " + this._extension.identifier.value)
					this._extTelemetry.onExtensionError(this._extension.identifier, s), this._logService.error(s)
					return
				}
				return (e.command = this._commands.toInternal(r.command, i)), e
			}
		}
		releaseCodeLenses(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
	}
function RS(o) {
	return Array.isArray(o) ? o.map(Yu.from) : o ? [Yu.from(o)] : []
}
var fS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDefinition(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDefinition(r, i, n)
			return RS(s)
		}
	},
	gS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDeclaration(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDeclaration(r, i, n)
			return RS(s)
		}
	},
	hS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideImplementation(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideImplementation(r, i, n)
			return RS(s)
		}
	},
	vS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideTypeDefinition(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideTypeDefinition(r, i, n)
			return RS(s)
		}
	},
	Eh = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._hoverCounter = 0
			this._hoverMap = new Map()
		}
		static {
			this.HOVER_MAP_MAX_SIZE = 10
		}
		async provideHover(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a
			if (n && n.verbosityRequest) {
				let u = n.verbosityRequest.previousHover.id,
					m = this._hoverMap.get(u)
				if (!m) throw new Error(`Hover with id ${u} not found`)
				let f = { verbosityDelta: n.verbosityRequest.verbosityDelta, previousHover: m }
				a = await this._provider.provideHover(i, s, r, f)
			} else a = await this._provider.provideHover(i, s, r)
			if (!a || rf(a.contents)) return
			a.range || (a.range = i.getWordRangeAtPosition(s)), a.range || (a.range = new pe(s, s))
			let l = Zu.from(a),
				d = this._hoverCounter
			if (this._hoverMap.size === o.HOVER_MAP_MAX_SIZE) {
				let u = Math.min(...this._hoverMap.keys())
				this._hoverMap.delete(u)
			}
			return this._hoverMap.set(d, a), (this._hoverCounter += 1), { ...l, id: d }
		}
		releaseHover(e) {
			this._hoverMap.delete(e)
		}
	},
	bS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideEvaluatableExpression(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideEvaluatableExpression(r, i, n)
			if (s) return zD.from(s)
		}
	},
	yS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideInlineValues(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = await this._provider.provideInlineValues(i, H.to(t), wg.to(n), r)
			if (Array.isArray(s)) return s.map((a) => Eg.from(a))
		}
	},
	IS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentHighlights(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideDocumentHighlights(r, i, n)
			if (Array.isArray(s)) return s.map(Pd.from)
		}
	},
	xS = class {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		async provideMultiDocumentHighlights(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = n
					.map((d) => {
						try {
							return this._documents.getDocument(d)
						} catch (c) {
							this._logService.error(
								"Error: Unable to retrieve document from URI: " + d + ". Error message: " + c,
							)
							return
						}
					})
					.filter((d) => d !== void 0),
				a = Je.to(t),
				l = await this._provider.provideMultiDocumentHighlights(i, a, s, r)
			if (Array.isArray(l)) return l.map(qD.from)
		}
	},
	CS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideLinkedEditingRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.provideLinkedEditingRanges(r, i, n)
			if (s && Array.isArray(s.ranges)) return { ranges: Ye(s.ranges.map(H.from)), wordPattern: s.wordPattern }
		}
	},
	SS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideReferences(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = await this._provider.provideReferences(i, s, n, r)
			if (Array.isArray(a)) return a.map($n.from)
		}
	},
	ym = class o {
		constructor(e, t, n, r, i, s, a) {
			this._documents = e
			this._commands = t
			this._diagnostics = n
			this._provider = r
			this._logService = i
			this._extension = s
			this._apiDeprecation = a
			this._cache = new mr("CodeAction")
			this._disposables = new Map()
		}
		static {
			this._maxCodeActionsPerFile = 1e3
		}
		async provideCodeActions(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = pS.isISelection(t) ? er.to(t) : H.to(t),
				a = []
			for (let f of this._diagnostics.getDiagnostics(e))
				if (s.intersection(f.range) && a.push(f) > o._maxCodeActionsPerFile) break
			let l = { diagnostics: a, only: n.only ? new lt(n.only) : void 0, triggerKind: ok.to(n.trigger) },
				d = await this._provider.provideCodeActions(i, s, l, r)
			if (!si(d) || r.isCancellationRequested) return
			let c = this._cache.add(d),
				u = new Q()
			this._disposables.set(c, u)
			let m = []
			for (let f = 0; f < d.length; f++) {
				let h = d[f]
				if (h)
					if (o._isCommand(h) && !(h instanceof xi))
						this._apiDeprecation.report(
							"CodeActionProvider.provideCodeActions - return commands",
							this._extension,
							"Return 'CodeAction' instances instead.",
						),
							m.push({ _isSynthetic: !0, title: h.title, command: this._commands.toInternal(h, u) })
					else {
						let g = h
						l.only &&
							(g.kind
								? l.only.contains(g.kind) ||
									this._logService.warn(
										`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action is of kind '${g.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`,
									)
								: this._logService.warn(
										`${this._extension.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`,
									))
						let I = g.ranges ?? []
						m.push({
							cacheId: [c, f],
							title: g.title,
							command: g.command && this._commands.toInternal(g.command, u),
							diagnostics: g.diagnostics && g.diagnostics.map(Rd.from),
							edit: g.edit && zn.from(g.edit, void 0),
							kind: g.kind && g.kind.value,
							isPreferred: g.isPreferred,
							isAI: nt(this._extension, "codeActionAI") ? g.isAI : !1,
							ranges: nt(this._extension, "codeActionRanges") ? Ye(I.map(H.from)) : void 0,
							disabled: g.disabled?.reason,
						})
					}
			}
			return { cacheId: c, actions: m }
		}
		async resolveCodeAction(e, t) {
			let [n, r] = e,
				i = this._cache.get(n, r)
			if (!i || o._isCommand(i)) return {}
			if (!this._provider.resolveCodeAction) return {}
			let s = (await this._provider.resolveCodeAction(i, t)) ?? i,
				a
			s.edit && (a = zn.from(s.edit, void 0))
			let l
			if (s.command) {
				let d = this._disposables.get(n)
				d && (l = this._commands.toInternal(s.command, d))
			}
			return { edit: a, command: l }
		}
		releaseCodeActions(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		static _isCommand(e) {
			return typeof e.command == "string" && typeof e.title == "string"
		}
	},
	jd = class {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._documents = t
			this._provider = n
			this._handle = r
			this._extension = i
			this._editsCache = new mr("DocumentPasteEdit.edits")
		}
		async prepareDocumentPaste(e, t, n, r) {
			if (!this._provider.prepareDocumentPaste) return
			this._cachedPrepare = void 0
			let i = this._documents.getDocument(e),
				s = t.map((u) => H.to(u)),
				a = Ld.toDataTransfer(n, () => {
					throw new lv()
				})
			if ((await this._provider.prepareDocumentPaste(i, s, a, r), r.isCancellationRequested)) return
			let l = Array.from(a).filter(([, u]) => !(u instanceof Ka)),
				d = new Map(),
				c = await Promise.all(
					Array.from(l, async ([u, m]) => {
						let f = He()
						return d.set(f, m), [u, await wd.from(u, m, f)]
					}),
				)
			return (this._cachedPrepare = d), { items: c }
		}
		async providePasteEdits(e, t, n, r, i, s) {
			if (!this._provider.provideDocumentPasteEdits) return []
			let a = this._documents.getDocument(t),
				l = n.map((f) => H.to(f)),
				d = r.items.map(([f, h]) => {
					let g = this._cachedPrepare?.get(h.id)
					return g
						? [f, g]
						: [
								f,
								wd.to(
									f,
									h,
									async (I) => (await this._proxy.$resolvePasteFileData(this._handle, e, I)).buffer,
								),
							]
				}),
				c = new bo(d),
				u = await this._provider.provideDocumentPasteEdits(
					a,
					l,
					c,
					{ only: i.only ? new yo(i.only) : void 0, triggerKind: i.triggerKind },
					s,
				)
			if (!u || s.isCancellationRequested) return []
			let m = this._editsCache.add(u)
			return u.map((f, h) => ({
				_cacheId: [m, h],
				title:
					f.title ??
					p(
						"defaultPasteLabel",
						"Paste using '{0}' extension",
						this._extension.displayName || this._extension.name,
					),
				kind: f.kind,
				yieldTo: f.yieldTo?.map((g) => g.value),
				insertText: typeof f.insertText == "string" ? f.insertText : { snippet: f.insertText.value },
				additionalEdit: f.additionalEdit ? zn.from(f.additionalEdit, void 0) : void 0,
			}))
		}
		async resolvePasteEdit(e, t) {
			let [n, r] = e,
				i = this._editsCache.get(n, r)
			if (!i || !this._provider.resolveDocumentPasteEdit) return {}
			let s = (await this._provider.resolveDocumentPasteEdit(i, t)) ?? i
			return {
				insertText: s.insertText,
				additionalEdit: s.additionalEdit ? zn.from(s.additionalEdit, void 0) : void 0,
			}
		}
		releasePasteEdits(e) {
			this._editsCache.delete(e)
		}
	},
	TS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentFormattingEdits(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideDocumentFormattingEdits(r, t, n)
			if (Array.isArray(i)) return i.map(on.from)
		}
	},
	wh = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentRangeFormattingEdits(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = H.to(t),
				a = await this._provider.provideDocumentRangeFormattingEdits(i, s, n, r)
			if (Array.isArray(a)) return a.map(on.from)
		}
		async provideDocumentRangesFormattingEdits(e, t, n, r) {
			bc(
				typeof this._provider.provideDocumentRangesFormattingEdits == "function",
				"INVALID invocation of `provideDocumentRangesFormattingEdits`",
			)
			let i = this._documents.getDocument(e),
				s = t.map(H.to),
				a = await this._provider.provideDocumentRangesFormattingEdits(i, s, n, r)
			if (Array.isArray(a)) return a.map(on.from)
		}
	},
	ES = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this.autoFormatTriggerCharacters = []
		}
		async provideOnTypeFormattingEdits(e, t, n, r, i) {
			let s = this._documents.getDocument(e),
				a = Je.to(t),
				l = await this._provider.provideOnTypeFormattingEdits(s, a, n, r, i)
			if (Array.isArray(l)) return l.map(on.from)
		}
	},
	Im = class {
		constructor(e, t) {
			this._provider = e
			this._logService = t
			this._cache = new mr("WorkspaceSymbols")
		}
		async provideWorkspaceSymbols(e, t) {
			let n = await this._provider.provideWorkspaceSymbols(e, t)
			if (!si(n)) return { symbols: [] }
			let r = this._cache.add(n),
				i = { cacheId: r, symbols: [] }
			for (let s = 0; s < n.length; s++) {
				let a = n[s]
				if (!a || !a.name) {
					this._logService.warn("INVALID SymbolInformation", a)
					continue
				}
				i.symbols.push({ ...nl.from(a), cacheId: [r, s] })
			}
			return i
		}
		async resolveWorkspaceSymbol(e, t) {
			if (typeof this._provider.resolveWorkspaceSymbol != "function" || !e.cacheId) return e
			let n = this._cache.get(...e.cacheId)
			if (n) {
				let r = await this._provider.resolveWorkspaceSymbol(n, t)
				return r && gr(e, nl.from(r), !0)
			}
		}
		releaseWorkspaceSymbols(e) {
			this._cache.delete(e)
		}
	},
	xm = class o {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		static supportsResolving(e) {
			return typeof e.prepareRename == "function"
		}
		async provideRenameEdits(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t)
			try {
				let a = await this._provider.provideRenameEdits(i, s, n, r)
				return a ? zn.from(a) : void 0
			} catch (a) {
				let l = o._asMessage(a)
				return l ? { rejectReason: l, edits: void 0 } : Promise.reject(a)
			}
		}
		async resolveRenameLocation(e, t, n) {
			if (typeof this._provider.prepareRename != "function") return Promise.resolve(void 0)
			let r = this._documents.getDocument(e),
				i = Je.to(t)
			try {
				let s = await this._provider.prepareRename(r, i, n),
					a,
					l
				if (
					(pe.isRange(s) ? ((a = s), (l = r.getText(s))) : dt(s) && ((a = s.range), (l = s.placeholder)),
					!a || !l)
				)
					return
				if (a.start.line > i.line || a.end.line < i.line) {
					this._logService.warn("INVALID rename location: position line must be within range start/end lines")
					return
				}
				return { range: H.from(a), text: l }
			} catch (s) {
				let a = o._asMessage(s)
				return a ? { rejectReason: a, range: void 0, text: void 0 } : Promise.reject(s)
			}
		}
		static _asMessage(e) {
			return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0
		}
	},
	Ph = class o {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		static {
			this.languageTriggerKindToVSCodeTriggerKind = { 0: 0, 1: 1 }
		}
		async supportsAutomaticNewSymbolNamesTriggerKind() {
			return this._provider.supportsAutomaticTriggerKind
		}
		async provideNewSymbolNames(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = H.to(t)
			try {
				let a = o.languageTriggerKindToVSCodeTriggerKind[n],
					l = await this._provider.provideNewSymbolNames(i, s, a, r)
				return l
					? l.map((d) =>
							typeof d == "string"
								? { newSymbolName: d }
								: { newSymbolName: d.newSymbolName, tags: d.tags },
						)
					: void 0
			} catch (a) {
				this._logService.error(o._asMessage(a) ?? JSON.stringify(a, null, "	"))
				return
			}
		}
		static _asMessage(e) {
			return typeof e == "string" ? e : e instanceof Error && typeof e.message == "string" ? e.message : void 0
		}
	},
	_h = class {
		constructor(e, t) {
			this.resultId = e
			this.tokens = t
		}
	},
	Dh = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._nextResultId = 1
			this._previousResults = new Map()
		}
		async provideDocumentSemanticTokens(e, t, n) {
			let r = this._documents.getDocument(e),
				i = t !== 0 ? this._previousResults.get(t) : null,
				s =
					typeof i?.resultId == "string" &&
					typeof this._provider.provideDocumentSemanticTokensEdits == "function"
						? await this._provider.provideDocumentSemanticTokensEdits(r, i.resultId, n)
						: await this._provider.provideDocumentSemanticTokens(r, n)
			return (
				i && this._previousResults.delete(t),
				s ? ((s = o._fixProvidedSemanticTokens(s)), this._send(o._convertToEdits(i, s), s)) : null
			)
		}
		async releaseDocumentSemanticColoring(e) {
			this._previousResults.delete(e)
		}
		static _fixProvidedSemanticTokens(e) {
			return o._isSemanticTokens(e)
				? o._isCorrectSemanticTokens(e)
					? e
					: new Xo(new Uint32Array(e.data), e.resultId)
				: o._isSemanticTokensEdits(e)
					? o._isCorrectSemanticTokensEdits(e)
						? e
						: new ja(
								e.edits.map(
									(t) => new wu(t.start, t.deleteCount, t.data ? new Uint32Array(t.data) : t.data),
								),
								e.resultId,
							)
					: e
		}
		static _isSemanticTokens(e) {
			return e && !!e.data
		}
		static _isCorrectSemanticTokens(e) {
			return e.data instanceof Uint32Array
		}
		static _isSemanticTokensEdits(e) {
			return e && Array.isArray(e.edits)
		}
		static _isCorrectSemanticTokensEdits(e) {
			for (let t of e.edits) if (!(t.data instanceof Uint32Array)) return !1
			return !0
		}
		static _convertToEdits(e, t) {
			if (!o._isSemanticTokens(t) || !e || !e.tokens) return t
			let n = e.tokens,
				r = n.length,
				i = t.data,
				s = i.length,
				a = 0,
				l = Math.min(r, s)
			for (; a < l && n[a] === i[a]; ) a++
			if (a === r && a === s) return new ja([], t.resultId)
			let d = 0,
				c = l - a
			for (; d < c && n[r - d - 1] === i[s - d - 1]; ) d++
			return new ja([{ start: a, deleteCount: r - a - d, data: i.subarray(a, s - d) }], t.resultId)
		}
		_send(e, t) {
			if (o._isSemanticTokens(e)) {
				let n = this._nextResultId++
				return (
					this._previousResults.set(n, new _h(e.resultId, e.data)), UC({ id: n, type: "full", data: e.data })
				)
			}
			if (o._isSemanticTokensEdits(e)) {
				let n = this._nextResultId++
				return (
					o._isSemanticTokens(t)
						? this._previousResults.set(n, new _h(t.resultId, t.data))
						: this._previousResults.set(n, new _h(e.resultId)),
					UC({
						id: n,
						type: "delta",
						deltas: (e.edits || []).map((r) => ({
							start: r.start,
							deleteCount: r.deleteCount,
							data: r.data,
						})),
					})
				)
			}
			return null
		}
	},
	wS = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideDocumentRangeSemanticTokens(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideDocumentRangeSemanticTokens(r, H.to(t), n)
			return i ? this._send(i) : null
		}
		_send(e) {
			return UC({ id: 0, type: "full", data: e.data })
		}
	},
	Gd = class o {
		constructor(e, t, n, r, i) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._apiDeprecation = r
			this._extension = i
			this._cache = new mr("CompletionItem")
			this._disposables = new Map()
		}
		static supportsResolving(e) {
			return typeof e.resolveCompletionItem == "function"
		}
		async provideCompletionItems(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = i.getWordRangeAtPosition(s) || new pe(s, s),
				l = a.with({ end: s }),
				d = new zt(),
				c = await this._provider.provideCompletionItems(i, s, r, KD.to(n))
			if (!c || r.isCancellationRequested) return
			let u = Array.isArray(c) ? new zo(c) : c,
				m = o.supportsResolving(this._provider) ? this._cache.add(u.items) : this._cache.add([]),
				f = new Q()
			this._disposables.set(m, f)
			let h = [],
				g = {
					x: m,
					b: h,
					a: { replace: H.from(a), insert: H.from(l) },
					c: u.isIncomplete || void 0,
					d: d.elapsed(),
				}
			for (let I = 0; I < u.items.length; I++) {
				let C = u.items[I],
					T = this._convertCompletionItem(C, [m, I], l, a)
				h.push(T)
			}
			return g
		}
		async resolveCompletionItem(e, t) {
			if (typeof this._provider.resolveCompletionItem != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = this._convertCompletionItem(n, e),
				i = await this._provider.resolveCompletionItem(n, t)
			if (!i) return
			let s = this._convertCompletionItem(i, e)
			return (
				(r.h !== s.h || r.i !== s.i) &&
					this._apiDeprecation.report(
						"CompletionItem.insertText",
						this._extension,
						"extension MAY NOT change 'insertText' of a CompletionItem during resolve",
					),
				(r.n !== s.n || r.o !== s.o || !nn(r.p, s.p)) &&
					this._apiDeprecation.report(
						"CompletionItem.command",
						this._extension,
						"extension MAY NOT change 'command' of a CompletionItem during resolve",
					),
				{ ...r, d: s.d, c: s.c, l: s.l, h: s.h, i: s.i, n: s.n, o: s.o, p: s.p }
			)
		}
		releaseCompletionItems(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		_convertCompletionItem(e, t, n, r) {
			let i = this._disposables.get(t[0])
			if (!i) throw Error("DisposableStore is missing...")
			let s = this._commands.toInternal(e.command, i),
				a = {
					x: t,
					a: e.label,
					b: e.kind !== void 0 ? mx.from(e.kind) : void 0,
					m: e.tags && e.tags.map(px.from),
					c: e.detail,
					d: typeof e.documentation > "u" ? void 0 : Se.fromStrict(e.documentation),
					e: e.sortText !== e.label ? e.sortText : void 0,
					f: e.filterText !== e.label ? e.filterText : void 0,
					g: e.preselect || void 0,
					i: e.keepWhitespace ? 1 : 0,
					k: e.commitCharacters?.join(""),
					l: e.additionalTextEdits && e.additionalTextEdits.map(on.from),
					n: s?.$ident,
					o: s?.id,
					p: s?.$ident ? void 0 : s?.arguments,
				}
			e.textEdit
				? (this._apiDeprecation.report(
						"CompletionItem.textEdit",
						this._extension,
						"Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.",
					),
					(a.h = e.textEdit.newText))
				: typeof e.insertText == "string"
					? (a.h = e.insertText)
					: e.insertText instanceof Vn && ((a.h = e.insertText.value), (a.i |= 4))
			let l
			return (
				e.textEdit ? (l = e.textEdit.range) : e.range && (l = e.range),
				pe.isRange(l)
					? (a.j = H.from(l))
					: l &&
						(!n?.isEqual(l.inserting) || !r?.isEqual(l.replacing)) &&
						(a.j = { insert: H.from(l.inserting), replace: H.from(l.replacing) }),
				a
			)
		}
	},
	Qs = class {
		constructor(e, t, n, r) {
			this._extension = e
			this._documents = t
			this._provider = n
			this._commands = r
			this._references = new PS()
			this._isAdditionsProposedApiEnabled = nt(this._extension, "inlineCompletionsAdditions")
			this.languageTriggerKindToVSCodeTriggerKind = { 0: 1, 1: 0 }
		}
		get supportsHandleEvents() {
			return (
				nt(this._extension, "inlineCompletionsAdditions") &&
				(typeof this._provider.handleDidShowCompletionItem == "function" ||
					typeof this._provider.handleDidPartiallyAcceptCompletionItem == "function" ||
					typeof this._provider.handleDidRejectCompletionItem == "function")
			)
		}
		async provideInlineCompletions(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = await this._provider.provideInlineCompletionItems(
					i,
					s,
					{
						selectedCompletionInfo: n.selectedSuggestionInfo
							? { range: H.to(n.selectedSuggestionInfo.range), text: n.selectedSuggestionInfo.text }
							: void 0,
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[n.triggerKind],
						requestUuid: n.requestUuid,
					},
					r,
				)
			if (!a || r.isCancellationRequested) return
			let l = Array.isArray(a) ? a : a.items,
				d = this._isAdditionsProposedApiEnabled ? (Array.isArray(a) ? [] : a.commands || []) : [],
				c = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0,
				u
			return {
				pid: this._references.createReferenceId({
					dispose() {
						u?.dispose()
					},
					items: l,
				}),
				items: l.map((f, h) => {
					let g
					f.command && (u || (u = new Q()), (g = this._commands.toInternal(f.command, u)))
					let I
					f.action && (u || (u = new Q()), (I = this._commands.toInternal(f.action, u)))
					let C = f.insertText
					return {
						insertText: typeof C == "string" ? C : { snippet: C.value },
						filterText: f.filterText,
						range: f.range ? H.from(f.range) : void 0,
						showRange: this._isAdditionsProposedApiEnabled && f.showRange ? H.from(f.showRange) : void 0,
						command: g,
						action: I,
						idx: h,
						completeBracketPairs: this._isAdditionsProposedApiEnabled ? f.completeBracketPairs : !1,
						isInlineEdit: this._isAdditionsProposedApiEnabled ? f.isInlineEdit : !1,
						showInlineEditMenu: this._isAdditionsProposedApiEnabled ? f.showInlineEditMenu : !1,
						warning:
							f.warning && this._isAdditionsProposedApiEnabled
								? {
										message: Se.from(f.warning.message),
										icon: f.warning.icon ? mk.fromThemeIcon(f.warning.icon) : void 0,
									}
								: void 0,
					}
				}),
				commands: d.map((f) => (u || (u = new Q()), this._commands.toInternal(f, u))),
				suppressSuggestions: !1,
				enableForwardStability: c,
			}
		}
		async provideInlineEditsForRange(e, t, n, r) {
			if (!this._provider.provideInlineEditsForRange) return
			F(this._extension, "inlineCompletionsAdditions")
			let i = this._documents.getDocument(e),
				s = H.to(t),
				a = await this._provider.provideInlineEditsForRange(
					i,
					s,
					{
						selectedCompletionInfo: n.selectedSuggestionInfo
							? { range: H.to(n.selectedSuggestionInfo.range), text: n.selectedSuggestionInfo.text }
							: void 0,
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[n.triggerKind],
						userPrompt: n.userPrompt,
						requestUuid: n.requestUuid,
					},
					r,
				)
			if (!a || r.isCancellationRequested) return
			let l = Array.isArray(a) ? a : a.items,
				d = this._isAdditionsProposedApiEnabled ? (Array.isArray(a) ? [] : a.commands || []) : [],
				c = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0,
				u
			return {
				pid: this._references.createReferenceId({
					dispose() {
						u?.dispose()
					},
					items: l,
				}),
				items: l.map((f, h) => {
					let g
					f.command && (u || (u = new Q()), (g = this._commands.toInternal(f.command, u)))
					let I
					f.action && (u || (u = new Q()), (I = this._commands.toInternal(f.action, u)))
					let C = f.insertText
					return {
						insertText: typeof C == "string" ? C : { snippet: C.value },
						filterText: f.filterText,
						range: f.range ? H.from(f.range) : void 0,
						command: g,
						action: I,
						idx: h,
						completeBracketPairs: this._isAdditionsProposedApiEnabled ? f.completeBracketPairs : !1,
					}
				}),
				commands: d.map((f) => (u || (u = new Q()), this._commands.toInternal(f, u))),
				suppressSuggestions: !1,
				enableForwardStability: c,
			}
		}
		disposeCompletions(e) {
			this._references.disposeReferenceId(e)?.dispose()
		}
		handleDidShowCompletionItem(e, t, n) {
			let r = this._references.get(e)?.items[t]
			r &&
				this._provider.handleDidShowCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				this._provider.handleDidShowCompletionItem(r, n)
		}
		handlePartialAccept(e, t, n, r) {
			let i = this._references.get(e)?.items[t]
			i &&
				this._provider.handleDidPartiallyAcceptCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				(this._provider.handleDidPartiallyAcceptCompletionItem(i, n),
				this._provider.handleDidPartiallyAcceptCompletionItem(i, ck.to(r)))
		}
		handleRejection(e, t) {
			let n = this._references.get(e)?.items[t]
			n &&
				this._provider.handleDidRejectCompletionItem &&
				this._isAdditionsProposedApiEnabled &&
				this._provider.handleDidRejectCompletionItem(n)
		}
	},
	kh = class {
		constructor(e, t, n, r) {
			this._documents = t
			this._provider = n
			this._commands = r
			this._references = new PS()
			this.languageTriggerKindToVSCodeTriggerKind = { 1: 1, 0: 0 }
		}
		async provideInlineEdits(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideInlineEdit(
					r,
					{
						triggerKind: this.languageTriggerKindToVSCodeTriggerKind[t.triggerKind],
						requestUuid: t.requestUuid,
					},
					n,
				)
			if (!i || n.isCancellationRequested) return
			let s,
				a = this._references.createReferenceId({
					dispose() {
						s?.dispose()
					},
					item: i,
				}),
				l
			i.accepted && (s || (s = new Q()), (l = this._commands.toInternal(i.accepted, s)))
			let d
			i.rejected && (s || (s = new Q()), (d = this._commands.toInternal(i.rejected, s)))
			let c
			i.shown && (s || (s = new Q()), (c = this._commands.toInternal(i.shown, s)))
			let u
			return (
				i.action && (s || (s = new Q()), (u = this._commands.toInternal(i.action, s))),
				s || (s = new Q()),
				{
					pid: a,
					text: i.text,
					range: H.from(i.range),
					showRange: H.from(i.showRange),
					accepted: l,
					rejected: d,
					shown: c,
					action: u,
					commands: i.commands?.map((f) => this._commands.toInternal(f, s)),
				}
			)
		}
		disposeEdit(e) {
			this._references.disposeReferenceId(e)?.dispose()
		}
	},
	PS = class {
		constructor() {
			this._references = new Map()
			this._idPool = 1
		}
		createReferenceId(e) {
			let t = this._idPool++
			return this._references.set(t, e), t
		}
		disposeReferenceId(e) {
			let t = this._references.get(e)
			return this._references.delete(e), t
		}
		get(e) {
			return this._references.get(e)
		}
	},
	Rh = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._cache = new mr("SignatureHelp")
		}
		async provideSignatureHelp(e, t, n, r) {
			let i = this._documents.getDocument(e),
				s = Je.to(t),
				a = this.reviveContext(n),
				l = await this._provider.provideSignatureHelp(i, s, r, a)
			if (l) {
				let d = this._cache.add([l])
				return { ...ep.from(l), id: d }
			}
		}
		reviveContext(e) {
			let t
			if (e.activeSignatureHelp) {
				let n = ep.to(e.activeSignatureHelp),
					r = this._cache.get(e.activeSignatureHelp.id, 0)
				r
					? ((t = r), (t.activeSignature = n.activeSignature), (t.activeParameter = n.activeParameter))
					: (t = n)
			}
			return { ...e, activeSignatureHelp: t }
		}
		releaseSignatureHelp(e) {
			this._cache.delete(e)
		}
	},
	Cm = class {
		constructor(e, t, n, r, i) {
			this._documents = e
			this._commands = t
			this._provider = n
			this._logService = r
			this._extension = i
			this._cache = new mr("InlayHints")
			this._disposables = new Map()
		}
		async provideInlayHints(e, t, n) {
			let r = this._documents.getDocument(e),
				i = H.to(t),
				s = await this._provider.provideInlayHints(r, i, n)
			if (!Array.isArray(s) || s.length === 0) {
				this._logService.trace(
					`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`,
				)
				return
			}
			if (n.isCancellationRequested) return
			let a = this._cache.add(s)
			this._disposables.set(a, new Q())
			let l = { hints: [], cacheId: a }
			for (let d = 0; d < s.length; d++)
				this._isValidInlayHint(s[d], i) && l.hints.push(this._convertInlayHint(s[d], [a, d]))
			return (
				this._logService.trace(
					`[InlayHints] ${l.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`,
				),
				l
			)
		}
		async resolveInlayHint(e, t) {
			if (typeof this._provider.resolveInlayHint != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = await this._provider.resolveInlayHint(n, t)
			if (r && this._isValidInlayHint(r)) return this._convertInlayHint(r, e)
		}
		releaseHints(e) {
			this._disposables.get(e)?.dispose(), this._disposables.delete(e), this._cache.delete(e)
		}
		_isValidInlayHint(e, t) {
			return e.label.length === 0 || (Array.isArray(e.label) && e.label.every((n) => n.value.length === 0))
				? (console.log("INVALID inlay hint, empty label", e), !1)
				: !(t && !t.contains(e.position))
		}
		_convertInlayHint(e, t) {
			let n = this._disposables.get(t[0])
			if (!n) throw Error("DisposableStore is missing...")
			let r = {
				label: "",
				cacheId: t,
				tooltip: Se.fromStrict(e.tooltip),
				position: Je.from(e.position),
				textEdits: e.textEdits && e.textEdits.map(on.from),
				kind: e.kind && fx.from(e.kind),
				paddingLeft: e.paddingLeft,
				paddingRight: e.paddingRight,
			}
			if (typeof e.label == "string") r.label = e.label
			else {
				let i = []
				r.label = i
				for (let s of e.label) {
					if (!s.value) {
						console.warn("INVALID inlay hint, empty label part", this._extension.identifier.value)
						continue
					}
					let a = { label: s.value, tooltip: Se.fromStrict(s.tooltip) }
					rn.isLocation(s.location) && (a.location = $n.from(s.location)),
						s.command && (a.command = this._commands.toInternal(s.command, n)),
						i.push(a)
				}
			}
			return r
		}
	},
	Sm = class o {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._cache = new mr("DocumentLink")
		}
		async provideLinks(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentLinks(n, t)
			if (!(!Array.isArray(r) || r.length === 0) && !t.isCancellationRequested) {
				if (typeof this._provider.resolveDocumentLink != "function")
					return { links: r.filter(o._validateLink).map(Vs.from) }
				{
					let i = this._cache.add(r),
						s = { links: [], cacheId: i }
					for (let a = 0; a < r.length; a++) {
						if (!o._validateLink(r[a])) continue
						let l = Vs.from(r[a])
						;(l.cacheId = [i, a]), s.links.push(l)
					}
					return s
				}
			}
		}
		static _validateLink(e) {
			return e.target && e.target.path.length > 5e4
				? (console.warn("DROPPING link because it is too long"), !1)
				: !0
		}
		async resolveLink(e, t) {
			if (typeof this._provider.resolveDocumentLink != "function") return
			let n = this._cache.get(...e)
			if (!n) return
			let r = await this._provider.resolveDocumentLink(n, t)
			if (!(!r || !o._validateLink(r))) return Vs.from(r)
		}
		releaseLinks(e) {
			this._cache.delete(e)
		}
	},
	Ah = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideColors(e, t) {
			let n = this._documents.getDocument(e),
				r = await this._provider.provideDocumentColors(n, t)
			return Array.isArray(r) ? r.map((s) => ({ color: Ad.from(s.color), range: H.from(s.range) })) : []
		}
		async provideColorPresentations(e, t, n) {
			let r = this._documents.getDocument(e),
				i = H.to(t.range),
				s = Ad.to(t.color),
				a = await this._provider.provideColorPresentations(s, { document: r, range: i }, n)
			if (Array.isArray(a)) return a.map(Pg.from)
		}
	},
	_S = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
		}
		async provideFoldingRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = await this._provider.provideFoldingRanges(r, t, n)
			if (Array.isArray(i)) return i.map(Dg.from)
		}
	},
	DS = class {
		constructor(e, t, n) {
			this._documents = e
			this._provider = t
			this._logService = n
		}
		async provideSelectionRanges(e, t, n) {
			let r = this._documents.getDocument(e),
				i = t.map(Je.to),
				s = await this._provider.provideSelectionRanges(r, i, n)
			if (!si(s)) return []
			if (s.length !== i.length)
				return this._logService.warn("BAD selection ranges, provider must return ranges for each position"), []
			let a = []
			for (let l = 0; l < i.length; l++) {
				let d = []
				a.push(d)
				let c = i[l],
					u = s[l]
				for (;;) {
					if (!u.range.contains(c))
						throw new Error("INVALID selection range, must contain the previous range")
					if ((d.push(QD.from(u)), !u.parent)) break
					;(c = u.range), (u = u.parent)
				}
			}
			return a
		}
	},
	Qd = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._idPool = new fl("")
			this._cache = new Map()
		}
		async prepareSession(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.prepareCallHierarchy(r, i, n)
			if (!s) return
			let a = this._idPool.nextId()
			return (
				this._cache.set(a, new Map()),
				Array.isArray(s) ? s.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, s)]
			)
		}
		async provideCallsTo(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing call hierarchy item")
			let i = await this._provider.provideCallHierarchyIncomingCalls(r, n)
			if (i)
				return i.map((s) => ({
					from: this._cacheAndConvertItem(e, s.from),
					fromRanges: s.fromRanges.map((a) => H.from(a)),
				}))
		}
		async provideCallsFrom(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing call hierarchy item")
			let i = await this._provider.provideCallHierarchyOutgoingCalls(r, n)
			if (i)
				return i.map((s) => ({
					to: this._cacheAndConvertItem(e, s.to),
					fromRanges: s.fromRanges.map((a) => H.from(a)),
				}))
		}
		releaseSession(e) {
			this._cache.delete(e)
		}
		_cacheAndConvertItem(e, t) {
			let n = this._cache.get(e),
				r = Ws.from(t, e, n.size.toString(36))
			return n.set(r._itemId, t), r
		}
		_itemFromCache(e, t) {
			return this._cache.get(e)?.get(t)
		}
	},
	Jd = class {
		constructor(e, t) {
			this._documents = e
			this._provider = t
			this._idPool = new fl("")
			this._cache = new Map()
		}
		async prepareSession(e, t, n) {
			let r = this._documents.getDocument(e),
				i = Je.to(t),
				s = await this._provider.prepareTypeHierarchy(r, i, n)
			if (!s) return
			let a = this._idPool.nextId()
			return (
				this._cache.set(a, new Map()),
				Array.isArray(s) ? s.map((l) => this._cacheAndConvertItem(a, l)) : [this._cacheAndConvertItem(a, s)]
			)
		}
		async provideSupertypes(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing type hierarchy item")
			let i = await this._provider.provideTypeHierarchySupertypes(r, n)
			if (i) return i.map((s) => this._cacheAndConvertItem(e, s))
		}
		async provideSubtypes(e, t, n) {
			let r = this._itemFromCache(e, t)
			if (!r) throw new Error("missing type hierarchy item")
			let i = await this._provider.provideTypeHierarchySubtypes(r, n)
			if (i) return i.map((s) => this._cacheAndConvertItem(e, s))
		}
		releaseSession(e) {
			this._cache.delete(e)
		}
		_cacheAndConvertItem(e, t) {
			let n = this._cache.get(e),
				r = Bs.from(t, e, n.size.toString(36))
			return n.set(r._itemId, t), r
		}
		_itemFromCache(e, t) {
			return this._cache.get(e)?.get(t)
		}
	},
	Tm = class {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._documents = t
			this._provider = n
			this._handle = r
			this._extension = i
			this._cache = new mr("DocumentDropEdit")
		}
		async provideDocumentOnDropEdits(e, t, n, r, i) {
			let s = this._documents.getDocument(t),
				a = Je.to(n),
				l = Ld.toDataTransfer(
					r,
					async (m) => (await this._proxy.$resolveDocumentOnDropFileData(this._handle, e, m)).buffer,
				),
				d = await this._provider.provideDocumentDropEdits(s, a, l, i)
			if (!d) return
			let c = an(d),
				u = this._cache.add(c)
			return c.map((m, f) => ({
				_cacheId: [u, f],
				title:
					m.title ??
					p(
						"defaultDropLabel",
						"Drop using '{0}' extension",
						this._extension.displayName || this._extension.name,
					),
				kind: m.kind?.value,
				yieldTo: m.yieldTo?.map((h) => h.value),
				insertText: typeof m.insertText == "string" ? m.insertText : { snippet: m.insertText.value },
				additionalEdit: m.additionalEdit ? zn.from(m.additionalEdit, void 0) : void 0,
			}))
		}
		async resolveDropEdit(e, t) {
			let [n, r] = e,
				i = this._cache.get(n, r)
			if (!i || !this._provider.resolveDocumentDropEdit) return {}
			let s = (await this._provider.resolveDocumentDropEdit(i, t)) ?? i
			return { additionalEdit: s.additionalEdit ? zn.from(s.additionalEdit, void 0) : void 0 }
		}
		releaseDropEdits(e) {
			this._cache.delete(e)
		}
	},
	Xd = class {
		constructor(e, t) {
			this.adapter = e
			this.extension = t
		}
	},
	kS = class o {
		constructor(e, t, n, r, i, s, a, l) {
			this._uriTransformer = t
			this._documents = n
			this._commands = r
			this._diagnostics = i
			this._logService = s
			this._apiDeprecation = a
			this._extensionTelemetry = l
			this._adapter = new Map()
			this._proxy = e.getProxy(M.MainThreadLanguageFeatures)
		}
		static {
			this._handlePool = 0
		}
		_transformDocumentSelector(e, t) {
			return Hs.from(e, this._uriTransformer, t)
		}
		_createDisposable(e) {
			return new ye(() => {
				this._adapter.delete(e), this._proxy.$unregister(e)
			})
		}
		_nextHandle() {
			return o._handlePool++
		}
		async _withAdapter(e, t, n, r, i, s = !1) {
			let a = this._adapter.get(e)
			if (!a || !(a.adapter instanceof t)) return r
			let l = Date.now()
			s ||
				this._logService.trace(
					`[${a.extension.identifier.value}] INVOKE provider '${n.toString().replace(/[\r\n]/g, "")}'`,
				)
			let d = n(a.adapter, a.extension)
			return (
				Promise.resolve(d)
					.catch((c) => {
						bn(c) ||
							(this._logService.error(`[${a.extension.identifier.value}] provider FAILED`),
							this._logService.error(c),
							this._extensionTelemetry.onExtensionError(a.extension.identifier, c))
					})
					.finally(() => {
						s ||
							this._logService.trace(
								`[${a.extension.identifier.value}] provider DONE after ${Date.now() - l}ms`,
							)
					}),
				De.isCancellationToken(i) ? yO(d, i) : d
			)
		}
		_addNewAdapter(e, t) {
			let n = this._nextHandle()
			return this._adapter.set(n, new Xd(e, t)), n
		}
		static _extLabel(e) {
			return e.displayName || e.name
		}
		static _extId(e) {
			return e.identifier.value
		}
		registerDocumentSymbolProvider(e, t, n, r) {
			let i = this._addNewAdapter(new mS(this._documents, n), e),
				s = (r && r.label) || o._extLabel(e)
			return (
				this._proxy.$registerDocumentSymbolProvider(i, this._transformDocumentSelector(t, e), s),
				this._createDisposable(i)
			)
		}
		$provideDocumentSymbols(e, t, n) {
			return this._withAdapter(e, mS, (r) => r.provideDocumentSymbols(b.revive(t), n), void 0, n)
		}
		registerCodeLensProvider(e, t, n) {
			let r = this._nextHandle(),
				i = typeof n.onDidChangeCodeLenses == "function" ? this._nextHandle() : void 0
			this._adapter.set(
				r,
				new Xd(
					new bm(this._documents, this._commands.converter, n, e, this._extensionTelemetry, this._logService),
					e,
				),
			),
				this._proxy.$registerCodeLensSupport(r, this._transformDocumentSelector(t, e), i)
			let s = this._createDisposable(r)
			if (i !== void 0) {
				let a = n.onDidChangeCodeLenses((l) => this._proxy.$emitCodeLensEvent(i))
				s = ye.from(s, a)
			}
			return s
		}
		$provideCodeLenses(e, t, n) {
			return this._withAdapter(
				e,
				bm,
				(r) => r.provideCodeLenses(b.revive(t), n),
				void 0,
				n,
				t.scheme === "output",
			)
		}
		$resolveCodeLens(e, t, n) {
			return this._withAdapter(e, bm, (r) => r.resolveCodeLens(t, n), void 0, void 0, !0)
		}
		$releaseCodeLenses(e, t) {
			this._withAdapter(e, bm, (n) => Promise.resolve(n.releaseCodeLenses(t)), void 0, void 0, !0)
		}
		registerDefinitionProvider(e, t, n) {
			let r = this._addNewAdapter(new fS(this._documents, n), e)
			return (
				this._proxy.$registerDefinitionSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDefinition(e, t, n, r) {
			return this._withAdapter(e, fS, (i) => i.provideDefinition(b.revive(t), n, r), [], r)
		}
		registerDeclarationProvider(e, t, n) {
			let r = this._addNewAdapter(new gS(this._documents, n), e)
			return (
				this._proxy.$registerDeclarationSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDeclaration(e, t, n, r) {
			return this._withAdapter(e, gS, (i) => i.provideDeclaration(b.revive(t), n, r), [], r)
		}
		registerImplementationProvider(e, t, n) {
			let r = this._addNewAdapter(new hS(this._documents, n), e)
			return (
				this._proxy.$registerImplementationSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideImplementation(e, t, n, r) {
			return this._withAdapter(e, hS, (i) => i.provideImplementation(b.revive(t), n, r), [], r)
		}
		registerTypeDefinitionProvider(e, t, n) {
			let r = this._addNewAdapter(new vS(this._documents, n), e)
			return (
				this._proxy.$registerTypeDefinitionSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideTypeDefinition(e, t, n, r) {
			return this._withAdapter(e, vS, (i) => i.provideTypeDefinition(b.revive(t), n, r), [], r)
		}
		registerHoverProvider(e, t, n, r) {
			let i = this._addNewAdapter(new Eh(this._documents, n), e)
			return (
				this._proxy.$registerHoverProvider(i, this._transformDocumentSelector(t, e)), this._createDisposable(i)
			)
		}
		$provideHover(e, t, n, r, i) {
			return this._withAdapter(e, Eh, (s) => s.provideHover(b.revive(t), n, r, i), void 0, i)
		}
		$releaseHover(e, t) {
			this._withAdapter(e, Eh, (n) => Promise.resolve(n.releaseHover(t)), void 0, void 0)
		}
		registerEvaluatableExpressionProvider(e, t, n, r) {
			let i = this._addNewAdapter(new bS(this._documents, n), e)
			return (
				this._proxy.$registerEvaluatableExpressionProvider(i, this._transformDocumentSelector(t, e)),
				this._createDisposable(i)
			)
		}
		$provideEvaluatableExpression(e, t, n, r) {
			return this._withAdapter(e, bS, (i) => i.provideEvaluatableExpression(b.revive(t), n, r), void 0, r)
		}
		registerInlineValuesProvider(e, t, n, r) {
			let i = typeof n.onDidChangeInlineValues == "function" ? this._nextHandle() : void 0,
				s = this._addNewAdapter(new yS(this._documents, n), e)
			this._proxy.$registerInlineValuesProvider(s, this._transformDocumentSelector(t, e), i)
			let a = this._createDisposable(s)
			if (i !== void 0) {
				let l = n.onDidChangeInlineValues((d) => this._proxy.$emitInlineValuesEvent(i))
				a = ye.from(a, l)
			}
			return a
		}
		$provideInlineValues(e, t, n, r, i) {
			return this._withAdapter(e, yS, (s) => s.provideInlineValues(b.revive(t), n, r, i), void 0, i)
		}
		registerDocumentHighlightProvider(e, t, n) {
			let r = this._addNewAdapter(new IS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentHighlightProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		registerMultiDocumentHighlightProvider(e, t, n) {
			let r = this._addNewAdapter(new xS(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerMultiDocumentHighlightProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDocumentHighlights(e, t, n, r) {
			return this._withAdapter(e, IS, (i) => i.provideDocumentHighlights(b.revive(t), n, r), void 0, r)
		}
		$provideMultiDocumentHighlights(e, t, n, r, i) {
			return this._withAdapter(
				e,
				xS,
				(s) =>
					s.provideMultiDocumentHighlights(
						b.revive(t),
						n,
						r.map((a) => b.revive(a)),
						i,
					),
				void 0,
				i,
			)
		}
		registerLinkedEditingRangeProvider(e, t, n) {
			let r = this._addNewAdapter(new CS(this._documents, n), e)
			return (
				this._proxy.$registerLinkedEditingRangeProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideLinkedEditingRanges(e, t, n, r) {
			return this._withAdapter(
				e,
				CS,
				async (i) => {
					let s = await i.provideLinkedEditingRanges(b.revive(t), n, r)
					if (s)
						return {
							ranges: s.ranges,
							wordPattern: s.wordPattern ? o._serializeRegExp(s.wordPattern) : void 0,
						}
				},
				void 0,
				r,
			)
		}
		registerReferenceProvider(e, t, n) {
			let r = this._addNewAdapter(new SS(this._documents, n), e)
			return (
				this._proxy.$registerReferenceSupport(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideReferences(e, t, n, r, i) {
			return this._withAdapter(e, SS, (s) => s.provideReferences(b.revive(t), n, r, i), void 0, i)
		}
		registerCodeActionProvider(e, t, n, r) {
			let i = new Q(),
				s = this._addNewAdapter(
					new ym(
						this._documents,
						this._commands.converter,
						this._diagnostics,
						n,
						this._logService,
						e,
						this._apiDeprecation,
					),
					e,
				)
			return (
				this._proxy.$registerCodeActionSupport(
					s,
					this._transformDocumentSelector(t, e),
					{
						providedKinds: r?.providedCodeActionKinds?.map((a) => a.value),
						documentation: r?.documentation?.map((a) => ({
							kind: a.kind.value,
							command: this._commands.converter.toInternal(a.command, i),
						})),
					},
					o._extLabel(e),
					o._extId(e),
					!!n.resolveCodeAction,
				),
				i.add(this._createDisposable(s)),
				i
			)
		}
		$provideCodeActions(e, t, n, r, i) {
			return this._withAdapter(e, ym, (s) => s.provideCodeActions(b.revive(t), n, r, i), void 0, i)
		}
		$resolveCodeAction(e, t, n) {
			return this._withAdapter(e, ym, (r) => r.resolveCodeAction(t, n), {}, void 0)
		}
		$releaseCodeActions(e, t) {
			this._withAdapter(e, ym, (n) => Promise.resolve(n.releaseCodeActions(t)), void 0, void 0)
		}
		registerDocumentFormattingEditProvider(e, t, n) {
			let r = this._addNewAdapter(new TS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentFormattingSupport(
					r,
					this._transformDocumentSelector(t, e),
					e.identifier,
					e.displayName || e.name,
				),
				this._createDisposable(r)
			)
		}
		$provideDocumentFormattingEdits(e, t, n, r) {
			return this._withAdapter(e, TS, (i) => i.provideDocumentFormattingEdits(b.revive(t), n, r), void 0, r)
		}
		registerDocumentRangeFormattingEditProvider(e, t, n) {
			let r = typeof n.provideDocumentRangesFormattingEdits == "function",
				i = this._addNewAdapter(new wh(this._documents, n), e)
			return (
				this._proxy.$registerRangeFormattingSupport(
					i,
					this._transformDocumentSelector(t, e),
					e.identifier,
					e.displayName || e.name,
					r,
				),
				this._createDisposable(i)
			)
		}
		$provideDocumentRangeFormattingEdits(e, t, n, r, i) {
			return this._withAdapter(
				e,
				wh,
				(s) => s.provideDocumentRangeFormattingEdits(b.revive(t), n, r, i),
				void 0,
				i,
			)
		}
		$provideDocumentRangesFormattingEdits(e, t, n, r, i) {
			return this._withAdapter(
				e,
				wh,
				(s) => s.provideDocumentRangesFormattingEdits(b.revive(t), n, r, i),
				void 0,
				i,
			)
		}
		registerOnTypeFormattingEditProvider(e, t, n, r) {
			let i = this._addNewAdapter(new ES(this._documents, n), e)
			return (
				this._proxy.$registerOnTypeFormattingSupport(i, this._transformDocumentSelector(t, e), r, e.identifier),
				this._createDisposable(i)
			)
		}
		$provideOnTypeFormattingEdits(e, t, n, r, i, s) {
			return this._withAdapter(e, ES, (a) => a.provideOnTypeFormattingEdits(b.revive(t), n, r, i, s), void 0, s)
		}
		registerWorkspaceSymbolProvider(e, t) {
			let n = this._addNewAdapter(new Im(t, this._logService), e)
			return (
				this._proxy.$registerNavigateTypeSupport(n, typeof t.resolveWorkspaceSymbol == "function"),
				this._createDisposable(n)
			)
		}
		$provideWorkspaceSymbols(e, t, n) {
			return this._withAdapter(e, Im, (r) => r.provideWorkspaceSymbols(t, n), { symbols: [] }, n)
		}
		$resolveWorkspaceSymbol(e, t, n) {
			return this._withAdapter(e, Im, (r) => r.resolveWorkspaceSymbol(t, n), void 0, void 0)
		}
		$releaseWorkspaceSymbols(e, t) {
			this._withAdapter(e, Im, (n) => n.releaseWorkspaceSymbols(t), void 0, void 0)
		}
		registerRenameProvider(e, t, n) {
			let r = this._addNewAdapter(new xm(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerRenameSupport(r, this._transformDocumentSelector(t, e), xm.supportsResolving(n)),
				this._createDisposable(r)
			)
		}
		$provideRenameEdits(e, t, n, r, i) {
			return this._withAdapter(e, xm, (s) => s.provideRenameEdits(b.revive(t), n, r, i), void 0, i)
		}
		$resolveRenameLocation(e, t, n, r) {
			return this._withAdapter(e, xm, (i) => i.resolveRenameLocation(b.revive(t), n, r), void 0, r)
		}
		registerNewSymbolNamesProvider(e, t, n) {
			let r = this._addNewAdapter(new Ph(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerNewSymbolNamesProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$supportsAutomaticNewSymbolNamesTriggerKind(e) {
			return this._withAdapter(e, Ph, (t) => t.supportsAutomaticNewSymbolNamesTriggerKind(), !1, void 0)
		}
		$provideNewSymbolNames(e, t, n, r, i) {
			return this._withAdapter(e, Ph, (s) => s.provideNewSymbolNames(b.revive(t), n, r, i), void 0, i)
		}
		registerDocumentSemanticTokensProvider(e, t, n, r) {
			let i = this._addNewAdapter(new Dh(this._documents, n), e),
				s = typeof n.onDidChangeSemanticTokens == "function" ? this._nextHandle() : void 0
			this._proxy.$registerDocumentSemanticTokensProvider(i, this._transformDocumentSelector(t, e), r, s)
			let a = this._createDisposable(i)
			if (s) {
				let l = n.onDidChangeSemanticTokens((d) => this._proxy.$emitDocumentSemanticTokensEvent(s))
				a = ye.from(a, l)
			}
			return a
		}
		$provideDocumentSemanticTokens(e, t, n, r) {
			return this._withAdapter(e, Dh, (i) => i.provideDocumentSemanticTokens(b.revive(t), n, r), null, r)
		}
		$releaseDocumentSemanticTokens(e, t) {
			this._withAdapter(e, Dh, (n) => n.releaseDocumentSemanticColoring(t), void 0, void 0)
		}
		registerDocumentRangeSemanticTokensProvider(e, t, n, r) {
			let i = this._addNewAdapter(new wS(this._documents, n), e)
			return (
				this._proxy.$registerDocumentRangeSemanticTokensProvider(i, this._transformDocumentSelector(t, e), r),
				this._createDisposable(i)
			)
		}
		$provideDocumentRangeSemanticTokens(e, t, n, r) {
			return this._withAdapter(e, wS, (i) => i.provideDocumentRangeSemanticTokens(b.revive(t), n, r), null, r)
		}
		registerCompletionItemProvider(e, t, n, r) {
			let i = this._addNewAdapter(
				new Gd(this._documents, this._commands.converter, n, this._apiDeprecation, e),
				e,
			)
			return (
				this._proxy.$registerCompletionsProvider(
					i,
					this._transformDocumentSelector(t, e),
					r,
					Gd.supportsResolving(n),
					e.identifier,
				),
				this._createDisposable(i)
			)
		}
		$provideCompletionItems(e, t, n, r, i) {
			return this._withAdapter(e, Gd, (s) => s.provideCompletionItems(b.revive(t), n, r, i), void 0, i)
		}
		$resolveCompletionItem(e, t, n) {
			return this._withAdapter(e, Gd, (r) => r.resolveCompletionItem(t, n), void 0, n)
		}
		$releaseCompletionItems(e, t) {
			this._withAdapter(e, Gd, (n) => n.releaseCompletionItems(t), void 0, void 0)
		}
		registerInlineCompletionsProvider(e, t, n, r) {
			let i = new Qs(e, this._documents, n, this._commands.converter),
				s = this._addNewAdapter(i, e)
			return (
				this._proxy.$registerInlineCompletionsSupport(
					s,
					this._transformDocumentSelector(t, e),
					i.supportsHandleEvents,
					Ce.toKey(e.identifier.value),
					r?.yieldTo?.map((a) => Ce.toKey(a)) || [],
					r?.displayName,
					r?.debounceDelayMs,
				),
				this._createDisposable(s)
			)
		}
		$provideInlineCompletions(e, t, n, r, i) {
			return this._withAdapter(e, Qs, (s) => s.provideInlineCompletions(b.revive(t), n, r, i), void 0, i)
		}
		$provideInlineEditsForRange(e, t, n, r, i) {
			return this._withAdapter(e, Qs, (s) => s.provideInlineEditsForRange(b.revive(t), n, r, i), void 0, i)
		}
		$handleInlineCompletionDidShow(e, t, n, r) {
			this._withAdapter(
				e,
				Qs,
				async (i) => {
					i.handleDidShowCompletionItem(t, n, r)
				},
				void 0,
				void 0,
			)
		}
		$handleInlineCompletionPartialAccept(e, t, n, r, i) {
			this._withAdapter(
				e,
				Qs,
				async (s) => {
					s.handlePartialAccept(t, n, r, i)
				},
				void 0,
				void 0,
			)
		}
		$handleInlineCompletionRejection(e, t, n) {
			this._withAdapter(
				e,
				Qs,
				async (r) => {
					r.handleRejection(t, n)
				},
				void 0,
				void 0,
			)
		}
		$freeInlineCompletionsList(e, t) {
			this._withAdapter(
				e,
				Qs,
				async (n) => {
					n.disposeCompletions(t)
				},
				void 0,
				void 0,
			)
		}
		registerInlineEditProvider(e, t, n) {
			let r = new kh(e, this._documents, n, this._commands.converter),
				i = this._addNewAdapter(r, e)
			return (
				this._proxy.$registerInlineEditProvider(
					i,
					this._transformDocumentSelector(t, e),
					e.identifier,
					n.displayName || e.name,
				),
				this._createDisposable(i)
			)
		}
		$provideInlineEdit(e, t, n, r) {
			return this._withAdapter(e, kh, (i) => i.provideInlineEdits(b.revive(t), n, r), void 0, r)
		}
		$freeInlineEdit(e, t) {
			this._withAdapter(
				e,
				kh,
				async (n) => {
					n.disposeEdit(t)
				},
				void 0,
				void 0,
			)
		}
		registerSignatureHelpProvider(e, t, n, r) {
			let i = Array.isArray(r) ? { triggerCharacters: r, retriggerCharacters: [] } : r,
				s = this._addNewAdapter(new Rh(this._documents, n), e)
			return (
				this._proxy.$registerSignatureHelpProvider(s, this._transformDocumentSelector(t, e), i),
				this._createDisposable(s)
			)
		}
		$provideSignatureHelp(e, t, n, r, i) {
			return this._withAdapter(e, Rh, (s) => s.provideSignatureHelp(b.revive(t), n, r, i), void 0, i)
		}
		$releaseSignatureHelp(e, t) {
			this._withAdapter(e, Rh, (n) => n.releaseSignatureHelp(t), void 0, void 0)
		}
		registerInlayHintsProvider(e, t, n) {
			let r = typeof n.onDidChangeInlayHints == "function" ? this._nextHandle() : void 0,
				i = this._addNewAdapter(new Cm(this._documents, this._commands.converter, n, this._logService, e), e)
			this._proxy.$registerInlayHintsProvider(
				i,
				this._transformDocumentSelector(t, e),
				typeof n.resolveInlayHint == "function",
				r,
				o._extLabel(e),
			)
			let s = this._createDisposable(i)
			if (r !== void 0) {
				let a = n.onDidChangeInlayHints((l) => this._proxy.$emitInlayHintsEvent(r))
				s = ye.from(s, a)
			}
			return s
		}
		$provideInlayHints(e, t, n, r) {
			return this._withAdapter(e, Cm, (i) => i.provideInlayHints(b.revive(t), n, r), void 0, r)
		}
		$resolveInlayHint(e, t, n) {
			return this._withAdapter(e, Cm, (r) => r.resolveInlayHint(t, n), void 0, n)
		}
		$releaseInlayHints(e, t) {
			this._withAdapter(e, Cm, (n) => n.releaseHints(t), void 0, void 0)
		}
		registerDocumentLinkProvider(e, t, n) {
			let r = this._addNewAdapter(new Sm(this._documents, n), e)
			return (
				this._proxy.$registerDocumentLinkProvider(
					r,
					this._transformDocumentSelector(t, e),
					typeof n.resolveDocumentLink == "function",
				),
				this._createDisposable(r)
			)
		}
		$provideDocumentLinks(e, t, n) {
			return this._withAdapter(e, Sm, (r) => r.provideLinks(b.revive(t), n), void 0, n, t.scheme === "output")
		}
		$resolveDocumentLink(e, t, n) {
			return this._withAdapter(e, Sm, (r) => r.resolveLink(t, n), void 0, void 0, !0)
		}
		$releaseDocumentLinks(e, t) {
			this._withAdapter(e, Sm, (n) => n.releaseLinks(t), void 0, void 0, !0)
		}
		registerColorProvider(e, t, n) {
			let r = this._addNewAdapter(new Ah(this._documents, n), e)
			return (
				this._proxy.$registerDocumentColorProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideDocumentColors(e, t, n) {
			return this._withAdapter(e, Ah, (r) => r.provideColors(b.revive(t), n), [], n)
		}
		$provideColorPresentations(e, t, n, r) {
			return this._withAdapter(e, Ah, (i) => i.provideColorPresentations(b.revive(t), n, r), void 0, r)
		}
		registerFoldingRangeProvider(e, t, n) {
			let r = this._nextHandle(),
				i = typeof n.onDidChangeFoldingRanges == "function" ? this._nextHandle() : void 0
			this._adapter.set(r, new Xd(new _S(this._documents, n), e)),
				this._proxy.$registerFoldingRangeProvider(r, this._transformDocumentSelector(t, e), e.identifier, i)
			let s = this._createDisposable(r)
			if (i !== void 0) {
				let a = n.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(i))
				s = ye.from(s, a)
			}
			return s
		}
		$provideFoldingRanges(e, t, n, r) {
			return this._withAdapter(e, _S, (i) => i.provideFoldingRanges(b.revive(t), n, r), void 0, r)
		}
		registerSelectionRangeProvider(e, t, n) {
			let r = this._addNewAdapter(new DS(this._documents, n, this._logService), e)
			return (
				this._proxy.$registerSelectionRangeProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$provideSelectionRanges(e, t, n, r) {
			return this._withAdapter(e, DS, (i) => i.provideSelectionRanges(b.revive(t), n, r), [], r)
		}
		registerCallHierarchyProvider(e, t, n) {
			let r = this._addNewAdapter(new Qd(this._documents, n), e)
			return (
				this._proxy.$registerCallHierarchyProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$prepareCallHierarchy(e, t, n, r) {
			return this._withAdapter(e, Qd, (i) => Promise.resolve(i.prepareSession(b.revive(t), n, r)), void 0, r)
		}
		$provideCallHierarchyIncomingCalls(e, t, n, r) {
			return this._withAdapter(e, Qd, (i) => i.provideCallsTo(t, n, r), void 0, r)
		}
		$provideCallHierarchyOutgoingCalls(e, t, n, r) {
			return this._withAdapter(e, Qd, (i) => i.provideCallsFrom(t, n, r), void 0, r)
		}
		$releaseCallHierarchy(e, t) {
			this._withAdapter(e, Qd, (n) => Promise.resolve(n.releaseSession(t)), void 0, void 0)
		}
		registerTypeHierarchyProvider(e, t, n) {
			let r = this._addNewAdapter(new Jd(this._documents, n), e)
			return (
				this._proxy.$registerTypeHierarchyProvider(r, this._transformDocumentSelector(t, e)),
				this._createDisposable(r)
			)
		}
		$prepareTypeHierarchy(e, t, n, r) {
			return this._withAdapter(e, Jd, (i) => Promise.resolve(i.prepareSession(b.revive(t), n, r)), void 0, r)
		}
		$provideTypeHierarchySupertypes(e, t, n, r) {
			return this._withAdapter(e, Jd, (i) => i.provideSupertypes(t, n, r), void 0, r)
		}
		$provideTypeHierarchySubtypes(e, t, n, r) {
			return this._withAdapter(e, Jd, (i) => i.provideSubtypes(t, n, r), void 0, r)
		}
		$releaseTypeHierarchy(e, t) {
			this._withAdapter(e, Jd, (n) => Promise.resolve(n.releaseSession(t)), void 0, void 0)
		}
		registerDocumentOnDropEditProvider(e, t, n, r) {
			let i = this._nextHandle()
			return (
				this._adapter.set(i, new Xd(new Tm(this._proxy, this._documents, n, i, e), e)),
				this._proxy.$registerDocumentOnDropEditProvider(
					i,
					this._transformDocumentSelector(t, e),
					r
						? {
								supportsResolve: !!n.resolveDocumentDropEdit,
								dropMimeTypes: r.dropMimeTypes,
								providedDropKinds: r.providedDropEditKinds?.map((s) => s.value),
							}
						: void 0,
				),
				this._createDisposable(i)
			)
		}
		$provideDocumentOnDropEdits(e, t, n, r, i, s) {
			return this._withAdapter(
				e,
				Tm,
				(a) => Promise.resolve(a.provideDocumentOnDropEdits(t, b.revive(n), r, i, s)),
				void 0,
				void 0,
			)
		}
		$resolveDropEdit(e, t, n) {
			return this._withAdapter(e, Tm, (r) => r.resolveDropEdit(t, n), {}, void 0)
		}
		$releaseDocumentOnDropEdits(e, t) {
			this._withAdapter(e, Tm, (n) => Promise.resolve(n.releaseDropEdits(t)), void 0, void 0)
		}
		registerDocumentPasteEditProvider(e, t, n, r) {
			let i = this._nextHandle()
			return (
				this._adapter.set(i, new Xd(new jd(this._proxy, this._documents, n, i, e), e)),
				this._proxy.$registerPasteEditProvider(i, this._transformDocumentSelector(t, e), {
					supportsCopy: !!n.prepareDocumentPaste,
					supportsPaste: !!n.provideDocumentPasteEdits,
					supportsResolve: !!n.resolveDocumentPasteEdit,
					providedPasteEditKinds: r.providedPasteEditKinds?.map((s) => s.value),
					copyMimeTypes: r.copyMimeTypes,
					pasteMimeTypes: r.pasteMimeTypes,
				}),
				this._createDisposable(i)
			)
		}
		$prepareDocumentPaste(e, t, n, r, i) {
			return this._withAdapter(e, jd, (s) => s.prepareDocumentPaste(b.revive(t), n, r, i), void 0, i)
		}
		$providePasteEdits(e, t, n, r, i, s, a) {
			return this._withAdapter(e, jd, (l) => l.providePasteEdits(t, b.revive(n), r, i, s, a), void 0, a)
		}
		$resolvePasteEdit(e, t, n) {
			return this._withAdapter(e, jd, (r) => r.resolvePasteEdit(t, n), {}, void 0)
		}
		$releasePasteEdits(e, t) {
			this._withAdapter(e, jd, (n) => Promise.resolve(n.releasePasteEdits(t)), void 0, void 0)
		}
		static _serializeRegExp(e) {
			return { pattern: e.source, flags: e.flags }
		}
		static _serializeIndentationRule(e) {
			return {
				decreaseIndentPattern: o._serializeRegExp(e.decreaseIndentPattern),
				increaseIndentPattern: o._serializeRegExp(e.increaseIndentPattern),
				indentNextLinePattern: e.indentNextLinePattern ? o._serializeRegExp(e.indentNextLinePattern) : void 0,
				unIndentedLinePattern: e.unIndentedLinePattern ? o._serializeRegExp(e.unIndentedLinePattern) : void 0,
			}
		}
		static _serializeOnEnterRule(e) {
			return {
				beforeText: o._serializeRegExp(e.beforeText),
				afterText: e.afterText ? o._serializeRegExp(e.afterText) : void 0,
				previousLineText: e.previousLineText ? o._serializeRegExp(e.previousLineText) : void 0,
				action: e.action,
			}
		}
		static _serializeOnEnterRules(e) {
			return e.map(o._serializeOnEnterRule)
		}
		static _serializeAutoClosingPair(e) {
			return { open: e.open, close: e.close, notIn: e.notIn ? e.notIn.map((t) => Ed.toString(t)) : void 0 }
		}
		static _serializeAutoClosingPairs(e) {
			return e.map(o._serializeAutoClosingPair)
		}
		setLanguageConfiguration(e, t, n) {
			let { wordPattern: r } = n
			if (r && Fv(r))
				throw new Error(
					`Invalid language configuration: wordPattern '${r}' is not allowed to match the empty string.`,
				)
			r ? this._documents.setWordDefinitionFor(t, r) : this._documents.setWordDefinitionFor(t, void 0),
				n.__electricCharacterSupport &&
					this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", e, "Do not use."),
				n.__characterPairSupport &&
					this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", e, "Do not use.")
			let i = this._nextHandle(),
				s = {
					comments: n.comments,
					brackets: n.brackets,
					wordPattern: n.wordPattern ? o._serializeRegExp(n.wordPattern) : void 0,
					indentationRules: n.indentationRules ? o._serializeIndentationRule(n.indentationRules) : void 0,
					onEnterRules: n.onEnterRules ? o._serializeOnEnterRules(n.onEnterRules) : void 0,
					__electricCharacterSupport: n.__electricCharacterSupport,
					__characterPairSupport: n.__characterPairSupport,
					autoClosingPairs: n.autoClosingPairs ? o._serializeAutoClosingPairs(n.autoClosingPairs) : void 0,
				}
			return this._proxy.$setLanguageConfiguration(i, t, s), this._createDisposable(i)
		}
		$setWordDefinitions(e) {
			for (let t of e) this._documents.setWordDefinitionFor(t.languageId, new RegExp(t.regexSource, t.regexFlags))
		}
	}
var _B
;((e) => {
	function o(t) {
		switch (t.type) {
			case "extension":
				return `extension:${t.extensionId.value}`
			case "mcp":
				return `mcp:${t.collectionId}:${t.definitionId}`
			case "internal":
				return "internal"
		}
	}
	e.toKey = o
})((_B ||= {}))
function qN(o) {
	return typeof o == "object" && typeof o.sessionId == "string"
}
var KN = O("ILanguageModelToolsService")
var jN = O("notebookService")
var GN = O("codeMapperService")
var QN = O("languageModelIgnoredFilesService")
var JN = `
The user is very smart and can understand how to apply your edits to their files, you just need to provide minimal hints.
Avoid repeating existing code, instead use comments to represent regions of unchanged code. The user prefers that you are as concise as possible. For example:
// ...existing code...
{ changed code }
// ...existing code...
{ changed code }
// ...existing code...

Here is an example of how you should use format an edit to an existing Person class:
class Person {
	// ...existing code...
	age: number;
	// ...existing code...
	getAge() {
		return this.age;
	}
}
`,
	C1 = "vscode_editFile",
	OS = "vscode_editFile_internal",
	Oh = {
		id: OS,
		displayName: p("chat.tools.editFile", "Edit File"),
		modelDescription: `Edit a file in the workspace. Use this tool once per file that needs to be modified, even if there are multiple changes for a file. Generate the "explanation" property first. ${JN}`,
		source: { type: "internal" },
		inputSchema: {
			type: "object",
			properties: {
				explanation: {
					type: "string",
					description:
						"A short explanation of the edit being made. Can be the same as the explanation you showed to the user.",
				},
				filePath: {
					type: "string",
					description:
						"An absolute path to the file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.",
				},
				code: { type: "string", description: "The code change to apply to the file. " + JN },
			},
			required: ["explanation", "filePath", "code"],
		},
	},
	Em = class {
		constructor(e, t, n, r, i, s, a) {
			this.chatService = e
			this.codeMapperService = t
			this.workspaceContextService = n
			this.ignoredFilesService = r
			this.textFileService = i
			this.notebookService = s
			this.editorGroupsService = a
		}
		async invoke(e, t, n) {
			if (!e.context) throw new Error("toolInvocationToken is required for this tool")
			let r = e.parameters,
				i = b.revive(r.file),
				s = ng.parse(i)?.notebook || i
			if (
				!this.workspaceContextService.isInsideWorkspace(s) &&
				!this.notebookService.getNotebookTextModel(s) &&
				!this.editorGroupsService.getGroups(1).some((h) => h.editors.some((g) => jr(g.resource, s)))
			)
				throw new Error(`File ${s.fsPath} can't be edited because it's not inside the current workspace`)
			if (await this.ignoredFilesService.fileIsIgnored(s, n))
				throw new Error(`File ${s.fsPath} can't be edited because it is configured to be ignored by Copilot`)
			let a = this.chatService.getSession(e.context?.sessionId),
				l = a.getRequests().at(-1)
			l.response?.response.getMarkdown().length && a.acceptResponseProgress(l, { kind: "undoStop", id: He() }),
				a.acceptResponseProgress(l, { kind: "markdownContent", content: new $o("\n````\n") }),
				a.acceptResponseProgress(l, { kind: "codeblockUri", uri: s, isEdit: !0 }),
				a.acceptResponseProgress(l, { kind: "markdownContent", content: new $o(r.code + "\n````\n") }),
				this.notebookService.hasSupportedNotebooks(s) && this.notebookService.getNotebookTextModel(s)
					? a.acceptResponseProgress(l, { kind: "notebookEdit", edits: [], uri: s })
					: a.acceptResponseProgress(l, { kind: "textEdit", edits: [], uri: s })
			let d = a.editingSession
			if (!d) throw new Error("This tool must be called from within an editing session")
			let c = await this.codeMapperService.mapCode(
				{
					codeBlocks: [{ code: r.code, resource: s, markdownBeforeBlock: r.explanation }],
					location: "tool",
					chatRequestId: e.chatRequestId,
				},
				{
					textEdit: (m, f) => {
						a.acceptResponseProgress(l, { kind: "textEdit", uri: m, edits: f })
					},
					notebookEdit(m, f) {
						a.acceptResponseProgress(l, { kind: "notebookEdit", uri: m, edits: f })
					},
				},
				n,
			)
			if (
				(this.notebookService.hasSupportedNotebooks(s) && this.notebookService.getNotebookTextModel(s)
					? a.acceptResponseProgress(l, { kind: "notebookEdit", uri: s, edits: [], done: !0 })
					: a.acceptResponseProgress(l, { kind: "textEdit", uri: s, edits: [], done: !0 }),
				c?.errorMessage)
			)
				throw new Error(c.errorMessage)
			let u
			return (
				await new Promise((m) => {
					let f = !1
					u = id((h) => {
						let I = d.entries.read(h)?.find((C) => C.modifiedURI.toString() === s.toString())
						I && (I.isCurrentlyBeingModifiedBy.read(h) ? (f = !0) : f && m(!0))
					})
				}).finally(() => {
					u.dispose()
				}),
				await this.textFileService.save(s, { reason: 2, skipSaveParticipants: !0 }),
				{ content: [{ kind: "text", value: "The file was edited successfully" }] }
			)
		}
		async prepareToolInvocation(e, t) {
			return { presentation: "hidden" }
		}
	}
Em = R([S(0, uF), S(1, GN), S(2, gi), S(3, QN), S(4, ZF), S(5, jN), S(6, $y)], Em)
var AS = class {
	processInput(e) {
		if (!e.filePath) return e
		let t = e.filePath
		return { file: t.startsWith("untitled:") ? b.parse(t) : b.file(t), explanation: e.explanation, code: e.code }
	}
}
var LS = class extends $ {
	static {
		this.ID = "chat.builtinTools"
	}
	constructor(e, t) {
		super()
		let n = t.createInstance(Em)
		this._register(e.registerToolData(Oh)), this._register(e.registerToolImplementation(Oh.id, n))
	}
}
LS = R([S(0, KN), S(1, Wo)], LS)
var XN = "vscode_fetchWebPage_internal"
var MS = class {
	constructor(e, t) {
		this._languageModels = t
		this._registeredTools = new Map()
		this._tokenCountFuncs = new Map()
		this._allTools = new Map()
		this._toolInputProcessors = new Map()
		;(this._proxy = e.getProxy(M.MainThreadLanguageModelTools)),
			this._proxy.$getTools().then((n) => {
				for (let r of n) this._allTools.set(r.id, ut(r))
			}),
			this._toolInputProcessors.set(Oh.id, new AS())
	}
	async $countTokensForInvocation(e, t, n) {
		let r = this._tokenCountFuncs.get(e)
		if (!r) throw new Error(`Tool invocation call ${e} not found`)
		return await r(t, n)
	}
	async invokeTool(e, t, n, r) {
		let i = He()
		n.tokenizationOptions && this._tokenCountFuncs.set(i, n.tokenizationOptions.countTokens)
		try {
			if (n.toolInvocationToken && !qN(n.toolInvocationToken)) throw new Error("Invalid tool invocation token")
			if ((t === OS || t === C1) && !nt(e, "chatParticipantPrivate")) throw new Error(`Invalid tool: ${t}`)
			let s = this._toolInputProcessors.get(t)?.processInput(n.input) ?? n.input,
				a = await this._proxy.$invokeTool(
					{
						toolId: t,
						callId: i,
						parameters: s,
						tokenBudget: n.tokenizationOptions?.tokenBudget,
						context: n.toolInvocationToken,
						chatRequestId: nt(e, "chatParticipantPrivate") ? n.chatRequestId : void 0,
						chatInteractionId: nt(e, "chatParticipantPrivate") ? n.chatInteractionId : void 0,
					},
					r,
				)
			return Dx.to(ut(a))
		} finally {
			this._tokenCountFuncs.delete(i)
		}
	}
	$onDidChangeTools(e) {
		this._allTools.clear()
		for (let t of e) this._allTools.set(t.id, t)
	}
	getTools(e) {
		return Array.from(this._allTools.values())
			.map((t) => pk.to(t))
			.filter((t) => {
				switch (t.name) {
					case OS:
					case C1:
					case XN:
						return nt(e, "chatParticipantPrivate")
					default:
						return !0
				}
			})
	}
	async $invokeTool(e, t) {
		let n = this._registeredTools.get(e.toolId)
		if (!n) throw new Error(`Unknown tool ${e.toolId}`)
		let r = { input: e.parameters, toolInvocationToken: e.context }
		nt(n.extension, "chatParticipantPrivate") &&
			((r.chatRequestId = e.chatRequestId),
			(r.chatInteractionId = e.chatInteractionId),
			(r.chatSessionId = e.context?.sessionId),
			e.toolSpecificData?.kind === "terminal" && (r.terminalCommand = e.toolSpecificData.command)),
			nt(n.extension, "chatParticipantAdditions") &&
				e.modelId &&
				(r.model = await this.getModel(e.modelId, n.extension)),
			e.tokenBudget !== void 0 &&
				(r.tokenizationOptions = {
					tokenBudget: e.tokenBudget,
					countTokens:
						this._tokenCountFuncs.get(e.callId) ||
						((s, a = De.None) => this._proxy.$countTokensForInvocation(e.callId, s, a)),
				})
		let i = await Zv(Promise.resolve(n.tool.invoke(r, t)), t)
		if (!i) throw new xt()
		return Dx.from(i, n.extension)
	}
	async getModel(e, t) {
		let n
		if (
			(e && (n = await this._languageModels.getLanguageModelByIdentifier(t, e)),
			!n && ((n = await this._languageModels.getDefaultLanguageModel(t)), !n))
		)
			throw new Error("Language model unavailable")
		return n
	}
	async $prepareToolInvocation(e, t, n) {
		let r = this._registeredTools.get(e)
		if (!r) throw new Error(`Unknown tool ${e}`)
		let i = { input: t }
		if (nt(r.extension, "chatParticipantPrivate") && r.tool.prepareInvocation2) {
			let s = await r.tool.prepareInvocation2(i, n)
			return s
				? {
						confirmationMessages: s.confirmationMessages
							? {
									title: s.confirmationMessages.title,
									message:
										typeof s.confirmationMessages.message == "string"
											? s.confirmationMessages.message
											: Se.from(s.confirmationMessages.message),
								}
							: void 0,
						toolSpecificData: { kind: "terminal", language: s.language, command: s.command },
					}
				: void 0
		} else if (r.tool.prepareInvocation) {
			let s = await r.tool.prepareInvocation(i, n)
			return s
				? ((s.pastTenseMessage || s.presentation) && F(r.extension, "chatParticipantPrivate"),
					{
						confirmationMessages: s.confirmationMessages
							? {
									title: s.confirmationMessages.title,
									message:
										typeof s.confirmationMessages.message == "string"
											? s.confirmationMessages.message
											: Se.from(s.confirmationMessages.message),
								}
							: void 0,
						invocationMessage: Se.fromStrict(s.invocationMessage),
						pastTenseMessage: Se.fromStrict(s.pastTenseMessage),
						presentation: s.presentation,
					})
				: void 0
		}
	}
	registerTool(e, t, n) {
		return (
			this._registeredTools.set(t, { extension: e, tool: n }),
			this._proxy.$registerTool(t),
			q(() => {
				this._registeredTools.delete(t), this._proxy.$unregisterTool(t)
			})
		)
	}
}
var FS = class {
	constructor(e, t, n, r) {
		this._documents = t
		this._commands = n
		this._uriTransformer = r
		this._languageIds = []
		this._handlePool = 0
		this._ids = new Set()
		this._proxy = e.getProxy(M.MainThreadLanguages)
	}
	$acceptLanguageIds(e) {
		this._languageIds = e
	}
	async getLanguages() {
		return this._languageIds.slice(0)
	}
	async changeLanguage(e, t) {
		await this._proxy.$changeLanguage(e, t)
		let n = this._documents.getDocumentData(e)
		if (!n) throw new Error(`document '${e.toString()}' NOT found`)
		return n.document
	}
	async tokenAtPosition(e, t) {
		let n = e.version,
			r = Je.from(t),
			i = await this._proxy.$tokensAtPosition(e.uri, r),
			s = { type: 0, range: e.getWordRangeAtPosition(t) ?? new pe(t.line, t.character, t.line, t.character) }
		if (!i) return s
		let a = { range: H.to(i.range), type: UD.to(i.type) }
		return !a.range.contains(t) || n !== e.version ? s : a
	}
	createLanguageStatusItem(e, t, n) {
		let r = this._handlePool++,
			i = this._proxy,
			s = this._ids,
			a = `${e.identifier.value}/${t}`
		if (s.has(a)) throw new Error(`LanguageStatusItem with id '${t}' ALREADY exists`)
		s.add(a)
		let l = {
				selector: n,
				id: t,
				name: e.displayName ?? e.name,
				severity: 0,
				command: void 0,
				text: "",
				detail: "",
				busy: !1,
			},
			d,
			c = new Q(),
			u = () => {
				if ((d?.dispose(), !s.has(a))) {
					console.warn(
						`LanguageStatusItem (${t}) from ${e.identifier.value} has been disposed and CANNOT be updated anymore`,
					)
					return
				}
				d = Ef(() => {
					c.clear(),
						this._proxy.$setLanguageStatus(r, {
							id: a,
							name: l.name ?? e.displayName ?? e.name,
							source: e.displayName ?? e.name,
							selector: Hs.from(l.selector, this._uriTransformer),
							label: l.text,
							detail: l.detail ?? "",
							severity: l.severity === 2 ? It.Error : l.severity === 1 ? It.Warning : It.Info,
							command: l.command && this._commands.toInternal(l.command, c),
							accessibilityInfo: l.accessibilityInformation,
							busy: l.busy,
						})
				}, 0)
			},
			m = {
				dispose() {
					c.dispose(), d?.dispose(), i.$removeLanguageStatus(r), s.delete(a)
				},
				get id() {
					return l.id
				},
				get name() {
					return l.name
				},
				set name(f) {
					;(l.name = f), u()
				},
				get selector() {
					return l.selector
				},
				set selector(f) {
					;(l.selector = f), u()
				},
				get text() {
					return l.text
				},
				set text(f) {
					;(l.text = f), u()
				},
				set text2(f) {
					F(e, "languageStatusText"), (l.text = f), u()
				},
				get text2() {
					return F(e, "languageStatusText"), l.text
				},
				get detail() {
					return l.detail
				},
				set detail(f) {
					;(l.detail = f), u()
				},
				get severity() {
					return l.severity
				},
				set severity(f) {
					;(l.severity = f), u()
				},
				get accessibilityInformation() {
					return l.accessibilityInformation
				},
				set accessibilityInformation(f) {
					;(l.accessibilityInformation = f), u()
				},
				get command() {
					return l.command
				},
				set command(f) {
					;(l.command = f), u()
				},
				get busy() {
					return l.busy
				},
				set busy(f) {
					;(l.busy = f), u()
				},
			}
		return u(), m
	}
}
function DB(o) {
	return o && o.title
}
var wm = class {
	constructor(e, t) {
		this._logService = t
		this._proxy = e.getProxy(M.MainThreadMessageService)
	}
	showMessage(e, t, n, r, i) {
		let s = { source: { identifier: e.identifier, label: e.displayName || e.name } },
			a
		typeof r == "string" || DB(r)
			? (a = [r, ...i])
			: ((s.modal = r?.modal), (s.useCustom = r?.useCustom), (s.detail = r?.detail), (a = i)),
			s.useCustom && F(e, "resolvers")
		let l = [],
			d = !1
		for (let c = 0; c < a.length; c++) {
			let u = a[c]
			if (typeof u == "string") l.push({ title: u, handle: c, isCloseAffordance: !1 })
			else if (typeof u == "object") {
				let { title: m, isCloseAffordance: f } = u
				l.push({ title: m, isCloseAffordance: !!f, handle: c }),
					f &&
						(d
							? this._logService.warn(
									`[${e.identifier}] Only one message item can have 'isCloseAffordance':`,
									u,
								)
							: (d = !0))
			} else this._logService.warn(`[${e.identifier}] Invalid message item:`, u)
		}
		return this._proxy.$showMessage(t, n, s, l).then((c) => {
			if (typeof c == "number") return a[c]
		})
	}
}
wm = R([S(1, te)], wm)
var Lh = class {
		constructor(e, t, n, r) {
			this.start = e
			this.deletedCount = t
			this.deletedItems = n
			this.items = r
		}
		asApiEvent() {
			return {
				range: new cr(this.start, this.start + this.deletedCount),
				addedCells: this.items.map((e) => e.apiCell),
				removedCells: this.deletedItems,
			}
		}
	},
	Pm = class {
		constructor(e, t, n) {
			this.notebook = e
			this._extHostDocument = t
			this._cellData = n
			;(this.handle = n.handle),
				(this.uri = b.revive(n.uri)),
				(this.cellKind = n.cellKind),
				(this._outputs = n.outputs.map(Us.to)),
				(this._internalMetadata = n.internalMetadata ?? {}),
				(this._metadata = Object.freeze(n.metadata ?? {})),
				(this._previousResult = Object.freeze(Ju.to(n.internalMetadata ?? {})))
		}
		static asModelAddData(e) {
			return {
				EOL: e.eol,
				lines: e.source,
				languageId: e.language,
				uri: e.uri,
				isDirty: !1,
				versionId: 1,
				encoding: "utf8",
			}
		}
		get internalMetadata() {
			return this._internalMetadata
		}
		get apiCell() {
			if (!this._apiCell) {
				let e = this,
					t = this._extHostDocument.getDocument(this.uri)
				if (!t) throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`)
				let n = {
					get index() {
						return e.notebook.getCellIndex(e)
					},
					notebook: e.notebook.apiNotebook,
					kind: bg.to(this._cellData.cellKind),
					document: t.document,
					get mime() {
						return e._mime
					},
					set mime(r) {
						e._mime = r
					},
					get outputs() {
						return e._outputs.slice(0)
					},
					get metadata() {
						return e._metadata
					},
					get executionSummary() {
						return e._previousResult
					},
				}
				this._apiCell = Object.freeze(n)
			}
			return this._apiCell
		}
		setOutputs(e) {
			this._outputs = e.map(Us.to)
		}
		setOutputItems(e, t, n) {
			let r = n.map(Dd.to),
				i = this._outputs.find((s) => s.id === e)
			if (
				i &&
				(t || (i.items.length = 0), i.items.push(...r), i.items.length > 1 && i.items.every((s) => iy(s.mime)))
			) {
				let s = new Map(),
					a = []
				i.items.forEach((l) => {
					let d
					s.has(l.mime) ? (d = s.get(l.mime)) : ((d = []), s.set(l.mime, d), a.push(l.mime)), d.push(l.data)
				}),
					(i.items.length = 0),
					a.forEach((l) => {
						let d = FM(s.get(l))
						i.items.push({ mime: l, data: d.data.buffer })
					})
			}
		}
		setMetadata(e) {
			this._metadata = Object.freeze(e)
		}
		setInternalMetadata(e) {
			;(this._internalMetadata = e), (this._previousResult = Object.freeze(Ju.to(e)))
		}
		setMime(e) {}
	},
	NS = class o {
		constructor(e, t, n, r, i) {
			this._proxy = e
			this._textDocumentsAndEditors = t
			this._textDocuments = n
			this.uri = r
			this.handle = o._handlePool++
			this._cells = []
			this._versionId = 0
			this._isDirty = !1
			this._disposed = !1
			;(this._notebookType = i.viewType),
				(this._metadata = Object.freeze(i.metadata ?? Object.create(null))),
				this._spliceNotebookCells([[0, 0, i.cells]], !0, void 0),
				(this._versionId = i.versionId)
		}
		static {
			this._handlePool = 0
		}
		dispose() {
			this._disposed = !0
		}
		get versionId() {
			return this._versionId
		}
		get apiNotebook() {
			if (!this._notebook) {
				let e = this,
					t = {
						get uri() {
							return e.uri
						},
						get version() {
							return e._versionId
						},
						get notebookType() {
							return e._notebookType
						},
						get isDirty() {
							return e._isDirty
						},
						get isUntitled() {
							return e.uri.scheme === W.untitled
						},
						get isClosed() {
							return e._disposed
						},
						get metadata() {
							return e._metadata
						},
						get cellCount() {
							return e._cells.length
						},
						cellAt(n) {
							return (n = e._validateIndex(n)), e._cells[n].apiCell
						},
						getCells(n) {
							return (n ? e._getCells(n) : e._cells).map((i) => i.apiCell)
						},
						save() {
							return e._save()
						},
						[Symbol.for("debug.description")]() {
							return `NotebookDocument(${this.uri.toString()})`
						},
					}
				this._notebook = Object.freeze(t)
			}
			return this._notebook
		}
		acceptDocumentPropertiesChanged(e) {
			e.metadata && (this._metadata = Object.freeze({ ...this._metadata, ...e.metadata }))
		}
		acceptDirty(e) {
			this._isDirty = e
		}
		acceptModelChanged(e, t, n) {
			;(this._versionId = e.versionId), (this._isDirty = t), this.acceptDocumentPropertiesChanged({ metadata: n })
			let r = { notebook: this.apiNotebook, metadata: n, cellChanges: [], contentChanges: [] },
				i = []
			for (let a of e.rawEvents)
				a.kind === 1
					? this._spliceNotebookCells(a.changes, !1, r.contentChanges)
					: a.kind === 2
						? this._moveCells(a.index, a.length, a.newIdx, r.contentChanges)
						: a.kind === 8
							? (this._setCellOutputs(a.index, a.outputs),
								i.push({
									cell: this._cells[a.index].apiCell,
									outputs: this._cells[a.index].apiCell.outputs,
								}))
							: a.kind === 9
								? (this._setCellOutputItems(a.index, a.outputId, a.append, a.outputItems),
									i.push({
										cell: this._cells[a.index].apiCell,
										outputs: this._cells[a.index].apiCell.outputs,
									}))
								: a.kind === 5
									? (this._changeCellLanguage(a.index, a.language),
										i.push({
											cell: this._cells[a.index].apiCell,
											document: this._cells[a.index].apiCell.document,
										}))
									: a.kind === 10
										? i.push({
												cell: this._cells[a.index].apiCell,
												document: this._cells[a.index].apiCell.document,
											})
										: a.kind === 13
											? this._changeCellMime(a.index, a.mime)
											: a.kind === 7
												? (this._changeCellMetadata(a.index, a.metadata),
													i.push({
														cell: this._cells[a.index].apiCell,
														metadata: this._cells[a.index].apiCell.metadata,
													}))
												: a.kind === 12 &&
													(this._changeCellInternalMetadata(a.index, a.internalMetadata),
													i.push({
														cell: this._cells[a.index].apiCell,
														executionSummary: this._cells[a.index].apiCell.executionSummary,
													}))
			let s = new Map()
			for (let a = 0; a < i.length; a++) {
				let l = i[a],
					d = s.get(l.cell)
				if (d === void 0) {
					let c = r.cellChanges.push({
						document: void 0,
						executionSummary: void 0,
						metadata: void 0,
						outputs: void 0,
						...l,
					})
					s.set(l.cell, c - 1)
				} else r.cellChanges[d] = { ...r.cellChanges[d], ...l }
			}
			return Object.freeze(r), Object.freeze(r.cellChanges), Object.freeze(r.contentChanges), r
		}
		_validateIndex(e) {
			return (e = e | 0), e < 0 ? 0 : e >= this._cells.length ? this._cells.length - 1 : e
		}
		_validateRange(e) {
			let t = e.start | 0,
				n = e.end | 0
			return t < 0 && (t = 0), n > this._cells.length && (n = this._cells.length), e.with({ start: t, end: n })
		}
		_getCells(e) {
			e = this._validateRange(e)
			let t = []
			for (let n = e.start; n < e.end; n++) t.push(this._cells[n])
			return t
		}
		async _save() {
			return this._disposed
				? Promise.reject(new Error("Notebook has been closed"))
				: this._proxy.$trySaveNotebook(this.uri)
		}
		_spliceNotebookCells(e, t, n) {
			if (this._disposed) return
			let r = [],
				i = [],
				s = []
			if (
				(e.reverse().forEach((a) => {
					let d = a[2].map((m) => {
							let f = new Pm(this, this._textDocumentsAndEditors, m)
							return t || i.push(Pm.asModelAddData(m)), f
						}),
						c = new Lh(a[0], a[1], [], d),
						u = this._cells.splice(a[0], a[1], ...d)
					for (let m of u) s.push(m.uri), c.deletedItems.push(m.apiCell)
					r.push(c)
				}),
				this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
					addedDocuments: i,
					removedDocuments: s,
				}),
				n)
			)
				for (let a of r) n.push(a.asApiEvent())
		}
		_moveCells(e, t, n, r) {
			let i = this._cells.splice(e, t)
			this._cells.splice(n, 0, ...i)
			let s = [
				new Lh(
					e,
					t,
					i.map((a) => a.apiCell),
					[],
				),
				new Lh(n, 0, [], i),
			]
			for (let a of s) r.push(a.asApiEvent())
		}
		_setCellOutputs(e, t) {
			this._cells[e].setOutputs(t)
		}
		_setCellOutputItems(e, t, n, r) {
			this._cells[e].setOutputItems(t, n, r)
		}
		_changeCellLanguage(e, t) {
			let n = this._cells[e]
			n.apiCell.document.languageId !== t && this._textDocuments.$acceptModelLanguageChanged(n.uri, t)
		}
		_changeCellMime(e, t) {
			let n = this._cells[e]
			n.apiCell.mime = t
		}
		_changeCellMetadata(e, t) {
			this._cells[e].setMetadata(t)
		}
		_changeCellInternalMetadata(e, t) {
			this._cells[e].setInternalMetadata(t)
		}
		getCellFromApiCell(e) {
			return this._cells.find((t) => t.apiCell === e)
		}
		getCellFromIndex(e) {
			return this._cells[e]
		}
		getCell(e) {
			return this._cells.find((t) => t.handle === e)
		}
		getCellIndex(e) {
			return this._cells.indexOf(e)
		}
	}
var Yd = class o {
	constructor(e, t, n, r, i, s, a) {
		this.id = e
		this._proxy = t
		this.notebookData = n
		this._visibleRanges = r
		this._selections = i
		this._viewColumn = s
		this.viewType = a
		this._visible = !1
	}
	static {
		this.apiEditorsToExtHost = new WeakMap()
	}
	get apiEditor() {
		if (!this._editor) {
			let e = this
			;(this._editor = {
				get notebook() {
					return e.notebookData.apiNotebook
				},
				get selection() {
					return e._selections[0]
				},
				set selection(t) {
					this.selections = [t]
				},
				get selections() {
					return e._selections
				},
				set selections(t) {
					if (!Array.isArray(t) || !t.every(cr.isNotebookRange)) throw We("selections")
					;(e._selections = t), e._trySetSelections(t)
				},
				get visibleRanges() {
					return e._visibleRanges
				},
				revealRange(t, n) {
					e._proxy.$tryRevealRange(e.id, to.from(t), n ?? 0)
				},
				get viewColumn() {
					return e._viewColumn
				},
				get replOptions() {
					if (e.viewType === "repl") return { appendIndex: this.notebook.cellCount - 1 }
				},
				[Symbol.for("debug.description")]() {
					return `NotebookEditor(${this.notebook.uri.toString()})`
				},
			}),
				o.apiEditorsToExtHost.set(this._editor, this)
		}
		return this._editor
	}
	get visible() {
		return this._visible
	}
	_acceptVisibility(e) {
		this._visible = e
	}
	_acceptVisibleRanges(e) {
		this._visibleRanges = e
	}
	_acceptSelections(e) {
		this._selections = e
	}
	_trySetSelections(e) {
		this._proxy.$trySetSelections(this.id, e.map(to.from))
	}
	_acceptViewColumn(e) {
		this._viewColumn = e
	}
}
var _m = class {
	constructor(e, t) {
		;(this.piece = e),
			(this.color = t),
			(this.size_left = 0),
			(this.lf_left = 0),
			(this.parent = this),
			(this.left = this),
			(this.right = this)
	}
	next() {
		if (this.right !== ue) return US(this.right)
		let e = this
		for (; e.parent !== ue && e.parent.left !== e; ) e = e.parent
		return e.parent === ue ? ue : e.parent
	}
	prev() {
		if (this.left !== ue) return T1(this.left)
		let e = this
		for (; e.parent !== ue && e.parent.right !== e; ) e = e.parent
		return e.parent === ue ? ue : e.parent
	}
	detach() {
		;(this.parent = null), (this.left = null), (this.right = null)
	}
}
var ue = new _m(null, 0)
ue.parent = ue
ue.left = ue
ue.right = ue
ue.color = 0
function US(o) {
	for (; o.left !== ue; ) o = o.left
	return o
}
function T1(o) {
	for (; o.right !== ue; ) o = o.right
	return o
}
function E1(o) {
	return o === ue ? 0 : o.size_left + o.piece.length + E1(o.right)
}
function w1(o) {
	return o === ue ? 0 : o.lf_left + o.piece.lineFeedCnt + w1(o.right)
}
function S1() {
	ue.parent = ue
}
function Fh(o, e) {
	let t = e.right
	;(t.size_left += e.size_left + (e.piece ? e.piece.length : 0)),
		(t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0)),
		(e.right = t.left),
		t.left !== ue && (t.left.parent = e),
		(t.parent = e.parent),
		e.parent === ue ? (o.root = t) : e.parent.left === e ? (e.parent.left = t) : (e.parent.right = t),
		(t.left = e),
		(e.parent = t)
}
function Nh(o, e) {
	let t = e.left
	;(e.left = t.right),
		t.right !== ue && (t.right.parent = e),
		(t.parent = e.parent),
		(e.size_left -= t.size_left + (t.piece ? t.piece.length : 0)),
		(e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0)),
		e.parent === ue ? (o.root = t) : e === e.parent.right ? (e.parent.right = t) : (e.parent.left = t),
		(t.right = e),
		(e.parent = t)
}
function Uh(o, e) {
	let t, n
	if (
		(e.left === ue
			? ((n = e), (t = n.right))
			: e.right === ue
				? ((n = e), (t = n.left))
				: ((n = US(e.right)), (t = n.right)),
		n === o.root)
	) {
		;(o.root = t), (t.color = 0), e.detach(), S1(), (o.root.parent = ue)
		return
	}
	let r = n.color === 1
	if (
		(n === n.parent.left ? (n.parent.left = t) : (n.parent.right = t),
		n === e
			? ((t.parent = n.parent), Mh(o, t))
			: (n.parent === e ? (t.parent = n) : (t.parent = n.parent),
				Mh(o, t),
				(n.left = e.left),
				(n.right = e.right),
				(n.parent = e.parent),
				(n.color = e.color),
				e === o.root ? (o.root = n) : e === e.parent.left ? (e.parent.left = n) : (e.parent.right = n),
				n.left !== ue && (n.left.parent = n),
				n.right !== ue && (n.right.parent = n),
				(n.size_left = e.size_left),
				(n.lf_left = e.lf_left),
				Mh(o, n)),
		e.detach(),
		t.parent.left === t)
	) {
		let s = E1(t),
			a = w1(t)
		if (s !== t.parent.size_left || a !== t.parent.lf_left) {
			let l = s - t.parent.size_left,
				d = a - t.parent.lf_left
			;(t.parent.size_left = s), (t.parent.lf_left = a), Wi(o, t.parent, l, d)
		}
	}
	if ((Mh(o, t.parent), r)) {
		S1()
		return
	}
	let i
	for (; t !== o.root && t.color === 0; )
		t === t.parent.left
			? ((i = t.parent.right),
				i.color === 1 && ((i.color = 0), (t.parent.color = 1), Fh(o, t.parent), (i = t.parent.right)),
				i.left.color === 0 && i.right.color === 0
					? ((i.color = 1), (t = t.parent))
					: (i.right.color === 0 && ((i.left.color = 0), (i.color = 1), Nh(o, i), (i = t.parent.right)),
						(i.color = t.parent.color),
						(t.parent.color = 0),
						(i.right.color = 0),
						Fh(o, t.parent),
						(t = o.root)))
			: ((i = t.parent.left),
				i.color === 1 && ((i.color = 0), (t.parent.color = 1), Nh(o, t.parent), (i = t.parent.left)),
				i.left.color === 0 && i.right.color === 0
					? ((i.color = 1), (t = t.parent))
					: (i.left.color === 0 && ((i.right.color = 0), (i.color = 1), Fh(o, i), (i = t.parent.left)),
						(i.color = t.parent.color),
						(t.parent.color = 0),
						(i.left.color = 0),
						Nh(o, t.parent),
						(t = o.root)))
	;(t.color = 0), S1()
}
function P1(o, e) {
	for (Mh(o, e); e !== o.root && e.parent.color === 1; )
		if (e.parent === e.parent.parent.left) {
			let t = e.parent.parent.right
			t.color === 1
				? ((e.parent.color = 0), (t.color = 0), (e.parent.parent.color = 1), (e = e.parent.parent))
				: (e === e.parent.right && ((e = e.parent), Fh(o, e)),
					(e.parent.color = 0),
					(e.parent.parent.color = 1),
					Nh(o, e.parent.parent))
		} else {
			let t = e.parent.parent.left
			t.color === 1
				? ((e.parent.color = 0), (t.color = 0), (e.parent.parent.color = 1), (e = e.parent.parent))
				: (e === e.parent.left && ((e = e.parent), Nh(o, e)),
					(e.parent.color = 0),
					(e.parent.parent.color = 1),
					Fh(o, e.parent.parent))
		}
	o.root.color = 0
}
function Wi(o, e, t, n) {
	for (; e !== o.root && e !== ue; )
		e.parent.left === e && ((e.parent.size_left += t), (e.parent.lf_left += n)), (e = e.parent)
}
function Mh(o, e) {
	let t = 0,
		n = 0
	if (e !== o.root) {
		for (; e !== o.root && e === e.parent.right; ) e = e.parent
		if (e !== o.root)
			for (
				e = e.parent,
					t = E1(e.left) - e.size_left,
					n = w1(e.left) - e.lf_left,
					e.size_left += t,
					e.lf_left += n;
				e !== o.root && (t !== 0 || n !== 0);

			)
				e.parent.left === e && ((e.parent.size_left += t), (e.parent.lf_left += n)), (e = e.parent)
	}
}
var Js = 65535
function YN(o) {
	let e
	return o[o.length - 1] < 65536 ? (e = new Uint16Array(o.length)) : (e = new Uint32Array(o.length)), e.set(o, 0), e
}
var _1 = class {
	constructor(e, t, n, r, i) {
		this.lineStarts = e
		this.cr = t
		this.lf = n
		this.crlf = r
		this.isBasicASCII = i
	}
}
function Vi(o, e = !0) {
	let t = [0],
		n = 1
	for (let r = 0, i = o.length; r < i; r++) {
		let s = o.charCodeAt(r)
		s === 13
			? r + 1 < i && o.charCodeAt(r + 1) === 10
				? ((t[n++] = r + 2), r++)
				: (t[n++] = r + 1)
			: s === 10 && (t[n++] = r + 1)
	}
	return e ? YN(t) : t
}
function ZN(o, e) {
	;(o.length = 0), (o[0] = 0)
	let t = 1,
		n = 0,
		r = 0,
		i = 0,
		s = !0
	for (let l = 0, d = e.length; l < d; l++) {
		let c = e.charCodeAt(l)
		c === 13
			? l + 1 < d && e.charCodeAt(l + 1) === 10
				? (i++, (o[t++] = l + 2), l++)
				: (n++, (o[t++] = l + 1))
			: c === 10
				? (r++, (o[t++] = l + 1))
				: s && c !== 9 && (c < 32 || c > 126) && (s = !1)
	}
	let a = new _1(YN(o), n, r, i, s)
	return (o.length = 0), a
}
var nr = class {
		constructor(e, t, n, r, i) {
			;(this.bufferIndex = e), (this.start = t), (this.end = n), (this.lineFeedCnt = r), (this.length = i)
		}
	},
	Bi = class {
		constructor(e, t) {
			;(this.buffer = e), (this.lineStarts = t)
		}
	},
	D1 = class {
		constructor(e, t) {
			;(this._pieces = []),
				(this._tree = e),
				(this._BOM = t),
				(this._index = 0),
				e.root !== ue && e.iterate(e.root, (n) => (n !== ue && this._pieces.push(n.piece), !0))
		}
		read() {
			return this._pieces.length === 0
				? this._index === 0
					? (this._index++, this._BOM)
					: null
				: this._index > this._pieces.length - 1
					? null
					: this._index === 0
						? this._BOM + this._tree.getPieceContent(this._pieces[this._index++])
						: this._tree.getPieceContent(this._pieces[this._index++])
		}
	},
	k1 = class {
		constructor(e) {
			;(this._limit = e), (this._cache = [])
		}
		get(e) {
			for (let t = this._cache.length - 1; t >= 0; t--) {
				let n = this._cache[t]
				if (n.nodeStartOffset <= e && n.nodeStartOffset + n.node.piece.length >= e) return n
			}
			return null
		}
		get2(e) {
			for (let t = this._cache.length - 1; t >= 0; t--) {
				let n = this._cache[t]
				if (
					n.nodeStartLineNumber &&
					n.nodeStartLineNumber < e &&
					n.nodeStartLineNumber + n.node.piece.lineFeedCnt >= e
				)
					return n
			}
			return null
		}
		set(e) {
			this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e)
		}
		validate(e) {
			let t = !1,
				n = this._cache
			for (let r = 0; r < n.length; r++) {
				let i = n[r]
				if (i.node.parent === null || i.nodeStartOffset >= e) {
					;(n[r] = null), (t = !0)
					continue
				}
			}
			if (t) {
				let r = []
				for (let i of n) i !== null && r.push(i)
				this._cache = r
			}
		}
	},
	HS = class {
		constructor(e, t, n) {
			this.create(e, t, n)
		}
		create(e, t, n) {
			;(this._buffers = [new Bi("", [0])]),
				(this._lastChangeBufferPos = { line: 0, column: 0 }),
				(this.root = ue),
				(this._lineCnt = 1),
				(this._length = 0),
				(this._EOL = t),
				(this._EOLLength = t.length),
				(this._EOLNormalized = n)
			let r = null
			for (let i = 0, s = e.length; i < s; i++)
				if (e[i].buffer.length > 0) {
					e[i].lineStarts || (e[i].lineStarts = Vi(e[i].buffer))
					let a = new nr(
						i + 1,
						{ line: 0, column: 0 },
						{
							line: e[i].lineStarts.length - 1,
							column: e[i].buffer.length - e[i].lineStarts[e[i].lineStarts.length - 1],
						},
						e[i].lineStarts.length - 1,
						e[i].buffer.length,
					)
					this._buffers.push(e[i]), (r = this.rbInsertRight(r, a))
				}
			;(this._searchCache = new k1(1)),
				(this._lastVisitedLine = { lineNumber: 0, value: "" }),
				this.computeBufferMetadata()
		}
		normalizeEOL(e) {
			let t = Js,
				n = t - Math.floor(t / 3),
				r = n * 2,
				i = "",
				s = 0,
				a = []
			if (
				(this.iterate(this.root, (l) => {
					let d = this.getNodeContent(l),
						c = d.length
					if (s <= n || s + c < r) return (i += d), (s += c), !0
					let u = i.replace(/\r\n|\r|\n/g, e)
					return a.push(new Bi(u, Vi(u))), (i = d), (s = c), !0
				}),
				s > 0)
			) {
				let l = i.replace(/\r\n|\r|\n/g, e)
				a.push(new Bi(l, Vi(l)))
			}
			this.create(a, e, !0)
		}
		getEOL() {
			return this._EOL
		}
		setEOL(e) {
			;(this._EOL = e), (this._EOLLength = this._EOL.length), this.normalizeEOL(e)
		}
		createSnapshot(e) {
			return new D1(this, e)
		}
		equal(e) {
			if (this.getLength() !== e.getLength() || this.getLineCount() !== e.getLineCount()) return !1
			let t = 0
			return this.iterate(this.root, (r) => {
				if (r === ue) return !0
				let i = this.getNodeContent(r),
					s = i.length,
					a = e.nodeAt(t),
					l = e.nodeAt(t + s),
					d = e.getValueInRange2(a, l)
				return (t += s), i === d
			})
		}
		getOffsetAt(e, t) {
			let n = 0,
				r = this.root
			for (; r !== ue; )
				if (r.left !== ue && r.lf_left + 1 >= e) r = r.left
				else if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) {
					n += r.size_left
					let i = this.getAccumulatedValue(r, e - r.lf_left - 2)
					return (n += i + t - 1)
				} else (e -= r.lf_left + r.piece.lineFeedCnt), (n += r.size_left + r.piece.length), (r = r.right)
			return n
		}
		getPositionAt(e) {
			;(e = Math.floor(e)), (e = Math.max(0, e))
			let t = this.root,
				n = 0,
				r = e
			for (; t !== ue; )
				if (t.size_left !== 0 && t.size_left >= e) t = t.left
				else if (t.size_left + t.piece.length >= e) {
					let i = this.getIndexOf(t, e - t.size_left)
					if (((n += t.lf_left + i.index), i.index === 0)) {
						let s = this.getOffsetAt(n + 1, 1),
							a = r - s
						return new cn(n + 1, a + 1)
					}
					return new cn(n + 1, i.remainder + 1)
				} else if (
					((e -= t.size_left + t.piece.length), (n += t.lf_left + t.piece.lineFeedCnt), t.right === ue)
				) {
					let i = this.getOffsetAt(n + 1, 1),
						s = r - e - i
					return new cn(n + 1, s + 1)
				} else t = t.right
			return new cn(1, 1)
		}
		getValueInRange(e, t) {
			if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn) return ""
			let n = this.nodeAt2(e.startLineNumber, e.startColumn),
				r = this.nodeAt2(e.endLineNumber, e.endColumn),
				i = this.getValueInRange2(n, r)
			return t
				? t !== this._EOL || !this._EOLNormalized
					? i.replace(/\r\n|\r|\n/g, t)
					: t === this.getEOL() && this._EOLNormalized
						? i
						: i.replace(/\r\n|\r|\n/g, t)
				: i
		}
		getValueInRange2(e, t) {
			if (e.node === t.node) {
				let a = e.node,
					l = this._buffers[a.piece.bufferIndex].buffer,
					d = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start)
				return l.substring(d + e.remainder, d + t.remainder)
			}
			let n = e.node,
				r = this._buffers[n.piece.bufferIndex].buffer,
				i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start),
				s = r.substring(i + e.remainder, i + n.piece.length)
			for (n = n.next(); n !== ue; ) {
				let a = this._buffers[n.piece.bufferIndex].buffer,
					l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				if (n === t.node) {
					s += a.substring(l, l + t.remainder)
					break
				} else s += a.substr(l, n.piece.length)
				n = n.next()
			}
			return s
		}
		getLinesContent() {
			let e = [],
				t = 0,
				n = "",
				r = !1
			return (
				this.iterate(this.root, (i) => {
					if (i === ue) return !0
					let s = i.piece,
						a = s.length
					if (a === 0) return !0
					let l = this._buffers[s.bufferIndex].buffer,
						d = this._buffers[s.bufferIndex].lineStarts,
						c = s.start.line,
						u = s.end.line,
						m = d[c] + s.start.column
					if (r && (l.charCodeAt(m) === 10 && (m++, a--), (e[t++] = n), (n = ""), (r = !1), a === 0))
						return !0
					if (c === u)
						return (
							!this._EOLNormalized && l.charCodeAt(m + a - 1) === 13
								? ((r = !0), (n += l.substr(m, a - 1)))
								: (n += l.substr(m, a)),
							!0
						)
					;(n += this._EOLNormalized
						? l.substring(m, Math.max(m, d[c + 1] - this._EOLLength))
						: l.substring(m, d[c + 1]).replace(/(\r\n|\r|\n)$/, "")),
						(e[t++] = n)
					for (let f = c + 1; f < u; f++)
						(n = this._EOLNormalized
							? l.substring(d[f], d[f + 1] - this._EOLLength)
							: l.substring(d[f], d[f + 1]).replace(/(\r\n|\r|\n)$/, "")),
							(e[t++] = n)
					return (
						!this._EOLNormalized && l.charCodeAt(d[u] + s.end.column - 1) === 13
							? ((r = !0), s.end.column === 0 ? t-- : (n = l.substr(d[u], s.end.column - 1)))
							: (n = l.substr(d[u], s.end.column)),
						!0
					)
				}),
				r && ((e[t++] = n), (n = "")),
				(e[t++] = n),
				e
			)
		}
		getLength() {
			return this._length
		}
		getLineCount() {
			return this._lineCnt
		}
		getLineContent(e) {
			return this._lastVisitedLine.lineNumber === e
				? this._lastVisitedLine.value
				: ((this._lastVisitedLine.lineNumber = e),
					e === this._lineCnt
						? (this._lastVisitedLine.value = this.getLineRawContent(e))
						: this._EOLNormalized
							? (this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength))
							: (this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, "")),
					this._lastVisitedLine.value)
		}
		_getCharCode(e) {
			if (e.remainder === e.node.piece.length) {
				let t = e.node.next()
				if (!t) return 0
				let n = this._buffers[t.piece.bufferIndex],
					r = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start)
				return n.buffer.charCodeAt(r)
			} else {
				let t = this._buffers[e.node.piece.bufferIndex],
					r = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder
				return t.buffer.charCodeAt(r)
			}
		}
		getLineCharCode(e, t) {
			let n = this.nodeAt2(e, t + 1)
			return this._getCharCode(n)
		}
		getLineLength(e) {
			if (e === this.getLineCount()) {
				let t = this.getOffsetAt(e, 1)
				return this.getLength() - t
			}
			return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength
		}
		getCharCode(e) {
			let t = this.nodeAt(e)
			return this._getCharCode(t)
		}
		getNearestChunk(e) {
			let t = this.nodeAt(e)
			if (t.remainder === t.node.piece.length) {
				let n = t.node.next()
				if (!n || n === ue) return ""
				let r = this._buffers[n.piece.bufferIndex],
					i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				return r.buffer.substring(i, i + n.piece.length)
			} else {
				let n = this._buffers[t.node.piece.bufferIndex],
					r = this.offsetInBuffer(t.node.piece.bufferIndex, t.node.piece.start),
					i = r + t.remainder,
					s = r + t.node.piece.length
				return n.buffer.substring(i, s)
			}
		}
		findMatchesInNode(e, t, n, r, i, s, a, l, d, c, u) {
			let m = this._buffers[e.piece.bufferIndex],
				f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start),
				h = this.offsetInBuffer(e.piece.bufferIndex, i),
				g = this.offsetInBuffer(e.piece.bufferIndex, s),
				I,
				C = { line: 0, column: 0 },
				T,
				w
			t._wordSeparators
				? ((T = m.buffer.substring(h, g)), (w = (L) => L + h), t.reset(0))
				: ((T = m.buffer), (w = (L) => L), t.reset(h))
			do
				if (((I = t.next(T)), I)) {
					if (w(I.index) >= g) return c
					this.positionInBuffer(e, w(I.index) - f, C)
					let L = this.getLineFeedCnt(e.piece.bufferIndex, i, C),
						A = C.line === i.line ? C.column - i.column + r : C.column + 1,
						J = A + I[0].length
					if (((u[c++] = $k(new Re(n + L, A, n + L, J), I, l)), w(I.index) + I[0].length >= g || c >= d))
						return c
				}
			while (I)
			return c
		}
		findMatchesLineByLine(e, t, n, r) {
			let i = [],
				s = 0,
				a = new Jx(t.wordSeparators, t.regex),
				l = this.nodeAt2(e.startLineNumber, e.startColumn)
			if (l === null) return []
			let d = this.nodeAt2(e.endLineNumber, e.endColumn)
			if (d === null) return []
			let c = this.positionInBuffer(l.node, l.remainder),
				u = this.positionInBuffer(d.node, d.remainder)
			if (l.node === d.node)
				return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, c, u, t, n, r, s, i), i
			let m = e.startLineNumber,
				f = l.node
			for (; f !== d.node; ) {
				let g = this.getLineFeedCnt(f.piece.bufferIndex, c, f.piece.end)
				if (g >= 1) {
					let C = this._buffers[f.piece.bufferIndex].lineStarts,
						T = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start),
						w = C[c.line + g],
						L = m === e.startLineNumber ? e.startColumn : 1
					if (
						((s = this.findMatchesInNode(f, a, m, L, c, this.positionInBuffer(f, w - T), t, n, r, s, i)),
						s >= r)
					)
						return i
					m += g
				}
				let I = m === e.startLineNumber ? e.startColumn - 1 : 0
				if (m === e.endLineNumber) {
					let C = this.getLineContent(m).substring(I, e.endColumn - 1)
					return (s = this._findMatchesInLine(t, a, C, e.endLineNumber, I, s, i, n, r)), i
				}
				if (((s = this._findMatchesInLine(t, a, this.getLineContent(m).substr(I), m, I, s, i, n, r)), s >= r))
					return i
				m++, (l = this.nodeAt2(m, 1)), (f = l.node), (c = this.positionInBuffer(l.node, l.remainder))
			}
			if (m === e.endLineNumber) {
				let g = m === e.startLineNumber ? e.startColumn - 1 : 0,
					I = this.getLineContent(m).substring(g, e.endColumn - 1)
				return (s = this._findMatchesInLine(t, a, I, e.endLineNumber, g, s, i, n, r)), i
			}
			let h = m === e.startLineNumber ? e.startColumn : 1
			return (s = this.findMatchesInNode(d.node, a, m, h, c, u, t, n, r, s, i)), i
		}
		_findMatchesInLine(e, t, n, r, i, s, a, l, d) {
			let c = e.wordSeparators
			if (!l && e.simpleSearch) {
				let m = e.simpleSearch,
					f = m.length,
					h = n.length,
					g = -f
				for (; (g = n.indexOf(m, g + f)) !== -1; )
					if (
						(!c || zk(c, n, h, g, f)) &&
						((a[s++] = new td(new Re(r, g + 1 + i, r, g + 1 + f + i), null)), s >= d)
					)
						return s
				return s
			}
			let u
			t.reset(0)
			do
				if (
					((u = t.next(n)),
					u && ((a[s++] = $k(new Re(r, u.index + 1 + i, r, u.index + 1 + u[0].length + i), u, l)), s >= d))
				)
					return s
			while (u)
			return s
		}
		insert(e, t, n = !1) {
			if (
				((this._EOLNormalized = this._EOLNormalized && n),
				(this._lastVisitedLine.lineNumber = 0),
				(this._lastVisitedLine.value = ""),
				this.root !== ue)
			) {
				let { node: r, remainder: i, nodeStartOffset: s } = this.nodeAt(e),
					a = r.piece,
					l = a.bufferIndex,
					d = this.positionInBuffer(r, i)
				if (
					r.piece.bufferIndex === 0 &&
					a.end.line === this._lastChangeBufferPos.line &&
					a.end.column === this._lastChangeBufferPos.column &&
					s + a.length === e &&
					t.length < Js
				) {
					this.appendToNode(r, t), this.computeBufferMetadata()
					return
				}
				if (s === e) this.insertContentToNodeLeft(t, r), this._searchCache.validate(e)
				else if (s + r.piece.length > e) {
					let c = [],
						u = new nr(
							a.bufferIndex,
							d,
							a.end,
							this.getLineFeedCnt(a.bufferIndex, d, a.end),
							this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, d),
						)
					if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(r, i) === 10) {
						let g = { line: u.start.line + 1, column: 0 }
						;(u = new nr(
							u.bufferIndex,
							g,
							u.end,
							this.getLineFeedCnt(u.bufferIndex, g, u.end),
							u.length - 1,
						)),
							(t += `
`)
					}
					if (this.shouldCheckCRLF() && this.startWithLF(t))
						if (this.nodeCharCodeAt(r, i - 1) === 13) {
							let g = this.positionInBuffer(r, i - 1)
							this.deleteNodeTail(r, g), (t = "\r" + t), r.piece.length === 0 && c.push(r)
						} else this.deleteNodeTail(r, d)
					else this.deleteNodeTail(r, d)
					let m = this.createNewPieces(t)
					u.length > 0 && this.rbInsertRight(r, u)
					let f = r
					for (let h = 0; h < m.length; h++) f = this.rbInsertRight(f, m[h])
					this.deleteNodes(c)
				} else this.insertContentToNodeRight(t, r)
			} else {
				let r = this.createNewPieces(t),
					i = this.rbInsertLeft(null, r[0])
				for (let s = 1; s < r.length; s++) i = this.rbInsertRight(i, r[s])
			}
			this.computeBufferMetadata()
		}
		delete(e, t) {
			if (
				((this._lastVisitedLine.lineNumber = 0), (this._lastVisitedLine.value = ""), t <= 0 || this.root === ue)
			)
				return
			let n = this.nodeAt(e),
				r = this.nodeAt(e + t),
				i = n.node,
				s = r.node
			if (i === s) {
				let m = this.positionInBuffer(i, n.remainder),
					f = this.positionInBuffer(i, r.remainder)
				if (n.nodeStartOffset === e) {
					if (t === i.piece.length) {
						let h = i.next()
						Uh(this, i), this.validateCRLFWithPrevNode(h), this.computeBufferMetadata()
						return
					}
					this.deleteNodeHead(i, f),
						this._searchCache.validate(e),
						this.validateCRLFWithPrevNode(i),
						this.computeBufferMetadata()
					return
				}
				if (n.nodeStartOffset + i.piece.length === e + t) {
					this.deleteNodeTail(i, m), this.validateCRLFWithNextNode(i), this.computeBufferMetadata()
					return
				}
				this.shrinkNode(i, m, f), this.computeBufferMetadata()
				return
			}
			let a = [],
				l = this.positionInBuffer(i, n.remainder)
			this.deleteNodeTail(i, l), this._searchCache.validate(e), i.piece.length === 0 && a.push(i)
			let d = this.positionInBuffer(s, r.remainder)
			this.deleteNodeHead(s, d), s.piece.length === 0 && a.push(s)
			let c = i.next()
			for (let m = c; m !== ue && m !== s; m = m.next()) a.push(m)
			let u = i.piece.length === 0 ? i.prev() : i
			this.deleteNodes(a), this.validateCRLFWithNextNode(u), this.computeBufferMetadata()
		}
		insertContentToNodeLeft(e, t) {
			let n = []
			if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
				let s = t.piece,
					a = { line: s.start.line + 1, column: 0 },
					l = new nr(s.bufferIndex, a, s.end, this.getLineFeedCnt(s.bufferIndex, a, s.end), s.length - 1)
				;(t.piece = l),
					(e += `
`),
					Wi(this, t, -1, -1),
					t.piece.length === 0 && n.push(t)
			}
			let r = this.createNewPieces(e),
				i = this.rbInsertLeft(t, r[r.length - 1])
			for (let s = r.length - 2; s >= 0; s--) i = this.rbInsertLeft(i, r[s])
			this.validateCRLFWithPrevNode(i), this.deleteNodes(n)
		}
		insertContentToNodeRight(e, t) {
			this.adjustCarriageReturnFromNext(e, t) &&
				(e += `
`)
			let n = this.createNewPieces(e),
				r = this.rbInsertRight(t, n[0]),
				i = r
			for (let s = 1; s < n.length; s++) i = this.rbInsertRight(i, n[s])
			this.validateCRLFWithPrevNode(r)
		}
		positionInBuffer(e, t, n) {
			let r = e.piece,
				i = e.piece.bufferIndex,
				s = this._buffers[i].lineStarts,
				l = s[r.start.line] + r.start.column + t,
				d = r.start.line,
				c = r.end.line,
				u = 0,
				m = 0,
				f = 0
			for (; d <= c && ((u = (d + (c - d) / 2) | 0), (f = s[u]), u !== c); )
				if (((m = s[u + 1]), l < f)) c = u - 1
				else if (l >= m) d = u + 1
				else break
			return n ? ((n.line = u), (n.column = l - f), null) : { line: u, column: l - f }
		}
		getLineFeedCnt(e, t, n) {
			if (n.column === 0) return n.line - t.line
			let r = this._buffers[e].lineStarts
			if (n.line === r.length - 1) return n.line - t.line
			let i = r[n.line + 1],
				s = r[n.line] + n.column
			if (i > s + 1) return n.line - t.line
			let a = s - 1
			return this._buffers[e].buffer.charCodeAt(a) === 13 ? n.line - t.line + 1 : n.line - t.line
		}
		offsetInBuffer(e, t) {
			return this._buffers[e].lineStarts[t.line] + t.column
		}
		deleteNodes(e) {
			for (let t = 0; t < e.length; t++) Uh(this, e[t])
		}
		createNewPieces(e) {
			if (e.length > Js) {
				let c = []
				for (; e.length > Js; ) {
					let m = e.charCodeAt(Js - 1),
						f
					m === 13 || (m >= 55296 && m <= 56319)
						? ((f = e.substring(0, Js - 1)), (e = e.substring(Js - 1)))
						: ((f = e.substring(0, Js)), (e = e.substring(Js)))
					let h = Vi(f)
					c.push(
						new nr(
							this._buffers.length,
							{ line: 0, column: 0 },
							{ line: h.length - 1, column: f.length - h[h.length - 1] },
							h.length - 1,
							f.length,
						),
					),
						this._buffers.push(new Bi(f, h))
				}
				let u = Vi(e)
				return (
					c.push(
						new nr(
							this._buffers.length,
							{ line: 0, column: 0 },
							{ line: u.length - 1, column: e.length - u[u.length - 1] },
							u.length - 1,
							e.length,
						),
					),
					this._buffers.push(new Bi(e, u)),
					c
				)
			}
			let t = this._buffers[0].buffer.length,
				n = Vi(e, !1),
				r = this._lastChangeBufferPos
			if (
				this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t &&
				t !== 0 &&
				this.startWithLF(e) &&
				this.endWithCR(this._buffers[0].buffer)
			) {
				;(this._lastChangeBufferPos = {
					line: this._lastChangeBufferPos.line,
					column: this._lastChangeBufferPos.column + 1,
				}),
					(r = this._lastChangeBufferPos)
				for (let c = 0; c < n.length; c++) n[c] += t + 1
				;(this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1))),
					(this._buffers[0].buffer += "_" + e),
					(t += 1)
			} else {
				if (t !== 0) for (let c = 0; c < n.length; c++) n[c] += t
				;(this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1))),
					(this._buffers[0].buffer += e)
			}
			let i = this._buffers[0].buffer.length,
				s = this._buffers[0].lineStarts.length - 1,
				a = i - this._buffers[0].lineStarts[s],
				l = { line: s, column: a },
				d = new nr(0, r, l, this.getLineFeedCnt(0, r, l), i - t)
			return (this._lastChangeBufferPos = l), [d]
		}
		getLinesRawContent() {
			return this.getContentOfSubTree(this.root)
		}
		getLineRawContent(e, t = 0) {
			let n = this.root,
				r = "",
				i = this._searchCache.get2(e)
			if (i) {
				n = i.node
				let s = this.getAccumulatedValue(n, e - i.nodeStartLineNumber - 1),
					a = this._buffers[n.piece.bufferIndex].buffer,
					l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
				if (i.nodeStartLineNumber + n.piece.lineFeedCnt === e) r = a.substring(l + s, l + n.piece.length)
				else {
					let d = this.getAccumulatedValue(n, e - i.nodeStartLineNumber)
					return a.substring(l + s, l + d - t)
				}
			} else {
				let s = 0,
					a = e
				for (; n !== ue; )
					if (n.left !== ue && n.lf_left >= e - 1) n = n.left
					else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
						let l = this.getAccumulatedValue(n, e - n.lf_left - 2),
							d = this.getAccumulatedValue(n, e - n.lf_left - 1),
							c = this._buffers[n.piece.bufferIndex].buffer,
							u = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
						return (
							(s += n.size_left),
							this._searchCache.set({
								node: n,
								nodeStartOffset: s,
								nodeStartLineNumber: a - (e - 1 - n.lf_left),
							}),
							c.substring(u + l, u + d - t)
						)
					} else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
						let l = this.getAccumulatedValue(n, e - n.lf_left - 2),
							d = this._buffers[n.piece.bufferIndex].buffer,
							c = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
						r = d.substring(c + l, c + n.piece.length)
						break
					} else (e -= n.lf_left + n.piece.lineFeedCnt), (s += n.size_left + n.piece.length), (n = n.right)
			}
			for (n = n.next(); n !== ue; ) {
				let s = this._buffers[n.piece.bufferIndex].buffer
				if (n.piece.lineFeedCnt > 0) {
					let a = this.getAccumulatedValue(n, 0),
						l = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
					return (r += s.substring(l, l + a - t)), r
				} else {
					let a = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start)
					r += s.substr(a, n.piece.length)
				}
				n = n.next()
			}
			return r
		}
		computeBufferMetadata() {
			let e = this.root,
				t = 1,
				n = 0
			for (; e !== ue; )
				(t += e.lf_left + e.piece.lineFeedCnt), (n += e.size_left + e.piece.length), (e = e.right)
			;(this._lineCnt = t), (this._length = n), this._searchCache.validate(this._length)
		}
		getIndexOf(e, t) {
			let n = e.piece,
				r = this.positionInBuffer(e, t),
				i = r.line - n.start.line
			if (this.offsetInBuffer(n.bufferIndex, n.end) - this.offsetInBuffer(n.bufferIndex, n.start) === t) {
				let s = this.getLineFeedCnt(e.piece.bufferIndex, n.start, r)
				if (s !== i) return { index: s, remainder: 0 }
			}
			return { index: i, remainder: r.column }
		}
		getAccumulatedValue(e, t) {
			if (t < 0) return 0
			let n = e.piece,
				r = this._buffers[n.bufferIndex].lineStarts,
				i = n.start.line + t + 1
			return i > n.end.line
				? r[n.end.line] + n.end.column - r[n.start.line] - n.start.column
				: r[i] - r[n.start.line] - n.start.column
		}
		deleteNodeTail(e, t) {
			let n = e.piece,
				r = n.lineFeedCnt,
				i = this.offsetInBuffer(n.bufferIndex, n.end),
				s = t,
				a = this.offsetInBuffer(n.bufferIndex, s),
				l = this.getLineFeedCnt(n.bufferIndex, n.start, s),
				d = l - r,
				c = a - i,
				u = n.length + c
			;(e.piece = new nr(n.bufferIndex, n.start, s, l, u)), Wi(this, e, c, d)
		}
		deleteNodeHead(e, t) {
			let n = e.piece,
				r = n.lineFeedCnt,
				i = this.offsetInBuffer(n.bufferIndex, n.start),
				s = t,
				a = this.getLineFeedCnt(n.bufferIndex, s, n.end),
				l = this.offsetInBuffer(n.bufferIndex, s),
				d = a - r,
				c = i - l,
				u = n.length + c
			;(e.piece = new nr(n.bufferIndex, s, n.end, a, u)), Wi(this, e, c, d)
		}
		shrinkNode(e, t, n) {
			let r = e.piece,
				i = r.start,
				s = r.end,
				a = r.length,
				l = r.lineFeedCnt,
				d = t,
				c = this.getLineFeedCnt(r.bufferIndex, r.start, d),
				u = this.offsetInBuffer(r.bufferIndex, t) - this.offsetInBuffer(r.bufferIndex, i)
			;(e.piece = new nr(r.bufferIndex, r.start, d, c, u)), Wi(this, e, u - a, c - l)
			let m = new nr(
					r.bufferIndex,
					n,
					s,
					this.getLineFeedCnt(r.bufferIndex, n, s),
					this.offsetInBuffer(r.bufferIndex, s) - this.offsetInBuffer(r.bufferIndex, n),
				),
				f = this.rbInsertRight(e, m)
			this.validateCRLFWithPrevNode(f)
		}
		appendToNode(e, t) {
			this.adjustCarriageReturnFromNext(t, e) &&
				(t += `
`)
			let n = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e),
				r = this._buffers[0].buffer.length
			this._buffers[0].buffer += t
			let i = Vi(t, !1)
			for (let f = 0; f < i.length; f++) i[f] += r
			if (n) {
				let f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2]
				this._buffers[0].lineStarts.pop(),
					(this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: r - f })
			}
			this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1))
			let s = this._buffers[0].lineStarts.length - 1,
				a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[s],
				l = { line: s, column: a },
				d = e.piece.length + t.length,
				c = e.piece.lineFeedCnt,
				u = this.getLineFeedCnt(0, e.piece.start, l),
				m = u - c
			;(e.piece = new nr(e.piece.bufferIndex, e.piece.start, l, u, d)),
				(this._lastChangeBufferPos = l),
				Wi(this, e, t.length, m)
		}
		nodeAt(e) {
			let t = this.root,
				n = this._searchCache.get(e)
			if (n) return { node: n.node, nodeStartOffset: n.nodeStartOffset, remainder: e - n.nodeStartOffset }
			let r = 0
			for (; t !== ue; )
				if (t.size_left > e) t = t.left
				else if (t.size_left + t.piece.length >= e) {
					r += t.size_left
					let i = { node: t, remainder: e - t.size_left, nodeStartOffset: r }
					return this._searchCache.set(i), i
				} else (e -= t.size_left + t.piece.length), (r += t.size_left + t.piece.length), (t = t.right)
			return null
		}
		nodeAt2(e, t) {
			let n = this.root,
				r = 0
			for (; n !== ue; )
				if (n.left !== ue && n.lf_left >= e - 1) n = n.left
				else if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
					let i = this.getAccumulatedValue(n, e - n.lf_left - 2),
						s = this.getAccumulatedValue(n, e - n.lf_left - 1)
					return (r += n.size_left), { node: n, remainder: Math.min(i + t - 1, s), nodeStartOffset: r }
				} else if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
					let i = this.getAccumulatedValue(n, e - n.lf_left - 2)
					if (i + t - 1 <= n.piece.length) return { node: n, remainder: i + t - 1, nodeStartOffset: r }
					t -= n.piece.length - i
					break
				} else (e -= n.lf_left + n.piece.lineFeedCnt), (r += n.size_left + n.piece.length), (n = n.right)
			for (n = n.next(); n !== ue; ) {
				if (n.piece.lineFeedCnt > 0) {
					let i = this.getAccumulatedValue(n, 0),
						s = this.offsetOfNode(n)
					return { node: n, remainder: Math.min(t - 1, i), nodeStartOffset: s }
				} else if (n.piece.length >= t - 1) {
					let i = this.offsetOfNode(n)
					return { node: n, remainder: t - 1, nodeStartOffset: i }
				} else t -= n.piece.length
				n = n.next()
			}
			return null
		}
		nodeCharCodeAt(e, t) {
			if (e.piece.lineFeedCnt < 1) return -1
			let n = this._buffers[e.piece.bufferIndex],
				r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t
			return n.buffer.charCodeAt(r)
		}
		offsetOfNode(e) {
			if (!e) return 0
			let t = e.size_left
			for (; e !== this.root; )
				e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), (e = e.parent)
			return t
		}
		shouldCheckCRLF() {
			return !(
				this._EOLNormalized &&
				this._EOL ===
					`
`
			)
		}
		startWithLF(e) {
			if (typeof e == "string") return e.charCodeAt(0) === 10
			if (e === ue || e.piece.lineFeedCnt === 0) return !1
			let t = e.piece,
				n = this._buffers[t.bufferIndex].lineStarts,
				r = t.start.line,
				i = n[r] + t.start.column
			return r === n.length - 1 || n[r + 1] > i + 1
				? !1
				: this._buffers[t.bufferIndex].buffer.charCodeAt(i) === 10
		}
		endWithCR(e) {
			return typeof e == "string"
				? e.charCodeAt(e.length - 1) === 13
				: e === ue || e.piece.lineFeedCnt === 0
					? !1
					: this.nodeCharCodeAt(e, e.piece.length - 1) === 13
		}
		validateCRLFWithPrevNode(e) {
			if (this.shouldCheckCRLF() && this.startWithLF(e)) {
				let t = e.prev()
				this.endWithCR(t) && this.fixCRLF(t, e)
			}
		}
		validateCRLFWithNextNode(e) {
			if (this.shouldCheckCRLF() && this.endWithCR(e)) {
				let t = e.next()
				this.startWithLF(t) && this.fixCRLF(e, t)
			}
		}
		fixCRLF(e, t) {
			let n = [],
				r = this._buffers[e.piece.bufferIndex].lineStarts,
				i
			e.piece.end.column === 0
				? (i = { line: e.piece.end.line - 1, column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1 })
				: (i = { line: e.piece.end.line, column: e.piece.end.column - 1 })
			let s = e.piece.length - 1,
				a = e.piece.lineFeedCnt - 1
			;(e.piece = new nr(e.piece.bufferIndex, e.piece.start, i, a, s)),
				Wi(this, e, -1, -1),
				e.piece.length === 0 && n.push(e)
			let l = { line: t.piece.start.line + 1, column: 0 },
				d = t.piece.length - 1,
				c = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end)
			;(t.piece = new nr(t.piece.bufferIndex, l, t.piece.end, c, d)),
				Wi(this, t, -1, -1),
				t.piece.length === 0 && n.push(t)
			let u = this.createNewPieces(`\r
`)
			this.rbInsertRight(e, u[0])
			for (let m = 0; m < n.length; m++) Uh(this, n[m])
		}
		adjustCarriageReturnFromNext(e, t) {
			if (this.shouldCheckCRLF() && this.endWithCR(e)) {
				let n = t.next()
				if (this.startWithLF(n)) {
					if (
						((e += `
`),
						n.piece.length === 1)
					)
						Uh(this, n)
					else {
						let r = n.piece,
							i = { line: r.start.line + 1, column: 0 },
							s = r.length - 1,
							a = this.getLineFeedCnt(r.bufferIndex, i, r.end)
						;(n.piece = new nr(r.bufferIndex, i, r.end, a, s)), Wi(this, n, -1, -1)
					}
					return !0
				}
			}
			return !1
		}
		iterate(e, t) {
			if (e === ue) return t(ue)
			let n = this.iterate(e.left, t)
			return n && t(e) && this.iterate(e.right, t)
		}
		getNodeContent(e) {
			if (e === ue) return ""
			let t = this._buffers[e.piece.bufferIndex],
				n = e.piece,
				r = this.offsetInBuffer(n.bufferIndex, n.start),
				i = this.offsetInBuffer(n.bufferIndex, n.end)
			return t.buffer.substring(r, i)
		}
		getPieceContent(e) {
			let t = this._buffers[e.bufferIndex],
				n = this.offsetInBuffer(e.bufferIndex, e.start),
				r = this.offsetInBuffer(e.bufferIndex, e.end)
			return t.buffer.substring(n, r)
		}
		rbInsertRight(e, t) {
			let n = new _m(t, 1)
			if (((n.left = ue), (n.right = ue), (n.parent = ue), (n.size_left = 0), (n.lf_left = 0), this.root === ue))
				(this.root = n), (n.color = 0)
			else if (e.right === ue) (e.right = n), (n.parent = e)
			else {
				let i = US(e.right)
				;(i.left = n), (n.parent = i)
			}
			return P1(this, n), n
		}
		rbInsertLeft(e, t) {
			let n = new _m(t, 1)
			if (((n.left = ue), (n.right = ue), (n.parent = ue), (n.size_left = 0), (n.lf_left = 0), this.root === ue))
				(this.root = n), (n.color = 0)
			else if (e.left === ue) (e.left = n), (n.parent = e)
			else {
				let r = T1(e.left)
				;(r.right = n), (n.parent = r)
			}
			return P1(this, n), n
		}
		getContentOfSubTree(e) {
			let t = ""
			return this.iterate(e, (n) => ((t += this.getNodeContent(n)), !0)), t
		}
	}
function WS(o) {
	let e = 0,
		t = 0,
		n = 0,
		r = 0
	for (let i = 0, s = o.length; i < s; i++) {
		let a = o.charCodeAt(i)
		a === 13
			? (e === 0 && (t = i),
				e++,
				i + 1 < s && o.charCodeAt(i + 1) === 10 ? ((r |= 2), i++) : (r |= 3),
				(n = i + 1))
			: a === 10 && ((r |= 1), e === 0 && (t = i), e++, (n = i + 1))
	}
	return e === 0 && (t = o.length), [e, t, o.length - n, r]
}
var R1
function kB() {
	return R1 || (R1 = new TextDecoder("UTF-16LE")), R1
}
function eU(o, e, t) {
	let n = new Uint16Array(o.buffer, e, t)
	return t > 0 && (n[0] === 65279 || n[0] === 65534) ? RB(o, e, t) : kB().decode(n)
}
function RB(o, e, t) {
	let n = [],
		r = 0
	for (let i = 0; i < t; i++) {
		let s = hA(o, e)
		;(e += 2), (n[r++] = String.fromCharCode(s))
	}
	return n.join("")
}
function VS(o) {
	return o.replace(/\n/g, "\\n").replace(/\r/g, "\\r")
}
var BS = class o {
	constructor(e, t, n, r) {
		this.oldPosition = e
		this.oldText = t
		this.newPosition = n
		this.newText = r
	}
	get oldLength() {
		return this.oldText.length
	}
	get oldEnd() {
		return this.oldPosition + this.oldText.length
	}
	get newLength() {
		return this.newText.length
	}
	get newEnd() {
		return this.newPosition + this.newText.length
	}
	toString() {
		return this.oldText.length === 0
			? `(insert@${this.oldPosition} "${VS(this.newText)}")`
			: this.newText.length === 0
				? `(delete@${this.oldPosition} "${VS(this.oldText)}")`
				: `(replace@${this.oldPosition} "${VS(this.oldText)}" with "${VS(this.newText)}")`
	}
	static _writeStringSize(e) {
		return 4 + 2 * e.length
	}
	static _writeString(e, t, n) {
		let r = t.length
		lf(e, r, n), (n += 4)
		for (let i = 0; i < r; i++) vA(e, t.charCodeAt(i), n), (n += 2)
		return n
	}
	static _readString(e, t) {
		let n = af(e, t)
		return (t += 4), eU(e, t, n)
	}
	writeSize() {
		return 8 + o._writeStringSize(this.oldText) + o._writeStringSize(this.newText)
	}
	write(e, t) {
		return (
			lf(e, this.oldPosition, t),
			(t += 4),
			lf(e, this.newPosition, t),
			(t += 4),
			(t = o._writeString(e, this.oldText, t)),
			(t = o._writeString(e, this.newText, t)),
			t
		)
	}
	static read(e, t, n) {
		let r = af(e, t)
		t += 4
		let i = af(e, t)
		t += 4
		let s = o._readString(e, t)
		t += o._writeStringSize(s)
		let a = o._readString(e, t)
		return (t += o._writeStringSize(a)), n.push(new o(r, s, i, a)), t
	}
}
var $S = class o extends $ {
	constructor(t, n, r, i, s, a, l) {
		super()
		this._onDidChangeContent = this._register(new E())
		this.onDidChangeContent = this._onDidChangeContent.event
		;(this._BOM = n),
			(this._mightContainNonBasicASCII = !a),
			(this._mightContainRTL = i),
			(this._mightContainUnusualLineTerminators = s),
			(this._pieceTree = new HS(t, r, l))
	}
	equals(t) {
		return !(t instanceof o) || this._BOM !== t._BOM || this.getEOL() !== t.getEOL()
			? !1
			: this._pieceTree.equal(t._pieceTree)
	}
	mightContainRTL() {
		return this._mightContainRTL
	}
	mightContainUnusualLineTerminators() {
		return this._mightContainUnusualLineTerminators
	}
	resetMightContainUnusualLineTerminators() {
		this._mightContainUnusualLineTerminators = !1
	}
	mightContainNonBasicASCII() {
		return this._mightContainNonBasicASCII
	}
	getBOM() {
		return this._BOM
	}
	getEOL() {
		return this._pieceTree.getEOL()
	}
	createSnapshot(t) {
		return this._pieceTree.createSnapshot(t ? this._BOM : "")
	}
	getOffsetAt(t, n) {
		return this._pieceTree.getOffsetAt(t, n)
	}
	getPositionAt(t) {
		return this._pieceTree.getPositionAt(t)
	}
	getRangeAt(t, n) {
		let r = t + n,
			i = this.getPositionAt(t),
			s = this.getPositionAt(r)
		return new Re(i.lineNumber, i.column, s.lineNumber, s.column)
	}
	getValueInRange(t, n = 0) {
		if (t.isEmpty()) return ""
		let r = this._getEndOfLine(n)
		return this._pieceTree.getValueInRange(t, r)
	}
	getValueLengthInRange(t, n = 0) {
		if (t.isEmpty()) return 0
		if (t.startLineNumber === t.endLineNumber) return t.endColumn - t.startColumn
		let r = this.getOffsetAt(t.startLineNumber, t.startColumn),
			i = this.getOffsetAt(t.endLineNumber, t.endColumn),
			s = 0,
			a = this._getEndOfLine(n),
			l = this.getEOL()
		if (a.length !== l.length) {
			let d = a.length - l.length,
				c = t.endLineNumber - t.startLineNumber
			s = d * c
		}
		return i - r + s
	}
	getCharacterCountInRange(t, n = 0) {
		if (this._mightContainNonBasicASCII) {
			let r = 0,
				i = t.startLineNumber,
				s = t.endLineNumber
			for (let a = i; a <= s; a++) {
				let l = this.getLineContent(a),
					d = a === i ? t.startColumn - 1 : 0,
					c = a === s ? t.endColumn - 1 : l.length
				for (let u = d; u < c; u++) Ul(l.charCodeAt(u)) ? ((r = r + 1), (u = u + 1)) : (r = r + 1)
			}
			return (r += this._getEndOfLine(n).length * (s - i)), r
		}
		return this.getValueLengthInRange(t, n)
	}
	getNearestChunk(t) {
		return this._pieceTree.getNearestChunk(t)
	}
	getLength() {
		return this._pieceTree.getLength()
	}
	getLineCount() {
		return this._pieceTree.getLineCount()
	}
	getLinesContent() {
		return this._pieceTree.getLinesContent()
	}
	getLineContent(t) {
		return this._pieceTree.getLineContent(t)
	}
	getLineCharCode(t, n) {
		return this._pieceTree.getLineCharCode(t, n)
	}
	getCharCode(t) {
		return this._pieceTree.getCharCode(t)
	}
	getLineLength(t) {
		return this._pieceTree.getLineLength(t)
	}
	getLineMinColumn(t) {
		return 1
	}
	getLineMaxColumn(t) {
		return this.getLineLength(t) + 1
	}
	getLineFirstNonWhitespaceColumn(t) {
		let n = Uv(this.getLineContent(t))
		return n === -1 ? 0 : n + 1
	}
	getLineLastNonWhitespaceColumn(t) {
		let n = GA(this.getLineContent(t))
		return n === -1 ? 0 : n + 2
	}
	_getEndOfLine(t) {
		switch (t) {
			case 1:
				return `
`
			case 2:
				return `\r
`
			case 0:
				return this.getEOL()
			default:
				throw new Error("Unknown EOL preference")
		}
	}
	setEOL(t) {
		this._pieceTree.setEOL(t)
	}
	applyEdits(t, n, r) {
		let i = this._mightContainRTL,
			s = this._mightContainUnusualLineTerminators,
			a = this._mightContainNonBasicASCII,
			l = !0,
			d = []
		for (let I = 0; I < t.length; I++) {
			let C = t[I]
			l && C._isTracked && (l = !1)
			let T = C.range
			if (C.text) {
				let ne = !0
				a || ((ne = !JA(C.text)), (a = ne)), !i && ne && (i = Bv(C.text)), !s && ne && (s = $v(C.text))
			}
			let w = "",
				L = 0,
				A = 0,
				J = 0
			if (C.text) {
				let ne
				;[L, A, J, ne] = WS(C.text)
				let oe = this.getEOL(),
					Y =
						oe ===
						`\r
`
							? 2
							: 1
				ne === 0 || ne === Y ? (w = C.text) : (w = C.text.replace(/\r\n|\r|\n/g, oe))
			}
			d[I] = {
				sortIndex: I,
				identifier: C.identifier || null,
				range: T,
				rangeOffset: this.getOffsetAt(T.startLineNumber, T.startColumn),
				rangeLength: this.getValueLengthInRange(T),
				text: w,
				eolCount: L,
				firstLineLength: A,
				lastLineLength: J,
				forceMoveMarkers: !!C.forceMoveMarkers,
				isAutoWhitespaceEdit: C.isAutoWhitespaceEdit || !1,
			}
		}
		d.sort(o._sortOpsAscending)
		let c = !1
		for (let I = 0, C = d.length - 1; I < C; I++) {
			let T = d[I].range.getEndPosition(),
				w = d[I + 1].range.getStartPosition()
			if (w.isBeforeOrEqual(T)) {
				if (w.isBefore(T)) throw new Error("Overlapping ranges are not allowed!")
				c = !0
			}
		}
		l && (d = this._reduceOperations(d))
		let u = r || n ? o._getInverseEditRanges(d) : [],
			m = []
		if (n)
			for (let I = 0; I < d.length; I++) {
				let C = d[I],
					T = u[I]
				if (C.isAutoWhitespaceEdit && C.range.isEmpty())
					for (let w = T.startLineNumber; w <= T.endLineNumber; w++) {
						let L = ""
						;(w === T.startLineNumber &&
							((L = this.getLineContent(C.range.startLineNumber)), Uv(L) !== -1)) ||
							m.push({ lineNumber: w, oldContent: L })
					}
			}
		let f = null
		if (r) {
			let I = 0
			f = []
			for (let C = 0; C < d.length; C++) {
				let T = d[C],
					w = u[C],
					L = this.getValueInRange(T.range),
					A = T.rangeOffset + I
				;(I += T.text.length - L.length),
					(f[C] = {
						sortIndex: T.sortIndex,
						identifier: T.identifier,
						range: w,
						text: L,
						textChange: new BS(T.rangeOffset, L, A, T.text),
					})
			}
			c || f.sort((C, T) => C.sortIndex - T.sortIndex)
		}
		;(this._mightContainRTL = i),
			(this._mightContainUnusualLineTerminators = s),
			(this._mightContainNonBasicASCII = a)
		let h = this._doApplyEdits(d),
			g = null
		if (n && m.length > 0) {
			m.sort((I, C) => C.lineNumber - I.lineNumber), (g = [])
			for (let I = 0, C = m.length; I < C; I++) {
				let T = m[I].lineNumber
				if (I > 0 && m[I - 1].lineNumber === T) continue
				let w = m[I].oldContent,
					L = this.getLineContent(T)
				L.length === 0 || L === w || Uv(L) !== -1 || g.push(T)
			}
		}
		return this._onDidChangeContent.fire(), new Vb(f, h, g)
	}
	_reduceOperations(t) {
		return t.length < 1e3 ? t : [this._toSingleEditOperation(t)]
	}
	_toSingleEditOperation(t) {
		let n = !1,
			r = t[0].range,
			i = t[t.length - 1].range,
			s = new Re(r.startLineNumber, r.startColumn, i.endLineNumber, i.endColumn),
			a = r.startLineNumber,
			l = r.startColumn,
			d = []
		for (let h = 0, g = t.length; h < g; h++) {
			let I = t[h],
				C = I.range
			;(n = n || I.forceMoveMarkers),
				d.push(this.getValueInRange(new Re(a, l, C.startLineNumber, C.startColumn))),
				I.text.length > 0 && d.push(I.text),
				(a = C.endLineNumber),
				(l = C.endColumn)
		}
		let c = d.join(""),
			[u, m, f] = WS(c)
		return {
			sortIndex: 0,
			identifier: t[0].identifier,
			range: s,
			rangeOffset: this.getOffsetAt(s.startLineNumber, s.startColumn),
			rangeLength: this.getValueLengthInRange(s, 0),
			text: c,
			eolCount: u,
			firstLineLength: m,
			lastLineLength: f,
			forceMoveMarkers: n,
			isAutoWhitespaceEdit: !1,
		}
	}
	_doApplyEdits(t) {
		t.sort(o._sortOpsDescending)
		let n = []
		for (let r = 0; r < t.length; r++) {
			let i = t[r],
				s = i.range.startLineNumber,
				a = i.range.startColumn,
				l = i.range.endLineNumber,
				d = i.range.endColumn
			if (s === l && a === d && i.text.length === 0) continue
			i.text
				? (this._pieceTree.delete(i.rangeOffset, i.rangeLength),
					this._pieceTree.insert(i.rangeOffset, i.text, !0))
				: this._pieceTree.delete(i.rangeOffset, i.rangeLength)
			let c = new Re(s, a, l, d)
			n.push({
				range: c,
				rangeLength: i.rangeLength,
				text: i.text,
				rangeOffset: i.rangeOffset,
				forceMoveMarkers: i.forceMoveMarkers,
			})
		}
		return n
	}
	findMatchesLineByLine(t, n, r, i) {
		return this._pieceTree.findMatchesLineByLine(t, n, r, i)
	}
	getPieceTree() {
		return this._pieceTree
	}
	static _getInverseEditRange(t, n) {
		let r = t.startLineNumber,
			i = t.startColumn,
			[s, a, l] = WS(n),
			d
		if (n.length > 0) {
			let c = s + 1
			c === 1 ? (d = new Re(r, i, r, i + a)) : (d = new Re(r, i, r + c - 1, l + 1))
		} else d = new Re(r, i, r, i)
		return d
	}
	static _getInverseEditRanges(t) {
		let n = [],
			r = 0,
			i = 0,
			s = null
		for (let a = 0, l = t.length; a < l; a++) {
			let d = t[a],
				c,
				u
			s
				? s.range.endLineNumber === d.range.startLineNumber
					? ((c = r), (u = i + (d.range.startColumn - s.range.endColumn)))
					: ((c = r + (d.range.startLineNumber - s.range.endLineNumber)), (u = d.range.startColumn))
				: ((c = d.range.startLineNumber), (u = d.range.startColumn))
			let m
			if (d.text.length > 0) {
				let f = d.eolCount + 1
				f === 1
					? (m = new Re(c, u, c, u + d.firstLineLength))
					: (m = new Re(c, u, c + f - 1, d.lastLineLength + 1))
			} else m = new Re(c, u, c, u)
			;(r = m.endLineNumber), (i = m.endColumn), n.push(m), (s = d)
		}
		return n
	}
	static _sortOpsAscending(t, n) {
		let r = Re.compareRangesUsingEnds(t.range, n.range)
		return r === 0 ? t.sortIndex - n.sortIndex : r
	}
	static _sortOpsDescending(t, n) {
		let r = Re.compareRangesUsingEnds(t.range, n.range)
		return r === 0 ? n.sortIndex - t.sortIndex : -r
	}
}
var A1 = class {
		constructor(e, t, n, r, i, s, a, l, d) {
			this._chunks = e
			this._bom = t
			this._cr = n
			this._lf = r
			this._crlf = i
			this._containsRTL = s
			this._containsUnusualLineTerminators = a
			this._isBasicASCII = l
			this._normalizeEOL = d
		}
		_getEOL(e) {
			let t = this._cr + this._lf + this._crlf,
				n = this._cr + this._crlf
			return t === 0
				? e === 1
					? `
`
					: `\r
`
				: n > t / 2
					? `\r
`
					: `
`
		}
		create(e) {
			let t = this._getEOL(e),
				n = this._chunks
			if (
				this._normalizeEOL &&
				((t ===
					`\r
` &&
					(this._cr > 0 || this._lf > 0)) ||
					(t ===
						`
` &&
						(this._cr > 0 || this._crlf > 0)))
			)
				for (let i = 0, s = n.length; i < s; i++) {
					let a = n[i].buffer.replace(/\r\n|\r|\n/g, t),
						l = Vi(a)
					n[i] = new Bi(a, l)
				}
			let r = new $S(
				n,
				this._bom,
				t,
				this._containsRTL,
				this._containsUnusualLineTerminators,
				this._isBasicASCII,
				this._normalizeEOL,
			)
			return { textBuffer: r, disposable: r }
		}
		getFirstLineText(e) {
			return this._chunks[0].buffer.substr(0, e).split(/\r\n|\r|\n/)[0]
		}
	},
	Hh = class {
		constructor() {
			;(this.chunks = []),
				(this.BOM = ""),
				(this._hasPreviousChar = !1),
				(this._previousChar = 0),
				(this._tmpLineStarts = []),
				(this.cr = 0),
				(this.lf = 0),
				(this.crlf = 0),
				(this.containsRTL = !1),
				(this.containsUnusualLineTerminators = !1),
				(this.isBasicASCII = !0)
		}
		acceptChunk(e) {
			if (e.length === 0) return
			this.chunks.length === 0 && YA(e) && ((this.BOM = XA), (e = e.substr(1)))
			let t = e.charCodeAt(e.length - 1)
			t === 13 || (t >= 55296 && t <= 56319)
				? (this._acceptChunk1(e.substr(0, e.length - 1), !1),
					(this._hasPreviousChar = !0),
					(this._previousChar = t))
				: (this._acceptChunk1(e, !1), (this._hasPreviousChar = !1), (this._previousChar = t))
		}
		_acceptChunk1(e, t) {
			;(!t && e.length === 0) ||
				(this._hasPreviousChar
					? this._acceptChunk2(String.fromCharCode(this._previousChar) + e)
					: this._acceptChunk2(e))
		}
		_acceptChunk2(e) {
			let t = ZN(this._tmpLineStarts, e)
			this.chunks.push(new Bi(e, t.lineStarts)),
				(this.cr += t.cr),
				(this.lf += t.lf),
				(this.crlf += t.crlf),
				t.isBasicASCII ||
					((this.isBasicASCII = !1),
					this.containsRTL || (this.containsRTL = Bv(e)),
					this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = $v(e)))
		}
		finish(e = !0) {
			return (
				this._finish(),
				new A1(
					this.chunks,
					this.BOM,
					this.cr,
					this.lf,
					this.crlf,
					this.containsRTL,
					this.containsUnusualLineTerminators,
					this.isBasicASCII,
					e,
				)
			)
		}
		_finish() {
			if ((this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar)) {
				this._hasPreviousChar = !1
				let e = this.chunks[this.chunks.length - 1]
				e.buffer += String.fromCharCode(this._previousChar)
				let t = Vi(e.buffer)
				;(e.lineStarts = t), this._previousChar === 13 && this.cr++
			}
		}
	}
var zS = class extends $ {
	constructor(t, n, r) {
		super()
		this._source = t
		this._inputTextBuffer = n
		this._outputs = r
		this._outputTextBuffers = void 0
	}
	_getFullModelRange(t) {
		let n = t.getLineCount()
		return new Re(1, 1, n, this._getLineMaxColumn(t, n))
	}
	_getLineMaxColumn(t, n) {
		if (n < 1 || n > t.getLineCount()) throw new Error("Illegal value for lineNumber")
		return t.getLineLength(n) + 1
	}
	get inputTextBuffer() {
		if (!this._inputTextBuffer) {
			let t = new Hh()
			t.acceptChunk(this._source)
			let n = t.finish(!0),
				{ textBuffer: r, disposable: i } = n.create(1)
			;(this._inputTextBuffer = r), this._register(i)
		}
		return this._inputTextBuffer
	}
	get outputTextBuffers() {
		return (
			this._outputTextBuffers ||
				(this._outputTextBuffers = this._outputs.map((t) => {
					let n = new Hh()
					n.acceptChunk(t)
					let r = n.finish(!0),
						{ textBuffer: i, disposable: s } = r.create(1)
					return this._register(s), i
				})),
			this._outputTextBuffers
		)
	}
	findInInputs(t) {
		let r = new rh(t, !1, !1, null).parseSearchRequest()
		if (!r) return []
		let i = this._getFullModelRange(this.inputTextBuffer)
		return this.inputTextBuffer.findMatchesLineByLine(i, r, !0, 5e3)
	}
	findInOutputs(t) {
		let r = new rh(t, !1, !1, null).parseSearchRequest()
		return r
			? this.outputTextBuffers
					.map((i) => {
						let s = i.findMatchesLineByLine(this._getFullModelRange(i), r, !0, 5e3)
						if (s.length !== 0) return { textBuffer: i, matches: s }
					})
					.filter((i) => !!i)
			: []
	}
}
function O1(o, e) {
	let t = -1,
		n = [],
		r = []
	return (
		o.forEach((s) => {
			s.range.startLineNumber !== t && r.length > 0 && (n.push([...r]), (r = [])),
				r.push(s),
				(t = s.range.endLineNumber)
		}),
		r.length > 0 && n.push([...r]),
		n.map((s) => {
			let a = [],
				l = s[0].range.startLineNumber,
				d = s[s.length - 1].range.endLineNumber
			for (let c = l; c <= d; c++) a.push(e.getLineContent(c))
			return new ip(
				a.join(`
`) +
					`
`,
				s.map(
					(c) =>
						new Re(
							c.range.startLineNumber - 1,
							c.range.startColumn - 1,
							c.range.endLineNumber - 1,
							c.range.endColumn - 1,
						),
				),
			)
		})
	)
}
var VVe = Object.freeze({
		id: "application",
		order: 100,
		title: p("applicationConfigurationTitle", "Application"),
		type: "object",
	}),
	tU = Object.freeze({
		id: "workbench",
		order: 7,
		title: p("workbenchConfigurationTitle", "Workbench"),
		type: "object",
	}),
	OB = Object.freeze({
		id: "security",
		scope: 1,
		title: p("securityConfigurationTitle", "Security"),
		type: "object",
		order: 7,
	}),
	BVe = Object.freeze({
		id: "problems",
		title: p("problemsConfigurationTitle", "Problems"),
		type: "object",
		order: 101,
	}),
	LB = Object.freeze({ id: "window", order: 8, title: p("windowConfigurationTitle", "Window"), type: "object" }),
	MB = { ConfigurationMigration: "base.contributions.configuration.migration" },
	L1 = class {
		constructor() {
			this.migrations = []
			this._onDidRegisterConfigurationMigrations = new E()
			this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event
		}
		registerConfigurationMigrations(e) {
			this.migrations.push(...e)
		}
	},
	GS = new L1()
yt.add(MB.ConfigurationMigration, GS)
var qS = class extends $ {
	constructor(t, n) {
		super()
		this.configurationService = t
		this.workspaceService = n
		this._register(
			this.workspaceService.onDidChangeWorkspaceFolders(async (r) => {
				for (let i of r.added) await this.migrateConfigurationsForFolder(i, GS.migrations)
			}),
		),
			this.migrateConfigurations(GS.migrations),
			this._register(GS.onDidRegisterConfigurationMigration((r) => this.migrateConfigurations(r)))
	}
	static {
		this.ID = "workbench.contrib.configurationMigration"
	}
	async migrateConfigurations(t) {
		await this.migrateConfigurationsForFolder(void 0, t)
		for (let n of this.workspaceService.getWorkspace().folders) await this.migrateConfigurationsForFolder(n, t)
	}
	async migrateConfigurationsForFolder(t, n) {
		await Promise.all([n.map((r) => this.migrateConfigurationsForFolderAndOverride(r, t?.uri))])
	}
	async migrateConfigurationsForFolderAndOverride(t, n) {
		let r = this.configurationService.inspect(t.key, { resource: n }),
			i =
				this.workspaceService.getWorkbenchState() === 3
					? [
							["user", 2],
							["userLocal", 3],
							["userRemote", 4],
							["workspace", 5],
							["workspaceFolder", 6],
						]
					: [
							["user", 2],
							["userLocal", 3],
							["userRemote", 4],
							["workspace", 5],
						]
		for (let [s, a] of i) {
			let l = r[s]
			if (!l) continue
			let d = []
			if (l.value !== void 0) {
				let c = await this.runMigration(t, s, l.value, n, void 0)
				for (let u of c ?? []) d.push([u, []])
			}
			for (let { identifiers: c, value: u } of l.overrides ?? [])
				if (u !== void 0) {
					let m = await this.runMigration(t, s, u, n, c)
					for (let f of m ?? []) d.push([f, c])
				}
			d.length &&
				(await Promise.allSettled(
					d.map(async ([[c, u], m]) =>
						this.configurationService.updateValue(c, u.value, { resource: n, overrideIdentifiers: m }, a),
					),
				))
		}
	}
	async runMigration(t, n, r, i, s) {
		let a = (d) => {
				let u = this.configurationService.inspect(d, { resource: i })[n]
				if (u) return s ? u.overrides?.find(({ identifiers: m }) => nn(m, s))?.value : u.value
			},
			l = await t.migrateFn(r, a)
		return Array.isArray(l) ? l : [[t.key, l]]
	}
}
qS = R([S(0, br), S(1, gi)], qS)
var KS = class extends $ {
	constructor(t) {
		super()
		this.remoteAgentService = t
		this._ready = new Cn()
		this.ready = this._ready.p
		this.create()
	}
	static {
		this.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration"
	}
	async create() {
		try {
			await this.doCreate()
		} finally {
			this._ready.complete()
		}
	}
	async doCreate() {
		if (!Ie && (await this.remoteAgentService.getEnvironment())?.os !== 1) return
		yt.as(ho.Configuration).registerConfiguration({
			...OB,
			properties: {
				"security.allowedUNCHosts": {
					type: "array",
					items: {
						type: "string",
						pattern: "^[^\\\\]+$",
						patternErrorMessage: p(
							"security.allowedUNCHosts.patternErrorMessage",
							"UNC host names must not contain backslashes.",
						),
					},
					default: [],
					markdownDescription: p(
						"security.allowedUNCHosts",
						"A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc.",
					),
					scope: 3,
				},
				"security.restrictUNCAccess": {
					type: "boolean",
					default: !0,
					markdownDescription: p(
						"security.restrictUNCAccess",
						"If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc.",
					),
					scope: 3,
				},
			},
		})
	}
}
KS = R([S(0, Yx)], KS)
var Wh = "window.newWindowProfile",
	jS = class extends $ {
		constructor(t, n) {
			super()
			this.userDataProfilesService = t
			this.configurationService = n
			this.registerNewWindowProfileConfiguration(),
				this._register(
					this.userDataProfilesService.onDidChangeProfiles((r) =>
						this.registerNewWindowProfileConfiguration(),
					),
				),
				this.setNewWindowProfile(),
				this.checkAndResetNewWindowProfileConfig(),
				this._register(
					n.onDidChangeConfiguration((r) => {
						r.source !== 7 && r.affectsConfiguration(Wh) && this.setNewWindowProfile()
					}),
				),
				this._register(
					this.userDataProfilesService.onDidChangeProfiles(() => this.checkAndResetNewWindowProfileConfig()),
				)
		}
		static {
			this.ID = "workbench.contrib.dynamicWindowConfiguration"
		}
		registerNewWindowProfileConfiguration() {
			let t = yt.as(ho.Configuration),
				n = {
					...LB,
					properties: {
						[Wh]: {
							type: ["string", "null"],
							default: null,
							enum: [...this.userDataProfilesService.profiles.map((r) => r.name), null],
							enumItemLabels: [
								...this.userDataProfilesService.profiles.map((r) => ""),
								p("active window", "Active Window"),
							],
							description: p(
								"newWindowProfile",
								"Specifies the profile to use when opening a new window. If a profile name is provided, the new window will use that profile. If no profile name is provided, the new window will use the profile of the active window or the Default profile if no active window exists.",
							),
							scope: 1,
						},
					},
				}
			this.configurationNode
				? t.updateConfigurations({ add: [n], remove: [this.configurationNode] })
				: t.registerConfiguration(n),
				(this.configurationNode = n)
		}
		setNewWindowProfile() {
			let t = this.configurationService.getValue(Wh)
			this.newWindowProfile = t ? this.userDataProfilesService.profiles.find((n) => n.name === t) : void 0
		}
		checkAndResetNewWindowProfileConfig() {
			let t = this.configurationService.getValue(Wh)
			if (!t) return
			let n = this.newWindowProfile
				? this.userDataProfilesService.profiles.find((r) => r.id === this.newWindowProfile.id)
				: void 0
			t !== n?.name && this.configurationService.updateValue(Wh, n?.name)
		}
	}
jS = R([S(0, YM), S(1, br)], jS)
var t7e = O("editorResolverService")
var FB = yt.as(ho.Configuration),
	NB = {
		...tU,
		properties: {
			"workbench.editorAssociations": {
				type: "object",
				markdownDescription: p(
					"editor.editorAssociations",
					'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.',
				),
				additionalProperties: { type: "string" },
			},
		},
	}
FB.registerConfiguration(NB)
function nU(o, e) {
	if (new Set([W.extension, W.webviewPanel, W.vscodeWorkspaceTrust, W.vscodeSettings]).has(e.scheme)) return !1
	let r = typeof o == "string" && o.indexOf(Ue.sep) >= 0 ? `${e.scheme}:${e.path}` : Ht(e)
	return yi(typeof o == "string" ? o.toLowerCase() : o, r.toLowerCase())
}
var QS = class o {
	constructor(e, t, n, r, i, s, a) {
		this._textDocumentsAndEditors = n
		this._textDocuments = r
		this._extHostFileSystem = i
		this._extHostSearch = s
		this._logService = a
		this._notebookStatusBarItemProviders = new Map()
		this._documents = new ft()
		this._editors = new Map()
		this._onDidChangeActiveNotebookEditor = new E()
		this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event
		this._visibleNotebookEditors = []
		this._onDidOpenNotebookDocument = new E()
		this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event
		this._onDidCloseNotebookDocument = new E()
		this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event
		this._onDidChangeVisibleNotebookEditors = new E()
		this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event
		this._statusBarCache = new mr("NotebookCellStatusBarCache")
		this._handlePool = 0
		this._notebookSerializer = new Map()
		;(this._notebookProxy = e.getProxy(M.MainThreadNotebook)),
			(this._notebookDocumentsProxy = e.getProxy(M.MainThreadNotebookDocuments)),
			(this._notebookEditorsProxy = e.getProxy(M.MainThreadNotebookEditors)),
			(this._commandsConverter = t.converter),
			t.registerArgumentProcessor({
				processArgument: (l) => {
					if (l && l.$mid === 13) {
						let d = l.notebookEditor?.notebookUri,
							c = l.cell.handle,
							m = this._documents.get(d)?.getCell(c)
						if (m) return m.apiCell
					}
					if (l && l.$mid === 14) {
						let d = l.uri,
							c = this._documents.get(d)
						if (c) return c.apiNotebook
					}
					return l
				},
			}),
			o._registerApiCommands(t)
	}
	static {
		this._notebookStatusBarItemProviderHandlePool = 0
	}
	get activeNotebookEditor() {
		return this._activeNotebookEditor?.apiEditor
	}
	get visibleNotebookEditors() {
		return this._visibleNotebookEditors.map((e) => e.apiEditor)
	}
	getEditorById(e) {
		let t = this._editors.get(e)
		if (!t) throw new Error(`unknown text editor: ${e}. known editors: ${[...this._editors.keys()]} `)
		return t
	}
	getIdByEditor(e) {
		for (let [t, n] of this._editors) if (n.apiEditor === e) return t
	}
	get notebookDocuments() {
		return [...this._documents.values()]
	}
	getNotebookDocument(e, t) {
		let n = this._documents.get(e)
		if (!n && !t) throw new Error(`NO notebook document for '${e}'`)
		return n
	}
	static _convertNotebookRegistrationData(e, t) {
		if (!t) return
		let n = t.filenamePattern.map((r) => Rg.from(r)).filter((r) => r !== void 0)
		if (t.filenamePattern && !n) {
			console.warn(`Notebook content provider view options file name pattern is invalid ${t.filenamePattern}`)
			return
		}
		return {
			extension: e.identifier,
			providerDisplayName: e.displayName || e.name,
			displayName: t.displayName,
			filenamePattern: n,
			priority: t.exclusive ? "exclusive" : void 0,
		}
	}
	registerNotebookCellStatusBarItemProvider(e, t, n) {
		let r = o._notebookStatusBarItemProviderHandlePool++,
			i =
				typeof n.onDidChangeCellStatusBarItems == "function"
					? o._notebookStatusBarItemProviderHandlePool++
					: void 0
		this._notebookStatusBarItemProviders.set(r, n),
			this._notebookProxy.$registerNotebookCellStatusBarItemProvider(r, i, t)
		let s
		return (
			i !== void 0 &&
				(s = n.onDidChangeCellStatusBarItems((a) => this._notebookProxy.$emitCellStatusBarEvent(i))),
			new ye(() => {
				this._notebookStatusBarItemProviders.delete(r),
					this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(r, i),
					s?.dispose()
			})
		)
	}
	async createNotebookDocument(e) {
		let t = await this._notebookDocumentsProxy.$tryCreateNotebook({
			viewType: e.viewType,
			content: e.content && rl.from(e.content),
		})
		return b.revive(t)
	}
	async openNotebookDocument(e) {
		let t = this._documents.get(e)
		if (t) return t.apiNotebook
		let n = await this._notebookDocumentsProxy.$tryOpenNotebook(e),
			r = this._documents.get(b.revive(n))
		return Ro(r?.apiNotebook)
	}
	async showNotebookDocument(e, t) {
		let n
		typeof t == "object"
			? (n = {
					position: wt.from(t.viewColumn),
					preserveFocus: t.preserveFocus,
					selections: t.selections && t.selections.map(to.from),
					pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
					label:
						typeof t.asRepl == "string" ? t.asRepl : typeof t.asRepl == "object" ? t.asRepl.label : void 0,
				})
			: (n = { preserveFocus: !1, pinned: !0 })
		let r = t?.asRepl ? "repl" : e.notebookType,
			i = await this._notebookEditorsProxy.$tryShowNotebookDocument(e.uri, r, n),
			s = i && this._editors.get(i)?.apiEditor
		if (s) return s
		throw i
			? new Error(
					`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`,
				)
			: new Error(`Could NOT open editor for "${e.uri.toString()}".`)
	}
	async $provideNotebookCellStatusBarItems(e, t, n, r) {
		let i = this._notebookStatusBarItemProviders.get(e),
			s = b.revive(t),
			a = this._documents.get(s)
		if (!a || !i) return
		let l = a.getCellFromIndex(n)
		if (!l) return
		let d = await i.provideCellStatusBarItems(l.apiCell, r)
		if (!d) return
		let c = new Q(),
			u = this._statusBarCache.add([c]),
			f = (Array.isArray(d) ? d : [d]).map((h) => ZD.from(h, this._commandsConverter, c))
		return { cacheId: u, items: f }
	}
	$releaseNotebookCellStatusBarItems(e) {
		this._statusBarCache.delete(e)
	}
	registerNotebookSerializer(e, t, n, r, i) {
		if (Yi(t)) throw new Error("viewType cannot be empty or just whitespace")
		let s = this._handlePool++
		return (
			this._notebookSerializer.set(s, { viewType: t, serializer: n, options: r }),
			this._notebookProxy.$registerNotebookSerializer(
				s,
				{ id: e.identifier, location: e.extensionLocation },
				t,
				tk.from(r),
				o._convertNotebookRegistrationData(e, i),
			),
			q(() => {
				this._notebookProxy.$unregisterNotebookSerializer(s)
			})
		)
	}
	async $dataToNotebook(e, t, n) {
		let r = this._notebookSerializer.get(e)
		if (!r) throw new Error("NO serializer found")
		let i = await r.serializer.deserializeNotebook(t.buffer, n)
		return new Xt(rl.from(i))
	}
	async $notebookToData(e, t, n) {
		let r = this._notebookSerializer.get(e)
		if (!r) throw new Error("NO serializer found")
		let i = await r.serializer.serializeNotebook(rl.to(t.value), n)
		return z.wrap(i)
	}
	async $saveNotebook(e, t, n, r, i) {
		let s = b.revive(t),
			a = this._notebookSerializer.get(e)
		if ((this.trace(`enter saveNotebook(versionId: ${n}, ${s.toString()})`), !a))
			throw new Error("NO serializer found")
		let l = this._documents.get(s)
		if (!l) throw new Error("Document NOT found")
		if (l.versionId !== n) throw new Error("Document version mismatch")
		if (!this._extHostFileSystem.value.isWritableFileSystem(s.scheme))
			throw new Jl(p("err.readonly", "Unable to modify read-only file '{0}'", this._resourceForError(s)), 6)
		let d = {
			metadata: lw(l.apiNotebook.metadata, (h) => !(a.options?.transientDocumentMetadata ?? {})[h]),
			cells: [],
		}
		for (let h of l.apiNotebook.getCells()) {
			let g = new Ts(
				h.kind,
				h.document.getText(),
				h.document.languageId,
				h.mime,
				a.options?.transientOutputs ? [] : [...h.outputs],
				h.metadata,
				h.executionSummary,
			)
			;(g.metadata = lw(h.metadata, (I) => !(a.options?.transientCellMetadata ?? {})[I])), d.cells.push(g)
		}
		if ((await this._validateWriteFile(s, r), i.isCancellationRequested)) throw new Error("canceled")
		let c = await a.serializer.serializeNotebook(d, i)
		if (i.isCancellationRequested) throw new Error("canceled")
		this.trace(`serialized versionId: ${n} ${s.toString()}`),
			await this._extHostFileSystem.value.writeFile(s, c),
			this.trace(`Finished write versionId: ${n} ${s.toString()}`)
		let u = this._extHostFileSystem.getFileSystemProviderExtUri(s.scheme),
			m = await this._extHostFileSystem.value.stat(s),
			f = {
				name: u.basename(s),
				isFile: (m.type & 1) !== 0,
				isDirectory: (m.type & 2) !== 0,
				isSymbolicLink: (m.type & 64) !== 0,
				mtime: m.mtime,
				ctime: m.ctime,
				size: m.size,
				readonly: !!((m.permissions ?? 0) & 1) || !this._extHostFileSystem.value.isWritableFileSystem(s.scheme),
				locked: !!((m.permissions ?? 0) & 2),
				etag: bP({ mtime: m.mtime, size: m.size }),
				children: void 0,
			}
		return this.trace(`exit saveNotebook(versionId: ${n}, ${s.toString()})`), f
	}
	async $searchInNotebooks(e, t, n, r, i) {
		let s = this._notebookSerializer.get(e)?.serializer
		if (!s) return { limitHit: !1, results: [] }
		let a = new mc()
		await (async (m, f, h) => {
			await Promise.all(
				m.map(
					async (g) =>
						await Promise.all(
							g.filenamePatterns.map((I) => {
								let C = {
									_reason: h._reason,
									folderQueries: h.folderQueries,
									includePattern: h.includePattern,
									excludePattern: h.excludePattern,
									maxResults: h.maxResults,
									type: 1,
									filePattern: I,
								}
								return this._extHostSearch
									.doInternalFileSearchWithCustomCallback(C, f, (T) => {
										T.forEach((w) => {
											a.has(w) ||
												r.some((A) =>
													g.isFromSettings && !A.isFromSettings
														? !1
														: A.filenamePatterns.some((J) => nU(J, w)),
												) ||
												a.add(w)
										})
									})
									.catch((T) => {
										if (T.code === "ENOENT")
											return (
												console.warn(
													"Could not find notebook search results, ignoring notebook results.",
												),
												{ limitHit: !1, messages: [] }
											)
										throw T
									})
							}),
						),
				),
			)
		})(n, i, t)
		let d = new ft(),
			c = !1,
			u = Array.from(a).map(async (m) => {
				let f = []
				try {
					if (i.isCancellationRequested) return
					if (t.maxResults && [...d.values()].reduce((C, T) => C + T.cellResults.length, 0) > t.maxResults) {
						c = !0
						return
					}
					let h = [],
						g = this._documents.get(m)
					if (g)
						g.apiNotebook.getCells().forEach((T) =>
							h.push({
								input: T.document.getText(),
								outputs: T.outputs.flatMap((w) => w.items.map((L) => L.data.toString())),
							}),
						)
					else {
						let C = await this._extHostFileSystem.value.readFile(m),
							T = z.fromString(C.toString()),
							w = await s.deserializeNotebook(T.buffer, i)
						if (i.isCancellationRequested) return
						rl.from(w).cells.forEach((A) =>
							h.push({
								input: A.source,
								outputs: A.outputs.flatMap((J) => J.items.map((ne) => ne.valueBytes.toString())),
							}),
						)
					}
					if (i.isCancellationRequested) return
					h.forEach((C, T) => {
						let w = t.contentPattern.pattern,
							L = new zS(C.input, void 0, C.outputs),
							A = L.findInInputs(w),
							J = L.findInOutputs(w),
							ne = J.flatMap((oe) => O1(oe.matches, oe.textBuffer)).map(
								(oe, Y) => ((oe.webviewIndex = Y), oe),
							)
						if (A.length > 0 || J.length > 0) {
							let oe = { index: T, contentResults: O1(A, L.inputTextBuffer), webviewResults: ne }
							f.push(oe)
						}
					})
					let I = { resource: m, cellResults: f }
					d.set(m, I)
					return
				} catch {
					return
				}
			})
		return await Promise.all(u), { limitHit: c, results: [...d.values()] }
	}
	async _validateWriteFile(e, t) {
		let n = await this._extHostFileSystem.value.stat(e)
		if (
			typeof t?.mtime == "number" &&
			typeof t.etag == "string" &&
			t.etag !== bL &&
			typeof n.mtime == "number" &&
			typeof n.size == "number" &&
			t.mtime < n.mtime &&
			t.etag !== bP({ mtime: t.mtime, size: n.size })
		)
			throw new Jl(p("fileModifiedError", "File Modified Since"), 3, t)
	}
	_resourceForError(e) {
		return e.scheme === W.file ? e.fsPath : e.toString()
	}
	_createExtHostEditor(e, t, n) {
		if (this._editors.has(t)) throw new Error(`editor with id ALREADY EXSIST: ${t}`)
		let r = new Yd(
			t,
			this._notebookEditorsProxy,
			e,
			n.visibleRanges.map(to.to),
			n.selections.map(to.to),
			typeof n.viewColumn == "number" ? wt.to(n.viewColumn) : void 0,
			n.viewType,
		)
		this._editors.set(t, r)
	}
	$acceptDocumentAndEditorsDelta(e) {
		if (e.value.removedDocuments)
			for (let n of e.value.removedDocuments) {
				let r = b.revive(n),
					i = this._documents.get(r)
				i &&
					(i.dispose(),
					this._documents.delete(r),
					this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({
						removedDocuments: i.apiNotebook.getCells().map((s) => s.document.uri),
					}),
					this._onDidCloseNotebookDocument.fire(i.apiNotebook))
				for (let s of this._editors.values())
					s.notebookData.uri.toString() === r.toString() && this._editors.delete(s.id)
			}
		if (e.value.addedDocuments) {
			let n = []
			for (let r of e.value.addedDocuments) {
				let i = b.revive(r.uri)
				if (this._documents.has(i)) throw new Error(`adding EXISTING notebook ${i} `)
				let s = new NS(this._notebookDocumentsProxy, this._textDocumentsAndEditors, this._textDocuments, i, r)
				n.push(...r.cells.map((a) => Pm.asModelAddData(a))),
					this._documents.get(i)?.dispose(),
					this._documents.set(i, s),
					this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: n }),
					this._onDidOpenNotebookDocument.fire(s.apiNotebook)
			}
		}
		if (e.value.addedEditors)
			for (let n of e.value.addedEditors) {
				if (this._editors.has(n.id)) return
				let r = b.revive(n.documentUri),
					i = this._documents.get(r)
				i && this._createExtHostEditor(i, n.id, n)
			}
		let t = []
		if (e.value.removedEditors)
			for (let n of e.value.removedEditors) {
				let r = this._editors.get(n)
				r &&
					(this._editors.delete(n),
					this._activeNotebookEditor?.id === r.id && (this._activeNotebookEditor = void 0),
					t.push(r))
			}
		if (e.value.visibleEditors) {
			this._visibleNotebookEditors = e.value.visibleEditors.map((r) => this._editors.get(r)).filter((r) => !!r)
			let n = new Set()
			this._visibleNotebookEditors.forEach((r) => n.add(r.id))
			for (let r of this._editors.values()) {
				let i = n.has(r.id)
				r._acceptVisibility(i)
			}
			;(this._visibleNotebookEditors = [...this._editors.values()].map((r) => r).filter((r) => r.visible)),
				this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors)
		}
		e.value.newActiveEditor === null
			? (this._activeNotebookEditor = void 0)
			: e.value.newActiveEditor &&
				(this._editors.get(e.value.newActiveEditor) ||
					console.error(`FAILED to find active notebook editor ${e.value.newActiveEditor}`),
				(this._activeNotebookEditor = this._editors.get(e.value.newActiveEditor))),
			e.value.newActiveEditor !== void 0 &&
				this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor?.apiEditor)
	}
	static _registerApiCommands(e) {
		let t = G.String.with("notebookType", "A notebook type"),
			n = new be(
				"vscode.executeDataToNotebook",
				"_executeDataToNotebook",
				"Invoke notebook serializer",
				[
					t,
					new G(
						"data",
						"Bytes to convert to data",
						(i) => i instanceof Uint8Array,
						(i) => z.wrap(i),
					),
				],
				new ge("Notebook Data", (i) => rl.to(i.value)),
			),
			r = new be(
				"vscode.executeNotebookToData",
				"_executeNotebookToData",
				"Invoke notebook serializer",
				[
					t,
					new G(
						"NotebookData",
						"Notebook data to convert to bytes",
						(i) => !0,
						(i) => new Xt(rl.from(i)),
					),
				],
				new ge("Bytes", (i) => i.buffer),
			)
		e.registerApiCommand(n), e.registerApiCommand(r)
	}
	trace(e) {
		this._logService.trace(`[Extension Host Notebook] ${e}`)
	}
}
var JS = class {
	constructor(e, t, n, r = { timeout: 1500, errors: 3 }) {
		this._logService = e
		this._notebooksAndEditors = t
		this._mainThreadBulkEdits = n
		this._thresholds = r
		this._onWillSaveNotebookDocumentEvent = new di()
	}
	dispose() {}
	getOnWillSaveNotebookDocumentEvent(e) {
		return (t, n, r) => {
			let i = function (a) {
				t.call(n, a)
			}
			return (i.extension = e), this._onWillSaveNotebookDocumentEvent.event(i, void 0, r)
		}
	}
	async $participateInSave(e, t, n) {
		let r = b.revive(e),
			i = this._notebooksAndEditors.getNotebookDocument(r)
		if (!i) throw new Error("Unable to resolve notebook document")
		let s = []
		if (
			(await this._onWillSaveNotebookDocumentEvent.fireAsync(
				{ notebook: i.apiNotebook, reason: _g.to(t) },
				n,
				async (l, d) => {
					let c = Date.now(),
						u = await await Promise.resolve(l)
					Date.now() - c > this._thresholds.timeout &&
						this._logService.warn(
							"onWillSaveNotebookDocument-listener from extension",
							d.extension.identifier,
						),
						!n.isCancellationRequested &&
							u &&
							(u instanceof Yr
								? s.push(u)
								: this._logService.warn(
										"onWillSaveNotebookDocument-listener from extension",
										d.extension.identifier,
										"ignored due to invalid data",
									))
				},
			),
			n.isCancellationRequested)
		)
			return !1
		if (s.length === 0) return !0
		let a = { edits: [] }
		for (let l of s) {
			let { edits: d } = zn.from(l)
			a.edits = a.edits.concat(d)
		}
		return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new Xt(a))
	}
}
var XS = class {
	constructor(e) {
		this._notebooksAndEditors = e
		this._onDidSaveNotebookDocument = new E()
		this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event
		this._onDidChangeNotebookDocument = new E()
		this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event
	}
	$acceptModelChanged(e, t, n, r) {
		let s = this._notebooksAndEditors.getNotebookDocument(b.revive(e)).acceptModelChanged(t.value, n, r)
		this._onDidChangeNotebookDocument.fire(s)
	}
	$acceptDirtyStateChanged(e, t) {
		this._notebooksAndEditors.getNotebookDocument(b.revive(e)).acceptDirty(t)
	}
	$acceptModelSaved(e) {
		let t = this._notebooksAndEditors.getNotebookDocument(b.revive(e))
		this._onDidSaveNotebookDocument.fire(t.apiNotebook)
	}
}
var Dm = class {
	constructor(e, t) {
		this._logService = e
		this._notebooksAndEditors = t
		this._onDidChangeNotebookEditorSelection = new E()
		this._onDidChangeNotebookEditorVisibleRanges = new E()
		this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event
		this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event
	}
	$acceptEditorPropertiesChanged(e, t) {
		this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", e, t)
		let n = this._notebooksAndEditors.getEditorById(e)
		t.visibleRanges && n._acceptVisibleRanges(t.visibleRanges.ranges.map(to.to)),
			t.selections && n._acceptSelections(t.selections.selections.map(to.to)),
			t.visibleRanges &&
				this._onDidChangeNotebookEditorVisibleRanges.fire({
					notebookEditor: n.apiEditor,
					visibleRanges: n.apiEditor.visibleRanges,
				}),
			t.selections &&
				this._onDidChangeNotebookEditorSelection.fire(
					Object.freeze({ notebookEditor: n.apiEditor, selections: n.apiEditor.selections }),
				)
	}
	$acceptEditorViewColumns(e) {
		for (let t in e) this._notebooksAndEditors.getEditorById(t)._acceptViewColumn(wt.to(e[t]))
	}
}
Dm = R([S(0, te)], Dm)
var u8e = O("INotebookExecutionService")
var rU = 100
var f8e = O("INotebookKernelService"),
	g8e = O("INotebookKernelHistoryService")
var km = class {
	constructor(e, t, n, r, i) {
		this._initData = t
		this._extHostNotebook = n
		this._commands = r
		this._logService = i
		this._activeExecutions = new ft()
		this._activeNotebookExecutions = new ft()
		this._kernelDetectionTask = new Map()
		this._kernelDetectionTaskHandlePool = 0
		this._kernelSourceActionProviders = new Map()
		this._kernelSourceActionProviderHandlePool = 0
		this._kernelData = new Map()
		this._handlePool = 0
		this._onDidChangeCellExecutionState = new E()
		this.onDidChangeNotebookCellExecutionState = this._onDidChangeCellExecutionState.event
		this.id = 0
		this.variableStore = {}
		this._proxy = e.getProxy(M.MainThreadNotebookKernels)
		let s = new be(
				"notebook.selectKernel",
				"_notebook.selectKernel",
				"Trigger kernel picker for specified notebook editor widget",
				[
					new G(
						"options",
						"Select kernel options",
						(l) => !0,
						(l) => {
							if (l && "notebookEditor" in l && "id" in l) {
								let d = this._extHostNotebook.getIdByEditor(l.notebookEditor)
								return { id: l.id, extension: l.extension, notebookEditorId: d }
							} else if (l && "notebookEditor" in l) {
								let d = this._extHostNotebook.getIdByEditor(l.notebookEditor)
								if (d === void 0)
									throw new Error(
										`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${l.notebookEditor.notebook.uri.toString()}`,
									)
								return { notebookEditorId: d }
							}
							return l
						},
					),
				],
				ge.Void,
			),
			a = new be(
				"vscode.executeNotebookVariableProvider",
				"_executeNotebookVariableProvider",
				"Execute notebook variable provider",
				[G.Uri],
				new ge("A promise that resolves to an array of variables", (l, d) =>
					l.map((c) => ({
						variable: {
							name: c.name,
							value: c.value,
							expression: c.expression,
							type: c.type,
							language: c.language,
						},
						hasNamedChildren: c.hasNamedChildren,
						indexedChildrenCount: c.indexedChildrenCount,
					})),
				),
			)
		this._commands.registerApiCommand(s), this._commands.registerApiCommand(a)
	}
	createNotebookController(e, t, n, r, i, s) {
		for (let A of this._kernelData.values())
			if (A.controller.id === t && Ce.equals(e.identifier, A.extensionId))
				throw new Error(`notebook controller with id '${t}' ALREADY exist`)
		let a = this._handlePool++,
			l = this
		this._logService.trace(`NotebookController[${a}], CREATED by ${e.identifier.value}, ${t}`)
		let d = () =>
				console.warn(`NO execute handler from notebook controller '${f.id}' of extension: '${e.identifier}'`),
			c = !1,
			u = new E(),
			m = new E(),
			f = {
				id: YS(e.identifier, t),
				notebookType: n,
				extensionId: e.identifier,
				extensionLocation: e.extensionLocation,
				label: r || e.identifier.value,
				preloads: s ? s.map(gx.from) : [],
			},
			h = i ?? d,
			g,
			I
		this._proxy.$addKernel(a, f).catch((A) => {
			console.log(A), (c = !0)
		})
		let C = 0,
			T = () => {
				if (c) return
				let A = ++C
				Promise.resolve().then(() => {
					A === C && this._proxy.$updateKernel(a, f)
				})
			},
			w = new ft(),
			L = {
				get id() {
					return t
				},
				get notebookType() {
					return f.notebookType
				},
				onDidChangeSelectedNotebooks: u.event,
				get label() {
					return f.label
				},
				set label(A) {
					;(f.label = A ?? e.displayName ?? e.name), T()
				},
				get detail() {
					return f.detail ?? ""
				},
				set detail(A) {
					;(f.detail = A), T()
				},
				get description() {
					return f.description ?? ""
				},
				set description(A) {
					;(f.description = A), T()
				},
				get supportedLanguages() {
					return f.supportedLanguages
				},
				set supportedLanguages(A) {
					;(f.supportedLanguages = A), T()
				},
				get supportsExecutionOrder() {
					return f.supportsExecutionOrder ?? !1
				},
				set supportsExecutionOrder(A) {
					;(f.supportsExecutionOrder = A), T()
				},
				get rendererScripts() {
					return f.preloads ? f.preloads.map(gx.to) : []
				},
				get executeHandler() {
					return h
				},
				set executeHandler(A) {
					h = A ?? d
				},
				get interruptHandler() {
					return g
				},
				set interruptHandler(A) {
					;(g = A), (f.supportsInterrupt = !!A), T()
				},
				set variableProvider(A) {
					F(e, "notebookVariableProvider"),
						(I = A),
						(f.hasVariableProvider = !!A),
						A?.onDidChangeVariables((J) => l._proxy.$variablesUpdated(J.uri)),
						T()
				},
				get variableProvider() {
					return I
				},
				createNotebookCellExecution(A) {
					if (c) throw new Error("notebook controller is DISPOSED")
					if (!w.has(A.notebook.uri))
						throw (
							(l._logService.trace(
								`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`,
								Array.from(w.keys()).map((J) => J.toString()),
							),
							new Error(
								`notebook controller is NOT associated to notebook: ${A.notebook.uri.toString()}`,
							))
						)
					return l._createNotebookCellExecution(A, YS(e.identifier, this.id))
				},
				createNotebookExecution(A) {
					if ((F(e, "notebookExecution"), c)) throw new Error("notebook controller is DISPOSED")
					if (!w.has(A.uri))
						throw (
							(l._logService.trace(
								`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`,
								Array.from(w.keys()).map((J) => J.toString()),
							),
							new Error(`notebook controller is NOT associated to notebook: ${A.uri.toString()}`))
						)
					return l._createNotebookExecution(A, YS(e.identifier, this.id))
				},
				dispose: () => {
					c ||
						(this._logService.trace(`NotebookController[${a}], DISPOSED`),
						(c = !0),
						this._kernelData.delete(a),
						u.dispose(),
						m.dispose(),
						this._proxy.$removeKernel(a))
				},
				updateNotebookAffinity(A, J) {
					J === -1 && F(e, "notebookControllerAffinityHidden"), l._proxy.$updateNotebookPriority(a, A.uri, J)
				},
				onDidReceiveMessage: m.event,
				postMessage(A, J) {
					return (
						F(e, "notebookMessaging"), l._proxy.$postMessage(a, J && l._extHostNotebook.getIdByEditor(J), A)
					)
				},
				asWebviewUri(A) {
					return F(e, "notebookMessaging"), xl(A, l._initData.remote)
				},
			}
		return (
			this._kernelData.set(a, {
				extensionId: e.identifier,
				controller: L,
				onDidReceiveMessage: m,
				onDidChangeSelection: u,
				associatedNotebooks: w,
			}),
			L
		)
	}
	getIdByController(e) {
		for (let [t, n] of this._kernelData) if (n.controller === e) return YS(n.extensionId, e.id)
		return null
	}
	createNotebookControllerDetectionTask(e, t) {
		let n = this._kernelDetectionTaskHandlePool++,
			r = this
		this._logService.trace(`NotebookControllerDetectionTask[${n}], CREATED by ${e.identifier.value}`),
			this._proxy.$addKernelDetectionTask(n, t)
		let i = {
			dispose: () => {
				this._kernelDetectionTask.delete(n), r._proxy.$removeKernelDetectionTask(n)
			},
		}
		return this._kernelDetectionTask.set(n, i), i
	}
	registerKernelSourceActionProvider(e, t, n) {
		let r = this._kernelSourceActionProviderHandlePool++,
			i = typeof n.onDidChangeNotebookKernelSourceActions == "function" ? r : void 0,
			s = this
		this._kernelSourceActionProviders.set(r, n),
			this._logService.trace(`NotebookKernelSourceActionProvider[${r}], CREATED by ${e.identifier.value}`),
			this._proxy.$addKernelSourceActionProvider(r, r, t)
		let a
		return (
			i !== void 0 &&
				(a = n.onDidChangeNotebookKernelSourceActions((l) =>
					this._proxy.$emitNotebookKernelSourceActionsChangeEvent(i),
				)),
			{
				dispose: () => {
					this._kernelSourceActionProviders.delete(r),
						s._proxy.$removeKernelSourceActionProvider(r, r),
						a?.dispose()
				},
			}
		)
	}
	async $provideKernelSourceActions(e, t) {
		let n = this._kernelSourceActionProviders.get(e)
		if (n) {
			let r = new Q()
			return ((await n.provideNotebookKernelSourceActions(t)) ?? []).map((s) =>
				ek.from(s, this._commands.converter, r),
			)
		}
		return []
	}
	$acceptNotebookAssociation(e, t, n) {
		let r = this._kernelData.get(e)
		if (r) {
			let i = this._extHostNotebook.getNotebookDocument(b.revive(t))
			n ? r.associatedNotebooks.set(i.uri, !0) : r.associatedNotebooks.delete(i.uri),
				this._logService.trace(`NotebookController[${e}] ASSOCIATE notebook`, i.uri.toString(), n),
				r.onDidChangeSelection.fire({ selected: n, notebook: i.apiNotebook })
		}
	}
	async $executeCells(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getNotebookDocument(b.revive(t)),
			s = []
		for (let a of n) {
			let l = i.getCell(a)
			l && s.push(l.apiCell)
		}
		try {
			this._logService.trace(`NotebookController[${e}] EXECUTE cells`, i.uri.toString(), s.length),
				await r.controller.executeHandler.call(r.controller, s, i.apiNotebook, r.controller)
		} catch (a) {
			this._logService.error(`NotebookController[${e}] execute cells FAILED`, a), console.error(a)
		}
	}
	async $cancelCells(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getNotebookDocument(b.revive(t))
		if (r.controller.interruptHandler) await r.controller.interruptHandler.call(r.controller, i.apiNotebook)
		else
			for (let s of n) {
				let a = i.getCell(s)
				a && this._activeExecutions.get(a.uri)?.cancel()
			}
		if (r.controller.interruptHandler) {
			let s = this._activeNotebookExecutions.get(i.uri)
			this._activeNotebookExecutions.delete(i.uri),
				n.length && Array.isArray(s) && s.length && s.forEach((a) => a.dispose())
		}
	}
	async $provideVariables(e, t, n, r, i, s, a) {
		let l = this._kernelData.get(e)
		if (!l) return
		let d = this._extHostNotebook.getNotebookDocument(b.revive(n)),
			c = l.controller.variableProvider
		if (!c) return
		let u
		if (r !== void 0) {
			if (((u = this.variableStore[r]), !u)) return
		} else this.variableStore = {}
		let m = i === "named" ? 1 : 2,
			f = c.provideVariables(d.apiNotebook, u, m, s, a),
			h = 0
		for await (let g of f) {
			if (a.isCancellationRequested) return
			let I = {
				id: this.id++,
				name: g.variable.name,
				value: g.variable.value,
				type: g.variable.type,
				interfaces: g.variable.interfaces,
				language: g.variable.language,
				expression: g.variable.expression,
				hasNamedChildren: g.hasNamedChildren,
				indexedChildrenCount: g.indexedChildrenCount,
				extensionId: l.extensionId.value,
			}
			if (((this.variableStore[I.id] = g.variable), this._proxy.$receiveVariable(t, I), h++ >= rU)) return
		}
	}
	$acceptKernelMessageFromRenderer(e, t, n) {
		let r = this._kernelData.get(e)
		if (!r) return
		let i = this._extHostNotebook.getEditorById(t)
		r.onDidReceiveMessage.fire(Object.freeze({ editor: i.apiEditor, message: n }))
	}
	$cellExecutionChanged(e, t, n) {
		let i = this._extHostNotebook.getNotebookDocument(b.revive(e)).getCell(t)
		if (i) {
			let s = n ? YD.to(n) : 1
			s !== void 0 && this._onDidChangeCellExecutionState.fire({ cell: i.apiCell, state: s })
		}
	}
	_createNotebookCellExecution(e, t) {
		if (e.index < 0) throw new Error("CANNOT execute cell that has been REMOVED from notebook")
		let r = this._extHostNotebook.getNotebookDocument(e.notebook.uri).getCellFromApiCell(e)
		if (!r) throw new Error("invalid cell")
		if (this._activeExecutions.has(r.uri)) throw new Error(`duplicate execution for ${r.uri}`)
		let i = new M1(t, r, this._proxy)
		this._activeExecutions.set(r.uri, i)
		let s = i.onDidChangeState(() => {
			i.state === 2 && (i.dispose(), s.dispose(), this._activeExecutions.delete(r.uri))
		})
		return i.asApiObject()
	}
	_createNotebookExecution(e, t) {
		let n = this._extHostNotebook.getNotebookDocument(e.uri),
			r = e.getCells().find((a) => {
				let l = n.getCellFromApiCell(a)
				return l && this._activeExecutions.has(l.uri)
			})
		if (r) throw new Error(`duplicate cell execution for ${r.document.uri}`)
		if (this._activeNotebookExecutions.has(n.uri)) throw new Error(`duplicate notebook execution for ${n.uri}`)
		let i = new F1(t, n, this._proxy),
			s = i.onDidChangeState(() => {
				i.state === 2 && (i.dispose(), s.dispose(), this._activeNotebookExecutions.delete(n.uri))
			})
		return this._activeNotebookExecutions.set(n.uri, [i, s]), i.asApiObject()
	}
}
km = R([S(4, te)], km)
var M1 = class o extends $ {
	constructor(t, n, r) {
		super()
		this._cell = n
		this._proxy = r
		this._handle = o.HANDLE++
		this._onDidChangeState = new E()
		this.onDidChangeState = this._onDidChangeState.event
		this._state = 0
		this._tokenSource = this._register(new _e())
		;(this._collector = new N1(10, (i) => this.update(i))),
			(this._executionOrder = n.internalMetadata.executionOrder),
			this._proxy.$createExecution(this._handle, t, this._cell.notebook.uri, this._cell.handle)
	}
	static {
		this.HANDLE = 0
	}
	get state() {
		return this._state
	}
	cancel() {
		this._tokenSource.cancel()
	}
	async updateSoon(t) {
		await this._collector.addItem(t)
	}
	async update(t) {
		let n = Array.isArray(t) ? t : [t]
		return this._proxy.$updateExecution(this._handle, new Xt(n))
	}
	verifyStateForOutput() {
		if (this._state === 0) throw new Error("Must call start before modifying cell output")
		if (this._state === 2) throw new Error("Cannot modify cell output after calling resolve")
	}
	cellIndexToHandle(t) {
		let n = this._cell
		if ((t && (n = this._cell.notebook.getCellFromApiCell(t)), !n)) throw new Error("INVALID cell")
		return n.handle
	}
	validateAndConvertOutputs(t) {
		return t.map((n) => {
			let r = Es.ensureUniqueMimeTypes(n.items, !0)
			return r === n.items ? Us.from(n) : Us.from({ items: r, id: n.id, metadata: n.metadata })
		})
	}
	async updateOutputs(t, n, r) {
		let i = this.cellIndexToHandle(n),
			s = this.validateAndConvertOutputs(an(t))
		return this.updateSoon({ editType: 1, cellHandle: i, append: r, outputs: s })
	}
	async updateOutputItems(t, n, r) {
		return (
			(t = Es.ensureUniqueMimeTypes(an(t), !0)),
			this.updateSoon({ editType: 2, items: t.map(Dd.from), outputId: n.id, append: r })
		)
	}
	asApiObject() {
		let t = this
		return Object.freeze({
			get token() {
				return t._tokenSource.token
			},
			get cell() {
				return t._cell.apiCell
			},
			get executionOrder() {
				return t._executionOrder
			},
			set executionOrder(r) {
				;(t._executionOrder = r), t.update([{ editType: 3, executionOrder: t._executionOrder }])
			},
			start(r) {
				if (t._state === 2 || t._state === 1) throw new Error("Cannot call start again")
				;(t._state = 1), t._onDidChangeState.fire(), t.update({ editType: 3, runStartTime: r })
			},
			end(r, i, s) {
				if (t._state === 2) throw new Error("Cannot call resolve twice")
				;(t._state = 2), t._onDidChangeState.fire(), t._collector.flush()
				let a = UB(s)
				t._proxy.$completeExecution(t._handle, new Xt({ runEndTime: i, lastRunSuccess: r, error: a }))
			},
			clearOutput(r) {
				return t.verifyStateForOutput(), t.updateOutputs([], r, !1)
			},
			appendOutput(r, i) {
				return t.verifyStateForOutput(), t.updateOutputs(r, i, !0)
			},
			replaceOutput(r, i) {
				return t.verifyStateForOutput(), t.updateOutputs(r, i, !1)
			},
			appendOutputItems(r, i) {
				return t.verifyStateForOutput(), t.updateOutputItems(r, i, !0)
			},
			replaceOutputItems(r, i) {
				return t.verifyStateForOutput(), t.updateOutputItems(r, i, !1)
			},
		})
	}
}
function UB(o) {
	let e = (r) =>
			r
				? {
						startLineNumber: r.start.line,
						startColumn: r.start.character,
						endLineNumber: r.end.line,
						endColumn: r.end.character,
					}
				: void 0,
		t = (r) => ({ uri: r.uri, position: r.position, label: r.label })
	return o
		? {
				name: o.name,
				message: o.message,
				stack: o.stack instanceof Array ? o.stack.map((r) => t(r)) : o.stack,
				location: e(o.location),
				uri: o.uri,
			}
		: void 0
}
var F1 = class o extends $ {
		constructor(t, n, r) {
			super()
			this._notebook = n
			this._proxy = r
			this._handle = o.HANDLE++
			this._onDidChangeState = new E()
			this.onDidChangeState = this._onDidChangeState.event
			this._state = 0
			this._tokenSource = this._register(new _e())
			this._proxy.$createNotebookExecution(this._handle, t, this._notebook.uri)
		}
		static {
			this.HANDLE = 0
		}
		get state() {
			return this._state
		}
		cancel() {
			this._tokenSource.cancel()
		}
		asApiObject() {
			return Object.freeze({
				start: () => {
					if (this._state === 2 || this._state === 1) throw new Error("Cannot call start again")
					;(this._state = 1), this._onDidChangeState.fire(), this._proxy.$beginNotebookExecution(this._handle)
				},
				end: () => {
					if (this._state === 2) throw new Error("Cannot call resolve twice")
					;(this._state = 2),
						this._onDidChangeState.fire(),
						this._proxy.$completeNotebookExecution(this._handle)
				},
			})
		}
	},
	N1 = class {
		constructor(e, t) {
			this.delay = e
			this.callback = t
			this.batch = []
			this.startedTimer = Date.now()
		}
		addItem(e) {
			return (
				this.batch.push(e),
				this.currentDeferred ||
					((this.currentDeferred = new Cn()),
					(this.startedTimer = Date.now()),
					Wt(this.delay).then(() => this.flush())),
				Date.now() - this.startedTimer > this.delay ? this.flush() : this.currentDeferred.p
			)
		}
		flush() {
			if (this.batch.length === 0 || !this.currentDeferred) return Promise.resolve()
			let e = this.currentDeferred
			this.currentDeferred = void 0
			let t = this.batch
			return (this.batch = []), this.callback(t).finally(() => e.complete())
		}
	}
function YS(o, e) {
	return `${o.value}/${e}`
}
var ZS = class {
	constructor(e, t) {
		this._extHostNotebook = t
		this._rendererMessageEmitters = new Map()
		this.proxy = e.getProxy(M.MainThreadNotebookRenderers)
	}
	$postRendererMessage(e, t, n) {
		let r = this._extHostNotebook.getEditorById(e)
		this._rendererMessageEmitters.get(t)?.fire({ editor: r.apiEditor, message: n })
	}
	createRendererMessaging(e, t) {
		if (!e.contributes?.notebookRenderer?.some((r) => r.id === t))
			throw new Error(
				`Extensions may only call createRendererMessaging() for renderers they contribute (got ${t})`,
			)
		return {
			onDidReceiveMessage: (r, i, s) => this.getOrCreateEmitterFor(t).event(r, i, s),
			postMessage: (r, i) => {
				Yd.apiEditorsToExtHost.has(r) && ([r, i] = [i, r])
				let s = i && Yd.apiEditorsToExtHost.get(i)
				return this.proxy.$postMessage(s?.id, t, r)
			},
		}
	}
	getOrCreateEmitterFor(e) {
		let t = this._rendererMessageEmitters.get(e)
		return (
			t ||
			((t = new E({
				onDidRemoveLastListener: () => {
					t?.dispose(), this._rendererMessageEmitters.delete(e)
				},
			})),
			this._rendererMessageEmitters.set(e, t),
			t)
		)
	}
}
var eT = class {
	constructor(e) {
		this.handlers = new Map()
		this.proxy = e.getProxy(M.MainThreadProfileContentHandlers)
	}
	registerProfileContentHandler(e, t, n) {
		if ((F(e, "profileContentHandlers"), this.handlers.has(t)))
			throw new Error(`Handler with id '${t}' already registered`)
		return (
			this.handlers.set(t, n),
			this.proxy.$registerProfileContentHandler(t, n.name, n.description, e.identifier.value),
			q(() => {
				this.handlers.delete(t), this.proxy.$unregisterProfileContentHandler(t)
			})
		)
	}
	async $saveProfile(e, t, n, r) {
		let i = this.handlers.get(e)
		if (!i) throw new Error(`Unknown handler with id: ${e}`)
		return i.saveProfile(t, n, r)
	}
	async $readProfile(e, t, n) {
		let r = this.handlers.get(e)
		if (!r) throw new Error(`Unknown handler with id: ${e}`)
		return r.readProfile(we(t) ? t : b.revive(t), n)
	}
}
var nT = class {
	constructor(e) {
		this._handles = 0
		this._mapHandleToCancellationSource = new Map()
		this._proxy = e
	}
	async withProgress(e, t, n) {
		let r = this._handles++,
			{ title: i, location: s, cancellable: a } = t,
			l = { label: e.displayName || e.name, id: e.identifier.value }
		return (
			this._proxy
				.$startProgress(
					r,
					{ location: JD.from(s), title: i, source: l, cancellable: a },
					e.isUnderDevelopment ? void 0 : e.identifier.value,
				)
				.catch(dv),
			this._withProgress(r, n, !!a)
		)
	}
	_withProgress(e, t, n) {
		let r
		n && ((r = new _e()), this._mapHandleToCancellationSource.set(e, r))
		let i = (a) => {
				this._proxy.$progressEnd(a), this._mapHandleToCancellationSource.delete(a), r?.dispose()
			},
			s
		try {
			s = t(new tT(this._proxy, e), n && r ? r.token : De.None)
		} catch (a) {
			throw (i(e), a)
		}
		return (
			s.then(
				(a) => i(e),
				(a) => i(e),
			),
			s
		)
	}
	$acceptProgressCanceled(e) {
		let t = this._mapHandleToCancellationSource.get(e)
		t && (t.cancel(), this._mapHandleToCancellationSource.delete(e))
	}
}
function HB(o, e) {
	return (
		(o.message = e.message),
		typeof e.increment == "number" &&
			(typeof o.increment == "number" ? (o.increment += e.increment) : (o.increment = e.increment)),
		o
	)
}
var tT = class extends xa {
	constructor(t, n) {
		super((r) => this.throttledReport(r))
		this._proxy = t
		this._handle = n
	}
	throttledReport(t) {
		this._proxy.$progressReport(this._handle, t)
	}
}
R(
	[
		SO(
			100,
			(t, n) => HB(t, n),
			() => Object.create(null),
		),
	],
	tT.prototype,
	"throttledReport",
	1,
)
var rT = class o {
	constructor(e, t) {
		this.uriTransformer = t
		this.providers = new Map()
		this.proxy = e.getProxy(M.MainThreadQuickDiff)
	}
	static {
		this.handlePool = 0
	}
	$provideOriginalResource(e, t, n) {
		let r = b.revive(t),
			i = this.providers.get(e)
		return i ? Jt(() => i.provideOriginalResource(r, n)).then((s) => s || null) : Promise.resolve(null)
	}
	registerQuickDiffProvider(e, t, n, r) {
		let i = o.handlePool++
		return (
			this.providers.set(i, t),
			this.proxy.$registerQuickDiffProvider(i, Hs.from(e, this.uriTransformer), n, r, t.visible ?? !0),
			{
				dispose: () => {
					this.proxy.$unregisterQuickDiffProvider(i), this.providers.delete(i)
				},
			}
		)
	}
}
function oU(o, e, t) {
	let n = o.getProxy(M.MainThreadQuickOpen)
	class r {
		constructor(f, h) {
			this._sessions = new Map()
			this._instances = 0
			;(this._workspace = f), (this._commands = h)
		}
		showQuickPick(f, h, g, I = De.None) {
			this._onDidSelectItem = void 0
			let C = Promise.resolve(h),
				T = ++this._instances,
				w = n.$show(
					T,
					{
						title: g?.title,
						placeHolder: g?.placeHolder,
						matchOnDescription: g?.matchOnDescription,
						matchOnDetail: g?.matchOnDetail,
						ignoreFocusLost: g?.ignoreFocusOut,
						canPickMany: g?.canPickMany,
					},
					I,
				),
				L = {},
				A = w.then(() => L)
			return Promise.race([A, C])
				.then((J) => {
					if (J === L) return
					let ne = nt(f, "quickPickItemTooltip")
					return C.then((oe) => {
						let Y = []
						for (let j = 0; j < oe.length; j++) {
							let K = oe[j]
							if (typeof K == "string") Y.push({ label: K, handle: j })
							else if (K.kind === -1) Y.push({ type: "separator", label: K.label })
							else {
								K.tooltip &&
									!ne &&
									console.warn(
										`Extension '${f.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${f.identifier.value}`,
									)
								let qe = K.iconPath ? d(K.iconPath) : void 0
								Y.push({
									label: K.label,
									iconPath: qe?.iconPath,
									iconClass: qe?.iconClass,
									description: K.description,
									detail: K.detail,
									picked: K.picked,
									alwaysShow: K.alwaysShow,
									tooltip: ne ? Se.fromStrict(K.tooltip) : void 0,
									handle: j,
								})
							}
						}
						return (
							g &&
								typeof g.onDidSelectItem == "function" &&
								(this._onDidSelectItem = (j) => {
									g.onDidSelectItem(oe[j])
								}),
							n.$setItems(T, Y),
							w.then((j) => {
								if (typeof j == "number") return oe[j]
								if (Array.isArray(j)) return j.map((K) => oe[K])
							})
						)
					})
				})
				.then(void 0, (J) => {
					if (!bn(J)) return n.$setError(T, J), Promise.reject(J)
				})
		}
		$onItemSelected(f) {
			this._onDidSelectItem?.(f)
		}
		showInput(f, h = De.None) {
			return (
				(this._validateInput = f?.validateInput),
				n.$input(f, typeof this._validateInput == "function", h).then(void 0, (g) => {
					if (!bn(g)) return Promise.reject(g)
				})
			)
		}
		async $validateInput(f) {
			if (!this._validateInput) return
			let h = await this._validateInput(f)
			if (!h || typeof h == "string") return h
			let g
			switch (h.severity) {
				case 1:
					g = It.Info
					break
				case 2:
					g = It.Warning
					break
				case 3:
					g = It.Error
					break
				default:
					g = h.message ? It.Error : It.Ignore
					break
			}
			return { content: h.message, severity: g }
		}
		async showWorkspaceFolderPick(f, h = De.None) {
			let g = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [f])
			if (!g) return
			let I = await this._workspace.getWorkspaceFolders2()
			if (I) return I.find((C) => C.uri.toString() === g.uri.toString())
		}
		createQuickPick(f) {
			let h = new c(f, () => this._sessions.delete(h._id))
			return this._sessions.set(h._id, h), h
		}
		createInputBox(f) {
			let h = new u(f, () => this._sessions.delete(h._id))
			return this._sessions.set(h._id, h), h
		}
		$onDidChangeValue(f, h) {
			this._sessions.get(f)?._fireDidChangeValue(h)
		}
		$onDidAccept(f) {
			this._sessions.get(f)?._fireDidAccept()
		}
		$onDidChangeActive(f, h) {
			let g = this._sessions.get(f)
			g instanceof c && g._fireDidChangeActive(h)
		}
		$onDidChangeSelection(f, h) {
			let g = this._sessions.get(f)
			g instanceof c && g._fireDidChangeSelection(h)
		}
		$onDidTriggerButton(f, h) {
			this._sessions.get(f)?._fireDidTriggerButton(h)
		}
		$onDidTriggerItemButton(f, h, g) {
			let I = this._sessions.get(f)
			I instanceof c && I._fireDidTriggerItemButton(h, g)
		}
		$onDidHide(f) {
			this._sessions.get(f)?._fireDidHide()
		}
	}
	class i {
		constructor(f, h) {
			this._extension = f
			this._onDidDispose = h
			this._id = c._nextId++
			this._visible = !1
			this._expectingHide = !1
			this._enabled = !0
			this._busy = !1
			this._ignoreFocusOut = !0
			this._value = ""
			this._valueSelection = void 0
			this._buttons = []
			this._handlesToButtons = new Map()
			this._onDidAcceptEmitter = new E()
			this._onDidChangeValueEmitter = new E()
			this._onDidTriggerButtonEmitter = new E()
			this._onDidHideEmitter = new E()
			this._pendingUpdate = { id: this._id }
			this._disposed = !1
			this._disposables = [
				this._onDidTriggerButtonEmitter,
				this._onDidHideEmitter,
				this._onDidAcceptEmitter,
				this._onDidChangeValueEmitter,
			]
			this.onDidChangeValue = this._onDidChangeValueEmitter.event
			this.onDidAccept = this._onDidAcceptEmitter.event
			this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event
			this.onDidHide = this._onDidHideEmitter.event
		}
		static {
			this._nextId = 1
		}
		get title() {
			return this._title
		}
		set title(f) {
			;(this._title = f), this.update({ title: f })
		}
		get step() {
			return this._steps
		}
		set step(f) {
			;(this._steps = f), this.update({ step: f })
		}
		get totalSteps() {
			return this._totalSteps
		}
		set totalSteps(f) {
			;(this._totalSteps = f), this.update({ totalSteps: f })
		}
		get enabled() {
			return this._enabled
		}
		set enabled(f) {
			;(this._enabled = f), this.update({ enabled: f })
		}
		get busy() {
			return this._busy
		}
		set busy(f) {
			;(this._busy = f), this.update({ busy: f })
		}
		get ignoreFocusOut() {
			return this._ignoreFocusOut
		}
		set ignoreFocusOut(f) {
			;(this._ignoreFocusOut = f), this.update({ ignoreFocusOut: f })
		}
		get value() {
			return this._value
		}
		set value(f) {
			;(this._value = f), this.update({ value: f })
		}
		get valueSelection() {
			return this._valueSelection
		}
		set valueSelection(f) {
			;(this._valueSelection = f), this.update({ valueSelection: f })
		}
		get placeholder() {
			return this._placeholder
		}
		set placeholder(f) {
			;(this._placeholder = f), this.update({ placeholder: f })
		}
		get buttons() {
			return this._buttons
		}
		set buttons(f) {
			let h = nt(this._extension, "quickInputButtonLocation")
			!h &&
				f.some((g) => g.location) &&
				console.warn(
					`Extension '${this._extension.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`,
				),
				(this._buttons = f.slice()),
				this._handlesToButtons.clear(),
				f.forEach((g, I) => {
					let C = g === Ii.Back ? -1 : I
					this._handlesToButtons.set(C, g)
				}),
				this.update({
					buttons: f.map((g, I) => ({
						...d(g.iconPath),
						tooltip: g.tooltip,
						handle: g === Ii.Back ? -1 : I,
						location: h ? g.location : void 0,
					})),
				})
		}
		show() {
			;(this._visible = !0), (this._expectingHide = !0), this.update({ visible: !0 })
		}
		hide() {
			;(this._visible = !1), this.update({ visible: !1 })
		}
		_fireDidAccept() {
			this._onDidAcceptEmitter.fire()
		}
		_fireDidChangeValue(f) {
			;(this._value = f), this._onDidChangeValueEmitter.fire(f)
		}
		_fireDidTriggerButton(f) {
			let h = this._handlesToButtons.get(f)
			h && this._onDidTriggerButtonEmitter.fire(h)
		}
		_fireDidHide() {
			this._expectingHide && ((this._expectingHide = this._visible), this._onDidHideEmitter.fire())
		}
		dispose() {
			this._disposed ||
				((this._disposed = !0),
				this._fireDidHide(),
				(this._disposables = Nn(this._disposables)),
				this._updateTimeout && (clearTimeout(this._updateTimeout), (this._updateTimeout = void 0)),
				this._onDidDispose(),
				n.$dispose(this._id))
		}
		update(f) {
			if (!this._disposed) {
				for (let h of Object.keys(f)) {
					let g = f[h]
					this._pendingUpdate[h] = g === void 0 ? null : g
				}
				"visible" in this._pendingUpdate
					? (this._updateTimeout && (clearTimeout(this._updateTimeout), (this._updateTimeout = void 0)),
						this.dispatchUpdate())
					: this._visible &&
						!this._updateTimeout &&
						(this._updateTimeout = setTimeout(() => {
							;(this._updateTimeout = void 0), this.dispatchUpdate()
						}, 0))
			}
		}
		dispatchUpdate() {
			n.$createOrUpdate(this._pendingUpdate), (this._pendingUpdate = { id: this._id })
		}
	}
	function s(m) {
		if (m instanceof Vt) return { id: m.id }
		let f = l(m),
			h = a(m)
		return { dark: typeof f == "string" ? b.file(f) : f, light: typeof h == "string" ? b.file(h) : h }
	}
	function a(m) {
		return typeof m == "object" && "light" in m ? m.light : m
	}
	function l(m) {
		return typeof m == "object" && "dark" in m ? m.dark : m
	}
	function d(m) {
		let f = s(m),
			h,
			g
		return "id" in f ? (g = Yt.asClassName(f)) : (h = f), { iconPath: h, iconClass: g }
	}
	class c extends i {
		constructor(h, g) {
			super(h, g)
			this._items = []
			this._handlesToItems = new Map()
			this._itemsToHandles = new Map()
			this._canSelectMany = !1
			this._matchOnDescription = !0
			this._matchOnDetail = !0
			this._sortByLabel = !0
			this._keepScrollPosition = !1
			this._activeItems = []
			this._onDidChangeActiveEmitter = new E()
			this._selectedItems = []
			this._onDidChangeSelectionEmitter = new E()
			this._onDidTriggerItemButtonEmitter = new E()
			this.onDidChangeActive = this._onDidChangeActiveEmitter.event
			this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event
			this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event
			this._disposables.push(
				this._onDidChangeActiveEmitter,
				this._onDidChangeSelectionEmitter,
				this._onDidTriggerItemButtonEmitter,
			),
				this.update({ type: "quickPick" })
		}
		get items() {
			return this._items
		}
		set items(h) {
			;(this._items = h.slice()),
				this._handlesToItems.clear(),
				this._itemsToHandles.clear(),
				h.forEach((C, T) => {
					this._handlesToItems.set(T, C), this._itemsToHandles.set(C, T)
				})
			let g = nt(this._extension, "quickPickItemTooltip"),
				I = []
			for (let C = 0; C < h.length; C++) {
				let T = h[C]
				if (T.kind === -1) I.push({ type: "separator", label: T.label })
				else {
					T.tooltip &&
						!g &&
						console.warn(
							`Extension '${this._extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`,
						)
					let w = T.iconPath ? d(T.iconPath) : void 0
					I.push({
						handle: C,
						label: T.label,
						iconPath: w?.iconPath,
						iconClass: w?.iconClass,
						description: T.description,
						detail: T.detail,
						picked: T.picked,
						alwaysShow: T.alwaysShow,
						tooltip: g ? Se.fromStrict(T.tooltip) : void 0,
						buttons: T.buttons?.map((L, A) => ({ ...d(L.iconPath), tooltip: L.tooltip, handle: A })),
					})
				}
			}
			this.update({ items: I })
		}
		get canSelectMany() {
			return this._canSelectMany
		}
		set canSelectMany(h) {
			;(this._canSelectMany = h), this.update({ canSelectMany: h })
		}
		get matchOnDescription() {
			return this._matchOnDescription
		}
		set matchOnDescription(h) {
			;(this._matchOnDescription = h), this.update({ matchOnDescription: h })
		}
		get matchOnDetail() {
			return this._matchOnDetail
		}
		set matchOnDetail(h) {
			;(this._matchOnDetail = h), this.update({ matchOnDetail: h })
		}
		get sortByLabel() {
			return this._sortByLabel
		}
		set sortByLabel(h) {
			;(this._sortByLabel = h), this.update({ sortByLabel: h })
		}
		get keepScrollPosition() {
			return this._keepScrollPosition
		}
		set keepScrollPosition(h) {
			;(this._keepScrollPosition = h), this.update({ keepScrollPosition: h })
		}
		get activeItems() {
			return this._activeItems
		}
		set activeItems(h) {
			;(this._activeItems = h.filter((g) => this._itemsToHandles.has(g))),
				this.update({ activeItems: this._activeItems.map((g) => this._itemsToHandles.get(g)) })
		}
		get selectedItems() {
			return this._selectedItems
		}
		set selectedItems(h) {
			;(this._selectedItems = h.filter((g) => this._itemsToHandles.has(g))),
				this.update({ selectedItems: this._selectedItems.map((g) => this._itemsToHandles.get(g)) })
		}
		_fireDidChangeActive(h) {
			let g = Ye(h.map((I) => this._handlesToItems.get(I)))
			;(this._activeItems = g), this._onDidChangeActiveEmitter.fire(g)
		}
		_fireDidChangeSelection(h) {
			let g = Ye(h.map((I) => this._handlesToItems.get(I)))
			;(this._selectedItems = g), this._onDidChangeSelectionEmitter.fire(g)
		}
		_fireDidTriggerItemButton(h, g) {
			let I = this._handlesToItems.get(h)
			if (!I || !I.buttons || !I.buttons.length) return
			let C = I.buttons[g]
			C && this._onDidTriggerItemButtonEmitter.fire({ button: C, item: I })
		}
	}
	class u extends i {
		constructor(h, g) {
			super(h, g)
			this._password = !1
			this.update({ type: "inputBox" })
		}
		get password() {
			return this._password
		}
		set password(h) {
			;(this._password = h), this.update({ password: h })
		}
		get prompt() {
			return this._prompt
		}
		set prompt(h) {
			;(this._prompt = h), this.update({ prompt: h })
		}
		get validationMessage() {
			return this._validationMessage
		}
		set validationMessage(h) {
			;(this._validationMessage = h),
				h
					? typeof h == "string"
						? this.update({ validationMessage: h, severity: It.Error })
						: this.update({ validationMessage: h.message, severity: h.severity ?? It.Error })
					: this.update({ validationMessage: void 0, severity: It.Ignore })
		}
	}
	return new r(e, t)
}
function iU(o) {
	return o instanceof b
}
function WB(o, e) {
	return o.scheme === W.file && e.scheme === W.file && Ve
		? o.toString() === e.toString()
		: o.toString().toLowerCase() === e.toString().toLowerCase()
}
function U1(o) {
	if (o)
		return typeof o.iconPath == "string"
			? b.file(o.iconPath)
			: b.isUri(o.iconPath) || Yt.isThemeIcon(o.iconPath)
				? o.iconPath
				: void 0
}
function Zd(o) {
	if (o) {
		if (b.isUri(o)) return o
		if (Yt.isThemeIcon(o)) return o
		{
			let e = o
			return { light: e.light, dark: e.dark }
		}
	} else return
}
function VB(o) {
	let e = Zd(o.authorIcon),
		t = o.references?.map((n) => ({ ...n, icon: Zd(n.icon) }))
	return { ...o, authorIcon: e, references: t }
}
function H1(o) {
	return o ? { ...o, icon: Zd(o.icon) } : void 0
}
function W1(o, e) {
	if (!o.iconPath && !e.iconPath) return 0
	if (o.iconPath) {
		if (!e.iconPath) return 1
	} else return -1
	let t = typeof o.iconPath == "string" ? o.iconPath : b.isUri(o.iconPath) ? o.iconPath.fsPath : o.iconPath.id,
		n = typeof e.iconPath == "string" ? e.iconPath : b.isUri(e.iconPath) ? e.iconPath.fsPath : e.iconPath.id
	return vh(t, n)
}
function BB(o, e) {
	let t = 0
	if (o.strikeThrough !== e.strikeThrough) return o.strikeThrough ? 1 : -1
	if (o.faded !== e.faded) return o.faded ? 1 : -1
	if (o.tooltip !== e.tooltip) return (o.tooltip || "").localeCompare(e.tooltip || "")
	if (((t = W1(o, e)), t !== 0)) return t
	if (o.light && e.light) t = W1(o.light, e.light)
	else {
		if (o.light) return 1
		if (e.light) return -1
	}
	if (t !== 0) return t
	if (o.dark && e.dark) t = W1(o.dark, e.dark)
	else {
		if (o.dark) return 1
		if (e.dark) return -1
	}
	return t
}
function $B(o, e) {
	if (o.command !== e.command) return o.command < e.command ? -1 : 1
	if (o.title !== e.title) return o.title < e.title ? -1 : 1
	if (o.tooltip !== e.tooltip) {
		if (o.tooltip !== void 0 && e.tooltip !== void 0) return o.tooltip < e.tooltip ? -1 : 1
		if (o.tooltip !== void 0) return 1
		if (e.tooltip !== void 0) return -1
	}
	if (o.arguments === e.arguments) return 0
	if (o.arguments)
		if (e.arguments) {
			if (o.arguments.length !== e.arguments.length) return o.arguments.length - e.arguments.length
		} else return 1
	else return -1
	for (let t = 0; t < o.arguments.length; t++) {
		let n = o.arguments[t],
			r = e.arguments[t]
		if (n !== r && !(iU(n) && iU(r) && WB(n, r))) return n < r ? -1 : 1
	}
	return 0
}
function sU(o, e) {
	let t = vh(o.resourceUri.fsPath, e.resourceUri.fsPath, !0)
	if (t !== 0) return t
	if (o.command && e.command) t = $B(o.command, e.command)
	else {
		if (o.command) return 1
		if (e.command) return -1
	}
	if (t !== 0) return t
	if (o.decorations && e.decorations) t = BB(o.decorations, e.decorations)
	else {
		if (o.decorations) return 1
		if (e.decorations) return -1
	}
	if (t !== 0) return t
	if (o.multiFileDiffEditorModifiedUri && e.multiFileDiffEditorModifiedUri)
		t = vh(o.multiFileDiffEditorModifiedUri.fsPath, e.multiFileDiffEditorModifiedUri.fsPath, !0)
	else {
		if (o.multiFileDiffEditorModifiedUri) return 1
		if (e.multiFileDiffEditorModifiedUri) return -1
	}
	if (t !== 0) return t
	if (o.multiDiffEditorOriginalUri && e.multiDiffEditorOriginalUri)
		t = vh(o.multiDiffEditorOriginalUri.fsPath, e.multiDiffEditorOriginalUri.fsPath, !0)
	else {
		if (o.multiDiffEditorOriginalUri) return 1
		if (e.multiDiffEditorOriginalUri) return -1
	}
	return t
}
function zB(o, e) {
	for (let t = 0; t < o.length; t++) if (o[t] !== e[t]) return !1
	return !0
}
function qB(o, e) {
	return (
		o.command === e.command &&
		o.title === e.title &&
		o.tooltip === e.tooltip &&
		(o.arguments && e.arguments ? zB(o.arguments, e.arguments) : o.arguments === e.arguments)
	)
}
function KB(o, e) {
	return mn(o, e, qB)
}
var V1 = class {
		constructor(e, t, n, r, i) {
			this._extension = e
			this._sourceControlHandle = r
			this._documentUri = i
			this._value = ""
			this._onDidChange = new E()
			this._placeholder = ""
			this._enabled = !0
			this._visible = !0
			;(this.#t = t), (this.#e = n)
		}
		#e
		#t
		get value() {
			return this._value
		}
		set value(e) {
			;(e = e ?? ""), this.#e.$setInputBoxValue(this._sourceControlHandle, e), this.updateValue(e)
		}
		get onDidChange() {
			return this._onDidChange.event
		}
		get placeholder() {
			return this._placeholder
		}
		set placeholder(e) {
			this.#e.$setInputBoxPlaceholder(this._sourceControlHandle, e), (this._placeholder = e)
		}
		get validateInput() {
			return F(this._extension, "scmValidation"), this._validateInput
		}
		set validateInput(e) {
			if ((F(this._extension, "scmValidation"), e && typeof e != "function"))
				throw new Error(`[${this._extension.identifier.value}]: Invalid SCM input box validation function`)
			;(this._validateInput = e), this.#e.$setValidationProviderIsEnabled(this._sourceControlHandle, !!e)
		}
		get enabled() {
			return this._enabled
		}
		set enabled(e) {
			;(e = !!e),
				this._enabled !== e &&
					((this._enabled = e), this.#e.$setInputBoxEnablement(this._sourceControlHandle, e))
		}
		get visible() {
			return this._visible
		}
		set visible(e) {
			;(e = !!e),
				this._visible !== e &&
					((this._visible = e), this.#e.$setInputBoxVisibility(this._sourceControlHandle, e))
		}
		get document() {
			return F(this._extension, "scmTextDocument"), this.#t.getDocument(this._documentUri)
		}
		showValidationMessage(e, t) {
			F(this._extension, "scmValidation"), this.#e.$showValidationMessage(this._sourceControlHandle, e, t)
		}
		$onInputBoxValueChange(e) {
			this.updateValue(e)
		}
		updateValue(e) {
			;(this._value = e), this._onDidChange.fire(e)
		}
	},
	B1 = class o {
		constructor(e, t, n, r, i, s, a) {
			this._proxy = e
			this._commands = t
			this._sourceControlHandle = n
			this._id = r
			this._label = i
			this.multiDiffEditorEnableViewChanges = s
			this._extension = a
			this._resourceHandlePool = 0
			this._resourceStates = []
			this._resourceStatesMap = new Map()
			this._resourceStatesCommandsMap = new Map()
			this._resourceStatesDisposablesMap = new Map()
			this._onDidUpdateResourceStates = new E()
			this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event
			this._disposed = !1
			this._onDidDispose = new E()
			this.onDidDispose = this._onDidDispose.event
			this._handlesSnapshot = []
			this._resourceSnapshot = []
			this._contextValue = void 0
			this._hideWhenEmpty = void 0
			this.handle = o._handlePool++
		}
		static {
			this._handlePool = 0
		}
		get disposed() {
			return this._disposed
		}
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		set label(e) {
			;(this._label = e), this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, e)
		}
		get contextValue() {
			return this._contextValue
		}
		set contextValue(e) {
			;(this._contextValue = e), this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features)
		}
		get hideWhenEmpty() {
			return this._hideWhenEmpty
		}
		set hideWhenEmpty(e) {
			;(this._hideWhenEmpty = e), this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features)
		}
		get features() {
			return { contextValue: this.contextValue, hideWhenEmpty: this.hideWhenEmpty }
		}
		get resourceStates() {
			return [...this._resourceStates]
		}
		set resourceStates(e) {
			;(this._resourceStates = [...e]), this._onDidUpdateResourceStates.fire()
		}
		getResourceState(e) {
			return this._resourceStatesMap.get(e)
		}
		$executeResourceCommand(e, t) {
			let n = this._resourceStatesCommandsMap.get(e)
			return n
				? Jt(() => this._commands.executeCommand(n.command, ...(n.arguments || []), t))
				: Promise.resolve(void 0)
		}
		_takeResourceStateSnapshot() {
			let e = [...this._resourceStates].sort(sU),
				n = eE(this._resourceSnapshot, e, sU).map((s) => {
					let a = s.toInsert.map((l) => {
						let d = this._resourceHandlePool++
						this._resourceStatesMap.set(d, l)
						let c = l.resourceUri,
							u
						if (l.command)
							if (
								l.command.command === "vscode.open" ||
								l.command.command === "vscode.diff" ||
								l.command.command === "vscode.changes"
							) {
								let oe = new Q()
								;(u = this._commands.converter.toInternal(l.command, oe)),
									this._resourceStatesDisposablesMap.set(d, oe)
							} else this._resourceStatesCommandsMap.set(d, l.command)
						let m = nt(this._extension, "scmMultiDiffEditor"),
							f = m ? l.multiDiffEditorOriginalUri : void 0,
							h = m ? l.multiFileDiffEditorModifiedUri : void 0,
							g = U1(l.decorations),
							I = (l.decorations && U1(l.decorations.light)) || g,
							C = (l.decorations && U1(l.decorations.dark)) || g,
							T = [I, C],
							w = (l.decorations && l.decorations.tooltip) || "",
							L = l.decorations && !!l.decorations.strikeThrough,
							A = l.decorations && !!l.decorations.faded,
							J = l.contextValue || ""
						return { rawResource: [d, c, T, w, L, A, J, u, f, h], handle: d }
					})
					return { start: s.start, deleteCount: s.deleteCount, toInsert: a }
				}),
				r = n.map(({ start: s, deleteCount: a, toInsert: l }) => [s, a, l.map((d) => d.rawResource)]),
				i = n.reverse()
			for (let { start: s, deleteCount: a, toInsert: l } of i) {
				let d = l.map((u) => u.handle),
					c = this._handlesSnapshot.splice(s, a, ...d)
				for (let u of c)
					this._resourceStatesMap.delete(u),
						this._resourceStatesCommandsMap.delete(u),
						this._resourceStatesDisposablesMap.get(u)?.dispose(),
						this._resourceStatesDisposablesMap.delete(u)
			}
			return (this._resourceSnapshot = e), r
		}
		dispose() {
			;(this._disposed = !0), this._onDidDispose.fire()
		}
	},
	Vh = class Vh {
		constructor(e, t, n, r, i, s, a) {
			this._extension = e
			this._commands = r
			this._id = i
			this._label = s
			this._rootUri = a
			this._groups = new Map()
			this._count = void 0
			this._quickDiffProvider = void 0
			this._historyProviderDisposable = new kn()
			this._commitTemplate = void 0
			this._acceptInputDisposables = new kn()
			this._acceptInputCommand = void 0
			this._actionButtonDisposables = new kn()
			this._statusBarDisposables = new kn()
			this._statusBarCommands = void 0
			this._selected = !1
			this._onDidChangeSelection = new E()
			this.onDidChangeSelection = this._onDidChangeSelection.event
			this.handle = Vh._handlePool++
			this.createdResourceGroups = new Map()
			this.updatedResourceGroups = new Set()
			this.#e = n
			let l = b.from({
				scheme: W.vscodeSourceControl,
				path: `${i}/scm${this.handle}/input`,
				query: a ? `rootUri=${encodeURIComponent(a.toString())}` : void 0,
			})
			;(this._inputBox = new V1(e, t, this.#e, this.handle, l)),
				this.#e.$registerSourceControl(this.handle, i, s, a, l)
		}
		static {
			this._handlePool = 0
		}
		#e
		get id() {
			return this._id
		}
		get label() {
			return this._label
		}
		get rootUri() {
			return this._rootUri
		}
		get inputBox() {
			return this._inputBox
		}
		get count() {
			return this._count
		}
		set count(e) {
			this._count !== e && ((this._count = e), this.#e.$updateSourceControl(this.handle, { count: e }))
		}
		get quickDiffProvider() {
			return this._quickDiffProvider
		}
		set quickDiffProvider(e) {
			this._quickDiffProvider = e
			let t
			nt(this._extension, "quickDiffProvider") && (t = e?.label),
				this.#e.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!e, quickDiffLabel: t })
		}
		get historyProvider() {
			return F(this._extension, "scmHistoryProvider"), this._historyProvider
		}
		set historyProvider(e) {
			F(this._extension, "scmHistoryProvider"),
				(this._historyProvider = e),
				(this._historyProviderDisposable.value = new Q()),
				this.#e.$updateSourceControl(this.handle, { hasHistoryProvider: !!e }),
				e &&
					(this._historyProviderDisposable.value.add(
						e.onDidChangeCurrentHistoryItemRefs(() => {
							let t = H1(e?.currentHistoryItemRef),
								n = H1(e?.currentHistoryItemRemoteRef),
								r = H1(e?.currentHistoryItemBaseRef)
							this.#e.$onDidChangeHistoryProviderCurrentHistoryItemRefs(this.handle, t, n, r)
						}),
					),
					this._historyProviderDisposable.value.add(
						e.onDidChangeHistoryItemRefs((t) => {
							if (t.added.length === 0 && t.modified.length === 0 && t.removed.length === 0) return
							let n = t.added.map((s) => ({ ...s, icon: Zd(s.icon) })),
								r = t.modified.map((s) => ({ ...s, icon: Zd(s.icon) })),
								i = t.removed.map((s) => ({ ...s, icon: Zd(s.icon) }))
							this.#e.$onDidChangeHistoryProviderHistoryItemRefs(this.handle, {
								added: n,
								modified: r,
								removed: i,
								silent: t.silent,
							})
						}),
					))
		}
		get commitTemplate() {
			return this._commitTemplate
		}
		set commitTemplate(e) {
			e !== this._commitTemplate &&
				((this._commitTemplate = e), this.#e.$updateSourceControl(this.handle, { commitTemplate: e }))
		}
		get acceptInputCommand() {
			return this._acceptInputCommand
		}
		set acceptInputCommand(e) {
			;(this._acceptInputDisposables.value = new Q()), (this._acceptInputCommand = e)
			let t = this._commands.converter.toInternal(e, this._acceptInputDisposables.value)
			this.#e.$updateSourceControl(this.handle, { acceptInputCommand: t })
		}
		get actionButton() {
			return F(this._extension, "scmActionButton"), this._actionButton
		}
		set actionButton(e) {
			if ((F(this._extension, "scmActionButton"), Kb(this._actionButton, e))) return
			;(this._actionButton = e), (this._actionButtonDisposables.value = new Q())
			let t =
				e !== void 0
					? {
							command: {
								...this._commands.converter.toInternal(e.command, this._actionButtonDisposables.value),
								shortTitle: e.command.shortTitle,
							},
							secondaryCommands: e.secondaryCommands?.map((n) =>
								n.map((r) =>
									this._commands.converter.toInternal(r, this._actionButtonDisposables.value),
								),
							),
							enabled: e.enabled,
						}
					: void 0
			this.#e.$updateSourceControl(this.handle, { actionButton: t ?? null })
		}
		get statusBarCommands() {
			return this._statusBarCommands
		}
		set statusBarCommands(e) {
			if (this._statusBarCommands && e && KB(this._statusBarCommands, e)) return
			;(this._statusBarDisposables.value = new Q()), (this._statusBarCommands = e)
			let t = (e || []).map((n) => this._commands.converter.toInternal(n, this._statusBarDisposables.value))
			this.#e.$updateSourceControl(this.handle, { statusBarCommands: t })
		}
		get selected() {
			return this._selected
		}
		createResourceGroup(e, t, n) {
			let r = nt(this._extension, "scmMultiDiffEditor") && n?.multiDiffEditorEnableViewChanges === !0,
				i = new B1(this.#e, this._commands, this.handle, e, t, r, this._extension),
				s = Ee.once(i.onDidDispose)(() => this.createdResourceGroups.delete(i))
			return this.createdResourceGroups.set(i, s), this.eventuallyAddResourceGroups(), i
		}
		eventuallyAddResourceGroups() {
			let e = [],
				t = []
			for (let [n, r] of this.createdResourceGroups) {
				r.dispose()
				let i = n.onDidUpdateResourceStates(() => {
					this.updatedResourceGroups.add(n), this.eventuallyUpdateResourceStates()
				})
				Ee.once(n.onDidDispose)(() => {
					this.updatedResourceGroups.delete(n),
						i.dispose(),
						this._groups.delete(n.handle),
						this.#e.$unregisterGroup(this.handle, n.handle)
				}),
					e.push([n.handle, n.id, n.label, n.features, n.multiDiffEditorEnableViewChanges])
				let s = n._takeResourceStateSnapshot()
				s.length > 0 && t.push([n.handle, s]), this._groups.set(n.handle, n)
			}
			this.#e.$registerGroups(this.handle, e, t), this.createdResourceGroups.clear()
		}
		eventuallyUpdateResourceStates() {
			let e = []
			this.updatedResourceGroups.forEach((t) => {
				let n = t._takeResourceStateSnapshot()
				n.length !== 0 && e.push([t.handle, n])
			}),
				e.length > 0 && this.#e.$spliceResourceStates(this.handle, e),
				this.updatedResourceGroups.clear()
		}
		getResourceGroup(e) {
			return this._groups.get(e)
		}
		setSelectionState(e) {
			;(this._selected = e), this._onDidChangeSelection.fire(e)
		}
		dispose() {
			this._acceptInputDisposables.dispose(),
				this._actionButtonDisposables.dispose(),
				this._statusBarDisposables.dispose(),
				this._groups.forEach((e) => e.dispose()),
				this.#e.$unregisterSourceControl(this.handle)
		}
	}
R([Wl(100)], Vh.prototype, "eventuallyAddResourceGroups", 1),
	R([Wl(100)], Vh.prototype, "eventuallyUpdateResourceStates", 1)
var $1 = Vh,
	Cl = class {
		constructor(e, t, n, r) {
			this._commands = t
			this._extHostDocuments = n
			this.logService = r
			this._sourceControls = new Map()
			this._sourceControlsByExtension = new Ln()
			this._onDidChangeActiveProvider = new E()
			;(this._proxy = e.getProxy(M.MainThreadSCM)),
				(this._telemetry = e.getProxy(M.MainThreadTelemetry)),
				t.registerArgumentProcessor({
					processArgument: (i) => {
						if (i && i.$mid === 3) {
							let s = this._sourceControls.get(i.sourceControlHandle)
							if (!s) return i
							let a = s.getResourceGroup(i.groupHandle)
							return a ? a.getResourceState(i.handle) : i
						} else if (i && i.$mid === 4) {
							let s = this._sourceControls.get(i.sourceControlHandle)
							return s ? s.getResourceGroup(i.groupHandle) : i
						} else if (i && i.$mid === 5) {
							let s = this._sourceControls.get(i.handle)
							return s || i
						}
						return i
					},
				})
		}
		static {
			this._handlePool = 0
		}
		get onDidChangeActiveProvider() {
			return this._onDidChangeActiveProvider.event
		}
		createSourceControl(e, t, n, r) {
			this.logService.trace("ExtHostSCM#createSourceControl", e.identifier.value, t, n, r),
				this._telemetry.$publicLog2("api/scm/createSourceControl", { extensionId: e.identifier.value })
			let i = Cl._handlePool++,
				s = new $1(e, this._extHostDocuments, this._proxy, this._commands, t, n, r)
			this._sourceControls.set(i, s)
			let a = this._sourceControlsByExtension.get(e.identifier) || []
			return a.push(s), this._sourceControlsByExtension.set(e.identifier, a), s
		}
		getLastInputBox(e) {
			this.logService.trace("ExtHostSCM#getLastInputBox", e.identifier.value)
			let t = this._sourceControlsByExtension.get(e.identifier),
				n = t && t[t.length - 1]
			return n && n.inputBox
		}
		$provideOriginalResource(e, t, n) {
			let r = b.revive(t)
			this.logService.trace("ExtHostSCM#$provideOriginalResource", e, r.toString())
			let i = this._sourceControls.get(e)
			return !i || !i.quickDiffProvider || !i.quickDiffProvider.provideOriginalResource
				? Promise.resolve(null)
				: Jt(() => i.quickDiffProvider.provideOriginalResource(r, n)).then((s) => s || null)
		}
		$onInputBoxValueChange(e, t) {
			this.logService.trace("ExtHostSCM#$onInputBoxValueChange", e)
			let n = this._sourceControls.get(e)
			return n && n.inputBox.$onInputBoxValueChange(t), Promise.resolve(void 0)
		}
		$executeResourceCommand(e, t, n, r) {
			this.logService.trace("ExtHostSCM#$executeResourceCommand", e, t, n)
			let i = this._sourceControls.get(e)
			if (!i) return Promise.resolve(void 0)
			let s = i.getResourceGroup(t)
			return s ? s.$executeResourceCommand(n, r) : Promise.resolve(void 0)
		}
		$validateInput(e, t, n) {
			this.logService.trace("ExtHostSCM#$validateInput", e)
			let r = this._sourceControls.get(e)
			return !r || !r.inputBox.validateInput
				? Promise.resolve(void 0)
				: Jt(() => r.inputBox.validateInput(t, n)).then((i) => {
						if (!i) return Promise.resolve(void 0)
						let s = Se.fromStrict(i.message)
						return s ? Promise.resolve([s, i.type]) : Promise.resolve(void 0)
					})
		}
		$setSelectedSourceControl(e) {
			return (
				this.logService.trace("ExtHostSCM#$setSelectedSourceControl", e),
				e !== void 0 && this._sourceControls.get(e)?.setSelectionState(!0),
				this._selectedSourceControlHandle !== void 0 &&
					this._sourceControls.get(this._selectedSourceControlHandle)?.setSelectionState(!1),
				(this._selectedSourceControlHandle = e),
				Promise.resolve(void 0)
			)
		}
		async $resolveHistoryItemRefsCommonAncestor(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.resolveHistoryItemRefsCommonAncestor(t, n)) ??
					void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", r)
				return
			}
		}
		async $provideHistoryItemRefs(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemRefs(t, n))?.map((s) => ({
						...s,
						icon: Zd(s.icon),
					})) ?? void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$provideHistoryItemRefs", r)
				return
			}
		}
		async $provideHistoryItems(e, t, n) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItems(t, n))?.map((s) =>
						VB(s),
					) ?? void 0
				)
			} catch (r) {
				this.logService.error("ExtHostSCM#$provideHistoryItems", r)
				return
			}
		}
		async $provideHistoryItemChanges(e, t, n, r) {
			try {
				return (
					(await this._sourceControls.get(e)?.historyProvider?.provideHistoryItemChanges(t, n, r)) ?? void 0
				)
			} catch (i) {
				this.logService.error("ExtHostSCM#$provideHistoryItemChanges", i)
				return
			}
		}
	}
Cl = R([S(3, te)], Cl)
var oT = class o {
	constructor(e, t) {
		this.uriTransformer = t
		this.providers = new Map()
		this.proxy = e.getProxy(M.MainThreadShare)
	}
	static {
		this.handlePool = 0
	}
	async $provideShare(e, t, n) {
		return (
			(await this.providers
				.get(e)
				?.provideShare({ selection: H.to(t.selection), resourceUri: b.revive(t.resourceUri) }, n)) ?? void 0
		)
	}
	registerShareProvider(e, t) {
		let n = o.handlePool++
		return (
			this.providers.set(n, t),
			this.proxy.$registerShareProvider(n, Hs.from(e, this.uriTransformer), t.id, t.label, t.priority),
			{
				dispose: () => {
					this.proxy.$unregisterShareProvider(n), this.providers.delete(n)
				},
			}
		)
	}
}
var iT = class o {
	constructor(e) {
		this.providers = new Map()
		this.sessions = new Map()
		this.synthesizers = new Map()
		this.proxy = e.getProxy(M.MainThreadSpeech)
	}
	static {
		this.ID_POOL = 1
	}
	async $createSpeechToTextSession(e, t, n) {
		let r = this.providers.get(e)
		if (!r) return
		let i = new Q(),
			s = new _e()
		this.sessions.set(t, s)
		let a = await r.provideSpeechToTextSession(s.token, n ? { language: n } : void 0)
		a &&
			(i.add(
				a.onDidChange((l) => {
					s.token.isCancellationRequested || this.proxy.$emitSpeechToTextEvent(t, l)
				}),
			),
			i.add(s.token.onCancellationRequested(() => i.dispose())))
	}
	async $cancelSpeechToTextSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e)
	}
	async $createTextToSpeechSession(e, t, n) {
		let r = this.providers.get(e)
		if (!r) return
		let i = new Q(),
			s = new _e()
		this.sessions.set(t, s)
		let a = await r.provideTextToSpeechSession(s.token, n ? { language: n } : void 0)
		a &&
			(this.synthesizers.set(t, a),
			i.add(
				a.onDidChange((l) => {
					s.token.isCancellationRequested || this.proxy.$emitTextToSpeechEvent(t, l)
				}),
			),
			i.add(s.token.onCancellationRequested(() => i.dispose())))
	}
	async $synthesizeSpeech(e, t) {
		this.synthesizers.get(e)?.synthesize(t)
	}
	async $cancelTextToSpeechSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e), this.synthesizers.delete(e)
	}
	async $createKeywordRecognitionSession(e, t) {
		let n = this.providers.get(e)
		if (!n) return
		let r = new Q(),
			i = new _e()
		this.sessions.set(t, i)
		let s = await n.provideKeywordRecognitionSession(i.token)
		s &&
			(r.add(
				s.onDidChange((a) => {
					i.token.isCancellationRequested || this.proxy.$emitKeywordRecognitionEvent(t, a)
				}),
			),
			r.add(i.token.onCancellationRequested(() => r.dispose())))
	}
	async $cancelKeywordRecognitionSession(e) {
		this.sessions.get(e)?.dispose(!0), this.sessions.delete(e)
	}
	registerProvider(e, t, n) {
		let r = o.ID_POOL++
		return (
			this.providers.set(r, n),
			this.proxy.$registerProvider(r, t, { extension: e, displayName: e.value }),
			q(() => {
				this.proxy.$unregisterProvider(r), this.providers.delete(r)
			})
		)
	}
}
var z1 = class o {
		constructor(e, t, n, r, i, s = 1, a, l) {
			this._onDispose = l
			this._disposed = !1
			this._text = ""
			this._staleCommandRegistrations = new Q()
			if (((this.#e = e), (this.#t = t), i && r)) {
				this._entryId = RF(r.identifier, i)
				let d = n.get(this._entryId)
				d &&
					((s = d.alignLeft ? 1 : 2),
					(a = d.priority),
					(this._visible = !0),
					(this.name = d.name),
					(this.text = d.text),
					(this.tooltip = d.tooltip),
					(this.command = d.command),
					(this.accessibilityInformation = d.accessibilityInformation))
			} else this._entryId = String(o.ID_GEN++)
			;(this._extension = r), (this._id = i), (this._alignment = s), (this._priority = this.validatePriority(a))
		}
		static {
			this.ID_GEN = 0
		}
		static {
			this.ALLOWED_BACKGROUND_COLORS = new Map([
				["statusBarItem.errorBackground", new Is("statusBarItem.errorForeground")],
				["statusBarItem.warningBackground", new Is("statusBarItem.warningForeground")],
			])
		}
		#e
		#t
		validatePriority(e) {
			if (fn(e))
				return e === Number.POSITIVE_INFINITY
					? Number.MAX_VALUE
					: e === Number.NEGATIVE_INFINITY
						? -Number.MAX_VALUE
						: e
		}
		get id() {
			return this._id ?? this._extension.identifier.value
		}
		get entryId() {
			return this._entryId
		}
		get alignment() {
			return this._alignment
		}
		get priority() {
			return this._priority
		}
		get text() {
			return this._text
		}
		get name() {
			return this._name
		}
		get tooltip() {
			return this._tooltip
		}
		get tooltip2() {
			return this._extension && F(this._extension, "statusBarItemTooltip"), this._tooltip2
		}
		get color() {
			return this._color
		}
		get backgroundColor() {
			return this._backgroundColor
		}
		get command() {
			return this._command?.fromApi
		}
		get accessibilityInformation() {
			return this._accessibilityInformation
		}
		set text(e) {
			;(this._text = e), this.update()
		}
		set name(e) {
			;(this._name = e), this.update()
		}
		set tooltip(e) {
			;(this._tooltip = e), this.update()
		}
		set tooltip2(e) {
			this._extension && F(this._extension, "statusBarItemTooltip"), (this._tooltip2 = e), this.update()
		}
		set color(e) {
			;(this._color = e), this.update()
		}
		set backgroundColor(e) {
			e && !o.ALLOWED_BACKGROUND_COLORS.has(e.id) && (e = void 0), (this._backgroundColor = e), this.update()
		}
		set command(e) {
			this._command?.fromApi !== e &&
				(this._latestCommandRegistration &&
					this._staleCommandRegistrations.add(this._latestCommandRegistration),
				(this._latestCommandRegistration = new Q()),
				typeof e == "string"
					? (this._command = {
							fromApi: e,
							internal: this.#t.toInternal({ title: "", command: e }, this._latestCommandRegistration),
						})
					: e
						? (this._command = {
								fromApi: e,
								internal: this.#t.toInternal(e, this._latestCommandRegistration),
							})
						: (this._command = void 0),
				this.update())
		}
		set accessibilityInformation(e) {
			;(this._accessibilityInformation = e), this.update()
		}
		show() {
			;(this._visible = !0), this.update()
		}
		hide() {
			clearTimeout(this._timeoutHandle), (this._visible = !1), this.#e.$disposeEntry(this._entryId)
		}
		update() {
			this._disposed ||
				!this._visible ||
				(clearTimeout(this._timeoutHandle),
				(this._timeoutHandle = setTimeout(() => {
					this._timeoutHandle = void 0
					let e
					this._extension
						? this._id
							? (e = `${this._extension.identifier.value}.${this._id}`)
							: (e = this._extension.identifier.value)
						: (e = this._id)
					let t
					this._name
						? (t = this._name)
						: (t = p(
								"extensionLabel",
								"{0} (Extension)",
								this._extension.displayName || this._extension.name,
							))
					let n = this._color
					this._backgroundColor && (n = o.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id))
					let r, i
					typeof this._tooltip2 == "function"
						? ((r = Se.fromStrict(this._tooltip)), (i = !0))
						: ((r = Se.fromStrict(this._tooltip2 ?? this._tooltip)), (i = !1)),
						this.#e.$setEntry(
							this._entryId,
							e,
							this._extension?.identifier.value,
							t,
							this._text,
							r,
							i,
							this._command?.internal,
							n,
							this._backgroundColor,
							this._alignment === 1,
							this._priority,
							this._accessibilityInformation,
						),
						this._staleCommandRegistrations.clear()
				}, 0)))
		}
		dispose() {
			this.hide(), this._onDispose?.(), (this._disposed = !0)
		}
	},
	q1 = class {
		constructor(e) {
			this._messages = []
			;(this._item = e.createStatusBarEntry(void 0, "status.extensionMessage", 1, Number.MIN_VALUE)),
				(this._item.name = p("status.extensionMessage", "Extension Status"))
		}
		dispose() {
			;(this._messages.length = 0), this._item.dispose()
		}
		setMessage(e) {
			let t = { message: e }
			return (
				this._messages.unshift(t),
				this._update(),
				new ye(() => {
					let n = this._messages.indexOf(t)
					n >= 0 && (this._messages.splice(n, 1), this._update())
				})
			)
		}
		_update() {
			this._messages.length > 0
				? ((this._item.text = this._messages[0].message), this._item.show())
				: this._item.hide()
		}
	},
	sT = class {
		constructor(e, t) {
			this._entries = new Map()
			this._existingItems = new Map()
			;(this._proxy = e.getProxy(M.MainThreadStatusBar)),
				(this._commands = t),
				(this._statusMessage = new q1(this))
		}
		$acceptStaticEntries(e) {
			for (let t of e) this._existingItems.set(t.entryId, t)
		}
		async $provideTooltip(e, t) {
			let n = this._entries.get(e)
			if (!n) return
			let r = typeof n.tooltip2 == "function" ? await n.tooltip2(t) : n.tooltip2
			return t.isCancellationRequested ? void 0 : Se.fromStrict(r)
		}
		createStatusBarEntry(e, t, n, r) {
			let i = new z1(this._proxy, this._commands, this._existingItems, e, t, n, r, () =>
				this._entries.delete(i.entryId),
			)
			return this._entries.set(i.entryId, i), i
		}
		setStatusBarMessage(e, t) {
			let n = this._statusMessage.setMessage(e),
				r
			return (
				typeof t == "number"
					? (r = setTimeout(() => n.dispose(), t))
					: typeof t < "u" &&
						t.then(
							() => n.dispose(),
							() => n.dispose(),
						),
				new ye(() => {
					n.dispose(), clearTimeout(r)
				})
			)
		}
	}
var aT = class extends $ {
	constructor(t, n) {
		super()
		this._extHostDocumentsAndEditors = n
		this._onDidChangeTextEditorSelection = new E()
		this._onDidChangeTextEditorOptions = new E()
		this._onDidChangeTextEditorVisibleRanges = new E()
		this._onDidChangeTextEditorViewColumn = new E()
		this._onDidChangeTextEditorDiffInformation = new E()
		this._onDidChangeActiveTextEditor = new E()
		this._onDidChangeVisibleTextEditors = new E()
		this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event
		this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event
		this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event
		this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event
		this.onDidChangeTextEditorDiffInformation = this._onDidChangeTextEditorDiffInformation.event
		this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event
		this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event
		;(this._proxy = t.getProxy(M.MainThreadTextEditors)),
			this._register(
				this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((r) =>
					this._onDidChangeVisibleTextEditors.fire(r),
				),
			),
			this._register(
				this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((r) =>
					this._onDidChangeActiveTextEditor.fire(r),
				),
			)
	}
	getActiveTextEditor() {
		return this._extHostDocumentsAndEditors.activeEditor()
	}
	getVisibleTextEditors(t) {
		let n = this._extHostDocumentsAndEditors.allEditors()
		return t ? n : n.map((r) => r.value)
	}
	async showTextDocument(t, n, r) {
		let i
		typeof n == "number"
			? (i = { position: wt.from(n), preserveFocus: r })
			: typeof n == "object"
				? (i = {
						position: wt.from(n.viewColumn),
						preserveFocus: n.preserveFocus,
						selection: typeof n.selection == "object" ? H.from(n.selection) : void 0,
						pinned: typeof n.preview == "boolean" ? !n.preview : void 0,
					})
				: (i = { preserveFocus: !1 })
		let s = await this._proxy.$tryShowTextDocument(t.uri, i),
			a = s && this._extHostDocumentsAndEditors.getEditor(s)
		if (a) return a.value
		throw s
			? new Error(
					`Could NOT open editor for "${t.uri.toString()}" because another editor opened in the meantime.`,
				)
			: new Error(`Could NOT open editor for "${t.uri.toString()}".`)
	}
	createTextEditorDecorationType(t, n) {
		return new dC(this._proxy, t, n).value
	}
	$acceptEditorPropertiesChanged(t, n) {
		let r = this._extHostDocumentsAndEditors.getEditor(t)
		if (!r) throw new Error("unknown text editor")
		if ((n.options && r._acceptOptions(n.options), n.selections)) {
			let i = n.selections.selections.map(er.to)
			r._acceptSelections(i)
		}
		if (n.visibleRanges) {
			let i = Ye(n.visibleRanges.map(H.to))
			r._acceptVisibleRanges(i)
		}
		if (
			(n.options &&
				this._onDidChangeTextEditorOptions.fire({
					textEditor: r.value,
					options: { ...n.options, lineNumbers: Od.to(n.options.lineNumbers) },
				}),
			n.selections)
		) {
			let i = Td.fromValue(n.selections.source),
				s = n.selections.selections.map(er.to)
			this._onDidChangeTextEditorSelection.fire({ textEditor: r.value, selections: s, kind: i })
		}
		if (n.visibleRanges) {
			let i = Ye(n.visibleRanges.map(H.to))
			this._onDidChangeTextEditorVisibleRanges.fire({ textEditor: r.value, visibleRanges: i })
		}
	}
	$acceptEditorPositionData(t) {
		for (let n in t) {
			let r = this._extHostDocumentsAndEditors.getEditor(n)
			if (!r) throw new Error("Unknown text editor")
			let i = wt.to(t[n])
			r.value.viewColumn !== i &&
				(r._acceptViewColumn(i),
				this._onDidChangeTextEditorViewColumn.fire({ textEditor: r.value, viewColumn: i }))
		}
	}
	$acceptEditorDiffInformation(t, n) {
		let r = this._extHostDocumentsAndEditors.getEditor(t)
		if (!r) throw new Error("unknown text editor")
		if (!n) {
			r._acceptDiffInformation(void 0),
				this._onDidChangeTextEditorDiffInformation.fire({ textEditor: r.value, diffInformation: void 0 })
			return
		}
		let i = this,
			s = n.map((a) => {
				let l = b.revive(a.original),
					d = b.revive(a.modified),
					c = a.changes.map((u) => {
						let [m, f, h, g] = u,
							I
						return (
							m === f ? (I = 1) : h === g ? (I = 2) : (I = 3),
							{
								original: { startLineNumber: m, endLineNumberExclusive: f },
								modified: { startLineNumber: h, endLineNumberExclusive: g },
								kind: I,
							}
						)
					})
				return Object.freeze({
					documentVersion: a.documentVersion,
					original: l,
					modified: d,
					changes: c,
					get isStale() {
						return i._extHostDocumentsAndEditors.getDocument(d)?.version !== a.documentVersion
					},
				})
			})
		r._acceptDiffInformation(s),
			this._onDidChangeTextEditorDiffInformation.fire({ textEditor: r.value, diffInformation: s })
	}
	getDiffInformation(t) {
		return Promise.resolve(this._proxy.$getDiffInformation(t))
	}
}
var Rm = class {
	constructor(e) {
		;(this._actual = new fd(2)), (this._onDidChangeActiveColorTheme = new E())
	}
	get activeColorTheme() {
		return this._actual
	}
	$onColorThemeChange(e) {
		let t
		switch (e) {
			case "light":
				t = 1
				break
			case "hcDark":
				t = 3
				break
			case "hcLight":
				t = 4
				break
			default:
				t = 2
		}
		;(this._actual = new fd(t)), this._onDidChangeActiveColorTheme.fire(this._actual)
	}
	get onDidChangeActiveColorTheme() {
		return this._onDidChangeActiveColorTheme.event
	}
}
Rm = R([S(0, ie)], Rm)
var V$e = O("IExtHostTimeline"),
	lT = class {
		constructor(e, t) {
			this._providers = new Map()
			this._itemsBySourceAndUriMap = new Map()
			;(this._proxy = e.getProxy(M.MainThreadTimeline)),
				t.registerArgumentProcessor({
					processArgument: (n, r) => {
						if (n && n.$mid === 12)
							if (this._providers.get(n.source) && r && nt(r, "timeline")) {
								let i = n.uri === void 0 ? void 0 : b.revive(n.uri)
								return this._itemsBySourceAndUriMap.get(n.source)?.get(aU(i))?.get(n.handle)
							} else return
						return n
					},
				})
		}
		async $getTimeline(e, t, n, r) {
			return this._providers.get(e)?.provider.provideTimeline(b.revive(t), n, r)
		}
		registerTimelineProvider(e, t, n, r) {
			let i = new Q(),
				s = this.convertTimelineItem(t.id, r, i).bind(this),
				a
			t.onDidChange &&
				(a = t.onDidChange(
					(d) => this._proxy.$emitTimelineChangeEvent({ uri: void 0, reset: !0, ...d, id: t.id }),
					this,
				))
			let l = this._itemsBySourceAndUriMap
			return this.registerTimelineProviderCore(
				{
					...t,
					scheme: e,
					onDidChange: void 0,
					async provideTimeline(d, c, u) {
						c?.resetCache && (i.clear(), l.get(t.id)?.clear())
						let m = await t.provideTimeline(d, c, u)
						if (m == null) return
						let f = s(d, c)
						return { ...m, source: t.id, items: m.items.map(f) }
					},
					dispose() {
						for (let d of l.values()) d.get(t.id)?.clear()
						a?.dispose(), i.dispose()
					},
				},
				n,
			)
		}
		convertTimelineItem(e, t, n) {
			return (r, i) => {
				let s
				if (i?.cacheResults) {
					let a = this._itemsBySourceAndUriMap.get(e)
					a === void 0 && ((a = new Map()), this._itemsBySourceAndUriMap.set(e, a))
					let l = aU(r)
					;(s = a.get(l)), s === void 0 && ((s = new Map()), a.set(l, s))
				}
				return (a) => {
					let { iconPath: l, ...d } = a,
						c = `${e}|${a.id ?? a.timestamp}`
					s?.set(c, a)
					let u, m, f
					a.iconPath &&
						(l instanceof Vt
							? (f = { id: l.id, color: l.color })
							: b.isUri(l)
								? ((u = l), (m = l))
								: ({ light: u, dark: m } = l))
					let h
					return (
						en.isMarkdownString(d.tooltip)
							? (h = Se.from(d.tooltip))
							: we(d.tooltip)
								? (h = d.tooltip)
								: en.isMarkdownString(d.detail)
									? (console.warn(
											"Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
										),
										(h = Se.from(d.detail)))
									: we(d.detail) &&
										(console.warn(
											"Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
										),
										(h = d.detail)),
						{
							...d,
							id: d.id ?? void 0,
							handle: c,
							source: e,
							command: a.command ? t.toInternal(a.command, n) : void 0,
							icon: u,
							iconDark: m,
							themeIcon: f,
							tooltip: h,
							accessibilityInformation: a.accessibilityInformation,
						}
					)
				}
			}
		}
		registerTimelineProviderCore(e, t) {
			if (this._providers.get(e.id)) throw new Error(`Timeline Provider ${e.id} already exists.`)
			return (
				this._proxy.$registerTimelineProvider({ id: e.id, label: e.label, scheme: e.scheme }),
				this._providers.set(e.id, { provider: e, extension: t }),
				q(() => {
					for (let r of this._itemsBySourceAndUriMap.values()) r.get(e.id)?.clear()
					this._providers.delete(e.id), this._proxy.$unregisterTimelineProvider(e.id), e.dispose()
				})
			)
		}
	}
function aU(o) {
	return o?.toString()
}
var jB = { IconContribution: "base.contributions.icons" },
	GB
;((e) => {
	function o(t, n) {
		let r = t.defaults
		for (; Yt.isThemeIcon(r); ) {
			let i = Am.getIcon(r.id)
			if (!i) return
			r = i.defaults
		}
		return r
	}
	e.getDefinition = o
})((GB ||= {}))
var QB
;((t) => {
	function o(n) {
		return {
			weight: n.weight,
			style: n.style,
			src: n.src.map((r) => ({ format: r.format, location: r.location.toString() })),
		}
	}
	t.toJSONObject = o
	function e(n) {
		let r = (i) => (we(i) ? i : void 0)
		if (n && Array.isArray(n.src) && n.src.every((i) => we(i.format) && we(i.location)))
			return {
				weight: r(n.weight),
				style: r(n.style),
				src: n.src.map((i) => ({ format: i.format, location: b.parse(i.location) })),
			}
	}
	t.fromJSONObject = e
})((QB ||= {}))
var JB = /^([\w_-]+)$/
var XB = p("schema.fontId.formatError", "The font ID must only contain letters, numbers, underscores and dashes."),
	K1 = class {
		constructor() {
			this._onDidChange = new E()
			this.onDidChange = this._onDidChange.event
			this.iconSchema = {
				definitions: {
					icons: {
						type: "object",
						properties: {
							fontId: {
								type: "string",
								description: p(
									"iconDefinition.fontId",
									"The id of the font to use. If not set, the font that is defined first is used.",
								),
								pattern: JB.source,
								patternErrorMessage: XB,
							},
							fontCharacter: {
								type: "string",
								description: p(
									"iconDefinition.fontCharacter",
									"The font character associated with the icon definition.",
								),
							},
						},
						additionalProperties: !1,
						defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }],
					},
				},
				type: "object",
				properties: {},
			}
			this.iconReferenceSchema = {
				type: "string",
				pattern: `^${Yt.iconNameExpression}$`,
				enum: [],
				enumDescriptions: [],
			}
			;(this.iconsById = {}), (this.iconFontsById = {})
		}
		registerIcon(e, t, n, r) {
			let i = this.iconsById[e]
			if (i) {
				if (n && !i.description) {
					;(i.description = n), (this.iconSchema.properties[e].markdownDescription = `${n} $(${e})`)
					let l = this.iconReferenceSchema.enum.indexOf(e)
					l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = n), this._onDidChange.fire()
				}
				return i
			}
			let s = { id: e, description: n, defaults: t, deprecationMessage: r }
			this.iconsById[e] = s
			let a = { $ref: "#/definitions/icons" }
			return (
				r && (a.deprecationMessage = r),
				n && (a.markdownDescription = `${n}: $(${e})`),
				(this.iconSchema.properties[e] = a),
				this.iconReferenceSchema.enum.push(e),
				this.iconReferenceSchema.enumDescriptions.push(n || ""),
				this._onDidChange.fire(),
				{ id: e }
			)
		}
		deregisterIcon(e) {
			delete this.iconsById[e], delete this.iconSchema.properties[e]
			let t = this.iconReferenceSchema.enum.indexOf(e)
			t !== -1 &&
				(this.iconReferenceSchema.enum.splice(t, 1), this.iconReferenceSchema.enumDescriptions.splice(t, 1)),
				this._onDidChange.fire()
		}
		getIcons() {
			return Object.keys(this.iconsById).map((e) => this.iconsById[e])
		}
		getIcon(e) {
			return this.iconsById[e]
		}
		getIconSchema() {
			return this.iconSchema
		}
		getIconReferenceSchema() {
			return this.iconReferenceSchema
		}
		registerIconFont(e, t) {
			let n = this.iconFontsById[e]
			return n || ((this.iconFontsById[e] = t), this._onDidChange.fire(), t)
		}
		deregisterIconFont(e) {
			delete this.iconFontsById[e]
		}
		getIconFont(e) {
			return this.iconFontsById[e]
		}
		toString() {
			let e = (i, s) => i.id.localeCompare(s.id),
				t = (i) => {
					for (; Yt.isThemeIcon(i.defaults); ) i = this.iconsById[i.defaults.id]
					return `codicon codicon-${i ? i.id : ""}`
				},
				n = []
			n.push(
				"| preview     | identifier                        | default codicon ID                | description",
			),
				n.push(
					"| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |",
				)
			let r = Object.keys(this.iconsById).map((i) => this.iconsById[i])
			for (let i of r.filter((s) => !!s.description).sort(e))
				n.push(
					`|<i class="${t(i)}"></i>|${i.id}|${Yt.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ""}|`,
				)
			n.push("| preview     | identifier                        "),
				n.push("| ----------- | --------------------------------- |")
			for (let i of r.filter((s) => !Yt.isThemeIcon(s.defaults)).sort(e))
				n.push(`|<i class="${t(i)}"></i>|${i.id}|`)
			return n.join(`
`)
		}
	},
	Am = new K1()
yt.add(jB.IconContribution, Am)
function Bh(o, e, t, n) {
	return Am.registerIcon(o, e, t, n)
}
function YB() {
	let o = AL()
	for (let e in o) {
		let t = "\\" + o[e].toString(16)
		Am.registerIcon(e, { fontCharacter: t })
	}
}
YB()
var dU = "vscode://schemas/icons",
	cU = yt.as(ad.JSONContribution)
cU.registerSchema(dU, Am.getIconSchema())
var lU = new Wn(() => cU.notifySchemaChanged(dU), 200)
Am.onDidChange(() => {
	lU.isScheduled() || lU.schedule()
})
var t6e = Bh("widget-close", ce.close, p("widgetClose", "Icon for the close action in widgets.")),
	n6e = Bh("goto-previous-location", ce.arrowUp, p("previousChangeIcon", "Icon for goto previous editor location.")),
	r6e = Bh("goto-next-location", ce.arrowDown, p("nextChangeIcon", "Icon for goto next editor location.")),
	o6e = Yt.modify(ce.sync, "spin"),
	i6e = Yt.modify(ce.loading, "spin")
var b6e = p("views log", "Views"),
	y6e = Bh("default-view-icon", ce.window, p("defaultViewIcon", "Default view icon.")),
	Q1
;((t) => (
	(t.ViewContainersRegistry = "workbench.registry.view.containers"), (t.ViewsRegistry = "workbench.registry.view")
))((Q1 ||= {}))
var j1 = class extends $ {
	constructor() {
		super(...arguments)
		this._onDidRegister = this._register(new E())
		this.onDidRegister = this._onDidRegister.event
		this._onDidDeregister = this._register(new E())
		this.onDidDeregister = this._onDidDeregister.event
		this.viewContainers = new Map()
		this.defaultViewContainers = []
	}
	get all() {
		return [...this.viewContainers.values()].flat()
	}
	registerViewContainer(t, n, r) {
		let i = this.get(t.id)
		if (i) return i
		let s = t
		return (
			(s.openCommandActionDescriptor = r?.doNotRegisterOpenCommand
				? void 0
				: (s.openCommandActionDescriptor ?? { id: s.id })),
			aE(this.viewContainers, n, []).push(s),
			r?.isDefault && this.defaultViewContainers.push(s),
			this._onDidRegister.fire({ viewContainer: s, viewContainerLocation: n }),
			s
		)
	}
	deregisterViewContainer(t) {
		for (let n of this.viewContainers.keys()) {
			let r = this.viewContainers.get(n),
				i = r?.indexOf(t)
			if (i !== -1) {
				r?.splice(i, 1),
					r.length === 0 && this.viewContainers.delete(n),
					this._onDidDeregister.fire({ viewContainer: t, viewContainerLocation: n })
				return
			}
		}
	}
	get(t) {
		return this.all.filter((n) => n.id === t)[0]
	}
	getViewContainers(t) {
		return [...(this.viewContainers.get(t) || [])]
	}
	getViewContainerLocation(t) {
		return [...this.viewContainers.keys()].filter(
			(n) => this.getViewContainers(n).filter((r) => r?.id === t.id).length > 0,
		)[0]
	}
	getDefaultViewContainer(t) {
		return this.defaultViewContainers.find((n) => this.getViewContainerLocation(n) === t)
	}
}
yt.add(Q1.ViewContainersRegistry, new j1())
function ZB(o, e) {
	let t = o.group ?? "9_more",
		n = e.group ?? "9_more"
	return t !== n ? t.localeCompare(n) : (o.order ?? 5) - (e.order ?? 5)
}
var G1 = class extends $ {
	constructor() {
		super(...arguments)
		this._onViewsRegistered = this._register(new E())
		this.onViewsRegistered = this._onViewsRegistered.event
		this._onViewsDeregistered = this._register(new E())
		this.onViewsDeregistered = this._onViewsDeregistered.event
		this._onDidChangeContainer = this._register(new E())
		this.onDidChangeContainer = this._onDidChangeContainer.event
		this._onDidChangeViewWelcomeContent = this._register(new E())
		this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event
		this._viewContainers = []
		this._views = new Map()
		this._viewWelcomeContents = new fc()
	}
	registerViews(t, n) {
		this.registerViews2([{ views: t, viewContainer: n }])
	}
	registerViews2(t) {
		t.forEach(({ views: n, viewContainer: r }) => this.addViews(n, r)), this._onViewsRegistered.fire(t)
	}
	deregisterViews(t, n) {
		let r = this.removeViews(t, n)
		r.length && this._onViewsDeregistered.fire({ views: r, viewContainer: n })
	}
	moveViews(t, n) {
		for (let r of this._views.keys())
			if (r !== n) {
				let i = this.removeViews(t, r)
				i.length && (this.addViews(i, n), this._onDidChangeContainer.fire({ views: i, from: r, to: n }))
			}
	}
	getViews(t) {
		return this._views.get(t) || []
	}
	getView(t) {
		for (let n of this._viewContainers) {
			let r = (this._views.get(n) || []).filter((i) => i.id === t)[0]
			if (r) return r
		}
		return null
	}
	getViewContainer(t) {
		for (let n of this._viewContainers) if ((this._views.get(n) || []).filter((i) => i.id === t)[0]) return n
		return null
	}
	registerViewWelcomeContent(t, n) {
		return (
			this._viewWelcomeContents.add(t, n),
			this._onDidChangeViewWelcomeContent.fire(t),
			q(() => {
				this._viewWelcomeContents.delete(t, n), this._onDidChangeViewWelcomeContent.fire(t)
			})
		)
	}
	registerViewWelcomeContent2(t, n) {
		let r = new Map()
		for (let [i, s] of n)
			this._viewWelcomeContents.add(t, s),
				r.set(
					i,
					q(() => {
						this._viewWelcomeContents.delete(t, s), this._onDidChangeViewWelcomeContent.fire(t)
					}),
				)
		return this._onDidChangeViewWelcomeContent.fire(t), r
	}
	getViewWelcomeContent(t) {
		let n = []
		return this._viewWelcomeContents.forEach(t, (r) => n.push(r)), n.sort(ZB)
	}
	addViews(t, n) {
		let r = this._views.get(n)
		r || ((r = []), this._views.set(n, r), this._viewContainers.push(n))
		for (let i of t) {
			if (this.getView(i.id) !== null)
				throw new Error(p("duplicateId", "A view with id '{0}' is already registered", i.id))
			r.push(i)
		}
	}
	removeViews(t, n) {
		let r = this._views.get(n)
		if (!r) return []
		let i = [],
			s = []
		for (let a of r) t.includes(a) ? i.push(a) : s.push(a)
		return (
			i.length &&
				(s.length
					? this._views.set(n, s)
					: (this._views.delete(n), this._viewContainers.splice(this._viewContainers.indexOf(n), 1))),
			i
		)
	}
}
yt.add(Q1.ViewsRegistry, new G1())
var I6e = O("viewDescriptorService")
var wo = class extends Error {
	constructor(t) {
		super(p("treeView.notRegistered", "No tree view with id '{0}' registered.", t))
		this.name = "NoTreeViewError"
	}
	static is(t) {
		return !!t && t.name === "NoTreeViewError"
	}
}
var dT = class {
	constructor() {
		this._dragOperations = new Map()
	}
	removeDragOperationTransfer(e) {
		if (e && this._dragOperations.has(e)) {
			let t = this._dragOperations.get(e)
			return this._dragOperations.delete(e), t
		}
	}
	addDragOperationTransfer(e, t) {
		this._dragOperations.set(e, t)
	}
}
function uU(o, e) {
	if (we(o)) return { label: o }
	if (o && typeof o == "object" && typeof o.label == "string") {
		let t
		return (
			Array.isArray(o.highlights) &&
				((t = o.highlights.filter((n) => n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number")),
				(t = t.length ? t : void 0)),
			{ label: o.label, highlights: t }
		)
	}
}
var cT = class extends $ {
		constructor(t, n, r) {
			super()
			this._proxy = t
			this.commands = n
			this.logService = r
			this.treeViews = new Map()
			this.treeDragAndDropService = new dT()
			function i(s) {
				return s && s.$treeViewId && (s.$treeItemHandle || s.$selectedTreeItems || s.$focusedTreeItem)
			}
			n.registerArgumentProcessor({
				processArgument: (s) =>
					i(s)
						? this.convertArgument(s)
						: Array.isArray(s) && s.length > 0
							? s.map((a) => (i(a) ? this.convertArgument(a) : a))
							: s,
			})
		}
		registerTreeDataProvider(t, n, r) {
			let i = this.createTreeView(t, { treeDataProvider: n }, r)
			return { dispose: () => i.dispose() }
		}
		createTreeView(t, n, r) {
			if (!n || !n.treeDataProvider) throw new Error("Options with treeDataProvider is mandatory")
			let i = n.dragAndDropController?.dropMimeTypes ?? [],
				s = n.dragAndDropController?.dragMimeTypes ?? [],
				a = !!n.dragAndDropController?.handleDrag,
				l = !!n.dragAndDropController?.handleDrop,
				d = this.createExtHostTreeView(t, n, r),
				c = {
					showCollapseAll: !!n.showCollapseAll,
					canSelectMany: !!n.canSelectMany,
					dropMimeTypes: i,
					dragMimeTypes: s,
					hasHandleDrag: a,
					hasHandleDrop: l,
					manuallyManageCheckboxes: !!n.manageCheckboxStateManually,
				},
				u = this._proxy.$registerTreeViewDataProvider(t, c),
				m = {
					get onDidCollapseElement() {
						return d.onDidCollapseElement
					},
					get onDidExpandElement() {
						return d.onDidExpandElement
					},
					get selection() {
						return d.selectedElements
					},
					get onDidChangeSelection() {
						return d.onDidChangeSelection
					},
					get activeItem() {
						return F(r, "treeViewActiveItem"), d.focusedElement
					},
					get onDidChangeActiveItem() {
						return F(r, "treeViewActiveItem"), d.onDidChangeActiveItem
					},
					get visible() {
						return d.visible
					},
					get onDidChangeVisibility() {
						return d.onDidChangeVisibility
					},
					get onDidChangeCheckboxState() {
						return d.onDidChangeCheckboxState
					},
					get message() {
						return d.message
					},
					set message(f) {
						Gr(f) && F(r, "treeViewMarkdownMessage"), (d.message = f)
					},
					get title() {
						return d.title
					},
					set title(f) {
						d.title = f
					},
					get description() {
						return d.description
					},
					set description(f) {
						d.description = f
					},
					get badge() {
						return d.badge
					},
					set badge(f) {
						f !== void 0 && lD.isViewBadge(f)
							? (d.badge = { value: Math.floor(Math.abs(f.value)), tooltip: f.tooltip })
							: f === void 0 && (d.badge = void 0)
					},
					reveal: (f, h) => d.reveal(f, h),
					dispose: async () => {
						await u, this.treeViews.delete(t), d.dispose()
					},
				}
			return this._register(m), m
		}
		async $getChildren(t, n) {
			let r = this.treeViews.get(t)
			if (!r) return Promise.reject(new wo(t))
			if (!n) {
				let s = await r.getChildren()
				return s ? [[0, ...s]] : void 0
			}
			let i = []
			for (let s = 0; s < n.length; s++) {
				let a = n[s],
					l = await r.getChildren(a)
				l && i.push([s, ...l])
			}
			return i
		}
		async $handleDrop(t, n, r, i, s, a, l, d) {
			let c = this.treeViews.get(t)
			if (!c) return Promise.reject(new wo(t))
			let u = Ld.toDataTransfer(r, async (m) => (await this._proxy.$resolveDropFileData(t, n, m)).buffer)
			return l === t && d && (await this.addAdditionalTransferItems(u, c, d, s, a)), c.onDrop(u, i, s)
		}
		async addAdditionalTransferItems(t, n, r, i, s) {
			let a = this.treeDragAndDropService.removeDragOperationTransfer(s)
			if (a)
				(await a)?.forEach((l, d) => {
					l && t.set(d, l)
				})
			else if (s && n.handleDrag) {
				let l = n.handleDrag(r, t, i)
				this.treeDragAndDropService.addDragOperationTransfer(s, l), await l
			}
			return t
		}
		async $handleDrag(t, n, r, i) {
			let s = this.treeViews.get(t)
			if (!s) return Promise.reject(new wo(t))
			let a = await this.addAdditionalTransferItems(new bo(), s, n, i, r)
			if (!(!a || i.isCancellationRequested)) return Ld.from(a)
		}
		async $hasResolve(t) {
			let n = this.treeViews.get(t)
			if (!n) throw new wo(t)
			return n.hasResolve
		}
		$resolve(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new wo(t)
			return i.resolveTreeItem(n, r)
		}
		$setExpanded(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new wo(t)
			i.setExpanded(n, r)
		}
		$setSelectionAndFocus(t, n, r) {
			let i = this.treeViews.get(t)
			if (!i) throw new wo(t)
			i.setSelectionAndFocus(n, r)
		}
		$setVisible(t, n) {
			let r = this.treeViews.get(t)
			if (!r) {
				if (!n) return
				throw new wo(t)
			}
			r.setVisible(n)
		}
		$changeCheckboxState(t, n) {
			let r = this.treeViews.get(t)
			if (!r) throw new wo(t)
			r.setCheckboxState(n)
		}
		createExtHostTreeView(t, n, r) {
			let i = this._register(new J1(t, n, this._proxy, this.commands.converter, this.logService, r))
			return this.treeViews.set(t, i), i
		}
		convertArgument(t) {
			let n = this.treeViews.get(t.$treeViewId)
			return n && "$treeItemHandle" in t
				? n.getExtensionElement(t.$treeItemHandle)
				: n && "$focusedTreeItem" in t && t.$focusedTreeItem
					? n.focusedElement
					: null
		}
	},
	J1 = class o extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.viewId = t
			this.proxy = r
			this.commands = i
			this.logService = s
			this.extension = a
			this.roots = void 0
			this.elements = new Map()
			this.nodes = new Map()
			this._visible = !1
			this._selectedHandles = []
			this._focusedHandle = void 0
			this._onDidExpandElement = this._register(new E())
			this.onDidExpandElement = this._onDidExpandElement.event
			this._onDidCollapseElement = this._register(new E())
			this.onDidCollapseElement = this._onDidCollapseElement.event
			this._onDidChangeSelection = this._register(new E())
			this.onDidChangeSelection = this._onDidChangeSelection.event
			this._onDidChangeActiveItem = this._register(new E())
			this.onDidChangeActiveItem = this._onDidChangeActiveItem.event
			this._onDidChangeVisibility = this._register(new E())
			this.onDidChangeVisibility = this._onDidChangeVisibility.event
			this._onDidChangeCheckboxState = this._register(new E())
			this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event
			this._onDidChangeData = this._register(new E())
			this.refreshPromise = Promise.resolve()
			this.refreshQueue = Promise.resolve()
			this._message = ""
			this._title = ""
			this._refreshCancellationSource = new _e()
			if (a.contributes && a.contributes.views)
				for (let u in a.contributes.views)
					for (let m of a.contributes.views[u]) m.id === t && (this._title = m.name)
			;(this.dataProvider = n.treeDataProvider),
				(this.dndController = n.dragAndDropController),
				this.dataProvider.onDidChangeTreeData &&
					this._register(
						this.dataProvider.onDidChangeTreeData((u) => {
							;(Array.isArray(u) && u.length === 0) ||
								this._onDidChangeData.fire({ message: !1, element: u })
						}),
					)
			let l,
				d,
				c = Ee.debounce(
					this._onDidChangeData.event,
					(u, m) => (
						u || (u = { message: !1, elements: [] }),
						m.element !== !1 &&
							(l ||
								((l = new Promise((f) => (d = f))),
								(this.refreshPromise = this.refreshPromise.then(() => l))),
							Array.isArray(m.element) ? u.elements.push(...m.element) : u.elements.push(m.element)),
						m.message && (u.message = !0),
						u
					),
					200,
					!0,
				)
			this._register(
				c(({ message: u, elements: m }) => {
					m.length &&
						(this.refreshQueue = this.refreshQueue.then(() => {
							let f = d
							return (l = null), this.refresh(m).then(() => f())
						})),
						u && this.proxy.$setMessage(this.viewId, Se.fromStrict(this._message) ?? "")
				}),
			)
		}
		static {
			this.LABEL_HANDLE_PREFIX = "0"
		}
		static {
			this.ID_HANDLE_PREFIX = "1"
		}
		get visible() {
			return this._visible
		}
		get selectedElements() {
			return this._selectedHandles.map((t) => this.getExtensionElement(t)).filter((t) => !bt(t))
		}
		get focusedElement() {
			return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0
		}
		async getChildren(t) {
			let n = t ? this.getExtensionElement(t) : void 0
			if (t && !n) return this.logService.error(`No tree item with id '${t}' found.`), Promise.resolve([])
			let r = this.getChildrenNodes(t)
			return r || (r = await this.fetchChildrenNodes(n)), r ? r.map((i) => i.item) : void 0
		}
		getExtensionElement(t) {
			return this.elements.get(t)
		}
		reveal(t, n) {
			n = n || { select: !0, focus: !1 }
			let r = bt(n.select) ? !0 : n.select,
				i = bt(n.focus) ? !1 : n.focus,
				s = bt(n.expand) ? !1 : n.expand
			return typeof this.dataProvider.getParent != "function"
				? Promise.reject(
						new Error(
							"Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method",
						),
					)
				: t
					? this.refreshPromise
							.then(() => this.resolveUnknownParentChain(t))
							.then(
								(a) =>
									this.resolveTreeNode(t, a[a.length - 1]).then((l) =>
										this.proxy.$reveal(
											this.viewId,
											{ item: l.item, parentChain: a.map((d) => d.item) },
											{ select: r, focus: i, expand: s },
										),
									),
								(a) => this.logService.error(a),
							)
					: this.proxy.$reveal(this.viewId, void 0, { select: r, focus: i, expand: s })
		}
		get message() {
			return this._message
		}
		set message(t) {
			;(this._message = t), this._onDidChangeData.fire({ message: !0, element: !1 })
		}
		get title() {
			return this._title
		}
		set title(t) {
			;(this._title = t), this.proxy.$setTitle(this.viewId, t, this._description)
		}
		get description() {
			return this._description
		}
		set description(t) {
			;(this._description = t), this.proxy.$setTitle(this.viewId, this._title, t)
		}
		get badge() {
			return this._badge
		}
		set badge(t) {
			;(this._badge?.value === t?.value && this._badge?.tooltip === t?.tooltip) ||
				((this._badge = Og.from(t)), this.proxy.$setBadge(this.viewId, t))
		}
		setExpanded(t, n) {
			let r = this.getExtensionElement(t)
			r &&
				(n
					? this._onDidExpandElement.fire(Object.freeze({ element: r }))
					: this._onDidCollapseElement.fire(Object.freeze({ element: r })))
		}
		setSelectionAndFocus(t, n) {
			let r = !mn(this._selectedHandles, t)
			this._selectedHandles = t
			let i = this._focusedHandle !== n
			;(this._focusedHandle = n),
				r && this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements })),
				i && this._onDidChangeActiveItem.fire(Object.freeze({ activeItem: this.focusedElement }))
		}
		setVisible(t) {
			t !== this._visible &&
				((this._visible = t), this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible })))
		}
		async setCheckboxState(t) {
			let n = (
				await Promise.all(
					t.map(async (r) => {
						let i = this.getExtensionElement(r.treeItemHandle)
						return i
							? {
									extensionItem: i,
									treeItem: await this.dataProvider.getTreeItem(i),
									newState: r.newState ? 1 : 0,
								}
							: Promise.resolve(void 0)
					}),
				)
			).filter((r) => r !== void 0)
			n.forEach((r) => {
				r.treeItem.checkboxState = r.newState ? 1 : 0
			}),
				this._onDidChangeCheckboxState.fire({ items: n.map((r) => [r.extensionItem, r.newState]) })
		}
		async handleDrag(t, n, r) {
			let i = []
			for (let s of t) {
				let a = this.getExtensionElement(s)
				a && i.push(a)
			}
			if (!(!this.dndController?.handleDrag || i.length === 0))
				return await this.dndController.handleDrag(i, n, r), n
		}
		get hasHandleDrag() {
			return !!this.dndController?.handleDrag
		}
		async onDrop(t, n, r) {
			let i = n ? this.getExtensionElement(n) : void 0
			if (!((!i && n) || !this.dndController?.handleDrop))
				return Jt(() => (this.dndController?.handleDrop ? this.dndController.handleDrop(i, t, r) : void 0))
		}
		get hasResolve() {
			return !!this.dataProvider.resolveTreeItem
		}
		async resolveTreeItem(t, n) {
			if (!this.dataProvider.resolveTreeItem) return
			let r = this.elements.get(t)
			if (r) {
				let i = this.nodes.get(r)
				if (i) {
					let s = (await this.dataProvider.resolveTreeItem(i.extensionItem, r, n)) ?? i.extensionItem
					return (
						this.validateTreeItem(s),
						(i.item.tooltip = this.getTooltip(s.tooltip)),
						(i.item.command = this.getCommand(i.disposableStore, s.command)),
						i.item
					)
				}
			}
		}
		resolveUnknownParentChain(t) {
			return this.resolveParent(t).then((n) =>
				n
					? this.resolveUnknownParentChain(n).then((r) =>
							this.resolveTreeNode(n, r[r.length - 1]).then((i) => (r.push(i), r)),
						)
					: Promise.resolve([]),
			)
		}
		resolveParent(t) {
			let n = this.nodes.get(t)
			return n
				? Promise.resolve(n.parent ? this.elements.get(n.parent.item.handle) : void 0)
				: Jt(() => this.dataProvider.getParent(t))
		}
		resolveTreeNode(t, n) {
			let r = this.nodes.get(t)
			return r
				? Promise.resolve(r)
				: Jt(() => this.dataProvider.getTreeItem(t))
						.then((i) => this.createHandle(t, i, n, !0))
						.then((i) =>
							this.getChildren(n ? n.item.handle : void 0).then(() => {
								let s = this.getExtensionElement(i)
								if (s) {
									let a = this.nodes.get(s)
									if (a) return Promise.resolve(a)
								}
								throw new Error(
									`Cannot resolve tree item for element ${i} from extension ${this.extension.identifier.value}`,
								)
							}),
						)
		}
		getChildrenNodes(t) {
			if (t) {
				let n
				if (typeof t == "string") {
					let r = this.getExtensionElement(t)
					n = r ? this.nodes.get(r) : void 0
				} else n = t
				return (n && n.children) || void 0
			}
			return this.roots
		}
		async fetchChildrenNodes(t) {
			this.clearChildren(t)
			let n = new _e(this._refreshCancellationSource.token)
			try {
				let r = t ? this.nodes.get(t) : void 0,
					i = await this.dataProvider.getChildren(t)
				if (n.token.isCancellationRequested) return
				let s = Ye(i || []),
					a = await Promise.all(Ye(s).map((d) => this.dataProvider.getTreeItem(d)))
				if (n.token.isCancellationRequested) return
				let l = a.map((d, c) => (d ? this.createAndRegisterTreeNode(s[c], d, r) : null))
				return Ye(l)
			} finally {
				n.dispose()
			}
		}
		refresh(t) {
			if (t.some((r) => !r))
				return (
					this._refreshCancellationSource.dispose(!0),
					(this._refreshCancellationSource = new _e()),
					this.clearAll(),
					this.proxy.$refresh(this.viewId)
				)
			{
				let r = this.getHandlesToRefresh(t)
				if (r.length) return this.refreshHandles(r)
			}
			return Promise.resolve(void 0)
		}
		getHandlesToRefresh(t) {
			let n = new Set(),
				r = t.map((s) => this.nodes.get(s))
			for (let s of r)
				if (s && !n.has(s.item.handle)) {
					let a = s
					for (
						;
						a &&
						a.parent &&
						r.findIndex((l) => a && a.parent && l && l.item.handle === a.parent.item.handle) === -1;

					) {
						let l = this.elements.get(a.parent.item.handle)
						a = l ? this.nodes.get(l) : void 0
					}
					a && !a.parent && n.add(s.item.handle)
				}
			let i = []
			return (
				n.forEach((s) => {
					let a = this.elements.get(s)
					if (a) {
						let l = this.nodes.get(a)
						l && (!l.parent || !n.has(l.parent.item.handle)) && i.push(s)
					}
				}),
				i
			)
		}
		refreshHandles(t) {
			let n = {}
			return Promise.all(
				t.map((r) =>
					this.refreshNode(r).then((i) => {
						i && (n[r] = i.item)
					}),
				),
			).then(() => (Object.keys(n).length ? this.proxy.$refresh(this.viewId, n) : void 0))
		}
		refreshNode(t) {
			let n = this.getExtensionElement(t)
			if (n) {
				let r = this.nodes.get(n)
				if (r)
					return (
						this.clearChildren(n),
						Jt(() => this.dataProvider.getTreeItem(n)).then((i) => {
							if (i) {
								let s = this.createTreeNode(n, i, r.parent)
								return this.updateNodeCache(n, s, r, r.parent), r.dispose(), s
							}
							return null
						})
					)
			}
			return Promise.resolve(null)
		}
		createAndRegisterTreeNode(t, n, r) {
			let i = this.createTreeNode(t, n, r)
			if (n.id && this.elements.has(i.item.handle))
				throw new Error(p("treeView.duplicateElement", "Element with id {0} is already registered", n.id))
			return this.addNodeToCache(t, i), this.addNodeToParentCache(i, r), i
		}
		getTooltip(t) {
			return en.isMarkdownString(t) ? Se.from(t) : t
		}
		getCommand(t, n) {
			return n ? { ...this.commands.toInternal(n, t), originalId: n.command } : void 0
		}
		getCheckbox(t) {
			if (t.checkboxState === void 0) return
			let n, r, i
			return (
				typeof t.checkboxState == "number"
					? (n = t.checkboxState)
					: ((n = t.checkboxState.state),
						(r = t.checkboxState.tooltip),
						(i = t.checkboxState.accessibilityInformation)),
				{ isChecked: n === 1, tooltip: r, accessibilityInformation: i }
			)
		}
		validateTreeItem(t) {
			if (!Ti.isTreeItem(t, this.extension))
				throw new Error(`Extension ${this.extension.identifier.value} has provided an invalid tree item.`)
		}
		createTreeNode(t, n, r) {
			this.validateTreeItem(n)
			let i = this._register(new Q()),
				s = this.createHandle(t, n, r),
				a = this.getLightIconPath(n)
			return {
				item: {
					handle: s,
					parentHandle: r ? r.item.handle : void 0,
					label: uU(n.label, this.extension),
					description: n.description,
					resourceUri: n.resourceUri,
					tooltip: this.getTooltip(n.tooltip),
					command: this.getCommand(i, n.command),
					contextValue: n.contextValue,
					icon: a,
					iconDark: this.getDarkIconPath(n) || a,
					themeIcon: this.getThemeIcon(n),
					collapsibleState: bt(n.collapsibleState) ? 0 : n.collapsibleState,
					accessibilityInformation: n.accessibilityInformation,
					checkbox: this.getCheckbox(n),
				},
				extensionItem: n,
				parent: r,
				children: void 0,
				disposableStore: i,
				dispose() {
					i.dispose()
				},
			}
		}
		getThemeIcon(t) {
			return t.iconPath instanceof Vt ? t.iconPath : void 0
		}
		createHandle(t, { id: n, label: r, resourceUri: i }, s, a) {
			if (n) return `${o.ID_HANDLE_PREFIX}/${n}`
			let l = uU(r, this.extension),
				d = s ? s.item.handle : o.LABEL_HANDLE_PREFIX,
				c = l ? l.label : i ? Ht(i) : ""
			c = c.indexOf("/") !== -1 ? c.replace("/", "//") : c
			let u = this.nodes.has(t) ? this.nodes.get(t).item.handle : void 0,
				m = this.getChildrenNodes(s) || [],
				f,
				h = 0
			do {
				if (((f = `${d}/${h}:${c}`), a || !this.elements.has(f) || u === f)) break
				h++
			} while (h <= m.length)
			return f
		}
		getLightIconPath(t) {
			if (t.iconPath && !(t.iconPath instanceof Vt))
				return typeof t.iconPath == "string" || b.isUri(t.iconPath)
					? this.getIconPath(t.iconPath)
					: this.getIconPath(t.iconPath.light)
		}
		getDarkIconPath(t) {
			if (t.iconPath && !(t.iconPath instanceof Vt) && t.iconPath.dark) return this.getIconPath(t.iconPath.dark)
		}
		getIconPath(t) {
			return b.isUri(t) ? t : b.file(t)
		}
		addNodeToCache(t, n) {
			this.elements.set(n.item.handle, t), this.nodes.set(t, n)
		}
		updateNodeCache(t, n, r, i) {
			this.elements.delete(n.item.handle),
				this.nodes.delete(t),
				n.item.handle !== r.item.handle && this.elements.delete(r.item.handle),
				this.addNodeToCache(t, n)
			let s = this.getChildrenNodes(i) || [],
				a = s.filter((l) => l.item.handle === r.item.handle)[0]
			a && s.splice(s.indexOf(a), 1, n)
		}
		addNodeToParentCache(t, n) {
			n
				? (n.children || (n.children = []), n.children.push(t))
				: (this.roots || (this.roots = []), this.roots.push(t))
		}
		clearChildren(t) {
			if (t) {
				let n = this.nodes.get(t)
				if (n) {
					if (n.children)
						for (let r of n.children) {
							let i = this.elements.get(r.item.handle)
							i && this.clear(i)
						}
					n.children = void 0
				}
			} else this.clearAll()
		}
		clear(t) {
			let n = this.nodes.get(t)
			if (n) {
				if (n.children)
					for (let r of n.children) {
						let i = this.elements.get(r.item.handle)
						i && this.clear(i)
					}
				this.nodes.delete(t), this.elements.delete(n.item.handle), n.dispose()
			}
		}
		clearAll() {
			;(this.roots = void 0), this.elements.clear(), this.nodes.forEach((t) => t.dispose()), this.nodes.clear()
		}
		dispose() {
			super.dispose(),
				this._refreshCancellationSource.dispose(),
				this.clearAll(),
				this.proxy.$disposeTree(this.viewId)
		}
	}
var uT = class o {
	constructor(e) {
		this._openers = new Map()
		this._proxy = e.getProxy(M.MainThreadUriOpeners)
	}
	static {
		this.supportedSchemes = new Set([W.http, W.https])
	}
	registerExternalUriOpener(e, t, n, r) {
		if (this._openers.has(t)) throw new Error(`Opener with id '${t}' already registered`)
		let i = r.schemes.find((s) => !o.supportedSchemes.has(s))
		if (i) throw new Error(`Scheme '${i}' is not supported. Only http and https are currently supported.`)
		return (
			this._openers.set(t, n),
			this._proxy.$registerUriOpener(t, r.schemes, e, r.label),
			q(() => {
				this._openers.delete(t), this._proxy.$unregisterUriOpener(t)
			})
		)
	}
	async $canOpenUri(e, t, n) {
		let r = this._openers.get(e)
		if (!r) throw new Error(`Unknown opener with id: ${e}`)
		let i = b.revive(t)
		return r.canOpenExternalUri(i, n)
	}
	async $openUri(e, t, n) {
		let r = this._openers.get(e)
		if (!r) throw new Error(`Unknown opener id: '${e}'`)
		return r.openExternalUri(b.revive(t.resolvedUri), { sourceUri: b.revive(t.sourceUri) }, n)
	}
}
var pT = class o {
	constructor(e) {
		this.handles = new ar()
		this.handlers = new Map()
		this._proxy = e.getProxy(M.MainThreadUrls)
	}
	static {
		this.HandlePool = 0
	}
	registerUriHandler(e, t) {
		let n = e.identifier
		if (this.handles.has(n)) throw new Error(`Protocol handler already registered for extension ${n}`)
		let r = o.HandlePool++
		return (
			this.handles.add(n),
			this.handlers.set(r, t),
			this._proxy.$registerUriHandler(r, n, e.displayName || e.name),
			q(() => {
				this.handles.delete(n), this.handlers.delete(r), this._proxy.$unregisterUriHandler(r)
			})
		)
	}
	$handleExternalUri(e, t) {
		let n = this.handlers.get(e)
		if (!n) return Promise.resolve(void 0)
		try {
			n.handleUri(b.revive(t))
		} catch (r) {
			Be(r)
		}
		return Promise.resolve(void 0)
	}
	async createAppUri(e) {
		return b.revive(await this._proxy.$createAppUri(e))
	}
}
var X1 = class extends $ {
		constructor(t, n, r, i) {
			super()
			this.#s = void 0
			this.#l = !0
			this.#c = !1
			this.#u = this._register(new E())
			this.onDidDispose = this.#u.event
			this.#p = this._register(new E())
			this.onDidChangeViewState = this.#p.event
			;(this.#e = t),
				(this.#t = n),
				(this.#r = r),
				(this.#n = i.viewType),
				(this.#i = i.panelOptions),
				(this.#s = i.viewColumn),
				(this.#o = i.title),
				(this.#d = i.active)
		}
		#e
		#t
		#n
		#r
		#i
		#o
		#a
		#s
		#l
		#d
		#c
		#u
		#p
		dispose() {
			this.#c ||
				((this.#c = !0), this.#u.fire(), this.#t.$disposeWebview(this.#e), this.#r.dispose(), super.dispose())
		}
		get webview() {
			return this.assertNotDisposed(), this.#r
		}
		get viewType() {
			return this.assertNotDisposed(), this.#n
		}
		get title() {
			return this.assertNotDisposed(), this.#o
		}
		set title(t) {
			this.assertNotDisposed(), this.#o !== t && ((this.#o = t), this.#t.$setTitle(this.#e, t))
		}
		get iconPath() {
			return this.assertNotDisposed(), this.#a
		}
		set iconPath(t) {
			this.assertNotDisposed(),
				this.#a !== t && ((this.#a = t), this.#t.$setIconPath(this.#e, b.isUri(t) ? { light: t, dark: t } : t))
		}
		get options() {
			return this.#i
		}
		get viewColumn() {
			if ((this.assertNotDisposed(), !(typeof this.#s == "number" && this.#s < 0))) return this.#s
		}
		get active() {
			return this.assertNotDisposed(), this.#d
		}
		get visible() {
			return this.assertNotDisposed(), this.#l
		}
		_updateViewState(t) {
			this.#c ||
				((this.active !== t.active || this.visible !== t.visible || this.viewColumn !== t.viewColumn) &&
					((this.#d = t.active),
					(this.#l = t.visible),
					(this.#s = t.viewColumn),
					this.#p.fire({ webviewPanel: this })))
		}
		reveal(t, n) {
			this.assertNotDisposed(),
				this.#t.$reveal(this.#e, { viewColumn: typeof t > "u" ? void 0 : wt.from(t), preserveFocus: !!n })
		}
		assertNotDisposed() {
			if (this.#c) throw new Error("Webview is disposed")
		}
	},
	mT = class o extends $ {
		constructor(t, n, r) {
			super()
			this.webviews = n
			this.workspace = r
			this._webviewPanels = new Map()
			this._serializers = new Map()
			this._proxy = t.getProxy(M.MainThreadWebviewPanels)
		}
		static newHandle() {
			return He()
		}
		dispose() {
			super.dispose(), this._webviewPanels.forEach((t) => t.dispose()), this._webviewPanels.clear()
		}
		createWebviewPanel(t, n, r, i, s = {}) {
			let a = typeof i == "object" ? i.viewColumn : i,
				l = { viewColumn: wt.from(a), preserveFocus: typeof i == "object" && !!i.preserveFocus },
				d = Gs(t),
				c = o.newHandle()
			this._proxy.$createWebviewPanel(
				Kd(t),
				c,
				n,
				{
					title: r,
					panelOptions: e$(s),
					webviewOptions: l1(t, this.workspace, s),
					serializeBuffersForPostMessage: d,
				},
				l,
			)
			let u = this.webviews.createNewWebview(c, s, t)
			return this.createNewWebviewPanel(c, n, r, a, s, u, !0)
		}
		$onDidChangeWebviewPanelViewStates(t) {
			let n = Object.keys(t)
			n.sort((r, i) => {
				let s = t[r],
					a = t[i]
				return s.active ? 1 : a.active ? -1 : +s.visible - +a.visible
			})
			for (let r of n) {
				let i = this.getWebviewPanel(r)
				if (!i) continue
				let s = t[r]
				i._updateViewState({ active: s.active, visible: s.visible, viewColumn: wt.to(s.position) })
			}
		}
		async $onDidDisposeWebviewPanel(t) {
			this.getWebviewPanel(t)?.dispose(), this._webviewPanels.delete(t), this.webviews.deleteWebview(t)
		}
		registerWebviewPanelSerializer(t, n, r) {
			if (this._serializers.has(n)) throw new Error(`Serializer for '${n}' already registered`)
			return (
				this._serializers.set(n, { serializer: r, extension: t }),
				this._proxy.$registerSerializer(n, { serializeBuffersForPostMessage: Gs(t) }),
				new ye(() => {
					this._serializers.delete(n), this._proxy.$unregisterSerializer(n)
				})
			)
		}
		async $deserializeWebviewPanel(t, n, r, i) {
			let s = this._serializers.get(n)
			if (!s) throw new Error(`No serializer found for '${n}'`)
			let { serializer: a, extension: l } = s,
				d = this.webviews.createNewWebview(t, r.webviewOptions, l),
				c = this.createNewWebviewPanel(t, n, r.title, i, r.panelOptions, d, r.active)
			await a.deserializeWebviewPanel(c, r.state)
		}
		createNewWebviewPanel(t, n, r, i, s, a, l) {
			let d = new X1(t, this._proxy, a, { viewType: n, title: r, viewColumn: i, panelOptions: s, active: l })
			return this._webviewPanels.set(t, d), d
		}
		getWebviewPanel(t) {
			return this._webviewPanels.get(t)
		}
	}
function e$(o) {
	return { enableFindWidget: o.enableFindWidget, retainContextWhenHidden: o.retainContextWhenHidden }
}
var Y1 = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this.#i = !1
			this.#d = this._register(new E())
			this.onDidChangeVisibility = this.#d.event
			this.#c = this._register(new E())
			this.onDidDispose = this.#c.event
			;(this.#n = r), (this.#a = i), (this.#e = t), (this.#t = n), (this.#r = s), (this.#o = a)
		}
		#e
		#t
		#n
		#r
		#i
		#o
		#a
		#s
		#l
		dispose() {
			this.#i || ((this.#i = !0), this.#c.fire(), this.#r.dispose(), super.dispose())
		}
		#d
		#c
		get title() {
			return this.assertNotDisposed(), this.#a
		}
		set title(t) {
			this.assertNotDisposed(), this.#a !== t && ((this.#a = t), this.#t.$setWebviewViewTitle(this.#e, t))
		}
		get description() {
			return this.assertNotDisposed(), this.#s
		}
		set description(t) {
			this.assertNotDisposed(), this.#s !== t && ((this.#s = t), this.#t.$setWebviewViewDescription(this.#e, t))
		}
		get visible() {
			return this.#o
		}
		get webview() {
			return this.#r
		}
		get viewType() {
			return this.#n
		}
		_setVisible(t) {
			t === this.#o || this.#i || ((this.#o = t), this.#d.fire())
		}
		get badge() {
			return this.assertNotDisposed(), this.#l
		}
		set badge(t) {
			this.assertNotDisposed(),
				!(t?.value === this.#l?.value && t?.tooltip === this.#l?.tooltip) &&
					((this.#l = Og.from(t)), this.#t.$setWebviewViewBadge(this.#e, t))
		}
		show(t) {
			this.assertNotDisposed(), this.#t.$show(this.#e, !!t)
		}
		assertNotDisposed() {
			if (this.#i) throw new Error("Webview is disposed")
		}
	},
	fT = class {
		constructor(e, t) {
			this._extHostWebview = t
			this._viewProviders = new Map()
			this._webviewViews = new Map()
			this._proxy = e.getProxy(M.MainThreadWebviewViews)
		}
		registerWebviewViewProvider(e, t, n, r) {
			if ((ht.logIncoming(0, 0, 0, "registerWebviewViewProvider start: " + t), this._viewProviders.has(t)))
				throw new Error(`View provider for '${t}' already registered`)
			return (
				this._viewProviders.set(t, { provider: n, extension: e }),
				this._proxy.$registerWebviewViewProvider(Kd(e), t, {
					retainContextWhenHidden: r?.retainContextWhenHidden,
					serializeBuffersForPostMessage: Gs(e),
				}),
				new ye(() => {
					this._viewProviders.delete(t), this._proxy.$unregisterWebviewViewProvider(t)
				})
			)
		}
		async $resolveWebviewView(e, t, n, r, i) {
			console.log("resolveWebviewView", e, t, n, r), ht.logIncoming(0, 0, 0, "resolveWebviewView start: " + t)
			let s = this._viewProviders.get(t)
			if (!s) throw new Error(`No view provider found for '${t}'`)
			let { provider: a, extension: l } = s,
				d = this._extHostWebview.createNewWebview(e, {}, l),
				c = new Y1(e, this._proxy, t, n, d, !0)
			this._webviewViews.set(e, c), await a.resolveWebviewView(c, { state: r }, i)
		}
		async $onDidChangeWebviewViewVisibility(e, t) {
			this.getWebviewView(e)._setVisible(t)
		}
		async $disposeWebviewView(e) {
			let t = this.getWebviewView(e)
			this._webviewViews.delete(e), t.dispose(), this._extHostWebview.deleteWebview(e)
		}
		getWebviewView(e) {
			let t = this._webviewViews.get(e)
			if (!t) throw new Error("No webview found")
			return t
		}
	}
function pU(o) {
	let e = o.get(Xe),
		t = o.get(po),
		n = o.get(Fi),
		r = o.get(pr),
		i = o.get(Sn),
		s = o.get(cl),
		a = o.get(pn),
		l = o.get(fi),
		d = o.get(ie),
		c = o.get(bp),
		u = o.get(Ip),
		m = o.get(uo),
		f = o.get(te),
		h = o.get(ll),
		g = o.get(Ks),
		I = o.get(yC),
		C = o.get(Np),
		T = o.get(Zo),
		w = o.get(Vp),
		L = o.get(Rp),
		A = o.get(Ap),
		J = o.get(Bd)
	d.set(le.ExtHostFileSystemInfo, t),
		d.set(le.ExtHostLogLevelServiceShape, m),
		d.set(le.ExtHostWorkspace, i),
		d.set(le.ExtHostConfiguration, a),
		d.set(le.ExtHostExtensionService, r),
		d.set(le.ExtHostStorage, c),
		d.set(le.ExtHostTunnelService, h),
		d.set(le.ExtHostWindow, I),
		d.set(le.ExtHostSecretState, C),
		d.set(le.ExtHostTelemetry, s),
		d.set(le.ExtHostEditorTabs, T),
		d.set(le.ExtHostManagedSockets, w),
		d.set(le.ExtHostAuthentication, L),
		d.set(le.ExtHostChatProvider, A)
	let ne = d.set(le.ExtHostDecorations, o.get(iC)),
		oe = d.set(le.ExtHostDocumentsAndEditors, o.get(no)),
		Y = d.set(le.ExtHostCommands, o.get(Tn)),
		j = d.set(le.ExtHostTerminalService, o.get(tr)),
		K = d.set(le.ExtHostTerminalShellIntegration, o.get(im)),
		qe = d.set(le.ExtHostDebugService, o.get(em)),
		Bt = d.set(le.ExtHostSearch, o.get(rm)),
		vt = d.set(le.ExtHostTask, o.get(Qp)),
		ae = d.set(le.ExtHostOutputService, o.get(oC)),
		Z = d.set(le.ExtHostLocalization, o.get(Hp)),
		se = d.set(le.ExtHostUrls, new pT(d)),
		ee = d.set(le.ExtHostDocuments, new eS(d, oe)),
		fe = d.set(le.ExtHostDocumentContentProviders, new YC(d, oe, f)),
		Ae = d.set(le.ExtHostDocumentSaveParticipant, new ZC(f, ee, d.getProxy(M.MainThreadBulkEdits))),
		he = d.set(le.ExtHostNotebook, new QS(d, Y, oe, ee, n, Bt, f)),
		de = d.set(le.ExtHostNotebookDocuments, new XS(he)),
		Et = d.set(le.ExtHostNotebookEditors, new Dm(f, he)),
		_t = d.set(le.ExtHostNotebookKernels, new km(d, e, he, Y, f)),
		Te = d.set(le.ExtHostNotebookRenderers, new ZS(d, he)),
		wn = d.set(le.ExtHostNotebookDocumentSaveParticipant, new JS(f, he, d.getProxy(M.MainThreadBulkEdits))),
		Ft = d.set(le.ExtHostEditors, new aT(d, oe)),
		ro = d.set(le.ExtHostTreeViews, new cT(d.getProxy(M.MainThreadTreeViews), Y, f)),
		sc = d.set(le.ExtHostEditorInsets, new zC(d.getProxy(M.MainThreadEditorInsets), Ft, e.remote)),
		oi = d.set(le.ExtHostDiagnostics, new Eo(d, f, t, oe)),
		oo = d.set(le.ExtHostLanguages, new FS(d, ee, Y.converter, l)),
		$e = d.set(le.ExtHostLanguageFeatures, new kS(d, l, ee, Y, oi, f, g, s)),
		mt = d.set(le.ExtHostCodeMapper, new qC(d)),
		ov = d.set(le.ExtHostFileSystem, new oS(d, $e)),
		Tr = d.set(le.ExtHostFileSystemEventService, new dS(d, f, oe)),
		fr = d.set(le.ExtHostQuickOpen, oU(d, i, Y)),
		wl = d.set(le.ExtHostSCM, new Cl(d, Y, ee, f)),
		ac = d.set(le.ExtHostQuickDiff, new rT(d, l)),
		Gm = d.set(le.ExtHostShare, new oT(d, l)),
		iv = d.set(le.ExtHostComments, NN(d, Y, ee)),
		lc = d.set(le.ExtHostProgress, new nT(d.getProxy(M.MainThreadProgress))),
		Qm = d.set(le.ExtHostLabelService, new uS(d)),
		Pl = d.set(le.ExtHostTheming, new Rm(d)),
		Er = d.set(le.ExtHostTimeline, new lT(d, Y)),
		qi = d.set(le.ExtHostWebviews, new jC(d, e.remote, i, f, g)),
		Nt = d.set(le.ExtHostWebviewPanels, new mT(d, qi, i)),
		Kn = d.set(le.ExtHostCustomEditors, new QC(d, ee, u, qi, Nt)),
		XT = d.set(le.ExtHostWebviewViews, new fT(d, qi)),
		ta = d.set(le.ExtHostTesting, o.get(js)),
		dc = d.set(le.ExtHostUriOpeners, new uT(d)),
		Jm = d.set(le.ExtHostProfileContentHandlers, new eT(d))
	d.set(le.ExtHostInteractive, new cS(d, he, oe, Y, f))
	let k = d.set(le.ExtHostLanguageModelTools, new MS(d, A)),
		U = d.set(le.ExtHostChatAgents2, new WC(d, f, Y, ee, A, oi, k)),
		B = d.set(le.ExtHostAiRelatedInformation, new NC(d)),
		ve = d.set(le.ExtHostAiEmbeddingVector, new nS(d)),
		Me = d.set(le.ExtHostStatusBar, new sT(d, Y.converter)),
		hn = d.set(le.ExtHostSpeech, new iT(d)),
		it = d.set(le.ExtHostEmbeddings, new tS(d))
	d.set(le.ExtHostMcp, o.get(Bd))
	let rr = Object.values(le)
	d.assertRegistered(rr)
	let tn = new vm(d, oe),
		Fn = new $C(d),
		wr = new wm(d, f),
		jt = new XC(d),
		Pn = new BC(d)
	return (
		HC.register(Y),
		function (P, vn, Ne) {
			function X(y) {
				return (x, _, Oe) => {
					let Dt = y((Dn) => {
						try {
							x.call(_, Dn)
						} catch (AH) {
							dv(new Hc(P.identifier, AH, "FAILED to handle event"))
						}
					})
					return Oe?.push(Dt), Dt
				}
			}
			let xe = (function () {
					let y = !P.isUnderDevelopment
					function x() {
						y ||
							(f.info(
								`Extension '${P.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`,
							),
							(y = !0))
					}
					return function _(Oe) {
						if (Array.isArray(Oe)) Oe.forEach(_)
						else if (typeof Oe == "string") x()
						else {
							let Dt = Oe
							typeof Dt.scheme > "u" && x(),
								typeof Dt.exclusive == "boolean" && F(P, "documentFiltersExclusive")
						}
						return Oe
					}
				})(),
				Ut = {
					getSession(y, x, _) {
						return (
							((typeof _?.forceNewSession == "object" && _.forceNewSession.learnMore) ||
								(typeof _?.createIfNone == "object" && _.createIfNone.learnMore)) &&
								F(P, "authLearnMore"),
							L.getSession(P, y, x, _)
						)
					},
					getAccounts(y) {
						return L.getAccounts(y)
					},
					async hasSession(y, x) {
						return F(P, "authSession"), !!(await L.getSession(P, y, x, { silent: !0 }))
					},
					get onDidChangeSessions() {
						return X(L.getExtensionScopedSessionsEvent(P.identifier.value))
					},
					registerAuthenticationProvider(y, x, _, Oe) {
						return L.registerAuthenticationProvider(y, x, _, Oe)
					},
				},
				_n = {
					registerCommand(y, x, _) {
						return Y.registerCommand(!0, y, x, _, void 0, P)
					},
					registerTextEditorCommand(y, x, _) {
						return Y.registerCommand(
							!0,
							y,
							(...Oe) => {
								let Dt = Ft.getActiveTextEditor()
								if (!Dt) {
									f.warn("Cannot execute " + y + " because there is no active text editor.")
									return
								}
								return Dt.edit((Dn) => {
									x.apply(_, [Dt, Dn, ...Oe])
								}).then(
									(Dn) => {
										Dn || f.warn("Edits from command " + y + " were not applied.")
									},
									(Dn) => {
										f.warn("An error occurred while running command " + y, Dn)
									},
								)
							},
							void 0,
							void 0,
							P,
						)
					},
					registerDiffInformationCommand: (y, x, _) => (
						F(P, "diffCommand"),
						Y.registerCommand(
							!0,
							y,
							async (...Oe) => {
								let Dt = oe.activeEditor(!0)
								if (!Dt) {
									f.warn("Cannot execute " + y + " because there is no active text editor.")
									return
								}
								let Dn = await Ft.getDiffInformation(Dt.id)
								x.apply(_, [Dn, ...Oe])
							},
							void 0,
							void 0,
							P,
						)
					),
					executeCommand(y, ...x) {
						return Y.executeCommand(y, ...x)
					},
					getCommands(y = !1) {
						return Y.getCommands(y)
					},
				},
				Xm = {
					get machineId() {
						return e.telemetryInfo.machineId
					},
					get sessionId() {
						return e.telemetryInfo.sessionId
					},
					get language() {
						return e.environment.appLanguage
					},
					get appName() {
						return e.environment.appName
					},
					get appRoot() {
						return e.environment.appRoot?.fsPath ?? ""
					},
					get appHost() {
						return e.environment.appHost
					},
					get uriScheme() {
						return e.environment.appUriScheme
					},
					get clipboard() {
						return Fn.value
					},
					get shell() {
						return j.getDefaultShell(!1)
					},
					get onDidChangeShell() {
						return X(j.onDidChangeShell)
					},
					get isTelemetryEnabled() {
						return s.getTelemetryConfiguration()
					},
					get onDidChangeTelemetryEnabled() {
						return X(s.onDidChangeTelemetryEnabled)
					},
					get telemetryConfiguration() {
						return F(P, "telemetry"), s.getTelemetryDetails()
					},
					get onDidChangeTelemetryConfiguration() {
						return F(P, "telemetry"), X(s.onDidChangeTelemetryConfiguration)
					},
					get isNewAppInstall() {
						return Mk(e.telemetryInfo.firstSessionDate)
					},
					createTelemetryLogger(y, x) {
						return th.validateSender(y), s.instantiateLogger(P, y, x)
					},
					openExternal(y, x) {
						return I.openUri(y, {
							allowTunneling: !!e.remote.authority,
							allowContributedOpeners: x?.allowContributedOpeners,
						})
					},
					async asExternalUri(y) {
						if (y.scheme === e.environment.appUriScheme) return se.createAppUri(y)
						try {
							return await I.asExternalUri(y, { allowTunneling: !!e.remote.authority })
						} catch (x) {
							if (jv(y, W.http) || jv(y, W.https)) return y
							throw x
						}
					},
					get remoteName() {
						return Ql(e.remote.authority)
					},
					get remoteAuthority() {
						return F(P, "resolvers"), e.remote.authority
					},
					get uiKind() {
						return e.uiKind
					},
					get logLevel() {
						return f.getLevel()
					},
					get onDidChangeLogLevel() {
						return X(f.onDidChangeLogLevel)
					},
					get appQuality() {
						return F(P, "resolvers"), e.quality
					},
					get appCommit() {
						return F(P, "resolvers"), e.commit
					},
				}
			e.environment.extensionTestsLocationURI || Object.freeze(Xm)
			let _l = {
					createTestController(y, x, _) {
						return ta.createTestController(P, y, x, _)
					},
					createTestObserver() {
						return F(P, "testObserver"), ta.createTestObserver()
					},
					runTests(y) {
						return F(P, "testObserver"), ta.runTests(y)
					},
					registerTestFollowupProvider(y) {
						return F(P, "testObserver"), ta.registerTestFollowupProvider(y)
					},
					get onDidChangeTestResults() {
						return F(P, "testObserver"), X(ta.onResultsChanged)
					},
					get testResults() {
						return F(P, "testObserver"), ta.results
					},
				},
				ii = e.remote.isRemote ? 2 : 1,
				bH = {
					getExtension(y, x) {
						nt(P, "extensionsAny") || (x = !1)
						let _ = vn.mine.getExtensionDescription(y)
						if (_) return new pl(r, P.identifier, _, ii, !1)
						if (x) {
							let Oe = vn.all.getExtensionDescription(y)
							if (Oe) return new pl(r, P.identifier, Oe, ii, !0)
						}
					},
					get all() {
						let y = []
						for (let x of vn.mine.getAllExtensionDescriptions()) y.push(new pl(r, P.identifier, x, ii, !1))
						return y
					},
					get allAcrossExtensionHosts() {
						F(P, "extensionsAny")
						let y = new ar(vn.mine.getAllExtensionDescriptions().map((_) => _.identifier)),
							x = []
						for (let _ of vn.all.getAllExtensionDescriptions()) {
							let Oe = !y.has(_.identifier)
							x.push(new pl(r, P.identifier, _, ii, Oe))
						}
						return x
					},
					get onDidChange() {
						return nt(P, "extensionsAny")
							? X(Ee.any(vn.mine.onDidChange, vn.all.onDidChange))
							: X(vn.mine.onDidChange)
					},
				},
				yH = {
					createDiagnosticCollection(y) {
						return oi.createDiagnosticCollection(P.identifier, y)
					},
					get onDidChangeDiagnostics() {
						return X(oi.onDidChangeDiagnostics)
					},
					getDiagnostics: (y) => oi.getDiagnostics(y),
					getLanguages() {
						return oo.getLanguages()
					},
					setTextDocumentLanguage(y, x) {
						return oo.changeLanguage(y.uri, x)
					},
					match(y, x) {
						let _ = XD.from(y),
							Oe
						return (
							XR(_) &&
								(Oe = he.notebookDocuments.find((Dt) =>
									Dt.apiNotebook.getCells().find((Dn) => Dn.document === x),
								)?.apiNotebook),
							JR(_, x.uri, x.languageId, !0, Oe?.uri, Oe?.notebookType)
						)
					},
					registerCodeActionsProvider(y, x, _) {
						return $e.registerCodeActionProvider(P, xe(y), x, _)
					},
					registerDocumentPasteEditProvider(y, x, _) {
						return $e.registerDocumentPasteEditProvider(P, xe(y), x, _)
					},
					registerCodeLensProvider(y, x) {
						return $e.registerCodeLensProvider(P, xe(y), x)
					},
					registerDefinitionProvider(y, x) {
						return $e.registerDefinitionProvider(P, xe(y), x)
					},
					registerDeclarationProvider(y, x) {
						return $e.registerDeclarationProvider(P, xe(y), x)
					},
					registerImplementationProvider(y, x) {
						return $e.registerImplementationProvider(P, xe(y), x)
					},
					registerTypeDefinitionProvider(y, x) {
						return $e.registerTypeDefinitionProvider(P, xe(y), x)
					},
					registerHoverProvider(y, x) {
						return $e.registerHoverProvider(P, xe(y), x, P.identifier)
					},
					registerEvaluatableExpressionProvider(y, x) {
						return $e.registerEvaluatableExpressionProvider(P, xe(y), x, P.identifier)
					},
					registerInlineValuesProvider(y, x) {
						return $e.registerInlineValuesProvider(P, xe(y), x, P.identifier)
					},
					registerDocumentHighlightProvider(y, x) {
						return $e.registerDocumentHighlightProvider(P, xe(y), x)
					},
					registerMultiDocumentHighlightProvider(y, x) {
						return $e.registerMultiDocumentHighlightProvider(P, xe(y), x)
					},
					registerLinkedEditingRangeProvider(y, x) {
						return $e.registerLinkedEditingRangeProvider(P, xe(y), x)
					},
					registerReferenceProvider(y, x) {
						return $e.registerReferenceProvider(P, xe(y), x)
					},
					registerRenameProvider(y, x) {
						return $e.registerRenameProvider(P, xe(y), x)
					},
					registerNewSymbolNamesProvider(y, x) {
						return F(P, "newSymbolNamesProvider"), $e.registerNewSymbolNamesProvider(P, xe(y), x)
					},
					registerDocumentSymbolProvider(y, x, _) {
						return $e.registerDocumentSymbolProvider(P, xe(y), x, _)
					},
					registerWorkspaceSymbolProvider(y) {
						return $e.registerWorkspaceSymbolProvider(P, y)
					},
					registerDocumentFormattingEditProvider(y, x) {
						return $e.registerDocumentFormattingEditProvider(P, xe(y), x)
					},
					registerDocumentRangeFormattingEditProvider(y, x) {
						return $e.registerDocumentRangeFormattingEditProvider(P, xe(y), x)
					},
					registerOnTypeFormattingEditProvider(y, x, _, ...Oe) {
						return $e.registerOnTypeFormattingEditProvider(P, xe(y), x, [_].concat(Oe))
					},
					registerDocumentSemanticTokensProvider(y, x, _) {
						return $e.registerDocumentSemanticTokensProvider(P, xe(y), x, _)
					},
					registerDocumentRangeSemanticTokensProvider(y, x, _) {
						return $e.registerDocumentRangeSemanticTokensProvider(P, xe(y), x, _)
					},
					registerSignatureHelpProvider(y, x, _, ...Oe) {
						return typeof _ == "object"
							? $e.registerSignatureHelpProvider(P, xe(y), x, _)
							: $e.registerSignatureHelpProvider(P, xe(y), x, typeof _ > "u" ? [] : [_, ...Oe])
					},
					registerCompletionItemProvider(y, x, ..._) {
						return $e.registerCompletionItemProvider(P, xe(y), x, _)
					},
					registerInlineCompletionItemProvider(y, x, _) {
						return (
							x.handleDidShowCompletionItem && F(P, "inlineCompletionsAdditions"),
							x.handleDidPartiallyAcceptCompletionItem && F(P, "inlineCompletionsAdditions"),
							_ && F(P, "inlineCompletionsAdditions"),
							$e.registerInlineCompletionsProvider(P, xe(y), x, _)
						)
					},
					registerInlineEditProvider(y, x) {
						return F(P, "inlineEdit"), $e.registerInlineEditProvider(P, xe(y), x)
					},
					registerDocumentLinkProvider(y, x) {
						return $e.registerDocumentLinkProvider(P, xe(y), x)
					},
					registerColorProvider(y, x) {
						return $e.registerColorProvider(P, xe(y), x)
					},
					registerFoldingRangeProvider(y, x) {
						return $e.registerFoldingRangeProvider(P, xe(y), x)
					},
					registerSelectionRangeProvider(y, x) {
						return $e.registerSelectionRangeProvider(P, y, x)
					},
					registerCallHierarchyProvider(y, x) {
						return $e.registerCallHierarchyProvider(P, y, x)
					},
					registerTypeHierarchyProvider(y, x) {
						return $e.registerTypeHierarchyProvider(P, y, x)
					},
					setLanguageConfiguration: (y, x) => $e.setLanguageConfiguration(P, y, x),
					getTokenInformationAtPosition(y, x) {
						return F(P, "tokenInformation"), oo.tokenAtPosition(y, x)
					},
					registerInlayHintsProvider(y, x) {
						return $e.registerInlayHintsProvider(P, y, x)
					},
					createLanguageStatusItem(y, x) {
						return oo.createLanguageStatusItem(P, y, x)
					},
					registerDocumentDropEditProvider(y, x, _) {
						return $e.registerDocumentOnDropEditProvider(P, y, x, _)
					},
				},
				IH = {
					get activeTextEditor() {
						return Ft.getActiveTextEditor()
					},
					get visibleTextEditors() {
						return Ft.getVisibleTextEditors()
					},
					get activeTerminal() {
						return j.activeTerminal
					},
					get terminals() {
						return j.terminals
					},
					async showTextDocument(y, x, _) {
						b.isUri(y) &&
							y.scheme === W.vscodeRemote &&
							!y.authority &&
							g.report(
								"workspace.showTextDocument",
								P,
								"A URI of 'vscode-remote' scheme requires an authority.",
							)
						let Oe = await (b.isUri(y) ? Promise.resolve(H0.openTextDocument(y)) : Promise.resolve(y))
						return Ft.showTextDocument(Oe, x, _)
					},
					createTextEditorDecorationType(y) {
						return Ft.createTextEditorDecorationType(P, y)
					},
					onDidChangeActiveTextEditor(y, x, _) {
						return X(Ft.onDidChangeActiveTextEditor)(y, x, _)
					},
					onDidChangeVisibleTextEditors(y, x, _) {
						return X(Ft.onDidChangeVisibleTextEditors)(y, x, _)
					},
					onDidChangeTextEditorSelection(y, x, _) {
						return X(Ft.onDidChangeTextEditorSelection)(y, x, _)
					},
					onDidChangeTextEditorOptions(y, x, _) {
						return X(Ft.onDidChangeTextEditorOptions)(y, x, _)
					},
					onDidChangeTextEditorVisibleRanges(y, x, _) {
						return X(Ft.onDidChangeTextEditorVisibleRanges)(y, x, _)
					},
					onDidChangeTextEditorViewColumn(y, x, _) {
						return X(Ft.onDidChangeTextEditorViewColumn)(y, x, _)
					},
					onDidChangeTextEditorDiffInformation(y, x, _) {
						return F(P, "textEditorDiffInformation"), X(Ft.onDidChangeTextEditorDiffInformation)(y, x, _)
					},
					onDidCloseTerminal(y, x, _) {
						return X(j.onDidCloseTerminal)(y, x, _)
					},
					onDidOpenTerminal(y, x, _) {
						return X(j.onDidOpenTerminal)(y, x, _)
					},
					onDidChangeActiveTerminal(y, x, _) {
						return X(j.onDidChangeActiveTerminal)(y, x, _)
					},
					onDidChangeTerminalDimensions(y, x, _) {
						return F(P, "terminalDimensions"), X(j.onDidChangeTerminalDimensions)(y, x, _)
					},
					onDidChangeTerminalState(y, x, _) {
						return X(j.onDidChangeTerminalState)(y, x, _)
					},
					onDidWriteTerminalData(y, x, _) {
						return F(P, "terminalDataWriteEvent"), X(j.onDidWriteTerminalData)(y, x, _)
					},
					onDidExecuteTerminalCommand(y, x, _) {
						return F(P, "terminalExecuteCommandEvent"), X(j.onDidExecuteTerminalCommand)(y, x, _)
					},
					onDidChangeTerminalShellIntegration(y, x, _) {
						return X(K.onDidChangeTerminalShellIntegration)(y, x, _)
					},
					onDidStartTerminalShellExecution(y, x, _) {
						return X(K.onDidStartTerminalShellExecution)(y, x, _)
					},
					onDidEndTerminalShellExecution(y, x, _) {
						return X(K.onDidEndTerminalShellExecution)(y, x, _)
					},
					get state() {
						return I.getState()
					},
					onDidChangeWindowState(y, x, _) {
						return X(I.onDidChangeWindowState)(y, x, _)
					},
					showInformationMessage(y, ...x) {
						return wr.showMessage(P, It.Info, y, x[0], x.slice(1))
					},
					showWarningMessage(y, ...x) {
						return wr.showMessage(P, It.Warning, y, x[0], x.slice(1))
					},
					showErrorMessage(y, ...x) {
						return wr.showMessage(P, It.Error, y, x[0], x.slice(1))
					},
					showQuickPick(y, x, _) {
						return fr.showQuickPick(P, y, x, _)
					},
					showWorkspaceFolderPick(y) {
						return fr.showWorkspaceFolderPick(y)
					},
					showInputBox(y, x) {
						return fr.showInput(y, x)
					},
					showOpenDialog(y) {
						return jt.showOpenDialog(y)
					},
					showSaveDialog(y) {
						return jt.showSaveDialog(y)
					},
					createStatusBarItem(y, x, _) {
						let Oe, Dt, Dn
						return (
							typeof y == "string" ? ((Oe = y), (Dt = x), (Dn = _)) : ((Dt = y), (Dn = x)),
							Me.createStatusBarEntry(P, Oe, Dt, Dn)
						)
					},
					setStatusBarMessage(y, x) {
						return Me.setStatusBarMessage(y, x)
					},
					withScmProgress(y) {
						return (
							g.report("window.withScmProgress", P, "Use 'withProgress' instead."),
							lc.withProgress(P, { location: 1 }, (x, _) => y({ report(Oe) {} }))
						)
					},
					withProgress(y, x) {
						return lc.withProgress(P, y, x)
					},
					createOutputChannel(y, x) {
						return ae.createOutputChannel(y, x, P)
					},
					createWebviewPanel(y, x, _, Oe) {
						return Nt.createWebviewPanel(P, y, x, _, Oe)
					},
					createWebviewTextEditorInset(y, x, _, Oe) {
						return F(P, "editorInsets"), sc.createWebviewEditorInset(y, x, _, Oe, P)
					},
					createTerminal(y, x, _) {
						return typeof y == "object"
							? "pty" in y
								? j.createExtensionTerminal(y)
								: j.createTerminalFromOptions(y)
							: j.createTerminal(y, x, _)
					},
					registerTerminalLinkProvider(y) {
						return j.registerLinkProvider(y)
					},
					registerTerminalProfileProvider(y, x) {
						return j.registerProfileProvider(P, y, x)
					},
					registerTerminalCompletionProvider(y, ...x) {
						return F(P, "terminalCompletionProvider"), j.registerTerminalCompletionProvider(P, y, ...x)
					},
					registerTerminalQuickFixProvider(y, x) {
						return (
							F(P, "terminalQuickFixProvider"),
							j.registerTerminalQuickFixProvider(y, P.identifier.value, x)
						)
					},
					registerTreeDataProvider(y, x) {
						return ro.registerTreeDataProvider(y, x, P)
					},
					createTreeView(y, x) {
						return ro.createTreeView(y, x, P)
					},
					registerWebviewPanelSerializer: (y, x) => Nt.registerWebviewPanelSerializer(P, y, x),
					registerCustomEditorProvider: (y, x, _ = {}) => Kn.registerCustomEditorProvider(P, y, x, _),
					registerFileDecorationProvider(y) {
						return ne.registerFileDecorationProvider(y, P)
					},
					registerUriHandler(y) {
						return se.registerUriHandler(P, y)
					},
					createQuickPick() {
						return fr.createQuickPick(P)
					},
					createInputBox() {
						return fr.createInputBox(P)
					},
					get activeColorTheme() {
						return Pl.activeColorTheme
					},
					onDidChangeActiveColorTheme(y, x, _) {
						return X(Pl.onDidChangeActiveColorTheme)(y, x, _)
					},
					registerWebviewViewProvider(y, x, _) {
						return XT.registerWebviewViewProvider(P, y, x, _?.webviewOptions)
					},
					get activeNotebookEditor() {
						return he.activeNotebookEditor
					},
					onDidChangeActiveNotebookEditor(y, x, _) {
						return X(he.onDidChangeActiveNotebookEditor)(y, x, _)
					},
					get visibleNotebookEditors() {
						return he.visibleNotebookEditors
					},
					get onDidChangeVisibleNotebookEditors() {
						return X(he.onDidChangeVisibleNotebookEditors)
					},
					onDidChangeNotebookEditorSelection(y, x, _) {
						return X(Et.onDidChangeNotebookEditorSelection)(y, x, _)
					},
					onDidChangeNotebookEditorVisibleRanges(y, x, _) {
						return X(Et.onDidChangeNotebookEditorVisibleRanges)(y, x, _)
					},
					showNotebookDocument(y, x) {
						return he.showNotebookDocument(y, x)
					},
					registerExternalUriOpener(y, x, _) {
						return F(P, "externalUriOpener"), dc.registerExternalUriOpener(P.identifier, y, x, _)
					},
					registerProfileContentHandler(y, x) {
						return F(P, "profileContentHandlers"), Jm.registerProfileContentHandler(P, y, x)
					},
					registerQuickDiffProvider(y, x, _, Oe) {
						return F(P, "quickDiffProvider"), ac.registerQuickDiffProvider(xe(y), x, _, Oe)
					},
					get tabGroups() {
						return T.tabGroups
					},
					registerShareProvider(y, x) {
						return F(P, "shareProvider"), Gm.registerShareProvider(xe(y), x)
					},
					get nativeHandle() {
						return F(P, "nativeWindowHandle"), I.nativeHandle
					},
					createChatStatusItem: (y) => (F(P, "chatStatusItem"), Pn.createChatStatusItem(P, y)),
				},
				H0 = {
					get rootPath() {
						return (
							g.report(
								"workspace.rootPath",
								P,
								"Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath",
							),
							i.getPath()
						)
					},
					set rootPath(y) {
						throw new _o("rootPath")
					},
					getWorkspaceFolder(y) {
						return i.getWorkspaceFolder(y)
					},
					get workspaceFolders() {
						return i.getWorkspaceFolders()
					},
					get name() {
						return i.name
					},
					set name(y) {
						throw new _o("name")
					},
					get workspaceFile() {
						return i.workspaceFile
					},
					set workspaceFile(y) {
						throw new _o("workspaceFile")
					},
					updateWorkspaceFolders: (y, x, ..._) => i.updateWorkspaceFolders(P, y, x || 0, ..._),
					onDidChangeWorkspaceFolders: function (y, x, _) {
						return X(i.onDidChangeWorkspace)(y, x, _)
					},
					asRelativePath: (y, x) => i.getRelativePath(y, x),
					findFiles: (y, x, _, Oe) => i.findFiles(y, x, _, P.identifier, Oe),
					findFiles2: (y, x, _) => (F(P, "findFiles2"), i.findFiles2(y, x, P.identifier, _)),
					findTextInFiles: (y, x, _, Oe) => {
						F(P, "findTextInFiles")
						let Dt, Dn
						return (
							typeof x == "object" ? ((Dt = x), (Dn = _)) : ((Dt = {}), (Dn = x), (Oe = _)),
							i.findTextInFiles(y, Dt || {}, Dn, P.identifier, Oe)
						)
					},
					findTextInFiles2: (y, x, _) => (
						F(P, "findTextInFiles2"), F(P, "textSearchProvider2"), i.findTextInFiles2(y, x, P.identifier, _)
					),
					save: (y) => i.save(y),
					saveAs: (y) => i.saveAs(y),
					saveAll: (y) => i.saveAll(y),
					applyEdit(y, x) {
						return tn.applyWorkspaceEdit(y, P, x)
					},
					createFileSystemWatcher: (y, x, _, Oe) => {
						let Dt = { ignoreCreateEvents: !!x, ignoreChangeEvents: !!_, ignoreDeleteEvents: !!Oe }
						return Tr.createFileSystemWatcher(i, Ne, P, y, Dt)
					},
					get textDocuments() {
						return ee.getAllDocumentData().map((y) => y.document)
					},
					set textDocuments(y) {
						throw new _o("textDocuments")
					},
					openTextDocument(y, x) {
						let _
						if (
							((x = x ?? y),
							typeof x?.encoding == "string" && F(P, "textDocumentEncoding"),
							typeof y == "string")
						)
							_ = Promise.resolve(b.file(y))
						else if (b.isUri(y)) _ = Promise.resolve(y)
						else if (!x || typeof x == "object") _ = ee.createDocumentData(x)
						else throw new Error("illegal argument - uriOrFileNameOrOptions")
						return _.then(
							(Oe) => (
								f.trace(`openTextDocument from ${P.identifier}`),
								Oe.scheme === W.vscodeRemote &&
									!Oe.authority &&
									g.report(
										"workspace.openTextDocument",
										P,
										"A URI of 'vscode-remote' scheme requires an authority.",
									),
								ee.ensureDocumentData(Oe, x).then((Dt) => Dt.document)
							),
						)
					},
					onDidOpenTextDocument: (y, x, _) => X(ee.onDidAddDocument)(y, x, _),
					onDidCloseTextDocument: (y, x, _) => X(ee.onDidRemoveDocument)(y, x, _),
					onDidChangeTextDocument: (y, x, _) => X(ee.onDidChangeDocument)(y, x, _),
					onDidSaveTextDocument: (y, x, _) => X(ee.onDidSaveDocument)(y, x, _),
					onWillSaveTextDocument: (y, x, _) => X(Ae.getOnWillSaveTextDocumentEvent(P))(y, x, _),
					get notebookDocuments() {
						return he.notebookDocuments.map((y) => y.apiNotebook)
					},
					async openNotebookDocument(y, x) {
						let _
						if (b.isUri(y)) (_ = y), await he.openNotebookDocument(y)
						else if (typeof y == "string")
							_ = b.revive(await he.createNotebookDocument({ viewType: y, content: x }))
						else throw new Error("Invalid arguments")
						return he.getNotebookDocument(_).apiNotebook
					},
					onDidSaveNotebookDocument(y, x, _) {
						return X(de.onDidSaveNotebookDocument)(y, x, _)
					},
					onDidChangeNotebookDocument(y, x, _) {
						return X(de.onDidChangeNotebookDocument)(y, x, _)
					},
					onWillSaveNotebookDocument(y, x, _) {
						return X(wn.getOnWillSaveNotebookDocumentEvent(P))(y, x, _)
					},
					get onDidOpenNotebookDocument() {
						return X(he.onDidOpenNotebookDocument)
					},
					get onDidCloseNotebookDocument() {
						return X(he.onDidCloseNotebookDocument)
					},
					registerNotebookSerializer(y, x, _, Oe) {
						return he.registerNotebookSerializer(P, y, x, _, nt(P, "notebookLiveShare") ? Oe : void 0)
					},
					onDidChangeConfiguration: (y, x, _) => X(Ne.onDidChangeConfiguration)(y, x, _),
					getConfiguration(y, x) {
						return (x = arguments.length === 1 ? void 0 : x), Ne.getConfiguration(y, x, P)
					},
					registerTextDocumentContentProvider(y, x) {
						return fe.registerTextDocumentContentProvider(y, x)
					},
					registerTaskProvider: (y, x) => (
						g.report(
							"window.registerTaskProvider",
							P,
							"Use the corresponding function on the 'tasks' namespace instead",
						),
						vt.registerTaskProvider(P, y, x)
					),
					registerFileSystemProvider(y, x, _) {
						return fv(ov.registerFileSystemProvider(P, y, x, _), n.addFileSystemProvider(y, x, _))
					},
					get fs() {
						return n.value
					},
					registerFileSearchProvider: (y, x) => (
						F(P, "fileSearchProvider"), Bt.registerFileSearchProviderOld(y, x)
					),
					registerTextSearchProvider: (y, x) => (
						F(P, "textSearchProvider"), Bt.registerTextSearchProviderOld(y, x)
					),
					registerAITextSearchProvider: (y, x) => (
						F(P, "aiTextSearchProvider"), F(P, "textSearchProvider2"), Bt.registerAITextSearchProvider(y, x)
					),
					registerFileSearchProvider2: (y, x) => (
						F(P, "fileSearchProvider2"), Bt.registerFileSearchProvider(y, x)
					),
					registerTextSearchProvider2: (y, x) => (
						F(P, "textSearchProvider2"), Bt.registerTextSearchProvider(y, x)
					),
					registerRemoteAuthorityResolver: (y, x) => (
						F(P, "resolvers"), r.registerRemoteAuthorityResolver(y, x)
					),
					registerResourceLabelFormatter: (y) => (F(P, "resolvers"), Qm.$registerResourceLabelFormatter(y)),
					getRemoteExecServer: (y) => (F(P, "resolvers"), r.getRemoteExecServer(y)),
					onDidCreateFiles: (y, x, _) => X(Tr.onDidCreateFile)(y, x, _),
					onDidDeleteFiles: (y, x, _) => X(Tr.onDidDeleteFile)(y, x, _),
					onDidRenameFiles: (y, x, _) => X(Tr.onDidRenameFile)(y, x, _),
					onWillCreateFiles: (y, x, _) => X(Tr.getOnWillCreateFileEvent(P))(y, x, _),
					onWillDeleteFiles: (y, x, _) => X(Tr.getOnWillDeleteFileEvent(P))(y, x, _),
					onWillRenameFiles: (y, x, _) => X(Tr.getOnWillRenameFileEvent(P))(y, x, _),
					openTunnel: (y) => (
						F(P, "tunnels"),
						h.openTunnel(P, y).then((x) => {
							if (!x) throw new Error("cannot open tunnel")
							return x
						})
					),
					get tunnels() {
						return F(P, "tunnels"), h.getTunnels()
					},
					onDidChangeTunnels: (y, x, _) => (F(P, "tunnels"), X(h.onDidChangeTunnels)(y, x, _)),
					registerPortAttributesProvider: (y, x) => (
						F(P, "portsAttributes"), h.registerPortsAttributesProvider(y, x)
					),
					registerTunnelProvider: (y, x) => (F(P, "tunnelFactory"), h.registerTunnelProvider(y, x)),
					registerTimelineProvider: (y, x) => (
						F(P, "timeline"), Er.registerTimelineProvider(y, x, P.identifier, Y.converter)
					),
					get isTrusted() {
						return i.trusted
					},
					requestWorkspaceTrust: (y) => (F(P, "workspaceTrust"), i.requestWorkspaceTrust(y)),
					onDidGrantWorkspaceTrust: (y, x, _) => X(i.onDidGrantWorkspaceTrust)(y, x, _),
					registerEditSessionIdentityProvider: (y, x) => (
						F(P, "editSessionIdentityProvider"), i.registerEditSessionIdentityProvider(y, x)
					),
					onWillCreateEditSessionIdentity: (y, x, _) => (
						F(P, "editSessionIdentityProvider"), X(i.getOnWillCreateEditSessionIdentityEvent(P))(y, x, _)
					),
					registerCanonicalUriProvider: (y, x) => (
						F(P, "canonicalUriProvider"), i.registerCanonicalUriProvider(y, x)
					),
					getCanonicalUri: (y, x, _) => (F(P, "canonicalUriProvider"), i.provideCanonicalUri(y, x, _)),
					decode: function (y) {
						return F(P, "textDocumentEncoding"), i.decode(y, void 0, void 0)
					},
					encode: function (y) {
						return F(P, "textDocumentEncoding"), i.encode(y, void 0, void 0)
					},
				},
				xH = {
					get inputBox() {
						return (
							g.report("scm.inputBox", P, "Use 'SourceControl.inputBox' instead"), wl.getLastInputBox(P)
						)
					},
					createSourceControl(y, x, _) {
						return wl.createSourceControl(P, y, x, _)
					},
				},
				CH = {
					createCommentController(y, x) {
						return iv.createCommentController(P, y, x)
					},
				},
				SH = {
					get activeDebugSession() {
						return qe.activeDebugSession
					},
					get activeDebugConsole() {
						return qe.activeDebugConsole
					},
					get breakpoints() {
						return qe.breakpoints
					},
					get activeStackItem() {
						return qe.activeStackItem
					},
					registerDebugVisualizationProvider(y, x) {
						return F(P, "debugVisualization"), qe.registerDebugVisualizationProvider(P, y, x)
					},
					registerDebugVisualizationTreeProvider(y, x) {
						return F(P, "debugVisualization"), qe.registerDebugVisualizationTree(P, y, x)
					},
					onDidStartDebugSession(y, x, _) {
						return X(qe.onDidStartDebugSession)(y, x, _)
					},
					onDidTerminateDebugSession(y, x, _) {
						return X(qe.onDidTerminateDebugSession)(y, x, _)
					},
					onDidChangeActiveDebugSession(y, x, _) {
						return X(qe.onDidChangeActiveDebugSession)(y, x, _)
					},
					onDidReceiveDebugSessionCustomEvent(y, x, _) {
						return X(qe.onDidReceiveDebugSessionCustomEvent)(y, x, _)
					},
					onDidChangeBreakpoints(y, x, _) {
						return X(qe.onDidChangeBreakpoints)(y, x, _)
					},
					onDidChangeActiveStackItem(y, x, _) {
						return X(qe.onDidChangeActiveStackItem)(y, x, _)
					},
					registerDebugConfigurationProvider(y, x, _) {
						return qe.registerDebugConfigurationProvider(y, x, _ || 1)
					},
					registerDebugAdapterDescriptorFactory(y, x) {
						return qe.registerDebugAdapterDescriptorFactory(P, y, x)
					},
					registerDebugAdapterTrackerFactory(y, x) {
						return qe.registerDebugAdapterTrackerFactory(y, x)
					},
					startDebugging(y, x, _) {
						return !_ || (typeof _ == "object" && "configuration" in _)
							? qe.startDebugging(y, x, { parentSession: _ })
							: qe.startDebugging(y, x, _ || {})
					},
					stopDebugging(y) {
						return qe.stopDebugging(y)
					},
					addBreakpoints(y) {
						return qe.addBreakpoints(y)
					},
					removeBreakpoints(y) {
						return qe.removeBreakpoints(y)
					},
					asDebugSourceUri(y, x) {
						return qe.asDebugSourceUri(y, x)
					},
				},
				TH = {
					registerTaskProvider: (y, x) => vt.registerTaskProvider(P, y, x),
					fetchTasks: (y) => vt.fetchTasks(y),
					executeTask: (y) => vt.executeTask(P, y),
					get taskExecutions() {
						return vt.taskExecutions
					},
					onDidStartTask: (y, x, _) => X(vt.onDidStartTask)(y, x, _),
					onDidEndTask: (y, x, _) => X(vt.onDidEndTask)(y, x, _),
					onDidStartTaskProcess: (y, x, _) => X(vt.onDidStartTaskProcess)(y, x, _),
					onDidEndTaskProcess: (y, x, _) => X(vt.onDidEndTaskProcess)(y, x, _),
					onDidStartTaskProblemMatchers: (y, x, _) => (
						F(P, "taskProblemMatcherStatus"), X(vt.onDidStartTaskProblemMatchers)(y, x, _)
					),
					onDidEndTaskProblemMatchers: (y, x, _) => (
						F(P, "taskProblemMatcherStatus"), X(vt.onDidEndTaskProblemMatchers)(y, x, _)
					),
				},
				EH = {
					createNotebookController(y, x, _, Oe, Dt) {
						return _t.createNotebookController(P, y, x, _, Oe, nt(P, "notebookMessaging") ? Dt : void 0)
					},
					registerNotebookCellStatusBarItemProvider: (y, x) =>
						he.registerNotebookCellStatusBarItemProvider(P, y, x),
					createRendererMessaging(y) {
						return Te.createRendererMessaging(P, y)
					},
					createNotebookControllerDetectionTask(y) {
						return F(P, "notebookKernelSource"), _t.createNotebookControllerDetectionTask(P, y)
					},
					registerKernelSourceActionProvider(y, x) {
						return F(P, "notebookKernelSource"), _t.registerKernelSourceActionProvider(P, y, x)
					},
					onDidChangeNotebookCellExecutionState(y, x, _) {
						return F(P, "notebookCellExecutionState"), X(_t.onDidChangeNotebookCellExecutionState)(y, x, _)
					},
				},
				wH = {
					t(...y) {
						if (typeof y[0] == "string") {
							let x = y.shift(),
								_ = !y || typeof y[0] != "object" ? y : y[0]
							return Z.getMessage(P.identifier.value, { message: x, args: _ })
						}
						return Z.getMessage(P.identifier.value, y[0])
					},
					get bundle() {
						return Z.getBundle(P.identifier.value)
					},
					get uri() {
						return Z.getBundleUri(P.identifier.value)
					},
				},
				PH = {
					transferActiveChat(y) {
						return F(P, "interactive"), U.transferActiveChat(y)
					},
				},
				_H = {
					getRelatedInformation(y, x) {
						return F(P, "aiRelatedInformation"), B.getRelatedInformation(P, y, x)
					},
					registerRelatedInformationProvider(y, x) {
						return F(P, "aiRelatedInformation"), B.registerRelatedInformationProvider(P, y, x)
					},
					registerEmbeddingVectorProvider(y, x) {
						return F(P, "aiRelatedInformation"), ve.registerEmbeddingVectorProvider(P, y, x)
					},
				},
				DH = {
					registerMappedEditsProvider(y, x) {
						return F(P, "mappedEditsProvider"), { dispose() {} }
					},
					registerMappedEditsProvider2(y) {
						return F(P, "mappedEditsProvider"), mt.registerMappedEditsProvider(P, y)
					},
					createChatParticipant(y, x) {
						return U.createChatAgent(P, y, x)
					},
					createDynamicChatParticipant(y, x, _) {
						return F(P, "chatParticipantPrivate"), U.createDynamicChatAgent(P, y, x, _)
					},
					registerChatParticipantDetectionProvider(y) {
						return F(P, "chatParticipantPrivate"), U.registerChatParticipantDetectionProvider(P, y)
					},
					registerRelatedFilesProvider(y, x) {
						return F(P, "chatEditing"), U.registerRelatedFilesProvider(P, y, x)
					},
					onDidDisposeChatSession: (y, x, _) => (
						F(P, "chatParticipantPrivate"), X(U.onDidDisposeChatSession)(y, x, _)
					),
				},
				kH = {
					selectChatModels: (y) => A.selectLanguageModels(P, y ?? {}),
					onDidChangeChatModels: (y, x, _) => A.onDidChangeProviders(y, x, _),
					registerChatModelProvider: (y, x, _) => (F(P, "chatProvider"), A.registerLanguageModel(P, y, x, _)),
					get embeddingModels() {
						return F(P, "embeddings"), it.embeddingsModels
					},
					onDidChangeEmbeddingModels: (y, x, _) => (F(P, "embeddings"), it.onDidChange(y, x, _)),
					registerEmbeddingsProvider(y, x) {
						return F(P, "embeddings"), it.registerEmbeddingsProvider(P, y, x)
					},
					async computeEmbeddings(y, x, _) {
						return F(P, "embeddings"), it.computeEmbeddings(y, x, _)
					},
					registerTool(y, x) {
						return k.registerTool(P, y, x)
					},
					invokeTool(y, x, _) {
						return k.invokeTool(P, y, x, _)
					},
					get tools() {
						return k.getTools(P)
					},
					fileIsIgnored(y, x) {
						return A.fileIsIgnored(P, y, x)
					},
					registerIgnoredFileProvider(y) {
						return A.registerIgnoredFileProvider(P, y)
					},
					registerMcpConfigurationProvider(y, x) {
						return F(P, "mcpConfigurationProvider"), J.registerMcpConfigurationProvider(P, y, x)
					},
				},
				RH = {
					registerSpeechProvider(y, x) {
						return F(P, "speech"), hn.registerProvider(P.identifier, y, x)
					},
				}
			return {
				version: e.version,
				ai: _H,
				authentication: Ut,
				commands: _n,
				comments: CH,
				chat: DH,
				debug: SH,
				env: Xm,
				extensions: bH,
				interactive: PH,
				l10n: wH,
				languages: yH,
				lm: kH,
				notebooks: EH,
				scm: xH,
				speech: RH,
				tasks: TH,
				tests: _l,
				window: IH,
				workspace: H0,
				Breakpoint: xs,
				TerminalOutputAnchor: Q_,
				ChatResultFeedbackKind: lx,
				ChatVariableLevel: xD,
				ChatCompletionItem: uI,
				ChatReferenceDiagnostic: qu,
				CallHierarchyIncomingCall: Cu,
				CallHierarchyItem: qa,
				CallHierarchyOutgoingCall: Su,
				CancellationError: xt,
				CancellationTokenSource: _e,
				CandidatePortSource: sP,
				CodeAction: xi,
				CodeActionKind: lt,
				CodeActionTriggerKind: xI,
				CodeLens: Aa,
				Color: qo,
				ColorInformation: Na,
				ColorPresentation: Ua,
				ColorThemeKind: YI,
				CommentMode: uD,
				CommentState: pD,
				CommentThreadCollapsibleState: zI,
				CommentThreadState: qI,
				CommentThreadApplicability: KI,
				CommentThreadFocus: jI,
				CompletionItem: Ma,
				CompletionItemKind: pg,
				CompletionItemTag: TI,
				CompletionList: zo,
				CompletionTriggerKind: SI,
				ConfigurationTarget: HI,
				CustomExecution: yd,
				DebugAdapterExecutable: Qo,
				DebugAdapterInlineImplementation: Cs,
				DebugAdapterNamedPipeServer: wi,
				DebugAdapterServer: Jo,
				DebugConfigurationProviderTriggerKind: M_,
				DebugConsoleMode: GI,
				DebugVisualization: oI,
				DecorationRangeBehavior: OI,
				Diagnostic: _a,
				DiagnosticRelatedInformation: ys,
				DiagnosticSeverity: Qu,
				DiagnosticTag: bI,
				Disposable: ye,
				DocumentHighlight: ka,
				DocumentHighlightKind: yI,
				MultiDocumentHighlight: Ra,
				DocumentLink: Fa,
				DocumentSymbol: Zr,
				EndOfLine: Gu,
				EnvironmentVariableMutatorType: vI,
				EvaluatableExpression: Ha,
				InlineValueText: Wa,
				InlineValueVariableLookup: Va,
				InlineValueEvaluatableExpression: Ba,
				InlineCompletionTriggerKind: WI,
				EventEmitter: E,
				ExtensionKind: XI,
				ExtensionMode: ox,
				ExternalUriOpenerPriority: hD,
				FileChangeType: BI,
				FileDecoration: xd,
				FileDecoration2: xd,
				FileSystemError: rt,
				FileType: ya,
				FilePermission: Ia,
				FoldingRange: Iu,
				FoldingRangeKind: $I,
				FunctionBreakpoint: Go,
				InlineCompletionItem: hu,
				InlineCompletionList: vu,
				Hover: ud,
				VerboseHover: Da,
				HoverVerbosityAction: J_,
				IndentAction: YR,
				Location: rn,
				MarkdownString: en,
				OverviewRulerLane: NP,
				ParameterInformation: mu,
				PortAutoForwardAction: bD,
				Position: Pe,
				ProcessExecution: Si,
				ProgressLocation: FI,
				QuickInputButtonLocation: mD,
				QuickInputButtons: Ii,
				Range: pe,
				RelativePattern: Ei,
				Selection: Bn,
				SelectionRange: Ci,
				SemanticTokens: Xo,
				SemanticTokensBuilder: rI,
				SemanticTokensEdit: wu,
				SemanticTokensEdits: ja,
				SemanticTokensLegend: Id,
				ShellExecution: Ko,
				ShellQuoting: aD,
				SignatureHelp: gu,
				SignatureHelpTriggerKind: X_,
				SignatureInformation: fu,
				SnippetString: Vn,
				SourceBreakpoint: jo,
				StandardTokenType: fg,
				StatusBarAlignment: PI,
				SymbolInformation: vo,
				SymbolKind: ug,
				SymbolTag: II,
				Task: gn,
				TaskEventKind: iD,
				TaskGroup: un,
				TaskPanelKind: sD,
				TaskRevealKind: oD,
				TaskScope: MI,
				TerminalLink: jy,
				TerminalQuickFixTerminalCommand: Qy,
				TerminalQuickFixOpener: Gy,
				TerminalLocation: nD,
				TerminalProfile: Jy,
				TerminalExitReason: eD,
				TerminalShellExecutionCommandLineConfidence: LI,
				TerminalCompletionItem: Xy,
				TerminalCompletionItemKind: rD,
				TerminalCompletionList: Yy,
				TerminalShellType: tD,
				TextDocumentSaveReason: DI,
				TextEdit: Mn,
				SnippetTextEdit: bd,
				TextEditorCursorStyle: iP,
				TextEditorChangeKind: RI,
				TextEditorLineNumbersStyle: _I,
				TextEditorRevealType: kI,
				TextEditorSelectionChangeKind: Td,
				SyntaxTokenType: Ed,
				TextDocumentChangeReason: AI,
				ThemeColor: Is,
				ThemeIcon: Vt,
				TreeItem: Ti,
				TreeItemCheckboxState: UI,
				TreeItemCollapsibleState: NI,
				TypeHierarchyItem: Ga,
				UIKind: Yg,
				Uri: b,
				ViewColumn: wI,
				WorkspaceEdit: Yr,
				DocumentPasteTriggerKind: dD,
				DocumentDropEdit: bu,
				DocumentDropOrPasteEditKind: yo,
				DocumentPasteEdit: tI,
				InlayHint: La,
				InlayHintLabelPart: Oa,
				InlayHintKind: Y_,
				RemoteAuthorityResolverError: _i,
				ResolvedAuthority: Ky,
				ManagedResolvedAuthority: za,
				SourceControlInputBoxValidationType: Z_,
				ExtensionRuntime: ix,
				TimelineItem: xu,
				NotebookRange: cr,
				NotebookCellKind: ZI,
				NotebookCellExecutionState: mg,
				NotebookCellData: Ts,
				NotebookData: Pu,
				NotebookRendererScript: Du,
				NotebookCellStatusBarAlignment: ex,
				NotebookEditorRevealType: tx,
				NotebookCellOutput: Es,
				NotebookCellOutputItem: _u,
				CellErrorStackFrame: iI,
				NotebookCellStatusBarItem: sI,
				NotebookControllerAffinity: fD,
				NotebookControllerAffinity2: nx,
				NotebookEdit: Ur,
				NotebookKernelSourceAction: aI,
				NotebookVariablesRequestKind: rx,
				PortAttributes: dI,
				LinkedEditingRanges: lI,
				TestResultState: gD,
				TestRunRequest: $a,
				TestMessage: Pi,
				TestMessageStackFrame: cI,
				TestTag: Ss,
				TestRunProfileKind: sx,
				TextSearchCompleteMessageType: Hg,
				DataTransfer: bo,
				DataTransferItem: pd,
				TestCoverageCount: vd,
				FileCoverage: ws,
				StatementCoverage: Ru,
				BranchCoverage: Au,
				DeclarationCoverage: Ou,
				WorkspaceTrustState: vD,
				LanguageStatusSeverity: CI,
				QuickPickItemKind: QI,
				InputBoxValidationSeverity: JI,
				TabInputText: Qa,
				TabInputTextDiff: Ps,
				TabInputTextMerge: Lu,
				TabInputCustom: Ja,
				TabInputNotebook: Xa,
				TabInputNotebookDiff: Ya,
				TabInputWebview: Mu,
				TabInputTerminal: Fu,
				TabInputInteractiveWindow: Nu,
				TabInputChat: Uu,
				TabInputTextMultiDiff: Hu,
				TelemetryTrustedValue: wa,
				LogLevel: ha,
				EditSessionIdentityMatch: ZR,
				InteractiveSessionVoteDirection: yD,
				ChatCopyKind: ID,
				ChatEditingSessionActionOutcome: ax,
				InteractiveEditorResponseFeedbackKind: CD,
				DebugStackFrame: Tu,
				DebugThread: Eu,
				RelatedInformationType: PD,
				SpeechToTextStatus: _D,
				TextToSpeechStatus: DD,
				PartialAcceptTriggerKind: EI,
				KeywordRecognitionStatus: kD,
				ChatResponseMarkdownPart: _s,
				ChatResponseFileTreePart: ks,
				ChatResponseAnchorPart: ki,
				ChatResponseProgressPart: Cd,
				ChatResponseProgressPart2: Za,
				ChatResponseReferencePart: Io,
				ChatResponseReferencePart2: Io,
				ChatResponseCodeCitationPart: Os,
				ChatResponseCodeblockUriPart: As,
				ChatResponseWarningPart: Ri,
				ChatResponseTextEditPart: Ai,
				ChatResponseNotebookEditPart: Ms,
				ChatResponseMarkdownWithVulnerabilitiesPart: Di,
				ChatResponseCommandButtonPart: Rs,
				ChatResponseConfirmationPart: Ds,
				ChatResponseMovePart: Ls,
				ChatResponseReferencePartStatusKind: SD,
				ChatRequestTurn: Wu,
				ChatResponseTurn: Vu,
				ChatLocation: dx,
				ChatRequestEditorData: Bu,
				ChatRequestNotebookData: $u,
				ChatReferenceBinaryData: zu,
				LanguageModelChatMessageRole: hg,
				LanguageModelChatMessage: Ku,
				LanguageModelChatMessage2: ju,
				LanguageModelToolResultPart: Fs,
				LanguageModelTextPart: Pt,
				LanguageModelToolCallPart: xo,
				LanguageModelError: Hr,
				LanguageModelToolResult: el,
				LanguageModelDataPart: Sd,
				ChatImageMimeType: ED,
				ExtendedLanguageModelToolResult: mI,
				PreparedTerminalToolInvocation: pI,
				LanguageModelChatToolMode: wD,
				LanguageModelPromptTsxPart: Co,
				NewSymbolName: nI,
				NewSymbolNameTag: cD,
				NewSymbolNameTriggerKind: VI,
				InlineEdit: fI,
				InlineEditTriggerKind: cx,
				ExcludeSettingOptions: Rx,
				TextSearchContext2: Li,
				TextSearchMatch2: ur,
				TextSearchCompleteMessageTypeNew: Hg,
				ChatErrorLevel: TD,
				McpSSEServerDefinition: hI,
				McpStdioServerDefinition: gI,
			}
		}
	)
}
var ec = class {
	constructor(e, t, n, r, i, s, a) {
		this._apiFactory = e
		this._extensionRegistry = t
		this._instaService = n
		this._extHostConfiguration = r
		this._extHostExtensionService = i
		this._initData = s
		this._logService = a
		;(this._factories = new Map()), (this._alternatives = [])
	}
	async install() {
		this._installInterceptor(), Ct("code/extHost/willWaitForConfig")
		let e = await this._extHostConfiguration.getConfigProvider()
		Ct("code/extHost/didWaitForConfig")
		let t = await this._extHostExtensionService.getExtensionPathIndex()
		this.register(new Z1(this._apiFactory, t, this._extensionRegistry, e, this._logService)),
			this.register(this._instaService.createInstance(Sl)),
			this._initData.remote.isRemote &&
				this.register(this._instaService.createInstance($h, t, this._initData.environment.appUriScheme))
	}
	register(e) {
		if ("nodeModuleName" in e)
			if (Array.isArray(e.nodeModuleName)) for (let t of e.nodeModuleName) this._factories.set(t, e)
			else this._factories.set(e.nodeModuleName, e)
		typeof e.alternativeModuleName == "function" && this._alternatives.push((t) => e.alternativeModuleName(t))
	}
}
ec = R([S(2, Wo), S(3, pn), S(4, pr), S(5, Xe), S(6, te)], ec)
var Sl = class {
	static {
		this.aliased = new Map([
			["vscode-ripgrep", "@vscode/ripgrep"],
			["vscode-windows-registry", "@vscode/windows-registry"],
		])
	}
	constructor(e) {
		if (e.environment.appRoot && Sl.aliased.size) {
			let t = kr(this.forceForwardSlashes(e.environment.appRoot.fsPath)),
				n = "[a-z0-9_.-]",
				r = `@${n}+\\/${n}+|${n}+`,
				i = "node_modules|node_modules\\.asar(?:\\.unpacked)?"
			this.re = new RegExp(`^(${t}/${i}\\/)(${r})(.*)$`, "i")
		}
	}
	alternativeModuleName(e) {
		if (!this.re) return
		let t = this.re.exec(this.forceForwardSlashes(e))
		if (!t) return
		let [, n, r, i] = t,
			s = Sl.aliased.get(r)
		if (s !== void 0) return console.warn(`${r} as been renamed to ${s}, please update your imports`), n + s + i
	}
	forceForwardSlashes(e) {
		return e.replace(/\\/g, "/")
	}
}
Sl = R([S(0, Xe)], Sl)
var Z1 = class {
		constructor(e, t, n, r, i) {
			this._apiFactory = e
			this._extensionPaths = t
			this._extensionRegistry = n
			this._configProvider = r
			this._logService = i
			this.nodeModuleName = "vscode"
			this._extApiImpl = new Ln()
		}
		load(e, t) {
			let n = this._extensionPaths.findSubstr(t)
			if (n) {
				let r = this._extApiImpl.get(n.identifier)
				return (
					r ||
						((r = this._apiFactory(n, this._extensionRegistry, this._configProvider)),
						this._extApiImpl.set(n.identifier, r)),
					r
				)
			}
			if (!this._defaultApiImpl) {
				let r = ""
				this._extensionPaths.forEach(
					(i, s) =>
						(r += `	${s} -> ${i.identifier.value}
`),
				),
					this._logService
						.warn(`Could not identify extension for 'vscode' require call from ${t}. These are the extension path mappings: 
${r}`),
					(this._defaultApiImpl = this._apiFactory(gF, this._extensionRegistry, this._configProvider))
			}
			return this._defaultApiImpl
		}
	},
	$h = class {
		constructor(e, t, n) {
			this._extensionPaths = e
			this._appUriScheme = t
			this.nodeModuleName = ["open", "opn"]
			this._mainThreadTelemetry = n.getProxy(M.MainThreadTelemetry)
			let r = n.getProxy(M.MainThreadWindow)
			this._impl = (i, s) => {
				let a = b.parse(i)
				return s
					? this.callOriginal(i, s)
					: a.scheme === "http" || a.scheme === "https"
						? r.$openUri(a, i, { allowTunneling: !0 })
						: a.scheme === "mailto" || a.scheme === this._appUriScheme
							? r.$openUri(a, i, {})
							: this.callOriginal(i, s)
			}
		}
		load(e, t, n) {
			let r = this._extensionPaths.findSubstr(t)
			return (
				r && ((this._extensionId = r.identifier.value), this.sendShimmingTelemetry()),
				(this._original = n(e)),
				this._impl
			)
		}
		callOriginal(e, t) {
			return this.sendNoForwardTelemetry(), this._original(e, t)
		}
		sendShimmingTelemetry() {
			this._extensionId &&
				this._mainThreadTelemetry.$publicLog2("shimming.open", { extension: this._extensionId })
		}
		sendNoForwardTelemetry() {
			this._extensionId &&
				this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", { extension: this._extensionId })
		}
	}
$h = R([S(2, ie)], $h)
import {
	LogLevel as nc,
	createHttpPatch as CU,
	createProxyResolver as b$,
	createTlsPatch as y$,
	createNetPatch as I$,
	loadSystemCertificates as x$,
} from "@vscode/proxy-agent"
import { createRequire as C$ } from "module"
import { parse as IU } from "url"
import { spawn as m$ } from "child_process"
import { userInfo as d$ } from "os"
import * as e0 from "os"
var mU = /^\d+$/,
	t$ = /^Microsoft.PowerShell_.*/,
	n$ = /^Microsoft.PowerShellPreview_.*/
var zh
switch (process.arch) {
	case "ia32":
		zh = 1
		break
	case "arm":
	case "arm64":
		zh = 2
		break
	default:
		zh = 0
		break
}
var Om
process.env.PROCESSOR_ARCHITEW6432
	? (Om = process.env.PROCESSOR_ARCHITEW6432 === "ARM64" ? 2 : 0)
	: process.env.PROCESSOR_ARCHITECTURE === "ARM64"
		? (Om = 2)
		: process.env.PROCESSOR_ARCHITECTURE === "X86"
			? (Om = 1)
			: (Om = 0)
var tc = class {
	constructor(e, t, n) {
		this.exePath = e
		this.displayName = t
		this.knownToExist = n
	}
	async exists() {
		return (
			this.knownToExist === void 0 && (this.knownToExist = await ir.existsFile(this.exePath)), this.knownToExist
		)
	}
}
function r$({ useAlternateBitness: o = !1 } = {}) {
	return o
		? zh === 0
			? process.env["ProgramFiles(x86)"] || null
			: (Om === 0 && process.env.ProgramW6432) || null
		: process.env.ProgramFiles || null
}
async function gT({ useAlternateBitness: o = !1, findPreview: e = !1 } = {}) {
	let t = r$({ useAlternateBitness: o })
	if (!t) return null
	let n = Fe(t, "PowerShell")
	if (!(await ir.existsDirectory(n))) return null
	let r = -1,
		i = null
	for (let l of await Qe.readdir(n)) {
		let d = -1
		if (e) {
			let u = l.indexOf("-")
			if (u < 0) continue
			let m = l.substring(0, u)
			if (!mU.test(m) || l.substring(u + 1) !== "preview") continue
			d = parseInt(m, 10)
		} else {
			if (!mU.test(l)) continue
			d = parseInt(l, 10)
		}
		if (d <= r) continue
		let c = Fe(n, l, "pwsh.exe")
		;(await ir.existsFile(c)) && ((i = c), (r = d))
	}
	if (!i) return null
	let s = t.includes("x86") ? " (x86)" : "",
		a = e ? " Preview" : ""
	return new tc(i, `PowerShell${a}${s}`, !0)
}
async function fU({ findPreview: o } = {}) {
	if (!process.env.LOCALAPPDATA) return null
	let e = Fe(process.env.LOCALAPPDATA, "Microsoft", "WindowsApps")
	if (!(await ir.existsDirectory(e))) return null
	let { pwshMsixDirRegex: t, pwshMsixName: n } = o
		? { pwshMsixDirRegex: n$, pwshMsixName: "PowerShell Preview (Store)" }
		: { pwshMsixDirRegex: t$, pwshMsixName: "PowerShell (Store)" }
	for (let r of await Qe.readdir(e))
		if (t.test(r)) {
			let i = Fe(e, r, "pwsh.exe")
			return new tc(i, n)
		}
	return null
}
function o$() {
	let o = Fe(e0.homedir(), ".dotnet", "tools", "pwsh.exe")
	return new tc(o, ".NET Core PowerShell Global Tool")
}
function i$() {
	let o = Fe(e0.homedir(), "scoop", "apps"),
		e = Fe(o, "pwsh", "current", "pwsh.exe")
	return new tc(e, "PowerShell (Scoop)")
}
function s$() {
	let o = Fe(
		process.env.windir,
		zh === 1 && Om !== 1 ? "SysNative" : "System32",
		"WindowsPowerShell",
		"v1.0",
		"powershell.exe",
	)
	return new tc(o, "Windows PowerShell", !0)
}
async function* a$() {
	let o = await gT()
	o && (yield o),
		(o = await gT({ useAlternateBitness: !0 })),
		o && (yield o),
		(o = await fU()),
		o && (yield o),
		(o = o$()),
		o && (yield o),
		(o = await gT({ findPreview: !0 })),
		o && (yield o),
		(o = await fU({ findPreview: !0 })),
		o && (yield o),
		(o = await gT({ useAlternateBitness: !0, findPreview: !0 })),
		o && (yield o),
		(o = await i$()),
		o && (yield o),
		(o = s$()),
		o && (yield o)
}
async function* l$() {
	for await (let o of a$()) (await o.exists()) && (yield o)
}
async function gU() {
	for await (let o of l$()) return o
	return null
}
async function hU(o, e) {
	return o === 1 ? (Ie ? u$() : SC(e)) : c$(o, e)
}
var t0 = null
function c$(o, e) {
	if ((Ve && o === 2) || (st && o === 3)) return "/bin/bash"
	if (!t0) {
		let t
		if (Ie) t = "/bin/bash"
		else {
			if (((t = e.SHELL), !t))
				try {
					t = d$().shell
				} catch {}
			t || (t = "sh"), t === "/bin/false" && (t = "/bin/bash")
		}
		t0 = t
	}
	return t0
}
var n0 = null
async function u$() {
	return n0 || (n0 = (await gU()).exePath), n0
}
import Gqe from "minimist"
var Xqe = {
	o: p("optionsUpperCase", "Options"),
	e: p("extensionsManagement", "Extensions Management"),
	t: p("troubleshooting", "Troubleshooting"),
}
var p$ = {
	tunnel: {
		type: "subcommand",
		description: "Make the current machine accessible from vscode.dev or other machines through a secure tunnel",
		options: {
			"cli-data-dir": {
				type: "string",
				args: "dir",
				description: p("cliDataDir", "Directory where CLI metadata should be stored."),
			},
			"disable-telemetry": { type: "boolean" },
			"telemetry-level": { type: "string" },
			user: {
				type: "subcommand",
				options: {
					login: {
						type: "subcommand",
						options: { provider: { type: "string" }, "access-token": { type: "string" } },
					},
				},
			},
		},
	},
	"serve-web": {
		type: "subcommand",
		description: "Run a server that displays the editor UI in browsers.",
		options: {
			"cli-data-dir": {
				type: "string",
				args: "dir",
				description: p("cliDataDir", "Directory where CLI metadata should be stored."),
			},
			"disable-telemetry": { type: "boolean" },
			"telemetry-level": { type: "string" },
		},
	},
	diff: {
		type: "boolean",
		cat: "o",
		alias: "d",
		args: ["file", "file"],
		description: p("diff", "Compare two files with each other."),
	},
	merge: {
		type: "boolean",
		cat: "o",
		alias: "m",
		args: ["path1", "path2", "base", "result"],
		description: p(
			"merge",
			"Perform a three-way merge by providing paths for two modified versions of a file, the common origin of both modified versions and the output file to save merge results.",
		),
	},
	add: {
		type: "boolean",
		cat: "o",
		alias: "a",
		args: "folder",
		description: p("add", "Add folder(s) to the last active window."),
	},
	remove: {
		type: "boolean",
		cat: "o",
		args: "folder",
		description: p("remove", "Remove folder(s) from the last active window."),
	},
	goto: {
		type: "boolean",
		cat: "o",
		alias: "g",
		args: "file:line[:character]",
		description: p("goto", "Open a file at the path on the specified line and character position."),
	},
	"new-window": { type: "boolean", cat: "o", alias: "n", description: p("newWindow", "Force to open a new window.") },
	"reuse-window": {
		type: "boolean",
		cat: "o",
		alias: "r",
		description: p("reuseWindow", "Force to open a file or folder in an already opened window."),
	},
	wait: {
		type: "boolean",
		cat: "o",
		alias: "w",
		description: p("wait", "Wait for the files to be closed before returning."),
	},
	waitMarkerFilePath: { type: "string" },
	locale: {
		type: "string",
		cat: "o",
		args: "locale",
		description: p("locale", "The locale to use (e.g. en-US or zh-TW)."),
	},
	"user-data-dir": {
		type: "string",
		cat: "o",
		args: "dir",
		description: p(
			"userDataDir",
			"Specifies the directory that user data is kept in. Can be used to open multiple distinct instances of Code.",
		),
	},
	profile: {
		type: "string",
		cat: "o",
		args: "profileName",
		description: p(
			"profileName",
			"Opens the provided folder or workspace with the given profile and associates the profile with the workspace. If the profile does not exist, a new empty one is created.",
		),
	},
	help: { type: "boolean", cat: "o", alias: "h", description: p("help", "Print usage.") },
	"extensions-dir": {
		type: "string",
		deprecates: ["extensionHomePath"],
		cat: "e",
		args: "dir",
		description: p("extensionHomePath", "Set the root path for extensions."),
	},
	"extensions-download-dir": { type: "string" },
	"builtin-extensions-dir": { type: "string" },
	"list-extensions": {
		type: "boolean",
		cat: "e",
		description: p("listExtensions", "List the installed extensions."),
	},
	"show-versions": {
		type: "boolean",
		cat: "e",
		description: p("showVersions", "Show versions of installed extensions, when using --list-extensions."),
	},
	category: {
		type: "string",
		allowEmptyValue: !0,
		cat: "e",
		description: p("category", "Filters installed extensions by provided category, when using --list-extensions."),
		args: "category",
	},
	"install-extension": {
		type: "string[]",
		cat: "e",
		args: "ext-id | path",
		description: p(
			"installExtension",
			"Installs or updates an extension. The argument is either an extension id or a path to a VSIX. The identifier of an extension is '${publisher}.${name}'. Use '--force' argument to update to latest version. To install a specific version provide '@${version}'. For example: 'vscode.csharp@1.2.3'.",
		),
	},
	"pre-release": {
		type: "boolean",
		cat: "e",
		description: p(
			"install prerelease",
			"Installs the pre-release version of the extension, when using --install-extension",
		),
	},
	"uninstall-extension": {
		type: "string[]",
		cat: "e",
		args: "ext-id",
		description: p("uninstallExtension", "Uninstalls an extension."),
	},
	"update-extensions": {
		type: "boolean",
		cat: "e",
		description: p("updateExtensions", "Update the installed extensions."),
	},
	"enable-proposed-api": {
		type: "string[]",
		allowEmptyValue: !0,
		cat: "e",
		args: "ext-id",
		description: p(
			"experimentalApis",
			"Enables proposed API features for extensions. Can receive one or more extension IDs to enable individually.",
		),
	},
	"add-mcp": {
		type: "string[]",
		cat: "o",
		args: "json",
		description: p(
			"addMcp",
			`Adds a Model Context Protocol server definition to the user profile, or workspace or folder when used with --mcp-workspace. Accepts JSON input in the form '{"name":"server-name","command":...}'`,
		),
	},
	version: { type: "boolean", cat: "t", alias: "v", description: p("version", "Print version.") },
	verbose: {
		type: "boolean",
		cat: "t",
		global: !0,
		description: p("verbose", "Print verbose output (implies --wait)."),
	},
	log: {
		type: "string[]",
		cat: "t",
		args: "level",
		global: !0,
		description: p(
			"log",
			"Log level to use. Default is 'info'. Allowed values are 'critical', 'error', 'warn', 'info', 'debug', 'trace', 'off'. You can also configure the log level of an extension by passing extension id and log level in the following format: '${publisher}.${name}:${logLevel}'. For example: 'vscode.csharp:trace'. Can receive one or more such entries.",
		),
	},
	status: {
		type: "boolean",
		alias: "s",
		cat: "t",
		description: p("status", "Print process usage and diagnostics information."),
	},
	"prof-startup": { type: "boolean", cat: "t", description: p("prof-startup", "Run CPU profiler during startup.") },
	"prof-append-timers": { type: "string" },
	"prof-duration-markers": { type: "string[]" },
	"prof-duration-markers-file": { type: "string" },
	"no-cached-data": { type: "boolean" },
	"prof-startup-prefix": { type: "string" },
	"prof-v8-extensions": { type: "boolean" },
	"disable-extensions": {
		type: "boolean",
		deprecates: ["disableExtensions"],
		cat: "t",
		description: p(
			"disableExtensions",
			"Disable all installed extensions. This option is not persisted and is effective only when the command opens a new window.",
		),
	},
	"disable-extension": {
		type: "string[]",
		cat: "t",
		args: "ext-id",
		description: p(
			"disableExtension",
			"Disable the provided extension. This option is not persisted and is effective only when the command opens a new window.",
		),
	},
	sync: { type: "string", cat: "t", description: p("turn sync", "Turn sync on or off."), args: ["on | off"] },
	"inspect-extensions": {
		type: "string",
		allowEmptyValue: !0,
		deprecates: ["debugPluginHost"],
		args: "port",
		cat: "t",
		description: p(
			"inspect-extensions",
			"Allow debugging and profiling of extensions. Check the developer tools for the connection URI.",
		),
	},
	"inspect-brk-extensions": {
		type: "string",
		allowEmptyValue: !0,
		deprecates: ["debugBrkPluginHost"],
		args: "port",
		cat: "t",
		description: p(
			"inspect-brk-extensions",
			"Allow debugging and profiling of extensions with the extension host being paused after start. Check the developer tools for the connection URI.",
		),
	},
	"disable-lcd-text": { type: "boolean", cat: "t", description: p("disableLCDText", "Disable LCD font rendering.") },
	"disable-gpu": { type: "boolean", cat: "t", description: p("disableGPU", "Disable GPU hardware acceleration.") },
	"disable-chromium-sandbox": {
		type: "boolean",
		cat: "t",
		description: p(
			"disableChromiumSandbox",
			"Use this option only when there is requirement to launch the application as sudo user on Linux or when running as an elevated user in an applocker environment on Windows.",
		),
	},
	sandbox: { type: "boolean" },
	"locate-shell-integration-path": {
		type: "string",
		cat: "t",
		args: ["shell"],
		description: p(
			"locateShellIntegrationPath",
			"Print the path to a terminal shell integration script. Allowed values are 'bash', 'pwsh', 'zsh' or 'fish'.",
		),
	},
	telemetry: {
		type: "boolean",
		cat: "t",
		description: p("telemetry", "Shows all telemetry events which VS code collects."),
	},
	remote: { type: "string", allowEmptyValue: !0 },
	"folder-uri": { type: "string[]", cat: "o", args: "uri" },
	"file-uri": { type: "string[]", cat: "o", args: "uri" },
	"locate-extension": { type: "string[]" },
	extensionDevelopmentPath: { type: "string[]" },
	extensionDevelopmentKind: { type: "string[]" },
	extensionTestsPath: { type: "string" },
	extensionEnvironment: { type: "string" },
	debugId: { type: "string" },
	debugRenderer: { type: "boolean" },
	"inspect-ptyhost": { type: "string", allowEmptyValue: !0 },
	"inspect-brk-ptyhost": { type: "string", allowEmptyValue: !0 },
	"inspect-search": { type: "string", deprecates: ["debugSearch"], allowEmptyValue: !0 },
	"inspect-brk-search": { type: "string", deprecates: ["debugBrkSearch"], allowEmptyValue: !0 },
	"inspect-sharedprocess": { type: "string", allowEmptyValue: !0 },
	"inspect-brk-sharedprocess": { type: "string", allowEmptyValue: !0 },
	"export-default-configuration": { type: "string" },
	"install-source": { type: "string" },
	"enable-smoke-test-driver": { type: "boolean" },
	logExtensionHostCommunication: { type: "boolean" },
	"skip-release-notes": { type: "boolean" },
	"skip-welcome": { type: "boolean" },
	"disable-telemetry": { type: "boolean" },
	"disable-updates": { type: "boolean" },
	"use-inmemory-secretstorage": { type: "boolean", deprecates: ["disable-keytar"] },
	"password-store": { type: "string" },
	"disable-workspace-trust": { type: "boolean" },
	"disable-crash-reporter": { type: "boolean" },
	"crash-reporter-directory": { type: "string" },
	"crash-reporter-id": { type: "string" },
	"skip-add-to-recently-opened": { type: "boolean" },
	"open-url": { type: "boolean" },
	"file-write": { type: "boolean" },
	"file-chmod": { type: "boolean" },
	"install-builtin-extension": { type: "string[]" },
	force: { type: "boolean" },
	"do-not-sync": { type: "boolean" },
	"do-not-include-pack-dependencies": { type: "boolean" },
	trace: { type: "boolean" },
	"trace-memory-infra": { type: "boolean" },
	"trace-category-filter": { type: "string" },
	"trace-options": { type: "string" },
	"preserve-env": { type: "boolean" },
	"force-user-env": { type: "boolean" },
	"force-disable-user-env": { type: "boolean" },
	"open-devtools": { type: "boolean" },
	"disable-gpu-sandbox": { type: "boolean" },
	logsPath: { type: "string" },
	"__enable-file-policy": { type: "boolean" },
	editSessionId: { type: "string" },
	continueOn: { type: "string" },
	"enable-coi": { type: "boolean" },
	"unresponsive-sample-interval": { type: "string" },
	"unresponsive-sample-period": { type: "string" },
	"no-proxy-server": { type: "boolean" },
	"no-sandbox": { type: "boolean", alias: "sandbox" },
	"proxy-server": { type: "string" },
	"proxy-bypass-list": { type: "string" },
	"proxy-pac-url": { type: "string" },
	"js-flags": { type: "string" },
	inspect: { type: "string", allowEmptyValue: !0 },
	"inspect-brk": { type: "string", allowEmptyValue: !0 },
	nolazy: { type: "boolean" },
	"force-device-scale-factor": { type: "string" },
	"force-renderer-accessibility": { type: "boolean" },
	"ignore-certificate-errors": { type: "boolean" },
	"allow-insecure-localhost": { type: "boolean" },
	"log-net-log": { type: "string" },
	vmodule: { type: "string" },
	_urls: { type: "string[]" },
	"disable-dev-shm-usage": { type: "boolean" },
	"profile-temp": { type: "boolean" },
	"ozone-platform": { type: "string" },
	"enable-tracing": { type: "string" },
	"trace-startup-format": { type: "string" },
	"trace-startup-file": { type: "string" },
	"trace-startup-duration": { type: "string" },
	"xdg-portal-required-version": { type: "string" },
	_: { type: "string[]" },
}
function r0(o) {
	return o.VSCODE_CLI === "1"
}
var o0
async function vU(o, e, t, n) {
	return t["force-disable-user-env"]
		? (e.trace("resolveShellEnv(): skipped (--force-disable-user-env)"), {})
		: Ie
			? (e.trace("resolveShellEnv(): skipped (Windows)"), {})
			: r0(n) && !t["force-user-env"]
				? (e.trace("resolveShellEnv(): skipped (VSCODE_CLI is set)"), {})
				: (r0(n)
						? e.trace("resolveShellEnv(): running (--force-user-env)")
						: e.trace("resolveShellEnv(): running (macOS/Linux)"),
					o0 ||
						(o0 = lo.withAsyncBody(async (r, i) => {
							let s = new _e(),
								a = 1e4,
								l = o.getValue("application.shellEnvironmentResolutionTimeout")
							typeof l == "number" && (a = mL(l, 1, 120) * 1e3)
							let d = setTimeout(() => {
								s.dispose(!0),
									i(
										new Error(
											p(
												"resolveShellEnvTimeout",
												"Unable to resolve your shell environment in a reasonable time. Please review your shell configuration and restart.",
											),
										),
									)
							}, a)
							try {
								r(await f$(e, s.token))
							} catch (c) {
								!bn(c) && !s.token.isCancellationRequested
									? i(
											new Error(
												p(
													"resolveShellEnvError",
													"Unable to resolve your shell environment: {0}",
													Xn(c),
												),
											),
										)
									: r({})
							} finally {
								clearTimeout(d), s.dispose()
							}
						})),
					o0)
}
async function f$(o, e) {
	let t = process.env.ELECTRON_RUN_AS_NODE
	o.trace("getUnixShellEnvironment#runAsNode", t)
	let n = process.env.ELECTRON_NO_ATTACH_CONSOLE
	o.trace("getUnixShellEnvironment#noAttach", n)
	let r = He().replace(/-/g, "").substr(0, 12),
		i = new RegExp(r + "({.*})" + r),
		s = {
			...process.env,
			ELECTRON_RUN_AS_NODE: "1",
			ELECTRON_NO_ATTACH_CONSOLE: "1",
			VSCODE_RESOLVING_ENVIRONMENT: "1",
		}
	o.trace("getUnixShellEnvironment#env", s)
	let a = await hU(Ll, s)
	return (
		o.trace("getUnixShellEnvironment#shell", a),
		new Promise((l, d) => {
			if (e.isCancellationRequested) return d(new xt())
			let c = Ze(a),
				u,
				m,
				f = ""
			;/^(?:pwsh|powershell)(?:-preview)?$/.test(c)
				? ((u = `& '${process.execPath}' ${f} -p '''${r}'' + JSON.stringify(process.env) + ''${r}'''`),
					(m = ["-Login", "-Command"]))
				: c === "nu"
					? ((u = `^'${process.execPath}' ${f} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
						(m = ["-i", "-l", "-c"]))
					: c === "xonsh"
						? ((u = `import os, json; print("${r}", json.dumps(dict(os.environ)), "${r}")`),
							(m = ["-i", "-l", "-c"]))
						: ((u = `'${process.execPath}' ${f} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
							c === "tcsh" || c === "csh" ? (m = ["-ic"]) : (m = ["-i", "-l", "-c"])),
				o.trace("getUnixShellEnvironment#spawn", JSON.stringify(m), u)
			let h = m$(a, [...m, u], { detached: !0, stdio: ["ignore", "pipe", "pipe"], env: s })
			e.onCancellationRequested(() => (h.kill(), d(new xt()))),
				h.on("error", (C) => {
					o.error("getUnixShellEnvironment#errorChildProcess", Xn(C)), d(C)
				})
			let g = []
			h.stdout.on("data", (C) => g.push(C))
			let I = []
			h.stderr.on("data", (C) => I.push(C)),
				h.on("close", (C, T) => {
					let w = Buffer.concat(g).toString("utf8")
					o.trace("getUnixShellEnvironment#raw", w)
					let L = Buffer.concat(I).toString("utf8")
					if ((L.trim() && o.trace("getUnixShellEnvironment#stderr", L), C || T))
						return d(
							new Error(
								p(
									"resolveShellEnvExitError",
									"Unexpected exit code from spawned shell (code {0}, signal {1})",
									C,
									T,
								),
							),
						)
					let A = i.exec(w),
						J = A ? A[1] : "{}"
					try {
						let ne = JSON.parse(J)
						t ? (ne.ELECTRON_RUN_AS_NODE = t) : delete ne.ELECTRON_RUN_AS_NODE,
							n ? (ne.ELECTRON_NO_ATTACH_CONSOLE = n) : delete ne.ELECTRON_NO_ATTACH_CONSOLE,
							delete ne.VSCODE_RESOLVING_ENVIRONMENT,
							delete ne.XDG_RUNTIME_DIR,
							o.trace("getUnixShellEnvironment#result", ne),
							l(ne)
					} catch (ne) {
						o.error("getUnixShellEnvironment#errorCaught", Xn(ne)), d(ne)
					}
				})
		})
	)
}
import { parse as bU } from "url"
function g$(o, e) {
	return o.protocol === "http:"
		? e.HTTP_PROXY || e.http_proxy || null
		: (o.protocol === "https:" && (e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy)) || null
}
async function yU(o, e, t = {}) {
	let n = bU(o),
		r = t.proxyUrl || g$(n, e)
	if (!r) return null
	let i = bU(r)
	if (!/^https?:$/.test(i.protocol || "")) return null
	let s = {
		host: i.hostname || "",
		port: (i.port ? +i.port : 0) || (i.protocol === "https" ? 443 : 80),
		auth: i.auth,
		rejectUnauthorized: uv(t.strictSSL) ? t.strictSSL : !0,
	}
	if (n.protocol === "http:") {
		let { default: a } = await import("http-proxy-agent")
		return new a.HttpProxyAgent(r, s)
	} else {
		let { default: a } = await import("https-proxy-agent")
		return new a.HttpsProxyAgent(r, s)
	}
}
import { createGunzip as h$ } from "zlib"
var hT = class extends gy {
	constructor(t, n, r, i) {
		super(i)
		this.machine = t
		this.configurationService = n
		this.environmentService = r
		this.configure(),
			this._register(
				n.onDidChangeConfiguration((s) => {
					s.affectsConfiguration("http") && this.configure()
				}),
			)
	}
	configure() {
		;(this.proxyUrl = this.getConfigValue("http.proxy")),
			(this.strictSSL = !!this.getConfigValue("http.proxyStrictSSL")),
			(this.authorization = this.getConfigValue("http.proxyAuthorization"))
	}
	async request(t, n) {
		let { proxyUrl: r, strictSSL: i } = this,
			s
		try {
			s = await vU(this.configurationService, this.logService, this.environmentService.args, process.env)
		} catch (d) {
			this.shellEnvErrorLogged ||
				((this.shellEnvErrorLogged = !0), this.logService.error("resolving shell environment failed", nf(d)))
		}
		let a = { ...process.env, ...s },
			l = t.agent ? t.agent : await yU(t.url || "", a, { proxyUrl: r, strictSSL: i })
		return (
			(t.agent = l),
			(t.strictSSL = i),
			this.authorization && (t.headers = { ...(t.headers || {}), "Proxy-Authorization": this.authorization }),
			this.logAndRequest(t, () => xU(t, n))
		)
	}
	async resolveProxy(t) {}
	async lookupAuthorization(t) {}
	async lookupKerberosAuthorization(t) {
		try {
			let n = this.getConfigValue("http.proxyKerberosServicePrincipal")
			return "Negotiate " + (await i0(t, n, this.logService, "RequestService#lookupKerberosAuthorization"))
		} catch (n) {
			this.logService.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed", n)
			return
		}
	}
	async loadCertificates() {
		return (await import("@vscode/proxy-agent")).loadSystemCertificates({ log: this.logService })
	}
	getConfigValue(t) {
		if (this.machine === "remote") return this.configurationService.getValue(t)
		let n = this.configurationService.inspect(t)
		return n.userLocalValue || n.defaultValue
	}
}
hT = R([S(1, br), S(2, JM), S(3, te)], hT)
async function i0(o, e, t, n) {
	let r = await import("kerberos"),
		i = r.default || r,
		s = new URL(o),
		a = e || (process.platform === "win32" ? `HTTP/${s.hostname}` : `HTTP@${s.hostname}`)
	return (
		t.debug(`${n} Kerberos authentication lookup`, `proxyURL:${s}`, `spn:${a}`),
		(await i.initializeClient(a)).step("")
	)
}
async function v$(o) {
	return (IU(o.url).protocol === "https:" ? await import("https") : await import("http")).request
}
async function xU(o, e) {
	return lo.withAsyncBody(async (t, n) => {
		let r = IU(o.url),
			i = o.getRawRequest ? o.getRawRequest(o) : await v$(o),
			s = {
				hostname: r.hostname,
				port: r.port ? parseInt(r.port) : r.protocol === "https:" ? 443 : 80,
				protocol: r.protocol,
				path: r.path,
				method: o.type || "GET",
				headers: o.headers,
				agent: o.agent,
				rejectUnauthorized: uv(o.strictSSL) ? o.strictSSL : !0,
			}
		o.user && o.password && (s.auth = o.user + ":" + o.password), o.disableCache && (s.cache = "no-store")
		let a = i(s, (l) => {
			let d = fn(o.followRedirects) ? o.followRedirects : 3
			if (l.statusCode && l.statusCode >= 300 && l.statusCode < 400 && d > 0 && l.headers.location)
				xU({ ...o, url: l.headers.location, followRedirects: d - 1 }, e).then(t, n)
			else {
				let c = l
				!o.isChromiumNetwork && l.headers["content-encoding"] === "gzip" && (c = l.pipe(h$())),
					t({ res: l, stream: xA(c) })
			}
		})
		if ((a.on("error", n), o.timeout))
			if (o.isChromiumNetwork) {
				let l = setTimeout(() => {
					a.abort(), n(new Error(`Request timeout after ${o.timeout}ms`))
				}, o.timeout)
				a.on("response", () => clearTimeout(l)),
					a.on("error", () => clearTimeout(l)),
					a.on("abort", () => clearTimeout(l))
			} else a.setTimeout(o.timeout)
		o.isChromiumNetwork && a.removeHeader("Content-Length"),
			o.data && typeof o.data == "string" && a.write(o.data),
			a.end(),
			e.onCancellationRequested(() => {
				a.abort(), n(new xt())
			})
	})
}
import * as rc from "@vscode/proxy-agent"
var Mm = C$(import.meta.url),
	SU = Mm("http"),
	bT = Mm("https"),
	TU = Mm("tls"),
	EU = Mm("net"),
	RU = !1,
	wU = !1
function AU(o, e, t, n, r, i, s) {
	let a = i.remote.isRemote,
		l = i.environment.useHostProxy ?? !a,
		d = l,
		c = l,
		u = () => !a || e.getConfiguration("http").get("useLocalProxyConfiguration", l),
		m = {
			resolveProxy: (C) => o.resolveProxy(C),
			lookupProxyAuthorization: k$.bind(void 0, o, n, r, e, {}, {}, i.remote.isRemote, d),
			getProxyURL: () => Xs(e, a, "http.proxy"),
			getProxySupport: () => Xs(e, a, "http.proxySupport") || "off",
			getNoProxyConfig: () => Xs(e, a, "http.noProxy") || [],
			isAdditionalFetchSupportEnabled: () => Xs(e, a, "http.fetchAdditionalSupport", !0),
			addCertificatesV1: () => P$(e, a),
			addCertificatesV2: () => _$(e, a),
			log: n,
			getLogLevel: () => {
				let C = n.getLevel()
				switch (C) {
					case 1:
						return nc.Trace
					case 2:
						return nc.Debug
					case 3:
						return nc.Info
					case 4:
						return nc.Warning
					case 5:
						return nc.Error
					case 0:
						return nc.Off
					default:
						return T(C)
				}
				function T(w) {
					return n.error("Unknown log level", w), nc.Debug
				}
			},
			proxyResolveTelemetry: () => {},
			isUseHostProxyEnabled: u,
			loadAdditionalCertificates: async () => {
				let C = []
				if ((i.remote.isRemote && C.push(x$({ log: n })), c)) {
					n.trace("ProxyResolver#loadAdditionalCertificates: Loading certificates from main process")
					let T = o.loadCertificates()
					T.then((w) =>
						n.trace(
							"ProxyResolver#loadAdditionalCertificates: Loaded certificates from main process",
							w.length,
						),
					),
						C.push(T)
				}
				return (
					i.environment.extensionTestsLocationURI &&
						bT.globalAgent.testCertificates?.length &&
						(n.trace("ProxyResolver#loadAdditionalCertificates: Loading test certificates"),
						C.push(Promise.resolve(bT.globalAgent.testCertificates))),
					(await Promise.all(C)).flat()
				)
			},
			env: process.env,
		},
		{ resolveProxyWithRequest: f, resolveProxyURL: h } = b$(m),
		g = rc.default || rc
	;(g.resolveProxyURL = h), T$(m, e, r, i, h, s)
	let I = w$(m, f)
	return D$(t, I)
}
var S$ = [
	"content-length",
	"host",
	"trailer",
	"te",
	"upgrade",
	"cookie2",
	"keep-alive",
	"transfer-encoding",
	"set-cookie",
]
function T$(o, e, t, n, r, i) {
	if (!globalThis.__vscodeOriginalFetch) {
		let s = globalThis.fetch
		globalThis.__vscodeOriginalFetch = s
		let a = rc.createFetchPatch(o, s, r)
		globalThis.__vscodePatchedFetch = a
		let l = !1
		n.remote.isRemote ||
			((l = e.getConfiguration("http").get("electronFetch", wU)),
			i.add(
				e.onDidChangeConfiguration((d) => {
					d.affectsConfiguration("http.electronFetch") &&
						(l = e.getConfiguration("http").get("electronFetch", wU))
				}),
			)),
			(globalThis.fetch = async function (c, u) {
				function m(A) {
					return u && A in u ? u[A] : typeof c == "object" && "cache" in c ? c[A] : void 0
				}
				let f = typeof c == "string" ? c : "cache" in c ? c.url : c.toString(),
					h = f.startsWith("data:")
				h && Lm(t, "data")
				let g = f.startsWith("blob:")
				g && Lm(t, "blob")
				let I = m("redirect") === "manual"
				I && Lm(t, "manualRedirect")
				let C = m("integrity")
				if ((C && Lm(t, "integrity"), !l || h || g || I || C)) {
					let A = await a(c, u)
					return PU(t, A, f), A
				}
				if (u?.headers) {
					let A = new Headers(u.headers)
					for (let J of S$) A.delete(J)
					u = { ...u, headers: A }
				}
				let T = c instanceof URL ? c.toString() : c,
					L = await Mm("electron").net.fetch(T, u)
				return PU(t, L, f), L
			})
	}
}
function PU(o, e, t) {
	let n = e.url
	Object.defineProperty(e, "url", {
		get() {
			return Lm(o, "url"), n || t
		},
	})
	let r = e.type
	Object.defineProperty(e, "type", {
		get() {
			return Lm(o, "typeProperty"), r !== "default" ? r : "basic"
		},
	})
}
var _U = { url: 0, typeProperty: 0, data: 0, blob: 0, integrity: 0, manualRedirect: 0 },
	vT,
	E$ = !1
function Lm(o, e) {
	E$ &&
		!_U[e]++ &&
		(vT && clearTimeout(vT),
		(vT = setTimeout(() => {
			o.$publicLog2("fetchFeatureUse", _U)
		}, 1e4)),
		vT.unref())
}
function w$(o, e) {
	function t(n, r) {
		let i = n.default || n
		return (i.__vscodeOriginal = Object.assign({}, i)), Object.assign(i, r)
	}
	return { http: t(SU, CU(o, SU, e)), https: t(bT, CU(o, bT, e)), net: t(EU, I$(o, EU)), tls: t(TU, y$(o, TU)) }
}
function P$(o, e) {
	return !Xs(o, e, "http.experimental.systemCertificatesV2", RU) && !!Xs(o, e, "http.systemCertificates")
}
function _$(o, e) {
	return !!Xs(o, e, "http.experimental.systemCertificatesV2", RU) && !!Xs(o, e, "http.systemCertificates")
}
var DU = new Map()
function D$(o, e) {
	return o.getExtensionPathIndex().then((t) => {
		let n = Mm("module"),
			r = n._load
		n._load = function (s, a, l) {
			if (s === "net") return e.net
			if (s === "tls") return e.tls
			if (s !== "http" && s !== "https" && s !== "undici") return r.apply(this, arguments)
			let d = t.findSubstr(b.file(a.filename)),
				c = DU.get(d)
			if ((c || DU.set(d, (c = {})), !c[s]))
				if (s === "undici") {
					let u = r.apply(this, arguments)
					rc.patchUndici(u), (c[s] = u)
				} else {
					let u = e[s]
					c[s] = { ...u }
				}
			return c[s]
		}
	})
}
async function k$(o, e, t, n, r, i, s, a, l, d, c) {
	let u = r[l]
	d && (r[l] = d),
		e.trace(
			"ProxyResolver#lookupProxyAuthorization callback",
			`proxyURL:${l}`,
			`proxyAuthenticate:${d}`,
			`proxyAuthenticateCache:${u}`,
		)
	let m = d || u,
		f = Array.isArray(m) ? m : typeof m == "string" ? [m] : []
	if ((A$(t, f, s), f.some((g) => /^(Negotiate|Kerberos)( |$)/i.test(g)) && !c.kerberosRequested)) {
		c.kerberosRequested = !0
		try {
			let g = Xs(n, s, "http.proxyKerberosServicePrincipal")
			return "Negotiate " + (await i0(l, g, e, "ProxyResolver#lookupProxyAuthorization"))
		} catch (g) {
			e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication failed", g)
		}
		if (s && a) {
			e.debug("ProxyResolver#lookupProxyAuthorization Kerberos authentication lookup on host", `proxyURL:${l}`)
			let g = await o.lookupKerberosAuthorization(l)
			if (g) return "Negotiate " + g
		}
	}
	let h = f.find((g) => /^Basic( |$)/i.test(g))
	if (h)
		try {
			let g = i[l]
			if (g)
				if (c.basicAuthCacheUsed)
					e.debug(
						"ProxyResolver#lookupProxyAuthorization Basic authentication deleting cached credentials",
						`proxyURL:${l}`,
					),
						delete i[l]
				else
					return (
						e.debug(
							"ProxyResolver#lookupProxyAuthorization Basic authentication using cached credentials",
							`proxyURL:${l}`,
						),
						(c.basicAuthCacheUsed = !0),
						g
					)
			c.basicAuthAttempt = (c.basicAuthAttempt || 0) + 1
			let I = / realm="([^"]+)"/i.exec(h)?.[1]
			e.debug("ProxyResolver#lookupProxyAuthorization Basic authentication lookup", `proxyURL:${l}`, `realm:${I}`)
			let C = new URL(l),
				T = {
					scheme: "basic",
					host: C.hostname,
					port: Number(C.port),
					realm: I || "",
					isProxy: !0,
					attempt: c.basicAuthAttempt,
				},
				w = await o.lookupAuthorization(T)
			if (w) {
				e.debug(
					"ProxyResolver#lookupProxyAuthorization Basic authentication received credentials",
					`proxyURL:${l}`,
					`realm:${I}`,
				)
				let L = "Basic " + Buffer.from(`${w.username}:${w.password}`).toString("base64")
				return (i[l] = L), L
			} else
				e.debug(
					"ProxyResolver#lookupProxyAuthorization Basic authentication received no credentials",
					`proxyURL:${l}`,
					`realm:${I}`,
				)
		} catch (g) {
			e.error("ProxyResolver#lookupProxyAuthorization Basic authentication failed", g)
		}
}
var kU = !1,
	R$ = !1
function A$(o, e, t) {
	!R$ ||
		kU ||
		!e.length ||
		((kU = !0),
		o.$publicLog2("proxyAuthenticationRequest", {
			authenticationType: e.map((n) => n.split(" ")[0]).join(","),
			extensionHostType: t ? "remote" : "local",
		}))
}
function Xs(o, e, t, n) {
	if (e) return o.getConfiguration().get(t) ?? n
	let r = o.getConfiguration().inspect(t)
	return r?.globalLocalValue ?? r?.defaultValue ?? n
}
import { tmpdir as O$ } from "os"
var Fm = class extends $ {
	constructor(e, t) {
		super()
		let n = e.getProxy(M.MainThreadDownloadService)
		t.registerCommand(!1, "_workbench.downloadResource", async (r) => {
			let i = b.file(Fe(O$(), He()))
			return await n.$download(r, i), i
		})
	}
}
Fm = R([S(0, ie), S(1, Tn)], Fm)
import * as OU from "http"
import * as yT from "fs"
var s0 = class {
		constructor(e, t, n) {
			this._commands = e
			this.logService = t
			this._ipcHandlePath = n
			;(this._server = OU.createServer((r, i) => this.onRequest(r, i))),
				this.setup().catch((r) => (t.error(r), ""))
		}
		get ipcHandlePath() {
			return this._ipcHandlePath
		}
		async setup() {
			try {
				this._server.listen(this.ipcHandlePath), this._server.on("error", (e) => this.logService.error(e))
			} catch {
				this.logService.error("Could not start open from terminal server.")
			}
			return this._ipcHandlePath
		}
		onRequest(e, t) {
			let n = (i, s) => {
					t.writeHead(i, { "content-type": "application/json" }),
						t.end(JSON.stringify(s || null), (a) => a && this.logService.error(a))
				},
				r = []
			e.setEncoding("utf8"),
				e.on("data", (i) => r.push(i)),
				e.on("end", async () => {
					try {
						let i = JSON.parse(r.join("")),
							s
						switch (i.type) {
							case "open":
								s = await this.open(i)
								break
							case "openExternal":
								s = await this.openExternal(i)
								break
							case "status":
								s = await this.getStatus(i)
								break
							case "extensionManagement":
								s = await this.manageExtensions(i)
								break
							default:
								n(404, `Unknown message type: ${i.type}`)
								break
						}
						n(200, s)
					} catch (i) {
						let s = i instanceof Error ? i.message : JSON.stringify(i)
						n(500, s), this.logService.error("Error while processing pipe request", i)
					}
				})
		}
		async open(e) {
			let {
					fileURIs: t,
					folderURIs: n,
					forceNewWindow: r,
					diffMode: i,
					mergeMode: s,
					addMode: a,
					removeMode: l,
					forceReuseWindow: d,
					gotoLineMode: c,
					waitMarkerFilePath: u,
					remoteAuthority: m,
				} = e,
				f = []
			if (Array.isArray(n))
				for (let C of n)
					try {
						f.push({ folderUri: b.parse(C) })
					} catch {}
			if (Array.isArray(t))
				for (let C of t)
					try {
						SL(C) ? f.push({ workspaceUri: b.parse(C) }) : f.push({ fileUri: b.parse(C) })
					} catch {}
			let h = u ? b.file(u) : void 0,
				I = {
					forceNewWindow: r,
					diffMode: i,
					mergeMode: s,
					addMode: a,
					removeMode: l,
					gotoLineMode: c,
					forceReuseWindow: d,
					preferNewWindow: !d && !h && !a && !l,
					waitMarkerFileURI: h,
					remoteAuthority: m,
				}
			this._commands.executeCommand("_remoteCLI.windowOpen", f, I)
		}
		async openExternal(e) {
			for (let t of e.uris) {
				let n = b.parse(t),
					r = n.scheme === "file" ? n : t
				await this._commands.executeCommand("_remoteCLI.openExternal", r)
			}
		}
		async manageExtensions(e) {
			let t = (r) => r?.map((i) => (/\.vsix$/i.test(i) ? b.parse(i) : i)),
				n = { list: e.list, install: t(e.install), uninstall: t(e.uninstall), force: e.force }
			return await this._commands.executeCommand("_remoteCLI.manageExtensions", n)
		}
		async getStatus(e) {
			return await this._commands.executeCommand("_remoteCLI.getSystemStatus")
		}
		dispose() {
			this._server.close(),
				this._ipcHandlePath &&
					process.platform !== "win32" &&
					yT.existsSync(this._ipcHandlePath) &&
					yT.unlinkSync(this._ipcHandlePath)
		}
	},
	Nm = class extends s0 {
		constructor(e, t) {
			super(e, t, LU())
		}
	}
Nm = R([S(0, Tn), S(1, te)], Nm)
var Um = class {
	constructor(e, t) {
		;(this._mainThreadConsole = e.getProxy(M.MainThreadConsole)),
			(this._includeStack = t.consoleForward.includeStack),
			(this._logNative = t.consoleForward.logNative),
			this._wrapConsoleMethod("info", "log"),
			this._wrapConsoleMethod("log", "log"),
			this._wrapConsoleMethod("warn", "warn"),
			this._wrapConsoleMethod("debug", "debug"),
			this._wrapConsoleMethod("error", "error")
	}
	_wrapConsoleMethod(e, t) {
		let n = this,
			r = console[e]
		Object.defineProperty(console, e, {
			set: () => {},
			get: () =>
				function () {
					n._handleConsoleCall(e, t, r, arguments)
				},
		})
	}
	_handleConsoleCall(e, t, n, r) {
		this._mainThreadConsole.$logExtensionHostMessage({
			type: "__$console",
			severity: t,
			arguments: M$(r, this._includeStack),
		}),
			this._logNative && this._nativeConsoleLogMessage(e, n, r)
	}
}
Um = R([S(0, ie), S(1, Xe)], Um)
var L$ = 1e5
function M$(o, e) {
	let t = []
	if (o.length)
		for (let n = 0; n < o.length; n++) {
			let r = o[n]
			if (typeof r > "u") r = "undefined"
			else if (r instanceof Error) {
				let i = r
				i.stack ? (r = i.stack) : (r = i.toString())
			}
			t.push(r)
		}
	if (e) {
		let n = new Error().stack
		n &&
			t.push({
				__$stack: n
					.split(
						`
`,
					)
					.slice(3).join(`
`),
			})
	}
	try {
		let n = sw(t)
		return n.length > L$ ? "Output omitted for a large object that exceeds the limits" : n
	} catch (n) {
		return `Output omitted for an object that cannot be inspected ('${n.toString()}')`
	}
}
var F$ = 1024 * 1024,
	Hm = class extends Um {
		constructor(t, n) {
			super(t, n)
			this._isMakingConsoleCall = !1
			this._wrapStream("stderr", "error"), this._wrapStream("stdout", "log")
		}
		_nativeConsoleLogMessage(t, n, r) {
			let i = t === "error" || t === "warn" ? process.stderr : process.stdout
			;(this._isMakingConsoleCall = !0),
				i.write(`
START_NATIVE_LOG
`),
				n.apply(console, r),
				i.write(`
END_NATIVE_LOG
`),
				(this._isMakingConsoleCall = !1)
		}
		_wrapStream(t, n) {
			let r = process[t],
				i = r.write,
				s = ""
			Object.defineProperty(r, "write", {
				set: () => {},
				get: () => (a, l, d) => {
					if (!this._isMakingConsoleCall) {
						s += a.toString(l)
						let c =
							s.length > F$
								? s.length
								: s.lastIndexOf(`
`)
						c !== -1 && (console[n](s.slice(0, c)), (s = s.slice(c + 1)))
					}
					i.call(r, a, l, d)
				},
			})
		}
	}
Hm = R([S(0, ie), S(1, Xe)], Hm)
import { promises as oc } from "fs"
async function MU(o, e, t, n, r, i) {
	let s
	try {
		await N$(o, e, t, n, r, i)
	} catch (a) {
		s = a
	} finally {
		s && r.errorTransformer && (s = r.errorTransformer(s)), typeof s < "u" && t.error(s), t.end()
	}
}
async function N$(o, e, t, n, r, i) {
	a0(i)
	let s = await o.open(e, { create: !1 })
	try {
		a0(i)
		let a = 0,
			l = 0,
			d = r && typeof r.length == "number" ? r.length : void 0,
			c = z.alloc(Math.min(r.bufferSize, typeof d == "number" ? d : r.bufferSize)),
			u = r && typeof r.position == "number" ? r.position : 0,
			m = 0
		do
			(l = await o.read(s, u, c.buffer, m, c.byteLength - m)),
				(u += l),
				(m += l),
				(a += l),
				typeof d == "number" && (d -= l),
				m === c.byteLength &&
					(await t.write(n(c)),
					(c = z.alloc(Math.min(r.bufferSize, typeof d == "number" ? d : r.bufferSize))),
					(m = 0))
		while (l > 0 && (typeof d != "number" || d > 0) && a0(i) && U$(a, r))
		if (m > 0) {
			let f = m
			typeof d == "number" && (f = Math.min(m, d)), t.write(n(c.slice(0, f)))
		}
	} catch (a) {
		throw gL(a)
	} finally {
		await o.close(s)
	}
}
function a0(o) {
	if (o.isCancellationRequested) throw Ki()
	return !0
}
function U$(o, e) {
	if (typeof e?.limits?.size == "number" && o > e.limits.size)
		throw Bo(p("fileTooLargeError", "File is too large to open"), "EntryTooLarge")
	return !0
}
var IT = class extends $ {
	constructor(t, n) {
		super()
		this.logService = t
		this.options = n
		this._onDidChangeFile = this._register(new E())
		this.onDidChangeFile = this._onDidChangeFile.event
		this._onDidWatchError = this._register(new E())
		this.onDidWatchError = this._onDidWatchError.event
		this.universalWatchRequests = []
		this.universalWatchRequestDelayer = this._register(
			new ns(this.getRefreshWatchersDelay(this.universalWatchRequests.length)),
		)
		this.nonRecursiveWatchRequests = []
		this.nonRecursiveWatchRequestDelayer = this._register(
			new ns(this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length)),
		)
	}
	watch(t, n) {
		return n.recursive || this.options?.watcher?.forceUniversal
			? this.watchUniversal(t, n)
			: this.watchNonRecursive(t, n)
	}
	getRefreshWatchersDelay(t) {
		return t > 200 ? 500 : 0
	}
	watchUniversal(t, n) {
		let r = this.toWatchRequest(t, n),
			i = tE(this.universalWatchRequests, r)
		return (
			this.refreshUniversalWatchers(),
			q(() => {
				i(), this.refreshUniversalWatchers()
			})
		)
	}
	toWatchRequest(t, n) {
		let r = {
			path: this.toWatchPath(t),
			excludes: n.excludes,
			includes: n.includes,
			recursive: n.recursive,
			filter: n.filter,
			correlationId: n.correlationId,
		}
		if (VN(r)) {
			let i = this.options?.watcher?.recursive?.usePolling
			i === !0
				? (r.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5e3)
				: Array.isArray(i) &&
					i.includes(r.path) &&
					(r.pollingInterval = this.options?.watcher?.recursive?.pollingInterval ?? 5e3)
		}
		return r
	}
	refreshUniversalWatchers() {
		this.universalWatchRequestDelayer
			.trigger(
				() => this.doRefreshUniversalWatchers(),
				this.getRefreshWatchersDelay(this.universalWatchRequests.length),
			)
			.catch((t) => Be(t))
	}
	doRefreshUniversalWatchers() {
		return (
			this.universalWatcher ||
				((this.universalWatcher = this._register(
					this.createUniversalWatcher(
						(t) => this._onDidChangeFile.fire(v1(t)),
						(t) => this.onWatcherLogMessage(t),
						this.logService.getLevel() === 1,
					),
				)),
				this._register(
					this.logService.onDidChangeLogLevel(() => {
						this.universalWatcher?.setVerboseLogging(this.logService.getLevel() === 1)
					}),
				)),
			this.universalWatcher.watch(this.universalWatchRequests)
		)
	}
	watchNonRecursive(t, n) {
		let r = {
				path: this.toWatchPath(t),
				excludes: n.excludes,
				includes: n.includes,
				recursive: !1,
				filter: n.filter,
				correlationId: n.correlationId,
			},
			i = tE(this.nonRecursiveWatchRequests, r)
		return (
			this.refreshNonRecursiveWatchers(),
			q(() => {
				i(), this.refreshNonRecursiveWatchers()
			})
		)
	}
	refreshNonRecursiveWatchers() {
		this.nonRecursiveWatchRequestDelayer
			.trigger(
				() => this.doRefreshNonRecursiveWatchers(),
				this.getRefreshWatchersDelay(this.nonRecursiveWatchRequests.length),
			)
			.catch((t) => Be(t))
	}
	doRefreshNonRecursiveWatchers() {
		return (
			this.nonRecursiveWatcher ||
				((this.nonRecursiveWatcher = this._register(
					this.createNonRecursiveWatcher(
						(t) => this._onDidChangeFile.fire(v1(t)),
						(t) => this.onWatcherLogMessage(t),
						this.logService.getLevel() === 1,
					),
				)),
				this._register(
					this.logService.onDidChangeLogLevel(() => {
						this.nonRecursiveWatcher?.setVerboseLogging(this.logService.getLevel() === 1)
					}),
				)),
			this.nonRecursiveWatcher.watch(this.nonRecursiveWatchRequests)
		)
	}
	onWatcherLogMessage(t) {
		t.type === "error" && this._onDidWatchError.fire(t.message), this.logWatcherMessage(t)
	}
	logWatcherMessage(t) {
		this.logService[t.type](t.message)
	}
	toFilePath(t) {
		return Gn(t.fsPath)
	}
	toWatchPath(t) {
		let n = this.toFilePath(t)
		return iO(n)
	}
}
import { fork as V$ } from "child_process"
function FU(o) {
	let e = o
	return e && typeof e.type == "string" && typeof e.severity == "string"
}
function H$(o) {
	let e = [],
		t
	try {
		let n = JSON.parse(o.arguments),
			r = n[n.length - 1]
		r && r.__$stack && (n.pop(), (t = r.__$stack)), e.push(...n)
	} catch {
		e.push("Unable to log remote console arguments", o.arguments)
	}
	return { args: e, stack: t }
}
function W$(o) {
	if (!o) return o
	let e = o.indexOf(`
`)
	return e === -1 ? o : o.substring(0, e)
}
function NU(o, e) {
	let { args: t, stack: n } = H$(o),
		r = typeof t[0] == "string" && t.length === 1,
		i = W$(n)
	i && (i = `(${i.trim()})`)
	let s = []
	if (
		(typeof t[0] == "string"
			? i && r
				? (s = [`%c[${e}] %c${t[0]} %c${i}`, Wm("blue"), Wm(""), Wm("grey")])
				: (s = [`%c[${e}] %c${t[0]}`, Wm("blue"), Wm(""), ...t.slice(1)])
			: (s = [`%c[${e}]%`, Wm("blue"), ...t]),
		i && !r && s.push(i),
		typeof console[o.severity] != "function")
	)
		throw new Error("Unknown console method")
	console[o.severity].apply(console, s)
}
function Wm(o) {
	return `color: ${o}`
}
var xT = class {
	constructor(e, t) {
		this.modulePath = e
		this.options = t
		this.activeRequests = new Set()
		this.channels = new Map()
		this._onDidProcessExit = new E()
		this.onDidProcessExit = this._onDidProcessExit.event
		let n = t && t.timeout ? t.timeout : 6e4
		;(this.disposeDelayer = new Cf(n)), (this.child = null), (this._client = null)
	}
	getChannel(e) {
		let t = this
		return {
			call(n, r, i) {
				return t.requestPromise(e, n, r, i)
			},
			listen(n, r) {
				return t.requestEvent(e, n, r)
			},
		}
	}
	requestPromise(e, t, n, r = De.None) {
		if (!this.disposeDelayer) return Promise.reject(new Error("disposed"))
		if (r.isCancellationRequested) return Promise.reject(Ki())
		this.disposeDelayer.cancel()
		let i = this.getCachedChannel(e),
			s = Ar((d) => i.call(t, n, d)),
			a = r.onCancellationRequested(() => s.cancel()),
			l = q(() => s.cancel())
		return (
			this.activeRequests.add(l),
			s.finally(() => {
				a.dispose(),
					this.activeRequests.delete(l),
					this.activeRequests.size === 0 &&
						this.disposeDelayer &&
						this.disposeDelayer.trigger(() => this.disposeClient())
			}),
			s
		)
	}
	requestEvent(e, t, n) {
		if (!this.disposeDelayer) return Ee.None
		this.disposeDelayer.cancel()
		let r,
			i = new E({
				onWillAddFirstListener: () => {
					;(r = this.getCachedChannel(e).listen(t, n)(i.fire, i)), this.activeRequests.add(r)
				},
				onDidRemoveLastListener: () => {
					this.activeRequests.delete(r),
						r.dispose(),
						this.activeRequests.size === 0 &&
							this.disposeDelayer &&
							this.disposeDelayer.trigger(() => this.disposeClient())
				},
			})
		return i.event
	}
	get client() {
		if (!this._client) {
			let e = this.options && this.options.args ? this.options.args : [],
				t = Object.create(null)
			;(t.env = { ...je(process.env), VSCODE_PARENT_PID: String(process.pid) }),
				this.options && this.options.env && (t.env = { ...t.env, ...this.options.env }),
				this.options && this.options.freshExecArgv && (t.execArgv = []),
				this.options &&
					typeof this.options.debug == "number" &&
					(t.execArgv = ["--nolazy", "--inspect=" + this.options.debug]),
				this.options &&
					typeof this.options.debugBrk == "number" &&
					(t.execArgv = ["--nolazy", "--inspect-brk=" + this.options.debugBrk]),
				t.execArgv === void 0 &&
					(t.execArgv = process.execArgv
						.filter((u) => !/^--inspect(-brk)?=/.test(u))
						.filter((u) => !u.startsWith("--vscode-"))),
				tN(t.env),
				(this.child = V$(this.modulePath, e, t))
			let n = new E(),
				i = Ee.fromNodeEventEmitter(
					this.child,
					"message",
					(u) => u,
				)((u) => {
					if (FU(u)) {
						NU(u, `IPC Library: ${this.options.serverName}`)
						return
					}
					n.fire(z.wrap(Buffer.from(u, "base64")))
				}),
				s = this.options.useQueue ? rN(this.child) : this.child,
				a = (u) => this.child && this.child.connected && s.send(u.buffer.toString("base64")),
				l = n.event,
				d = { send: a, onMessage: l }
			this._client = new wf(d)
			let c = () => this.disposeClient()
			process.once("exit", c),
				this.child.on("error", (u) => console.warn('IPC "' + this.options.serverName + '" errored with ' + u)),
				this.child.on("exit", (u, m) => {
					process.removeListener("exit", c),
						i.dispose(),
						this.activeRequests.forEach((f) => Nn(f)),
						this.activeRequests.clear(),
						u !== 0 &&
							m !== "SIGTERM" &&
							console.warn(
								'IPC "' +
									this.options.serverName +
									'" crashed with exit code ' +
									u +
									" and signal " +
									m,
							),
						this.disposeDelayer?.cancel(),
						this.disposeClient(),
						this._onDidProcessExit.fire({ code: u, signal: m })
				})
		}
		return this._client
	}
	getCachedChannel(e) {
		let t = this.channels.get(e)
		return t || ((t = this.client.getChannel(e)), this.channels.set(e, t)), t
	}
	disposeClient() {
		this._client &&
			(this.child && (this.child.kill(), (this.child = null)), (this._client = null), this.channels.clear())
	}
	dispose() {
		this._onDidProcessExit.dispose(),
			this.disposeDelayer?.cancel(),
			(this.disposeDelayer = void 0),
			this.disposeClient(),
			this.activeRequests.clear()
	}
}
var CT = class extends aS {
	constructor(e, t, n) {
		super(e, t, n), this.init()
	}
	createWatcher(e) {
		let t = e.add(
			new xT(Ec.asFileUri("bootstrap-fork").fsPath, {
				serverName: "File Watcher",
				args: ["--type=fileWatcher"],
				env: {
					VSCODE_ESM_ENTRYPOINT: "vs/platform/files/node/watcher/watcherMain",
					VSCODE_PIPE_LOGGING: "true",
					VSCODE_VERBOSE_LOGGING: "true",
				},
			}),
		)
		return (
			e.add(
				t.onDidProcessExit(({ code: n, signal: r }) =>
					this.onError(`terminated by itself with code ${n}, signal: ${r} (ETERM)`),
				),
			),
			YE.toService(PO(t.getChannel("watcher")))
		)
	}
}
import { watchFile as B$, unwatchFile as $$ } from "fs"
var ST = class extends $ {
	constructor() {
		super()
		this._onDidChangeFile = this._register(new E())
		this.onDidChangeFile = this._onDidChangeFile.event
		this._onDidLogMessage = this._register(new E())
		this.onDidLogMessage = this._onDidLogMessage.event
		this._onDidWatchFail = this._register(new E())
		this.onDidWatchFail = this._onDidWatchFail.event
		this.correlatedWatchRequests = new Map()
		this.nonCorrelatedWatchRequests = new Map()
		this.suspendedWatchRequests = this._register(new Br())
		this.suspendedWatchRequestsWithPolling = new Set()
		this.updateWatchersDelayer = this._register(new ns(this.getUpdateWatchersDelay()))
		this.suspendedWatchRequestPollingInterval = 5007
		this.joinWatch = new Cn()
		this.verboseLogging = !1
		this._register(
			this.onDidWatchFail((t) =>
				this.suspendWatchRequest({
					id: this.computeId(t),
					correlationId: this.isCorrelated(t) ? t.correlationId : void 0,
					path: t.path,
				}),
			),
		)
	}
	isCorrelated(t) {
		return lS(t)
	}
	computeId(t) {
		return this.isCorrelated(t) ? t.correlationId : lr(t)
	}
	async watch(t) {
		this.joinWatch.isSettled || this.joinWatch.complete(), (this.joinWatch = new Cn())
		try {
			this.correlatedWatchRequests.clear(), this.nonCorrelatedWatchRequests.clear()
			for (let n of t)
				this.isCorrelated(n)
					? this.correlatedWatchRequests.set(n.correlationId, n)
					: this.nonCorrelatedWatchRequests.set(this.computeId(n), n)
			for (let [n] of this.suspendedWatchRequests)
				!this.nonCorrelatedWatchRequests.has(n) &&
					!this.correlatedWatchRequests.has(n) &&
					(this.suspendedWatchRequests.deleteAndDispose(n), this.suspendedWatchRequestsWithPolling.delete(n))
			return await this.updateWatchers(!1)
		} finally {
			this.joinWatch.complete()
		}
	}
	updateWatchers(t) {
		let n = []
		for (let [r, i] of [...this.nonCorrelatedWatchRequests, ...this.correlatedWatchRequests])
			this.suspendedWatchRequests.has(r) || n.push(i)
		return this.updateWatchersDelayer
			.trigger(() => this.doWatch(n), t ? this.getUpdateWatchersDelay() : 0)
			.catch((r) => Be(r))
	}
	getUpdateWatchersDelay() {
		return 800
	}
	isSuspended(t) {
		let n = this.computeId(t)
		return this.suspendedWatchRequestsWithPolling.has(n) ? "polling" : this.suspendedWatchRequests.has(n)
	}
	async suspendWatchRequest(t) {
		if (this.suspendedWatchRequests.has(t.id)) return
		let n = new Q()
		this.suspendedWatchRequests.set(t.id, n),
			await this.joinWatch.p,
			!n.isDisposed && (this.monitorSuspendedWatchRequest(t, n), this.updateWatchers(!0))
	}
	resumeWatchRequest(t) {
		this.suspendedWatchRequests.deleteAndDispose(t.id),
			this.suspendedWatchRequestsWithPolling.delete(t.id),
			this.updateWatchers(!1)
	}
	monitorSuspendedWatchRequest(t, n) {
		this.doMonitorWithExistingWatcher(t, n)
			? (this.trace(`reusing an existing recursive watcher to monitor ${t.path}`),
				this.suspendedWatchRequestsWithPolling.delete(t.id))
			: (this.doMonitorWithNodeJS(t, n), this.suspendedWatchRequestsWithPolling.add(t.id))
	}
	doMonitorWithExistingWatcher(t, n) {
		let r = this.recursiveWatcher?.subscribe(t.path, (i, s) => {
			n.isDisposed ||
				(i ? this.monitorSuspendedWatchRequest(t, n) : s?.type === 1 && this.onMonitoredPathAdded(t))
		})
		return r ? (n.add(r), !0) : !1
	}
	doMonitorWithNodeJS(t, n) {
		let r = !1,
			i = (s, a) => {
				if (n.isDisposed) return
				let l = this.isPathNotFound(s),
					d = this.isPathNotFound(a),
					c = r
				;(r = l), !l && (d || c) && this.onMonitoredPathAdded(t)
			}
		this.trace(`starting fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`)
		try {
			B$(t.path, { persistent: !1, interval: this.suspendedWatchRequestPollingInterval }, i)
		} catch (s) {
			this.warn(`fs.watchFile() failed with error ${s} on path ${t.path} (correlationId: ${t.correlationId})`)
		}
		n.add(
			q(() => {
				this.trace(`stopping fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`)
				try {
					$$(t.path, i)
				} catch (s) {
					this.warn(
						`fs.unwatchFile() failed with error ${s} on path ${t.path} (correlationId: ${t.correlationId})`,
					)
				}
			}),
		)
	}
	onMonitoredPathAdded(t) {
		this.trace(`detected ${t.path} exists again, resuming watcher (correlationId: ${t.correlationId})`)
		let n = { resource: b.file(t.path), type: 1, cId: t.correlationId }
		this._onDidChangeFile.fire([n]), this.traceEvent(n, t), this.resumeWatchRequest(t)
	}
	isPathNotFound(t) {
		return t.ctimeMs === 0 && t.ino === 0
	}
	async stop() {
		this.suspendedWatchRequests.clearAndDisposeAll(), this.suspendedWatchRequestsWithPolling.clear()
	}
	traceEvent(t, n) {
		if (this.verboseLogging) {
			let r = ` >> normalized ${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`
			this.traceWithCorrelation(r, n)
		}
	}
	traceWithCorrelation(t, n) {
		this.verboseLogging && this.trace(`${t}${typeof n.correlationId == "number" ? ` <${n.correlationId}> ` : ""}`)
	}
	requestToString(t) {
		return `${t.path} (excludes: ${t.excludes.length > 0 ? t.excludes : "<none>"}, includes: ${t.includes && t.includes.length > 0 ? JSON.stringify(t.includes) : "<all>"}, filter: ${zN(t.filter)}, correlationId: ${typeof t.correlationId == "number" ? t.correlationId : "<none>"})`
	}
	async setVerboseLogging(t) {
		this.verboseLogging = t
	}
}
import { watch as z$, promises as q$ } from "fs"
var TT = class o extends $ {
	constructor(t, n, r, i, s, a) {
		super()
		this.request = t
		this.recursiveWatcher = n
		this.onDidFilesChange = r
		this.onDidWatchFail = i
		this.onLogMessage = s
		this.verboseLogging = a
		this.throttledFileChangesEmitter = this._register(
			new Dc({ maxWorkChunkSize: 100, throttleDelay: 200, maxBufferedWork: 1e4 }, (t) =>
				this.onDidFilesChange(t),
			),
		)
		this.fileChangesAggregator = this._register(
			new Xv((t) => this.handleFileChanges(t), o.FILE_CHANGES_HANDLER_DELAY),
		)
		this.cts = new _e()
		this.realPath = new kt(async () => {
			let t = this.request.path
			try {
				;(t = await rb(this.request.path)),
					this.request.path !== t &&
						this.trace(
							`correcting a path to watch that seems to be a symbolic link (original: ${this.request.path}, real: ${t})`,
						)
			} catch {}
			return t
		})
		this._isReusingRecursiveWatcher = !1
		this.didFail = !1
		;(this.excludes = y1(this.request.path, this.request.excludes)),
			(this.includes = this.request.includes ? y1(this.request.path, this.request.includes) : void 0),
			(this.filter = lS(this.request) ? this.request.filter : void 0),
			(this.ready = this.watch())
	}
	static {
		this.FILE_DELETE_HANDLER_DELAY = 100
	}
	static {
		this.FILE_CHANGES_HANDLER_DELAY = 75
	}
	get isReusingRecursiveWatcher() {
		return this._isReusingRecursiveWatcher
	}
	get failed() {
		return this.didFail
	}
	async watch() {
		try {
			let t = await q$.stat(this.request.path)
			if (this.cts.token.isCancellationRequested) return
			this._register(await this.doWatch(t.isDirectory()))
		} catch (t) {
			t.code !== "ENOENT"
				? this.error(t)
				: this.trace(
						`ignoring a path for watching who's stat info failed to resolve: ${this.request.path} (error: ${t})`,
					),
				this.notifyWatchFailed()
		}
	}
	notifyWatchFailed() {
		;(this.didFail = !0), this.onDidWatchFail?.()
	}
	async doWatch(t) {
		let n = new Q()
		return (
			this.doWatchWithExistingWatcher(t, n)
				? (this.trace(`reusing an existing recursive watcher for ${this.request.path}`),
					(this._isReusingRecursiveWatcher = !0))
				: ((this._isReusingRecursiveWatcher = !1), await this.doWatchWithNodeJS(t, n)),
			n
		)
	}
	doWatchWithExistingWatcher(t, n) {
		if (t) return !1
		let r = b.file(this.request.path),
			i = this.recursiveWatcher?.subscribe(this.request.path, async (s, a) => {
				if (!n.isDisposed)
					if (s) {
						let l = await this.doWatch(t)
						n.isDisposed ? l.dispose() : n.add(l)
					} else
						a &&
							(typeof a.cId == "number" || typeof this.request.correlationId == "number") &&
							this.onFileChange({ resource: r, type: a.type, cId: this.request.correlationId }, !0)
			})
		return i ? (n.add(i), !0) : !1
	}
	async doWatchWithNodeJS(t, n) {
		let r = await this.realPath.value
		if (this.cts.token.isCancellationRequested) return
		if (st && Kr(r, "/Volumes/", !0)) {
			this.error(
				`Refusing to watch ${r} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`,
			)
			return
		}
		let i = new _e(this.cts.token)
		n.add(q(() => i.dispose(!0)))
		let s = new Q()
		n.add(s)
		try {
			let a = b.file(this.request.path),
				l = Ze(r),
				d = z$(r)
			s.add(
				q(() => {
					d.removeAllListeners(), d.close()
				}),
			),
				this.trace(`Started watching: '${r}'`)
			let c = new Set()
			if (t)
				try {
					for (let m of await Qe.readdir(r)) c.add(m)
				} catch (m) {
					this.error(m)
				}
			if (i.token.isCancellationRequested) return
			let u = new Map()
			s.add(
				q(() => {
					for (let [, m] of u) m.dispose()
					u.clear()
				}),
			),
				d.on("error", (m, f) => {
					i.token.isCancellationRequested ||
						(this.error(`Failed to watch ${r} for changes using fs.watch() (${m}, ${f})`),
						this.notifyWatchFailed())
				}),
				d.on("change", (m, f) => {
					if (i.token.isCancellationRequested) return
					this.verboseLogging && this.traceWithCorrelation(`[raw] ["${m}"] ${f}`)
					let h = ""
					if ((f && ((h = f.toString()), st && (h = Bl(h))), !(!h || (m !== "change" && m !== "rename"))))
						if (t)
							if (m === "rename") {
								u.get(h)?.dispose()
								let g = setTimeout(async () => {
									if ((u.delete(h), Tc(h, l, !Ve) && !(await Qe.exists(r)))) {
										this.onWatchedPathDeleted(a)
										return
									}
									if (i.token.isCancellationRequested) return
									let I = await this.existsChildStrictCase(Fe(r, h))
									if (i.token.isCancellationRequested) return
									let C
									I ? (c.has(h) ? (C = 0) : ((C = 1), c.add(h))) : (c.delete(h), (C = 2)),
										this.onFileChange({
											resource: ct(a, h),
											type: C,
											cId: this.request.correlationId,
										})
								}, o.FILE_DELETE_HANDLER_DELAY)
								u.set(
									h,
									q(() => clearTimeout(g)),
								)
							} else {
								let g
								c.has(h) ? (g = 0) : ((g = 1), c.add(h)),
									this.onFileChange({ resource: ct(a, h), type: g, cId: this.request.correlationId })
							}
						else if (m === "rename" || !Tc(h, l, !Ve)) {
							let g = setTimeout(async () => {
								let I = await Qe.exists(r)
								i.token.isCancellationRequested ||
									(I
										? (this.onFileChange(
												{ resource: a, type: 0, cId: this.request.correlationId },
												!0,
											),
											s.add(await this.doWatch(!1)))
										: this.onWatchedPathDeleted(a))
							}, o.FILE_DELETE_HANDLER_DELAY)
							s.clear(), s.add(q(() => clearTimeout(g)))
						} else this.onFileChange({ resource: a, type: 0, cId: this.request.correlationId }, !0)
				})
		} catch (a) {
			if (i.token.isCancellationRequested) return
			this.error(`Failed to watch ${r} for changes using fs.watch() (${a.toString()})`), this.notifyWatchFailed()
		}
	}
	onWatchedPathDeleted(t) {
		this.warn("Watcher shutdown because watched path got deleted"),
			this.onFileChange({ resource: t, type: 2, cId: this.request.correlationId }, !0),
			this.fileChangesAggregator.flush(),
			this.notifyWatchFailed()
	}
	onFileChange(t, n = !1) {
		this.cts.token.isCancellationRequested ||
			(this.verboseLogging &&
				this.traceWithCorrelation(
					`${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`,
				),
			!n && this.excludes.some((r) => r(t.resource.fsPath))
				? this.verboseLogging && this.traceWithCorrelation(` >> ignored (excluded) ${t.resource.fsPath}`)
				: !n && this.includes && this.includes.length > 0 && !this.includes.some((r) => r(t.resource.fsPath))
					? this.verboseLogging &&
						this.traceWithCorrelation(` >> ignored (not included) ${t.resource.fsPath}`)
					: this.fileChangesAggregator.work(t))
	}
	handleFileChanges(t) {
		let n = BN(t),
			r = []
		for (let s of n) {
			if ($N(s, this.filter)) {
				this.verboseLogging && this.traceWithCorrelation(` >> ignored (filtered) ${s.resource.fsPath}`)
				continue
			}
			r.push(s)
		}
		if (r.length === 0) return
		if (this.verboseLogging)
			for (let s of r)
				this.traceWithCorrelation(
					` >> normalized ${s.type === 1 ? "[ADDED]" : s.type === 2 ? "[DELETED]" : "[CHANGED]"} ${s.resource.fsPath}`,
				)
		this.throttledFileChangesEmitter.work(r)
			? this.throttledFileChangesEmitter.pending > 0 &&
				this.trace(
					`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesEmitter.pending}, most recent change: ${r[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
				)
			: this.warn(
					`started ignoring events due to too many file change events at once (incoming: ${r.length}, most recent change: ${r[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
				)
	}
	async existsChildStrictCase(t) {
		if (Ve) return Qe.exists(t)
		try {
			let n = Ze(t)
			return (await Qe.readdir(Qt(t))).some((i) => i === n)
		} catch (n) {
			return this.trace(n), !1
		}
	}
	setVerboseLogging(t) {
		this.verboseLogging = t
	}
	error(t) {
		this.cts.token.isCancellationRequested ||
			this.onLogMessage?.({ type: "error", message: `[File Watcher (node.js)] ${t}` })
	}
	warn(t) {
		this.cts.token.isCancellationRequested ||
			this.onLogMessage?.({ type: "warn", message: `[File Watcher (node.js)] ${t}` })
	}
	trace(t) {
		!this.cts.token.isCancellationRequested &&
			this.verboseLogging &&
			this.onLogMessage?.({ type: "trace", message: `[File Watcher (node.js)] ${t}` })
	}
	traceWithCorrelation(t) {
		!this.cts.token.isCancellationRequested &&
			this.verboseLogging &&
			this.trace(
				`${t}${typeof this.request.correlationId == "number" ? ` <${this.request.correlationId}> ` : ""}`,
			)
	}
	dispose() {
		this.cts.dispose(!0), super.dispose()
	}
}
var ET = class extends ST {
	constructor(t) {
		super()
		this.recursiveWatcher = t
		this.onDidError = Ee.None
		this._watchers = new Map()
		this.worker = this._register(new kn())
	}
	get watchers() {
		return this._watchers.values()
	}
	async doWatch(t) {
		t = this.removeDuplicateRequests(t)
		let n = [],
			r = new Set(Array.from(this.watchers))
		for (let i of t) {
			let s = this._watchers.get(this.requestToWatcherKey(i))
			s && a_(s.request.excludes, i.excludes) && a_(s.request.includes, i.includes) ? r.delete(s) : n.push(i)
		}
		n.length && this.trace(`Request to start watching: ${n.map((i) => this.requestToString(i)).join(",")}`),
			r.size &&
				this.trace(
					`Request to stop watching: ${Array.from(r)
						.map((i) => this.requestToString(i.request))
						.join(",")}`,
				),
			this.worker.clear()
		for (let i of r) this.stopWatching(i)
		this.createWatchWorker().work(n)
	}
	createWatchWorker() {
		return (
			(this.worker.value = new Dc(
				{ maxWorkChunkSize: 100, throttleDelay: 100, maxBufferedWork: Number.MAX_VALUE },
				(t) => {
					for (let n of t) this.startWatching(n)
				},
			)),
			this.worker.value
		)
	}
	requestToWatcherKey(t) {
		return typeof t.correlationId == "number" ? t.correlationId : this.pathToWatcherKey(t.path)
	}
	pathToWatcherKey(t) {
		return Ve ? t : t.toLowerCase()
	}
	startWatching(t) {
		let n = new TT(
				t,
				this.recursiveWatcher,
				(i) => this._onDidChangeFile.fire(i),
				() => this._onDidWatchFail.fire(t),
				(i) => this._onDidLogMessage.fire(i),
				this.verboseLogging,
			),
			r = { request: t, instance: n }
		this._watchers.set(this.requestToWatcherKey(t), r)
	}
	async stop() {
		await super.stop()
		for (let t of this.watchers) this.stopWatching(t)
	}
	stopWatching(t) {
		this.trace("stopping file watcher", t),
			this._watchers.delete(this.requestToWatcherKey(t.request)),
			t.instance.dispose()
	}
	removeDuplicateRequests(t) {
		let n = new Map()
		for (let r of t) {
			let i = n.get(r.correlationId)
			i || ((i = new Map()), n.set(r.correlationId, i))
			let s = this.pathToWatcherKey(r.path)
			i.has(s) &&
				this.trace(`ignoring a request for watching who's path is already watched: ${this.requestToString(r)}`),
				i.set(s, r)
		}
		return Array.from(n.values())
			.map((r) => Array.from(r.values()))
			.flat()
	}
	async setVerboseLogging(t) {
		super.setVerboseLogging(t)
		for (let n of this.watchers) n.instance.setVerboseLogging(t)
	}
	trace(t, n) {
		this.verboseLogging && this._onDidLogMessage.fire({ type: "trace", message: this.toMessage(t, n) })
	}
	warn(t) {
		this._onDidLogMessage.fire({ type: "warn", message: this.toMessage(t) })
	}
	toMessage(t, n) {
		return n
			? `[File Watcher (node.js)] ${t} (${this.requestToString(n.request)})`
			: `[File Watcher (node.js)] ${t}`
	}
}
var wT = class extends sS {
	constructor(e, t, n) {
		super(e, t, n), this.init()
	}
	createWatcher(e) {
		return e.add(new ET(void 0))
	}
}
var PT = class o extends IT {
	constructor(t, n) {
		super(t, n)
		this.onDidChangeCapabilities = Ee.None
		this.resourceLocks = new ft((t) => Hl.getComparisonKey(t))
		this.mapHandleToPos = new Map()
		this.mapHandleToLock = new Map()
		this.writeHandles = new Map()
	}
	static {
		this.TRACE_LOG_RESOURCE_LOCKS = !1
	}
	get capabilities() {
		return (
			this._capabilities || ((this._capabilities = 253982), Ve && (this._capabilities |= 1024)),
			this._capabilities
		)
	}
	async stat(t) {
		try {
			let { stat: n, symbolicLink: r } = await ir.stat(this.toFilePath(t))
			return {
				type: this.toType(n, r),
				ctime: n.birthtime.getTime(),
				mtime: n.mtime.getTime(),
				size: n.size,
				permissions: (n.mode & 128) === 0 ? 2 : void 0,
			}
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	async statIgnoreError(t) {
		try {
			return await this.stat(t)
		} catch {
			return
		}
	}
	async readdir(t) {
		try {
			let n = await Qe.readdir(this.toFilePath(t), { withFileTypes: !0 }),
				r = []
			return (
				await Promise.all(
					n.map(async (i) => {
						try {
							let s
							i.isSymbolicLink() ? (s = (await this.stat(ct(t, i.name))).type) : (s = this.toType(i)),
								r.push([i.name, s])
						} catch (s) {
							this.logService.trace(s)
						}
					}),
				),
				r
			)
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	toType(t, n) {
		let r
		return n?.dangling ? (r = 0) : t.isFile() ? (r = 1) : t.isDirectory() ? (r = 2) : (r = 0), n && (r |= 64), r
	}
	async createResourceLock(t) {
		let n = this.toFilePath(t)
		this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${n})`)
		let r
		for (; (r = this.resourceLocks.get(t)); )
			this.traceLock(
				`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${n})`,
			),
				await r.wait()
		let i = new dn()
		return (
			this.resourceLocks.set(t, i),
			this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${n})`),
			q(() => {
				this.traceLock(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${n})`),
					this.resourceLocks.get(t) === i &&
						(this.traceLock(
							`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${n})`,
						),
						this.resourceLocks.delete(t)),
					this.traceLock(
						`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${n})`,
					),
					i.open()
			})
		)
	}
	async readFile(t, n) {
		let r
		try {
			n?.atomic &&
				(this.traceLock(`[Disk FileSystemProvider]: atomic read operation started (${this.toFilePath(t)})`),
				(r = await this.createResourceLock(t)))
			let i = this.toFilePath(t)
			return await oc.readFile(i)
		} catch (i) {
			throw this.toFileSystemProviderError(i)
		} finally {
			r?.dispose()
		}
	}
	traceLock(t) {
		o.TRACE_LOG_RESOURCE_LOCKS && this.logService.trace(t)
	}
	readFileStream(t, n, r) {
		let i = Al((s) => z.concat(s.map((a) => z.wrap(a))).buffer)
		return MU(this, t, i, (s) => s.buffer, { ...n, bufferSize: 256 * 1024 }, r), i
	}
	async writeFile(t, n, r) {
		return r?.atomic !== !1 && r?.atomic?.postfix && (await this.canWriteFileAtomic(t))
			? this.doWriteFileAtomic(t, ct(ts(t), `${Ht(t)}${r.atomic.postfix}`), n, r)
			: this.doWriteFile(t, n, r)
	}
	async canWriteFileAtomic(t) {
		try {
			let n = this.toFilePath(t),
				{ symbolicLink: r } = await ir.stat(n)
			if (r) return !1
		} catch {}
		return !0
	}
	async doWriteFileAtomic(t, n, r, i) {
		let s = new Q()
		try {
			s.add(await this.createResourceLock(t)),
				s.add(await this.createResourceLock(n)),
				await this.doWriteFile(n, r, i, !0)
			try {
				await this.rename(n, t, { overwrite: !0 })
			} catch (a) {
				try {
					await this.delete(n, { recursive: !1, useTrash: !1, atomic: !1 })
				} catch {}
				throw a
			}
		} finally {
			s.dispose()
		}
	}
	async doWriteFile(t, n, r, i) {
		let s
		try {
			let a = this.toFilePath(t)
			if (!r.create || !r.overwrite) {
				if (await Qe.exists(a)) {
					if (!r.overwrite) throw Bo(p("fileExists", "File already exists"), "EntryExists")
				} else if (!r.create) throw Bo(p("fileNotExists", "File does not exist"), "EntryNotFound")
			}
			;(s = await this.open(t, { create: !0, unlock: r.unlock }, i)), await this.write(s, 0, n, 0, n.byteLength)
		} catch (a) {
			throw await this.toFileSystemProviderWriteError(t, a)
		} finally {
			typeof s == "number" && (await this.close(s))
		}
	}
	static {
		this.canFlush = !0
	}
	static configureFlushOnWrite(t) {
		o.canFlush = t
	}
	async open(t, n, r) {
		let i = this.toFilePath(t),
			s
		Xl(n) && !r && (s = await this.createResourceLock(t))
		let a
		try {
			if (Xl(n) && n.unlock)
				try {
					let { stat: l } = await ir.stat(i)
					l.mode & 128 || (await oc.chmod(i, l.mode | 128))
				} catch (l) {
					l.code !== "ENOENT" && this.logService.trace(l)
				}
			if (Ie && Xl(n))
				try {
					;(a = await Qe.open(i, "r+")), await Qe.ftruncate(a, 0)
				} catch (l) {
					if ((l.code !== "ENOENT" && this.logService.trace(l), typeof a == "number")) {
						try {
							await Qe.close(a)
						} catch (d) {
							this.logService.trace(d)
						}
						a = void 0
					}
				}
			typeof a != "number" && (a = await Qe.open(i, Xl(n) ? "w" : "r"))
		} catch (l) {
			throw (
				(s?.dispose(),
				Xl(n) ? await this.toFileSystemProviderWriteError(t, l) : this.toFileSystemProviderError(l))
			)
		}
		if ((this.mapHandleToPos.set(a, 0), Xl(n) && this.writeHandles.set(a, t), s)) {
			let l = this.mapHandleToLock.get(a)
			this.traceLock(`[Disk FileSystemProvider]: open() - storing lock for handle ${a} (${i})`),
				this.mapHandleToLock.set(a, s),
				l &&
					(this.traceLock(
						`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${a} (${i})`,
					),
					l.dispose())
		}
		return a
	}
	async close(t) {
		let n = this.mapHandleToLock.get(t)
		try {
			if ((this.mapHandleToPos.delete(t), this.writeHandles.delete(t) && o.canFlush))
				try {
					await Qe.fdatasync(t)
				} catch (r) {
					o.configureFlushOnWrite(!1), this.logService.error(r)
				}
			return await Qe.close(t)
		} catch (r) {
			throw this.toFileSystemProviderError(r)
		} finally {
			n &&
				(this.mapHandleToLock.get(t) === n &&
					(this.traceLock(
						`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${t}`,
					),
					this.mapHandleToLock.delete(t)),
				this.traceLock(`[Disk FileSystemProvider]: close() - disposing lock for handle ${t}`),
				n.dispose())
		}
	}
	async read(t, n, r, i, s) {
		let a = this.normalizePos(t, n),
			l = null
		try {
			l = (await Qe.read(t, r, i, s, a)).bytesRead
		} catch (d) {
			throw this.toFileSystemProviderError(d)
		} finally {
			this.updatePos(t, a, l)
		}
		return l
	}
	normalizePos(t, n) {
		return n === this.mapHandleToPos.get(t) ? null : n
	}
	updatePos(t, n, r) {
		let i = this.mapHandleToPos.get(t)
		typeof i == "number" &&
			(typeof n == "number" ||
				(typeof r == "number" ? this.mapHandleToPos.set(t, i + r) : this.mapHandleToPos.delete(t)))
	}
	async write(t, n, r, i, s) {
		return xO(() => this.doWrite(t, n, r, i, s), 100, 3)
	}
	async doWrite(t, n, r, i, s) {
		let a = this.normalizePos(t, n),
			l = null
		try {
			l = (await Qe.write(t, r, i, s, a)).bytesWritten
		} catch (d) {
			throw await this.toFileSystemProviderWriteError(this.writeHandles.get(t), d)
		} finally {
			this.updatePos(t, a, l)
		}
		return l
	}
	async mkdir(t) {
		try {
			await oc.mkdir(this.toFilePath(t))
		} catch (n) {
			throw this.toFileSystemProviderError(n)
		}
	}
	async delete(t, n) {
		try {
			let r = this.toFilePath(t)
			if (n.recursive) {
				let i
				n?.atomic !== !1 && n.atomic.postfix && (i = Fe(Qt(r), `${Ze(r)}${n.atomic.postfix}`)),
					await Qe.rm(r, 1, i)
			} else
				try {
					await oc.unlink(r)
				} catch (i) {
					if (i.code === "EPERM" || i.code === "EISDIR") {
						let s = !1
						try {
							let { stat: a, symbolicLink: l } = await ir.stat(r)
							s = a.isDirectory() && !l
						} catch {}
						if (s) await oc.rmdir(r)
						else throw i
					} else throw i
				}
		} catch (r) {
			throw this.toFileSystemProviderError(r)
		}
	}
	async rename(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n)
		if (i !== s)
			try {
				await this.validateMoveCopy(t, n, "move", r.overwrite), await Qe.rename(i, s)
			} catch (a) {
				throw (
					((a.code === "EINVAL" || a.code === "EBUSY" || a.code === "ENAMETOOLONG") &&
						(a = new Error(
							p("moveError", "Unable to move '{0}' into '{1}' ({2}).", Ze(i), Ze(Qt(s)), a.toString()),
						)),
					this.toFileSystemProviderError(a))
				)
			}
	}
	async copy(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n)
		if (i !== s)
			try {
				await this.validateMoveCopy(t, n, "copy", r.overwrite), await Qe.copy(i, s, { preserveSymlinks: !0 })
			} catch (a) {
				throw (
					((a.code === "EINVAL" || a.code === "EBUSY" || a.code === "ENAMETOOLONG") &&
						(a = new Error(
							p("copyError", "Unable to copy '{0}' into '{1}' ({2}).", Ze(i), Ze(Qt(s)), a.toString()),
						)),
					this.toFileSystemProviderError(a))
				)
			}
	}
	async validateMoveCopy(t, n, r, i) {
		let s = this.toFilePath(t),
			a = this.toFilePath(n),
			l = !1
		if ((!!(this.capabilities & 1024) || (l = Tc(s, a, !0)), l)) {
			if (r === "copy")
				throw Bo(
					p("fileCopyErrorPathCase", "File cannot be copied to same path with different path case"),
					"EntryExists",
				)
			if (r === "move") return
		}
		let c = await this.statIgnoreError(t)
		if (!c) throw Bo(p("fileMoveCopyErrorNotFound", "File to move/copy does not exist"), "EntryNotFound")
		let u = await this.statIgnoreError(n)
		if (u) {
			if (!i)
				throw Bo(
					p(
						"fileMoveCopyErrorExists",
						"File at target already exists and thus will not be moved/copied to unless overwrite is specified",
					),
					"EntryExists",
				)
			;((c.type & 1) !== 0 && (u.type & 1) !== 0) ||
				(await this.delete(n, { recursive: !0, useTrash: !1, atomic: !1 }))
		}
	}
	async cloneFile(t, n) {
		return this.doCloneFile(t, n, !1)
	}
	async doCloneFile(t, n, r) {
		let i = this.toFilePath(t),
			s = this.toFilePath(n),
			a = !!(this.capabilities & 1024)
		if (Tc(i, s, !a)) return
		let l = new Q()
		try {
			l.add(await this.createResourceLock(t)),
				l.add(await this.createResourceLock(n)),
				r && (await oc.mkdir(Qt(s), { recursive: !0 })),
				await oc.copyFile(i, s)
		} catch (d) {
			if (d.code === "ENOENT" && !r) return this.doCloneFile(t, n, !0)
			throw this.toFileSystemProviderError(d)
		} finally {
			l.dispose()
		}
	}
	createUniversalWatcher(t, n, r) {
		return new CT(
			(i) => t(i),
			(i) => n(i),
			r,
		)
	}
	createNonRecursiveWatcher(t, n, r) {
		return new wT(
			(i) => t(i),
			(i) => n(i),
			r,
		)
	}
	toFileSystemProviderError(t) {
		if (t instanceof ba) return t
		let n = t,
			r
		switch (t.code) {
			case "ENOENT":
				r = "EntryNotFound"
				break
			case "EISDIR":
				r = "EntryIsADirectory"
				break
			case "ENOTDIR":
				r = "EntryNotADirectory"
				break
			case "EEXIST":
				r = "EntryExists"
				break
			case "EPERM":
			case "EACCES":
				r = "NoPermissions"
				break
			case "ERR_UNC_HOST_NOT_ALLOWED":
				;(n = `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`),
					(r = "Unknown")
				break
			default:
				r = "Unknown"
		}
		return Bo(n, r)
	}
	async toFileSystemProviderWriteError(t, n) {
		let r = this.toFileSystemProviderError(n)
		if (t && r.code === "NoPermissions")
			try {
				let { stat: i } = await ir.stat(this.toFilePath(t))
				i.mode & 128 || (r = Bo(n, "EntryWriteLocked"))
			} catch (i) {
				this.logService.trace(i)
			}
		return r
	}
}
var Vm = class {
	constructor(e, t) {
		e.addFileSystemProvider(W.file, new l0(t), { isCaseSensitive: Ve })
	}
}
Vm = R([S(0, Fi), S(1, te)], Vm)
var l0 = class {
	constructor(e) {
		this.impl = new PT(e)
	}
	async stat(e) {
		let t = await this.impl.stat(e)
		return {
			type: t.type,
			ctime: t.ctime,
			mtime: t.mtime,
			size: t.size,
			permissions: t.permissions === 1 ? 1 : void 0,
		}
	}
	readDirectory(e) {
		return this.impl.readdir(e)
	}
	createDirectory(e) {
		return this.impl.mkdir(e)
	}
	readFile(e) {
		return this.impl.readFile(e)
	}
	writeFile(e, t, n) {
		return this.impl.writeFile(e, t, { ...n, unlock: !1, atomic: !1 })
	}
	delete(e, t) {
		return this.impl.delete(e, { ...t, useTrash: !1, atomic: !1 })
	}
	rename(e, t, n) {
		return this.impl.rename(e, t, n)
	}
	copy(e, t, n) {
		return this.impl.copy(e, t, n)
	}
	get onDidChangeFile() {
		throw new Error("Method not implemented.")
	}
	watch(e, t) {
		throw new Error("Method not implemented.")
	}
}
import UU from "module"
var HU = UU.createRequire(import.meta.url),
	d0 = class extends ec {
		_installInterceptor() {
			let e = this,
				t = HU("module"),
				n = t._load
			t._load = function (l, d, c) {
				return (
					(l = s(l)),
					e._factories.has(l)
						? e._factories.get(l).load(l, b.file(UO(d.filename)), (u) => n.apply(this, [u, d, c]))
						: n.apply(this, arguments)
				)
			}
			let r = t._resolveLookupPaths
			t._resolveLookupPaths = (a, l) => r.call(this, s(a), l)
			let i = t._resolveFilename
			t._resolveFilename = function (l, d, c, u) {
				return (
					l === "vsda" &&
						Array.isArray(u?.paths) &&
						u.paths.length === 0 &&
						(u.paths = t._nodeModulePaths(import.meta.dirname)),
					i.call(this, l, d, c, u)
				)
			}
			let s = (a) => {
				for (let l of e._alternatives) {
					let d = l(a)
					if (d) {
						a = d
						break
					}
				}
				return a
			}
		}
	},
	c0 = class o extends ec {
		constructor() {
			super(...arguments)
			this._store = new Q()
		}
		static _createDataUri(t) {
			return `data:text/javascript;base64,${Buffer.from(t).toString("base64")}`
		}
		static {
			this._loaderScript = `
	let lookup;
	export const initialize = async (context) => {
		let requestIds = 0;
		const { port } = context;
		const pendingRequests = new Map();
		port.onmessage = (event) => {
			const { id, url } = event.data;
			pendingRequests.get(id)?.(url);
		};
		lookup = url => {
			// debugger;
			const myId = requestIds++;
			return new Promise((resolve) => {
				pendingRequests.set(myId, resolve);
				port.postMessage({ id: myId, url, });
			});
		};
	};
	export const resolve = async (specifier, context, nextResolve) => {
		if (specifier !== 'vscode' || !context.parentURL) {
			return nextResolve(specifier, context);
		}
		const otherUrl = await lookup(context.parentURL);
		return {
			url: otherUrl,
			shortCircuit: true,
		};
	};`
		}
		static {
			this._vscodeImportFnName = "_VSCODE_IMPORT_VSCODE_API"
		}
		dispose() {
			this._store.dispose()
		}
		_installInterceptor() {
			let t = new cv(),
				n = new Map()
			Object.defineProperty(globalThis, o._vscodeImportFnName, {
				enumerable: !1,
				configurable: !1,
				writable: !1,
				value: (l) => t.getKey(l),
			})
			let { port1: r, port2: i } = new MessageChannel(),
				s,
				a = r
			;(a.onmessage = (l) => {
				s || ((s = this._factories.get("vscode")), bc(s))
				let { id: d, url: c } = l.data,
					u = b.parse(c),
					m = s.load("_not_used", u, () => {
						throw new Error("CANNOT LOAD MODULE from here.")
					}),
					f = t.get(m)
				f || ((f = He()), t.set(m, f))
				let h = n.get(f)
				if (!h) {
					let g = `const _vscodeInstance = globalThis.${o._vscodeImportFnName}('${f}');

${Object.keys(m).map((I) => `export const ${I} = _vscodeInstance['${I}'];`).join(`
`)}`
					;(h = o._createDataUri(g)), n.set(f, h)
				}
				r.postMessage({ id: d, url: h })
			}),
				UU.register(o._createDataUri(o._loaderScript), {
					parentURL: import.meta.url,
					data: { port: i },
					transferList: [i],
				}),
				this._store.add(
					q(() => {
						r.close(), i.close()
					}),
				)
		}
	},
	_T = class extends ul {
		constructor() {
			super(...arguments)
			this.extensionRuntime = 1
		}
		async _beforeAlmostReadyToRunExtensions() {
			this._instaService.createInstance(Hm)
			let t = this._instaService.invokeFunction(pU)
			if (
				(this._instaService.createInstance(Fm),
				this._initData.remote.isRemote && this._initData.remote.authority)
			) {
				let r = this._instaService.createInstance(Nm)
				process.env.VSCODE_IPC_HOOK_CLI = r.ipcHandlePath
			}
			this._instaService.createInstance(Vm),
				await this._instaService
					.createInstance(d0, t, { mine: this._myRegistry, all: this._globalRegistry })
					.install(),
				await this._store
					.add(
						this._instaService.createInstance(c0, t, { mine: this._myRegistry, all: this._globalRegistry }),
					)
					.install(),
				Ct("code/extHost/didInitAPI")
			let n = await this._extHostConfiguration.getConfigProvider()
			await AU(
				this._extHostWorkspace,
				n,
				this,
				this._logService,
				this._mainThreadTelemetryProxy,
				this._initData,
				this._store,
			),
				Ct("code/extHost/didInitProxyResolver")
		}
		_getEntryPoint(t) {
			return t.main
		}
		async _doLoadModule(t, n, r, i) {
			if (n.scheme !== W.file) throw new Error(`Cannot load URI: '${n}', must be of file-scheme`)
			let s = null
			r.codeLoadingStart(),
				this._logService.trace(`ExtensionService#loadModule [${i}] -> ${n.toString(!0)}`),
				this._logService.flush()
			let a = t?.identifier.value
			t && (await this._extHostLocalizationService.initializeLocalizedMessages(t))
			try {
				a && Ct(`code/extHost/willLoadExtensionCode/${a}`),
					i === "esm" ? (s = await import(n.fsPath)) : (s = HU(n.fsPath))
			} finally {
				a && Ct(`code/extHost/didLoadExtensionCode/${a}`), r.codeLoadingStop()
			}
			return s
		}
		async _loadCommonJSModule(t, n, r) {
			return this._doLoadModule(t, n, r, "cjs")
		}
		async _loadESMModule(t, n, r) {
			return this._doLoadModule(t, n, r, "esm")
		}
		async $setRemoteEnvironment(t) {
			if (this._initData.remote.isRemote)
				for (let n in t) {
					let r = t[n]
					r === null ? delete process.env[n] : (process.env[n] = r)
				}
		}
	}
import * as Bm from "fs"
import { exec as eH } from "child_process"
var K$ = (o, e, t) => {
		let n = new Uint8Array(16)
		for (let s = 0; s < 16; s++) n[s] = Math.round(Math.random() * 256)
		let r = Ol(z.wrap(n))
		return (
			[
				`GET ws://localhost${o}?${e}&skipWebSocketFrames=true HTTP/1.1`,
				"Connection: Upgrade",
				"Upgrade: websocket",
				`Sec-WebSocket-Key: ${r}`,
			].join(`\r
`) +
			`\r
\r
`
		)
	},
	WU = z.fromString(`\r
\r
`)
async function VU(o, e, t, n, r) {
	o.write(z.fromString(K$(e, t, n)))
	let i = new Q()
	try {
		return await new Promise((s, a) => {
			let l
			i.add(
				o.onData((d) => {
					l ? (l = z.concat([l, d], l.byteLength + d.byteLength)) : (l = d)
					let c = l.indexOf(WU)
					if (c === -1) return
					s(o), o.pauseData()
					let u = l.slice(c + WU.byteLength)
					u.byteLength && r.onData.fire(u)
				}),
			),
				i.add(o.onClose((d) => a(d ?? new Error("socket closed")))),
				i.add(o.onEnd(() => a(new Error("socket ended"))))
		})
	} catch (s) {
		throw (o.dispose(), s)
	} finally {
		i.dispose()
	}
}
var DT = class extends $ {
	constructor(t, n) {
		super()
		this.debugLabel = t
		this.pausableDataEmitter = this._register(new ci())
		this.onData = (...t) => (
			this.pausableDataEmitter.isPaused && queueMicrotask(() => this.pausableDataEmitter.resume()),
			this.pausableDataEmitter.event(...t)
		)
		this.didDisposeEmitter = this._register(new E())
		this.onDidDispose = this.didDisposeEmitter.event
		this.ended = !1
		this._register(n.onData),
			this._register(n.onData.event((r) => this.pausableDataEmitter.fire(r))),
			(this.onClose = this._register(n.onClose).event),
			(this.onEnd = this._register(n.onEnd).event)
	}
	pauseData() {
		this.pausableDataEmitter.pause()
	}
	drain() {
		return Promise.resolve()
	}
	end() {
		;(this.ended = !0), this.closeRemote()
	}
	traceSocketEvent(t, n) {
		qh.traceSocketEvent(this, this.debugLabel, t, n)
	}
	dispose() {
		this.ended || this.closeRemote(), this.didDisposeEmitter.fire(), super.dispose()
	}
}
var j$ = "signService",
	Tl = O(j$)
import * as QU from "net"
import * as JU from "os"
import * as u0 from "net"
var p0 = {
	1: !0,
	7: !0,
	9: !0,
	11: !0,
	13: !0,
	15: !0,
	17: !0,
	19: !0,
	20: !0,
	21: !0,
	22: !0,
	23: !0,
	25: !0,
	37: !0,
	42: !0,
	43: !0,
	53: !0,
	69: !0,
	77: !0,
	79: !0,
	87: !0,
	95: !0,
	101: !0,
	102: !0,
	103: !0,
	104: !0,
	109: !0,
	110: !0,
	111: !0,
	113: !0,
	115: !0,
	117: !0,
	119: !0,
	123: !0,
	135: !0,
	137: !0,
	139: !0,
	143: !0,
	161: !0,
	179: !0,
	389: !0,
	427: !0,
	465: !0,
	512: !0,
	513: !0,
	514: !0,
	515: !0,
	526: !0,
	530: !0,
	531: !0,
	532: !0,
	540: !0,
	548: !0,
	554: !0,
	556: !0,
	563: !0,
	587: !0,
	601: !0,
	636: !0,
	989: !0,
	990: !0,
	993: !0,
	995: !0,
	1719: !0,
	1720: !0,
	1723: !0,
	2049: !0,
	3659: !0,
	4045: !0,
	5060: !0,
	5061: !0,
	6e3: !0,
	6566: !0,
	6665: !0,
	6666: !0,
	6667: !0,
	6668: !0,
	6669: !0,
	6697: !0,
	10080: !0,
}
function BU(o, e, t, n = "127.0.0.1") {
	let r = !1,
		i,
		s = 1,
		a = u0.createServer({ pauseOnConnect: !0 })
	function l(d, c) {
		r || ((r = !0), a.removeAllListeners(), a.close(), i && clearTimeout(i), c(d))
	}
	return new Promise((d) => {
		;(i = setTimeout(() => {
			l(0, d)
		}, t)),
			a.on("listening", () => {
				l(o, d)
			}),
			a.on("error", (c) => {
				c && (c.code === "EADDRINUSE" || c.code === "EACCES") && s < e ? (o++, s++, a.listen(o, n)) : l(0, d)
			}),
			a.on("close", () => {
				l(0, d)
			}),
			a.listen(o, n)
	})
}
var G$ = 30 * 1e3
function f0(o) {
	switch (o) {
		case 1:
			return "Management"
		case 2:
			return "ExtensionHost"
		case 3:
			return "Tunnel"
	}
}
function zU(o) {
	let e = new _e()
	return setTimeout(() => e.cancel(), o), e.token
}
function Q$(o, e) {
	if (o.isCancellationRequested || e.isCancellationRequested) return De.Cancelled
	let t = new _e()
	return o.onCancellationRequested(() => t.cancel()), e.onCancellationRequested(() => t.cancel()), t.token
}
var Kh = class {
	get didTimeout() {
		return this._state === "timedout"
	}
	constructor(e) {
		;(this._state = "pending"),
			(this._disposables = new Q()),
			({ promise: this.promise, resolve: this._resolvePromise, reject: this._rejectPromise } = Tf()),
			e.isCancellationRequested
				? this._timeout()
				: this._disposables.add(e.onCancellationRequested(() => this._timeout()))
	}
	registerDisposable(e) {
		this._state === "pending" ? this._disposables.add(e) : e.dispose()
	}
	_timeout() {
		this._state === "pending" &&
			(this._disposables.dispose(), (this._state = "timedout"), this._rejectPromise(this._createTimeoutError()))
	}
	_createTimeoutError() {
		let e = new Error("Time limit reached")
		return (e.code = "ETIMEDOUT"), (e.syscall = "connect"), e
	}
	resolve(e) {
		this._state === "pending" && (this._disposables.dispose(), (this._state = "resolved"), this._resolvePromise(e))
	}
	reject(e) {
		this._state === "pending" && (this._disposables.dispose(), (this._state = "rejected"), this._rejectPromise(e))
	}
}
function J$(o, e) {
	let t = new Kh(e)
	return (
		t.registerDisposable(
			o.onControlMessage((n) => {
				let r = JSON.parse(n.toString()),
					i = t6(r)
				i ? t.reject(i) : t.resolve(r)
			}),
		),
		t.promise
	)
}
function X$(o, e, t, n, r, i, s, a) {
	let l = new Kh(a),
		d = zt.create(!1)
	return (
		o.info(`Creating a socket (${s})...`),
		Ct(`code/willCreateSocket/${i}`),
		e.connect(t, n, r, s).then(
			(c) => {
				l.didTimeout
					? (Ct(`code/didCreateSocketError/${i}`),
						o.info(
							`Creating a socket (${s}) finished after ${d.elapsed()} ms, but this is too late and has timed out already.`,
						),
						c?.dispose())
					: (Ct(`code/didCreateSocketOK/${i}`),
						o.info(`Creating a socket (${s}) was successful after ${d.elapsed()} ms.`),
						l.resolve(c))
			},
			(c) => {
				Ct(`code/didCreateSocketError/${i}`),
					o.info(`Creating a socket (${s}) returned an error after ${d.elapsed()} ms.`),
					o.error(c),
					l.reject(c)
			},
		),
		l.promise
	)
}
function m0(o, e) {
	let t = new Kh(e)
	return (
		o.then(
			(n) => {
				t.didTimeout || t.resolve(n)
			},
			(n) => {
				t.didTimeout || t.reject(n)
			},
		),
		t.promise
	)
}
async function Y$(o, e, t, n) {
	let r = GU(o, e)
	o.logService.trace(`${r} 1/6. invoking socketFactory.connect().`)
	let i
	try {
		i = await X$(
			o.logService,
			o.remoteSocketFactoryService,
			o.connectTo,
			WE.getServerRootPath(),
			`reconnectionToken=${o.reconnectionToken}&reconnection=${o.reconnectionProtocol ? "true" : "false"}`,
			f0(e),
			`renderer-${f0(e)}-${o.reconnectionToken}`,
			n,
		)
	} catch (c) {
		throw (o.logService.error(`${r} socketFactory.connect() failed or timed out. Error:`), o.logService.error(c), c)
	}
	o.logService.trace(`${r} 2/6. socketFactory.connect() was successful.`)
	let s, a
	o.reconnectionProtocol
		? (o.reconnectionProtocol.beginAcceptReconnection(i, null), (s = o.reconnectionProtocol), (a = !1))
		: ((s = new Ys({ socket: i })), (a = !0)),
		o.logService.trace(`${r} 3/6. sending AuthRequest control message.`)
	let l = await m0(o.signService.createNewMessage(He()), n),
		d = { type: "auth", auth: o.connectionToken || "00000000000000000000", data: l.data }
	s.sendControl(z.fromString(JSON.stringify(d)))
	try {
		let c = await J$(s, Q$(n, zU(1e4)))
		if (c.type !== "sign" || typeof c.data != "string") {
			let h = new Error("Unexpected handshake message")
			throw ((h.code = "VSCODE_CONNECTION_ERROR"), h)
		}
		if (
			(o.logService.trace(`${r} 4/6. received SignRequest control message.`),
			!(await m0(o.signService.validate(l, c.signedData), n)))
		) {
			let h = new Error("Refused to connect to unsupported server")
			throw ((h.code = "VSCODE_CONNECTION_ERROR"), h)
		}
		let m = await m0(o.signService.sign(c.data), n),
			f = { type: "connectionType", commit: o.commit, signedData: m, desiredConnectionType: e }
		return (
			t && (f.args = t),
			o.logService.trace(`${r} 5/6. sending ConnectionTypeRequest control message.`),
			s.sendControl(z.fromString(JSON.stringify(f))),
			{ protocol: s, ownsProtocol: a }
		)
	} catch (c) {
		throw (
			(c &&
				c.code === "ETIMEDOUT" &&
				(o.logService.error(`${r} the handshake timed out. Error:`), o.logService.error(c)),
			c &&
				c.code === "VSCODE_CONNECTION_ERROR" &&
				(o.logService.error(`${r} received error control message when negotiating connection. Error:`),
				o.logService.error(c)),
			a && jU(s),
			c)
		)
	}
}
async function Z$(o, e, t) {
	let n = Date.now(),
		r = GU(o, 3),
		{ protocol: i } = await Y$(o, 3, e, t)
	return o.logService.trace(`${r} 6/6. handshake finished, connection is up and running after ${o6(n)}!`), i
}
async function qU(o, e, t) {
	let { connectTo: n, connectionToken: r } = await o.addressProvider.getAddress()
	return {
		commit: o.commit,
		quality: o.quality,
		connectTo: n,
		connectionToken: r,
		reconnectionToken: e,
		reconnectionProtocol: t,
		remoteSocketFactoryService: o.remoteSocketFactoryService,
		signService: o.signService,
		logService: o.logService,
	}
}
async function KU(o, e, t) {
	let n = await qU(o, He(), null)
	return await Z$(n, { host: e, port: t }, De.None)
}
function e6(o) {
	return Ar(
		(e) =>
			new Promise((t, n) => {
				let r = setTimeout(t, o * 1e3)
				e.onCancellationRequested(() => {
					clearTimeout(r), t()
				})
			}),
	)
}
var g0 = class {
		constructor(e, t) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.type = 0
		}
	},
	h0 = class {
		constructor(e, t, n, r) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.durationSeconds = n
			this.cancellableTimer = r
			this.type = 1
		}
		skipWait() {
			this.cancellableTimer.cancel()
		}
	},
	v0 = class {
		constructor(e, t, n) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.type = 2
		}
	},
	RT = class {
		constructor(e, t, n) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.type = 4
		}
	},
	b0 = class {
		constructor(e, t, n, r) {
			this.reconnectionToken = e
			this.millisSinceLastIncomingData = t
			this.attempt = n
			this.handled = r
			this.type = 3
		}
	},
	$U = class o extends $ {
		constructor(t, n, r, i, s) {
			super()
			this._connectionType = t
			this._options = n
			this.reconnectionToken = r
			this.protocol = i
			this._reconnectionFailureIsFatal = s
			this._onDidStateChange = this._register(new E())
			this.onDidStateChange = this._onDidStateChange.event
			this._permanentFailure = !1
			this._isReconnecting = !1
			this._isDisposed = !1
			this._onDidStateChange.fire(new RT(this.reconnectionToken, 0, 0)),
				this._register(
					i.onSocketClose((a) => {
						let l = kT(this._connectionType, this.reconnectionToken, !0)
						a
							? a.type === 0
								? (this._options.logService.info(
										`${l} received socket close event (hadError: ${a.hadError}).`,
									),
									a.error && this._options.logService.error(a.error))
								: (this._options.logService.info(
										`${l} received socket close event (wasClean: ${a.wasClean}, code: ${a.code}, reason: ${a.reason}).`,
									),
									a.event && this._options.logService.error(a.event))
							: this._options.logService.info(`${l} received socket close event.`),
							this._beginReconnecting()
					}),
				),
				this._register(
					i.onSocketTimeout((a) => {
						let l = kT(this._connectionType, this.reconnectionToken, !0)
						this._options.logService.info(
							`${l} received socket timeout event (unacknowledgedMsgCount: ${a.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${a.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${a.timeSinceLastReceivedSomeData}).`,
						),
							this._beginReconnecting()
					}),
				),
				o._instances.push(this),
				this._register(
					q(() => {
						let a = o._instances.indexOf(this)
						a >= 0 && o._instances.splice(a, 1)
					}),
				),
				this._isPermanentFailure &&
					this._gotoPermanentFailure(
						o._permanentFailureMillisSinceLastIncomingData,
						o._permanentFailureAttempt,
						o._permanentFailureHandled,
					)
		}
		static triggerPermanentFailure(t, n, r) {
			;(this._permanentFailure = !0),
				(this._permanentFailureMillisSinceLastIncomingData = t),
				(this._permanentFailureAttempt = n),
				(this._permanentFailureHandled = r),
				this._instances.forEach((i) =>
					i._gotoPermanentFailure(
						this._permanentFailureMillisSinceLastIncomingData,
						this._permanentFailureAttempt,
						this._permanentFailureHandled,
					),
				)
		}
		static debugTriggerReconnection() {
			this._instances.forEach((t) => t._beginReconnecting())
		}
		static debugPauseSocketWriting() {
			this._instances.forEach((t) => t._pauseSocketWriting())
		}
		static {
			this._permanentFailure = !1
		}
		static {
			this._permanentFailureMillisSinceLastIncomingData = 0
		}
		static {
			this._permanentFailureAttempt = 0
		}
		static {
			this._permanentFailureHandled = !1
		}
		static {
			this._instances = []
		}
		get _isPermanentFailure() {
			return this._permanentFailure || o._permanentFailure
		}
		dispose() {
			super.dispose(), (this._isDisposed = !0)
		}
		async _beginReconnecting() {
			if (!this._isReconnecting)
				try {
					;(this._isReconnecting = !0), await this._runReconnectingLoop()
				} finally {
					this._isReconnecting = !1
				}
		}
		async _runReconnectingLoop() {
			if (this._isPermanentFailure || this._isDisposed) return
			let t = kT(this._connectionType, this.reconnectionToken, !0)
			this._options.logService.info(
				`${t} starting reconnecting loop. You can get more information with the trace log level.`,
			),
				this._onDidStateChange.fire(
					new g0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()),
				)
			let n = [0, 5, 5, 10, 10, 10, 10, 10, 30],
				r = -1
			do {
				r++
				let i = r < n.length ? n[r] : n[n.length - 1]
				try {
					if (i > 0) {
						let a = e6(i)
						this._onDidStateChange.fire(
							new h0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), i, a),
						),
							this._options.logService.info(`${t} waiting for ${i} seconds before reconnecting...`)
						try {
							await a
						} catch {}
					}
					if (this._isPermanentFailure) {
						this._options.logService.error(
							`${t} permanent failure occurred while running the reconnecting loop.`,
						)
						break
					}
					this._onDidStateChange.fire(
						new v0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r + 1),
					),
						this._options.logService.info(`${t} resolving connection...`)
					let s = await qU(this._options, this.reconnectionToken, this.protocol)
					this._options.logService.info(`${t} connecting to ${s.connectTo}...`),
						await this._reconnect(s, zU(G$)),
						this._options.logService.info(`${t} reconnected!`),
						this._onDidStateChange.fire(
							new RT(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r + 1),
						)
					break
				} catch (s) {
					if (s.code === "VSCODE_CONNECTION_ERROR") {
						this._options.logService.error(
							`${t} A permanent error occurred in the reconnecting loop! Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								!1,
							)
						break
					}
					if (r > 360) {
						this._options.logService.error(
							`${t} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								!1,
							)
						break
					}
					if (pu.isTemporarilyNotAvailable(s)) {
						this._options.logService.info(
							`${t} A temporarily not available error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (
						(s.code === "ETIMEDOUT" ||
							s.code === "ENETUNREACH" ||
							s.code === "ECONNREFUSED" ||
							s.code === "ECONNRESET") &&
						s.syscall === "connect"
					) {
						this._options.logService.info(
							`${t} A network error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (bn(s)) {
						this._options.logService.info(
							`${t} A promise cancelation error occurred while trying to reconnect, will try again...`,
						),
							this._options.logService.trace(s)
						continue
					}
					if (s instanceof pu) {
						this._options.logService.error(
							`${t} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`,
						),
							this._options.logService.error(s),
							this._onReconnectionPermanentFailure(
								this.protocol.getMillisSinceLastIncomingData(),
								r + 1,
								pu.isHandled(s),
							)
						break
					}
					this._options.logService.error(
						`${t} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`,
					),
						this._options.logService.error(s),
						this._onReconnectionPermanentFailure(this.protocol.getMillisSinceLastIncomingData(), r + 1, !1)
					break
				}
			} while (!this._isPermanentFailure && !this._isDisposed)
		}
		_onReconnectionPermanentFailure(t, n, r) {
			this._reconnectionFailureIsFatal ? o.triggerPermanentFailure(t, n, r) : this._gotoPermanentFailure(t, n, r)
		}
		_gotoPermanentFailure(t, n, r) {
			this._onDidStateChange.fire(new b0(this.reconnectionToken, t, n, r)), jU(this.protocol)
		}
		_pauseSocketWriting() {
			this.protocol.pauseSocketWriting()
		}
	}
function jU(o) {
	try {
		o.acceptDisconnect()
		let e = o.getSocket()
		o.dispose(), e.dispose()
	} catch (e) {
		Be(e)
	}
}
function t6(o) {
	if (o && o.type === "error") {
		let e = new Error(`Connection error: ${o.reason}`)
		return (e.code = "VSCODE_CONNECTION_ERROR"), e
	}
	return null
}
function n6(o, e) {
	for (; o.length < e; ) o += " "
	return o
}
function r6(o, e) {
	return `[remote-connection][${n6(f0(o), 13)}][${e.substr(0, 5)}\u2026]`
}
function kT(o, e, t) {
	return `${r6(o, e)}[${t ? "reconnect" : "initial"}]`
}
function GU(o, e) {
	return `${kT(e, o.reconnectionToken, !!o.reconnectionProtocol)}[${o.connectTo}]`
}
function o6(o) {
	return `${Date.now() - o} ms`
}
var AT = O("remoteSocketFactoryService")
async function s6(o, e, t, n, r) {
	let i
	for (
		let s = 3;
		s &&
		(i?.dispose(), (i = await new Qh(o, e, t, n, r).waitForReady()), !((r && p0[r]) || !p0[i.tunnelLocalPort]));
		s--
	);
	return i
}
var Qh = class extends $ {
		constructor(t, n, r, i, s) {
			super()
			this.defaultTunnelHost = n
			this.suggestedLocalPort = s
			this.privacy = "private"
			this._socketsDispose = new Map()
			;(this._options = t),
				(this._server = QU.createServer()),
				(this._barrier = new dn()),
				(this._listeningListener = () => this._barrier.open()),
				this._server.on("listening", this._listeningListener),
				(this._connectionListener = (a) => this._onConnection(a)),
				this._server.on("connection", this._connectionListener),
				(this._errorListener = () => {}),
				this._server.on("error", this._errorListener),
				(this.tunnelRemotePort = i),
				(this.tunnelRemoteHost = r)
		}
		async dispose() {
			super.dispose(),
				this._server.removeListener("listening", this._listeningListener),
				this._server.removeListener("connection", this._connectionListener),
				this._server.removeListener("error", this._errorListener),
				this._server.close(),
				Array.from(this._socketsDispose.values()).forEach((n) => {
					n()
				})
		}
		async waitForReady() {
			let t = this.suggestedLocalPort ?? this.tunnelRemotePort,
				n = To(this.defaultTunnelHost) ? "0.0.0.0" : "127.0.0.1",
				r = await BU(t, 2, 1e3, n),
				i = null
			return (
				this._server.listen(r, this.defaultTunnelHost),
				await this._barrier.wait(),
				(i = this._server.address()),
				i ||
					((r = 0),
					this._server.listen(r, this.defaultTunnelHost),
					await this._barrier.wait(),
					(i = this._server.address())),
				(this.tunnelLocalPort = i.port),
				(this.localAddress = `${this.tunnelRemoteHost === "127.0.0.1" ? "127.0.0.1" : "localhost"}:${i.port}`),
				this
			)
		}
		async _onConnection(t) {
			t.pause()
			let n = Ni(this.tunnelRemoteHost) || To(this.tunnelRemoteHost) ? "localhost" : this.tunnelRemoteHost,
				r = await KU(this._options, n, this.tunnelRemotePort),
				i = r.getSocket(),
				s = r.readEntireBuffer()
			r.dispose(),
				s.byteLength > 0 && t.write(s.buffer),
				t.on("end", () => {
					t.localAddress && this._socketsDispose.delete(t.localAddress), i.end()
				}),
				t.on("close", () => i.end()),
				t.on("error", () => {
					t.localAddress && this._socketsDispose.delete(t.localAddress),
						i instanceof ri ? i.socket.destroy() : i.end()
				}),
				i instanceof ri ? this._mirrorNodeSocket(t, i) : this._mirrorGenericSocket(t, i),
				t.localAddress &&
					this._socketsDispose.set(t.localAddress, () => {
						t.end(), i.end()
					})
		}
		_mirrorGenericSocket(t, n) {
			n.onClose(() => t.destroy()),
				n.onEnd(() => t.end()),
				n.onData((r) => t.write(r.buffer)),
				t.on("data", (r) => n.write(z.wrap(r))),
				t.resume()
		}
		_mirrorNodeSocket(t, n) {
			let r = n.socket
			r.on("end", () => t.end()),
				r.on("close", () => t.end()),
				r.on("error", () => {
					t.destroy()
				}),
				r.pipe(t),
				t.pipe(r)
		}
	},
	jh = class extends xp {
		constructor(t, n, r, i, s) {
			super(n, s)
			this.remoteSocketFactoryService = t
			this.signService = r
			this.productService = i
		}
		isPortPrivileged(t) {
			return u2(t, this.defaultTunnelHost, Ll, JU.release())
		}
		retainOrCreateTunnel(t, n, r, i, s, a, l, d) {
			let c = this.getTunnelFromMap(n, r)
			if (c) return ++c.refcount, c.value
			if (c2(t)) return this.createWithProvider(t, n, r, s, a, l, d)
			{
				this.logService.trace(
					`ForwardedPorts: (TunnelService) Creating tunnel without provider ${n}:${r} on local port ${s}.`,
				)
				let u = {
						commit: this.productService.commit,
						quality: this.productService.quality,
						addressProvider: t,
						remoteSocketFactoryService: this.remoteSocketFactoryService,
						signService: this.signService,
						logService: this.logService,
						ipcLogger: null,
					},
					m = s6(u, i, n, r, s)
				return (
					this.logService.trace("ForwardedPorts: (TunnelService) Tunnel created without provider."),
					this.addTunnelToMap(n, r, m),
					m
				)
			}
		}
	}
jh = R([S(0, AT), S(1, te), S(2, Tl), S(3, tu), S(4, br)], jh)
var Gh = class extends jh {
	constructor(e, t, n, r, i) {
		super(e, t, n, r, i)
	}
}
Gh = R([S(0, AT), S(1, te), S(2, Tl), S(3, tu), S(4, br)], Gh)
var OT = class extends $ {
	constructor(t, n, r, i, s) {
		super()
		this.remoteSocketFactoryService = t
		this.logService = n
		this.productService = r
		this.signService = i
		this.configurationService = s
		this._tunnelServices = new Map()
	}
	async openTunnel(t, n, r, i, s, a, l, d, c) {
		if (
			(this.logService.trace(
				`ForwardedPorts: (SharedTunnelService) openTunnel request for ${r}:${i} on local port ${a}.`,
			),
			!this._tunnelServices.has(t))
		) {
			let u = new Gh(
				this.remoteSocketFactoryService,
				this.logService,
				this.signService,
				this.productService,
				this.configurationService,
			)
			this._register(u),
				this._tunnelServices.set(t, u),
				u.onTunnelClosed(async () => {
					;(await u.tunnels).length === 0 && (u.dispose(), this._tunnelServices.delete(t))
				})
		}
		return this._tunnelServices.get(t).openTunnel(n, r, i, s, a, l, d, c)
	}
}
OT = R([S(0, AT), S(1, te), S(2, tu), S(3, Tl), S(4, br)], OT)
var XU = O("dialogService")
var GXe = O("fileDialogService")
var a6 = 10 * 1e3,
	LT = "remote.tunnels.toRestore",
	I0 = "remote.tunnels.toRestoreExpiration",
	l6 = 1e3 * 60 * 60 * 24 * 14,
	YU = "onTunnel",
	xYe = new D(
		"forwardedPortsViewEnabled",
		!1,
		p("tunnel.forwardedPortsViewEnabled", "Whether the Ports view is enabled."),
	),
	d6 = new D(
		"forwardedPortsViewOnlyEnabled",
		!1,
		p("tunnel.forwardedPortsViewEnabled", "Whether the Ports view is enabled."),
	)
function C0(o) {
	let e = o.match(/^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/)
	if (e) return { host: e[1]?.substring(0, e[1].length - 1) || "localhost", port: Number(e[2]) }
}
var x0 = { source: 0, description: p("tunnel.source.user", "User Forwarded") },
	CYe = { source: 1, description: p("tunnel.source.auto", "Auto Forwarded") }
function ZU(o, e, t) {
	let n = o.get(Vr(e, t))
	if (n) return n
	if (Ni(e))
		for (let r of Cp) {
			let i = Vr(r, t)
			if (o.has(i)) return o.get(i)
		}
	else if (To(e))
		for (let r of Xg) {
			let i = Vr(r, t)
			if (o.has(i)) return o.get(i)
		}
}
function Sr(o, e, t) {
	let n = ZU(o, e, t)
	if (n) return n
	let r = To(e) ? "localhost" : Ni(e) ? "0.0.0.0" : void 0
	if (r) return ZU(o, r, t)
}
function Vr(o, e) {
	return o + ":" + e
}
function c6(o) {
	return (
		o &&
		"host" in o &&
		typeof o.host == "string" &&
		"port" in o &&
		typeof o.port == "number" &&
		(!("detail" in o) || typeof o.detail == "string") &&
		(!("pid" in o) || typeof o.pid == "string")
	)
}
var MT = class o extends $ {
		constructor(t) {
			super()
			this.configurationService = t
			this.portsAttributes = []
			this._onDidChangeAttributes = new E()
			this.onDidChangeAttributes = this._onDidChangeAttributes.event
			this._register(
				t.onDidChangeConfiguration((n) => {
					;(n.affectsConfiguration(o.SETTING) || n.affectsConfiguration(o.DEFAULTS)) &&
						this.updateAttributes()
				}),
			),
				this.updateAttributes()
		}
		static {
			this.SETTING = "remote.portsAttributes"
		}
		static {
			this.DEFAULTS = "remote.otherPortsAttributes"
		}
		static {
			this.RANGE = /^(\d+)\-(\d+)$/
		}
		static {
			this.HOST_AND_PORT = /^([a-z0-9\-]+):(\d{1,5})$/
		}
		updateAttributes() {
			;(this.portsAttributes = this.readSetting()), this._onDidChangeAttributes.fire()
		}
		getAttributes(t, n, r) {
			let i = this.findNextIndex(t, n, r, this.portsAttributes, 0),
				s = {
					label: void 0,
					onAutoForward: void 0,
					elevateIfNeeded: void 0,
					requireLocalPort: void 0,
					protocol: void 0,
				}
			for (; i >= 0; ) {
				let a = this.portsAttributes[i]
				a.key === t
					? ((s.onAutoForward = a.onAutoForward ?? s.onAutoForward),
						(s.elevateIfNeeded = a.elevateIfNeeded !== void 0 ? a.elevateIfNeeded : s.elevateIfNeeded),
						(s.label = a.label ?? s.label),
						(s.requireLocalPort = a.requireLocalPort),
						(s.protocol = a.protocol))
					: ((s.onAutoForward = s.onAutoForward ?? a.onAutoForward),
						(s.elevateIfNeeded = s.elevateIfNeeded !== void 0 ? s.elevateIfNeeded : a.elevateIfNeeded),
						(s.label = s.label ?? a.label),
						(s.requireLocalPort = s.requireLocalPort !== void 0 ? s.requireLocalPort : void 0),
						(s.protocol = s.protocol ?? a.protocol)),
					(i = this.findNextIndex(t, n, r, this.portsAttributes, i + 1))
			}
			return s.onAutoForward !== void 0 ||
				s.elevateIfNeeded !== void 0 ||
				s.label !== void 0 ||
				s.requireLocalPort !== void 0 ||
				s.protocol !== void 0
				? s
				: this.getOtherAttributes()
		}
		hasStartEnd(t) {
			return t.start !== void 0 && t.end !== void 0
		}
		hasHostAndPort(t) {
			return t.host !== void 0 && t.port !== void 0 && we(t.host) && fn(t.port)
		}
		findNextIndex(t, n, r, i, s) {
			if (s >= i.length) return -1
			let a = !Ni(n) && !To(n),
				d = i
					.slice(s)
					.findIndex((c) =>
						fn(c.key)
							? a
								? !1
								: c.key === t
							: this.hasStartEnd(c.key)
								? a
									? !1
									: t >= c.key.start && t <= c.key.end
								: this.hasHostAndPort(c.key)
									? t === c.key.port && n === c.key.host
									: r
										? c.key.test(r)
										: !1,
					)
			return d >= 0 ? d + s : -1
		}
		readSetting() {
			let t = this.configurationService.getValue(o.SETTING)
			if (!t || !dt(t)) return []
			let n = []
			for (let i in t) {
				if (i === void 0) continue
				let s = t[i],
					a
				if (Number(i)) a = Number(i)
				else if (we(i))
					if (o.RANGE.test(i)) {
						let l = i.match(o.RANGE)
						a = { start: Number(l[1]), end: Number(l[2]) }
					} else if (o.HOST_AND_PORT.test(i)) {
						let l = i.match(o.HOST_AND_PORT)
						a = { host: l[1], port: Number(l[2]) }
					} else {
						let l
						try {
							l = RegExp(i)
						} catch {}
						l && (a = l)
					}
				a &&
					n.push({
						key: a,
						elevateIfNeeded: s.elevateIfNeeded,
						onAutoForward: s.onAutoForward,
						label: s.label,
						requireLocalPort: s.requireLocalPort,
						protocol: s.protocol,
					})
			}
			let r = this.configurationService.getValue(o.DEFAULTS)
			return (
				r &&
					(this.defaultPortAttributes = {
						elevateIfNeeded: r.elevateIfNeeded,
						label: r.label,
						onAutoForward: r.onAutoForward,
						requireLocalPort: r.requireLocalPort,
						protocol: r.protocol,
					}),
				this.sortAttributes(n)
			)
		}
		sortAttributes(t) {
			function n(r, i) {
				return fn(r.key)
					? r.key
					: i.hasStartEnd(r.key)
						? r.key.start
						: i.hasHostAndPort(r.key)
							? r.key.port
							: Number.MAX_VALUE
			}
			return t.sort((r, i) => n(r, this) - n(i, this))
		}
		getOtherAttributes() {
			return this.defaultPortAttributes
		}
		static providedActionToAction(t) {
			switch (t) {
				case 1:
					return "notify"
				case 2:
					return "openBrowser"
				case 6:
					return "openBrowserOnce"
				case 3:
					return "openPreview"
				case 4:
					return "silent"
				case 5:
					return "ignore"
				default:
					return
			}
		}
		async addAttributes(t, n, r) {
			let s = this.configurationService.inspect(o.SETTING).userRemoteValue,
				a
			!s || !dt(s) ? (a = {}) : (a = je(s)), a[`${t}`] || (a[`${t}`] = {})
			for (let l in n) a[`${t}`][l] = n[l]
			return this.configurationService.updateValue(o.SETTING, a, r)
		}
	},
	Jh = class extends $ {
		constructor(t, n, r, i, s, a, l, d, c, u) {
			super()
			this.tunnelService = t
			this.storageService = n
			this.configurationService = r
			this.environmentService = i
			this.remoteAuthorityResolverService = s
			this.workspaceContextService = a
			this.logService = l
			this.dialogService = d
			this.extensionService = c
			this.contextKeyService = u
			this.inProgress = new Map()
			this._onForwardPort = new E()
			this.onForwardPort = this._onForwardPort.event
			this._onClosePort = new E()
			this.onClosePort = this._onClosePort.event
			this._onPortName = new E()
			this.onPortName = this._onPortName.event
			this._onCandidatesChanged = new E()
			this.onCandidatesChanged = this._onCandidatesChanged.event
			this._onEnvironmentTunnelsSet = new E()
			this.onEnvironmentTunnelsSet = this._onEnvironmentTunnelsSet.event
			this._environmentTunnelsSet = !1
			this.restoreListener = void 0
			this.restoreComplete = !1
			this.onRestoreComplete = new E()
			this.unrestoredExtensionTunnels = new Map()
			this.sessionCachedProperties = new Map()
			this.portAttributesProviders = []
			this.hasCheckedExtensionsOnTunnelOpened = !1
			this.mismatchCooldown = new Date()
			;(this.configPortsAttributes = new MT(r)),
				(this.tunnelRestoreValue = this.getTunnelRestoreValue()),
				this._register(this.configPortsAttributes.onDidChangeAttributes(this.updateAttributes, this)),
				(this.forwarded = new Map()),
				(this.remoteTunnels = new Map()),
				this.tunnelService.tunnels.then(async (m) => {
					let f = await this.getAttributes(
						m.map((h) => ({ port: h.tunnelRemotePort, host: h.tunnelRemoteHost })),
					)
					for (let h of m)
						if (h.localAddress) {
							let g = Vr(h.tunnelRemoteHost, h.tunnelRemotePort),
								I = Sr(this._candidates ?? new Map(), h.tunnelRemoteHost, h.tunnelRemotePort)
							this.forwarded.set(g, {
								remotePort: h.tunnelRemotePort,
								remoteHost: h.tunnelRemoteHost,
								localAddress: h.localAddress,
								protocol: f?.get(h.tunnelRemotePort)?.protocol ?? "http",
								localUri: await this.makeLocalUri(h.localAddress, f?.get(h.tunnelRemotePort)),
								localPort: h.tunnelLocalPort,
								name: f?.get(h.tunnelRemotePort)?.label,
								runningProcess: I?.detail,
								hasRunningProcess: !!I,
								pid: I?.pid,
								privacy: h.privacy,
								source: x0,
							}),
								this.remoteTunnels.set(g, h)
						}
				}),
				(this.detected = new Map()),
				this._register(
					this.tunnelService.onTunnelOpened(async (m) => {
						let f = Vr(m.tunnelRemoteHost, m.tunnelRemotePort)
						if (
							!Sr(this.forwarded, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							!Sr(this.detected, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							!Sr(this.inProgress, m.tunnelRemoteHost, m.tunnelRemotePort) &&
							m.localAddress
						) {
							let h = Sr(this._candidates ?? new Map(), m.tunnelRemoteHost, m.tunnelRemotePort),
								g = (
									await this.getAttributes([{ port: m.tunnelRemotePort, host: m.tunnelRemoteHost }])
								)?.get(m.tunnelRemotePort)
							this.forwarded.set(f, {
								remoteHost: m.tunnelRemoteHost,
								remotePort: m.tunnelRemotePort,
								localAddress: m.localAddress,
								protocol: g?.protocol ?? "http",
								localUri: await this.makeLocalUri(m.localAddress, g),
								localPort: m.tunnelLocalPort,
								name: g?.label,
								closeable: !0,
								runningProcess: h?.detail,
								hasRunningProcess: !!h,
								pid: h?.pid,
								privacy: m.privacy,
								source: x0,
							})
						}
						await this.storeForwarded(),
							this.checkExtensionActivationEvents(!0),
							this.remoteTunnels.set(f, m),
							this._onForwardPort.fire(this.forwarded.get(f))
					}),
				),
				this._register(this.tunnelService.onTunnelClosed((m) => this.onTunnelClosed(m, "Other"))),
				this.checkExtensionActivationEvents(!1)
		}
		extensionHasActivationEvent() {
			return this.extensionService.extensions.find((t) => t.activationEvents?.includes(YU))
				? (this.contextKeyService.createKey(d6.key, !0), !0)
				: !1
		}
		checkExtensionActivationEvents(t) {
			if (
				this.hasCheckedExtensionsOnTunnelOpened ||
				(t && (this.hasCheckedExtensionsOnTunnelOpened = !0),
				this.environmentService.remoteAuthority !== void 0 && !t) ||
				this.extensionHasActivationEvent()
			)
				return
			let r = this._register(
				this.extensionService.onDidRegisterExtensions(() => {
					this.extensionHasActivationEvent() && r.dispose()
				}),
			)
		}
		async onTunnelClosed(t, n) {
			let r = Vr(t.host, t.port)
			this.forwarded.has(r) && (this.forwarded.delete(r), await this.storeForwarded(), this._onClosePort.fire(t))
		}
		makeLocalUri(t, n) {
			if (t.startsWith("http")) return b.parse(t)
			let r = n?.protocol ?? "http"
			return b.parse(`${r}://${t}`)
		}
		async addStorageKeyPostfix(t) {
			let n = this.workspaceContextService.getWorkspace(),
				r = n.configuration
					? lr(n.configuration.path)
					: n.folders.length > 0
						? lr(n.folders[0].uri.path)
						: void 0
			if (r === void 0) {
				this.logService.debug("Could not get workspace hash for forwarded ports storage key.")
				return
			}
			return `${t}.${this.environmentService.remoteAuthority}.${r}`
		}
		async getTunnelRestoreStorageKey() {
			return this.addStorageKeyPostfix(LT)
		}
		async getRestoreExpirationStorageKey() {
			return this.addStorageKeyPostfix(I0)
		}
		async getTunnelRestoreValue() {
			let t = this.storageService.get(LT, 1)
			if (t) return this.storageService.remove(LT, 1), await this.storeForwarded(), t
			let n = await this.getTunnelRestoreStorageKey()
			if (n) return this.storageService.get(n, 0)
		}
		async restoreForwarded() {
			if (
				(this.cleanupExpiredTunnelsForRestore(),
				this.configurationService.getValue("remote.restoreForwardedPorts"))
			) {
				let t = await this.tunnelRestoreValue
				if (t && t !== this.knownPortsRestoreValue) {
					let n = JSON.parse(t) ?? []
					this.logService.trace(
						`ForwardedPorts: (TunnelModel) restoring ports ${n.map((r) => r.remotePort).join(", ")}`,
					)
					for (let r of n) {
						let i = Sr(this.detected, r.remoteHost, r.remotePort)
						;(r.source.source !== 2 && !i) || (r.source.source === 2 && i)
							? await this.doForward({
									remote: { host: r.remoteHost, port: r.remotePort },
									local: r.localPort,
									name: r.name,
									elevateIfNeeded: !0,
									source: r.source,
								})
							: r.source.source === 2 &&
								!i &&
								this.unrestoredExtensionTunnels.set(Vr(r.remoteHost, r.remotePort), r)
					}
				}
			}
			if (((this.restoreComplete = !0), this.onRestoreComplete.fire(), !this.restoreListener)) {
				let t = await this.getTunnelRestoreStorageKey()
				;(this.restoreListener = this._register(new Q())),
					this.restoreListener.add(
						this.storageService.onDidChangeValue(
							0,
							void 0,
							this.restoreListener,
						)(async (n) => {
							n.key === t &&
								((this.tunnelRestoreValue = Promise.resolve(this.storageService.get(t, 0))),
								await this.restoreForwarded())
						}),
					)
			}
		}
		cleanupExpiredTunnelsForRestore() {
			let t = this.storageService.keys(0, 0).filter((n) => n.startsWith(I0))
			for (let n of t) {
				let r = this.storageService.getNumber(n, 0)
				if (r && r < Date.now()) {
					this.tunnelRestoreValue = Promise.resolve(void 0)
					let i = n.replace(I0, LT)
					this.storageService.remove(n, 0), this.storageService.remove(i, 0)
				}
			}
		}
		async storeForwarded() {
			if (this.configurationService.getValue("remote.restoreForwardedPorts")) {
				let t = Array.from(this.forwarded.values()),
					n = t.map((a) => ({
						remoteHost: a.remoteHost,
						remotePort: a.remotePort,
						localPort: a.localPort,
						name: a.name,
						localAddress: a.localAddress,
						localUri: a.localUri,
						protocol: a.protocol,
						source: a.source,
					})),
					r
				t.length > 0 && (r = JSON.stringify(n))
				let i = await this.getTunnelRestoreStorageKey(),
					s = await this.getRestoreExpirationStorageKey()
				!r && i && s
					? (this.storageService.remove(i, 0), this.storageService.remove(s, 0))
					: r !== this.knownPortsRestoreValue &&
						i &&
						s &&
						(this.storageService.store(i, r, 0, 0), this.storageService.store(s, Date.now() + l6, 0, 0)),
					(this.knownPortsRestoreValue = r)
			}
		}
		async showPortMismatchModalIfNeeded(t, n, r) {
			if (!t.tunnelLocalPort || !r?.requireLocalPort || t.tunnelLocalPort === n) return
			let i = new Date()
			if (this.mismatchCooldown.getTime() + a6 > i.getTime()) return
			this.mismatchCooldown = i
			let s = p(
				"remote.localPortMismatch.single",
				`Local port {0} could not be used for forwarding to remote port {1}.

This usually happens when there is already another process using local port {0}.

Port number {2} has been used instead.`,
				n,
				t.tunnelRemotePort,
				t.tunnelLocalPort,
			)
			return this.dialogService.info(s)
		}
		async forward(t, n) {
			return (
				!this.restoreComplete &&
					this.environmentService.remoteAuthority &&
					(await Ee.toPromise(this.onRestoreComplete.event)),
				this.doForward(t, n)
			)
		}
		async doForward(t, n) {
			await this.extensionService.activateByEvent(YU)
			let r = Sr(this.forwarded, t.remote.host, t.remote.port)
			n = n ?? (n !== null ? (await this.getAttributes([t.remote]))?.get(t.remote.port) : void 0)
			let i = t.local !== void 0 ? t.local : t.remote.port,
				s
			if (r) return this.mergeAttributesIntoExistingTunnel(r, t, n)
			{
				let a = this.environmentService.remoteAuthority,
					l = a
						? {
								getAddress: async () =>
									(await this.remoteAuthorityResolverService.resolveAuthority(a)).authority,
							}
						: void 0,
					d = Vr(t.remote.host, t.remote.port)
				this.inProgress.set(d, !0), (t = this.mergeCachedAndUnrestoredProperties(d, t))
				let c = await this.tunnelService.openTunnel(
					l,
					t.remote.host,
					t.remote.port,
					void 0,
					i,
					t.elevateIfNeeded ? t.elevateIfNeeded : n?.elevateIfNeeded,
					t.privacy,
					n?.protocol,
				)
				if (typeof c == "string") s = c
				else if (c && c.localAddress) {
					let u = Sr(this._candidates ?? new Map(), t.remote.host, t.remote.port),
						m = c.protocol ? (c.protocol === "https" ? "https" : "http") : (n?.protocol ?? "http"),
						f = {
							remoteHost: c.tunnelRemoteHost,
							remotePort: c.tunnelRemotePort,
							localPort: c.tunnelLocalPort,
							name: n?.label ?? t.name,
							closeable: !0,
							localAddress: c.localAddress,
							protocol: m,
							localUri: await this.makeLocalUri(c.localAddress, n),
							runningProcess: u?.detail,
							hasRunningProcess: !!u,
							pid: u?.pid,
							source: t.source ?? x0,
							privacy: c.privacy,
						}
					return (
						this.forwarded.set(d, f),
						this.remoteTunnels.set(d, c),
						this.inProgress.delete(d),
						await this.storeForwarded(),
						await this.showPortMismatchModalIfNeeded(c, i, n),
						this._onForwardPort.fire(f),
						c
					)
				}
				this.inProgress.delete(d)
			}
			return s
		}
		mergeCachedAndUnrestoredProperties(t, n) {
			let r = this.unrestoredExtensionTunnels.has(t)
				? this.unrestoredExtensionTunnels
				: this.sessionCachedProperties.has(t)
					? this.sessionCachedProperties
					: void 0
			if (r) {
				let i = r.get(t)
				r.delete(t),
					i &&
						((n.name = i.name ?? n.name),
						(n.local = ("local" in i ? i.local : "localPort" in i ? i.localPort : void 0) ?? n.local),
						(n.privacy = n.privacy))
			}
			return n
		}
		async mergeAttributesIntoExistingTunnel(t, n, r) {
			let i = r?.label ?? n.name,
				s
			;((u) => ((u[(u.None = 0)] = "None"), (u[(u.Fire = 1)] = "Fire"), (u[(u.Reopen = 2)] = "Reopen")))(
				(s ||= {}),
			)
			let a = 0
			switch (
				(i !== t.name && ((t.name = i), (a = 1)),
				(r?.protocol || t.protocol !== "http") &&
					r?.protocol !== t.protocol &&
					((n.source = t.source), (a = 2)),
				n.privacy && t.privacy !== n.privacy && (a = 2),
				a)
			) {
				case 1: {
					this._onForwardPort.fire()
					break
				}
				case 2:
					await this.close(t.remoteHost, t.remotePort, "User"), await this.doForward(n, r)
			}
			return Sr(this.remoteTunnels, n.remote.host, n.remote.port)
		}
		async name(t, n, r) {
			let i = Sr(this.forwarded, t, n),
				s = Vr(t, n)
			if (i) {
				;(i.name = r), await this.storeForwarded(), this._onPortName.fire({ host: t, port: n })
				return
			} else
				this.detected.has(s) && ((this.detected.get(s).name = r), this._onPortName.fire({ host: t, port: n }))
		}
		async close(t, n, r) {
			let i = Vr(t, n),
				s = this.forwarded.get(i)
			return (
				r === "AutoForwardEnd" &&
					s &&
					s.source.source === 1 &&
					this.sessionCachedProperties.set(i, { local: s.localPort, name: s.name, privacy: s.privacy }),
				await this.tunnelService.closeTunnel(t, n),
				this.onTunnelClosed({ host: t, port: n }, r)
			)
		}
		address(t, n) {
			let r = Vr(t, n)
			return (this.forwarded.get(r) || this.detected.get(r))?.localAddress
		}
		get environmentTunnelsSet() {
			return this._environmentTunnelsSet
		}
		addEnvironmentTunnels(t) {
			if (t)
				for (let n of t) {
					let r = Sr(this._candidates ?? new Map(), n.remoteAddress.host, n.remoteAddress.port),
						i =
							typeof n.localAddress == "string"
								? n.localAddress
								: Vr(n.localAddress.host, n.localAddress.port)
					this.detected.set(Vr(n.remoteAddress.host, n.remoteAddress.port), {
						remoteHost: n.remoteAddress.host,
						remotePort: n.remoteAddress.port,
						localAddress: i,
						protocol: "http",
						localUri: this.makeLocalUri(i),
						closeable: !1,
						runningProcess: r?.detail,
						hasRunningProcess: !!r,
						pid: r?.pid,
						privacy: "constantPrivate",
						source: { source: 2, description: p("tunnel.staticallyForwarded", "Statically Forwarded") },
					}),
						this.tunnelService.setEnvironmentTunnel(
							n.remoteAddress.host,
							n.remoteAddress.port,
							i,
							"constantPrivate",
							"http",
						)
				}
			;(this._environmentTunnelsSet = !0), this._onEnvironmentTunnelsSet.fire(), this._onForwardPort.fire()
		}
		setCandidateFilter(t) {
			this._candidateFilter = t
		}
		async setCandidates(t) {
			let n = t
			this._candidateFilter && (n = await this._candidateFilter(t))
			let r = this.updateInResponseToCandidates(n)
			this.logService.trace(
				`ForwardedPorts: (TunnelModel) removed candidates ${Array.from(r.values())
					.map((i) => i.port)
					.join(", ")}`,
			),
				this._onCandidatesChanged.fire(r)
		}
		updateInResponseToCandidates(t) {
			let n = this._candidates ?? new Map(),
				r = new Map()
			return (
				(this._candidates = r),
				t.forEach((i) => {
					let s = Vr(i.host, i.port)
					r.set(s, { host: i.host, port: i.port, detail: i.detail, pid: i.pid }), n.has(s) && n.delete(s)
					let a = Sr(this.forwarded, i.host, i.port)
					a && ((a.runningProcess = i.detail), (a.hasRunningProcess = !0), (a.pid = i.pid))
				}),
				n.forEach((i, s) => {
					let a = C0(s)
					if (!a) return
					let l = Sr(this.forwarded, a.host, a.port)
					l && ((l.runningProcess = void 0), (l.hasRunningProcess = !1), (l.pid = void 0))
					let d = Sr(this.detected, a.host, a.port)
					d && ((d.runningProcess = void 0), (d.hasRunningProcess = !1), (d.pid = void 0))
				}),
				n
			)
		}
		get candidates() {
			return this._candidates ? Array.from(this._candidates.values()) : []
		}
		get candidatesOrUndefined() {
			return this._candidates ? this.candidates : void 0
		}
		async updateAttributes() {
			let t = Array.from(this.forwarded.values()),
				n = await this.getAttributes(
					t.map((r) => ({ port: r.remotePort, host: r.remoteHost })),
					!1,
				)
			if (n)
				for (let r of t) {
					let i = n.get(r.remotePort)
					;(i?.protocol || r.protocol !== "http") &&
						i?.protocol !== r.protocol &&
						(await this.doForward(
							{
								remote: { host: r.remoteHost, port: r.remotePort },
								local: r.localPort,
								name: r.name,
								source: r.source,
							},
							i,
						)),
						i && i.label && i.label !== r.name && (await this.name(r.remoteHost, r.remotePort, i.label))
				}
		}
		async getAttributes(t, n = !0) {
			let r = new Map(),
				i = new Map()
			t.forEach((c) => {
				let u = Sr(this._candidates ?? new Map(), Cp[0], c.port) ?? c
				if (u) {
					r.set(c.port, u)
					let m = c6(u) ? u.pid : void 0
					i.has(m) || i.set(m, []), i.get(m)?.push(c.port)
				}
			})
			let s = new Map()
			if (
				(t.forEach((c) => {
					let u = this.configPortsAttributes.getAttributes(c.port, c.host, r.get(c.port)?.detail)
					u && s.set(c.port, u)
				}),
				this.portAttributesProviders.length === 0 || !n)
			)
				return s.size > 0 ? s : void 0
			let a = await Promise.all(
					this.portAttributesProviders.flatMap((c) =>
						Array.from(i.entries()).map((u) => {
							let m = u[1],
								f = r.get(m[0])
							return c.providePortAttributes(m, f?.pid, f?.detail, De.None)
						}),
					),
				),
				l = new Map()
			if (
				(a.forEach((c) =>
					c.forEach((u) => {
						u && l.set(u.port, u)
					}),
				),
				!s && !l)
			)
				return
			let d = new Map()
			return (
				t.forEach((c) => {
					let u = s.get(c.port),
						m = l.get(c.port)
					d.set(c.port, {
						elevateIfNeeded: u?.elevateIfNeeded,
						label: u?.label,
						onAutoForward: u?.onAutoForward ?? MT.providedActionToAction(m?.autoForwardAction),
						requireLocalPort: u?.requireLocalPort,
						protocol: u?.protocol,
					})
				}),
				d
			)
		}
		addAttributesProvider(t) {
			this.portAttributesProviders.push(t)
		}
	}
R([Wl(1e3)], Jh.prototype, "storeForwarded", 1),
	(Jh = R([S(0, d2), S(1, xy), S(2, br), S(3, Xx), S(4, PF), S(5, gi), S(6, te), S(7, XU), S(8, Ly), S(9, ma)], Jh))
function u6(o) {
	let e = o.trim().split(`
`),
		t = []
	return (
		e.forEach((r) => {
			let i = /\/proc\/(\d+)\/fd\/\d+ -> socket:\[(\d+)\]/.exec(r)
			i && i.length >= 3 && t.push({ pid: parseInt(i[1], 10), socket: parseInt(i[2], 10) })
		}),
		t.reduce((r, i) => ((r[i.socket] = i), r), {})
	)
}
function p6(...o) {
	let e = [].concat(...o.map(f6))
	return [
		...new Map(
			e
				.filter((t) => t.st === "0A")
				.map((t) => {
					let n = t.local_address.split(":")
					return { socket: parseInt(t.inode, 10), ip: m6(n[0]), port: parseInt(n[1], 16) }
				})
				.map((t) => [t.ip + ":" + t.port, t]),
		).values(),
	]
}
function m6(o) {
	let e = ""
	if (o.length === 8)
		for (let t = o.length - 2; t >= 0; t -= 2) (e += parseInt(o.substr(t, 2), 16)), t !== 0 && (e += ".")
	else
		for (let t = 0; t < o.length; t += 8) {
			let n = o.substring(t, t + 8),
				r = ""
			for (let i = 8; i >= 2; i -= 2)
				(r += n.substring(i - 2, i)),
					(i === 6 || i === 2) &&
						((r = parseInt(r, 16).toString(16)),
						(e += `${r}`),
						(r = ""),
						t + i !== o.length - 6 && (e += ":"))
		}
	return e
}
function f6(o) {
	let e = o.trim().split(`
`),
		t = e
			.shift()
			.trim()
			.split(/\s+/)
			.filter((r) => r !== "rx_queue" && r !== "tm->when")
	return e.map((r) =>
		r
			.trim()
			.split(/\s+/)
			.reduce((i, s, a) => ((i[t[a] || a] = s), i), {}),
	)
}
function g6(o) {
	return o.length > 500
		? !1
		: !!o.match(/.*\.vscode-server-[a-zA-Z]+\/bin.*/) ||
				o.indexOf("out/server-main.js") !== -1 ||
				o.indexOf("_productName=VSCode") !== -1
}
function h6(o) {
	let e = o.trim().split(`
`),
		t = []
	return (
		e.forEach((n) => {
			let r = /^\d+\s+\D+\s+root\s+(\d+)\s+(\d+).+\d+\:\d+\:\d+\s+(.+)$/.exec(n)
			r && r.length >= 4 && t.push({ pid: parseInt(r[1], 10), ppid: parseInt(r[2]), cmd: r[3] })
		}),
		t
	)
}
async function v6(o, e, t) {
	let n = t.reduce((i, s) => ((i[s.pid] = s), i), {}),
		r = []
	return (
		o.forEach(({ socket: i, ip: s, port: a }) => {
			let l = e[i] ? e[i].pid : void 0,
				d = l ? n[l]?.cmd : void 0
			l && d && !g6(d) && r.push({ host: s, port: a, detail: d, pid: l })
		}),
		r
	)
}
function b6(o, e, t) {
	let n = new Map(),
		r = h6(e)
	for (let i of o) {
		let s = t.get(i.port)
		if (s) {
			n.set(i.port, s)
			continue
		}
		let a = r.find((l) => l.cmd.includes(`${i.port}`))
		if (a) {
			let l = a,
				d
			do (d = r.find((c) => c.ppid === l.pid)), d && (l = d)
			while (d)
			n.set(i.port, { host: i.ip, port: i.port, pid: l.pid, detail: l.cmd, ppid: l.ppid })
		} else n.set(i.port, { host: i.ip, port: i.port, ppid: Number.MAX_VALUE })
	}
	return n
}
var $m = class extends al {
	constructor(t, n, r, i) {
		super(t, n, r)
		this.initData = n
		this.signService = i
		this._initialCandidates = void 0
		this._foundRootPorts = new Map()
		this._candidateFindingEnabled = !1
		Ve &&
			n.remote.isRemote &&
			n.remote.authority &&
			(this._proxy.$setRemoteTunnelService(process.pid), this.setInitialCandidates())
	}
	async $registerCandidateFinder(t) {
		if (t && this._candidateFindingEnabled) return
		this._candidateFindingEnabled = t
		let n
		this._initialCandidates &&
			((n = this._initialCandidates), await this._proxy.$onFoundNewCandidates(this._initialCandidates))
		let r = new Sb(),
			i = 0
		for (; this._candidateFindingEnabled; ) {
			let s = new Date().getTime(),
				a = (await this.findCandidatePorts()).filter((c) => Ni(c.host) || To(c.host))
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) found candidate ports ${a.map((c) => c.port).join(", ")}`,
			)
			let l = new Date().getTime() - s
			this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${l} ms.`),
				i++ > 3 && r.update(l),
				(!n || JSON.stringify(n) !== JSON.stringify(a)) && ((n = a), await this._proxy.$onFoundNewCandidates(n))
			let d = this.calculateDelay(r.value)
			this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${d} ms.`),
				await new Promise((c) => setTimeout(() => c(), d))
		}
	}
	calculateDelay(t) {
		return Math.max(t * 20, 2e3)
	}
	async setInitialCandidates() {
		;(this._initialCandidates = await this.findCandidatePorts()),
			this.logService.trace(
				`ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this._initialCandidates.map((t) => t.port).join(", ")}`,
			)
	}
	async findCandidatePorts() {
		let t = "",
			n = ""
		try {
			;(t = await Bm.promises.readFile("/proc/net/tcp", "utf8")),
				(n = await Bm.promises.readFile("/proc/net/tcp6", "utf8"))
		} catch {}
		let r = p6(t, n),
			i = await new Promise((f) => {
				eH("ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:", (h, g, I) => {
					f(g)
				})
			}),
			s = u6(i),
			a = await Qe.readdir("/proc"),
			l = []
		for (let f of a)
			try {
				let h = Number(f),
					g = ct(b.file("/proc"), f)
				if ((await Bm.promises.stat(g.fsPath)).isDirectory() && !isNaN(h)) {
					let C = await Bm.promises.readlink(ct(g, "cwd").fsPath),
						T = await Bm.promises.readFile(ct(g, "cmdline").fsPath, "utf8")
					l.push({ pid: h, cwd: C, cmd: T })
				}
			} catch {}
		let d = [],
			c = r.filter((f) => {
				let h = s[f.socket]
				return h || d.push(f), h
			}),
			u = v6(c, s, l),
			m
		if (
			(this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${d.length}`),
			d.length > 0)
		) {
			let f = await new Promise((h) => {
				eH("ps -F -A -l | grep root", (g, I, C) => {
					h(I)
				})
			})
			;(this._foundRootPorts = b6(d, f, this._foundRootPorts)),
				(m = Array.from(this._foundRootPorts.values())),
				this.logService.trace(
					`ForwardedPorts: (ExtHostTunnelService) heuristic ports ${m.map((h) => h.port).join(", ")}`,
				)
		}
		return u.then((f) => (m ? f.concat(m) : f))
	}
	makeManagedTunnelFactory(t) {
		return async (n) => {
			let r = new Qh(
				{
					commit: this.initData.commit,
					quality: this.initData.quality,
					logService: this.logService,
					ipcLogger: null,
					remoteSocketFactoryService: {
						_serviceBrand: void 0,
						async connect(s, a, l, d) {
							let c = await t.makeConnection()
							return S0.connect(c, a, l, d)
						},
						register() {
							throw new Error("not implemented")
						},
					},
					addressProvider: {
						getAddress() {
							return Promise.resolve({ connectTo: new uu(0), connectionToken: t.connectionToken })
						},
					},
					signService: this.signService,
				},
				"localhost",
				n.remoteAddress.host || "localhost",
				n.remoteAddress.port,
				n.localAddressPort,
			)
			await r.waitForReady()
			let i = new E()
			return {
				localAddress: C0(r.localAddress) ?? r.localAddress,
				remoteAddress: { port: r.tunnelRemotePort, host: r.tunnelRemoteHost },
				onDidDispose: i.event,
				dispose: () => {
					r.dispose(), i.fire(), i.dispose()
				},
			}
		}
	}
}
$m = R([S(0, ie), S(1, Xe), S(2, te), S(3, Tl)], $m)
var S0 = class o extends DT {
	constructor(t, n, r) {
		super(n, r)
		this.passing = t
	}
	static connect(t, n, r, i) {
		let s = new Q(),
			a = { onClose: s.add(new E()), onData: s.add(new E()), onEnd: s.add(new E()) }
		s.add(t.onDidReceiveMessage((d) => a.onData.fire(z.wrap(d)))),
			s.add(t.onDidEnd(() => a.onEnd.fire())),
			s.add(t.onDidClose((d) => a.onClose.fire({ type: 0, error: d, hadError: !!d })))
		let l = new o(t, i, a)
		return l._register(s), VU(l, n, r, i, a)
	}
	write(t) {
		this.passing.send(t.buffer)
	}
	closeRemote() {
		this.passing.end()
	}
	async drain() {
		await this.passing.drain?.()
	}
}
import * as Zs from "fs"
var FT = class extends yp {
	constructor() {
		super(...arguments)
		this._workspaceStorageLock = null
	}
	async _getWorkspaceStorageURI(t) {
		let n = await super._getWorkspaceStorageURI(t)
		if (n.scheme !== W.file) return n
		if (this._environment.skipWorkspaceStorageLock)
			return this._logService.info(`Skipping acquiring lock for ${n.fsPath}.`), n
		let r = n.fsPath,
			i = 0
		do {
			let s
			i === 0 ? (s = r) : (s = /[/\\]$/.test(r) ? `${r.substr(0, r.length - 1)}-${i}` : `${r}-${i}`), await y6(s)
			let a = Fe(s, "vscode.lock"),
				l = await nH(this._logService, a, !1)
			if (l)
				return (
					(this._workspaceStorageLock = l),
					process.on("exit", () => {
						l.dispose()
					}),
					b.file(s)
				)
			i++
		} while (i < 10)
		return n
	}
	onWillDeactivateAll() {
		this._workspaceStorageLock?.setWillRelease(6e3)
	}
}
async function y6(o) {
	try {
		await Zs.promises.stat(o)
		return
	} catch {}
	try {
		await Zs.promises.mkdir(o, { recursive: !0 })
	} catch {}
}
var I6 = 1e3,
	tH = 600 * 1e3,
	E0 = class extends $ {
		constructor(t, n) {
			super()
			this.logService = t
			this.filename = n
			;(this._timer = this._register(new _c())),
				this._timer.cancelAndSet(async () => {
					let r = await w0(t, n)
					;(!r || r.pid !== process.pid) &&
						(t.info(`Lock '${n}': The lock was lost unexpectedly.`), this._timer.cancel())
					try {
						await Zs.promises.utimes(n, new Date(), new Date())
					} catch (i) {
						t.error(i), t.info(`Lock '${n}': Could not update mtime.`)
					}
				}, I6)
		}
		dispose() {
			super.dispose()
			try {
				Zs.unlinkSync(this.filename)
			} catch {}
		}
		async setWillRelease(t) {
			this.logService.info(
				`Lock '${this.filename}': Marking the lockfile as scheduled to be released in ${t} ms.`,
			)
			try {
				let n = { pid: process.pid, willReleaseAt: Date.now() + t }
				await Qe.writeFile(this.filename, JSON.stringify(n), { flag: "w" })
			} catch (n) {
				this.logService.error(n)
			}
		}
	}
async function nH(o, e, t) {
	try {
		let r = { pid: process.pid, willReleaseAt: 0 }
		await Qe.writeFile(e, JSON.stringify(r), { flag: "wx" })
	} catch (r) {
		o.error(r)
	}
	let n = await w0(o, e)
	return !n || n.pid !== process.pid
		? t
			? (o.info(`Lock '${e}': Could not acquire lock, giving up.`), null)
			: (o.info(`Lock '${e}': Could not acquire lock, checking if the file is stale.`), C6(o, e))
		: (o.info(`Lock '${e}': Lock acquired.`), new E0(o, e))
}
async function w0(o, e) {
	let t
	try {
		t = await Zs.promises.readFile(e)
	} catch (n) {
		return o.error(n), null
	}
	try {
		return JSON.parse(String(t))
	} catch (n) {
		return o.error(n), null
	}
}
async function T0(o, e) {
	let t
	try {
		t = await Zs.promises.stat(e)
	} catch (n) {
		return o.error(n), 0
	}
	return t.mtime.getTime()
}
function x6(o) {
	try {
		return process.kill(o, 0), !0
	} catch {
		return !1
	}
}
async function C6(o, e) {
	let t = await w0(o, e)
	if (!t) return o.info(`Lock '${e}': Could not read pid of lock holder.`), Xh(o, e)
	if (t.willReleaseAt) {
		let a = t.willReleaseAt - Date.now()
		if (a < 5e3) {
			for (
				a > 0
					? o.info(`Lock '${e}': The lockfile is scheduled to be released in ${a} ms.`)
					: o.info(`Lock '${e}': The lockfile is scheduled to have been released.`);
				a > 0;

			) {
				if ((await Wt(Math.min(100, a)), (await T0(o, e)) === 0)) return Xh(o, e)
				a = t.willReleaseAt - Date.now()
			}
			return Xh(o, e)
		}
	}
	if (!x6(t.pid)) return o.info(`Lock '${e}': The pid ${t.pid} appears to be gone.`), Xh(o, e)
	let n = await T0(o, e),
		r = Date.now() - n
	if (r <= tH) return o.info(`Lock '${e}': The lock does not look stale, elapsed: ${r} ms, giving up.`), null
	o.info(`Lock '${e}': The lock looks stale, waiting for 2s.`), await Wt(2e3)
	let i = await T0(o, e),
		s = Date.now() - i
	return s <= tH
		? (o.info(`Lock '${e}': The lock does not look stale, elapsed: ${s} ms, giving up.`), null)
		: (o.info(`Lock '${e}': The lock looks stale even after waiting for 2s.`), Xh(o, e))
}
async function Xh(o, e) {
	o.info(`Lock '${e}': Deleting a stale lock.`)
	try {
		await Zs.promises.unlink(e)
	} catch {}
	return nH(o, e, !0)
}
async function S6(o, e, t, n, r) {
	try {
		let i = await import("@vscode/spdlog")
		i.setFlushOn(0)
		let s = await i.createAsyncRotatingLogger(o, e, t, n)
		return r ? s.clearFormatters() : s.setPattern("%Y-%m-%d %H:%M:%S.%e [%l] %v"), s
	} catch (i) {
		console.error(i)
	}
	return null
}
function rH(o, e, t) {
	switch (e) {
		case 1:
			o.trace(t)
			break
		case 2:
			o.debug(t)
			break
		case 3:
			o.info(t)
			break
		case 4:
			o.warn(t)
			break
		case 5:
			o.error(t)
			break
		case 0:
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
function oH(o, e) {
	switch (e) {
		case 1:
			o.setLevel(0)
			break
		case 2:
			o.setLevel(1)
			break
		case 3:
			o.setLevel(2)
			break
		case 4:
			o.setLevel(3)
			break
		case 5:
			o.setLevel(4)
			break
		case 0:
			o.setLevel(6)
			break
		default:
			throw new Error(`Invalid log level ${e}`)
	}
}
var NT = class extends ga {
	constructor(t, n, r, i, s) {
		super()
		this.buffer = []
		this.setLevel(s),
			(this._loggerCreationPromise = this._createSpdLogLogger(t, n, r, i)),
			this._register(
				this.onDidChangeLogLevel((a) => {
					this._logger && oH(this._logger, a)
				}),
			)
	}
	async _createSpdLogLogger(t, n, r, i) {
		let s = r ? 6 : 1,
			a = (30 / s) * Bc.MB,
			l = await S6(t, n, a, s, i)
		if (l) {
			;(this._logger = l), oH(this._logger, this.getLevel())
			for (let { level: d, message: c } of this.buffer) rH(this._logger, d, c)
			this.buffer = []
		}
	}
	log(t, n) {
		this._logger ? rH(this._logger, t, n) : this.getLevel() <= t && this.buffer.push({ level: t, message: n })
	}
	flush() {
		this._logger ? this.flushLogger() : this._loggerCreationPromise.then(() => this.flushLogger())
	}
	dispose() {
		this._logger ? this.disposeLogger() : this._loggerCreationPromise.then(() => this.disposeLogger()),
			super.dispose()
	}
	flushLogger() {
		this._logger && this._logger.flush()
	}
	disposeLogger() {
		this._logger && (this._logger.drop(), (this._logger = void 0))
	}
}
var UT = class extends bl {
	doCreateLogger(e, t, n) {
		return e.scheme === W.file
			? new NT(n?.name || He(), e.fsPath, !n?.donotRotate, !!n?.donotUseFormatters, t)
			: super.doCreateLogger(e, t, n)
	}
	registerLogger(e) {
		super.registerLogger(e), this._proxy.$registerLogger(e)
	}
	deregisterLogger(e) {
		super.deregisterLogger(e), this._proxy.$deregisterLogger(e)
	}
}
import { homedir as T6 } from "os"
var HT = class extends gl {
	homeDir() {
		return T6()
	}
}
var WT = class extends $ {
	constructor(e, t = []) {
		super(), (this.logger = new gb([e, ...t])), this._register(e.onDidChangeLogLevel((n) => this.setLevel(n)))
	}
	get onDidChangeLogLevel() {
		return this.logger.onDidChangeLogLevel
	}
	setLevel(e) {
		this.logger.setLevel(e)
	}
	getLevel() {
		return this.logger.getLevel()
	}
	trace(e, ...t) {
		this.logger.trace(e, ...t)
	}
	debug(e, ...t) {
		this.logger.debug(e, ...t)
	}
	info(e, ...t) {
		this.logger.info(e, ...t)
	}
	warn(e, ...t) {
		this.logger.warn(e, ...t)
	}
	error(e, ...t) {
		this.logger.error(e, ...t)
	}
	flush() {
		this.logger.flush()
	}
}
var zm = class extends WT {
	constructor(e, t, n) {
		let r = n.remote.isRemote ? "remoteexthost" : e ? "workerexthost" : "exthost",
			i = n.remote.isRemote
				? p("remote", "Extension Host (Remote)")
				: e
					? p("worker", "Extension Host (Worker)")
					: p("local", "Extension Host")
		super(t.createLogger(r, { name: i }))
	}
}
zm = R([S(1, uo), S(2, Xe)], zm)
import { spawn as w6 } from "child_process"
import { readFile as P6 } from "fs/promises"
import { homedir as sH } from "os"
function iH(o) {
	let e = new Map(),
		n = o.replace(
			/\r\n?/g,
			`
`,
		).split(`
`)
	for (let s of n) {
		if (((s = s.trim()), !s || s.startsWith("#"))) continue
		let [a, l] = r(s)
		a && e.set(a, l)
	}
	return e
	function r(s) {
		s.startsWith("export ") && (s = s.substring(7).trim())
		let a = i(s, (u) => u === "=" || u === ":")
		if (a === -1) return [null, null]
		let l = s.substring(0, a).trim(),
			d = s.substring(a + 1).trim(),
			c = i(d, (u) => u === "#")
		if ((c !== -1 && (d = d.substring(0, c).trim()), d.length >= 2)) {
			let u = d[0],
				m = d[d.length - 1]
			;((u === '"' && m === '"') || (u === "'" && m === "'") || (u === "`" && m === "`")) &&
				((d = d.substring(1, d.length - 1)),
				u === '"' &&
					(d = d
						.replace(
							/\\n/g,
							`
`,
						)
						.replace(/\\r/g, "\r")))
		}
		return [l, d]
	}
	function i(s, a) {
		let l = !1,
			d = ""
		for (let c = 0; c < s.length; c++) {
			let u = s[c]
			if (l) u === d && s[c - 1] !== "\\" && (l = !1)
			else if (u === '"' || u === "'" || u === "`") (l = !0), (d = u)
			else if (a(u)) return c
		}
		return -1
	}
}
import { Transform as E6 } from "stream"
var Yh = class extends E6 {
	constructor(e) {
		if ((super(), typeof e == "number")) (this.splitter = e), (this.spitterLen = 1)
		else {
			let t = Buffer.isBuffer(e) ? e : Buffer.from(e)
			;(this.splitter = t.length === 1 ? t[0] : t), (this.spitterLen = t.length)
		}
	}
	_transform(e, t, n) {
		this.buffer ? (this.buffer = Buffer.concat([this.buffer, e])) : (this.buffer = e)
		let r = 0
		for (; r < this.buffer.length; ) {
			let i =
				typeof this.splitter == "number"
					? this.buffer.indexOf(this.splitter, r)
					: uE(this.buffer, this.splitter, r)
			if (i === -1) break
			this.push(this.buffer.slice(r, i + this.spitterLen)), (r = i + this.spitterLen)
		}
		;(this.buffer = r === this.buffer.length ? void 0 : this.buffer.slice(r)), n()
	}
	_flush(e) {
		this.buffer && this.push(this.buffer), e()
	}
}
var qm = class extends yl {
	constructor(t) {
		super(t)
		this.nodeServers = new Map()
	}
	_startMcp(t, n) {
		n.type === 1 ? this.startNodeMpc(t, n) : super._startMcp(t, n)
	}
	$stopMcp(t) {
		let n = this.nodeServers.get(t)
		n ? (n.abortCtrl.abort(), this.nodeServers.delete(t)) : super.$stopMcp(t)
	}
	$sendMessage(t, n) {
		let r = this.nodeServers.get(t)
		r
			? r.child.stdin.write(
					n +
						`
`,
				)
			: super.$sendMessage(t, n)
	}
	async startNodeMpc(t, n) {
		let r = (l) =>
				this._proxy.$onDidChangeState(t, {
					state: Wr.Kind.Error,
					message: typeof l == "string" ? l : l.message,
				}),
			i = { ...process.env }
		if (n.envFile)
			try {
				for (let [l, d] of iH(await P6(n.envFile, "utf-8"))) i[l] = d
			} catch (l) {
				r(`Failed to read envFile '${n.envFile}': ${l.message}`)
				return
			}
		for (let [l, d] of Object.entries(n.env)) i[l] = d === null ? void 0 : String(d)
		let s = new AbortController(),
			a
		try {
			let l = n.cwd ? b.revive(n.cwd).fsPath : sH(),
				{ executable: d, args: c, shell: u } = await D6(n.command, n.args, l, i)
			this._proxy.$onDidPublishLog(t, 2, `Server command line: ${d} ${c.join(" ")}`),
				(a = w6(d, c, {
					stdio: "pipe",
					cwd: n.cwd ? b.revive(n.cwd).fsPath : sH(),
					signal: s.signal,
					env: i,
					shell: u,
				}))
		} catch (l) {
			r(l), s.abort()
			return
		}
		this._proxy.$onDidChangeState(t, { state: Wr.Kind.Starting }),
			a.stdout
				.pipe(
					new Yh(`
`),
				)
				.on("data", (l) => this._proxy.$onDidReceiveMessage(t, l.toString())),
			a.stdin.on("error", r),
			a.stdout.on("error", r),
			a.stderr
				.pipe(
					new Yh(`
`),
				)
				.on("data", (l) => this._proxy.$onDidPublishLog(t, 4, `[server stderr] ${l.toString().trimEnd()}`)),
			a.on("spawn", () => this._proxy.$onDidChangeState(t, { state: Wr.Kind.Running })),
			a.on("error", (l) => {
				s.signal.aborted ? this._proxy.$onDidChangeState(t, { state: Wr.Kind.Stopped }) : r(l)
			}),
			a.on("exit", (l) =>
				l === 0 || s.signal.aborted
					? this._proxy.$onDidChangeState(t, { state: Wr.Kind.Stopped })
					: this._proxy.$onDidChangeState(t, {
							state: Wr.Kind.Error,
							message: `Process exited with code ${l}`,
						}),
			),
			this.nodeServers.set(t, { abortCtrl: s, child: a })
	}
}
qm = R([S(0, ie)], qm)
var _6 = /\.(bat|cmd)$/i,
	D6 = async (o, e, t, n) => {
		if (process.platform !== "win32") return { executable: o, args: e, shell: !1 }
		let r = await $d(o, t, void 0, n)
		if (r && _6.test(r)) {
			let i = (s) => (s.includes(" ") ? `"${s}"` : s)
			return { executable: i(r), args: e.map(i), shell: !0 }
		}
		return { executable: o, args: e, shell: !1 }
	}
Ke(pr, _T, 0)
Ke(uo, UT, 1)
Ke(te, new hr(zm, [!1], !0))
Ke(Tl, dm, 1)
Ke(Ip, FT, 0)
Ke(cl, new hr(wp, [!1], !0))
Ke(em, um, 0)
Ke(rm, hm, 0)
Ke(Qp, am, 0)
Ke(tr, sm, 0)
Ke(ll, $m, 0)
Ke(ei, HT, 0)
Ke(Bd, qm, 0)
import { createRequire as A6 } from "module"
var lH = A6(import.meta.url)
;(function () {
	for (let e = 0; e < process.execArgv.length; e++)
		process.execArgv[e] === "--inspect-port=0" && (process.execArgv.splice(e, 1), e--)
})()
var VT = R6(process.argv.slice(2), { boolean: ["transformURIs", "skipWorkspaceStorageLock"], string: ["useHostProxy"] })
;(function () {
	let o = lH("module"),
		e = o._load
	o._load = function (t) {
		if (t === "natives")
			throw new Error(
				'Either the extension or an NPM dependency is using the [unsupported "natives" node module](https://go.microsoft.com/fwlink/?linkid=871887).',
			)
		return e.apply(this, arguments)
	}
})()
var BT = process.exit.bind(process),
	O6 = process.on.bind(process)
function L6(o) {
	;(process.exit = function (e) {
		if (o) BT(e)
		else {
			let t = new Error("An extension called process.exit() and this was prevented.")
			console.warn(t.stack)
		}
	}),
		(process.crash = function () {
			let e = new Error("An extension called process.crash() and this was prevented.")
			console.warn(e.stack)
		}),
		(process.env.ELECTRON_RUN_AS_NODE = "1"),
		(process.on = function (e, t) {
			if (e === "uncaughtException") {
				let n = t
				t = function (...r) {
					try {
						return n.apply(void 0, r)
					} catch {}
				}
			}
			O6(e, t)
		})
}
var $i = function (o) {
	BT()
}
function M6() {
	let o = O2(process.env)
	if (o.type === 3)
		return new Promise((e, t) => {
			let n = (r) => {
				let i = r[0],
					s = new zi()
				i.on("message", (a) => s.fire(z.wrap(a.data))),
					i.on("close", () => {
						$i("renderer closed the MessagePort")
					}),
					i.start(),
					e({ onMessage: s.event, send: (a) => i.postMessage(a.buffer) })
			}
			process.parentPort.on("message", (r) => n(r.ports))
		})
	if (o.type === 2)
		return new Promise((e, t) => {
			let n = null,
				r = setTimeout(() => {
					$i("VSCODE_EXTHOST_IPC_SOCKET timeout")
				}, 6e4),
				i = 108e5,
				s = 3e5,
				a = new Sf(() => $i("renderer disconnected for too long (1)"), i),
				l = new Sf(() => $i("renderer disconnected for too long (2)"), s)
			process.on("message", (c, u) => {
				if (c && c.type === "VSCODE_EXTHOST_IPC_SOCKET") {
					u.setNoDelay(!0)
					let m = z.wrap(Buffer.from(c.initialDataChunk, "base64")),
						f
					if (c.skipWebSocketFrames) f = new ri(u, "extHost-socket")
					else {
						let h = z.wrap(Buffer.from(c.inflateBytes, "base64"))
						f = new $T(new ri(u, "extHost-socket"), c.permessageDeflate, h, !1)
					}
					n
						? (ht.logOutgoing(0, 0, 0, "Reconnection case"),
							a.cancel(),
							l.cancel(),
							n.beginAcceptReconnection(f, m),
							n.endAcceptReconnection(),
							n.sendResume())
						: (ht.logOutgoing(0, 0, 0, "New connection case"),
							clearTimeout(r),
							(n = new Ys({ socket: f, initialChunk: m })),
							n.sendResume(),
							n.onDidDispose(() => $i("renderer disconnected")),
							e(n),
							n.onSocketClose(() => {
								a.schedule()
							}))
				}
				if (c && c.type === "VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME") {
					if ((ht.logOutgoing(0, 0, 0, "Reduce grace time case"), l.isScheduled())) return
					a.isScheduled() && l.schedule()
				}
			})
			let d = { type: "VSCODE_EXTHOST_IPC_READY" }
			process.send?.(d)
		})
	{
		let e = o.pipeName
		return new Promise((t, n) => {
			let r = aH.createConnection(e, () => {
				r.removeListener("error", n)
				let i = new Ys({ socket: new ri(r, "extHost-renderer") })
				i.sendResume(), t(i)
			})
			r.once("error", n),
				r.on("close", () => {
					$i("renderer closed the socket")
				})
		})
	}
}
async function F6() {
	let o = await M6()
	return new (class {
		constructor() {
			this._onMessage = new zi()
			this.onMessage = this._onMessage.event
			;(this._terminating = !1),
				(this._protocolListener = o.onMessage((e) => {
					eh(e, 2)
						? ((this._terminating = !0),
							this._protocolListener.dispose(),
							$i("received terminate message from renderer"))
						: this._onMessage.fire(e)
				}))
		}
		send(e) {
			this._terminating || o.send(e)
		}
		async drain() {
			if (o.drain) return o.drain()
		}
	})()
}
function N6(o) {
	return new Promise((e) => {
		let t = o.onMessage((n) => {
			t.dispose()
			let r = JSON.parse(n.toString()),
				i = r.commit,
				s = cb.commit
			if ((i && s && i !== s && BT(55), r.parentPid)) {
				let a = 0
				setInterval(function () {
					try {
						process.kill(r.parentPid, 0), (a = 0)
					} catch (d) {
						d && d.code === "EPERM"
							? (a++,
								a >= 3 &&
									$i(
										`parent process ${r.parentPid} does not exist anymore (3 x EPERM): ${d.message} (code: ${d.code}) (errno: ${d.errno})`,
									))
							: $i(
									`parent process ${r.parentPid} does not exist anymore: ${d.message} (code: ${d.code}) (errno: ${d.errno})`,
								)
					}
				}, 1e3)
				let l
				try {
					;(l = lH("native-watchdog")), l.start(r.parentPid)
				} catch (d) {
					Be(d)
				}
			}
			console.log("send initialized message"), o.send(Zg(0)), e({ protocol: o, initData: r })
		})
		console.log("send ready message"), o.send(Zg(1))
	})
}
async function U6() {
	let o = []
	process.on("unhandledRejection", (a, l) => {
		o.push(l),
			setTimeout(() => {
				let d = o.indexOf(l)
				d >= 0 &&
					l.catch((c) => {
						o.splice(d, 1),
							bn(c) ||
								(console.warn(`rejected promise not handled within 1 second: ${c}`),
								c && c.stack && console.warn(`stack trace: ${c.stack}`),
								a && Be(a))
					})
			}, 1e3)
	}),
		process.on("rejectionHandled", (a) => {
			let l = o.indexOf(a)
			l >= 0 && o.splice(l, 1)
		}),
		process.on("uncaughtException", function (a) {
			B0(a) || Be(a)
		}),
		Ct("code/extHost/willConnectToRenderer")
	let e = await F6()
	Ct("code/extHost/didConnectToRenderer")
	let t = await N6(e)
	Ct("code/extHost/didWaitForInitData")
	let { initData: n } = t
	L6(!!n.environment.extensionTestsLocationURI),
		(n.environment.useHostProxy = VT.useHostProxy !== void 0 ? VT.useHostProxy !== "false" : void 0),
		(n.environment.skipWorkspaceStorageLock = re(VT.skipWorkspaceStorageLock, !1))
	let r = new (class {
			constructor() {
				this.pid = process.pid
			}
			exit(l) {
				BT(l)
			}
			fsExists(l) {
				return Qe.exists(l)
			}
			fsRealpath(l) {
				return rb(l)
			}
		})(),
		i = null
	n.remote.authority && VT.transformURIs && (i = A2(n.remote.authority))
	let s = new nC(t.protocol, n, r, i)
	$i = (a) => s.terminate(a)
}
function H6() {
	U6().catch((o) => console.log(o))
}
var dH = H6
var ht = new ml("extension"),
	ev = process.argv.slice(2)
console.log("args:", ev)
var P0 = ev.includes("--listen") || process.env.VSCODE_EXTHOST_LISTEN === "true",
	Zh = parseInt(
		ev.find((o) => o.startsWith("--vscode-socket-port="))?.substring(21) ||
			process.env.VSCODE_EXTHOST_DEBUG_PORT ||
			"51234",
		10,
	),
	uH =
		ev.find((o) => o.startsWith("--vscode-socket-host="))?.substring(21) ||
		process.env.VSCODE_EXTHOST_SOCKET_HOST ||
		"127.0.0.1",
	pH =
		ev.find((o) => o.startsWith("--vscode-will-send-socket="))?.substring(26) ||
		process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET ||
		"0",
	mH = process.env.VSCODE_EXTHOST_IPC_HOOK
console.log(`Extension host starting in ${P0 ? "LISTEN" : "CONNECT"} mode`)
console.log("PORT:", Zh)
console.log("SOCKET_HOST:", uH)
console.log("WILL_SEND_SOCKET:", pH)
console.log("pipeName:", mH)
if (mH) console.log("Using pipeName, connection will be handled by VSCode IPC")
else {
	let a = function () {
			let c = cH.createServer((m) => {
					console.log("Main process connected to extension host"), m.setNoDelay(!0)
					let f = {
						type: "VSCODE_EXTHOST_IPC_SOCKET",
						initialDataChunk: "",
						skipWebSocketFrames: !0,
						permessageDeflate: !1,
						inflateBytes: "",
					}
					t.forEach((h) => {
						try {
							h(f, m)
						} catch (g) {
							console.error("Error in message handler:", g)
						}
					}),
						m.on("error", (h) => {
							console.error("Socket error:", h), ht.logOutgoing(0, 0, 0, "Socket error:", h)
						}),
						m.on("close", () => {
							console.log("Client connection closed, waiting for new connections..."),
								ht.logOutgoing(0, 0, 0, "Client connection closed, waiting for new connections...")
						})
				}),
				u = setInterval(() => {
					c.listening && console.log("Server still waiting for connections...")
				}, 6e4)
			process.on("exit", () => {
				clearInterval(u)
			}),
				c.listen(Zh, "127.0.0.1", () => {
					console.log(`Extension host server listening on 127.0.0.1:${Zh}`),
						console.log("Waiting for main process to connect...")
				}),
				c.on("error", (m) => {
					console.error("Server error:", m),
						ht.logOutgoing(0, 0, 0, "Server error:", m),
						setTimeout(() => {
							if (!c.listening) {
								console.log("Attempting to restart server after error...")
								try {
									c.listen(Zh, "127.0.0.1")
								} catch (f) {
									console.error("Failed to restart server:", f)
								}
							}
						}, 5e3)
				})
		},
		l = function () {
			if (n) {
				console.log("Already in reconnection process, skipping")
				return
			}
			try {
				let c = process.env.VSCODE_EXTHOST_SOCKET_HOST || "127.0.0.1",
					u = parseInt(process.env.VSCODE_EXTHOST_SOCKET_PORT || "0", 10)
				if (!u) throw new Error("Invalid socket port")
				console.log(`Attempting to connect to ${c}:${u}`)
				let m = cH.createConnection(u, c)
				m.setNoDelay(!0),
					m.on("connect", () => {
						console.log("Connected to main server"), (n = !1), (r = 0)
						let f = {
							type: "VSCODE_EXTHOST_IPC_SOCKET",
							initialDataChunk: "",
							skipWebSocketFrames: !0,
							permessageDeflate: !1,
							inflateBytes: "",
						}
						t.forEach((h) => {
							try {
								h(f, m)
							} catch (g) {
								console.error("Error in message handler:", g)
							}
						})
					}),
					m.on("error", (f) => {
						console.error("Socket connection error:", f),
							ht.logOutgoing(0, 0, 0, "Socket connection error:", f),
							d()
					}),
					m.on("close", () => {
						console.log("Socket connection closed"), d()
					})
			} catch (c) {
				console.error("Connection error:", c), ht.logOutgoing(0, 0, 0, "Connection error:", c), d()
			}
		}
	;(process.env.VSCODE_EXTHOST_SOCKET_PORT = Zh.toString()),
		(process.env.VSCODE_EXTHOST_SOCKET_HOST = uH),
		(process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET = pH),
		console.log("set send socket:", process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET)
	let o = process.on,
		e = process.send || (() => !1),
		t = [],
		n = !1,
		r = 0,
		i = 5,
		s = 1e3
	;(process.on = function (c, u) {
		return (
			c === "message" &&
				t.push((m, f) => {
					u.length === 1 ? u(m) : u(m, f)
				}),
			o.call(process, c, u)
		)
	}),
		(process.send = function (c) {
			return (
				c?.type === "VSCODE_EXTHOST_IPC_READY" &&
					(console.log("Extension host process is ready to receive socket"), P0 ? a() : l()),
				e.call(process, c)
			)
		})
	async function d() {
		if (n) {
			console.log("Already in reconnection process, skipping"),
				ht.logOutgoing(0, 0, 0, "Already in reconnection process, skipping")
			return
		}
		if (r >= i) {
			console.error("Max reconnection attempts reached. Giving up."),
				ht.logOutgoing(0, 0, 0, "Max reconnection attempts reached. Giving up.")
			return
		}
		;(n = !0),
			r++,
			console.log(`Attempting to reconnect (attempt ${r}/${i})...`),
			console.log(`Waiting ${s}ms before reconnecting...`),
			await new Promise((c) => setTimeout(c, s)),
			console.log("Reconnection delay finished, attempting to connect..."),
			(n = !1),
			l()
	}
}
console.log("Starting extension host process...")
P0 && (process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET = "1")
dH()
var qh
;((s) => {
	;(s.enableDiagnostics = !1), (s.records = [])
	let t = new WeakMap(),
		n = 0
	function r(a, l) {
		if (!t.has(a)) {
			let d = String(++n)
			t.set(a, d)
		}
		return t.get(a)
	}
	function i(a, l, d, c) {}
	s.traceSocketEvent = i
})((qh ||= {}))
var _0 = null
function El() {
	return _0 || (_0 = z.alloc(0)), _0
}
var tv = class {
	get byteLength() {
		return this._totalLength
	}
	constructor() {
		;(this._chunks = []), (this._totalLength = 0)
	}
	acceptChunk(e) {
		this._chunks.push(e), (this._totalLength += e.byteLength)
	}
	read(e) {
		return this._read(e, !0)
	}
	peek(e) {
		return this._read(e, !1)
	}
	_read(e, t) {
		if (e === 0) return El()
		if (e > this._totalLength) throw new Error("Cannot read so many bytes!")
		if (this._chunks[0].byteLength === e) {
			let s = this._chunks[0]
			return t && (this._chunks.shift(), (this._totalLength -= e)), s
		}
		if (this._chunks[0].byteLength > e) {
			let s = this._chunks[0].slice(0, e)
			return t && ((this._chunks[0] = this._chunks[0].slice(e)), (this._totalLength -= e)), s
		}
		let n = z.alloc(e),
			r = 0,
			i = 0
		for (; e > 0; ) {
			let s = this._chunks[i]
			if (s.byteLength > e) {
				let a = s.slice(0, e)
				n.set(a, r), (r += e), t && ((this._chunks[i] = s.slice(e)), (this._totalLength -= e)), (e -= e)
			} else
				n.set(s, r),
					(r += s.byteLength),
					t ? (this._chunks.shift(), (this._totalLength -= s.byteLength)) : i++,
					(e -= s.byteLength)
		}
		return n
	}
}
function fH(o) {
	switch (o) {
		case 0:
			return "None"
		case 1:
			return "Regular"
		case 2:
			return "Control"
		case 3:
			return "Ack"
		case 5:
			return "Disconnect"
		case 6:
			return "ReplayRequest"
		case 7:
			return "PauseWriting"
		case 8:
			return "ResumeWriting"
		case 9:
			return "KeepAlive"
	}
}
var Po = class {
		constructor(e, t, n, r) {
			this.type = e
			this.id = t
			this.ack = n
			this.data = r
			this.writtenTime = 0
		}
		get size() {
			return this.data.byteLength
		}
	},
	zT = class extends $ {
		constructor(t) {
			super()
			this._onMessage = this._register(new E())
			this.onMessage = this._onMessage.event
			this._state = { readHead: !0, readLen: 13, messageType: 0, id: 0, ack: 0 }
			;(this._socket = t),
				(this._isDisposed = !1),
				(this._incomingData = new tv()),
				this._register(this._socket.onData((n) => this.acceptChunk(n))),
				(this.lastReadTime = Date.now())
		}
		acceptChunk(t) {
			if (!t || t.byteLength === 0) {
				ht.logIncoming(0, 0, 0, "Accept chunk: empty buffer")
				return
			}
			for (
				ht.logIncoming(
					0,
					0,
					0,
					"Accept chunk: " +
						t.byteLength +
						", read head: " +
						this._state.readHead +
						", read len: " +
						this._state.readLen,
				),
					this.lastReadTime = Date.now(),
					this._incomingData.acceptChunk(t);
				this._incomingData.byteLength >= this._state.readLen;

			) {
				let n = this._incomingData.read(this._state.readLen)
				if (this._state.readHead)
					(this._state.readHead = !1),
						(this._state.readLen = n.readUInt32BE(9)),
						(this._state.messageType = n.readUInt8(0)),
						(this._state.id = n.readUInt32BE(1)),
						(this._state.ack = n.readUInt32BE(5)),
						ht.logIncoming(0, 0, 0, "Protocol header read: " + this._state.id),
						this._socket.traceSocketEvent("protocolHeaderRead", {
							messageType: fH(this._state.messageType),
							id: this._state.id,
							ack: this._state.ack,
							messageSize: this._state.readLen,
						})
				else {
					let r = this._state.messageType,
						i = this._state.id,
						s = this._state.ack
					if (
						((this._state.readHead = !0),
						(this._state.readLen = 13),
						(this._state.messageType = 0),
						(this._state.id = 0),
						(this._state.ack = 0),
						ht.logIncoming(0, 0, 0, "Protocol message read: " + i + ", type: " + r + ", ack: " + s),
						this._socket.traceSocketEvent("protocolMessageRead", n),
						this._onMessage.fire(new Po(r, i, s, n)),
						this._isDisposed)
					)
						break
				}
			}
		}
		readEntireBuffer() {
			return this._incomingData.read(this._incomingData.byteLength)
		}
		dispose() {
			;(this._isDisposed = !0), super.dispose()
		}
	},
	qT = class {
		constructor(e) {
			this._writeNowTimeout = null
			;(this._isDisposed = !1),
				(this._isPaused = !1),
				(this._socket = e),
				(this._data = []),
				(this._totalLength = 0),
				(this.lastWriteTime = 0)
		}
		dispose() {
			try {
				this.flush()
			} catch {}
			this._isDisposed = !0
		}
		drain() {
			return this.flush(), this._socket.drain()
		}
		flush() {
			this._writeNow()
		}
		pause() {
			this._isPaused = !0
		}
		resume() {
			;(this._isPaused = !1), this._scheduleWriting()
		}
		write(e) {
			if (this._isDisposed) return
			;(e.writtenTime = Date.now()), (this.lastWriteTime = Date.now())
			let t = z.alloc(13)
			t.writeUInt8(e.type, 0),
				t.writeUInt32BE(e.id, 1),
				t.writeUInt32BE(e.ack, 5),
				t.writeUInt32BE(e.data.byteLength, 9),
				this._socket.traceSocketEvent("protocolHeaderWrite", {
					messageType: fH(e.type),
					id: e.id,
					ack: e.ack,
					messageSize: e.data.byteLength,
				}),
				this._socket.traceSocketEvent("protocolMessageWrite", e.data),
				this._writeSoon(t, e.data)
		}
		_bufferAdd(e, t) {
			let n = this._totalLength === 0
			return this._data.push(e, t), (this._totalLength += e.byteLength + t.byteLength), n
		}
		_bufferTake() {
			let e = z.concat(this._data, this._totalLength)
			return (this._data.length = 0), (this._totalLength = 0), e
		}
		_writeSoon(e, t) {
			this._bufferAdd(e, t) && this._scheduleWriting()
		}
		_scheduleWriting() {
			this._writeNowTimeout ||
				(this._writeNowTimeout = setTimeout(() => {
					;(this._writeNowTimeout = null), this._writeNow()
				}))
		}
		_writeNow() {
			if (this._totalLength === 0 || this._isPaused) return
			let e = this._bufferTake()
			this._socket.traceSocketEvent("protocolWrite", { byteLength: e.byteLength }), this._socket.write(e)
		}
	}
var zi = class {
		constructor() {
			this._hasListeners = !1
			this._isDeliveringMessages = !1
			this._bufferedMessages = []
			;(this._emitter = new E({
				onWillAddFirstListener: () => {
					;(this._hasListeners = !0), queueMicrotask(() => this._deliverMessages())
				},
				onDidRemoveLastListener: () => {
					this._hasListeners = !1
				},
			})),
				(this.event = this._emitter.event)
		}
		_deliverMessages() {
			if (!this._isDeliveringMessages) {
				for (this._isDeliveringMessages = !0; this._hasListeners && this._bufferedMessages.length > 0; )
					this._emitter.fire(this._bufferedMessages.shift())
				this._isDeliveringMessages = !1
			}
		}
		fire(e) {
			this._hasListeners
				? this._bufferedMessages.length > 0
					? this._bufferedMessages.push(e)
					: this._emitter.fire(e)
				: this._bufferedMessages.push(e)
		}
		flushBuffer() {
			this._bufferedMessages = []
		}
	},
	D0 = class {
		constructor(e) {
			;(this.data = e), (this.next = null)
		}
	},
	k0 = class {
		constructor() {
			;(this._first = null), (this._last = null)
		}
		length() {
			let e = 0,
				t = this._first
			for (; t; ) (t = t.next), e++
			return e
		}
		peek() {
			return this._first ? this._first.data : null
		}
		toArray() {
			let e = [],
				t = 0,
				n = this._first
			for (; n; ) (e[t++] = n.data), (n = n.next)
			return e
		}
		pop() {
			if (this._first) {
				if (this._first === this._last) {
					;(this._first = null), (this._last = null)
					return
				}
				this._first = this._first.next
			}
		}
		push(e) {
			let t = new D0(e)
			if (!this._first) {
				;(this._first = t), (this._last = t)
				return
			}
			;(this._last.next = t), (this._last = t)
		}
	},
	R0 = class o {
		static {
			this._HISTORY_LENGTH = 10
		}
		static {
			this._INSTANCE = null
		}
		static getInstance() {
			return o._INSTANCE || (o._INSTANCE = new o()), o._INSTANCE
		}
		constructor() {
			this.lastRuns = []
			let e = Date.now()
			for (let t = 0; t < o._HISTORY_LENGTH; t++) this.lastRuns[t] = e - 1e3 * t
			setInterval(() => {
				for (let t = o._HISTORY_LENGTH; t >= 1; t--) this.lastRuns[t] = this.lastRuns[t - 1]
				this.lastRuns[0] = Date.now()
			}, 1e3)
		}
		load() {
			let e = Date.now(),
				t = (1 + o._HISTORY_LENGTH) * 1e3,
				n = 0
			for (let r = 0; r < o._HISTORY_LENGTH; r++) e - this.lastRuns[r] <= t && n++
			return 1 - n / o._HISTORY_LENGTH
		}
		hasHighLoad() {
			return this.load() >= 0.5
		}
	},
	Ys = class {
		constructor(e) {
			this._onControlMessage = new zi()
			this.onControlMessage = this._onControlMessage.event
			this._onMessage = new zi()
			this.onMessage = this._onMessage.event
			this._onDidDispose = new zi()
			this.onDidDispose = this._onDidDispose.event
			this._onSocketClose = new zi()
			this.onSocketClose = this._onSocketClose.event
			this._onSocketTimeout = new zi()
			this.onSocketTimeout = this._onSocketTimeout.event
			;(this._loadEstimator = e.loadEstimator ?? R0.getInstance()),
				(this._shouldSendKeepAlive = e.sendKeepAlive ?? !0),
				(this._isReconnecting = !1),
				(this._outgoingUnackMsg = new k0()),
				(this._outgoingMsgId = 0),
				(this._outgoingAckId = 0),
				(this._outgoingAckTimeout = null),
				(this._incomingMsgId = 0),
				(this._incomingAckId = 0),
				(this._incomingMsgLastTime = 0),
				(this._incomingAckTimeout = null),
				(this._lastReplayRequestTime = 0),
				(this._lastSocketTimeoutTime = Date.now()),
				(this._socketDisposables = new Q()),
				(this._socket = e.socket),
				(this._socketWriter = this._socketDisposables.add(new qT(this._socket))),
				(this._socketReader = this._socketDisposables.add(new zT(this._socket))),
				this._socketDisposables.add(this._socketReader.onMessage((t) => this._receiveMessage(t))),
				this._socketDisposables.add(this._socket.onClose((t) => this._onSocketClose.fire(t))),
				(this._fileLogger = new ml("PersistentProtocol")),
				e.initialChunk && this._socketReader.acceptChunk(e.initialChunk),
				this._shouldSendKeepAlive
					? (this._keepAliveInterval = setInterval(() => {
							this._sendKeepAlive()
						}, 5e3))
					: (this._keepAliveInterval = null)
		}
		get unacknowledgedCount() {
			return this._outgoingMsgId - this._outgoingAckId
		}
		dispose() {
			this._outgoingAckTimeout && (clearTimeout(this._outgoingAckTimeout), (this._outgoingAckTimeout = null)),
				this._incomingAckTimeout && (clearTimeout(this._incomingAckTimeout), (this._incomingAckTimeout = null)),
				this._keepAliveInterval && (clearInterval(this._keepAliveInterval), (this._keepAliveInterval = null)),
				this._socketDisposables.dispose()
		}
		drain() {
			return this._socketWriter.drain()
		}
		sendDisconnect() {
			if (!this._didSendDisconnect) {
				this._didSendDisconnect = !0
				let e = new Po(5, 0, 0, El())
				this._socketWriter.write(e), this._socketWriter.flush()
			}
		}
		sendPause() {
			let e = new Po(7, 0, 0, El())
			this._socketWriter.write(e)
		}
		sendResume() {
			let e = new Po(8, 0, 0, El())
			this._socketWriter.write(e)
		}
		pauseSocketWriting() {
			this._socketWriter.pause()
		}
		getSocket() {
			return this._socket
		}
		getMillisSinceLastIncomingData() {
			return Date.now() - this._socketReader.lastReadTime
		}
		beginAcceptReconnection(e, t) {
			this._fileLogger.logIncoming(0, 0, 0, "Begin accept reconnection"),
				(this._isReconnecting = !0),
				this._socketDisposables.dispose(),
				(this._socketDisposables = new Q()),
				this._onControlMessage.flushBuffer(),
				this._onSocketClose.flushBuffer(),
				this._onSocketTimeout.flushBuffer(),
				this._socket.dispose(),
				(this._lastReplayRequestTime = 0),
				(this._lastSocketTimeoutTime = Date.now()),
				(this._socket = e),
				(this._socketWriter = this._socketDisposables.add(new qT(this._socket))),
				(this._socketReader = this._socketDisposables.add(new zT(this._socket))),
				this._socketDisposables.add(this._socketReader.onMessage((n) => this._receiveMessage(n))),
				this._socketDisposables.add(this._socket.onClose((n) => this._onSocketClose.fire(n))),
				this._socketReader.acceptChunk(t)
		}
		endAcceptReconnection() {
			this._fileLogger.logIncoming(0, 0, 0, "End accept reconnection"),
				(this._isReconnecting = !1),
				(this._incomingAckId = this._incomingMsgId)
			let e = new Po(3, 0, this._incomingAckId, El())
			this._socketWriter.write(e)
			let t = this._outgoingUnackMsg.toArray()
			for (let n = 0, r = t.length; n < r; n++) this._socketWriter.write(t[n])
			this._recvAckCheck()
		}
		acceptDisconnect() {
			this._onDidDispose.fire()
		}
		_receiveMessage(e) {
			if (
				(this._fileLogger.logIncoming(
					0,
					0,
					0,
					"Receive message: " +
						e.type +
						", id: " +
						e.id +
						", ack: " +
						e.ack +
						", data: " +
						e.data.byteLength +
						", _incomingMsgId: " +
						this._incomingMsgId,
				),
				e.ack > this._outgoingAckId)
			) {
				this._outgoingAckId = e.ack
				do {
					let t = this._outgoingUnackMsg.peek()
					if (t && t.id <= e.ack) this._outgoingUnackMsg.pop()
					else break
				} while (!0)
			}
			switch (e.type) {
				case 0:
					break
				case 1: {
					if (e.id > this._incomingMsgId)
						if (e.id !== this._incomingMsgId + 1) {
							let t = Date.now()
							t - this._lastReplayRequestTime > 1e4 &&
								((this._lastReplayRequestTime = t), this._socketWriter.write(new Po(6, 0, 0, El())))
						} else
							(this._incomingMsgId = e.id),
								(this._incomingMsgLastTime = Date.now()),
								this._sendAckCheck(),
								this._onMessage.fire(e.data)
					break
				}
				case 2: {
					this._onControlMessage.fire(e.data)
					break
				}
				case 3:
					break
				case 5: {
					this._onDidDispose.fire()
					break
				}
				case 6: {
					let t = this._outgoingUnackMsg.toArray()
					for (let n = 0, r = t.length; n < r; n++) this._socketWriter.write(t[n])
					this._recvAckCheck()
					break
				}
				case 7: {
					this._socketWriter.pause()
					break
				}
				case 8: {
					this._socketWriter.resume()
					break
				}
				case 9:
					break
			}
		}
		readEntireBuffer() {
			return this._socketReader.readEntireBuffer()
		}
		flush() {
			this._socketWriter.flush()
		}
		send(e) {
			let t = ++this._outgoingMsgId
			this._incomingAckId = this._incomingMsgId
			let n = new Po(1, t, this._incomingAckId, e)
			this._outgoingUnackMsg.push(n), this._isReconnecting || (this._socketWriter.write(n), this._recvAckCheck())
		}
		sendControl(e) {
			let t = new Po(2, 0, 0, e)
			this._socketWriter.write(t)
		}
		_sendAckCheck() {
			if (this._incomingMsgId <= this._incomingAckId || this._incomingAckTimeout) return
			let e = Date.now() - this._incomingMsgLastTime
			if (e >= 2e3) {
				this._sendAck()
				return
			}
			this._incomingAckTimeout = setTimeout(
				() => {
					;(this._incomingAckTimeout = null), this._sendAckCheck()
				},
				2e3 - e + 5,
			)
		}
		_recvAckCheck() {
			if (this._outgoingMsgId <= this._outgoingAckId || this._outgoingAckTimeout || this._isReconnecting) return
			let e = this._outgoingUnackMsg.peek(),
				t = Date.now() - e.writtenTime,
				n = Date.now() - this._socketReader.lastReadTime,
				r = Date.now() - this._lastSocketTimeoutTime
			if (t >= 2e4 && n >= 2e4 && r >= 2e4 && !this._loadEstimator.hasHighLoad()) {
				;(this._lastSocketTimeoutTime = Date.now()),
					this._onSocketTimeout.fire({
						unacknowledgedMsgCount: this._outgoingUnackMsg.length(),
						timeSinceOldestUnacknowledgedMsg: t,
						timeSinceLastReceivedSomeData: n,
					})
				return
			}
			let i = Math.max(2e4 - t, 2e4 - n, 2e4 - r, 500)
			this._outgoingAckTimeout = setTimeout(() => {
				;(this._outgoingAckTimeout = null), this._recvAckCheck()
			}, i)
		}
		_sendAck() {
			if (this._incomingMsgId <= this._incomingAckId) return
			this._incomingAckId = this._incomingMsgId
			let e = new Po(3, 0, this._incomingAckId, El())
			this._socketWriter.write(e)
		}
		_sendKeepAlive() {
			this._incomingAckId = this._incomingMsgId
			let e = new Po(9, 0, this._incomingAckId, El())
			this._socketWriter.write(e)
		}
	}
var $6 = 3e4,
	ri = class {
		constructor(e, t = "") {
			this._canWrite = !0
			;(this.debugLabel = t),
				(this.socket = e),
				this.traceSocketEvent("created", { type: "NodeSocket" }),
				(this._errorListener = (r) => {
					if ((this.traceSocketEvent("error", { code: r?.code, message: r?.message }), r)) {
						if (r.code === "EPIPE") return
						Be(r)
					}
				}),
				this.socket.on("error", this._errorListener)
			let n
			;(this._closeListener = (r) => {
				this.traceSocketEvent("close", { hadError: r }), (this._canWrite = !1), n && clearTimeout(n)
			}),
				this.socket.on("close", this._closeListener),
				(this._endListener = () => {
					this.traceSocketEvent("nodeEndReceived"),
						(this._canWrite = !1),
						(n = setTimeout(() => e.destroy(), $6))
				}),
				this.socket.on("end", this._endListener)
		}
		traceSocketEvent(e, t) {
			qh.traceSocketEvent(this.socket, this.debugLabel, e, t)
		}
		dispose() {
			this.socket.off("error", this._errorListener),
				this.socket.off("close", this._closeListener),
				this.socket.off("end", this._endListener),
				this.socket.destroy()
		}
		onData(e) {
			let t = (n) => {
				this.traceSocketEvent("read", n), e(z.wrap(n))
			}
			return this.socket.on("data", t), { dispose: () => this.socket.off("data", t) }
		}
		onClose(e) {
			let t = (n) => {
				e({ type: 0, hadError: n, error: void 0 })
			}
			return this.socket.on("close", t), { dispose: () => this.socket.off("close", t) }
		}
		onEnd(e) {
			let t = () => {
				e()
			}
			return this.socket.on("end", t), { dispose: () => this.socket.off("end", t) }
		}
		write(e) {
			if (!(this.socket.destroyed || !this._canWrite))
				try {
					this.traceSocketEvent("write", e),
						this.socket.write(e.buffer, (t) => {
							if (t) {
								if (t.code === "EPIPE") return
								Be(t)
							}
						})
				} catch (t) {
					if (t.code === "EPIPE") return
					Be(t)
				}
		}
		end() {
			this.traceSocketEvent("nodeEndSent"), this.socket.end()
		}
		drain() {
			return (
				this.traceSocketEvent("nodeDrainBegin"),
				new Promise((e, t) => {
					if (this.socket.bufferSize === 0) {
						this.traceSocketEvent("nodeDrainEnd"), e()
						return
					}
					let n = () => {
						this.socket.off("close", n),
							this.socket.off("end", n),
							this.socket.off("error", n),
							this.socket.off("timeout", n),
							this.socket.off("drain", n),
							this.traceSocketEvent("nodeDrainEnd"),
							e()
					}
					this.socket.on("close", n),
						this.socket.on("end", n),
						this.socket.on("error", n),
						this.socket.on("timeout", n),
						this.socket.on("drain", n)
				})
			)
		}
	}
var $T = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._onData = this._register(new E())
			this._onClose = this._register(new E())
			this._isEnded = !1
			this._state = { state: 1, readLen: 2, fin: 0, compressed: !1, firstFrameOfMessage: !0, mask: 0, opcode: 0 }
			;(this.socket = t),
				this.traceSocketEvent("created", {
					type: "WebSocketNodeSocket",
					permessageDeflate: n,
					inflateBytesLength: r?.byteLength || 0,
					recordInflateBytes: i,
				}),
				(this._flowManager = this._register(new A0(this, n, r, i, this._onData, (s, a) => this._write(s, a)))),
				this._register(
					this._flowManager.onError((s) => {
						console.error(s), Be(s), this._onClose.fire({ type: 0, hadError: !0, error: s })
					}),
				),
				(this._incomingData = new tv()),
				this._register(this.socket.onData((s) => this._acceptChunk(s))),
				this._register(
					this.socket.onClose(async (s) => {
						this._flowManager.isProcessingReadQueue() &&
							(await Ee.toPromise(this._flowManager.onDidFinishProcessingReadQueue)),
							this._onClose.fire(s)
					}),
				)
		}
		get permessageDeflate() {
			return this._flowManager.permessageDeflate
		}
		get recordedInflateBytes() {
			return this._flowManager.recordedInflateBytes
		}
		traceSocketEvent(t, n) {
			this.socket.traceSocketEvent(t, n)
		}
		dispose() {
			this._flowManager.isProcessingWriteQueue()
				? this._register(
						this._flowManager.onDidFinishProcessingWriteQueue(() => {
							this.dispose()
						}),
					)
				: (this.socket.dispose(), super.dispose())
		}
		onData(t) {
			return this._onData.event(t)
		}
		onClose(t) {
			return this._onClose.event(t)
		}
		onEnd(t) {
			return this.socket.onEnd(t)
		}
		write(t) {
			let n = 0
			for (; n < t.byteLength; )
				this._flowManager.writeMessage(t.slice(n, Math.min(n + 262144, t.byteLength)), {
					compressed: !0,
					opcode: 2,
				}),
					(n += 262144)
		}
		_write(t, { compressed: n, opcode: r }) {
			if (this._isEnded) return
			this.traceSocketEvent("webSocketNodeSocketWrite", t)
			let i = 2
			t.byteLength < 126 ? (i += 0) : t.byteLength < 2 ** 16 ? (i += 2) : (i += 8)
			let s = z.alloc(i),
				a = n ? 64 : 0,
				l = r & 15
			if ((s.writeUInt8(128 | a | l, 0), t.byteLength < 126)) s.writeUInt8(t.byteLength, 1)
			else if (t.byteLength < 2 ** 16) {
				s.writeUInt8(126, 1)
				let d = 1
				s.writeUInt8((t.byteLength >>> 8) & 255, ++d), s.writeUInt8((t.byteLength >>> 0) & 255, ++d)
			} else {
				s.writeUInt8(127, 1)
				let d = 1
				s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8(0, ++d),
					s.writeUInt8((t.byteLength >>> 24) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 16) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 8) & 255, ++d),
					s.writeUInt8((t.byteLength >>> 0) & 255, ++d)
			}
			this.socket.write(z.concat([s, t]))
		}
		end() {
			;(this._isEnded = !0), this.socket.end()
		}
		_acceptChunk(t) {
			if (t.byteLength !== 0) {
				for (this._incomingData.acceptChunk(t); this._incomingData.byteLength >= this._state.readLen; )
					if (this._state.state === 1) {
						let n = this._incomingData.peek(this._state.readLen),
							r = n.readUInt8(0),
							i = (r & 128) >>> 7,
							s = (r & 64) >>> 6,
							a = r & 15,
							l = n.readUInt8(1),
							d = (l & 128) >>> 7,
							c = l & 127
						;(this._state.state = 2),
							(this._state.readLen = 2 + (d ? 4 : 0) + (c === 126 ? 2 : 0) + (c === 127 ? 8 : 0)),
							(this._state.fin = i),
							this._state.firstFrameOfMessage && (this._state.compressed = !!s),
							(this._state.firstFrameOfMessage = !!i),
							(this._state.mask = 0),
							(this._state.opcode = a),
							this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
								headerSize: this._state.readLen,
								compressed: this._state.compressed,
								fin: this._state.fin,
								opcode: this._state.opcode,
							})
					} else if (this._state.state === 2) {
						let n = this._incomingData.read(this._state.readLen),
							r = n.readUInt8(1),
							i = (r & 128) >>> 7,
							s = r & 127,
							a = 1
						s === 126
							? (s = n.readUInt8(++a) * 2 ** 8 + n.readUInt8(++a))
							: s === 127 &&
								(s =
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 0 +
									n.readUInt8(++a) * 2 ** 24 +
									n.readUInt8(++a) * 2 ** 16 +
									n.readUInt8(++a) * 2 ** 8 +
									n.readUInt8(++a))
						let l = 0
						i &&
							(l =
								n.readUInt8(++a) * 2 ** 24 +
								n.readUInt8(++a) * 2 ** 16 +
								n.readUInt8(++a) * 2 ** 8 +
								n.readUInt8(++a)),
							(this._state.state = 3),
							(this._state.readLen = s),
							(this._state.mask = l),
							this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
								bodySize: this._state.readLen,
								compressed: this._state.compressed,
								fin: this._state.fin,
								mask: this._state.mask,
								opcode: this._state.opcode,
							})
					} else if (this._state.state === 3) {
						let n = this._incomingData.read(this._state.readLen)
						this.traceSocketEvent("webSocketNodeSocketReadData", n),
							z6(n, this._state.mask),
							this.traceSocketEvent("webSocketNodeSocketUnmaskedData", n),
							(this._state.state = 1),
							(this._state.readLen = 2),
							(this._state.mask = 0),
							this._state.opcode <= 2
								? this._flowManager.acceptFrame(n, this._state.compressed, !!this._state.fin)
								: this._state.opcode === 9 &&
									this._flowManager.writeMessage(n, { compressed: !1, opcode: 10 })
					}
			}
		}
		async drain() {
			this.traceSocketEvent("webSocketNodeSocketDrainBegin"),
				this._flowManager.isProcessingWriteQueue() &&
					(await Ee.toPromise(this._flowManager.onDidFinishProcessingWriteQueue)),
				await this.socket.drain(),
				this.traceSocketEvent("webSocketNodeSocketDrainEnd")
		}
	},
	A0 = class extends $ {
		constructor(t, n, r, i, s, a) {
			super()
			this._tracer = t
			this._onData = s
			this._writeFn = a
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._writeQueue = []
			this._readQueue = []
			this._onDidFinishProcessingReadQueue = this._register(new E())
			this.onDidFinishProcessingReadQueue = this._onDidFinishProcessingReadQueue.event
			this._onDidFinishProcessingWriteQueue = this._register(new E())
			this.onDidFinishProcessingWriteQueue = this._onDidFinishProcessingWriteQueue.event
			this._isProcessingWriteQueue = !1
			this._isProcessingReadQueue = !1
			n
				? ((this._zlibInflateStream = this._register(new O0(this._tracer, i, r, { windowBits: 15 }))),
					(this._zlibDeflateStream = this._register(new L0(this._tracer, { windowBits: 15 }))),
					this._register(this._zlibInflateStream.onError((l) => this._onError.fire(l))),
					this._register(this._zlibDeflateStream.onError((l) => this._onError.fire(l))))
				: ((this._zlibInflateStream = null), (this._zlibDeflateStream = null))
		}
		get permessageDeflate() {
			return !!(this._zlibInflateStream && this._zlibDeflateStream)
		}
		get recordedInflateBytes() {
			return this._zlibInflateStream ? this._zlibInflateStream.recordedInflateBytes : z.alloc(0)
		}
		writeMessage(t, n) {
			this._writeQueue.push({ data: t, options: n }), this._processWriteQueue()
		}
		async _processWriteQueue() {
			if (!this._isProcessingWriteQueue) {
				for (this._isProcessingWriteQueue = !0; this._writeQueue.length > 0; ) {
					let { data: t, options: n } = this._writeQueue.shift()
					if (this._zlibDeflateStream && n.compressed) {
						let r = await this._deflateMessage(this._zlibDeflateStream, t)
						this._writeFn(r, n)
					} else this._writeFn(t, { ...n, compressed: !1 })
				}
				;(this._isProcessingWriteQueue = !1), this._onDidFinishProcessingWriteQueue.fire()
			}
		}
		isProcessingWriteQueue() {
			return this._isProcessingWriteQueue
		}
		_deflateMessage(t, n) {
			return new Promise((r, i) => {
				t.write(n), t.flush((s) => r(s))
			})
		}
		acceptFrame(t, n, r) {
			this._readQueue.push({ data: t, isCompressed: n, isLastFrameOfMessage: r }), this._processReadQueue()
		}
		async _processReadQueue() {
			if (!this._isProcessingReadQueue) {
				for (this._isProcessingReadQueue = !0; this._readQueue.length > 0; ) {
					let t = this._readQueue.shift()
					if (this._zlibInflateStream && t.isCompressed) {
						let n = await this._inflateFrame(this._zlibInflateStream, t.data, t.isLastFrameOfMessage)
						this._onData.fire(n)
					} else this._onData.fire(t.data)
				}
				;(this._isProcessingReadQueue = !1), this._onDidFinishProcessingReadQueue.fire()
			}
		}
		isProcessingReadQueue() {
			return this._isProcessingReadQueue
		}
		_inflateFrame(t, n, r) {
			return new Promise((i, s) => {
				t.write(n), r && t.write(z.fromByteArray([0, 0, 255, 255])), t.flush((a) => i(a))
			})
		}
	},
	O0 = class extends $ {
		constructor(t, n, r, i) {
			super()
			this._tracer = t
			this._recordInflateBytes = n
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._recordedInflateBytes = []
			this._pendingInflateData = []
			;(this._zlibInflate = B6(i)),
				this._zlibInflate.on("error", (s) => {
					this._tracer.traceSocketEvent("zlibInflateError", { message: s?.message, code: s?.code }),
						this._onError.fire(s)
				}),
				this._zlibInflate.on("data", (s) => {
					this._tracer.traceSocketEvent("zlibInflateData", s), this._pendingInflateData.push(z.wrap(s))
				}),
				r &&
					(this._tracer.traceSocketEvent("zlibInflateInitialWrite", r.buffer),
					this._zlibInflate.write(r.buffer),
					this._zlibInflate.flush(() => {
						this._tracer.traceSocketEvent("zlibInflateInitialFlushFired"),
							(this._pendingInflateData.length = 0)
					}))
		}
		get recordedInflateBytes() {
			return this._recordInflateBytes ? z.concat(this._recordedInflateBytes) : z.alloc(0)
		}
		write(t) {
			this._recordInflateBytes && this._recordedInflateBytes.push(t.clone()),
				this._tracer.traceSocketEvent("zlibInflateWrite", t),
				this._zlibInflate.write(t.buffer)
		}
		flush(t) {
			this._zlibInflate.flush(() => {
				this._tracer.traceSocketEvent("zlibInflateFlushFired")
				let n = z.concat(this._pendingInflateData)
				;(this._pendingInflateData.length = 0), t(n)
			})
		}
	},
	L0 = class extends $ {
		constructor(t, n) {
			super()
			this._tracer = t
			this._onError = this._register(new E())
			this.onError = this._onError.event
			this._pendingDeflateData = []
			;(this._zlibDeflate = V6({ windowBits: 15 })),
				this._zlibDeflate.on("error", (r) => {
					this._tracer.traceSocketEvent("zlibDeflateError", { message: r?.message, code: r?.code }),
						this._onError.fire(r)
				}),
				this._zlibDeflate.on("data", (r) => {
					this._tracer.traceSocketEvent("zlibDeflateData", r), this._pendingDeflateData.push(z.wrap(r))
				})
		}
		write(t) {
			this._tracer.traceSocketEvent("zlibDeflateWrite", t.buffer), this._zlibDeflate.write(t.buffer)
		}
		flush(t) {
			this._zlibDeflate.flush(2, () => {
				this._tracer.traceSocketEvent("zlibDeflateFlushFired")
				let n = z.concat(this._pendingDeflateData)
				;(this._pendingDeflateData.length = 0), (n = n.slice(0, n.byteLength - 4)), t(n)
			})
		}
	}
function z6(o, e) {
	if (e === 0) return
	let t = o.byteLength >>> 2
	for (let l = 0; l < t; l++) {
		let d = o.readUInt32BE(l * 4)
		o.writeUInt32BE(d ^ e, l * 4)
	}
	let n = t * 4,
		r = o.byteLength - n,
		i = (e >>> 24) & 255,
		s = (e >>> 16) & 255,
		a = (e >>> 8) & 255
	r >= 1 && o.writeUInt8(o.readUInt8(n) ^ i, n),
		r >= 2 && o.writeUInt8(o.readUInt8(n + 1) ^ s, n + 1),
		r >= 3 && o.writeUInt8(o.readUInt8(n + 2) ^ a, n + 2)
}
var gH = process.env.XDG_RUNTIME_DIR,
	q6 = { 2: 107, 1: 103 }
function LU() {
	let o = He()
	if (process.platform === "win32") return `\\\\.\\pipe\\vscode-ipc-${o}-sock`
	let e = process.platform !== "darwin" && gH ? gH : W6(),
		t = Fe(e, `vscode-ipc-${o}.sock`)
	return K6(t), t
}
function K6(o) {
	let e = q6[Ev]
	typeof e == "number" &&
		o.length >= e &&
		console.warn(`WARNING: IPC handle "${o}" is longer than ${e} chars, try a shorter --user-data-dir`)
}
import * as En from "fs"
import { promisify as ea } from "util"
var M0 = class {
		constructor() {
			this.contentOptions = {}
		}
		setHtml(e) {
			console.log("[SimpleWebview] Set HTML:", e)
		}
		setTitle(e) {
			console.log("[SimpleWebview] Set title:", e)
		}
		postMessage(e, t) {
			return console.log("[SimpleWebview] Post message:", e), Promise.resolve(!0)
		}
		focus() {
			console.log("[SimpleWebview] Focus")
		}
		dispose() {
			console.log("[SimpleWebview] Dispose")
		}
	},
	KT = class {
		constructor(e) {
			this.rpcProtocol = e
			this._webviews = new Map()
			this._proxy = this.rpcProtocol.getProxy(le.ExtHostWebviewViews)
		}
		$registerWebviewViewProvider(e, t, n) {
			console.log("Register webview view provider:", { extension: e, viewType: t, options: n })
			let r = new M0()
			this._webviews.set(t, r)
			let i = `webview-${t}-${Date.now()}`
			this._proxy.$resolveWebviewView(i, t, void 0, void 0, De.None)
		}
		$unregisterWebviewViewProvider(e) {
			console.log("Unregister webview view provider:", e)
			let t = this._webviews.get(e)
			t && (t.dispose(), this._webviews.delete(e))
		}
		$setWebviewViewTitle(e, t) {
			console.log("Set webview view title:", { handle: e, value: t })
			let n = this._webviews.get(e)
			n && n.setTitle(t || "")
		}
		$setWebviewViewDescription(e, t) {
			console.log("Set webview view description:", { handle: e, value: t })
		}
		$setWebviewViewBadge(e, t) {
			console.log("Set webview view badge:", { handle: e, badge: t })
		}
		$show(e, t) {
			console.log("Show webview view:", { handle: e, preserveFocus: t })
			let n = this._webviews.get(e)
			n && n.focus()
		}
		$setHtml(e, t) {
			console.log("Set webview HTML:", { handle: e, value: t })
			let n = this._webviews.get(e)
			n && n.setHtml(t)
		}
		$setOptions(e, t) {
			console.log("Set webview panel options:", { handle: e, options: t })
			let n = this._webviews.get(e)
			if (n) {
				let r = {
					allowScripts: t.enableScripts,
					allowForms: t.enableForms,
					localResourceRoots: t.localResourceRoots?.map((i) => b.revive(i)),
					portMapping: t.portMapping,
				}
				n.contentOptions = r
			}
		}
		$postMessage(e, t, ...n) {
			console.log("Post message to webview:", { handle: e, value: t, buffers: n })
			let r = this._webviews.get(e)
			return r ? r.postMessage(t, n) : Promise.resolve(!1)
		}
		dispose() {
			console.log("Dispose WebViewManager")
			for (let e of this._webviews.values()) e.dispose()
			this._webviews.clear()
		}
	}
var j6 = ea(En.stat),
	G6 = ea(En.readdir),
	Q6 = ea(En.readFile),
	J6 = ea(En.writeFile),
	X6 = ea(En.rename),
	Y6 = ea(En.copyFile),
	F0 = ea(En.unlink),
	Z6 = ea(En.lstat),
	e3 = ea(En.mkdir),
	N0 = class {
		logIncoming(e, t, n, r, i) {
			r != "ack" && console.log(`[RPC] ExtHost: ${r}`)
		}
		logOutgoing(e, t, n, r, i) {
			r == "ack" || r == "reply:" || console.log(`[RPC] Main: ${r}`)
		}
	},
	jT = class {
		constructor(e, t) {
			this.protocol = e
			;(this.logger = new N0()),
				(this.rpcProtocol = new Uc(this.protocol, this.logger)),
				(this.extensionManager = t),
				this.setupDefaultProtocols(),
				this.setupExtensionRequiredProtocols(),
				this.setupRooCodeRequiredProtocols()
		}
		startInitialize() {
			this.rpcProtocol.getProxy(le.ExtHostConfiguration).$initializeConfiguration({
				defaults: xr.createEmptyModel(new ds()),
				policy: xr.createEmptyModel(new ds()),
				application: xr.createEmptyModel(new ds()),
				userLocal: xr.createEmptyModel(new ds()),
				userRemote: xr.createEmptyModel(new ds()),
				workspace: xr.createEmptyModel(new ds()),
				folders: [],
				configurationScopes: [],
			}),
				this.rpcProtocol.getProxy(le.ExtHostWorkspace).$initializeWorkspace(null, !0)
		}
		setupDefaultProtocols() {
			if (!this.rpcProtocol) throw new Error("RPCProtocol not initialized")
			this.rpcProtocol.set(M.MainThreadErrors, {
				dispose() {},
				$onUnexpectedError(e) {
					e && e.$isError && (e = tf(e)), console.error("Unexpected error:", e)
				},
			}),
				this.rpcProtocol.set(M.MainThreadConsole, {
					dispose() {},
					$logExtensionHostMessage(e) {
						let t = this.parseRemoteConsoleLog(e)
						switch (e.severity) {
							case "log":
							case "info":
								console.log("[Extension Host]", ...t)
								break
							case "warn":
								console.warn("[Extension Host]", ...t)
								break
							case "error":
								console.error("[Extension Host]", ...t)
								break
							case "debug":
								console.debug("[Extension Host]", ...t)
								break
							default:
								console.log("[Extension Host]", ...t)
						}
					},
					parseRemoteConsoleLog(e) {
						let t = []
						try {
							let n = JSON.parse(e.arguments)
							t.push(...n)
						} catch {
							t.push("Unable to log remote console arguments", e.arguments)
						}
						return t
					},
				}),
				this.rpcProtocol.set(M.MainThreadLogger, {
					$log(e, t) {
						console.log("Logger message:", { file: e, messages: t })
					},
					$flush(e) {
						console.log("Flush logger:", e)
					},
					$createLogger(e, t) {
						return console.log("Create logger:", { file: e, options: t }), Promise.resolve()
					},
					$registerLogger(e) {
						return console.log("Register logger (id: ", e.id, ", name: ", e.name, ")"), Promise.resolve()
					},
					$deregisterLogger(e) {
						return console.log("Deregister logger:", e), Promise.resolve()
					},
					$setVisibility(e, t) {
						return console.log("Set logger visibility:", { resource: e, visible: t }), Promise.resolve()
					},
				}),
				this.rpcProtocol.set(M.MainThreadCommands, {
					$registerCommand(e) {
						console.log("Register command:", e)
					},
					$unregisterCommand(e) {
						console.log("Unregister command:", e)
					},
					$executeCommand(e, ...t) {
						return console.log("Execute command:", e, t), Promise.resolve(null)
					},
					$fireCommandActivationEvent(e) {
						console.log("Fire command activation event:", e)
					},
					$getCommands() {
						return Promise.resolve([])
					},
					dispose() {
						console.log("Dispose MainThreadCommands")
					},
				}),
				this.rpcProtocol.set(M.MainThreadTerminalService, {
					$registerProcessSupport(e) {
						console.log("Register process support:", e)
					},
					$createTerminal(e, t) {
						return console.log("Create terminal:", { extHostTerminalId: e, config: t }), Promise.resolve()
					},
					$dispose(e) {
						console.log("Dispose terminal:", e)
					},
					$hide(e) {
						console.log("Hide terminal:", e)
					},
					$sendText(e, t, n) {
						console.log("Send text to terminal:", { id: e, text: t, shouldExecute: n })
					},
					$show(e, t) {
						console.log("Show terminal:", { id: e, preserveFocus: t })
					},
					$registerProfileProvider(e, t) {
						console.log("Register profile provider:", { id: e, extensionIdentifier: t })
					},
					$unregisterProfileProvider(e) {
						console.log("Unregister profile provider:", e)
					},
					$registerCompletionProvider(e, t, ...n) {
						console.log("Register completion provider:", {
							id: e,
							extensionIdentifier: t,
							triggerCharacters: n,
						})
					},
					$unregisterCompletionProvider(e) {
						console.log("Unregister completion provider:", e)
					},
					$registerQuickFixProvider(e, t) {
						console.log("Register quick fix provider:", { id: e, extensionIdentifier: t })
					},
					$unregisterQuickFixProvider(e) {
						console.log("Unregister quick fix provider:", e)
					},
					$setEnvironmentVariableCollection(e, t, n, r) {
						console.log("Set environment variable collection:", {
							extensionIdentifier: e,
							persistent: t,
							collection: n,
							descriptionMap: r,
						})
					},
					$startSendingDataEvents() {
						console.log("Start sending data events")
					},
					$stopSendingDataEvents() {
						console.log("Stop sending data events")
					},
					$startSendingCommandEvents() {
						console.log("Start sending command events")
					},
					$stopSendingCommandEvents() {
						console.log("Stop sending command events")
					},
					$startLinkProvider() {
						console.log("Start link provider")
					},
					$stopLinkProvider() {
						console.log("Stop link provider")
					},
					$sendProcessData(e, t) {
						console.log("Send process data:", { terminalId: e, data: t })
					},
					$sendProcessReady(e, t, n, r) {
						console.log("Send process ready:", { terminalId: e, pid: t, cwd: n, windowsPty: r })
					},
					$sendProcessProperty(e, t) {
						console.log("Send process property:", { terminalId: e, property: t })
					},
					$sendProcessExit(e, t) {
						console.log("Send process exit:", { terminalId: e, exitCode: t })
					},
					dispose() {
						console.log("Dispose MainThreadTerminalService")
					},
				}),
				this.rpcProtocol.set(M.MainThreadWindow, {
					$getInitialState() {
						return console.log("Get initial state"), Promise.resolve({ isFocused: !1, isActive: !1 })
					},
					$openUri(e, t, n) {
						return console.log("Open URI:", { uri: e, uriString: t, options: n }), Promise.resolve(!0)
					},
					$asExternalUri(e, t) {
						return console.log("As external URI:", { uri: e, options: t }), Promise.resolve(e)
					},
					dispose() {
						console.log("Dispose MainThreadWindow")
					},
				}),
				this.rpcProtocol.set(M.MainThreadSearch, {
					$registerFileSearchProvider(e, t) {
						console.log("Register file search provider:", { handle: e, scheme: t })
					},
					$registerAITextSearchProvider(e, t) {
						console.log("Register AI text search provider:", { handle: e, scheme: t })
					},
					$registerTextSearchProvider(e, t) {
						console.log("Register text search provider:", { handle: e, scheme: t })
					},
					$unregisterProvider(e) {
						console.log("Unregister provider:", e)
					},
					$handleFileMatch(e, t, n) {
						console.log("Handle file match:", { handle: e, session: t, data: n })
					},
					$handleTextMatch(e, t, n) {
						console.log("Handle text match:", { handle: e, session: t, data: n })
					},
					$handleTelemetry(e, t) {
						console.log("Handle telemetry:", { eventName: e, data: t })
					},
					dispose() {
						console.log("Dispose MainThreadSearch")
					},
				}),
				this.rpcProtocol.set(M.MainThreadTask, {
					$createTaskId(e) {
						return console.log("Create task ID:", e), Promise.resolve("task-id")
					},
					$registerTaskProvider(e, t) {
						return console.log("Register task provider:", { handle: e, type: t }), Promise.resolve()
					},
					$unregisterTaskProvider(e) {
						return console.log("Unregister task provider:", e), Promise.resolve()
					},
					$fetchTasks(e) {
						return console.log("Fetch tasks:", e), Promise.resolve([])
					},
					$getTaskExecution(e) {
						return console.log("Get task execution:", e), Promise.resolve(null)
					},
					$executeTask(e) {
						return console.log("Execute task:", e), Promise.resolve(null)
					},
					$terminateTask(e) {
						return console.log("Terminate task:", e), Promise.resolve()
					},
					$registerTaskSystem(e, t) {
						console.log("Register task system:", { scheme: e, info: t })
					},
					$customExecutionComplete(e, t) {
						return console.log("Custom execution complete:", { id: e, result: t }), Promise.resolve()
					},
					$registerSupportedExecutions(e, t, n) {
						return (
							console.log("Register supported executions:", { custom: e, shell: t, process: n }),
							Promise.resolve()
						)
					},
					dispose() {
						console.log("Dispose MainThreadTask")
					},
				}),
				this.rpcProtocol.set(M.MainThreadConfiguration, {
					$updateConfigurationOption(e, t, n, r, i) {
						return (
							console.log("Update configuration option:", {
								target: e,
								key: t,
								value: n,
								overrides: r,
								scopeToLanguage: i,
							}),
							Promise.resolve()
						)
					},
					$removeConfigurationOption(e, t, n, r) {
						return (
							console.log("Remove configuration option:", {
								target: e,
								key: t,
								overrides: n,
								scopeToLanguage: r,
							}),
							Promise.resolve()
						)
					},
					dispose() {
						console.log("Dispose MainThreadConfiguration")
					},
				}),
				this.rpcProtocol.set(M.MainThreadFileSystem, {
					async $registerFileSystemProvider(e, t, n, r) {
						console.log("Register file system provider:", {
							handle: e,
							scheme: t,
							capabilities: n,
							readonlyMessage: r,
						})
					},
					$unregisterProvider(e) {
						console.log("Unregister provider:", e)
					},
					$onFileSystemChange(e, t) {
						console.log("File system change:", { handle: e, resource: t })
					},
					async $stat(e) {
						console.log("Stat:", e)
						try {
							let t = this.uriToPath(e),
								n = await j6(t)
							return {
								type: this.getFileType(n),
								ctime: n.birthtimeMs,
								mtime: n.mtimeMs,
								size: n.size,
								permissions: n.mode & 292 ? 1 : void 0,
							}
						} catch (t) {
							throw (console.error("Error in $stat:", t), this.handleFileSystemError(t))
						}
					},
					async $readdir(e) {
						console.log("Read directory:", e)
						try {
							let t = this.uriToPath(e)
							return (await G6(t, { withFileTypes: !0 })).map((r) => {
								let i = 0
								return (
									r.isFile() ? (i = 1) : r.isDirectory() && (i = 2),
									r.isSymbolicLink() && (i |= 64),
									[r.name, i]
								)
							})
						} catch (t) {
							throw (console.error("Error in $readdir:", t), this.handleFileSystemError(t))
						}
					},
					async $readFile(e) {
						console.log("Read file:", e)
						try {
							let t = this.uriToPath(e),
								n = await Q6(t)
							return z.wrap(n)
						} catch (t) {
							throw (console.error("Error in $readFile:", t), this.handleFileSystemError(t))
						}
					},
					async $writeFile(e, t) {
						console.log("Write file:", { resource: e, content: t })
						try {
							let n = this.uriToPath(e),
								r = t instanceof z ? t.buffer : t
							await J6(n, r)
						} catch (n) {
							throw (console.error("Error in $writeFile:", n), this.handleFileSystemError(n))
						}
					},
					async $rename(e, t, n) {
						console.log("Rename:", { resource: e, target: t, opts: n })
						try {
							let r = this.uriToPath(e),
								i = this.uriToPath(t)
							if (n.overwrite)
								try {
									await F0(i)
								} catch {}
							await X6(r, i)
						} catch (r) {
							throw (console.error("Error in $rename:", r), this.handleFileSystemError(r))
						}
					},
					async $copy(e, t, n) {
						console.log("Copy:", { resource: e, target: t, opts: n })
						try {
							let r = this.uriToPath(e),
								i = this.uriToPath(t)
							if (n.overwrite)
								try {
									await F0(i)
								} catch {}
							await Y6(r, i)
						} catch (r) {
							throw (console.error("Error in $copy:", r), this.handleFileSystemError(r))
						}
					},
					async $mkdir(e) {
						console.log("Make directory:", e)
						try {
							let t = this.uriToPath(e)
							await e3(t, { recursive: !0 })
						} catch (t) {
							throw (console.error("Error in $mkdir:", t), this.handleFileSystemError(t))
						}
					},
					async $delete(e, t) {
						console.log("Delete:", { resource: e, opts: t })
						try {
							let n = this.uriToPath(e)
							;(await Z6(n)).isDirectory() ? await En.promises.rm(n, { recursive: !0 }) : await F0(n)
						} catch (n) {
							throw (console.error("Error in $delete:", n), this.handleFileSystemError(n))
						}
					},
					async $ensureActivation(e) {
						return console.log("Ensure activation:", e), Promise.resolve()
					},
					dispose() {
						console.log("Dispose MainThreadFileSystem")
					},
					uriToPath(e) {
						if (e.scheme !== "file") throw new Error(`Unsupported URI scheme: ${e.scheme}`)
						let t = e.path || ""
						return process.platform === "win32" && t.startsWith("/") && (t = t.substring(1)), t
					},
					getFileType(e) {
						let t = 0
						return e.isFile() ? (t = 1) : e.isDirectory() && (t = 2), e.isSymbolicLink() && (t |= 64), t
					},
					handleFileSystemError(e) {
						if (e.code === "ENOENT") {
							let t = new Error(e.message)
							return (t.name = "EntryNotFound"), t
						} else if (e.code === "EACCES" || e.code === "EPERM") {
							let t = new Error(e.message)
							return (t.name = "NoPermissions"), t
						} else if (e.code === "EEXIST") {
							let t = new Error(e.message)
							return (t.name = "EntryExists"), t
						} else if (e.code === "EISDIR") {
							let t = new Error(e.message)
							return (t.name = "EntryIsADirectory"), t
						} else if (e.code === "ENOTDIR") {
							let t = new Error(e.message)
							return (t.name = "EntryNotADirectory"), t
						}
						return e
					},
				}),
				this.rpcProtocol.set(M.MainThreadLanguageModelTools, {
					$getTools() {
						return console.log("Getting language model tools"), Promise.resolve([])
					},
					$invokeTool(e, t) {
						return console.log("Invoking language model tool:", e), Promise.resolve({})
					},
					$countTokensForInvocation(e, t, n) {
						return (
							console.log("Counting tokens for invocation:", { callId: e, input: t }), Promise.resolve(0)
						)
					},
					$registerTool(e) {
						console.log("Registering language model tool:", e)
					},
					$unregisterTool(e) {
						console.log("Unregistering language model tool:", e)
					},
					dispose() {
						console.log("Disposing MainThreadLanguageModelTools")
					},
				})
		}
		setupExtensionRequiredProtocols() {
			this.rpcProtocol &&
				(this.rpcProtocol.set(M.MainThreadExtensionService, {
					$getExtension: async (e) => (
						console.log(`Getting extension: ${e}`), this.extensionManager.getExtensionDescription(e)
					),
					$activateExtension: async (e, t) => {
						console.log(`Activating extension ${e.value} with reason:`, t),
							await this.extensionManager.activateExtension(e.value, this.rpcProtocol)
					},
					$onWillActivateExtension: async (e) => {
						console.log(`Extension ${e.value} will be activated`)
					},
					$onDidActivateExtension: (e, t, n, r, i) => {
						console.log(`Extension ${e.value} was activated with reason:`, i)
					},
					$onExtensionActivationError: async (e, t, n) => {
						console.error(`Extension ${e.value} activation error:`, t)
					},
					$onExtensionRuntimeError: (e, t) => {
						console.error(`Extension ${e.value} runtime error:`, t)
					},
					$setPerformanceMarks: async (e) => {
						console.log("Setting performance marks:", e)
					},
					$asBrowserUri: async (e) => (console.log("Converting to browser URI:", e), e),
					dispose: () => {
						console.log("Disposing MainThreadExtensionService")
					},
				}),
				this.rpcProtocol.set(M.MainThreadTelemetry, {
					$publicLog(e, t) {
						console.log(`[Telemetry] ${e}`, t)
					},
					$publicLog2(e, t) {
						console.log(`[Telemetry] ${e}`, t)
					},
					dispose() {
						console.log("Disposing MainThreadTelemetry")
					},
				}),
				this.rpcProtocol.set(M.MainThreadDebugService, {
					$registerDebugTypes(e) {
						console.log("Register debug types:", e)
					},
					$sessionCached(e) {
						console.log("Session cached:", e)
					},
					$acceptDAMessage(e, t) {
						console.log("Accept debug adapter message:", { handle: e, message: t })
					},
					$acceptDAError(e, t, n, r) {
						console.error("Debug adapter error:", { handle: e, name: t, message: n, stack: r })
					},
					$acceptDAExit(e, t, n) {
						console.log("Debug adapter exit:", { handle: e, code: t, signal: n })
					},
					async $registerDebugConfigurationProvider(e, t, n, r, i, s) {
						console.log("Register debug configuration provider:", {
							type: e,
							triggerKind: t,
							hasProvideMethod: n,
							hasResolveMethod: r,
							hasResolve2Method: i,
							handle: s,
						})
					},
					async $registerDebugAdapterDescriptorFactory(e, t) {
						console.log("Register debug adapter descriptor factory:", { type: e, handle: t })
					},
					$unregisterDebugConfigurationProvider(e) {
						console.log("Unregister debug configuration provider:", e)
					},
					$unregisterDebugAdapterDescriptorFactory(e) {
						console.log("Unregister debug adapter descriptor factory:", e)
					},
					async $startDebugging(e, t, n) {
						return console.log("Start debugging:", { folder: e, nameOrConfig: t, options: n }), !0
					},
					async $stopDebugging(e) {
						console.log("Stop debugging:", e)
					},
					$setDebugSessionName(e, t) {
						console.log("Set debug session name:", { id: e, name: t })
					},
					async $customDebugAdapterRequest(e, t, n) {
						return console.log("Custom debug adapter request:", { id: e, command: t, args: n }), null
					},
					async $getDebugProtocolBreakpoint(e, t) {
						console.log("Get debug protocol breakpoint:", { id: e, breakpoinId: t })
					},
					$appendDebugConsole(e) {
						console.log("Debug console:", e)
					},
					async $registerBreakpoints(e) {
						console.log("Register breakpoints:", e)
					},
					async $unregisterBreakpoints(e, t, n) {
						console.log("Unregister breakpoints:", {
							breakpointIds: e,
							functionBreakpointIds: t,
							dataBreakpointIds: n,
						})
					},
					$registerDebugVisualizer(e, t) {
						console.log("Register debug visualizer:", { extensionId: e, id: t })
					},
					$unregisterDebugVisualizer(e, t) {
						console.log("Unregister debug visualizer:", { extensionId: e, id: t })
					},
					$registerDebugVisualizerTree(e, t) {
						console.log("Register debug visualizer tree:", { treeId: e, canEdit: t })
					},
					$unregisterDebugVisualizerTree(e) {
						console.log("Unregister debug visualizer tree:", e)
					},
					$registerCallHierarchyProvider(e, t) {
						console.log("Register call hierarchy provider:", { handle: e, supportsResolve: t })
					},
					dispose() {
						console.log("Disposing MainThreadDebugService")
					},
				}))
		}
		setupRooCodeRequiredProtocols() {
			if (!this.rpcProtocol) return
			this.rpcProtocol.set(M.MainThreadTextEditors, {
				$tryShowTextDocument(t, n) {
					return console.log("Try show text document:", { resource: t, options: n }), Promise.resolve(void 0)
				},
				$tryShowEditor(t, n) {
					return console.log("Try show editor:", { id: t, position: n }), Promise.resolve()
				},
				$tryHideEditor(t) {
					return console.log("Try hide editor:", t), Promise.resolve()
				},
				$trySetSelections(t, n) {
					return console.log("Try set selections:", { id: t, selections: n }), Promise.resolve()
				},
				$tryRevealRange(t, n, r) {
					return console.log("Try reveal range:", { id: t, range: n, revealType: r }), Promise.resolve()
				},
				$trySetOptions(t, n) {
					return console.log("Try set options:", { id: t, options: n }), Promise.resolve()
				},
				$tryApplyEdits(t, n, r, i) {
					return (
						console.log("Try apply edits:", { id: t, modelVersionId: n, edits: r, opts: i }),
						Promise.resolve(!0)
					)
				},
				$registerTextEditorDecorationType(t, n, r) {
					console.log("Register text editor decoration type:", { extensionId: t, key: n, options: r })
				},
				$removeTextEditorDecorationType(t) {
					console.log("Remove text editor decoration type:", t)
				},
				$trySetDecorations(t, n, r) {
					return console.log("Try set decorations:", { id: t, key: n, ranges: r }), Promise.resolve()
				},
				$trySetDecorationsFast(t, n, r) {
					return console.log("Try set decorations fast:", { id: t, key: n, ranges: r }), Promise.resolve()
				},
				$tryInsertSnippet(t, n, r, i) {
					return (
						console.log("Try insert snippet:", { id: t, snippet: n, location: r, options: i }),
						Promise.resolve(!0)
					)
				},
				$getDiffInformation(t) {
					return console.log("Get diff information:", t), Promise.resolve(null)
				},
				dispose() {
					console.log("Dispose MainThreadTextEditors")
				},
			}),
				this.rpcProtocol.set(M.MainThreadStorage, {
					$initializeExtensionStorage(t, n) {
						return (
							console.log("Initialize extension storage:", { shared: t, extensionId: n }),
							Promise.resolve(void 0)
						)
					},
					$setValue(t, n, r) {
						return console.log("Set value:", { shared: t, extensionId: n, value: r }), Promise.resolve()
					},
					$registerExtensionStorageKeysToSync(t, n) {
						console.log("Register extension storage keys to sync:", { extension: t, keys: n })
					},
					dispose() {
						console.log("Dispose MainThreadStorage")
					},
				}),
				this.rpcProtocol.set(M.MainThreadOutputService, {
					$register(t, n, r, i) {
						return (
							console.log("Register output channel:", {
								label: t,
								file: n,
								languageId: r,
								extensionId: i,
							}),
							Promise.resolve(`output-${i}-${t}`)
						)
					},
					$update(t, n, r) {
						return (
							console.log("Update output channel:", { channelId: t, mode: n, till: r }), Promise.resolve()
						)
					},
					$reveal(t, n) {
						return (
							console.log("Reveal output channel:", { channelId: t, preserveFocus: n }), Promise.resolve()
						)
					},
					$close(t) {
						return console.log("Close output channel:", t), Promise.resolve()
					},
					$dispose(t) {
						return console.log("Dispose output channel:", t), Promise.resolve()
					},
					dispose() {
						console.log("Dispose MainThreadOutputService")
					},
				})
			let e = new KT(this.rpcProtocol)
			this.rpcProtocol.set(M.MainThreadWebviewViews, e),
				this.rpcProtocol.set(M.MainThreadDocumentContentProviders, {
					$registerTextContentProvider(t, n) {
						console.log("Register text content provider:", { handle: t, scheme: n })
					},
					$unregisterTextContentProvider(t) {
						console.log("Unregister text content provider:", t)
					},
					$onVirtualDocumentChange(t, n) {
						return console.log("Virtual document change:", { uri: t, value: n }), Promise.resolve()
					},
					dispose() {
						console.log("Dispose MainThreadDocumentContentProviders")
					},
				}),
				this.rpcProtocol.set(M.MainThreadUrls, {
					$registerUriHandler(t, n, r) {
						return (
							console.log("Register URI handler:", {
								handle: t,
								extensionId: n,
								extensionDisplayName: r,
							}),
							Promise.resolve()
						)
					},
					$unregisterUriHandler(t) {
						return console.log("Unregister URI handler:", t), Promise.resolve()
					},
					$createAppUri(t) {
						return console.log("Create app URI:", t), Promise.resolve(t)
					},
					dispose() {
						console.log("Dispose MainThreadUrls")
					},
				}),
				this.rpcProtocol.set(M.MainThreadWebviews, e)
		}
		getRPCProtocol() {
			return this.rpcProtocol
		}
	}
import * as hH from "fs"
import * as QT from "path"
var GT = class {
	constructor() {
		this.extensionDescriptions = new Map()
	}
	parseExtensionDescription(e) {
		let t = QT.join(e, "extension.package.json"),
			n = JSON.parse(hH.readFileSync(t, "utf8"))
		return {
			identifier: new Ce(n.name),
			name: n.name,
			displayName: n.displayName,
			description: n.description,
			version: n.version,
			publisher: n.publisher,
			main: "./extension.cjs",
			activationEvents: n.activationEvents || ["onStartupFinished"],
			extensionLocation: b.file(QT.resolve(e)),
			targetPlatform: "universal",
			isBuiltin: !1,
			isUserBuiltin: !1,
			isUnderDevelopment: !1,
			engines: n.engines || { vscode: "^1.0.0" },
			preRelease: !1,
			capabilities: {},
			extensionDependencies: n.extensionDependencies || [],
		}
	}
	getAllExtensionDescriptions() {
		return Array.from(this.extensionDescriptions.values())
	}
	getExtensionDescription(e) {
		return this.extensionDescriptions.get(e)
	}
	registerExtension(e) {
		let t = this.parseExtensionDescription(e)
		return this.extensionDescriptions.set(t.identifier.value, t), t
	}
	async activateExtension(e, t) {
		let n = this.extensionDescriptions.get(e)
		if (!n) throw new Error(`Extension ${e} is not registered`)
		try {
			await t
				.getProxy(le.ExtHostExtensionService)
				.$activate(n.identifier, { startup: !0, extensionId: n.identifier, activationEvent: "api" })
		} catch (r) {
			throw (console.error(`Failed to activate extension ${e}:`, r), r)
		}
	}
}
var o3 = r3(import.meta.url),
	nv = ic.dirname(o3),
	Km = new GT(),
	i3 = Km.registerExtension("roo-code").identifier,
	JT,
	jm = null,
	U0 = null,
	rv = vH.createServer((o) => {
		console.log("Someone connected to main server"), o.setNoDelay(!0)
		let e = new ri(o),
			t = e.onClose((n) => {
				console.log("NodeSocket close event received"),
					n?.type === 0 &&
						(n.hadError
							? console.error("Socket closed with error:", n.error)
							: console.log("Socket closed normally")),
					t.dispose()
			})
		;(jm = new Ys({ socket: e, initialChunk: null })),
			jm.onMessage((n) => {
				if (eh(n, 1)) {
					console.log("Extension host is ready")
					let r = {
						commit: "development",
						version: "1.0.0",
						quality: void 0,
						parentPid: process.pid,
						environment: {
							isExtensionDevelopmentDebug: !1,
							appName: "VSCodeAPIHook",
							appHost: "node",
							appLanguage: "en",
							appUriScheme: "vscode",
							appRoot: b.file(nv),
							globalStorageHome: b.file(ic.join(nv, "globalStorage")),
							workspaceStorageHome: b.file(ic.join(nv, "workspaceStorage")),
							extensionDevelopmentLocationURI: void 0,
							extensionTestsLocationURI: void 0,
							useHostProxy: !1,
							skipWorkspaceStorageLock: !1,
							isExtensionTelemetryLoggingOnly: !1,
						},
						workspace: {
							id: "development-workspace",
							name: "Development Workspace",
							transient: !1,
							configuration: null,
							isUntitled: !1,
						},
						remote: { authority: void 0, connectionData: null, isRemote: !1 },
						extensions: {
							versionId: 1,
							allExtensions: Km.getAllExtensionDescriptions(),
							myExtensions: Km.getAllExtensionDescriptions().map((i) => i.identifier),
							activationEvents: Km.getAllExtensionDescriptions().reduce(
								(i, s) => (s.activationEvents && (i[s.identifier.value] = s.activationEvents), i),
								{},
							),
						},
						telemetryInfo: {
							sessionId: "development-session",
							machineId: "development-machine",
							sqmId: "",
							devDeviceId: "",
							firstSessionDate: new Date().toISOString(),
							msftInternal: !1,
						},
						logLevel: 0,
						loggers: [],
						logsLocation: b.file(ic.join(nv, "logs")),
						autoStart: !0,
						consoleForward: { includeStack: !1, logNative: !1 },
						uiKind: 1,
					}
					jm?.send(z.fromString(JSON.stringify(r)))
				} else if (eh(n, 0)) {
					console.log("Extension host initialized"), (U0 = new jT(jm, Km)), U0.startInitialize()
					let r = U0.getRPCProtocol()
					r
						? Km.activateExtension(i3.value, r).catch((i) => {
								console.error("Failed to load rooCode plugin:", i)
							})
						: console.error("Failed to get RPCProtocol from RPCManager")
				}
			})
	})
function s3() {
	process.env.VSCODE_DEBUG = "true"
	let o = process.env.VSCODE_DEBUG ? "--inspect-brk=9229" : `--inspect=${9229}`
	console.log("will start extension host process with options:", o),
		(JT = n3(ic.join(nv, "extension.js"), [], {
			env: {
				...process.env,
				VSCODE_EXTHOST_WILL_SEND_SOCKET: "1",
				VSCODE_EXTHOST_SOCKET_HOST: "127.0.0.1",
				VSCODE_EXTHOST_SOCKET_PORT: rv.address()?.port?.toString() || "0",
				NODE_OPTIONS: o,
			},
		})),
		JT.on("exit", (e, t) => {
			console.log(`Extension host process exited with code ${e} and signal ${t}`), rv.close()
		})
}
rv.listen(0, "127.0.0.1", () => {
	let o = rv.address()
	o && typeof o != "string" && (console.log(`Server listening on port ${o.port}`), s3())
})
process.on("SIGINT", () => {
	console.log("Cleaning up..."), jm && jm.send(Zg(2)), rv.close(), JT && JT.kill(), process.exit(0)
})
